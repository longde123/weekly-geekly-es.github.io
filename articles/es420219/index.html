<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õ∑Ô∏è üöã üë©‚Äçüíº Descripci√≥n general de las t√©cnicas de implementaci√≥n del juego AI üë©üèΩ‚Äç‚öïÔ∏è ü§ö ü§≤üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 
 Este art√≠culo le presentar√° una amplia gama de conceptos de inteligencia artificial en juegos ("IA de juegos"), para que comprenda qu√© ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Descripci√≥n general de las t√©cnicas de implementaci√≥n del juego AI</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420219/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/726/4db/e7b/7264dbe7b1834f3602b36deddc723163.png" alt="imagen"></div><br><h1>  Introduccion </h1><br>  Este art√≠culo le presentar√° una amplia gama de conceptos de inteligencia artificial en juegos ("IA de juegos"), para que comprenda qu√© herramientas se pueden usar para resolver problemas de IA, c√≥mo funcionan juntas y c√≥mo comenzar a implementarlas en el motor seleccionado. <br><br>  Asumir√© que est√°s familiarizado con los videojuegos, un poco versado en conceptos matem√°ticos como geometr√≠a, trigonometr√≠a, etc.  La mayor√≠a de los ejemplos de c√≥digo se escribir√°n en pseudoc√≥digo, por lo que no necesita saber un idioma espec√≠fico. <br><br><h1>  ¬øQu√© es <i>una</i> "IA de juegos"? </h1><br>  Game AI se ocupa principalmente de la selecci√≥n de acciones de una entidad en funci√≥n de las condiciones actuales.  En la literatura tradicional sobre IA, se denomina gesti√≥n de " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">agentes inteligentes</a> ".  El agente suele ser un personaje en el juego, pero puede ser una m√°quina, un robot o incluso algo m√°s abstracto: un grupo completo de entidades, un pa√≠s o una civilizaci√≥n.  En cualquier caso, es un objeto que monitorea su entorno, toma decisiones basadas en √©l y act√∫a de acuerdo con estas decisiones.  Esto a veces se llama ciclo de percepci√≥n-pensamiento-acci√≥n (Sentido / Pensar / Actuar): <br><br><ul><li>  Percepci√≥n: el agente reconoce, o se le informa al respecto, informaci√≥n sobre el medio ambiente que puede afectar su comportamiento (por ejemplo, peligros cercanos, elementos recolectados, puntos importantes, etc.) </li><li>  Pensamiento: el agente decide c√≥mo responder (por ejemplo, decide si es seguro recolectar objetos, si deber√≠a pelear o mejor esconderse primero) </li><li>  Acci√≥n: el agente realiza acciones para implementar sus decisiones (por ejemplo, comienza a moverse a lo largo de la ruta hacia el enemigo o hacia el sujeto, etc.) </li><li>  ... luego, debido a las acciones de los personajes, la situaci√≥n cambia, por lo que el ciclo debe repetirse con nuevos datos. </li></ul><a name="habracut"></a><br>  Las tareas de IA del mundo real, especialmente las que son relevantes hoy en d√≠a, generalmente se centran en la "percepci√≥n".  Por ejemplo, los veh√≠culos no tripulados deben recibir im√°genes de la carretera frente a ellos, combin√°ndolos con otros datos (radar y lidar) e intentando interpretar lo que ven.  Por lo general, esta tarea se resuelve mediante el aprendizaje autom√°tico, que funciona especialmente bien con grandes conjuntos de datos ruidosos del mundo real (por ejemplo, con fotos de la carretera frente al autom√≥vil o unos pocos cuadros de video) y les da algo de significado, extrayendo informaci√≥n sem√°ntica, por ejemplo, ‚Äúhay 20 yardas frente a m√≠ otro coche ".  Tales tareas se llaman <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">problemas de clasificaci√≥n</a> . <br><br>  Los juegos son inusuales ya que no necesitan un sistema complejo para extraer esta informaci√≥n, ya que es una parte integral de la simulaci√≥n.  No hay necesidad de realizar algoritmos de reconocimiento de im√°genes para detectar al enemigo frente a ti;  el juego <i>sabe</i> que hay un enemigo y puede transmitir esta informaci√≥n directamente al proceso de toma de decisiones.  Por lo tanto, la "percepci√≥n" en este ciclo generalmente se simplifica enormemente, y toda la complejidad surge en la implementaci√≥n del "pensamiento" y la "acci√≥n". <br><br><h1>  Limitaciones de desarrollo de IA de juego </h1><br>  Gaming AI generalmente tiene en cuenta las siguientes restricciones: <br><br><ul><li>  A diferencia del algoritmo de aprendizaje autom√°tico, generalmente no se entrena por adelantado;  al desarrollar un juego, no es pr√°ctico escribir una red neuronal para monitorear a decenas de miles de jugadores para encontrar la mejor manera de jugar contra ellos, porque el juego a√∫n no se ha lanzado y no tiene jugadores. </li><li>  Por lo general, se supone que el juego debe entretener y desafiar al jugador, y no ser "√≥ptimo"; por lo tanto, incluso si puede entrenar agentes para resistir a los jugadores de la mejor manera, la mayor√≠a de las veces los dise√±adores necesitan algo diferente de ellos. </li><li>  A menudo se requiere que los agentes tengan un comportamiento "realista" para que los jugadores sientan que est√°n compitiendo con oponentes similares a los humanos.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">El programa AlphaGo</a> result√≥ ser mucho mejor que las personas, pero los movimientos que elige est√°n tan lejos de la comprensi√≥n tradicional del juego que los oponentes experimentados hablaron de √©l como un juego contra un extraterrestre.  Si el juego pretende ser un oponente humano, entonces esto generalmente no es deseable, por lo que el algoritmo debe configurarse para que tome decisiones <i>plausibles</i> , no <i>ideales</i> . </li><li>  La IA debe ejecutarse en tiempo real.  En este contexto, esto significa que el algoritmo no puede, por decisi√≥n, monopolizar los recursos del procesador durante mucho tiempo.  Incluso 10 milisegundos para tomar una decisi√≥n es demasiado, porque la mayor√≠a de los juegos tienen solo 16-33 milisegundos para completar todas las operaciones para el siguiente cuadro del gr√°fico. </li><li>  Idealmente, al menos parte del sistema deber√≠a depender de los datos, y no estar codificado para que los no programadores puedan hacer cambios m√°s r√°pido. </li></ul><br>  Despu√©s de haber aprendido todo esto, podemos comenzar a considerar enfoques extremadamente simples para la creaci√≥n de IA, que implementan todo el ciclo de "percepci√≥n-pensamiento-acci√≥n" de manera que garantice la eficiencia y permita a los dise√±adores de juegos elegir comportamientos complejos similares a las acciones humanas. <br><br><h1>  F√°cil toma de decisiones </h1><br>  Comencemos con un juego muy simple, como Pong.  La tarea del jugador es mover la "raqueta" para que la pelota rebote, en lugar de pasar volando.  Las reglas son similares al tenis: pierdes si pierdes la pelota.  La IA tiene una tarea relativamente simple de tomar decisiones sobre la elecci√≥n de la direcci√≥n del movimiento de la raqueta. <br><br><h2>  Construcciones condicionales codificadas </h2><br>  Si quisi√©ramos escribir AI para controlar la raqueta, entonces hay una soluci√≥n intuitiva y simple: simplemente mueva constantemente la raqueta para que quede debajo de la pelota.  Cuando la pelota llega a la raqueta, ya est√° en posici√≥n perfecta y puede golpearla. <br><br>  Un algoritmo simple para esto, expresado en pseudoc√≥digo, podr√≠a ser: <br><br><pre>  en cada cuadro / actualizaci√≥n mientras se ejecuta el juego:<font></font>
<font></font>
 si la pelota est√° a la izquierda de la raqueta:<font></font>
<font></font>
	 mueve la raqueta hacia la izquierda<font></font>
<font></font>
 de lo contrario si la pelota est√° a la derecha de la raqueta:<font></font>
<font></font>
	 mueve la raqueta hacia la derecha </pre><br>  Si suponemos que la raqueta puede moverse a no menos velocidad que la pelota, entonces este ser√° el algoritmo perfecto para el jugador de IA en Pong.  En los casos en que no haya tantos datos de "percepci√≥n" para el procesamiento y pocas acciones que el agente pueda realizar, no necesitamos nada m√°s complicado. <br><br>  Este enfoque es tan simple que apenas muestra el ciclo completo de "percepci√≥n-pensamiento-acci√≥n".  Pero el <i>es</i> . <br><br><ul><li>  Las percepciones son dos si las declaraciones.  El juego sabe d√≥nde est√°n la pelota y la raqueta.  Por lo tanto, la IA pregunta al juego por su posici√≥n, por lo tanto, "siente" si la pelota est√° a la izquierda o a la derecha. </li><li>  El pensamiento tambi√©n est√° integrado en dos declaraciones if.  Contienen dos soluciones, que en este caso son mutuamente excluyentes, lo que lleva a la elecci√≥n de una de tres acciones: mover la raqueta hacia la izquierda, moverla hacia la derecha o no hacer nada si la raqueta ya est√° ubicada correctamente. </li><li>  Una "acci√≥n" es "mover la raqueta hacia la izquierda" o "mover la raqueta hacia la derecha".  Dependiendo de c√≥mo se implemente el juego, esto puede tomar la forma de mover instant√°neamente la posici√≥n de la raqueta o establecer la velocidad y la direcci√≥n de la raqueta para que pueda cambiarse correctamente en otro c√≥digo del juego. </li></ul><br>  Tales enfoques a menudo se denominan "reactivos" porque hay un conjunto simple de reglas (en nuestro caso, estas son declaraciones "si" en el c√≥digo) que responden al estado del mundo y deciden instant√°neamente c√≥mo proceder. <br><br><h2>  √Årboles de decisi√≥n </h2><br>  Este ejemplo de Pong es en realidad similar al concepto formal de IA llamado el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√°rbol de decisi√≥n</a> .  Este es un sistema en el que las decisiones se organizan en forma de √°rbol y el algoritmo debe rodearse para llegar a una "hoja" que contenga la decisi√≥n final sobre la acci√≥n elegida.  Dibujemos una representaci√≥n gr√°fica del √°rbol de decisi√≥n para el algoritmo de raqueta Pong usando un diagrama de flujo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34e/4a2/17e/34e4a217e703a6af9b51b5cfbec7370f.png"></div><br>  Se puede ver que se parece a un √°rbol, ¬°solo al rev√©s! <br><br>  Cada parte del √°rbol de decisi√≥n generalmente se denomina "nodo" porque en AI, la teor√≠a de grafos se usa para describir tales estructuras.  Cada nodo puede ser uno de dos tipos: <br><br><ol><li>  Nodos de soluciones: la elecci√≥n de dos alternativas basadas en la verificaci√≥n de una condici√≥n.  Cada alternativa se presenta como su propio nodo; </li><li>  Nodos finales: una acci√≥n realizada que representa la decisi√≥n final tomada por el √°rbol. </li></ol><br>  El algoritmo comienza desde el primer nodo asignado por la "ra√≠z" del √°rbol, despu√©s de lo cual decide a qu√© nodo secundario ir en funci√≥n de la condici√≥n o realiza la acci√≥n almacenada en el nodo, y luego deja de funcionar. <br><br>  A primera vista, la ventaja del √°rbol de decisi√≥n no es obvia, ya que hace exactamente el mismo trabajo que las declaraciones if de la secci√≥n anterior.  Pero hay un sistema muy general en el que cada soluci√≥n tiene exactamente 1 condici√≥n y 2 resultados posibles, lo que le permite al desarrollador construir AI a partir de los datos que representan las soluciones en el √°rbol, y evita escribirlo en el c√≥digo.  Es f√°cil imaginar un formato de datos simple para describir dicho √°rbol: <br><br><table><tbody><tr><td>  <b>N√∫mero de nodo</b> </td><td>  <b>Decisi√≥n (o "fin")</b> </td><td>  <b>Acci√≥n</b> </td><td>  <b>Acci√≥n</b> </td></tr><tr><td>  1 </td><td>  ¬øLa pelota a la izquierda de la raqueta? </td><td>  ¬øEh?  Comprobar nodo 2 </td><td>  No?  Comprobar nodo 3 </td></tr><tr><td>  2 </td><td>  <i>El final</i> </td><td colspan="2">  Mueve la raqueta hacia la izquierda </td></tr><tr><td>  3 </td><td>  ¬øLa pelota a la derecha de la raqueta? </td><td>  ¬øEh?  Ir al nodo 4 </td><td>  No?  Ir al nodo 5 </td></tr><tr><td>  4 4 </td><td>  <i>El final</i> </td><td colspan="2">  Mueve la raqueta hacia la derecha </td></tr><tr><td>  5 5 </td><td>  <i>El final</i> </td><td colspan="2">  No hacer nada </td></tr></tbody></table><br>  Desde el punto de vista del c√≥digo, necesitamos forzar al sistema a leer cada una de estas filas, crear para cada nodo, adjuntar la l√≥gica de decisi√≥n basada en la segunda columna y adjuntar nodos secundarios basados ‚Äã‚Äãen la tercera y cuarta columna.  Todav√≠a necesitamos definir manualmente las condiciones y acciones, pero ahora podemos imaginar un juego m√°s complejo en el que puede agregar nuevas soluciones y acciones, as√≠ como configurar toda la IA cambiando el √∫nico archivo de texto que contiene la definici√≥n del √°rbol.  Podemos transferir el archivo al dise√±ador del juego, que podr√° personalizar el comportamiento sin la necesidad de volver a compilar el juego y cambiar el c√≥digo, siempre que el c√≥digo ya tenga condiciones y acciones √∫tiles. <br><br>  Los √°rboles de decisi√≥n pueden ser muy potentes cuando se construyen autom√°ticamente en funci√≥n de una gran cantidad de ejemplos (por ejemplo, utilizando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el algoritmo ID3</a> ).  Los convierte en una herramienta efectiva y de alto rendimiento para clasificar la situaci√≥n en funci√≥n de los datos entrantes, pero este tema est√° m√°s all√° del alcance de los dise√±adores para crear sistemas simples para seleccionar acciones para los agentes. <br><br><h2>  Scripting </h2><br>  Arriba, examinamos un sistema de √°rbol de decisi√≥n que usa condiciones y acciones pre-creadas.  El desarrollador de IA puede reconstruir el √°rbol de cualquier forma que necesite, pero debe confiar en el hecho de que el programador ya ha creado todas las condiciones y acciones necesarias para √©l.  Pero, ¬øqu√© pasa si le damos al dise√±ador herramientas m√°s poderosas que le permiten crear sus propias condiciones y quiz√°s sus acciones? <br><br>  Por ejemplo, en lugar de obligar al codificador a escribir las condiciones "¬øBola a la izquierda de la raqueta?"  y "¬øLa pelota a la derecha de la raqueta?", simplemente puede crear un sistema en el que el dise√±ador escriba independientemente las condiciones para verificar estos valores.  Como resultado, los datos del √°rbol de decisi√≥n pueden verse as√≠: <br><br><table><tbody><tr><td>  <b>N√∫mero de nodo</b> </td><td>  <b>Decisi√≥n (o "fin")</b> </td><td>  <b>Soluci√≥n</b> </td><td>  <b>Acci√≥n</b> </td></tr><tr><td>  1 </td><td>  <b>ball.position.x &lt;paddle.position.x</b> </td><td>  ¬øEh?  Comprobar nodo 2 </td><td>  No?  Comprobar nodo 3 </td></tr><tr><td>  2 </td><td>  <i>El final</i> </td><td colspan="2">  Mueve la raqueta hacia la izquierda </td></tr><tr><td>  3 </td><td>  <b>ball.position.x&gt; paddle.position.x</b> </td><td>  ¬øEh?  Comprobar nodo 4 </td><td>  No?  Comprobar nodo 5 </td></tr><tr><td>  4 4 </td><td>  <i>El final</i> </td><td colspan="2">  Mueve la raqueta hacia la derecha </td></tr><tr><td>  5 5 </td><td>  <i>El final</i> </td><td colspan="2">  No hacer nada </td></tr></tbody></table><br>  Lo mismo que antes, pero ahora las soluciones tienen su propio c√≥digo, similar a la parte condicional de la declaraci√≥n if.  El c√≥digo leer√° los nodos de decisi√≥n de la segunda columna y, en lugar de buscar una condici√≥n espec√≠fica (por ejemplo, ‚Äú¬øla pelota a la izquierda de la raqueta?‚Äù), Calcule la expresi√≥n condicional y devuelva verdadero o falso.  Esto se puede implementar incorporando un <i>lenguaje de scripting</i> , como Lua o Angelscript, que permite al desarrollador tomar objetos del juego (por ejemplo, una pelota y una raqueta) y crear variables accesibles desde el script (por ejemplo, ball.position).  Por lo general, es m√°s f√°cil escribir en un lenguaje de secuencias de comandos que en C ++, y no requiere una etapa de compilaci√≥n completa, por lo tanto, es muy adecuado para realizar cambios r√°pidos en la l√≥gica del juego y permite que los miembros del equipo con menos conocimientos t√©cnicos creen funciones del juego sin la intervenci√≥n de un codificador. <br><br>  En el ejemplo anterior, el lenguaje de secuencias de comandos se usa solo para evaluar la expresi√≥n condicional, pero las acciones finales tambi√©n se pueden describir en la secuencia de comandos.  Por ejemplo, estas acciones del tipo "mover la raqueta hacia la derecha" pueden convertirse en una construcci√≥n de script como <code>ball.position.x += 10</code> , es decir, la acci√≥n tambi√©n se establece en el script sin escribir el c√≥digo de funci√≥n MovePaddleRight. <br><br>  Si da otro paso adelante, puede (y esto se hace a menudo) ir a su conclusi√≥n l√≥gica y escribir todo el √°rbol de decisi√≥n en un lenguaje de script, y no como una lista de l√≠neas de datos.  Este ser√° un c√≥digo similar a las construcciones condicionales que se muestran arriba, solo que no est√°n "codificadas"; est√°n en archivos de script externos, es decir, se pueden cambiar sin recompilar todo el programa.  A menudo, incluso es posible modificar el archivo de script durante la ejecuci√≥n del juego, lo que permite a los desarrolladores probar r√°pidamente varios enfoques para la implementaci√≥n de IA. <br><br><h2>  Reacci√≥n a eventos </h2><br>  Los ejemplos que se muestran arriba est√°n destinados a la ejecuci√≥n de un solo cuadro en juegos simples como Pong.  La idea es que continuamente realicen un ciclo de "percepci√≥n-pensamiento-acci√≥n" y contin√∫en actuando sobre la base del √∫ltimo estado del mundo.  Pero en los juegos m√°s complejos, en lugar de la inform√°tica, a menudo es m√°s razonable reaccionar a los "eventos", es decir, a cambios importantes en el entorno del juego. <br><br>  Esto no es particularmente aplicable a Pong, as√≠ que escojamos otro ejemplo.  Imagine un juego de disparos en el que los enemigos est√°n inm√≥viles hasta que encuentran un jugador, despu√©s del cual comienzan a realizar acciones dependiendo de su clase: los luchadores cuerpo a cuerpo pueden apresurarse hacia el jugador, y los francotiradores se mantienen a distancia e intentan apuntar.  En esencia, este es un sistema reactivo simple: "si vemos a un jugador, entonces hacemos algo", pero se puede dividir l√≥gicamente en un evento ("ver a un jugador") y reacci√≥n (seleccionar una respuesta y ejecutarla). <br><br>  Esto nos lleva de vuelta al ciclo de percepci√≥n-pensamiento-acci√≥n.  Es posible que tengamos un fragmento de c√≥digo, que es un c√≥digo de "percepci√≥n", que verifica en cada cuadro si el enemigo ve al jugador.  Si no, entonces no pasa nada.  Pero si √©l ve, esto crea un evento "ver al jugador".  El c√≥digo tendr√° una parte separada, que dice: "cuando ocurre el evento" ver al jugador ", entonces hacemos" xyz ", y" xyz "es cualquier respuesta que queramos para procesar el pensamiento y la acci√≥n.  Para un luchador de personajes, puedes conectar la respuesta de correr y atacar al evento "ver al jugador".  Para el francotirador, conectaremos la funci√≥n de respuesta "ocultar y apuntar" a este evento.  Como en los ejemplos anteriores, podemos crear tales asociaciones en el archivo de datos para que puedan cambiarse r√°pidamente sin reconstruir el motor.  Adem√°s, es posible (y esto se usa a menudo) escribir tales funciones de respuesta en un lenguaje de script para que puedan crear soluciones complejas cuando ocurren eventos. <br><br><h1>  Toma de decisiones mejorada </h1><br>  Aunque los sistemas reactivos simples son muy potentes, hay muchas situaciones en las que no son suficientes.  Algunas veces necesitamos tomar decisiones diferentes basadas en lo que el agente est√° haciendo en este momento, y presentarlo como una condici√≥n es inconveniente.  A veces, simplemente hay demasiadas condiciones para presentarlas efectivamente en forma de √°rbol de decisiones o script.  A veces necesitamos pensar con anticipaci√≥n y evaluar c√≥mo cambiar√° la situaci√≥n antes de decidir el pr√≥ximo movimiento.  Para tales tareas se necesitan soluciones m√°s complejas. <br><br><h2>  M√°quinas de estado </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Una</a> m√°quina de estados finitos (FSM) es una manera de decir en otras palabras que alg√∫n objeto, por ejemplo, uno de nuestros agentes de IA, se encuentra actualmente en uno de varios estados posibles, y que puede pasar de De un estado a otro.  Hay un n√∫mero finito de tales estados, de ah√≠ el nombre.  Un ejemplo del mundo real es el conjunto de sem√°foros, que cambia de rojo a amarillo, luego a verde, y nuevamente.  En diferentes lugares hay diferentes secuencias de luces, pero el principio es el mismo: cada estado significa algo ("estar de pie", "comer", "estar de pie, si es posible", etc.), en un momento dado solo hay un estado, y Las transiciones entre ellas se basan en reglas simples. <br><br>  Esto se aplica bien a los NPC en los juegos.  El guardia puede tener los siguientes estados claramente separados: <br><br><ul><li>  Patrulla </li><li>  Asalto </li><li>  Vuelo </li></ul><br>  Y podemos llegar a las siguientes reglas para la transici√≥n entre estados: <br><br><ul><li>  Si el guardia ve al enemigo, ataca </li><li>  Si el guardia ataca, pero ya no ve al enemigo, vuelve a patrullar. </li><li>  Si un guardia ataca pero resulta gravemente herido, escapa </li></ul><br>  Este esquema es bastante simple y podemos escribirlo con operadores "si" estrictamente definidos y una variable en la que se almacenar√° el estado del guardia de seguridad y varios controles: la presencia de enemigos cercanos, el nivel de salud del guardia de seguridad, etc.  Pero imagine que necesitamos agregar algunos estados m√°s: <br><br><ul><li>  Esperando (entre patrullas) </li><li>  Buscar (cuando el enemigo visto anteriormente se escondi√≥) </li><li>  Escape en busca de ayuda (cuando se ve al enemigo, pero es demasiado fuerte para luchar solo con √©l) </li></ul><br>  Y las opciones disponibles en cada estado generalmente son limitadas; por ejemplo, un guardia probablemente no querr√° buscar a un enemigo que se haya perdido de vista si su salud es demasiado baja. <br><br>  Tarde o temprano, la larga lista de "si &lt;x e y pero no z&gt; entonces &lt;p&gt;" se vuelve demasiado inc√≥moda, y un enfoque formal para la implementaci√≥n de estados y transiciones entre ellos puede ayudar aqu√≠.  Para hacer esto, consideramos todos los estados y en cada estado enumeramos todas las transiciones a otros estados junto con las condiciones necesarias para ellos.  Tambi√©n debemos indicar el estado inicial para que sepamos por d√≥nde empezar antes de aplicar otras condiciones. <br><br><table><tbody><tr><td>  <b>Condici√≥n</b> </td><td>  <b>Condici√≥n de transici√≥n</b> </td><td>  <b>Nueva condici√≥n</b> </td></tr><tr><td rowspan="4">  Esperando </td><td>  esperado por 10 segundos </td><td>  Patrulla </td></tr><tr><td>  el enemigo es visible y el enemigo es demasiado fuerte </td><td>  B√∫squeda de ayuda </td></tr><tr><td>  el enemigo es visible y mucha salud </td><td>  Asalto </td></tr><tr><td>  el enemigo es visible y poca salud </td><td>  Vuelo </td></tr><tr><td rowspan="4">  Patrulla </td><td>  ruta de patrulla completada </td><td>  Esperando </td></tr><tr><td>  el enemigo es visible y el enemigo es demasiado fuerte </td><td>  B√∫squeda de ayuda </td></tr><tr><td>  el enemigo es visible y mucha salud </td><td>  Asalto </td></tr><tr><td>  el enemigo es visible y poca salud </td><td>  Vuelo </td></tr><tr><td rowspan="2">  Asalto </td><td>  el enemigo no es visible </td><td>  Esperando </td></tr><tr><td>  poca salud </td><td>  Vuelo </td></tr><tr><td>  Vuelo </td><td>  el enemigo no es visible </td><td>  Esperando </td></tr><tr><td rowspan="4">  Buscar </td><td>  buscado por 10 segundos </td><td>  Esperando </td></tr><tr><td>  el enemigo es visible y el enemigo es demasiado fuerte </td><td>  B√∫squeda de ayuda </td></tr><tr><td>  el enemigo es visible y mucha salud </td><td>  Asalto </td></tr><tr><td>  el enemigo es visible y poca salud </td><td>  Vuelo </td></tr><tr><td>  B√∫squeda de ayuda </td><td>  amigo ve </td><td>  Asalto </td></tr><tr><td colspan="3">  <i>Estado inicial: esperando</i> </td></tr></tbody></table><br>  Tal esquema se llama tabla de transici√≥n de estado.  Es una forma compleja (y poco atractiva) de representar una nave espacial.  A partir de estos datos, tambi√©n puede dibujar un diagrama y obtener una representaci√≥n gr√°fica compleja de c√≥mo podr√≠a ser el comportamiento de los NPC. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee0/a7b/262/ee0a7b2621204b58f17703a71b78ed67.png"></div><br>  Captura la esencia misma de tomar decisiones para el agente en funci√≥n de la situaci√≥n en la que se encuentra.  Cada flecha indica una transici√≥n entre estados si la condici√≥n al lado de la flecha es verdadera. <br><br>  Con cada actualizaci√≥n (o "ciclo"), verificamos el estado actual del agente, miramos la lista de transiciones y, si se cumple la condici√≥n de transici√≥n, pasamos a un nuevo estado.  El estado Pendiente verifica en cada cuadro o ciclo si el temporizador de 10 segundos ha expirado.  Si caduca, comienza la transici√≥n al estado "Patrulla".  De manera similar, el estado "Ataque" verifica si el agente tiene mucha salud y, de ser as√≠, realiza la transici√≥n al estado "Vuelo". <br><br>  As√≠ es como se manejan las transiciones de estado, pero ¬øqu√© pasa con los comportamientos asociados con los propios estados?  Desde el punto de vista de realizar las acciones en s√≠ para un estado, generalmente hay dos tipos de acciones adjuntas a una nave espacial: <br><br><ol><li>  Las acciones para el estado actual se realizan peri√≥dicamente, por ejemplo, en cada cuadro o "ciclo". </li><li>  Las acciones se realizan durante la transici√≥n de un estado a otro. </li></ol><br><br>  Un ejemplo del primer tipo: el estado de "Patrulla" en cada cuadro o ciclo contin√∫a moviendo al agente a lo largo de la ruta de patrulla.  El estado de "Ataque" en cada cuadro o ciclo intenta lanzar un ataque o moverlo a una posici√≥n desde donde sea posible.  Y as√≠ sucesivamente. <br><br>  Un ejemplo del segundo tipo: considere la transici√≥n "si el enemigo es visible y el enemigo es demasiado fuerte ‚Üí Busque ayuda".  El agente debe elegir d√≥nde moverse para buscar ayuda y almacenar esta informaci√≥n para que el estado de "B√∫squeda de ayuda" sepa a d√≥nde ir.  De manera similar, en el estado "B√∫squeda de ayuda", cuando se encuentra ayuda, el agente vuelve al estado "Ataque" nuevamente, pero en este momento quiere informar al personaje amigo sobre la amenaza, por lo que puede haber una acci√≥n "decirle a un amigo sobre el peligro" realizada durante esta transici√≥n. <br><br>  Y aqu√≠ podemos considerar nuevamente este sistema desde el punto de vista de "percepci√≥n-pensamiento-acci√≥n".  La percepci√≥n est√° incrustada en los datos utilizados por la l√≥gica de transici√≥n.  El pensamiento est√° integrado en las transiciones disponibles para cada estado.  Y la acci√≥n se realiza mediante acciones realizadas peri√≥dicamente en un estado o durante la transici√≥n entre estados. <br><br>  Este sistema simple funciona bien, aunque a veces las condiciones de transici√≥n de sondeo constante pueden ser un proceso costoso.  Por ejemplo, si cada agente necesita realizar c√°lculos complejos en cada cuadro para determinar la visibilidad de los enemigos y decidir la transici√≥n de la patrulla al ataque, esto puede llevar mucho tiempo de procesador.  Como vimos anteriormente, es posible percibir cambios importantes en el estado del mundo como "eventos" que se procesan despu√©s de que ocurrieron.  Por lo tanto, en lugar de verificar expl√≠citamente la condici√≥n de transici√≥n "¬ømi agente puede ver al jugador?" En cada cuadro, podemos crear un sistema de visibilidad separado que realice estas comprobaciones con menos frecuencia (por ejemplo, 5 veces por segundo) y cree el "jugador ver "cuando se activa la prueba.  Se transmite a la m√°quina de estado, que ahora tiene la condici√≥n para la transici√≥n "Recibi√≥ el evento" jugador que ve "", y que responde en consecuencia.  El comportamiento resultante ser√° similar, con la excepci√≥n de un retraso de reacci√≥n apenas notable (e incluso realismo creciente), pero la productividad aumentar√° debido a la transferencia de "percepci√≥n" a una parte separada del programa. <br><br><h2>  M√°quinas de estado jer√°rquico </h2><br>  Todo esto es bueno, pero con m√°quinas de estado grandes resulta muy inconveniente trabajar.  Si queremos expandir el estado de "Ataque" reemplaz√°ndolo con estados separados de "Ataque cuerpo a cuerpo" y "Ataque desde lejos", entonces tendremos que cambiar las transiciones entrantes de cada estado, presente y futuro, que necesita la capacidad de cambiar al estado de "Ataque". <br><br>  Probablemente tambi√©n haya notado que en nuestro ejemplo hay muchas transiciones duplicadas.  La mayor√≠a de las transiciones en el estado "Pendiente" son id√©nticas a las transiciones en el estado "Patrulla", y ser√≠a bueno evitar la duplicaci√≥n de este trabajo, especialmente si queremos agregar a√∫n m√°s estados similares.  Ser√° l√≥gico combinar "Esperando" y "Patrullar" en alg√∫n grupo de "Estados que no sean de combate", que solo tiene un conjunto com√∫n de transiciones para combatir estados.  Si presentamos a este grupo como un estado, podemos considerar la "espera" y el "patrullaje" como "subestados" de este estado, lo que nos permitir√° describir de manera m√°s efectiva todo el sistema.  Un ejemplo de uso de una tabla de conversi√≥n separada para un nuevo subestado que no es de combate: <br><br>  <b><i>Las principales condiciones:</i></b> <br><br><table><tbody><tr><td>  <b>Condici√≥n</b> </td><td>  <b>Condici√≥n de transici√≥n</b> </td><td>  <b>Nueva condici√≥n</b> </td></tr><tr><td rowspan="3">  No combate </td><td>  el enemigo es visible y el enemigo es demasiado fuerte </td><td>  B√∫squeda de ayuda </td></tr><tr><td>  el enemigo es visible y mucha salud </td><td>  Asalto </td></tr><tr><td>  el enemigo es visible y poca salud </td><td>  Vuelo </td></tr><tr><td rowspan="2">  Asalto </td><td>  el enemigo no es visible </td><td>  No combate </td></tr><tr><td>  poca salud </td><td>  Vuelo </td></tr><tr><td>  Vuelo </td><td>  el enemigo no es visible </td><td>  No combate </td></tr><tr><td rowspan="4">  Buscar </td><td>  buscado por 10 segundos </td><td>  No combate </td></tr><tr><td>  el enemigo es visible y el enemigo es demasiado fuerte </td><td>  B√∫squeda de ayuda </td></tr><tr><td>  el enemigo es visible y mucha salud </td><td>  Asalto </td></tr><tr><td>  el enemigo es visible y poca salud </td><td>  Vuelo </td></tr><tr><td>  B√∫squeda de ayuda </td><td>  amigo ve </td><td>  Asalto </td></tr><tr><td colspan="3">  <i>Estado inicial: no combate</i> </td></tr></tbody></table><br>  <b><i>Estado sin combate:</i></b> <br><br><table><tbody><tr><td>  <b>Condici√≥n</b> </td><td>  <b>Condici√≥n de transici√≥n</b> <br><br></td><td>  <b>Nueva condici√≥n</b> <br><br></td></tr><tr><td>  Esperando </td><td>  esperado por 10 segundos </td><td>  Patrulla </td></tr><tr><td>  Patrulla </td><td>  completado la ruta de patrulla </td><td>  Esperando </td></tr><tr><td colspan="3">  <i>Estado inicial: esperando</i> </td></tr></tbody></table><br>  Y en forma de gr√°fico: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/240/7a0/21f/2407a021fd5e60c214d79069b86148d4.png"></div><br>  De hecho, este es el mismo sistema, solo que ahora hay un estado sin combate que reemplaza a "Patrulla" y "Espera", que en s√≠ mismo es una m√°quina de estado con dos subestados de patrullaje y espera.  Si cada estado puede contener potencialmente una m√°quina de estados de subestados (y estos subestados tambi√©n pueden contener su propia m√°quina de estados, etc.), entonces tenemos una m√°quina de estados jer√°rquica (HFSM).  Al agrupar los comportamientos que no son de combate, cortamos un mont√≥n de transiciones innecesarias, y podemos hacer lo mismo para cualquier estado nuevo que pueda tener transiciones comunes.  Por ejemplo, si en el futuro expandimos el estado de "Ataque" a los estados de "Ataque cuerpo a cuerpo" y "Ataque de proyectil", pueden ser subestados, cuya transici√≥n se basa en la distancia al enemigo y la presencia de municiones, que tienen transiciones de salida comunes basadas en niveles de salud y otras cosas  Por lo tanto, con un m√≠nimo de transiciones duplicadas, se pueden representar comportamientos y subcomportamientos complejos. <br><br><h2>  √Årboles de comportamiento </h2><br>  Con HFSM, tenemos la capacidad de crear conjuntos de comportamientos bastante complejos de una manera bastante intuitiva.  Sin embargo, se nota de inmediato que la toma de decisiones en forma de reglas de transici√≥n est√° estrechamente relacionada con el estado actual.  Muchos juegos requieren solo eso.  Y el uso cuidadoso de la jerarqu√≠a de estado reduce el n√∫mero de transiciones duplicadas.  Pero a veces necesitamos reglas que se apliquen independientemente del estado actual, o que se apliquen en casi todos los estados.  Por ejemplo, si la salud del agente se ha reducido al 25%, es posible que quiera huir, independientemente de si est√° en batalla, o est√° esperando, hablando, o est√° en cualquier otro estado.  No queremos recordar que necesitamos agregar esta condici√≥n a cada estado que podamos agregar al personaje en el futuro.  Entonces, cuando el dise√±ador m√°s tarde dice que quiere cambiar el valor del umbral del 25% al ‚Äã‚Äã10%, no tendr√≠amos que clasificar y cambiar cada transici√≥n correspondiente. <br><br>  Lo ideal en tal situaci√≥n era un sistema en el que las decisiones sobre en qu√© estado estar existieran por separado de los estados mismos, de modo que podamos cambiar solo un elemento, y las transiciones a√∫n se procesen correctamente.  Aqu√≠ es donde los √°rboles de comportamiento son √∫tiles. <br><br>  Hay varias formas de implementar √°rboles de comportamiento, pero la esencia es la misma para la mayor√≠a y muy similar al √°rbol de decisi√≥n mencionado anteriormente: el algoritmo comienza a funcionar desde el "nodo ra√≠z", y hay nodos en el √°rbol que indican decisiones o acciones.  Sin embargo, hay diferencias clave: <br><br><ul><li>  Los nodos ahora devuelven uno de los tres valores: "exitoso" (si el trabajo se complet√≥), "sin √©xito" (si el trabajo no se complet√≥) o "realizado" (si el trabajo todav√≠a se est√° completando y no tuvo √©xito o no fue completamente exitoso). </li><li>  Ahora no tenemos nodos de decisi√≥n en los que elegimos entre dos alternativas, pero hay nodos decoradores con un solo nodo hijo.  Si tienen "√©xito", ejecutan su √∫nico nodo hijo.  Los nodos decoradores a menudo contienen condiciones que determinan si la ejecuci√≥n finaliz√≥ con √©xito (lo que significa que debe ejecutar su sub√°rbol) o falla (entonces no es necesario hacer nada).  Tambi√©n pueden regresar "en progreso". </li><li>  Las acciones que realizan los nodos devuelven un valor de "ejecuci√≥n" para indicar lo que est√° sucediendo. </li></ul><br>  Se puede combinar un peque√±o conjunto de nodos, creando una gran cantidad de comportamientos complejos, y a menudo este esquema es muy breve.  Por ejemplo, podemos reescribir la CA jer√°rquica de la guardia del ejemplo anterior en forma de √°rbol de comportamiento: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b9/0f2/d18/9b90f2d18ce7b78b8a9a0673b8cde3d2.png"></div><br>  Cuando se usa esta estructura, no hay necesidad de una transici√≥n expl√≠cita de los estados de "Espera" o "Patrulla" a los estados de "Ataque" o cualquier otro: si el √°rbol se atraviesa de arriba a abajo y de izquierda a derecha, la decisi√≥n correcta se toma en funci√≥n de la situaci√≥n actual.  Si el enemigo es visible y el personaje tiene poca salud, entonces el √°rbol completar√° la carrera en el nodo "Vuelo", independientemente del nodo completado anteriormente ("Patrulla", "Esperando", "Ataque", etc.). <br><br>  Puede notar que todav√≠a no tenemos una transici√≥n para regresar al estado "En espera" de "Patrulla", y aqu√≠ los decoradores incondicionales ser√°n √∫tiles.  El nodo decorador est√°ndar es "Repetir": no tiene condiciones, solo intercepta el nodo secundario que regresa "exitosamente" y ejecuta el nodo secundario nuevamente, regresando "ejecutado".  El nuevo √°rbol se ve as√≠: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/187/487/d73/187487d733f1db9e07920b0475894bb4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los √°rboles de comportamiento son bastante complejos porque a menudo hay muchas formas diferentes de crear un √°rbol, y encontrar la combinaci√≥n correcta de decorador y nodos componentes puede ser una tarea desalentadora. Tambi√©n hay problemas con la frecuencia con la que necesitamos verificar el √°rbol (¬øqueremos atravesarlo cada cuadro o cuando sucede algo que puede afectar las condiciones?) Y c√≥mo almacenar el estado en relaci√≥n con los nodos (¬øc√≥mo sabemos que esperamos 10 segundos? ¬øC√≥mo ¬ødescubriremos cu√°ntos nodos se ejecutaron por √∫ltima vez para completar correctamente la secuencia?) Por lo tanto, hay muchas implementaciones diferentes. Por ejemplo, en algunos sistemas, como el sistema de √°rbol de comportamiento Unreal Engine 4, los nodos decoradores se reemplazan con decoradores de cadenas que verifican el √°rbol solo cuando cambian las condiciones del decorador y proporcionan "servicios",que se puede conectar a nodos y proporcionar actualizaciones peri√≥dicas incluso cuando el √°rbol no se vuelve a comprobar. Los √°rboles de comportamiento son herramientas poderosas, pero aprender a usarlos correctamente, especialmente con tantas implementaciones diferentes, puede ser una tarea desalentadora.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sistemas Basados ‚Äã‚Äãen Utilidades </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algunos juegos requieren la existencia de muchas acciones diferentes, por lo que requieren reglas de transici√≥n m√°s simples y centralizadas, pero no necesitan el poder para implementar completamente el √°rbol de comportamiento. </font><font style="vertical-align: inherit;">En lugar de crear un conjunto expl√≠cito de opciones o un √°rbol de acciones potenciales con posiciones de respaldo impl√≠citas definidas por la estructura del √°rbol, ¬øtal vez sea mejor simplemente examinar todas las acciones y elegir la que sea m√°s aplicable en este momento? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto es lo que hacen los sistemas basados ‚Äã‚Äãen la utilidad: estos son sistemas en los que el agente tiene muchas acciones a su disposici√≥n y elige realizar una en funci√≥n de la </font><i><font style="vertical-align: inherit;">utilidad</font></i><font style="vertical-align: inherit;"> relativa</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cada acci√≥n La utilidad aqu√≠ es una medida arbitraria de importancia o conveniencia para que un agente realice esta acci√≥n. Al escribir funciones de utilidad para calcular la utilidad de una acci√≥n en funci√≥n del estado actual del agente y su entorno, el agente puede verificar los valores de la utilidad y seleccionar el estado m√°s apropiado en este momento.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto tambi√©n es muy parecido a una m√°quina de estados finitos, excepto que las transiciones est√°n determinadas por una evaluaci√≥n de cada estado potencial, incluido el actual. Vale la pena se√±alar que en el caso general, elegimos la transici√≥n a la acci√≥n m√°s valiosa (o estar en ella si ya estamos realizando esta acci√≥n), pero para una mayor variabilidad puede ser una elecci√≥n aleatoria ponderada (dando prioridad a la acci√≥n m√°s valiosa, pero permitiendo la elecci√≥n de otros) , una opci√≥n de acci√≥n aleatoria entre los cinco primeros (o cualquier otra cantidad), etc.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El sistema est√°ndar basado en la utilidad asigna un cierto rango arbitrario de valores de utilidad, digamos de 0 (completamente indeseable) a 100 (absolutamente deseable), y cada acci√≥n puede tener un conjunto de factores que influyen en la forma en que se calcula el valor. </font><font style="vertical-align: inherit;">Volviendo a nuestro ejemplo con el guardia, uno puede imaginar algo como esto:</font></font><br><br><table><tbody><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acci√≥n</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√°lculo de utilidad</font></font></b> <br><br></td></tr><tr><td> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B√∫squeda de ayuda</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si el enemigo es visible y el enemigo es fuerte y la salud es baja, entonces devuelve 100, de lo contrario devuelve 0 </font></font><br><br></td></tr><tr><td> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vuelo</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si el enemigo es visible y hay poca salud, entonces devuelve 90, de lo contrario devuelve 0 </font></font><br></td></tr><tr><td> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asalto</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si el enemigo es visible, devuelve 80 </font></font><br><br></td></tr><tr><td> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esperando</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si estamos en un estado de espera y ya esperamos 10 segundos, regrese 0, de lo contrario 50 </font></font><br><br></td></tr><tr><td> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patrulla</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si estamos al final de la ruta de patrulla, regrese 0, de lo contrario 50 </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uno de los aspectos m√°s importantes de este esquema es que las transiciones entre acciones se expresan impl√≠citamente: desde cualquier estado puede pasar leg√≠timamente a cualquier otro. Adem√°s, las prioridades de acci√≥n est√°n impl√≠citas en los valores de utilidad devueltos. Si el enemigo es visible, y si es fuerte, y el personaje tiene poca salud, los valores distintos de cero devuelven </font><i><font style="vertical-align: inherit;">B√∫squeda de </font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vuelo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ayuda</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pero la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B√∫squeda de ayuda</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> siempre tiene una calificaci√≥n m√°s alta. Del mismo modo, las acciones que no son de combate nunca devuelven m√°s de 50, por lo que siempre son derrotados por la lucha. Con esto en mente, se crean acciones y sus c√°lculos de utilidad.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En nuestro ejemplo, las acciones devuelven un valor de utilidad constante o uno de los dos valores de utilidad constante. Un sistema m√°s realista utiliza un valor de retorno de un </font><font style="vertical-align: inherit;">rango </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">continuo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de valores. Por ejemplo, la acci√≥n </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Escapada</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> puede devolver valores de utilidad m√°s altos si la salud del agente es m√°s baja, y la acci√≥n de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ataque</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> puede devolver valores de utilidad m√°s bajos si el enemigo es demasiado fuerte. Esto permitir√° que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Getaway</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tenga prioridad sobre </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asalto.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en cualquier situaci√≥n en la que el agente sienta que no est√° lo suficientemente sano como para luchar contra el enemigo. Esto le permite cambiar las prioridades relativas de las acciones sobre la base de cualquier n√∫mero de criterios, lo que puede hacer que este enfoque sea m√°s flexible que un √°rbol de comportamiento o una nave espacial. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada acci√≥n generalmente tiene varias condiciones que influyen en el c√°lculo de la utilidad. Para no poner todo dif√≠cil en el c√≥digo, puede escribirlos en un lenguaje de script o como una serie de f√≥rmulas matem√°ticas, juntas de una manera comprensible. Mucha m√°s informaci√≥n sobre esto se encuentra en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conferencias</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">presentaciones de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dave Mark ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@IADaveMark</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En algunos juegos que intentan simular la vida diaria del personaje, por ejemplo, en Los Sims, se agrega otra capa de c√°lculos en la que el agente tiene "aspiraciones" o "motivaciones" que afectan los valores de utilidad. Por ejemplo, si un personaje tiene la motivaci√≥n del Hambre, entonces puede aumentar con el tiempo, y calcular la utilidad para la acci√≥n Coma devolver√° valores cada vez m√°s altos hasta que el personaje pueda realizar esta acci√≥n, reducir el hambre y la acci√≥n " Eat "se reduce a cero o casi cero valor de utilidad.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La idea de elegir acciones basadas en el sistema de puntos es bastante sencilla, por lo que es obvio que puede usar la toma de decisiones basada en la utilidad en otros procesos de toma de decisiones de IA, y no reemplazarlas completamente con ella. </font><font style="vertical-align: inherit;">El √°rbol de decisi√≥n puede consultar el valor de utilidad de sus dos nodos secundarios y seleccionar el nodo con el valor m√°s alto. </font><font style="vertical-align: inherit;">Del mismo modo, un √°rbol de comportamiento puede tener un nodo de utilidad compuesto que cuenta la utilidad para seleccionar el nodo secundario que se ejecutar√°.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Movimiento y navegaci√≥n </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En nuestros ejemplos anteriores, hab√≠a una raqueta simple, que orden√°bamos mover de izquierda a derecha, o un personaje de guardia, a quien siempre se le ordenaba patrullar o atacar. </font><font style="vertical-align: inherit;">Pero, ¬øc√≥mo controlamos exactamente el movimiento de un agente durante un per√≠odo de tiempo? </font><font style="vertical-align: inherit;">¬øC√≥mo podemos establecer la velocidad, evitar obst√°culos, planificar una ruta cuando es imposible llegar al punto final directamente? </font><font style="vertical-align: inherit;">Ahora consideraremos esta tarea.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Direcci√≥n </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el nivel m√°s simple, a menudo es aconsejable trabajar con cada agente como si tuviera un valor de velocidad que determina la velocidad y la direcci√≥n de su movimiento. Esta velocidad se puede medir en metros por segundo, en millas por hora, en p√≠xeles por segundo, etc. Si recordamos nuestro ciclo "percepci√≥n-pensamiento-acci√≥n", podemos imaginar que "pensar" puede elegir la velocidad, despu√©s de lo cual "acci√≥n" aplica esta velocidad al agente, movi√©ndola alrededor del mundo. Por lo general, en los juegos hay un sistema de f√≠sica que realiza esta tarea de forma independiente, estudia el valor de la velocidad de cada entidad y cambia su posici√≥n en consecuencia. Por lo tanto, a menudo es posible asignar dicho trabajo a este sistema, dejando a la IA solo la tarea de elegir la velocidad del agente.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si sabemos d√≥nde quiere estar el agente, entonces necesitamos usar nuestra velocidad para mover al agente en esta direcci√≥n. </font><font style="vertical-align: inherit;">En una forma trivial, obtenemos la siguiente ecuaci√≥n:</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> deseada_travel = destination_position - agent_position </font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagine un mundo 2D en el que el agente est√° ubicado en las coordenadas (-2, -2), y el punto objetivo est√° aproximadamente en el noreste, en las coordenadas (30, 20), es decir, para llegar all√≠ necesita moverse (32, 22). </font><font style="vertical-align: inherit;">Supongamos que estas posiciones se indican en metros. </font><font style="vertical-align: inherit;">Si decidimos que el agente puede moverse a una velocidad de 5 m / s, reduzca la escala del vector de desplazamiento a este valor y veamos que necesitamos establecer la velocidad aproximadamente (4.12, 2.83). </font><font style="vertical-align: inherit;">Movi√©ndose en funci√≥n de este valor, el agente llegar√° al punto final en poco menos de 8 segundos, como se esperaba.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los c√°lculos se pueden realizar nuevamente en cualquier momento. Por ejemplo, si el agente est√° a medio camino del objetivo, el movimiento deseado ser√° la mitad, pero despu√©s de escalar a la velocidad m√°xima del agente de 5 m / s, la velocidad sigue siendo la misma. Esto tambi√©n funciona para mover objetivos (dentro de lo razonable), lo que le permite al agente hacer peque√±os ajustes en el camino. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, a menudo necesitamos m√°s control. Por ejemplo, es posible que necesitemos aumentar lentamente la velocidad, como si el personaje se detuviera primero, luego avanzara un paso y luego corriera. Por otro lado, es posible que necesitemos reducir la velocidad a medida que se acerca al objetivo. A menudo, tales tareas se resuelven utilizando los llamados " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comportamientos de direcci√≥n"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"tener sus propios nombres como Seek, Flee, Arrival, etc. (en Habr√© hay una serie de art√≠culos sobre ellos: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://habr.com/post/358366/</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .) Su idea es que puede aplicar la velocidad del agente fuerzas de aceleraci√≥n basadas en una comparaci√≥n de la posici√≥n del agente y la velocidad actual de movimiento hacia el objetivo, creando varias formas de moverse hacia el objetivo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada comportamiento tiene su propio prop√≥sito ligeramente diferente. Buscar y llegar se utilizan para mover el agente a su destino. La evitaci√≥n de obst√°culos y la separaci√≥n ayudan al agente a hacer peque√±os movimientos correctivos para sortear peque√±os obst√°culos entre el agente y su destino. La alineaci√≥n y la cohesi√≥n obligan a los agentes a moverse juntos, imitando a los animales del reba√±o. Cualquier variaci√≥n de diferentes comportamientos de direcci√≥n se puede combinar, a menudo en forma de una suma ponderada, para crear un valor total que tenga en cuenta todos estos factores diferentes y cree un √∫nico vector resultante. Por ejemplo, un agente puede usar el comportamiento de Llegada junto con los comportamientos de Separaci√≥n y Evitaci√≥n de Obst√°culos para mantenerse alejado de las paredes y otros agentes. Este enfoque funciona bien en entornos abiertos que no son demasiado complejos y abarrotados.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, en entornos m√°s complejos, simplemente agregar los valores de salida del comportamiento no funciona muy bien: a veces el movimiento cerca del objeto es demasiado lento, o el agente se atasca cuando el comportamiento de Llegada quiere pasar un obst√°culo, y el comportamiento de Evitar obst√°culos empuja al agente hacia el lado del que proviene . Por lo tanto, a veces tiene sentido considerar las variaciones de comportamiento de direcci√≥n que son m√°s complicadas que simplemente sumar todos los valores. Una de las familias de tales enfoques consiste en una implementaci√≥n diferente: no consideramos cada uno de los comportamientos que nos dan direcci√≥n, seguidos de su combinaci√≥n para obtener un consenso (que en s√≠ mismo puede ser inadecuado). En cambio, consideramos el movimiento en varias direcciones diferentes, por ejemplo, en ocho direcciones de la br√∫jula, o en 5-6 puntos delante del agente,despu√©s de lo cual elegimos el mejor.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sin embargo, en entornos complejos con callejones sin salida y opciones de curvas, necesitaremos algo m√°s avanzado, y pasaremos a esto pronto. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Encontrar el camino </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los comportamientos de direcci√≥n son excelentes para un movimiento simple en un √°rea bastante abierta, como un campo de f√∫tbol o arena, donde puedes ir de A a B en l√≠nea recta con peque√±os ajustes para evitar obst√°culos. </font><font style="vertical-align: inherit;">Pero, ¬øqu√© pasa si la ruta al punto final es m√°s complicada? </font><font style="vertical-align: inherit;">Luego necesitamos una "b√∫squeda de caminos": explorar el mundo y trazar un camino a lo largo de √©l para que el agente llegue al punto final.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La forma m√°s sencilla es colocar una cuadr√≠cula en el mundo y, para cada celda al lado del agente, mirar las celdas vecinas a las que podemos movernos. Si uno de ellos es nuestro punto final, entonces regrese la ruta, desde cada celda a la anterior, hasta llegar al principio, obteniendo as√≠ una ruta. De lo contrario, repita el proceso con los vecinos alcanzables de los vecinos anteriores hasta que encontremos el punto final o nos quedemos sin celdas (esto significar√° que no hay ruta). Formalmente, este enfoque se llama </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritmo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Breadth-First Search (BFS), porque en cada paso se ve en todas las direcciones (es decir, "ancho") antes de mover las b√∫squedas. El espacio de b√∫squeda es como un frente de onda que se mueve hasta toparse con el lugar que est√°bamos buscando.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este es un ejemplo simple de una b√∫squeda en acci√≥n. El √°rea de b√∫squeda se expande en cada etapa hasta que se incluye un punto final, despu√©s de lo cual puede seguir el camino hacia el principio.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f12/08e/15f/f1208e15fc83ffa2b7ac3eca652854fc.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado, obtenemos una lista de celdas de cuadr√≠cula, que conforman la ruta que debe seguir. Por lo general, se llama "ruta", ruta (de ah√≠ la "b√∫squeda de rutas", b√∫squeda de ruta), pero tambi√©n puede imaginarlo como un plan, porque es una lista de lugares que debe visitar para lograr su objetivo, es decir, el punto final. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora que conocemos la posici√≥n de cada celda en el mundo, puede usar los comportamientos de direcci√≥n descritos anteriormente para moverse a lo largo de la ruta: primero del nodo inicial al nodo 2, luego del nodo 2 al nodo 3, y as√≠ sucesivamente. El enfoque m√°s simple es moverse hacia el centro de la siguiente celda, pero tambi√©n hay una alternativa popular: moverse hacia el centro de la costilla entre la celda actual y la siguiente. Esto le permite al agente cortar esquinas de curvas cerradas para crear un movimiento m√°s realista.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como puede ver, este algoritmo puede desperdiciar recursos porque examina tantas celdas en la direcci√≥n "incorrecta" como en la "correcta". Adem√°s, no permite tener en cuenta los costos de movimiento, en el que algunas celdas pueden ser "m√°s caras" que otras. Aqu√≠ venimos en ayuda de un algoritmo m√°s complejo llamado A *. Funciona de la misma manera que la b√∫squeda de amplitud, pero en lugar de explorar ciegamente vecinos, luego vecinos de vecinos, luego vecinos de vecinos, vecinos, etc., coloca todos estos nodos en una lista y los ordena para que el siguiente nodo examinado sea siempre el √∫nico. Lo m√°s probable es que conduzca a la ruta m√°s corta. Los nodos se ordenan seg√∫n la heur√≠stica (es decir, una suposici√≥n razonable),que tiene en cuenta dos aspectos: el costo de una ruta hipot√©tica a la celda (teniendo en cuenta todos los costos necesarios de la mudanza) y una evaluaci√≥n de qu√© tan lejos est√° esta celda del punto final (desplazando as√≠ la b√∫squeda en la direcci√≥n correcta).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/128/406/091/128406091bee8168b7b0e398386797da.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este ejemplo, mostramos que √©l examina una celda a la vez, cada vez que elige una celda vecina que tiene las mejores (o una de las mejores) perspectivas. </font><font style="vertical-align: inherit;">La ruta resultante es similar a la ruta de b√∫squeda de amplitud, pero se examinan menos celdas en el proceso, y esto es muy importante para el rendimiento del juego en niveles complejos.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Movimiento sin malla </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En los ejemplos anteriores, se us√≥ una cuadr√≠cula superpuesta al mundo y trazamos una ruta alrededor del mundo a trav√©s de las celdas de esta cuadr√≠cula. Pero la mayor√≠a de los juegos no se superponen a la cuadr√≠cula y, por lo tanto, la superposici√≥n de la cuadr√≠cula puede conducir a patrones de movimiento poco realistas. Adem√°s, este enfoque puede requerir compromisos con respecto al tama√±o de cada celda: si es demasiado grande, entonces no podr√° describir adecuadamente corredores y giros peque√±os, si es demasiado peque√±o, entonces buscar a trav√©s de miles de celdas puede ser demasiado largo. Cuales son las alternativas? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo primero que debemos entender es que, desde un punto de vista matem√°tico, la cuadr√≠cula nos da un " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gr√°fico</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"de nodos conectados. Los algoritmos A * (y BFS) funcionan con gr√°ficos, y no les importa la cuadr√≠cula. Por lo tanto, podemos colocar nodos en posiciones arbitrarias del mundo, y si hay una l√≠nea recta entre dos nodos conectados, pero hay una l√≠nea entre el principio y el final Si solo hay un nodo, nuestro algoritmo funcionar√° como antes, y de hecho es a√∫n mejor, porque habr√° menos nodos. Esto a menudo se llama el sistema de puntos de referencia, ya que cada nodo indica una posici√≥n importante en el mundo que puede crear parte de cualquier n√∫mero de pu hipot√©tico </font><font style="vertical-align: inherit;">s.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b0/a64/90f/5b0a6490f8fac6a4101d7d6833946325.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplo 1: un nodo en cada celda de la cuadr√≠cula. </font><font style="vertical-align: inherit;">La b√∫squeda comienza con el nodo en el que se encuentra el agente y termina con la celda final.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f9/a09/70d/0f9a0970dfadfd31260ae81c93d8792b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplo 2: un n√∫mero mucho menor de nodos o</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> puntos de referencia </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. La b√∫squeda comienza con el agente, pasa a trav√©s del n√∫mero requerido de puntos de referencia y se mueve al punto final. Tenga en cuenta que moverse al primer punto de la ruta al suroeste del jugador es una ruta ineficiente, por lo que generalmente es necesario un cierto procesamiento posterior de la ruta generada (por ejemplo, para notar que la ruta puede ir directamente al punto de referencia en el noreste).</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Este es un sistema bastante flexible y potente, pero requiere una ubicaci√≥n cuidadosa de los puntos intermedios; de lo contrario, es posible que los agentes no vean el punto intermedio m√°s cercano para comenzar la ruta. Ser√≠a genial si de alguna manera pudi√©ramos generar waypoints autom√°ticamente basados ‚Äã‚Äãen la geometr√≠a del mundo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y luego navmesh viene al rescate. Esto es la abreviatura de malla de navegaci√≥n. En esencia, esta es (generalmente) una malla de tri√°ngulos bidimensional, que se superpone aproximadamente con la geometr√≠a del mundo en aquellos lugares donde el juego permite que el agente se mueva. Cada uno de los tri√°ngulos en la malla se convierte en un nodo del gr√°fico y tiene hasta tres tri√°ngulos adyacentes que se convierten en nodos adyacentes del gr√°fico. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A continuaci√≥n se muestra un ejemplo del motor de Unity. El motor analiz√≥ la geometr√≠a del mundo y cre√≥ navmesh (azul), que es una aproximaci√≥n de la geometr√≠a. Cada pol√≠gono nammesh es un √°rea en la que un agente puede pararse, y un agente puede moverse de un pol√≠gono a otro adyacente. (En este ejemplo, los pol√≠gonos se hacen m√°s estrechos que el piso en el que se encuentran para tener en cuenta el radio del agente, que se extiende m√°s all√° de la posici√≥n nominal del agente).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/860/051/69e/86005169e23bd5d646664aeecf688b3a.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos buscar una ruta a trav√©s de una malla usando A * nuevamente, y esto nos dar√° una ruta ideal alrededor del mundo que tiene en cuenta toda la geometr√≠a y no requiere un n√∫mero excesivo de nodos adicionales (como ser√≠a con la cuadr√≠cula) y la participaci√≥n humana en la generaci√≥n de puntos el camino </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encontrar caminos es un tema extenso, para el cual hay muchos enfoques, especialmente si necesita programar detalles de bajo nivel usted mismo. </font><font style="vertical-align: inherit;">Una de las mejores fuentes de informaci√≥n adicional es el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sitio de Amit Patel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (traducci√≥n del art√≠culo sobre Habr√©: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://habr.com/post/331192/</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Planificacion </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilizando la b√∫squeda de rutas como ejemplo, vimos que a veces no basta con elegir una direcci√≥n y comenzar a moverse en ella; tenemos que elegir una ruta y hacer varios movimientos antes de llegar al punto final deseado. Podemos generalizar esta idea a una amplia gama de conceptos en los que el objetivo no es solo el siguiente paso. Para lograrlo, debe seguir una serie de pasos, y para saber cu√°l deber√≠a ser el primer paso, es posible que tenga que mirar unos pasos hacia adelante. Este enfoque se llama </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">planificaci√≥n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Encontrar rutas puede considerarse una de las aplicaciones espec√≠ficas de planificaci√≥n, pero este concepto tiene muchas m√°s aplicaciones. Volviendo al ciclo de "percepci√≥n-pensamiento-acci√≥n", esta planificaci√≥n es una fase de pensamiento que trata de planificar varias fases de acci√≥n para el futuro.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Veamos el juego Magic: The Gathering. </font><font style="vertical-align: inherit;">Tienes tu primer movimiento, hay varias cartas en tus manos, entre las cuales est√°n "Pantano", que da 1 punto de man√° negro, y "Bosque", que da 1 punto de man√° verde, "Exorcista", que requiere 1 punto de man√° azul para llamar, y " Elven Mystic ‚Äù, para llamar al cual necesitas 1 punto de man√° verde. </font><font style="vertical-align: inherit;">(Por simplicidad, omitimos las tres cartas restantes.) Las reglas dicen que un jugador puede jugar una carta de tierra por turno, puede "tocar" sus cartas de tierra para obtener man√° de ellas y puede lanzar tantos hechizos (incluidas criaturas de invocaci√≥n) cu√°nto man√° tiene. </font><font style="vertical-align: inherit;">En esta situaci√≥n, es probable que el jugador juegue "Bosque", t√≥quelo para obtener 1 punto de man√° verde y luego llame a "Elven Mystic". </font><font style="vertical-align: inherit;">Pero, ¬øc√≥mo sabe una IA de juegos que se debe tomar tal decisi√≥n?</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "Planificador" simple </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un enfoque ingenuo puede ser simplemente iterar sobre cada acci√≥n en orden, hasta que haya las adecuadas. Mirando la mano, AI ve que puede jugar "Swamp", y por lo tanto lo hace. ¬øQuedan m√°s acciones despu√©s de este turno? No puede invocar ni a Elven Mystic ni a Exile Wizard, porque esto requiere man√° verde o azul, y el pantano jugado solo da man√° negro. Y no podemos jugar "Forest" porque ya hemos jugado "Swamp". Es decir, el jugador de IA har√° el movimiento de acuerdo con las reglas, pero no ser√° muy √≥ptimo. Afortunadamente, hay una mejor soluci√≥n.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Casi de la misma manera en que la b√∫squeda de caminos encuentra una lista de posiciones para moverse por el mundo para llegar al punto correcto, nuestro planificador puede encontrar una lista de acciones que ponen el juego en el estado correcto. </font><font style="vertical-align: inherit;">Del mismo modo que cada posici√≥n en el camino tiene un conjunto de vecinos, que son opciones potenciales para elegir el siguiente paso a lo largo del camino, cada acci√≥n en el plan tiene vecinos o ‚Äúherederos‚Äù que son candidatos para el siguiente paso del plan. </font><font style="vertical-align: inherit;">Podemos buscar estas acciones y las siguientes acciones hasta que alcancemos el estado deseado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Supongamos, para nuestro ejemplo, que el resultado deseado ser√≠a "convocar a una criatura, si es posible". </font><font style="vertical-align: inherit;">Al comienzo del movimiento, solo tenemos dos acciones potenciales permitidas por las reglas del juego:</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1. Juega "Swamp" (resultado: "Swamp" deja la mano y entra en el juego)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. Juega "Forest" (resultado: "Forest" deja la mano y entra al juego) </font></font></pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada acci√≥n tomada puede abrir m√°s acciones o cerrarlas, tambi√©n de acuerdo con las reglas del juego. </font><font style="vertical-align: inherit;">Imagina que elegimos jugar "Swamp": esto cierra la oportunidad de jugar esta carta como una posible acci√≥n de herencia (porque "Swamp" ya se ha jugado), cierra la oportunidad de jugar "Forest" (porque las reglas del juego te permiten jugar solo una carta de tierra por turno) y agrega la capacidad de tocar el "Pantano" para obtener 1 punto de man√° negro, y esta, de hecho, es la √∫nica acci√≥n heredada. </font><font style="vertical-align: inherit;">Si damos un paso m√°s y seleccionamos "tocar" Pantano ", obtendremos 1 punto de man√° negro con el que no podemos hacer nada, as√≠ que esto no tiene sentido.</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1. Juega "Swamp" (resultado: "Swamp" deja la mano y entra en el juego)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            1.1 Toque "Pantano" (resultado: tocamos "Pantano", +1 man√° negro est√° disponible)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                        No queda acci√≥n - FIN</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. Juega "Forest" (resultado: "Forest" deja la mano y entra al juego) </font></font></pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta breve lista de acciones no nos dio mucho y condujo a un "callej√≥n sin salida", si utilizamos la analog√≠a con la b√∫squeda de caminos. </font><font style="vertical-align: inherit;">Por lo tanto, repetimos el proceso para el siguiente paso. </font><font style="vertical-align: inherit;">Elegimos jugar Forest. </font><font style="vertical-align: inherit;">Esto tambi√©n elimina la capacidad de "jugar al Bosque" y "jugar al Pantano", y se abre como un posible (y √∫nico) paso siguiente "tocar el Bosque". </font><font style="vertical-align: inherit;">Esto nos da 1 punto de man√° verde, que a su vez abre el tercer paso: "llamar" Elven Mystic ".</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1. Juega "Swamp" (resultado: "Swamp" deja la mano y entra en el juego)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            1.1 Toque "Pantano" (resultado: tocamos "Pantano", +1 man√° negro est√° disponible)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                        No queda acci√≥n - FIN</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. Juega "Forest" (resultado: "Forest" deja la mano y entra al juego)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            2.1 Toque "Bosque" (resultado: tocamos "Pantano", +1 de man√° verde est√° disponible)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                        2.1.1 Llamada "Elven Mystic" (resultado: "Elven Mystic" en el juego, -1 man√° verde est√° disponible)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                                    No queda acci√≥n - FIN </font></font></pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora hemos investigado todas las acciones posibles y las acciones resultantes de estas acciones, encontrando un plan que nos permite convocar a la criatura: "jugar al bosque", "tocar el bosque", "llamar al" M√≠stico √©lfico "". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, este es un ejemplo muy simplificado y, por lo general, debe elegir el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mejor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un plan, y no solo un plan que satisfaga algunos criterios (por ejemplo, "convocar a una criatura"). Por lo general, puede evaluar planes potenciales en funci√≥n del resultado final o los beneficios acumulativos de usar el plan. Por ejemplo, puedes darte 1 punto por un mapa de tierra y 3 puntos por llamar a una criatura. "Jugar" Pantano "" ser√° un plan corto que dar√° 1 punto, y el plan para "jugar" Bosque "‚Üí tocar" Bosque "‚Üí llamar a" Elven Mystic "" da 4 puntos, 1 para el suelo y 3 para la criatura. Este ser√° el plan m√°s rentable disponible, por lo que debe elegirlo si asignamos dichos puntos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arriba, mostramos c√≥mo funciona la planificaci√≥n dentro de un movimiento Magic: The Gathering, pero tambi√©n se puede aplicar a acciones en una serie de movimientos (por ejemplo, "mover un pe√≥n para dejar espacio para el desarrollo del alfil" en ajedrez o "correr para cubrir una unidad"). podr√≠a disparar el siguiente turno, estar a salvo "en XCOM) o para la estrategia general de todo el juego (por ejemplo," construir pilones para todos los dem√°s edificios protoss "en Starcraft, o" beber una poci√≥n Fortify Health antes de atacar al enemigo "en Skyrim). </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Planificaci√≥n mejorada </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A veces hay demasiadas acciones posibles en cada paso, y evaluar cada opci√≥n no es razonable. Volvamos al ejemplo de Magic: The Gathering: imagina que tenemos varias criaturas a mano, muchas tierras ya se han jugado, por lo que podemos llamar a cualquier criatura, varias criaturas con sus habilidades jugadas, y hay un par de cartas de tierra m√°s en la mano: el n√∫mero de permutaciones la tierra, el uso de la tierra, la invocaci√≥n de criaturas y el uso de las habilidades de las criaturas pueden ser iguales a miles o incluso decenas de miles. Afortunadamente, hay un par de formas de resolver este problema. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El primero se llama </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">encadenamiento hacia atr√°s.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"(" Ida y vuelta "). En lugar de verificar todas las acciones y sus resultados, podemos comenzar con cada uno de los resultados finales deseados y ver si podemos encontrar un camino directo hacia ellos. Puede comparar esto con intentar alcanzar una hoja espec√≠fica en un √°rbol, es mucho m√°s l√≥gico comience desde esta hoja y regrese, colocando una ruta a lo largo del tronco (y esta ruta podemos seguir en el orden opuesto), que comenzando desde el tronco e intentando adivinar qu√© rama elegir en cada paso. Si comienza desde el final y va en la direcci√≥n opuesta, luego creado Plan E ser√° mucho m√°s r√°pido y m√°s f√°cil.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por ejemplo, si al enemigo le queda 1 punto de vida, puede ser √∫til tratar de encontrar un plan para "infligir 1 o m√°s puntos de da√±o directo al enemigo". Nuestro sistema sabe que para lograr este objetivo necesita lanzar un hechizo de da√±o directo, lo que a su vez significa que debe estar en nuestras manos y necesitamos suficiente man√° para pronunciarlo. Esto, a su vez, significa que necesitamos tocar suficiente tierra para recibir este man√°, lo que puede requerir que juegues un mapa de tierra adicional.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otra forma es buscar por la primera mejor coincidencia. En lugar de analizar todas las permutaciones durante mucho tiempo, medimos cu√°n "bueno" es cada plan parcial (similar a c√≥mo elegimos entre las opciones de plan anteriores) y calculamos el mejor aspecto cada vez. A menudo, esto le permite crear un plan √≥ptimo, o al menos bastante bueno, sin la necesidad de considerar cada posible reorganizaci√≥n de los planes. A * es una variaci√≥n de la b√∫squeda del primer mejor partido: primero explora las rutas m√°s prometedoras, por lo que generalmente puede encontrar el camino hacia la meta sin tener que subir demasiado en otras direcciones. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una opci√≥n de b√∫squeda interesante y cada vez m√°s popular para la primera mejor coincidencia es la b√∫squeda de √°rboles de </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">Monte Carlo</font></a><font style="vertical-align: inherit;"> .</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. En lugar de adivinar qu√© planes son mejores que otros al elegir cada acci√≥n posterior, este m√©todo elige acciones posteriores aleatorias en cada paso hasta que llega al final donde ya no son posibles acciones, probablemente porque el plan hipot√©tico condujo a un estado de victoria o p√©rdida - y utiliza este resultado para dar m√°s o menos peso a las opciones seleccionadas anteriormente. Si el proceso se repite muchas veces, el m√©todo puede crear una buena evaluaci√≥n del mejor pr√≥ximo paso, incluso si la situaci√≥n cambia (por ejemplo, si el enemigo intenta frustrar nuestros planes). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, ninguna discusi√≥n sobre la planificaci√≥n en los juegos estar√≠a completa sin mencionar la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">planificaci√≥n de la acci√≥n basada en objetivos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Planificaci√≥n de acciones orientadas a objetivos, GOAP). </font><font style="vertical-align: inherit;">Esta es una t√©cnica ampliamente utilizada y ampliamente discutida, pero si ignora algunos detalles espec√≠ficos de implementaci√≥n, es esencialmente un planificador de ida y vuelta que comienza con un objetivo e intenta recoger una acci√≥n que conduzca a ese objetivo, o, m√°s probablemente, una lista de acciones que conducen a a la meta. </font><font style="vertical-align: inherit;">Por ejemplo, si el objetivo era "matar al jugador" y el jugador estaba cubierto, entonces el plan podr√≠a ser: "Fumar al jugador con una granada" ‚Üí "Sacar un arma" ‚Üí "Atacar".</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo general, hay varios objetivos, y cada uno tiene su propia prioridad. </font><font style="vertical-align: inherit;">Si los objetivos con la prioridad m√°s alta no se pueden lograr, por ejemplo, ning√∫n conjunto de acciones puede formar el plan "Mata al jugador" porque el jugador no es visible, entonces el sistema vuelve a los objetivos con prioridades m√°s bajas, por ejemplo, "Patrulla" o "Guardia en el lugar".</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entrenamiento y adaptaci√≥n </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al comienzo del art√≠culo, mencionamos que la inteligencia artificial para juegos generalmente no utiliza el "aprendizaje autom√°tico" porque generalmente no es adecuada para el control en tiempo real de agentes inteligentes en el mundo de los juegos. </font><font style="vertical-align: inherit;">Sin embargo, esto no significa que no podamos tomar prestado algo de esta √°rea donde tenga sentido. </font><font style="vertical-align: inherit;">Es posible que necesitemos un oponente inform√°tico en el tirador para descubrir los mejores lugares para movernos y obtener la mayor cantidad de asesinatos. </font><font style="vertical-align: inherit;">O podr√≠amos querer al oponente en un juego de lucha. </font><font style="vertical-align: inherit;">por ejemplo, en Tekken o Street Fighter, aprendi√≥ a reconocer a un jugador que usa los mismos combos para comenzar a bloquearlos, lo que obliga al jugador a usar diferentes t√°cticas. </font><font style="vertical-align: inherit;">Es decir, hay momentos en que un cierto porcentaje de aprendizaje autom√°tico es √∫til.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Estad√≠sticas y probabilidades </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de pasar a ejemplos m√°s complejos, vale la pena averiguar hasta d√≥nde podemos llegar simplemente tomando medidas y utilizando estos datos para tomar decisiones. Por ejemplo, supongamos que tenemos un juego en el g√©nero de la estrategia en tiempo real, y necesitamos entender si el jugador comenzar√° a correr en los primeros minutos para decidir si construir m√°s defensa. Podemos extrapolar el comportamiento anterior del jugador para comprender cu√°l podr√≠a ser el comportamiento futuro. Al principio, no tenemos datos que puedan extrapolarse, pero cada vez que la IA juega contra un enemigo vivo, puede registrar la hora del primer ataque. Despu√©s de algunos partidos, este tiempo se puede promediar y obtendremos una aproximaci√≥n suficientemente buena del tiempo de ataque del jugador en el futuro.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El problema con el promedio simple es que generalmente converge con el tiempo en el centro. Por lo tanto, si un jugador us√≥ la estrategia de prisa las primeras 20 veces, y las siguientes 20 veces cambi√≥ a una estrategia mucho m√°s lenta, entonces el valor promedio estar√° en alg√∫n punto intermedio, lo que no nos dar√° ninguna informaci√≥n √∫til. Una forma de mejorar los datos es utilizar una ventana de promedio simple que tenga en cuenta solo los √∫ltimos 20 puntos de datos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se puede usar un enfoque similar para evaluar la probabilidad de ciertas acciones, suponiendo que las preferencias previas del jugador continuar√°n en el futuro. Por ejemplo, si un jugador atac√≥ cinco veces con una bola de fuego, dos veces con un rayo y mano a mano solo una vez, lo m√°s probable es que prefiera una bola de fuego 5 de 8 veces. Extrapolando a partir de estos datos, podemos ver que la probabilidad de usar un arma es: Bola de fuego = 62.5%, Rayo = 25% Cuerpo a cuerpo = 12.5%. ¬°Nuestros personajes de IA se dar√°n cuenta de que es mejor encontrar una armadura a prueba de fuego!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otro m√©todo interesante es utilizar el clasificador Naive Bayes para estudiar grandes vol√∫menes de datos de entrada con el fin de clasificar la situaci√≥n actual para que el agente de inteligencia artificial pueda responder en consecuencia. Los clasificadores bayesianos son probablemente m√°s conocidos por su uso en los filtros de correo electr√≥nico no deseado, donde eval√∫an las palabras en el correo electr√≥nico, las comparan con las palabras que se encontraban con mayor frecuencia en mensajes no deseados y mensajes normales en el pasado. En base a estos c√°lculos, deciden la probabilidad de que el √∫ltimo mensaje recibido sea spam. Podemos hacer algo similar, solo con menos entrada. Al registrar toda la informaci√≥n √∫til observable (por ejemplo, unidades enemigas creadas,hechizos o tecnolog√≠as de investigaci√≥n) y al rastrear la situaci√≥n resultante (guerra / paz, estrategia r√°pida / estrategia de defensa, etc.), podemos seleccionar el comportamiento apropiado en funci√≥n de esto.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El uso de todas estas t√©cnicas de ense√±anza puede ser suficiente, y con frecuencia y de preferencia aplicado a los datos recopilados durante las pruebas de juego antes del lanzamiento del juego. </font><font style="vertical-align: inherit;">Esto permite que la IA se adapte a las diversas estrategias utilizadas por los probadores de juego y no cambie despu√©s del lanzamiento del juego. </font><font style="vertical-align: inherit;">Una IA que se adapta a un jugador despu√©s del lanzamiento de un juego puede volverse demasiado predecible o incluso demasiado compleja para derrotarla.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adaptaci√≥n f√°cil basada en el peso. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos a ir un paso m√°s all√°. </font><font style="vertical-align: inherit;">En lugar de simplemente usar los datos de entrada para elegir entre estrategias discretas predefinidas, puede cambiar el conjunto de valores que influyen en la toma de decisiones. </font><font style="vertical-align: inherit;">Si entendemos bien el mundo del juego y las reglas del juego, entonces podemos hacer lo siguiente:</font></font><br><br><ul><li>              (   ); </li><li>    ¬´¬ª       ; </li><li>         . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagine un agente inform√°tico que puede seleccionar habitaciones en un mapa en un juego de disparos en primera persona. Cada habitaci√≥n tiene un peso que determina la conveniencia de visitar esta habitaci√≥n. Inicialmente, todas las habitaciones tienen el mismo significado. Al elegir una habitaci√≥n, la IA la selecciona al azar, pero con la influencia de estos pesos. Ahora imagine que cuando un agente inform√°tico es asesinado, recuerda en qu√© habitaci√≥n est√° sucediendo esto y reduce su peso, por lo que es menos probable que vuelva a √©l en el futuro. Del mismo modo, imagine que un agente inform√°tico ha cometido un asesinato. Luego puede aumentar el peso de la habitaci√≥n en la que se encuentra para subirlo a la lista de preferencias. Entonces, si una habitaci√≥n se vuelve especialmente peligrosa para el jugador de IA, entonces comienza a evitarla en el futuro, y si otra habitaci√≥n permite que la IA reciba muchos asesinatos,entonces √©l regresar√° all√≠.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modelos de Markov </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© pasar√≠a si quisi√©ramos usar los datos que recolectamos para hacer pron√≥sticos? </font><font style="vertical-align: inherit;">Por ejemplo, si registramos cada habitaci√≥n en la que vemos a un jugador durante un cierto per√≠odo de tiempo, podemos predecir razonablemente a qu√© habitaci√≥n puede pasar. </font><font style="vertical-align: inherit;">Al rastrear tanto la sala actual en la que se encuentra el jugador como la anterior, y registrar estos pares de valores, podemos calcular con qu√© frecuencia cada una de las situaciones anteriores conduce a la siguiente situaci√≥n, y usar este conocimiento para pron√≥sticos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagine que hay tres salas: rojo, verde y azul, y que durante la sesi√≥n del juego recibimos tales observaciones:</font></font><br><br><table><tbody><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La primera sala en la que se ve al jugador.</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observaciones totales</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sala siguiente</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuantas veces visto</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Porcentaje</font></font></b> <br><br></td></tr><tr><td rowspan="3"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rojo </font></font><br><br></td><td rowspan="3">  10 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rojo </font></font><br><br></td><td>  2 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 20% </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verde </font></font><br><br></td><td>  7 7 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 70% </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Azul </font></font><br><br></td><td>  1 <br><br></td><td>  10% <br><br></td></tr><tr><td rowspan="3"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verde </font></font><br><br></td><td rowspan="3">  10 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rojo </font></font><br><br></td><td>  3 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 30% </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verde </font></font><br><br></td><td>  5 5 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 50% </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Azul </font></font><br><br></td><td>  2 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 20% </font></font><br><br></td></tr><tr><td rowspan="3"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Azul </font></font><br><br></td><td rowspan="3">  8 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rojo </font></font><br><br></td><td>  6 6 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 75% </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verde </font></font><br></td><td>  2 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 25% </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Azul </font></font><br><br></td><td>  0 0 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0% </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El n√∫mero de detecciones en cada una de las habitaciones es bastante uniforme, por lo que no nos da una idea de cu√°les de las habitaciones pueden ser un buen lugar para una emboscada. Los datos pueden verse distorsionados por el hecho de que los jugadores aparecen de manera uniforme en el mapa, con la misma probabilidad de aparecer en cualquiera de estas tres salas. Pero los datos sobre visitar la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">siguiente</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> habitaci√≥n pueden ser √∫tiles y ayudarnos a predecir el movimiento del jugador en el mapa.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos notar de inmediato que la sala verde es muy atractiva para los jugadores: la mayor√≠a de los jugadores de la sala roja fueron a verde, y el 50% de los jugadores vistos en la sala verde permanecen all√≠ durante la pr√≥xima comprobaci√≥n. Tambi√©n podemos notar que la habitaci√≥n azul es un lugar poco atractivo. Las personas rara vez se mueven de habitaciones rojas o verdes a azules y parece que a nadie le gusta quedarse all√≠ por mucho tiempo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero los datos nos dicen algo m√°s espec√≠fico: dicen que cuando un jugador est√° en la habitaci√≥n azul, luego de seguirlo es m√°s probable que elija rojo, en lugar de verde. A pesar de que la sala verde es un lugar mucho m√°s popular para ir que la roja, la tendencia es ligeramente opuesta si el jugador est√° en la sala azul. Parece que el siguiente estado (es decir, la sala en la que decide avanzar) depende del estado anterior (es decir, la sala en la que se encuentra ahora), por lo que estos datos nos permiten crear mejores pron√≥sticos sobre el comportamiento de los jugadores. que con conteo de observaci√≥n independiente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta idea de que podemos usar el conocimiento del estado anterior para predecir el estado futuro se llama </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modelo de Markov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y ejemplos similares en los que hemos medido eventos con precisi√≥n (por ejemplo, "en qu√© habitaci√≥n se encuentra el jugador") se llaman cadenas de Markov. Como representan la probabilidad de una transici√≥n entre estados sucesivos, a menudo se representan gr√°ficamente en forma de una m√°quina de estados finitos, cerca de cada transici√≥n de la cual se indica su probabilidad. Anteriormente, utilizamos una m√°quina de estados para representar el estado de comportamiento en el que se encuentra el agente, pero este concepto puede extenderse a todo tipo de estados, est√©n o no asociados con el agente. En nuestro caso, los estados indican las habitaciones ocupadas por el agente. Se ver√° as√≠:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e43/53b/691/e4353b691807e7476a2255f91dc2f248.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este es un enfoque simple para indicar la probabilidad relativa de transici√≥n a diferentes estados, lo que le da a AI la capacidad de predecir el siguiente estado. </font><font style="vertical-align: inherit;">Pero podemos ir m√°s all√° creando un sistema que mire hacia el futuro en dos o m√°s pasos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si un jugador ha sido visto en la sala verde, utilizaremos datos que nos indiquen que hay un 50 por ciento de posibilidades de que todav√≠a est√© en la sala verde en la pr√≥xima observaci√≥n. </font><font style="vertical-align: inherit;">Pero, ¬øcu√°l es la probabilidad de que permanezca en √©l por tercera vez? </font><font style="vertical-align: inherit;">Esta no es solo la probabilidad de que permanezca en la sala verde durante dos observaciones (50% * 50% = 25%), sino tambi√©n la probabilidad de que lo deje y regrese. </font><font style="vertical-align: inherit;">Aqu√≠ hay una nueva tabla con valores previos aplicados a tres observaciones: una actual y dos hipot√©ticas en el futuro.</font></font><br><br><table><tbody><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observaci√≥n 1</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observaci√≥n hipot√©tica 2</font></font></b> <br><br></td><td> <b>  </b> <br><br></td><td> <b>  3</b> <br><br></td><td> <b>  </b> <br><br></td><td> <b> </b> <br><br></td></tr><tr><td rowspan="10">  <br></td><td rowspan="3">  <br><br></td><td rowspan="3"> 30% <br><br></td><td>  <br><br></td><td> 20% <br><br></td><td> 6% <br><br></td></tr><tr><td> <b></b> <br><br></td><td> 70% <br><br></td><td> <b>21%</b> <br><br></td></tr><tr><td>  <br><br></td><td>  10% <br><br></td><td> 3% <br><br></td></tr><tr><td rowspan="3">  <br></td><td rowspan="3"> 50% <br><br></td><td>  <br><br></td><td> 30% <br><br></td><td> 15% <br><br></td></tr><tr><td> <b></b> <br><br></td><td> 50% <br><br></td><td> <b>25%</b> <br><br></td></tr><tr><td>  <br><br></td><td> 20% <br><br></td><td>  10% <br><br></td></tr><tr><td rowspan="3">  <br><br></td><td rowspan="3"> 20% <br><br></td><td>  <br><br></td><td> 75% <br><br></td><td> 15% <br><br></td></tr><tr><td> <b></b> <br><br></td><td> 25% <br><br></td><td> <b>5%</b> <br><br></td></tr><tr><td>  <br><br></td><td> 0% <br><br></td><td> 0% <br><br></td></tr><tr><td></td><td></td><td></td><td> <i>:</i> <br><br></td><td>  100% </td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ vemos que la probabilidad de ver a un jugador en la sala verde despu√©s de 2 observaciones es del 51%: 21% de lo que vendr√° de la sala roja, 5% de lo que vemos al jugador visitando la sala azul y 25% de lo que es todo el tiempo. se quedar√° en la sala verde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una tabla es solo una pista visual; un procedimiento solo requiere una multiplicaci√≥n de probabilidades en cada etapa. Esto significa que podemos mirar hacia el futuro, pero con una advertencia importante: suponemos que la probabilidad de entrar en una habitaci√≥n depende completamente de la habitaci√≥n en la que nos encontremos en este momento. Esta idea de que el estado futuro depende solo de la corriente se llama </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propiedad de Markov</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aunque nos permite usar herramientas poderosas como las cadenas de Markov, generalmente es solo una aproximaci√≥n. </font><font style="vertical-align: inherit;">Los jugadores pueden decidir visitar salas en funci√≥n de otros factores, como su nivel de salud y la cantidad de municiones, y dado que no registramos esta informaci√≥n como parte de la condici√≥n, nuestras predicciones ser√°n menos precisas.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N gramos </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Volvamos a nuestro ejemplo con el reconocimiento combinado en un juego de lucha. Esta es una situaci√≥n similar en la que queremos predecir el estado futuro en funci√≥n del pasado (para decidir c√≥mo bloquear un ataque o esquivarlo), pero en lugar de estudiar un solo estado o evento, consideraremos </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">secuencias de</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eventos que crean un movimiento combinado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una forma de hacerlo es guardar la entrada de cada jugador (por ejemplo, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">patada</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mano</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloque</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) en el b√∫fer y escribir todo el b√∫fer como un evento. Imagine que un jugador presiona constantemente </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">una patada</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">una patada</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , una </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">patada</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para usar el ataque " </font><i><font style="vertical-align: inherit;">Death Cancer</font></i><font style="vertical-align: inherit;"> "</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ", y el sistema de IA guarda todas las entradas del jugador en el b√∫fer y recuerda las √∫ltimas 3 entradas utilizadas en cada paso. </font></font><br><br><table><tbody><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entrar</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una secuencia de entrada existente</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nueva memoria de entrada</font></font></b> <br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Patada </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Patada </font></font><br><br></td><td> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no</font></font></i> <br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Golpe de mano </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Patada, patada </font></font><br><br></td><td> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no</font></font></i> <br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Patada </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Patada, patada, patada </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Patada, patada, patada </font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Patada </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Patada, patada, patada, patada </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Patada, patada, patada </font></font><br><br></td></tr><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Golpe de mano</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patada, patada, patada, patada, patada</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patada, patada, patada</font></font></b> <br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bloque </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Patada, patada, patada, patada, patada, bloque </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Patada, patada, bloque </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Patada </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Patada, patada, patada, patada, patada, bloque, patada </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Patada, bloqueo, patada </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Patada </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Patada, patada, patada, patada, patada, bloque, patada, patada </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bloquear, patear, patear </font></font><br><br></td></tr><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Golpe de mano</font></font></b> <br><br></td><td> <b> ,  ,  ,  ,  , ,  ,  ,  </b> <br><br></td><td> <b> ,  ,  </b> </td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(En negrita, el jugador realiza el ataque "Superbuck of Death"). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puedes ver todos los momentos en que el jugador eligi√≥ una </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">patada</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en el pasado </font><font style="vertical-align: inherit;">, seguida de otra </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">patada</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y notar que la siguiente entrada siempre es un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pu√±etazo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Esto permite al agente de IA hacer una predicci√≥n de que si un jugador acaba de elegir una patada, seguida de una patada, lo m√°s probable es que seleccione una </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">patada a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> continuaci√≥n </font><font style="vertical-align: inherit;">, lanzando as√≠ el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Death Superkulak</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Esto permite que la IA decida elegir una acci√≥n que contrarreste este golpe, como bloquear o esquivar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tales secuencias de eventos se llaman </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N-gramos.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">donde N es el n√∫mero de elementos almacenados. En el ejemplo anterior, eran 3 gramos, tambi√©n llamado trigrama, es decir, los primeros 2 elementos se usan para predecir el tercero. En los 5 gramos, el quinto se predice para los primeros 4 elementos, y as√≠ sucesivamente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los desarrolladores deben elegir cuidadosamente el tama√±o de N-gramos (a veces llamado orden). Cuanto menor es el n√∫mero, se requiere menos memoria, porque menor es el n√∫mero de permutaciones permitidas, pero se guarda menos historial, lo que significa que se pierde el contexto. Por ejemplo, un 2 gramos (tambi√©n llamado "bigram") contendr√° registros para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">patear</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">patear</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y grabaciones para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">patear</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">patear</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pero no puede guardar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">una patada</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kick</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hand kick</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , por lo tanto, no puede rastrear este combo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por otro lado, cuanto mayor sea el orden, m√°s memoria se requiere, y el sistema probablemente ser√° m√°s dif√≠cil de entrenar, porque tendremos muchas m√°s permutaciones posibles, lo que significa que nunca podremos encontrarnos con el mismo dos veces. Por ejemplo, si hay tres entradas posibles ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">patada</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mano</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloqueo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) y usamos 10 gramos, habr√° casi 60 mil permutaciones diferentes.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El modelo de bigram es esencialmente una cadena trivial de Markov: cada par "estado futuro / estado actual" es un bigram y podemos predecir el segundo estado en funci√≥n del primero. Los trigramas y los grandes N-gramos tambi√©n pueden considerarse cadenas de Markov, donde todos los elementos del N-gramo, excepto el √∫ltimo, forman el primer estado, y el √∫ltimo elemento es el segundo estado. En nuestro ejemplo de juego de lucha, se presenta la probabilidad de transici√≥n del estado de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">patear y patear</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> al estado de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">patear, luego patear</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Al percibir varios elementos del historial de entrada como un solo elemento, esencialmente transformamos la secuencia de entrada en un fragmento del estado, lo que nos da una propiedad de Markov, lo que nos permite usar cadenas de Markov para predecir la siguiente entrada, es decir, adivinar qu√© movimiento combinado seguir√°.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Representaci√≥n del conocimiento </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Discutimos varias formas de tomar decisiones, crear planes y pron√≥sticos, y todas se basan en las observaciones del agente del estado del mundo. </font><font style="vertical-align: inherit;">Pero, ¬øc√≥mo podemos observar efectivamente todo el mundo del juego? </font><font style="vertical-align: inherit;">Arriba, vimos que la forma de representar la geometr√≠a del mundo afecta en gran medida el movimiento a lo largo de √©l, por lo que es f√°cil imaginar que esto es cierto para otros aspectos de la IA del juego. </font><font style="vertical-align: inherit;">¬øC√≥mo podemos recopilar y organizar toda la informaci√≥n necesaria de una manera √≥ptima (para que a menudo sea actualizada y accesible para muchos agentes) y pr√°ctica (para que la informaci√≥n pueda usarse f√°cilmente en el proceso de toma de decisiones)? </font><font style="vertical-align: inherit;">¬øC√≥mo convertir </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">datos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> simples </font><font style="vertical-align: inherit;">en </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">informaci√≥n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conocimiento</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? </font><font style="vertical-align: inherit;">Para diferentes juegos, las soluciones pueden ser diferentes, pero hay varios enfoques m√°s populares.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Etiquetas / Etiquetas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A veces ya tenemos una gran cantidad de datos √∫tiles, y lo √∫nico que necesitamos es una buena manera de clasificarlos y buscarlos. Por ejemplo, en el mundo del juego puede haber muchos objetos, y algunos de ellos son un buen refugio contra las balas enemigas. O, por ejemplo, tenemos un mont√≥n de di√°logos de audio grabados que son aplicables en situaciones espec√≠ficas, y necesitamos una forma de resolverlos r√°pidamente. El paso obvio es agregar una peque√±a pieza de informaci√≥n adicional que puede usar para buscar. Dichos fragmentos se denominan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">etiquetas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o etiquetas.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Volvamos al ejemplo del refugio; En el mundo del juego puede haber un mont√≥n de objetos: cajas, barriles, racimos de hierba, cercas de alambre. Algunos de ellos son adecuados para refugio, por ejemplo, cajas y barriles, otros no. Por lo tanto, cuando nuestro agente realiza la acci√≥n "Mover al refugio", debe buscar objetos cercanos e identificar candidatos adecuados. No puede simplemente buscar por nombre, tal vez el juego tiene Crate_01, Crate_02, hasta Crate_27, y no queremos buscar todos estos nombres en el c√≥digo. No queremos agregar otro nombre al c√≥digo cada vez que el artista crea una nueva variaci√≥n de la caja o barril. En cambio, puede buscar cualquier nombre que contenga la palabra "Crate", pero un d√≠a un artista puede agregar "Broken_Crate" con un gran agujero, inadecuado como refugio.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, en su lugar, crearemos una etiqueta de "CUBIERTA" y pediremos a los artistas y dise√±adores que adjunten esta etiqueta a todos los objetos que puedan usarse como refugio. Si agregan una etiqueta a todos los barriles y cajas (enteras), entonces el procedimiento de IA solo necesitar√° encontrar objetos con esta etiqueta, y sabr√° que los objetos son adecuados para este prop√≥sito. La etiqueta funcionar√° incluso si luego se cambia el nombre de los objetos, y se puede agregar a los objetos en el futuro sin realizar cambios innecesarios en el c√≥digo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el c√≥digo, las etiquetas generalmente se representan como cadenas, pero si se conocen todas las etiquetas utilizadas, puede convertir cadenas en n√∫meros √∫nicos para ahorrar espacio y acelerar la b√∫squeda. En algunos motores, las etiquetas son funciones integradas, por ejemplo, en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unity</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unreal Engine 4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , por lo tanto, es suficiente determinar la elecci√≥n de etiquetas en ellas y usarlas para el prop√≥sito previsto. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objetos inteligentes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las etiquetas son una forma de agregar informaci√≥n adicional al entorno del agente, para ayudarlo a descubrir las opciones disponibles, de modo que consultas como "Encu√©ntrame todos los lugares m√°s cercanos para esconderse" o "Encu√©ntrame a todos los enemigos cercanos que puedan lanzar hechizos" se realizan de manera eficiente y con un m√≠nimo esfuerzo trabajado para nuevos recursos del juego. </font><font style="vertical-align: inherit;">Pero a veces las etiquetas no contienen suficiente informaci√≥n para su uso completo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagine un simulador de una ciudad medieval en la que los aventureros deambulan donde quieren, si es necesario, entrenar, luchar y relajarse. Podemos organizar sitios de entrenamiento en diferentes partes de la ciudad y asignarles la etiqueta "ENTRENAMIENTO" para que los personajes puedan encontrar f√°cilmente un lugar para el entrenamiento. Pero imaginemos que uno de ellos es un campo de tiro para arqueros, y el otro es una escuela de magos. En cada uno de estos casos, necesitamos mostrar nuestra animaci√≥n, porque bajo el nombre general de "entrenamiento" representan diferentes acciones, y no todos los aventureros est√°n interesados ‚Äã‚Äãen ambos tipos de entrenamiento. Puede profundizar a√∫n m√°s y crear etiquetas de ARCHERY-TRAINING y MAGIC-TRAINING, separar los procedimientos de entrenamiento unos de otros e incrustarlos en cada animaci√≥n diferente. Esto ayudar√° a resolver el problema. Pero imaginaque los dise√±adores luego declarar√°n "¬°Tengamos una escuela Robin Hood donde pueda aprender tiro con arco y lucha con espadas"! Y luego, cuando agregamos la lucha de espadas, piden la creaci√≥n de la Academia de Hechizos y Lucha de Espadas de Gandalf. Como resultado, tendremos que almacenar varias etiquetas para cada lugar y buscar diferentes animaciones basadas en qu√© aspecto de entrenamiento necesita el personaje, etc.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otra forma es almacenar informaci√≥n directamente en el objeto junto con la influencia que tiene sobre el jugador, para que el actor de IA simplemente pueda enumerar las posibles opciones y elegir entre ellas de acuerdo con las necesidades del agente. </font><font style="vertical-align: inherit;">Despu√©s de eso, puede moverse al lugar apropiado, realizar las animaciones apropiadas (o cualquier otra acci√≥n obligatoria), como se indica en el objeto, y recibir la recompensa apropiada.</font></font><br><br><table><tbody><tr><td><br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animaci√≥n en ejecuci√≥n</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resultado del usuario</font></font></b> <br><br></td></tr><tr><td> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Campo de tiro</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Disparar-flecha </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +10 habilidad de tiro con arco </font></font><br><br></td></tr><tr><td> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Escuela de magia</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Duelo de espadas </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +10 habilidad con espadas </font></font><br><br></td></tr><tr><td rowspan="2"> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Escuela Robin Hood</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Disparar-flecha </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +15 habilidad de tiro con arco </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Duelo de espadas </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +8 habilidad con espadas </font></font><br><br></td></tr><tr><td rowspan="2"> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Academia Gandalf</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Duelo de espadas </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +5 habilidad con espadas </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hechizo de lanzamiento </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +10 Habilidad M√°gica </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El personaje arquero junto a estas 4 ubicaciones tendr√° 6 opciones, 4 de las cuales no son aplicables a √©l si no usa una espada o magia. </font><font style="vertical-align: inherit;">Comparando el resultado en este caso con una mejora en la habilidad, en lugar de un nombre o etiqueta, podemos expandir f√°cilmente las posibilidades del mundo con nuevos comportamientos. </font><font style="vertical-align: inherit;">Puede agregar hoteles para descansar y satisfacer su hambre. </font><font style="vertical-align: inherit;">Puedes dejar que los personajes vayan a la biblioteca y lean sobre hechizos y t√©cnicas avanzadas de tiro con arco.</font></font><br><br><table><tbody><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El nombre del objeto.</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animaci√≥n en ejecuci√≥n</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resultado final</font></font></b> <br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hotel </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comprar </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -10 al hambre </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hotel </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dormir </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -50 a la fatiga </font></font><br><br></td></tr><tr><td>  La biblioteca <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Leer libro </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +10 Habilidad de lanzamiento de hechizos </font></font><br><br></td></tr><tr><td>  La biblioteca <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Leer libro </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +5 habilidad de tiro con arco </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si ya tenemos el comportamiento de "practicar tiro con arco", incluso si marcamos la biblioteca como un lugar para ARCHERY-TRAINING, lo m√°s probable es que necesitemos un caso especial para procesar la animaci√≥n del libro de lectura en lugar de la animaci√≥n habitual de lucha con espadas. </font><font style="vertical-align: inherit;">Este sistema nos brinda m√°s flexibilidad al mover estas asociaciones a datos y almacenar datos en el mundo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La existencia de objetos o ubicaciones (bibliotecas, hoteles o escuelas) nos informa sobre los servicios que ofrecen, sobre el personaje que puede obtenerlos y le permite utilizar una peque√±a cantidad de animaciones. </font><font style="vertical-align: inherit;">La capacidad de tomar decisiones simples sobre los resultados le permite crear una variedad de comportamientos interesantes. </font><font style="vertical-align: inherit;">En lugar de esperar pasivamente una solicitud, estos objetos pueden proporcionar una gran cantidad de informaci√≥n sobre c√≥mo y por qu√© usarlos.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Curvas de reacci√≥n </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A menudo hay una situaci√≥n en la que parte del estado del mundo se puede medir como un valor continuo. </font></font> Ejemplos: <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El "porcentaje de salud" generalmente var√≠a de 0 (muerto) a 100 (absolutamente saludable) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La "distancia al enemigo m√°s cercano" var√≠a de 0 a alg√∫n valor positivo arbitrario </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s, el juego puede tener alg√∫n aspecto del sistema de IA, que requiere la entrada de valores continuos en alg√∫n otro intervalo. Por ejemplo, para tomar una decisi√≥n de huir, un sistema de clasificaci√≥n de servicios p√∫blicos puede requerir tanto la distancia al enemigo m√°s cercano como la salud actual del personaje. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, el sistema no puede simplemente sumar dos valores del estado del mundo para obtener un cierto nivel de "seguridad", porque estas dos unidades de medida son incomparables: los sistemas supondr√°n que un personaje casi muerto a 200 metros del enemigo est√° en la misma seguridad que es absolutamente saludable personaje a 100 metros del enemigo. Adem√°s, si bien el valor porcentual de salud en un sentido amplio es lineal, la distancia no lo es: la diferencia de distancia del enemigo a 200 y 190 metros es menos significativa que la diferencia entre 10 metros y cero.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idealmente, necesitamos una soluci√≥n que tome dos indicadores y los convierta en intervalos similares para que puedan compararse directamente. Y necesitamos que los dise√±adores puedan controlar c√≥mo se calculan estas transformaciones para controlar la importancia relativa de cada valor. Para este prop√≥sito se utilizan curvas de reacci√≥n (curvas de respuesta). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La forma m√°s f√°cil de explicar la curva de reacci√≥n es como un gr√°fico con entrada a lo largo del eje X, valores arbitrarios, por ejemplo, "distancia al enemigo m√°s cercano" y salida a lo largo del eje Y (generalmente un valor normalizado en el rango de 0.0 a 1.0). Una l√≠nea o curva en el gr√°fico determina la uni√≥n de la entrada a la salida normalizada, y los dise√±adores ajustan estas l√≠neas para obtener el comportamiento que necesitan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para calcular el nivel de "seguridad", puede mantener la linealidad de los valores de porcentaje de salud, por ejemplo, 10% m√°s de salud, esto generalmente es bueno cuando el personaje se lastima gravemente y cuando se lesiona f√°cilmente. </font><font style="vertical-align: inherit;">Por lo tanto, asignamos estos valores al intervalo de 0 a 1 de manera directa:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e3f/65f/9a9/e3f65f9a90b2557c5408e529c477fb12.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La distancia al enemigo m√°s cercano es ligeramente diferente, por lo que no nos molestan en absoluto los enemigos m√°s all√° de cierta distancia (digamos 50 metros), y estamos mucho m√°s interesados ‚Äã‚Äãen las diferencias a corta distancia que a larga distancia. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ vemos que la salida de "seguridad" para los enemigos a 40 y 50 metros es casi la misma: 0.96 y 1.0.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b7/8bf/be7/9b78bfbe758bf8407a3abe44b430e7a5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, hay una diferencia mucho mayor entre el enemigo a 15 metros (aproximadamente 0.5) y el enemigo a 5 metros (aproximadamente 0.2). Tal horario refleja mejor la importancia de que el enemigo se acerque. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al normalizar ambos valores en el rango de 0 a 1, podemos calcular el valor de seguridad total como el promedio de estos dos valores de entrada. Un personaje con un 20% de salud y un enemigo a 50 metros tendr√° una puntuaci√≥n de seguridad de 0.6. Un personaje con un 75% de salud y un enemigo a solo 5 metros de distancia tendr√° una puntuaci√≥n de seguridad de 0.47. Un personaje gravemente herido con un 10% de salud y un enemigo de 5 metros tendr√° un √≠ndice de seguridad de solo 0.145. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo siguiente debe considerarse aqu√≠:</font></font><br><br><ul><li>              ‚Äî                  ,   . </li><li>         ‚Äî ,  ,   50  ‚Äî      ,    ,      . </li><li>        ,   (  )        .       ,       ‚Äî ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">Unity AnimationCurve</a>    ,           . </li></ul><br><h2> Blackboards </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A menudo nos encontramos en una situaci√≥n en la que la IA del agente debe comenzar a controlar el conocimiento y la informaci√≥n obtenidos durante el juego para que puedan utilizarse en la toma de decisiones adicionales. Por ejemplo, un agente puede necesitar recordar qu√© √∫ltimo personaje atac√≥ para enfocarse en los ataques de ese personaje por un corto tiempo. O debe recordar cu√°nto tiempo ha pasado despu√©s de escuchar un ruido, para que despu√©s de un cierto per√≠odo de tiempo deje de buscar sus razones y regrese a sus estudios anteriores. Muy a menudo, el sistema de registro de datos est√° muy separado del sistema de lectura de datos, por lo que debe ser f√°cilmente accesible desde el agente y no integrarse directamente en varios sistemas de inteligencia artificial. La lectura puede ocurrir alg√∫n tiempo despu√©s de la escritura, por lo que los datos deben almacenarse en alg√∫n lugar,para que puedan recuperarse m√°s tarde (y no calcularse a pedido, lo que puede no ser factible).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En un sistema de IA codificado, la soluci√≥n puede ser agregar las variables necesarias en el proceso de la necesidad. Estas variables se relacionan con instancias del personaje o agente, ya sea integrando directamente en √©l o creando una estructura / clase separada para almacenar dicha informaci√≥n. Los procedimientos de IA se pueden adaptar para leer y escribir estos datos. En un sistema simple, esto funcionar√° bien, pero a medida que se agrega m√°s informaci√≥n, se vuelve engorroso y generalmente requiere reconstruir el juego cada vez.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un mejor enfoque es convertir el almac√©n de datos en una estructura que permita a los sistemas leer y escribir datos arbitrarios. Esta soluci√≥n le permite agregar nuevas variables sin la necesidad de cambiar la estructura de datos, proporcionando as√≠ la capacidad de aumentar la cantidad de cambios que se pueden hacer desde archivos de datos y secuencias de comandos sin la necesidad de volver a montar. Si cada agente simplemente almacena una lista de pares clave-valor, cada uno de los cuales es un conocimiento separado, entonces diferentes sistemas de IA pueden cooperar agregando y leyendo esta informaci√≥n si es necesario.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el desarrollo de la IA, estos enfoques se denominan "pizarras" ("pizarras"), porque cada participante, en nuestro caso, los procedimientos de IA (por ejemplo, percepci√≥n, encontrar un camino y tomar decisiones), puede escribir en la "pizarra", leer desde donde los datos para el desempe√±o de su tarea pueden ser cualquier otro participante. Puedes imaginar esto como un equipo de expertos reunidos alrededor del pizarr√≥n y escribiendo algo √∫til sobre √©l que necesitas compartir con el grupo. Al mismo tiempo, pueden leer las notas anteriores de sus colegas hasta que lleguen a una decisi√≥n o plan conjunto. Una lista codificada de variables comunes en el c√≥digo a veces se denomina "pizarra est√°tica" (porque los elementos en los que se almacena la informaci√≥n son constantes durante la ejecuci√≥n del programa), y una lista arbitraria de pares clave-valor a menudo se denomina "pizarra din√°mica".Pero se usan aproximadamente de la misma manera, como un enlace intermedio entre partes del sistema de IA.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la IA tradicional, generalmente se hace hincapi√© en la colaboraci√≥n de diferentes sistemas para la toma de decisiones conjunta, pero relativamente pocos sistemas est√°n presentes en la IA del juego. </font><font style="vertical-align: inherit;">Sin embargo, un cierto grado de cooperaci√≥n a√∫n puede estar presente. </font><font style="vertical-align: inherit;">Imagine lo siguiente en un juego de rol de acci√≥n:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El sistema de "percepci√≥n" escanea regularmente el √°rea y escribe las siguientes entradas en la pizarra: </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enemigo m√°s cercano: Goblin 412 </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "Distancia al enemigo m√°s cercano": 35.0 </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "Amigo cercano": "Guerrero 43" </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "Distancia al amigo m√°s cercano": 55.4 </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "Hora del √∫ltimo ruido notado": 12:45 pm </font></font></li></ul></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Los sistemas como un sistema de combate pueden registrar eventos clave en una pizarra, por ejemplo: </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √öltimo da√±o recibido: 12:34 pm </font></font></li></ul></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muchos de estos datos pueden parecer redundantes: al final, siempre puede obtener la distancia al enemigo m√°s cercano, simplemente sabiendo qui√©n es este enemigo y cumpliendo una solicitud para su posici√≥n. Pero cuando se repite varias veces por cuadro, para decidir si un agente est√° amenazando algo o no, esto se convierte en una operaci√≥n potencialmente lenta, especialmente si necesita realizar una consulta espacial para determinar el enemigo m√°s cercano. Y las marcas de tiempo del "√∫ltimo ruido detectado" o del "√∫ltimo da√±o recibido" a√∫n no podr√°n ser instant√°neas; debe registrar la hora en que ocurrieron estos eventos, y la pizarra es un lugar conveniente para esto.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unreal Engine 4 utiliza un sistema de pizarra din√°mica para almacenar datos transmitidos por √°rboles de comportamiento. </font><font style="vertical-align: inherit;">Gracias a este objeto de datos com√∫n, los dise√±adores pueden escribir f√°cilmente nuevos valores en el pizarr√≥n en funci√≥n de sus planos (guiones visuales), y el √°rbol de comportamiento luego puede leer estos valores para seleccionar el comportamiento, y todo esto no requiere la recompilaci√≥n del motor.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mapas de influencia </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La tarea est√°ndar en AI es decidir a d√≥nde debe moverse el agente. </font><font style="vertical-align: inherit;">En el tirador podemos elegir la acci√≥n "Mover al refugio", pero ¬øc√≥mo decidir d√≥nde est√° el refugio en las condiciones de mover enemigos? </font><font style="vertical-align: inherit;">De manera similar a la acci√≥n "Escape", ¬ød√≥nde est√° la forma m√°s segura de escapar? </font><font style="vertical-align: inherit;">O en RTS, es posible que necesitemos que las tropas ataquen un punto d√©bil en defensa del enemigo. ¬øC√≥mo determinamos d√≥nde est√° este punto d√©bil?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todas estas preguntas pueden considerarse tareas geogr√°ficas, porque hacemos una pregunta sobre la geometr√≠a y la forma del entorno y la posici√≥n de las entidades en √©l. En nuestro juego, todos estos datos probablemente ya est√©n disponibles, pero darles sentido no es una tarea f√°cil. Por ejemplo, si queremos encontrar un punto d√©bil en la defensa del enemigo, simplemente elegir la posici√≥n del edificio o fortificaci√≥n m√°s d√©bil no es lo suficientemente bueno si tienen dos poderosos sistemas de armas en los flancos. Necesitamos una forma de tener en cuenta el √°rea local y dar un mejor an√°lisis de la situaci√≥n.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para eso es la estructura de datos del "mapa de influencia". Describe la "influencia" que una entidad puede tener en el √°rea a su alrededor. Combinando la influencia de varias entidades, creamos una visi√≥n m√°s realista de todo el paisaje. Desde el punto de vista de la implementaci√≥n, aproximamos el mundo del juego al superponerle una cuadr√≠cula 2D y, despu√©s de determinar en qu√© celda de la cuadr√≠cula se encuentra la entidad, aplicamos una evaluaci√≥n de impacto a esta y a las celdas circundantes que indican el aspecto del juego que queremos simular. Para obtener una imagen completa, acumulamos estos valores en la misma cuadr√≠cula. Despu√©s de eso, podemos realizar varias consultas de cuadr√≠cula para comprender el mundo y decidir sobre el posicionamiento y los puntos de destino.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tomemos, por ejemplo, "el punto m√°s d√©bil en la defensa del enemigo". </font><font style="vertical-align: inherit;">Tenemos un muro defensivo, cuyo ataque queremos enviar soldados de a pie, pero hay 3 catapultas detr√°s de √©l: 2 cerca uno del otro a la izquierda, 1 a la derecha. </font><font style="vertical-align: inherit;">¬øC√≥mo elegimos una buena posici√≥n de ataque? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para empezar, podemos asignar +1 puntos de protecci√≥n a todas las celdas de la cuadr√≠cula dentro del ataque de catapulta. </font><font style="vertical-align: inherit;">Dibujar estos puntos en el mapa de influencia para una catapulta se ve as√≠:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ce/e37/df8/0cee37df8083ed361e0bf7362a7e5666.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El rect√°ngulo azul limita todas las celdas en las que puedes lanzar un ataque contra la pared. </font><font style="vertical-align: inherit;">Los cuadrados rojos indican +1 influencia de catapulta. </font><font style="vertical-align: inherit;">En nuestro caso, esto significa el √°rea de su ataque y la amenaza a las unidades atacantes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora agregamos el efecto de la segunda catapulta:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db9/e7f/ef1/db9e7fef10229a2f5a38108197548490.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenemos un √°rea oscura en la que se forma la influencia de dos catapultas, lo que les da a estas c√©lulas protecci√≥n +2. ¬°La celda +2 dentro de la zona azul puede ser un lugar particularmente peligroso para atacar la pared! Agregue la influencia de la √∫ltima catapulta:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1aa/da0/6d7/1aada06d7ea16ef8e2e6bca315c196c5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Iconos: CC-BY: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://game-icons.net/heavenly-dog/originals/defensive-wall.html</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora tenemos una designaci√≥n completa del √°rea cubierta por las catapultas. En la zona de ataque potencial, hay una celda con influencias de catapulta +2, 11 celdas con influencia de +1 y 2 celdas con influencia de catapulta 0: estos son los principales candidatos para la posici√≥n de ataque, en ellos podemos atacar la pared sin temor al fuego de catapulta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La ventaja de los mapas de influencia es que transforman un espacio continuo con un conjunto casi infinito de posibles posiciones en un conjunto discreto de posiciones aproximadas, con respecto al cual podemos tomar decisiones muy r√°pidamente.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, obtuvimos esta ventaja solo al elegir un peque√±o n√∫mero de posibles posiciones de ataque. ¬øPor qu√© deber√≠amos usar el mapa de influencia aqu√≠ en lugar de verificar manualmente la distancia desde cada catapulta a cada una de estas posiciones? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En primer lugar, calcular un mapa de influencia puede ser muy econ√≥mico. Despu√©s de poner los puntos de influencia en la carta, no es necesario cambiarla hasta que las entidades comiencen a moverse. Esto significa que no necesitamos realizar c√°lculos de distancia constantemente o interrogar iterativamente a todas las unidades posibles: ‚Äúhorneamos‚Äù esta informaci√≥n en el mapa y podemos enviarle solicitudes cualquier n√∫mero de veces.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En segundo lugar, podemos superponer y combinar diferentes mapas de influencia para cumplir consultas m√°s complejas. </font><font style="vertical-align: inherit;">Por ejemplo, para seleccionar un lugar seguro para escapar, podemos tomar un mapa de la influencia de nuestros enemigos y restar el mapa de nuestros amigos: las celdas de la cuadr√≠cula con el mayor valor negativo se considerar√°n seguras.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/726/4db/e7b/7264dbe7b1834f3602b36deddc723163.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuanto m√°s rojo, m√°s peligroso y m√°s verde, m√°s seguro. </font><font style="vertical-align: inherit;">Las √°reas en las que se superponen las influencias pueden neutralizarse total o parcialmente para reflejar √°reas de influencia en conflicto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, los mapas de influencia son f√°ciles de visualizar al renderizar en el mundo. </font><font style="vertical-align: inherit;">Pueden ser una sugerencia valiosa para los dise√±adores que necesitan personalizar la IA en funci√≥n de las propiedades visibles, y pueden ser observados en tiempo real para comprender por qu√© la IA elige sus decisiones.</font></font><br><br><h1>  Conclusi√≥n </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espero que el art√≠culo te brinde una descripci√≥n general de las herramientas y enfoques m√°s populares utilizados en la IA de los juegos, as√≠ como las situaciones en las que se pueden aplicar. </font><font style="vertical-align: inherit;">El art√≠culo no consider√≥ muchas otras t√©cnicas (se usan con menos frecuencia, pero podr√≠an ser igualmente efectivas), incluidas las siguientes:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> algoritmos de tareas de optimizaci√≥n, incluida la escalada a la cima, el descenso del gradiente y los algoritmos gen√©ticos. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> algoritmos competitivos de b√∫squeda / planificaci√≥n como minimax y recorte alfa beta </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> t√©cnicas de clasificaci√≥n, por ejemplo, perceptrones, redes neuronales y el m√©todo del vector de soporte </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sistemas de percepci√≥n de agentes y procesamiento de memoria </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> enfoques arquitect√≥nicos de la IA, como sistemas h√≠bridos, arquitecturas predicativas (arquitecturas de Brooks) y otras formas de descomponer los sistemas de IA en capas </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> herramientas de animaci√≥n como planificaci√≥n de movimiento y coincidencia de movimiento </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tareas relacionadas con el rendimiento, como el nivel de detalle, los algoritmos en cualquier momento y la temporizaci√≥n </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para leer m√°s sobre estos temas, as√≠ como los temas discutidos en este art√≠culo, puede estudiar las siguientes fuentes. </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameDev.net tiene </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">art√≠culos y tutoriales sobre inteligencia artificial</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , as√≠ como un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foro sobre inteligencia artificial</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AiGameDev.com</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tener muchas presentaciones y art√≠culos sobre una amplia gama de temas de la inteligencia artificial en el contexto del desarrollo de juegos</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GDC Vault tiene informes con GDC AI Summit, muchos de los cuales est√°n disponibles de forma gratuita: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://www.gdcvault.com/</font></font></a> <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s, el AI Game Programmers Guild tiene un mont√≥n de enlaces a art√≠culos antiguos y presentaciones de esta cumbre: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://gameai.com/</font></font></a> <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El investigador de IA y desarrollador de juegos Tommy Thompson tiene un canal de YouTube dedicado a explicar y explorar la IA en juegos comerciales: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://www.youtube.com/user/tthompso</font></font></a> </li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Muchos de los materiales de la m√°s alta calidad se pueden encontrar en libros, incluidos los siguientes: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Game AI Pro Series es una colecci√≥n de art√≠culos breves que explican c√≥mo implementar funciones espec√≠ficas o resolver problemas espec√≠ficos. </font><font style="vertical-align: inherit;">En </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://www.gameaipro.com/</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> publicaron fragmentos gratuitos de libros anteriores.</font></font><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=http://go.gamedev.net/%3Fid%3D13722X707581%26amp%3Bxs%3D1%26amp%3Bisjs%3D1%26amp%3Burl%3Dhttps%253A%252F%252Famzn.to%252F2KGoB8n%26amp%3Bxguid%3Df8ad586e5984991508efff4754027dbd%26amp%3Bxuuid%3D305451ecead59d76ca830fded0aab276%26amp%3Bxsessid%3D6ccb8b9fa3f10b478b65f7ed703a447b%26amp%3Bxcreo%3D0%26amp%3Bxed%3D0%26amp%3Bsref%3Dhttps%253A%252F%252Fwww.gamedev.net%252Farticles%252Fprogramming%252Fartificial-intelligence%252Fthe-total-beginners-guide-to-game-ai-r4942%252F%253Fdo%253Dedit%2526d%253D1%2526id%253D4942%2526csrfKey%253D7015c6d2c5c643e87baa74f8e5d2c094%26amp%3Bpref%3D" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Game AI Pro: Sabidur√≠a recopilada de profesionales de Game AI</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=http://go.gamedev.net/%3Fid%3D13722X707581%26amp%3Bxs%3D1%26amp%3Bisjs%3D1%26amp%3Burl%3Dhttps%253A%252F%252Famzn.to%252F2KFKyoe%26amp%3Bxguid%3Df8ad586e5984991508efff4754027dbd%26amp%3Bxuuid%3D305451ecead59d76ca830fded0aab276%26amp%3Bxsessid%3D6ccb8b9fa3f10b478b65f7ed703a447b%26amp%3Bxcreo%3D0%26amp%3Bxed%3D0%26amp%3Bsref%3Dhttps%253A%252F%252Fwww.gamedev.net%252Farticles%252Fprogramming%252Fartificial-intelligence%252Fthe-total-beginners-guide-to-game-ai-r4942%252F%253Fdo%253Dedit%2526d%253D1%2526id%253D4942%2526csrfKey%253D7015c6d2c5c643e87baa74f8e5d2c094%26amp%3Bpref%3D" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Game AI Pro 2: Sabidur√≠a recopilada de los profesionales de Game AI</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Game AI Pro 3: Sabidur√≠a recopilada de los profesionales de Game AI</font></font></a> <br></li></ul><br></li><li>  AI Game Programming Wisdom    Game AI Pro.      ,       .    ,          ! <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">AI Game Programming Wisdom 1</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">AI Game Programming Wisdom 2</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">AI Game Programming Wisdom 3</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">AI Game Programming Wisdom 4</a> <br></li></ul></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">Artificial Intelligence: A Modern Approach</a> ‚Äî      ,        .       ,     ,         ,      . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s, hay varios buenos libros sobre juegos de IA en general, escritos por profesionales de la industria. </font><font style="vertical-align: inherit;">Es dif√≠cil dar preferencia a cualquiera: lea las rese√±as y elija la que m√°s le convenga.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es420219/">https://habr.com/ru/post/es420219/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es420205/index.html">ROM basadas en ADN, memoria de √°cido nucleico y sustratos para OxRAM</a></li>
<li><a href="../es420209/index.html">OpenAI demuestra la transferencia de manipulaciones complejas de simulaciones al mundo real</a></li>
<li><a href="../es420211/index.html">El pensamiento m√°gico sobre el aprendizaje autom√°tico no acercar√° la IA real</a></li>
<li><a href="../es420213/index.html">Descripci√≥n general de la asequible impresora 3D grande WANHAO D9</a></li>
<li><a href="../es420215/index.html">Consola, interruptores y mucho caf√©: un d√≠a en la vida del alojamiento VDS</a></li>
<li><a href="../es420221/index.html">Los atacantes piratearon miles de enrutadores D-link y redirigieron a sus propietarios a recursos maliciosos</a></li>
<li><a href="../es420223/index.html">Algunos consejos simples: c√≥mo evitar da√±os al dron</a></li>
<li><a href="../es420225/index.html">Melod√≠a algor√≠tmica infinita basada en n√∫meros primos</a></li>
<li><a href="../es420227/index.html">El presidente turco anuncia la prohibici√≥n de importar productos electr√≥nicos en EE. UU.</a></li>
<li><a href="../es420229/index.html">¬øPueden los ni√±os de las aldeas convertirse en programadores si en las cercan√≠as solo ense√±an trabajadores ferroviarios? Conversaci√≥n con el "C√≠rculo"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>