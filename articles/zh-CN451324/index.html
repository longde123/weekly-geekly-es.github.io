<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👢 ✊🏾 👍🏼 Swift和iOS Universe中的工厂方法和抽象工厂 🙍🏼 🎿 ⬜️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="到目前为止，“工厂”一词是程序员在讨论他们（或其他）程序时最常用的词之一。 但是其中所含的含义可能非常不同：它可以是一个生成对象的类（是否为多态的）； 和创建任何类型（静态或非静态）实例的方法； 它发生了，甚至任何生成方法（包括构造方法）都发生了。 

 当然，并不是所有生成任何事物实例的事物都可以...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Swift和iOS Universe中的工厂方法和抽象工厂</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451324/">到目前为止，“工厂”一词是程序员在讨论他们（或其他）程序时最常用的词之一。 但是其中所含的含义可能非常不同：它可以是一个生成对象的类（是否为多态的）； 和创建任何类型（静态或非静态）实例的方法； 它发生了，甚至任何生成方法（包括<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">构造</a>方法）都发生了。 <br><br> 当然，并不是所有生成任何事物实例的事物都可以称为“工厂”一词。 此外，用这个词可以隐藏来自“四人帮”武器库的两种不同的生成方式- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“工厂方法”</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“抽象工厂”</a> ，我想深入研究它们的细节，并特别注意它们的经典理解和实现。 <a name="habracut"></a><br><br> 我受到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Joshua Kerivsky</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“工业逻辑”负责人</a> ）的启发，或者更确切地说，是他的著作<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ Repating to Patterns”</a> ，这本书是本世纪初出版的，该书是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Martin Fowler</a> （现代编程经典著作的著名作者，该书<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“重构“</a> ）。 如果某人没有阅读甚至没有听说过第一本书（而且我知道很多），那么请确保将其添加到您的阅读清单中。 这是重构和更经典的《 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">目标设计技术》</a>一书的续集<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">设计模式</a> 。 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“</a> <br><br> 本书除其他外，包含数十种使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">设计模式</a>摆脱代码中各种<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“气味”</a>的秘诀。 包括有关所讨论主题的三（至少）条“食谱”。 <br><br><h2> 抽象工厂 </h2><br>  Kerivsky在他的书中给出了两种使用该模板的情况。 <br><br> 首先是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">封装</a>有关通过公共接口连接的特定类<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a>知识。 在这种情况下，只有工厂类型才具有此知识。 工厂的公共<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">API</a>将由一组方法（无论是否静态）组成，这些方法返回一个通用接口类型的实例并具有一些“对话”名称（以便了解出于特定目的需要调用哪种方法）。 <br><br> 第二个示例与第一个示例非常相似（通常，使用该模式的所有场景或多或少都彼此相似）。 当在程序的不同位置创建同一组的一种或多种类型的实例时，就是这种情况。 在这种情况下，工厂将再次封装有关创建实例的代码的知识，但动机有所不同。 例如，如果创建这些类型的实例的过程很复杂，并且不仅限于调用构造函数，则尤其如此。 <br><br> 为了更接近<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ iOS”</a>下的开发主题，可以方便地练习<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>UIViewController</code></a>子类。 实际上，这绝对是“ iOS”开发中最常见的类型之一，几乎总是在使用前“继承”，并且特定的子类对于客户端代码通常甚至都不重要。 <br><blockquote> 我将尝试使代码示例尽可能接近《四人帮》一书中的经典实现，但是在现实生活中，通常会以一种或另一种方式简化代码。 只有对模板有足够的了解，才能为模板提供更多的免费使用机会。 </blockquote><h3> 详细的例子 </h3><br> 假设我们在应用程序中交易车辆，并且映射取决于特定车辆的类型：我们将针对不同车辆使用<code>UIViewController</code>不同子类。 此外，所有车辆的状态（新旧）有所不同： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VehicleCondition</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> new <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> used } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BicycleViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> condition: <span class="hljs-type"><span class="hljs-type">VehicleCondition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(condition: <span class="hljs-type"><span class="hljs-type">VehicleCondition</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.condition = condition <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(nibName: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, bundle: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">required</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>?(coder aDecoder: <span class="hljs-type"><span class="hljs-type">NSCoder</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>(<span class="hljs-string"><span class="hljs-string">"BicycleViewController: init(coder:) has not been implemented."</span></span>) } } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScooterViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> condition: <span class="hljs-type"><span class="hljs-type">VehicleCondition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(condition: <span class="hljs-type"><span class="hljs-type">VehicleCondition</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.condition = condition <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(nibName: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, bundle: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">required</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>?(coder aDecoder: <span class="hljs-type"><span class="hljs-type">NSCoder</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>(<span class="hljs-string"><span class="hljs-string">"ScooterViewController: init(coder:) has not been implemented."</span></span>) } }</code> </pre> <br> 因此，我们有一组对象的一组，根据某些条件（例如，用户单击列表中的产品，并根据其是踏板车还是自行车），在同一位置创建其类型的实例。创建适当的控制器）。 控制器构造函数具有一些每次都需要设置的参数。 这两个论据是否都赞成建立一个“工厂”，而该工厂仅会了解创建正确控制器的逻辑？ <br><br> 当然，该示例非常简单，并且在类似情况下的实际项目中，引入“工厂”将是明确的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“过度设计”</a> 。 但是，如果我们假设我们没有两种类型的车辆，而设计人员具有多个参数，那么“工厂”的优势将变得更加明显。 <br><br> 因此，让我们声明一个将扮演“抽象工厂”角色的接口： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VehicleViewControllerFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeBicycleViewController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIViewController</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeScooterViewController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIViewController</span></span> }</code> </pre> <br>  （在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Swift中</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，API的</a>简短<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“设计指南”</a>建议以make开头的方法调用工厂方法。） <br><br>  （在“四人帮”一书中，有一个例子是用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ C ++”给出的</a> ，它基于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">继承</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“虚拟”功能</a> 。当然，使用“ Swift”，面向协议的编程范例离我们更近了。） <br><br> 抽象工厂界面仅包含两种方法：创建用于销售自行车和踏板车的控制器。 方法返回的实例不是特定子类的实例，而是公共基类的实例。 因此，有关特定类型的知识范围仅限于真正需要的领域。 <br><br> 作为“具体工厂”，我们将使用抽象工厂接口的两种实现： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NewVehicleViewControllerFactory</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VehicleViewControllerFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeBicycleViewController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIViewController</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">BicycleViewController</span></span>(condition: .new) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeScooterViewController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIViewController</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">ScooterViewController</span></span>(condition: .new) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UsedVehicleViewControllerFactory</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VehicleViewControllerFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeBicycleViewController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIViewController</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">BicycleViewController</span></span>(condition: .used) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeScooterViewController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIViewController</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">ScooterViewController</span></span>(condition: .used) } }</code> </pre> <br> 从代码中可以看出，在这种情况下，特定工厂负责不同条件的车辆（新旧）。 <br><br> 现在，创建正确的控制器将如下所示： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> factory: <span class="hljs-type"><span class="hljs-type">VehicleViewControllerFactory</span></span> = <span class="hljs-type"><span class="hljs-type">NewVehicleViewControllerFactory</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vc = factory.makeBicycleViewController()</code> </pre> <br><h3> 工厂封装类 </h3><br> 现在简要介绍一下Kerivsky在他的书中提供的用例。 <br><br> 第一种情况与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">特定类</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">封装有关</a> 。 例如，使用相同的控制器来显示有关车辆的数据： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BicycleViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScooterViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br> 假设我们正在处理一个单独的模块，例如，一个插件库。 在这种情况下，上述声明的类（默认情况下）保持为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>internal</code></a> ，并且工厂<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>internal</code></a>库的公共“ API”，该库在其方法中返回控制器的基类，从而将有关特定子类的知识留在库中： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VehicleViewControllerFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeBicycleViewController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIViewController</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">BicycleViewController</span></span>() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeScooterViewController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIViewController</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">ScooterViewController</span></span>() } }</code> </pre> <br><h3> 在工厂内部移动有关创建对象的知识 </h3><br> 第二个“案例”描述了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">对象</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">复杂初始化</a> ，而Kerivsky作为简化代码和保护封装原理的一种方法，建议限制关于初始化过程的知识在工厂外的传播。 <br><br> 假设我们想同时出售汽车。 无疑，这是一种更复杂的技术，具有更多的特征。 例如，我们将自己限制在所使用的燃料类型，传输类型和轮辋尺寸上： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Condition</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> new <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> used } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EngineType</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> diesel <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> gas } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Engine</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> type: <span class="hljs-type"><span class="hljs-type">EngineType</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TransmissionType</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> automatic <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> manual } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CarViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> condition: <span class="hljs-type"><span class="hljs-type">Condition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> engine: <span class="hljs-type"><span class="hljs-type">Engine</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> transmission: <span class="hljs-type"><span class="hljs-type">TransmissionType</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> wheelDiameter: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(engine: <span class="hljs-type"><span class="hljs-type">Engine</span></span>, transmission: <span class="hljs-type"><span class="hljs-type">TransmissionType</span></span>, wheelDiameter: <span class="hljs-type"><span class="hljs-type">Int</span></span> = <span class="hljs-number"><span class="hljs-number">16</span></span>, condition: <span class="hljs-type"><span class="hljs-type">Condition</span></span> = .new) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.engine = engine <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.transmission = transmission <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.wheelDiameter = wheelDiameter <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.condition = condition <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(nibName: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, bundle: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">required</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>?(coder aDecoder: <span class="hljs-type"><span class="hljs-type">NSCoder</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>(<span class="hljs-string"><span class="hljs-string">"CarViewController: init(coder:) has not been implemented."</span></span>) } }</code> </pre> <br> 相应控制器的初始化示例： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> engineType = <span class="hljs-type"><span class="hljs-type">EngineType</span></span>.diesel <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> engine = <span class="hljs-type"><span class="hljs-type">Engine</span></span>(type: engineType) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> transmission = <span class="hljs-type"><span class="hljs-type">TransmissionType</span></span>.automatic <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> wheelDiameter = <span class="hljs-number"><span class="hljs-number">18</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vc = <span class="hljs-type"><span class="hljs-type">CarViewController</span></span>(engine: engine, transmission: transmission, wheelDiameter: wheelDiameter)</code> </pre> <br> 我们可以将所有这些“小事”的责任放在专业工厂的“肩膀”上： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UsedCarViewControllerFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> engineType: <span class="hljs-type"><span class="hljs-type">EngineType</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> transmissionType: <span class="hljs-type"><span class="hljs-type">TransmissionType</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> wheelDiameter: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeCarViewController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIViewController</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> engine = <span class="hljs-type"><span class="hljs-type">Engine</span></span>(type: engineType) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">CarViewController</span></span>(engine: engine, transmission: transmissionType, wheelDiameter: wheelDiameter, condition: .used) } }</code> </pre> <br> 并以这种方式创建控制器： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> factory = <span class="hljs-type"><span class="hljs-type">UsedCarViewControllerFactory</span></span>(engineType: .gas, transmissionType: .manual, wheelDiameter: <span class="hljs-number"><span class="hljs-number">17</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vc = factory.makeCarViewController()</code> </pre> <br><h2> 工厂方法 </h2><br> 第二个“单根”模板还封装了有关特定生成类型的知识，但不是通过将这种知识隐藏在专门的类中而是通过多态来封装。  Kerivsky在他的书中用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Java</a>给出了示例，并建议使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">抽象类</a> ，但是Swift宇宙的居民并不熟悉这个概念。 我们在这里有自己的氛围...和协议。 <br><blockquote>  《四人帮》一书报道该模板也被称为“虚拟构造函数”，这并非徒劳。 在“ C ++”中，虚函数是在派生类中重新定义的函数。 该语言没有给设计者提供声明虚拟的机会，并且可能是试图模仿导致这种模式发明的预期行为。 </blockquote><h3> 多态对象创建 </h3><br> 作为模板有用性的经典示例，我们考虑以下情况： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在层次结构中，不同类型具有相同方法的一种实现，但在该方法中创建和使用的对象除外</a> 。 作为解决方案，提出了以单独的方法创建该对象并单独实现该对象的方法，并在层次结构中将通用方法提高了。 因此，不同类型将使用该方法的一般实现，并且此方法所需的对象将被多态创建。 <br><br> 例如，让我们返回到用于显示车辆的控制器： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BicycleViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScooterViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br> 并假设使用某个实体来显示它们，例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">coordinator</a> ，它从另一个控制器模态地表示这些控制器： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Coordinator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> presentingViewController: <span class="hljs-type"><span class="hljs-type">UIViewController?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> }</code> </pre> <br> 除了创建不同的控制器外， <code>start()</code>方法始终以相同的方式使用： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BicycleCoordinator</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Coordinator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> presentingViewController: <span class="hljs-type"><span class="hljs-type">UIViewController?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vc = <span class="hljs-type"><span class="hljs-type">BicycleViewController</span></span>() presentingViewController?.present(vc, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) } } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScooterCoordinator</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Coordinator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> presentingViewController: <span class="hljs-type"><span class="hljs-type">UIViewController?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vc = <span class="hljs-type"><span class="hljs-type">ScooterViewController</span></span>() presentingViewController?.present(vc, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) } }</code> </pre> <br> 提出的解决方案是通过一种单独的方法来创建所使用的对象： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Coordinator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> presentingViewController: <span class="hljs-type"><span class="hljs-type">UIViewController?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeViewController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIViewController</span></span> }</code> </pre> <br> 主要方法是提供基本实现： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Coordinator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vc = makeViewController() presentingViewController?.present(vc, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) } }</code> </pre> <br> 在这种情况下，特定类型将采用以下形式： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BicycleCoordinator</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Coordinator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> presentingViewController: <span class="hljs-type"><span class="hljs-type">UIViewController?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeViewController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIViewController</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">BicycleViewController</span></span>() } } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScooterCoordinator</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Coordinator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> presentingViewController: <span class="hljs-type"><span class="hljs-type">UIViewController?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeViewController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIViewController</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">ScooterViewController</span></span>() } }</code> </pre> <br><h2> 结论 </h2><br> 我试图通过结合三种方法来涵盖这个简单的主题： <br><br><ul><li> 受“四人帮”一书的启发，对接待处存在的经典宣言； </li><li> 使用动机，受Kerivsky的书公开启发； </li><li> 应用程序应用程序作为我附近编程行业的一个示例。 </li></ul><br> 同时，我尝试尽可能地接近模板的教科书结构，而不破坏iOS系统现代开发方法的原理并使用Swift语言的功能（而不是更常见的C ++和Java）。 <br><br> 事实证明，要找到包含应用示例的主题的详细材料相当困难。 现有的大多数文章和手册仅包含表面的评论和删节的示例，与实施的教科书版本相比，它们已经被截断了。 <br><br> 我希望至少部分能够实现自己的目标，并且读者-至少部分对学习或更新有关此主题的知识感兴趣或至少好奇。 <br><br>  <b>我关于设计模式的其他材料：</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ iOS”和“ Swift”的宇宙中的“建筑模板” Visitor”（“ Visitor”）</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Swift宇宙中的迭代器架构模式</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ Swift”和“ iOS” /“ macOS”的“建筑模式” Builder”</a> </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b>这是我的“ Twitter”的链接，我在其中发布文章的链接，还有更多内容。</b></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN451324/">https://habr.com/ru/post/zh-CN451324/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN451314/index.html">从A到Z的印刷电路板LUT'om生产</a></li>
<li><a href="../zh-CN451316/index.html">关于物理系</a></li>
<li><a href="../zh-CN451318/index.html">Dart 2.3发布：针对用户界面开发进行了优化</a></li>
<li><a href="../zh-CN451320/index.html">为什么开放式固件对安全性很重要</a></li>
<li><a href="../zh-CN451322/index.html">在Java 8和11时代，“实践中的Java并发性”这本书是否有用？</a></li>
<li><a href="../zh-CN451326/index.html">3CX V16 Update 1 Beta-用于以编程方式管理呼叫的新聊天和呼叫流程服务功能</a></li>
<li><a href="../zh-CN451330/index.html">广播中听到了什么？ 第三部分，火腿收音机/火腿收音机</a></li>
<li><a href="../zh-CN451332/index.html">丙型肝炎：“深情杀手”</a></li>
<li><a href="../zh-CN451334/index.html">宣布ML.NET 1.0</a></li>
<li><a href="../zh-CN451336/index.html">GitHub软件包注册表介绍</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>