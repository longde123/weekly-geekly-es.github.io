<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚬 👋🏼 ☘️ Berbahaya bagi cahaya, atau bagaimana menjaga baterai mobil tetap kosong 👩🏻‍🏭 🥚 👲🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya melanjutkan serangkaian artikel tentang konstruksi sepeda di bidang manajemen sirkuit listrik bertegangan rendah. Kali ini saya akan berbicara te...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Berbahaya bagi cahaya, atau bagaimana menjaga baterai mobil tetap kosong</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446956/">  Saya melanjutkan serangkaian artikel tentang konstruksi sepeda di bidang manajemen sirkuit listrik bertegangan rendah.  Kali ini saya akan berbicara tentang perangkat yang mencegah pelepasan aki mobil yang dalam oleh berbagai konsumen sekunder. <br><br><img src="https://habrastorage.org/webt/_p/pt/zv/_pptzvndfwivnln2xsqz7aae224.jpeg"><br>  <i>Salah satu konsekuensi yang mungkin terjadi dari pemulangan yang tidak terkendali.</i> <br><a name="habracut"></a><br>  Membeli mobil atau motor pertama adalah tonggak penting dalam kehidupan setiap orang, dan terutama seorang insinyur.  Lagi pula, siapa lagi selain keuntungan nyata dari kuda besi barunya yang segera memperhatikan kerugiannya yang tidak jelas?  Siapa yang segera mulai berpikir tentang perbaikan dan penambahan standar?  Tentu saja, jika ini adalah mobil dari segmen atas, dan bahkan merek "modis", maka pada awalnya mungkin tampak bahwa ia memiliki segalanya.  Tetapi, seperti yang ditunjukkan oleh latihan, dalam hal ini, waktu membantah kesan pertama.  Jika Anda membeli mobil kelas ekonomi, maka tangan Anda mulai terasa gatal pada hari pertama! <br><br>  Keinginan untuk "mengisi" mobil Anda dengan berbagai perangkat elektronik tambahan sangat wajar.  Namun, segera setelah implementasi semua rencana ini, hidup berhadapan dengan pemilik mobil dengan kenyataan pahit.  Ternyata bahkan perangkat paling modern yang dibangun di atas dasar elemen terbaru masih cukup bersemangat untuk listrik.  Dan aki mobil yang tampak sangat besar sama sekali bukan reaktor nuklir, dan dapat dengan mudah "duduk" di bawah beban semua konsumen yang tampaknya tidak berbahaya ini dalam beberapa hari. <br><br>  Agar tidak mengalir lebih jauh ke dalam situasi abstrak dan hipotetis, saya akan langsung menuju cerita saya.  Setelah membeli mobil, yang pertama adalah keinginan untuk memasukkan pendaftar di dalamnya.  Ini dilakukan dalam waktu sesingkat mungkin, hampir sepenuhnya ditentukan oleh kecepatan pengiriman paket dari AliExpress.  Jelas bahwa catu daya reguler dari pemantik rokok sangat tidak nyaman, dan perekam dengan cepat mendapatkan koneksi stasioner ke saluran terdekat dari jaringan on-board melalui konverter pulsa 12 / 5v.  Dan sejak itu  itu, secara sederhana, bukan kemarin, konverter ini bahkan tidak modern, untuk kebutuhannya sendiri, ternyata kemudian, ia makan sebanyak 21 mA saat ini.  Sekarang mari kita perkirakan berapa banyak konverter ini hanya dapat memberi makan baterai baru dan terisi penuh dengan kapasitas 60 Ah.  Aritmatika sangat sederhana dan mengecewakan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lj/kz/tb/ljkztbra63ol-bs6xwdpdxd4xjg.png"></div><br>  Jadi, dalam waktu kurang dari empat bulan, konverter yang tidak dimuat dengan apa pun akan mendaratkan baterai secara harfiah "ke nol".  Jika kita memperhitungkan bahwa baterai yang tidak sepenuhnya segar dapat dengan mudah berubah menjadi janda kurang, dan biaya setelah kota pokatushki jauh dari 100%, hari hujan dengan mudah dimulai dalam waktu sebulan dengan kail. <br><br>  Dan itu saja, saya ulangi, hanya konverter tegangan.  Ya, hari ini Anda dapat membeli konverter yang hanya membutuhkan setengah miliampere untuk kebutuhannya sendiri, tetapi saya memberikan contoh ini hanya untuk menunjukkan seberapa lambat dan percaya diri <s>air menajamkan batu,</s> bahkan remeh, tetapi terus-menerus bertindak, konsumen mengambil energi dari apa yang tampaknya sangat besar baterai. <br><br>  Kita melangkah lebih jauh, perekam dalam mode perekaman FHD @ 30fps mengkonsumsi hampir 300 mA dari sumber + 5v, yang setelah konversi dengan pertimbangan efisiensinya memberikan arus sekitar 150 mA dari jaringan on-board.  Misalkan konverter diganti dengan yang modern, dan kami menghitung waktu pengosongan hanya dengan arus ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uf/p8/fl/ufp8fldn4t5bfzpl8u8udb6fd3o.png"></div><br>  Hanya lebih dari dua minggu, tetapi dalam praktiknya - sepuluh hari.  Sekarang prospek pencahayaan (dan mungkin mengganti baterai) menjulang setelah liburan atau perjalanan bisnis berikutnya. <br><br>  Dan begitulah yang terjadi pada saya: ketika saya pergi berlibur singkat dengan terpaksa, saya tidak berpikir bahwa dalam seminggu atau lebih bahkan kunci pusat tidak akan dapat membuka pintu untuk saya. <br><br>  Banyak yang akan mengatakan bahwa itu adalah kesalahan mereka sendiri, bahwa segala sesuatu harus dihilangkan energi, atau setidaknya berhenti merekam, dan mereka akan benar.  Tetapi hidup adalah hidup, dan ingatannya tidak sama, dan berapa lama cuti yang sakit itu berlangsung tidak selalu mungkin diketahui sebelumnya.  Oleh karena itu, gagasan tentang pemutus sirkuit segera muncul. <br><br>  Tentu saja ada opsi untuk menghidupkan perekam dari kunci kontak sehingga hanya berfungsi saat bepergian, tetapi opsi ini juga tidak terlalu, karena  jika mobil menabrak di tempat parkir, saya ingin memiliki kesempatan untuk melihat pelakunya.  Plus, setelah beberapa saat setelah memasang perekam, mobil kekurangan staf dengan beberapa perangkat lagi, termasuk pelacak GPS tersembunyi, yang seharusnya berfungsi, jika tidak sampai akhir, maka setidaknya sampai ketika "hampir semua" sudah ada. <br><br>  Secara umum, selama beberapa minggu refleksi pasif, gagasan perangkat yang harus mengontrol tegangan jaringan on-board dan berdasarkan data ini untuk mengontrol pasokan daya ke dua kelompok konsumen akhirnya terbentuk: sekunder (perekam, soket USB) dan utama (GPS-tracker dan beberapa apa). <br><br><h3>  Bagaimana ini bisa dilakukan </h3><br>  Prototipe virtual pertama perangkat "dibangun" berdasarkan pembanding analog LM393N dan mampu melakukan segala sesuatu yang semula direncanakan akan diterima dari perangkat.  Skema abstrak adalah sesuatu seperti ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cf/la/yb/cflaybsmn6m3e6o7mshcfb_1j20.png"></div><br>  Di sini dua pembanding digunakan untuk mengalihkan beban.  Generator tegangan referensi umum, dua pembagi yang menentukan ambang batas untuk operasi, pengikat pembanding, dua sakelar daya.  Ikatan eksternal perangkat jadi direncanakan sebagai berikut. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0m/77/ew/0m77ewzvozy52h6zr-fg7uaivg0.png"></div><br>  Kunci primer tetap hidup lebih lama daripada kunci sekunder, sehingga konverter step-down itu sendiri diaktifkan melalui itu.  Muatan primer terhubung langsung ke konverter.  Saklar sekunder mengubah beban sekunder yang sudah ada di sirkuit + 5v pada output inverter. <br><br><h3>  Apa yang keluar pada akhirnya </h3><br>  Tampaknya hanya itulah yang diperlukan, tetapi, seperti yang sering terjadi, dengan pemikiran rinciannya, muncul gagasan implementasi alternatif.  Pertama, rangkaian analog berisi segunung elemen diskrit yang menyediakan mode operasi pembanding, dan kedua, ambang perjalanan seharusnya diatur menggunakan resistor trim, yang memperumit pengaturan dan menciptakan kemungkinan “lolos” dari goncangan dan waktu.  Oleh karena itu, pada akhirnya, diputuskan untuk memikirkan implementasi digital, yang ternyata jauh lebih sederhana baik secara skematis dan dalam pengaturan, sambil membuka peluang besar untuk meningkatkan algoritma kontrol, dan, yang paling penting, dalam konteks ini, ternyata menjadi urutan besarnya lebih ekonomis dalam hal konsumsi saat ini. <br><br>  Kontroler ATtiny13A hanya menanyakan inti dari perangkat, yang, selain kemudahan penggunaan dan murahnya, masih tersedia dalam case DIP-hangat tabung hangat untuk oldfag.  Pada awalnya, kemampuan pengendali sekecil itu tampak mubazir di semua lini, mulai dari jumlah input / output hingga jumlah program dan RAM, namun, seperti yang Anda tahu, nafsu makan datang dengan hidangan.  Sebagai hasilnya, melihat ke depan, saya akan mengatakan bahwa versi final dari kasus ini ternyata merupakan semua kesimpulan dari rangkaian mikro, dan memori perangkat lunak bebas tidak meninggalkan lebih dari dua lusin byte. <br><br>  Untuk mengukur tegangan jaringan terpasang, mikrokontroler hanya membutuhkan satu input, yang terhubung ke ADC.  Dua keluaran yang lebih logis adalah mengelola konsumen.  Pertama-tama, setelah transisi mental terakhir ke "digital", ada keinginan untuk mengadaptasi dua GPIO gratis ke bisnis, dan keputusan itu tidak lama datang.  Ketika, sekali lagi, dalam cuaca dingin, starter menghidupkan mesin dengan sobekan yang tersembunyi, keberadaan sensor suhu di sirkuit dan algoritma tampak sangat berguna.  Akibatnya, ADC kedua digunakan untuk mengukur suhu.  Dan agar termistor untuk mengkonsumsi arus hanya ketika diperlukan, diputuskan untuk menyalakannya dari keluaran logis terakhir yang tersisa. <br><br>  Akibatnya, diagram perangkat telah memperoleh bentuk final seperti itu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jh/ct/dt/jhctdt_pol1pk6xum1wwn_n7jzo.png"></div><br>  Di sini kita melihat detail yang sangat minimum, dan di antara mereka tidak ada yang tunduk pada jenis "memutar".  Mari kita bahas secara singkat poin-poin utama. <br><br>  Untuk catu daya, pengontrol memerlukan tegangan stabil dari 1,8 hingga 5,5 V, yang berarti bahwa harus ada stabilizer di sirkuit yang akan menurunkan tegangan jaringan on-board ke level yang diperlukan.  Dari sudut pandang penghematan energi, mungkin terlihat bahwa ada tempat untuk konverter stepdown berdenyut secara eksklusif, tetapi ini hanya pada pandangan pertama.  Faktanya adalah ATtiny13A bahkan dalam mode operasi paling intensif energi (frekuensi 8 MHz, eksekusi kode aktif) mengkonsumsi tidak lebih dari 6 mA.  Dalam skema ini, pengontrol 99% waktu dalam mode tidur nyenyak dan juga beroperasi pada frekuensi 1,2 MHz, menghasilkan konsumsi rata-rata sekitar kurang dari 15 μA.  Plus, sekitar 80 μA ke arus basis dari transistor kontrol (jika kedua beban aktif).  Nah, untuk sepersekian detik, kekuatan termistor diaktifkan, yang menambahkan sekitar 25 microamp ke arus rata-rata.  Dan di sini ada jawaban untuk pertanyaan “apakah layak untuk memuat konverter pulsa demi beban dengan konsumsi tidak lebih dari 120 μA?  Sepertinya tidak begitu mudah.  Dan jika kita menganggap bahwa kita berurusan dengan pengukuran analog, maka pasti tidak sepadan.  Oleh karena itu, stabilisator linier LP2950 digunakan, analog fungsional 78L05 populer, tetapi jauh lebih ekonomis.  Konverter ini dapat memberikan hingga 100 mA arus pada output, sambil mengkonsumsi tidak lebih dari 75 μA untuk orang yang dicintai. <br><br>  Pembagi tegangan jaringan on-board, dilindungi oleh dioda zener dan kapasitor, memungkinkan Anda untuk mengukur tegangan hingga 15 V. <br><br><blockquote>  Saya tahu bahwa sekarang gelombang kritik akan menyerang saya untuk keputusan seperti itu, tetapi kami akan bersikap objektif.  Pertama, saya tidak mengembangkan satelit, dan kedua, tidak ada faktor tunggal yang akan menyebabkan bencana.  Hambatan bahu tinggi, dioda zener mampu mengalihkan lebih banyak arus daripada yang bisa mengalir melalui pembagi, bahkan dalam skenario yang paling pesimistis.  Dari pulsa frekuensi tinggi, ketika dioda zener tidak memiliki kecepatan yang cukup, kapasitor C2 akan melindungi (dengan resistor R7 itu menciptakan filter low-pass dengan frekuensi cutoff hanya 7 Hz).  D1 dan R6 sampai batas tertentu memastikan skema dari jatuh satu sama lain.  Dan orang tidak boleh lupa tentang linearitas, metode isolasi galvanik di tempat seperti itu akan membuat perhitungan teoritis jumlah sepenuhnya tidak realistis, kita harus mengkalibrasi setidaknya prototipe, tetapi kita tidak membutuhkannya. </blockquote><br>  Resistansi keluaran pembagi sepuluh kali lebih tinggi dari yang direkomendasikan 10 kOhm untuk sumber sinyal ADC, tetapi berkat kapasitor C2 tidak ada masalah pengukuran. <br><br><blockquote>  Secara umum, impedansi input dari sirkuit ADC dari pengendali AVR menurut datasheet dinyatakan setidaknya 100 megohms.  Namun demikian, lembar data yang sama merekomendasikan penggunaan sumber dengan resistansi internal hingga 10 kOhm.  Kenapa begitu  Intinya adalah prinsip operasi ADC ini sendiri.  Konverter beroperasi berdasarkan prinsip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perkiraan sekuensial</a> , dan rangkaian inputnya adalah filter low-pass dari resistor dan kapasitor.  Memperoleh sampel 10-bit adalah berulang, dan kapasitor perlu diisi ke tegangan terukur penuh selama seluruh waktu pengukuran.  Jika impedansi keluaran sumber terlalu besar, kapasitor akan terus dibebankan secara langsung selama proses konversi dan hasilnya akan tidak akurat.  Dalam kasus kami, kapasitansi C2 lebih dari tujuh ribu kali kapasitas filter ADC, yang berarti bahwa ketika muatan didistribusikan kembali antara kapasitor ini ketika diaktifkan pada saat pengukuran, tegangan input akan berkurang tidak lebih dari 1/7000, yang merupakan tujuh kali lipat kurang dari akurasi tertinggi dari 10-bit ADC.  Benar, Anda harus ingat bahwa trik ini hanya berfungsi untuk pengukuran tunggal dengan jeda yang signifikan di antara mereka, jadi Anda tidak boleh "meningkatkan" program kontrol dengan menambahkan siklus padanya untuk beberapa pengukuran berturut-turut dengan rata-rata hasilnya. </blockquote><br>  Pembagi dengan termistor karena keberadaan sumber daya yang dikontrol dibangun menggunakan peringkat yang direkomendasikan.  NTCLE100E3 digunakan sebagai sensor, tetapi tidak ada batasan, Anda dapat menggunakan termistor yang kira-kira memiliki peringkat yang sama, hal utama adalah membuat koreksi yang sesuai dengan karakteristiknya dalam konstanta kode sumber sehingga tegangan pembagi dikonversi ke nilai suhu yang benar. <br><br>  Sebagai kunci kontrol, daya MOSFET saluran-P jenis apa pun digunakan dengan resistansi saluran terbuka yang dapat diterima dan tegangan sumber-saluran maksimum minimal 30 volt.  Rangkaian di atas menggunakan transistor yang berbeda.  Ini dilakukan karena mereka harus mengganti voltase yang berbeda dan tipe masing-masing dipilih untuk kondisi kerja tertentu.  Transistor atas harus lebih bertegangan tinggi, dan semakin rendah, jika mungkin, memiliki resistansi saluran terbuka minimum.  Tapi, saya ulangi, keputusan ini ditentukan oleh sirkuit switching perangkat (lihat di atas), dengan inklusi lain persyaratan untuk transistor yang lebih rendah mungkin berbeda. <br><br>  Untuk mengontrol sakelar daya, sepasang transistor bipolar identik digunakan.  Pada awalnya mungkin tampak bahwa transistor ini berlebihan, tetapi di sini tidak begitu sederhana.  Transistor efek medan dengan gerbang berinsulasi mulai membuka bukan dari tegangan apa pun dari polaritas yang diperlukan di gerbang, tetapi hanya setelah mencapai tingkat ambang tertentu, yang muncul di lembar data dengan nama "tegangan ambang pintu-ke-sumber" dan biasanya sama dengan 2.,4 V. Sekarang mari kita lihat hitung saja.  Sirkuit keluaran pengontrol dapat membentuk dua level logis: logis "0" dengan tegangan cenderung nol;  dan logis "1" dengan tegangan cenderung menyuplai.  Ketika diberdayakan oleh 5 volt, ini akan menjadi tegangan sekitar 0 dan 5 V, masing-masing.  Akibatnya, ketika mengganti sumber 12-volt, "0" logis pada gerbang akan membuat perbedaan tegangan sumber-gerbang 12 - 0 = 12 volt, transistor daya terbuka.  Semuanya tampak normal, tetapi logis "1" dengan tegangan 5 V akan menciptakan tegangan antara 12 - 5 = 7 volt antara sumber dan gerbang, dan transistor daya akan tetap terbuka.  Dengan demikian, sinyal kontrol lima volt tidak dapat mengontrol kunci, yang mengubah tegangan di atas 7..9 volt.  Oleh karena itu, transistor bipolar kontrol sebenarnya bekerja tidak begitu banyak dengan tombol sinyal sebagai amplifier yang menaikkan tegangan kontrol dari 5 volt ke tegangan jaringan on-board. <br><br>  Resistor dalam rangkaian dasar dari masing-masing transistor kontrol hanya membatasi arus keluaran pengontrol ke tingkat yang cukup untuk mengendalikannya.  Peringkat mereka dapat dikurangi dua hingga tiga kali tanpa konsekuensi untuk pengoperasian sirkuit. <br><br><blockquote>  Sangat mudah untuk melihat bahwa transistor kontrol tidak ada dalam rangkaian analog berdasarkan pada LM393N.  Masalahnya adalah bahwa tahap output komparator yang dipilih dibangun sesuai dengan rangkaian kolektor terbuka, yaitu, outputnya hanyalah keluaran dari kolektor transistor terminal.  Prinsip konstruksi ini membutuhkan bagian tambahan yang digantung pada chip untuk membuat beban tahap output, tetapi, di sisi lain, membuat chip sangat fleksibel.  Kolektor terbuka memungkinkan komparator untuk mengontrol sumber arus apa pun yang dapat diterima, dan tidak hanya kompatibel dengan sumber yang menyediakan daya bagi komparator itu sendiri. </blockquote><br>  Saya harus mengatakan bahwa membatasi ambang tegangan MOSFET daya bekerja tidak hanya terhadap tegangan tinggi, seperti yang disebutkan di atas, tetapi juga terhadap yang rendah.  Lagi pula, jika tegangan pembukaan minimum dari transistor adalah, katakanlah, 4 volt, maka ketika beralih sumber 3.3 V, bahkan menghubungkan gerbang ke tanah tidak akan membuat perbedaan tegangan yang diinginkan antara sumber dan gerbang dan transistor akan tetap ditutup.  Jadi 5 volt adalah, mungkin, tegangan minimum yang dapat dengan andal dialihkan oleh transistor yang dipilih. <br><br><h3>  Kustomisasi </h3><br>  Menyiapkan perangkat adalah percakapan terpisah.  Di satu sisi, tidak ada elemen tala tunggal di sirkuit, tetapi di sisi lain, kita berhadapan dengan mengukur tegangan dengan akurasi tidak lebih buruk dari 0,1 V. Bagaimana menghubungkan semua ini?  Ada dua cara.  Yang pertama adalah menggunakan resistor R6, R7 dan R8 dengan toleransi minimal 1% (atau lebih baik 0,1%).  Yang kedua melibatkan penggunaan resistor konvensional dengan pengukuran resistensi nyata mereka dan koreksi koefisien dalam kode sumber program. <br><br>  Metode pertama baik untuk produksi massal, tetapi jauh lebih menarik bagi kita untuk tidak repot-repot mencari nilai presisi tinggi yang diperlukan, jadi mari kita lanjutkan dengan cara kedua.  Resistansi dapat diukur dengan multimeter biasa, akurasinya di sini cukup memadai.  Objek pengukuran lain adalah tegangan stabilizer yang memasok rangkaian.  ADC controller dapat bekerja dalam mode yang berbeda, tetapi karena beberapa alasan lebih mudah bagi kita untuk menggunakannya di mana hasil konversi digital dihitung relatif terhadap tegangan suplai.  Itulah mengapa penting untuk mengetahuinya seakurat mungkin. <br><br>  Perhitungannya sangat sederhana dan terdiri dari menghitung koefisien pembagian pembagi resistif dan proporsi terjemahan hasil dalam LSB selama konversi analog-ke-digital. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/s-/-q/vf/s--qvfm_z0imo_xg5r7tnskhze0.png"></div><br>  Ux adalah tegangan input pembagi; <br>  Ru adalah resistansi lengan atas pembagi (yang disediakan Ux); <br>  Rd adalah resistansi lengan bawah pembagi (yang terhubung ke tanah); <br>  Uref - tegangan referensi ADC (yaitu tegangan suplai pengontrol); <br>  1024 - jumlah nilai diskrit pada output 10-bit ADC; <br>  LSB adalah nilai numerik yang diperoleh oleh program dari ADC. <br><br>  Mari kita mulai dengan pembagi tegangan R6-R7.          .     5.0 .      13.5 : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nr/ic/a2/nrica2q5vtygw-ck3mstvspkm4y.png"></div><br>      ,      ,       ,    . <br><br>   ,  ,     ,      Ru,  Ux    Uref.     : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zv/t7/qi/zvt7qi05g21ecwvaquqnjdbhjli.png"></div><br>     R8  ,  R9    NTCLE100E3   0⁰C: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/j5/gp/_k/j5gp_kzjcx3buv0ayejxoazlwcu.png"></div><br><blockquote>   ,        R8  R9      ,  , ,  . .       ,    R9   ,        0.5 m,       .   ,            ,   0.01 . </blockquote><br>         ,  , ,   .     ,                         .    -     ,        . <br><br> ,         ,      ,           . <br><br><h3>  Firmware </h3><br>     AtmelStudio ( gcc-avr 5.4.0)   <a href=""></a> ,     <a href="">hex</a> .      ,    . <br><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><pre><code class="cpp">//#define F_CPU 1200000UL //    <font></font>
<font></font>
#include &lt;avr/io.h&gt;<font></font>
#include &lt;avr/wdt.h&gt;<font></font>
#include &lt;avr/sleep.h&gt;<font></font>
#include &lt;avr/interrupt.h&gt; <font></font>
#include &lt;util/delay.h&gt;<font></font>
<font></font>
//#define DBG<font></font>
<font></font>
#define TEMPERATURE_OVERHEAT 753 // LSB-  +50⁰C<font></font>
#define TEMPERATURE_GIST     8   //    ( LSB)     <font></font>
#define VOLTAGE_GIST         3   //    ( LSB)     <font></font>
<font></font>
#define INTERVAL             WDTO_1S //     (1 )<font></font>
#ifndef DBG<font></font>
#define CELL_CHANGE_TIMEOUT  90  //      (  INTERVAL,   254)<font></font>
#define OVERHEAT_TIMEOUT     300 //      "" (  INTERVAL)<font></font>
#else<font></font>
#define CELL_CHANGE_TIMEOUT  2<font></font>
#define OVERHEAT_TIMEOUT     3<font></font>
#endif<font></font>
<font></font>
typedef unsigned char bool; //    <font></font>
#define true  0 == 0        //     <font></font>
#define false 0 != 0        //      <font></font>
<font></font>
typedef enum {st_none = 0b00, st_primary = 0b01, st_secondary = 0b10, st_both = 0b11} t_states; //    <font></font>
                                                                                                //       ,      <font></font>
typedef enum {adc_temperature, adc_voltage} t_measure;                                          //   <font></font>
typedef enum {move_null, move_up, move_down} t_movement;                                        //      <font></font>
<font></font>
//    <font></font>
struct t_coordidates {<font></font>
  signed char row, col;<font></font>
};<font></font>
<font></font>
//       <font></font>
struct t_correction {<font></font>
  t_movement voltage, temperature;<font></font>
};<font></font>
<font></font>
#define CELLS_ROWS 3 //      ( )<font></font>
#define CELLS_COLS 5 //      ( )<font></font>
<font></font>
//  <font></font>
const t_states CELLS[CELLS_ROWS][CELLS_COLS] = {<font></font>
  {st_both, st_both,    st_both,    st_primary, st_none},<font></font>
  {st_both, st_both,    st_primary, st_none,    st_none},<font></font>
  {st_both, st_primary, st_none,    st_none,    st_none}<font></font>
};<font></font>
<font></font>
// LSB- ,      <font></font>
const unsigned int ROWS_EDGES[CELLS_ROWS - 1] = {<font></font>
  241, // 0⁰C<font></font>
  157  // -10⁰C<font></font>
};<font></font>
<font></font>
// LSB- ,      <font></font>
const unsigned int COLS_EDGES[CELLS_COLS - 1] = {<font></font>
  864, // 13.5V<font></font>
  800, // 12.5V<font></font>
  787, // 12.3V<font></font>
  768  // 12.0V<font></font>
};<font></font>
<font></font>
unsigned int overheat_rest_time = 0; //       ""<font></font>
unsigned char cell_change_time  = 0; //      <font></font>
unsigned char no_cur_cell_time  = 0; //  ,            <font></font>
<font></font>
#define NULL_CELL (struct t_coordidates){.col = -1, .row = -1} // ,   <font></font>
#define NULL_CORRECTION (struct t_correction){.voltage = move_null, .temperature = move_null} // ,   <font></font>
<font></font>
struct t_correction moved_from = NULL_CORRECTION; //       <font></font>
struct t_coordidates cur_cell  = NULL_CELL,       //      <font></font>
                     next_cell = NULL_CELL;       //  -   <font></font>
<font></font>
//  <font></font>
static void init_pins() {<font></font>
  DDRB |= (1 &lt;&lt; PB0) | (1 &lt;&lt; PB1) | (1 &lt;&lt; PB3);     //   2 (PB3), 5 (PB0)  6 (PB1)  <font></font>
  PORTB &amp;= ~(1 &lt;&lt; PB0) &amp; ~(1 &lt;&lt; PB1) &amp; ~(1 &lt;&lt; PB3); //      2 (PB3), 5 (PB0)  6 (PB1)<font></font>
}<font></font>
<font></font>
// /    <font></font>
static void toggle_thermal_sensor(bool state) {<font></font>
  if(state) {<font></font>
    PORTB |= (1 &lt;&lt; PB1);  //  state ,      6 (PB1)<font></font>
<font></font>
    _delay_ms(5); //    <font></font>
  } else {<font></font>
    PORTB &amp;= ~(1 &lt;&lt; PB1); //  state  ,      6 (PB1)<font></font>
  }<font></font>
}<font></font>
<font></font>
//   <font></font>
static unsigned int measure_adc(t_measure measure) {<font></font>
  if(measure == adc_temperature) {<font></font>
    toggle_thermal_sensor(true); //    ,    <font></font>
<font></font>
    ADMUX = 0b10; //      -   3 (PB4)<font></font>
  } else {<font></font>
    ADMUX = 0b01; //      -   7 (PB2)<font></font>
  }<font></font>
<font></font>
  ADCSRA = (1 &lt;&lt; ADPS2) | //       = 16 (75 )<font></font>
           (1 &lt;&lt; ADIE) |  //    <font></font>
           (1 &lt;&lt; ADEN);   //  <font></font>
<font></font>
  set_sleep_mode(SLEEP_MODE_ADC); //   "" <font></font>
  do {<font></font>
    sleep_cpu(); //      ,      ,   <font></font>
  } while(ADCSRA &amp; (1 &lt;&lt; ADSC)); //        ,  <font></font>
<font></font>
  ADCSRA = 0; //  <font></font>
<font></font>
  toggle_thermal_sensor(false); //     <font></font>
<font></font>
  return ADC; //  10-  <font></font>
}<font></font>
<font></font>
//    watchdog<font></font>
static void init_interrupts(void) {<font></font>
  sleep_enable(); //   <font></font>
<font></font>
  WDTCR = (1 &lt;&lt; WDCE) | (1 &lt;&lt; WDE); //  watchdog<font></font>
  WDTCR = (1 &lt;&lt; WDTIE) | INTERVAL; // watchdog      ,  1 <font></font>
<font></font>
  sei(); //  <font></font>
}<font></font>
<font></font>
//          <font></font>
static void toggle_loads(t_states states) {<font></font>
  unsigned char port = PORTB &amp; ~((1 &lt;&lt; PB3) | (1 &lt;&lt; PB0)),     //           ,   <font></font>
                bits = (((states &amp; st_primary) &gt;&gt; 0) &lt;&lt; PB3) | //        <font></font>
                       (((states &amp; st_secondary) &gt;&gt; 1) &lt;&lt; PB0);<font></font>
<font></font>
  PORTB = port | bits; //    <font></font>
}<font></font>
<font></font>
//     t_coordidates<font></font>
static bool cells_equal(struct t_coordidates cell1, struct t_coordidates cell2) {<font></font>
  return cell1.row == cell2.row &amp;&amp; cell1.col == cell2.col;<font></font>
}<font></font>
<font></font>
//          LSB- <font></font>
static signed char get_cell_row(unsigned int temperature) {<font></font>
  signed char row = 0;<font></font>
<font></font>
  while(row &lt; CELLS_ROWS - 1) {          //          <font></font>
    if(temperature &gt;= ROWS_EDGES[row]) { //  temperature     ,    <font></font>
      return row;<font></font>
    } else {<font></font>
      ++row;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  return CELLS_ROWS - 1; //  temperature         ,       <font></font>
}<font></font>
<font></font>
//          LSB- <font></font>
static signed char get_cell_col(unsigned int voltage) {<font></font>
  signed char col = 0;<font></font>
<font></font>
  while(col &lt; CELLS_COLS - 1) {      //          <font></font>
    if(voltage &gt;= COLS_EDGES[col]) { //  voltage     ,    <font></font>
      return col;<font></font>
    } else {<font></font>
      ++col;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  return CELLS_COLS - 1; //  voltage         ,       <font></font>
}<font></font>
<font></font>
//    ,       <font></font>
static void get_row_edges(signed char row, unsigned int *upper, unsigned int *lower) {<font></font>
  *upper = row &gt; 0 ? ROWS_EDGES[row - 1] : 0xffff - TEMPERATURE_GIST; //       ,    <font></font>
  *lower = row &lt; CELLS_ROWS - 1 ? ROWS_EDGES[row] : TEMPERATURE_GIST; //       ,    <font></font>
}<font></font>
<font></font>
//    ,       <font></font>
static void get_col_edges(signed char col, unsigned int *upper, unsigned int *lower) {<font></font>
  *upper = col &gt; 0 ? COLS_EDGES[col - 1] : 0xffff - VOLTAGE_GIST; //      (  )  ,    <font></font>
  *lower = col &lt; CELLS_COLS - 1 ? COLS_EDGES[col] : VOLTAGE_GIST; //      (  )  ,    <font></font>
}<font></font>
<font></font>
//    -              <font></font>
static void gisteresis_correction(struct t_coordidates* new_cell, unsigned int temperature, unsigned int voltage) {<font></font>
  unsigned int upper_edge, lower_edge;<font></font>
<font></font>
  get_row_edges(cur_cell.row, &amp;upper_edge, &amp;lower_edge); //    <font></font>
  if(new_cell-&gt;row &gt; cur_cell.row &amp;&amp; moved_from.temperature == move_up &amp;&amp; temperature &gt;= lower_edge - TEMPERATURE_GIST) {<font></font>
    --new_cell-&gt;row; //   -   ,    ,        ,    <font></font>
  }<font></font>
<font></font>
  if(new_cell-&gt;row &lt; cur_cell.row &amp;&amp; moved_from.temperature == move_down &amp;&amp; temperature &lt;= upper_edge + TEMPERATURE_GIST) {<font></font>
    ++new_cell-&gt;row; //   -   ,    ,        ,    <font></font>
  }<font></font>
<font></font>
  get_col_edges(cur_cell.col, &amp;upper_edge, &amp;lower_edge); //    <font></font>
  if(new_cell-&gt;col &gt; cur_cell.col &amp;&amp; moved_from.voltage == move_up &amp;&amp; voltage &gt;= lower_edge - VOLTAGE_GIST) {<font></font>
    --new_cell-&gt;col; //   -   ,     (  ),        ,    <font></font>
  }<font></font>
<font></font>
  if(new_cell-&gt;col &lt; cur_cell.col &amp;&amp; moved_from.voltage == move_down &amp;&amp; voltage &lt;= upper_edge + VOLTAGE_GIST) {<font></font>
    ++new_cell-&gt;col; //   -   ,     (  ),        ,    <font></font>
  }<font></font>
}<font></font>
<font></font>
//       stdlib::abs()<font></font>
 static unsigned char absolute(signed char value) {<font></font>
  return value &gt;= 0 ? value : -value;<font></font>
}<font></font>
<font></font>
//      -<font></font>
static void calc_movement(struct t_coordidates new_cell) {<font></font>
  moved_from = NULL_CORRECTION;                                                   // -   <font></font>
  if(!cells_equal(new_cell, NULL_CELL) &amp;&amp; !cells_equal(cur_cell, NULL_CELL)) {    //         ,  -<font></font>
    if(absolute(new_cell.row - cur_cell.row) == 1) {                              //      <font></font>
      moved_from.temperature = new_cell.row &lt; cur_cell.row ? move_up : move_down; //   <font></font>
    }<font></font>
<font></font>
    if(absolute(new_cell.col - cur_cell.col) == 1) {                              //      <font></font>
      moved_from.voltage = new_cell.col &lt; cur_cell.col ? move_up : move_down;     //   <font></font>
    }<font></font>
  }<font></font>
}<font></font>
<font></font>
//   -<font></font>
static void set_next_cell(struct t_coordidates cell) {<font></font>
  next_cell = cell;<font></font>
  cell_change_time = 0; //    <font></font>
}<font></font>
<font></font>
//    <font></font>
static void set_cur_cell(struct t_coordidates cell) {<font></font>
  cur_cell = cell;<font></font>
  no_cur_cell_time = 0; //        <font></font>
  set_next_cell(NULL_CELL); //  -<font></font>
}<font></font>
<font></font>
// ,      <font></font>
static void change_cell(struct t_coordidates new_cell) {<font></font>
  if(cells_equal(new_cell, NULL_CELL)) { //         <font></font>
    toggle_loads(st_none);<font></font>
  } else {<font></font>
    toggle_loads(CELLS[new_cell.row][new_cell.col]); //         <font></font>
  }<font></font>
<font></font>
  calc_movement(new_cell); //     <font></font>
  set_cur_cell(new_cell);  //   <font></font>
}<font></font>
<font></font>
//  <font></font>
static void main_proc(void) {<font></font>
  unsigned int temperature, voltage; // 10- LSB-    <font></font>
  struct t_coordidates cell;         //      -<font></font>
<font></font>
  if(overheat_rest_time) { //      ""  ,          <font></font>
    --overheat_rest_time;<font></font>
  } else {<font></font>
    temperature = measure_adc(adc_temperature); //  <font></font>
    if(temperature &gt;= TEMPERATURE_OVERHEAT) {   //      +50C,  :<font></font>
      change_cell(NULL_CELL);                   //      (   )<font></font>
      overheat_rest_time = OVERHEAT_TIMEOUT;    //        <font></font>
    } else {<font></font>
      voltage = measure_adc(adc_voltage);   //  <font></font>
<font></font>
      cell.col = get_cell_col(voltage);     //    -  <font></font>
      cell.row = get_cell_row(temperature); //    -  <font></font>
<font></font>
      if(cells_equal(cur_cell, NULL_CELL)) { //        ,         <font></font>
        change_cell(cell);<font></font>
      } else {<font></font>
        gisteresis_correction(&amp;cell, temperature, voltage); //              <font></font>
<font></font>
        if(cells_equal(cell, cur_cell)) { //   -   ,      <font></font>
          set_next_cell(NULL_CELL);<font></font>
          no_cur_cell_time = 0; //    ,  <font></font>
        } else {<font></font>
          if(no_cur_cell_time++ &gt; CELL_CHANGE_TIMEOUT) { //    CELL_CHANGE_TIMEOUT+1        cur_cell,      <font></font>
            change_cell(cell); //    ,     <font></font>
          } else {<font></font>
            if(cells_equal(next_cell, NULL_CELL) || !cells_equal(next_cell, cell)) { //  -       ,   <font></font>
              set_next_cell(cell);<font></font>
            } else {<font></font>
              if(++cell_change_time &gt;= CELL_CHANGE_TIMEOUT) { //   ,       , ,    <font></font>
                change_cell(cell);<font></font>
              }<font></font>
            }<font></font>
          }<font></font>
        }<font></font>
      }<font></font>
    }<font></font>
  }<font></font>
}<font></font>
<font></font>
//    watchdog<font></font>
ISR(WDT_vect) {<font></font>
  WDTCR |= (1 &lt;&lt; WDTIE); //    watchdog   ""    <font></font>
}<font></font>
<font></font>
//    ,        ADSC  measure_adc()<font></font>
EMPTY_INTERRUPT(ADC_vect);<font></font>
<font></font>
//  <font></font>
int main(void) {<font></font>
  init_pins();       //  <font></font>
  init_interrupts(); //    watchdog<font></font>
	<font></font>
  while(true) {                          //  ,       <font></font>
    set_sleep_mode(SLEEP_MODE_PWR_DOWN); //        <font></font>
    sleep_cpu();                         //        watchdog <font></font>
<font></font>
    main_proc();                         //          <font></font>
  }<font></font>
}<font></font>
</code></pre><br>
<br>
    : L:0x6A, H:0xFF.<br>
</div></div><br>
   .    ,     –  ,    – .            ,    .     :<br>
<br>
<a href=""><div style="text-align:center;"><img src="https://habrastorage.org/webt/0j/wx/ez/0jwxezo197qadbln8crg05zwlhq.png"></div></a><br>
          ,      .<br>
<br>
,           .        ,        .   ,        ,       .<br>
<br>
<blockquote>,  -      ,       .                ,    ,      . , - ,  ,    ,   ,                .  ..  -   ,           ,      .    .         .      ,      ,     .</blockquote><br>
        ,                  .  ,  , ,  12.5   ,      ,      12.4 .                . ,             .<br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/_o/d5/9e/_od59e61ylpgaqhsrwwlwsro3dw.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/lo/bu/uu/lobuuuqhkbahdsyinpg5hhokeyw.png"></div><br>
 ,               , ,   .            ,    .           «» 8-9 .<br>
<br>
<blockquote>         ,     .        «»    ,          .   ,      ,    «» ,     -    (,   ,   ,    ,  ,     -  ).</blockquote><br>
      ,        +50⁰C  ,     .        ,  ,  ,       .                 .<br>
<br>
  «»,   ,    (watchdog).                    .<br>
<br>
<blockquote> ,          –  .       . Watchdog   ,  ,     ,     .  ,    ,         ,     watchdog.   ,      ,        .</blockquote><br>
           .       1006 ,      -  .<br>
<br>
<blockquote>,       ,  .   ,        O2,   ,       Os  ,      1024 .             -,      .</blockquote><br>
                       .<br>
<br>
<div class="spoiler"><b class="spoiler_title">    </b><div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/1b/gg/nv/1bggnvmw6h-x7nab-h9ljuag1lq.png"></div><br>
     Eagle  <a href=""></a>.<br>
</div></div></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id446956/">https://habr.com/ru/post/id446956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id446942/index.html">Server, bisakah kau mendengarku? Serangan BROP pada contoh tugas NeoQUEST-2019</a></li>
<li><a href="../id446944/index.html">Mengapa berinvestasi di perusahaan yang tidak menguntungkan?</a></li>
<li><a href="../id446948/index.html">Bagaimana Android Gustuff Trojan menghapus krim (fiat dan crypto) dari akun Anda</a></li>
<li><a href="../id446950/index.html">76% produsen tidak memiliki pengalaman menerapkan aditif - mengapa itu baik</a></li>
<li><a href="../id446952/index.html">Buat histogram animasi menggunakan R</a></li>
<li><a href="../id446958/index.html">Tine Perl rumit</a></li>
<li><a href="../id446960/index.html">Rumah yang dibangun Jack</a></li>
<li><a href="../id446962/index.html">Phishing dan tanpa chemistry</a></li>
<li><a href="../id446964/index.html">Integrasi dengan SAP ERP. Penerapan pemeriksa harga seluler di toko</a></li>
<li><a href="../id446966/index.html">Berita terbaik minggu ini: acara utama di bidang IT dan sains</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>