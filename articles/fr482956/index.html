<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé¥ üñêüèº üê™ Examen de WCS 5.2 - Serveur WebRTC pour d√©veloppeurs Webcast et Webcam üë©‚Äçüë©‚Äçüëß‚Äçüë¶ üíÉüèø üßû</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alice est un d√©veloppeur exp√©riment√© de pile compl√®te, capable d'√©crire un cadre de projet SAAS sur son cadre pr√©f√©r√© en utilisant php en une semaine....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Examen de WCS 5.2 - Serveur WebRTC pour d√©veloppeurs Webcast et Webcam</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flashphoner/blog/482956/"><img src="https://habrastorage.org/webt/za/go/wo/zagowolkguxr8_bdsbwjmkvyd0a.jpeg"><br><br><p>  Alice est un d√©veloppeur exp√©riment√© de pile compl√®te, capable d'√©crire un cadre de projet SAAS sur son cadre pr√©f√©r√© en utilisant php en une semaine.  Quant au frontend, elle pr√©f√®re Vue.js. </p><br><p>  Un client vous contacte via Telegram, vous demandant de d√©velopper un site Web qui sera le lieu de rencontre pour l'employeur et l'employ√© pour mener une entrevue en personne.  En personne signifie en face √† face, un contact vid√©o direct en temps r√©el avec vid√©o et voix.  "Pourquoi ne pas utiliser Skype?"  Il se trouve que des projets s√©rieux - et chaque startup se consid√®re sans aucun doute comme un projet s√©rieux - essaient d'offrir un service de communication interne pour diverses raisons, notamment: </p><a name="habracut"></a><br><p>  1) Ils ne veulent pas pr√™ter ses utilisateurs √† des communicateurs tiers (Skype, Hangouts, etc.) et souhaitent les conserver dans le service. </p><br><p>  2) Le d√©sir de surveiller leurs communications, comme l'historique des appels et les r√©sultats des entretiens. </p><br><p>  3) Enregistrez les appels (naturellement, informez les deux parties de l'enregistrement). </p><br><p> 4) Ils ne veulent pas d√©pendre des politiques et des mises √† jour des services tiers.  Tout le monde conna√Æt cette histoire: Skype a √©t√© mis √† jour, et tout part en fum√©e ... </p><br><p>  Cela semble √™tre une t√¢che facile.  WebRTC appara√Æt lors de la recherche sur le sujet, et il semble que vous pouvez organiser une connexion d'√©gal √† √©gal entre deux navigateurs, mais il reste des questions: </p><br><p>  1) O√π trouver les serveurs STUN / TURN? </p><br><p>  2) Peut-on s'en passer? </p><br><p>  3) Comment enregistrer un appel WebRTC poste √† poste? </p><br><p>  4) Que se passera-t-il si nous devons ajouter un tiers √† l'appel, par exemple un responsable RH ou un autre sp√©cialiste de l'employeur? </p><br><p>  Il s'av√®re que WebRTC et peer-to-peer seuls ne suffisent pas, et on ne sait pas quoi faire avec tout cela pour lancer les fonctions vid√©o requises du service. </p><br><h2>  Contenu de l'article </h2><br><div class="spoiler">  <b class="spoiler_title">Table des mati√®res</b> <div class="spoiler_text"><ul><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Serveur et API</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Flux entrants</a> <br><ul><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">WebRTC</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">RTMP</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Rtsp</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Vod</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">SIP / RTP</a> </li></ul><br></li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Flux sortants</a> <br><ul><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">WebRTC</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">RTMP</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Rtsp</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">MSE</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Hls</a> </li></ul><br></li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Entrant et sortant</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Manipulation de flux entrant</a> <br><ul><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Enregistrement de flux entrant</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Prendre un instantan√©</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Ajout d'un flux au m√©langeur</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Transcodage de flux</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Ajout d'un filigrane</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Ajout d'un filtre FPS</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Rotation de l'image de 90, 180, 270 degr√©s</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Gestion des flux entrants</a> </li></ul><br></li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Relais de flux</a> <br><ul><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">WebRTC</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">RTMP</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">SIP / RTP</a> </li></ul><br></li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Connexion de serveurs √† un r√©seau de traitement de contenu CDN</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Pour r√©sumer</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Les liens</a> </li></ul><br></div></div><br><h2><a name="serverapi"></a>  Serveur et API </h2><br><p>  Pour combler ces lacunes, des solutions serveur et une architecture pair-serveur-pair sont utilis√©es.  Web Call Server 5.2 (ci-apr√®s - WCS) est l'une des solutions serveur;  c'est une plate-forme de d√©veloppement qui vous permet d'ajouter de telles fonctions vid√©o au projet et de ne pas vous soucier de la STUN / TURN et de la stabilit√© de la connexion peer-to-peer. </p><br><p>  Au plus haut niveau, WCS est une partie JavaScript API + serveur.  L'API est utilis√©e pour le d√©veloppement en utilisant du JavaScript normal du c√¥t√© du navigateur, et le serveur traite le trafic vid√©o, agissant comme un proxy dynamique pour le trafic multim√©dia. </p><br><p><img src="https://habrastorage.org/webt/7a/w0/qv/7aw0qvwyfc9tak6ij9ycdr1sju4.png"></p><br><p>  En plus de l'API JavaScript, il existe √©galement le SDK Android et le SDK iOS, qui sont n√©cessaires pour d√©velopper des applications mobiles natives pour iOS et Android, respectivement. </p><br><p>  Par exemple, la publication d'un flux sur le serveur (streaming d'une webcam vers le serveur) ressemble √† ceci: </p><br><p>  Web sdk </p><br><pre><code class="plaintext hljs">session.createStream({name:‚Äùstream123‚Äù}).publish();</code> </pre> <br><p>  SDK Android </p><br><pre> <code class="plaintext hljs">publishStream = session.createStream(streamOptions) publishStream.publish();</code> </pre><br><p>  SDK iOS </p><br><pre> <code class="plaintext hljs">FPWCSApi2Stream *stream = [session createStream:options error:&amp;error]; if(![stream publish:&amp;error]) { //published without errors }</code> </pre><br><p>  En cons√©quence, nous pouvons mettre en ≈ìuvre non seulement une application Web, mais √©galement des mises √† jour √† part enti√®re pour Google Play et l'App Store avec prise en charge du streaming vid√©o.  Si nous ajoutons le SDK mobile √† l'image de niveau sup√©rieur, nous obtiendrons ceci: </p><br><p><img src="https://habrastorage.org/webt/tf/z-/ya/tfz-yax_izaf-eyitcvd57y82h0.png"></p><br><p></p><br><h2><a name="Incomingstreams"></a>  Flux entrants </h2><br><p>  Le serveur de streaming, qui est WCS, d√©marre avec les flux entrants.  Pour distribuer quelque chose, nous devons l'avoir.  Pour distribuer des flux vid√©o aux t√©l√©spectateurs, il est n√©cessaire que ces flux entrent dans le serveur, passent par sa RAM et sortent par la carte r√©seau.  Par cons√©quent, la premi√®re question que nous devons nous poser lorsque nous nous familiarisons avec le serveur multim√©dia est de savoir quels protocoles et formats ce dernier utilise pour accepter les flux.  Dans le cas de WCS, ce sont les technologies suivantes: WebRTC, RTMP, RTSP, VOD, SIP / RTP. </p><br><p><img src="https://habrastorage.org/webt/du/2r/pc/du2rpcr6ihdkicklwlyusrodjog.png"></p><br><p>  Chacun des protocoles peut √™tre utilis√© par divers clients.  Par exemple, non seulement le flux du navigateur peut entrer via WebRTC, mais aussi √† partir d'un autre serveur.  Le tableau ci-dessous r√©pertorie les sources possibles de trafic entrant. </p><br><div class="scrollable-table"><table><tbody><tr><td>  <strong>WebRTC</strong> </td><td>  <strong>RTMP</strong> </td><td>  <strong>Rtsp</strong> </td><td>  <strong>Vod</strong> </td><td>  <strong>SIP / RTP</strong> </td></tr><tr><td><ul><li>  Web sdk <br><ul><li>  cam√©ra + micro </li><li>  toile </li><li>  partage d'√©cran </li></ul><br></li><li>  SDK Android </li><li>  SDK iOS </li><li>  WCS <br><ul><li>  pousser </li><li>  tirer </li></ul><br></li><li>  Cdn </li></ul><br></td><td><ul><li>  Encodeur RTMP <br><ul><li>  ffmpeg </li><li>  Obs </li><li>  Wirecast </li></ul><br></li><li>  Encodeur Adobe </li><li>  WCS <br><ul><li>  pousser </li><li>  tirer </li></ul><br></li><li>  Lecteur Flash </li></ul><br></td><td><ul><li>  Cam√©ra IP </li><li>  Serveur RTSP </li></ul><br></td><td><ul><li>  Syst√®me de fichiers </li><li>  AWS S3 </li></ul><br></td><td><ul><li>  Point de terminaison SIP </li><li>  Conf√©rence SIP </li></ul><br></td></tr></tbody></table></div><br><br><p>  Si nous passons par les sources de trafic entrant, nous pouvons ajouter ce qui suit: <br></p><br><h3> <strong><a name="inWebRTC"></a></strong>  <strong>WebRTC entrant</strong> </h3><br><p>  Le SDK Web permet non seulement de capturer la cam√©ra et le microphone, mais √©galement d'utiliser les capacit√©s de l'API du navigateur pour acc√©der √† l'√©cran via le partage d'√©cran.  De plus, nous pouvons capturer un √©l√©ment Canvas arbitraire, et tout ce qui est dessin√© dessus pour une diffusion ult√©rieure est un streaming de toile: </p><br><p>  En raison des sp√©cificit√©s mobiles, le SDK Android et le SDK iOS ont la possibilit√© de basculer entre les cam√©ras avant et arri√®re de l'appareil lors de vos d√©placements.  Cela nous permet de changer de source pendant la diffusion sans avoir √† interrompre le flux. </p><br><p>  Le flux WebRTC entrant peut √©galement √™tre obtenu √† partir d'un autre serveur WCS en utilisant les m√©thodes push, pull et CDN, qui seront discut√©es plus loin. </p><br><p><img src="https://habrastorage.org/webt/zn/rw/5i/znrw5ikkd8vcjuexwarfzeqkhg4.jpeg"></p><br><p></p><br><h3> <strong><a name="inRTMP"></a></strong>  <strong>Rtmp entrant</strong> </h3><br><p>  Le protocole RTMP est largement utilis√© dans l'OBS pr√©f√©r√© des streamers, ainsi que dans d'autres encodeurs: Wirecast, Adobe Media Encoder, ffmpeg, etc.  En utilisant l'un de ces encodeurs, nous pouvons capturer le flux et l'envoyer au serveur. </p><br><p>  Nous pouvons √©galement r√©cup√©rer un flux RTMP √† partir d'un autre serveur multim√©dia ou serveur WCS en utilisant les m√©thodes push et pull.  En cas de push, l'initiateur est le serveur distant.  Dans le cas de pull, nous nous tournons vers le serveur local pour extraire le flux du serveur distant. </p><br><p><img src="https://habrastorage.org/webt/3o/8x/f8/3o8xf84v5rx2apw_09n_lm2cjoe.jpeg"></p><br><p></p><br><h3> <strong><a name="inRTSP"></a></strong>  <strong>Rtsp entrant</strong> </h3><br><p>  Les sources de trafic RTSP sont g√©n√©ralement des cam√©ras IP ou des serveurs multim√©dias tiers prenant en charge le protocole RTSP.  Malgr√© le fait que lors de l'initialisation d'une connexion RTSP, l'initiateur est WCS, le trafic audio et vid√©o en direction de la cam√©ra IP se d√©place vers le serveur WCS.  Par cons√©quent, nous consid√©rons que le flux de la cam√©ra est entrant. </p><br><p><img src="https://habrastorage.org/webt/ch/pj/qi/chpjqiof2ipgoqzmwx0zzkewrgm.jpeg"></p><br><p></p><br><h3> <strong><a name="inVOD"></a></strong>  <strong>Vod entrant</strong> </h3><br><p>  √Ä premi√®re vue, il peut sembler que la fonction VOD (Video On Demand) est exclusivement associ√©e aux flux sortants et √† la lecture des fichiers par les navigateurs.  Mais dans notre cas, ce n'est pas enti√®rement vrai.  WCS diffuse un fichier mp4 du syst√®me de fichiers vers localhost;  en cons√©quence, un flux entrant est cr√©√©, comme s'il provenait d'une source tierce.  De plus, si nous limitons un visualiseur √† un fichier mp4, nous obtenons le VOD classique, o√π le visualiseur obtient le flux et le lit depuis le tout d√©but.  Si nous ne limitons pas une visionneuse √† un seul fichier mp4, nous obtenons VOD LIVE - une variation de VOD, dans laquelle les spectateurs peuvent lire le m√™me fichier en tant que flux, se connectant au point de lecture o√π tous les autres sont actuellement situ√©s (pr√©- mode de diffusion t√©l√©vis√©e enregistr√©). </p><br><p><img src="https://habrastorage.org/webt/cn/ot/tv/cnottvwwytktaxh9vnbjexlxlaq.jpeg"></p><br><p></p><br><h3> <strong><a name="inSIP-RTP"></a></strong>  <strong>SIP / RTP entrants</strong> </h3><br><p>  Pour recevoir le trafic RTP entrant dans une session SIP, nous devons √©tablir un appel avec une passerelle SIP tierce.  Si la connexion est √©tablie avec succ√®s, le trafic audio et / ou vid√©o ira de la passerelle SIP, qui sera envelopp√©e dans le flux entrant du c√¥t√© WCS. </p><br><p><img src="https://habrastorage.org/webt/-r/km/io/-rkmio-9lhqlfjioblwkanzuxiq.jpeg"></p><br><p></p><br><h2><a name="Outgoingstreams"></a>  Flux sortants </h2><br><p>  Apr√®s avoir re√ßu le flux sur le serveur, nous pouvons r√©pliquer le flux re√ßu sur un ou plusieurs t√©l√©spectateurs sur demande.  Le spectateur demande un flux au lecteur ou √† un autre appareil.  Ces flux sont appel√©s flux sortants ou ¬´flux de visionneuse¬ª, car les sessions de ces flux sont toujours lanc√©es du c√¥t√© de la visionneuse / du lecteur.  L'ensemble des technologies de lecture comprend les protocoles / formats suivants: WebRTC, RTMP, RTSP, MSE et HLS. </p><br><br><div class="scrollable-table"><table><thead><tr><th>  WebRTC </th><th>  RTMP </th><th>  Rtsp </th><th>  MSE </th><th>  Hls </th></tr></thead><tbody><tr><td><ul><li>  Web sdk </li><li>  SDK Android </li><li>  SDK iOS </li><li>  WC <br><ul><li>  tirer </li><li>  Cdn </li></ul><br></li></ul><br></td><td><ul><li>  Lecteur Flash </li><li>  Lecteurs RTMP </li></ul><br></td><td><ul><li>  Lecteur RTSP <br><ul><li>  VLC </li><li>  WCS </li><li>  etc. </li></ul><br></li></ul><br></td><td><ul><li>  Web sdk </li></ul><br></td><td><ul><li>  Joueurs HLS <br><ul><li>  hls.js </li><li>  safari natif </li></ul><br></li></ul><br></td></tr></tbody></table></div><br><h3> <strong><a name="outWebRTC"></a></strong>  <strong>WebRTC sortant</strong> </h3><br><p>  Dans ce cas, le SDK Web, le SDK Android et le SDK iOS agissent comme l'API du lecteur.  Un exemple de lecture de flux WebRTC ressemble √† ceci: </p><br><p>  Web sdk </p><br><pre> <code class="plaintext hljs">session.createStream({name:‚Äùstream123‚Äù}).play();</code> </pre><br><p>  SDK Android </p><br><pre> <code class="plaintext hljs">playStream = session.createStream(streamOptions); playStream.play();</code> </pre><br><p>  SDK iOS </p><br><pre> <code class="plaintext hljs">FPWCSApi2Stream *stream = [session createStream:options error:nil]; if(![stream play:&amp;error]) { //published without errors }</code> </pre> <br><p>  Ceci est tr√®s similaire √† l'API de publication, √† la seule diff√©rence qu'au lieu de stream.publish (), stream.play () est appel√© √† jouer. </p><br><p>  Un serveur WCS tiers peut √™tre le lecteur, qui sera charg√© de r√©cup√©rer le flux via WebRTC √† partir d'un autre serveur √† l'aide de la m√©thode d'extraction ou de r√©cup√©rer le flux dans CDN. </p><br><p></p><br><h3> <strong><a name="outRTMP"></a></strong>  <strong>Rtmp sortant</strong> </h3><br><p><img src="https://habrastorage.org/webt/in/zq/nb/inzqnbejvsout_d4n5iiej4gozi.png"></p><br><p>  Ici, il y aura principalement des lecteurs RTMP - √† la fois le c√©l√®bre Flash Player et les applications de bureau et mobiles qui utilisent le protocole RTMP, re√ßoivent et lisent un flux RTMP.  Malgr√© le fait que Flash ait quitt√© le navigateur, il a conserv√© le protocole RTMP, qui est largement utilis√© pour les diffusions vid√©o, et le manque de support natif dans les navigateurs n'emp√™che pas l'utilisation de ce protocole assez r√©ussi dans d'autres applications clientes.  Il est connu que RTMP est largement utilis√© dans les lecteurs VR pour les applications mobiles sur Android et iOS. </p><br><p></p><br><h3> <strong><a name="outRTSP"></a></strong>  <strong>Rtsp sortant</strong> </h3><br><p><img src="https://habrastorage.org/webt/ly/xu/r9/lyxur9b3gfzwsubfmrb3afmkfh0.png"></p><br><p>  Le serveur WCS peut agir comme un serveur RTSP et distribuer le flux re√ßu via RTSP comme une cam√©ra IP standard.  Dans ce cas, le joueur doit √©tablir une connexion RTSP avec le serveur et r√©cup√©rer le flux pour la lecture, comme s'il s'agissait d'une cam√©ra IP. </p><br><p></p><br><h3> <strong><a name="outMSE"></a></strong>  <strong>MSE sortant</strong> </h3><br><p><img src="https://habrastorage.org/webt/lt/wh/wz/ltwhwz7b8urhlg4m5ay-blpg-d8.jpeg"></p><br><p>  Dans ce cas, le lecteur demande un flux au serveur en utilisant le protocole Websocket.  Le serveur distribue des donn√©es audio et vid√©o via des sockets Web.  Les donn√©es atteignent le navigateur et sont converties en morceaux que le navigateur peut jouer gr√¢ce √† l'extension native MSE prise en charge d√®s la sortie de la bo√Æte.  Le lecteur fonctionne finalement sur la base de l'√©l√©ment vid√©o HTML5. </p><br><p></p><br><h3> <strong><a name="outHLS"></a></strong>  <strong>Hls sortants</strong> </h3><br><p><img src="https://habrastorage.org/webt/if/5l/5f/if5l5fdsrgbgaekle2edci9gyws.jpeg"></p><br><p>  Ici, WCS agit comme un serveur HLS ou un serveur Web qui prend en charge HLS (HTTP Live Streaming).  Une fois que le flux entrant appara√Æt sur le serveur, une liste de lecture HLS .m3u8 est g√©n√©r√©e, qui est remise au lecteur en r√©ponse √† une demande HTTP.  La liste de lecture d√©crit les segments vid√©o que le lecteur doit t√©l√©charger et afficher.  Le lecteur t√©l√©charge des segments vid√©o et les lit sur la page du navigateur, sur l'appareil mobile, sur le bureau, dans le d√©codeur Apple TV et partout o√π le support HLS est revendiqu√©. </p><br><p></p><br><h2><a name="IncomingOutgoing"></a>  Entrant et sortant </h2><br><p>  Au total, nous avons 5 types de flux entrants et sortants.  Ils sont r√©pertori√©s dans le tableau: </p><br><br><div class="scrollable-table"><table><thead><tr><th>  <strong>Bo√Æte de r√©ception</strong> </th><th>  <strong>Sortant</strong> </th></tr></thead><tbody><tr><td>  WebRTC </td><td>  WebRTC </td></tr><tr><td>  RTMP </td><td>  RTMP </td></tr><tr><td>  Rtsp </td><td>  Rtsp </td></tr><tr><td>  Vod </td><td>  MSE </td></tr><tr><td>  SIP / RTP </td><td>  Hls </td></tr></tbody></table></div><br><p>  Autrement dit, nous pouvons t√©l√©charger les flux sur le serveur, nous y connecter et les lire avec des lecteurs appropri√©s.  Pour lire un flux WebRTC, utilisez le SDK Web.  Pour lire un flux WebRTC en tant que HLS, utilisez un lecteur HLS, etc.  Un flux peut √™tre jou√© par de nombreux spectateurs.  Les diffusions un √† plusieurs fonctionnent. </p><br><p>  D√©crivons maintenant quelles actions peuvent √™tre effectu√©es avec les flux. </p><br><p></p><br><h2><a name="manipulatingincoming"></a>  Manipulation de flux entrant </h2><br><p>  Les flux sortants avec des spectateurs ne sont pas faciles √† manipuler.  En effet, si le visualiseur a √©tabli une session avec le serveur et re√ßoit d√©j√† une sorte de flux, il n'y a aucun moyen d'y apporter des modifications sans interrompre la session.  Pour cette raison, toutes les manipulations et modifications ont lieu sur les flux entrants, au point o√π sa r√©plication ne s'est pas encore produite.  Le flux qui a subi des modifications est ensuite distribu√© √† tous les t√©l√©spectateurs connect√©s. </p><br><p>  Les pr√©sentations de flux incluent: </p><br><p>  - enregistrement </p><br><p>  - prendre un instantan√© </p><br><p>  - ajouter un flux au m√©langeur </p><br><p>  - transcodage de flux </p><br><p>  - ajouter un filigrane </p><br><p>  - ajout d'un filtre FPS </p><br><p>  - rotation de l'image de 90, 180, 270 degr√©s </p><br><p></p><br><h3> <strong><a name="recording"></a></strong>  <strong>Enregistrement de flux entrant</strong> </h3><br><p><img src="https://habrastorage.org/webt/m_/je/j8/m_jej8-gdyvh2e2urt4s75ltsse.jpeg"></p><br><p>  Peut-√™tre la fonction la plus compr√©hensible et la plus fr√©quemment rencontr√©e.  En effet, dans de nombreux cas, les flux doivent √™tre enregistr√©s: webinaires, cours d'anglais, consultations, etc. <br><img src="https://habrastorage.org/webt/kz/t0/_r/kzt0_rj0y1mvgb4rnob5ix4_bnk.jpeg"><br>  L'enregistrement peut √™tre lanc√© avec le Web SDK ou l'API REST avec une demande sp√©ciale: </p><br><pre> <code class="plaintext hljs">/stream/startRecording {}</code> </pre> <br><p>  Le r√©sultat est enregistr√© dans le syst√®me de fichiers en tant que fichier mp4. </p><br><p></p><br><h3> <strong><a name="snapshot"></a></strong>  <strong>Prendre un instantan√©</strong> </h3><br><p><img src="https://habrastorage.org/webt/cg/g6/yh/cgg6yhu_d8lj4tl6tecphzvgsce.jpeg"></p><br><p>  Une t√¢che tout aussi courante consiste √† prendre des photos du flux actuel pour afficher des ic√¥nes sur le site.  Par exemple, nous avons 50 flux dans un syst√®me de vid√©osurveillance, dont chacun a une cam√©ra IP comme source.  L'affichage des 50 discussions sur une seule page est non seulement probl√©matique pour les ressources du navigateur, mais aussi inutile.  Dans le cas de 30 FPS, le FPS total de l'image changeante sera de 1500, et l'≈ìil humain n'acceptera tout simplement pas une telle fr√©quence d'affichage.  Comme solution, nous pouvons configurer le d√©coupage automatique ou la prise d'instantan√©s √† la demande;  dans ce cas, des images avec une fr√©quence arbitraire peuvent √™tre affich√©es sur le site, par exemple, 1 image en 10 secondes.  Les instantan√©s peuvent √™tre supprim√©s du SDK via l'API REST ou d√©coup√©s automatiquement. </p><br><p><img src="https://habrastorage.org/webt/b9/c5/hf/b9c5hfkspnmifm7wfw96aatldl8.jpeg"></p><br><p>  Le serveur WCS prend en charge la m√©thode REST pour recevoir des instantan√©s: </p><br><pre> <code class="plaintext hljs">/stream/snapshot</code> </pre> <br><p></p><br><p><img src="https://habrastorage.org/webt/5c/8z/v-/5c8zv-0i7uglnd6t5eyldejyzt0.jpeg"></p><br><p></p><br><h3> <strong><a name="mixer"></a></strong>  <strong>Ajout d'un flux au m√©langeur</strong> </h3><br><p><img src="https://habrastorage.org/webt/o3/mx/bj/o3mxbjmxo3evugpsr5td7wko1pc.jpeg"></p><br><p>  Une image provenant de deux sources ou plus peut √™tre combin√©e en une seule pour √™tre affich√©e aux t√©l√©spectateurs finaux.  Cette proc√©dure est appel√©e m√©lange.  Exemples de base: 1) Surveillance vid√©o de plusieurs cam√©ras sur l'√©cran en une seule image.  2) Vid√©oconf√©rence, o√π chaque utilisateur re√ßoit un flux, dans lequel les autres sont m√©lang√©s, pour √©conomiser des ressources.  Le m√©langeur est contr√¥l√© via l'API REST et dispose d'un mode de fonctionnement MCU pour cr√©er des vid√©oconf√©rences. </p><br><p>  Commande REST pour ajouter un flux au m√©langeur: </p><br><pre> <code class="plaintext hljs">/mixer/startup</code> </pre> <br><p></p><br><h3> <strong><a name="transcoding"></a></strong>  <strong>Transcodage de flux</strong> </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d19/7de/e1b/d197dee1b288f44501461f2893f19af6.jpg" alt="transcoding_WebRTC_Android_iOS_SDK_API_WCS_browser_RTMP_RTSP_VOD_SIP_RTP" width="924" height="553"></p><br><p>  Les flux doivent parfois √™tre compress√©s afin de s'adapter √† certains groupes de p√©riph√©riques clients par r√©solution et d√©bit binaire.  Pour cela, le transcodage est utilis√©.  Le transcodage peut √™tre activ√© du c√¥t√© du SDK Web, via l'API REST, ou automatiquement via un n≈ìud de transcodage sp√©cial dans le CDN.  Par exemple, une vid√©o de 1280x720 peut √™tre transcod√©e en 640x360 pour √™tre distribu√©e aux clients d'une r√©gion g√©ographique avec une bande passante traditionnellement faible.  O√π sont tes satellites, Elon Musk? </p><br><p><img src="https://habrastorage.org/webt/yn/t2/5g/ynt25g1_9phfzcqtptzb0e0u3gq.jpeg"></p><br><p>  M√©thode REST utilis√©e: </p><br><pre> <code class="plaintext hljs">/transcoder/startup</code> </pre> <br><p></p><br><h3> <strong><a name="watermark"></a></strong>  <strong>Ajout d'un filigrane</strong> </h3><br><p><img src="https://habrastorage.org/webt/l_/7q/-t/l_7q-td_lifwkr5aw3mn-btem1o.png"></p><br><p>  Il est connu que tout contenu peut √™tre vol√© et transform√© en WebRip, quelle que soit la protection du joueur.  Si votre contenu est pr√©cieux, vous pouvez y incorporer un filigrane ou un logo qui compliquera consid√©rablement son utilisation ult√©rieure et son affichage public.  Pour ajouter un filigrane, t√©l√©chargez simplement une image PNG et elle sera ins√©r√©e dans le flux vid√©o par transcodage.  Par cons√©quent, vous devrez pr√©parer quelques c≈ìurs de processeur c√¥t√© serveur au cas o√π vous d√©cideriez toujours d'ajouter un filigrane au flux.  Afin de ne pas cr√©er le filigrane sur le serveur par transcodage, il est pr√©f√©rable de l'ajouter directement sur l'encodeur / streamer, ce qui offre souvent une telle opportunit√©. </p><br><p></p><br><h3> <strong><a name="fpsfilter"></a></strong>  <strong>Ajout d'un filtre FPS</strong> </h3><br><p><img src="https://habrastorage.org/webt/27/oi/bk/27oibkbef1jtrjulbcdcpomi_ts.png"></p><br><p>  Dans certains cas, il est n√©cessaire que le flux ait un FPS pair (images par seconde).  Cela peut √™tre utile si nous retransmettons le flux vers une ressource tierce comme Youtube ou Facebook ou si nous le lisons avec un lecteur HLS sensible.  Le filtrage n√©cessite √©galement un transcodage, alors assurez-vous d'√©valuer correctement la puissance de votre serveur et pr√©parez 2 c≈ìurs par flux si une telle op√©ration est pr√©vue. </p><br><p></p><br><h3> <strong><a name="rotate"></a></strong>  <strong>Rotation de l'image de 90, 180, 270 degr√©s</strong> </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8fe/997/147/8fe997147f962e8d2f2d3405c5415f6e.png" alt="rotation_WebRTC_Android_iOS_SDK_API_WCS_browser_RTMP_RTSP_VOD_SIP_RTP" width="628" height="189"></p><br><p>  Les appareils mobiles ont la possibilit√© de modifier la r√©solution du flux publi√© en fonction de l'angle de rotation.  Par exemple, vous avez commenc√© √† diffuser, en tenant l'iPhone horizontalement, puis en le faisant pivoter.  Selon la sp√©cification WebRTC, le navigateur de streamer de l'appareil mobile (dans ce cas iOS Safari) devrait signaler la rotation au serveur.  √Ä son tour, le serveur doit envoyer cet √©v√©nement √† tous les abonn√©s.  Sinon, ce serait comme √ßa - le streamer a mis le t√©l√©phone sur le c√¥t√©, mais voit toujours son appareil photo verticalement, tandis que les t√©l√©spectateurs voient une image pivot√©e.  Pour travailler avec des rotations du c√¥t√© du SDK, l'extension cvoExtension correspondante est incluse. </p><br><p></p><br><h3> <strong><a name="manage"></a></strong>  <strong>Gestion des flux entrants</strong> </h3><br><p>  Automatique - la configuration est g√©n√©ralement d√©finie c√¥t√© serveur dans les param√®tres. </p><br><div class="scrollable-table"><table><thead><tr><th>  Action d'√©coulement </th><th>  Web, iOS, SDK Android </th><th>  API REST </th><th>  Automatique </th><th>  Cdn </th></tr></thead><tbody><tr><td>  Record </td><td>  + </td><td>  + </td><td><br></td><td><br></td></tr><tr><td>  Suppression d'instantan√©s </td><td>  + </td><td>  + </td><td>  + </td><td><br></td></tr><tr><td>  Ajout au m√©langeur </td><td>  + </td><td>  + </td><td><br></td><td><br></td></tr><tr><td>  Transcodage de flux </td><td>  + </td><td>  + </td><td><br></td><td>  + </td></tr><tr><td>  Ajout d'eau <br>  signe </td><td><br></td><td><br></td><td>  + </td><td><br></td></tr><tr><td>  Ajout d'un filtre FPS </td><td><br></td><td><br></td><td>  + </td><td><br></td></tr><tr><td>  Faites pivoter l'image de 90, <br>  180, 270 degr√©s </td><td>  + </td><td><br></td><td><br></td><td><br></td></tr></tbody></table></div><br><p></p><br><h2><a name="Streamrelay"></a>  Relais de flux </h2><br><p>  Le relais est √©galement une option pour manipuler les flux entrant dans le serveur;  il consiste √† forcer le flux vers un serveur tiers.  Relayer est synonyme de mots tels que republier, pousser, injecter. </p><br><p>  Le relais peut √™tre impl√©ment√© en utilisant l'un des protocoles suivants: WebRTC, RTMP, SIP / RTP.  Le tableau indique la direction dans laquelle le flux peut √™tre relay√©. </p><br><br><div class="scrollable-table"><table><thead><tr><th>  WebRTC </th><th>  RTMP </th><th>  SIP / RTP </th></tr></thead><tbody><tr><td>  WCS </td><td>  Serveur RTMP WCS </td><td>  Serveur SIP </td></tr></tbody></table></div><br><br><h3> <strong><a name="repubWebRTC"></a></strong>  <strong>Relais WebRTC</strong> </h3><br><p><img src="https://habrastorage.org/webt/d9/yf/cc/d9yfccsjz8zqvx3jo-3gas2nuu8.jpeg"></p><br><p>  Un flux peut √™tre relay√© vers un autre serveur WCS si, pour une raison quelconque, il est n√©cessaire de rendre le flux disponible sur un autre serveur.  Le relais se fait via la m√©thode via / push de l'API REST.  √Ä la r√©ception d'une telle demande REST, WCS se connecte au serveur sp√©cifi√© et y publie un flux serveur-serveur.  Apr√®s cela, le flux devient disponible pour la lecture sur une autre machine. </p><br><pre> <code class="plaintext hljs">/pull/push</code> </pre> <br><p>  - m√©thode REST utilis√©e </p><br><p></p><br><h3> <strong><a name="rebubRTMP"></a></strong>  <strong>Relais RTMP</strong> </h3><br><p><img src="https://habrastorage.org/webt/y-/hv/tn/y-hvtne9e-vtgry-2or6nhmqzte.jpeg"></p><br><p>  Comme pour le relais WebRTC, le relais RTMP vers un autre serveur est √©galement possible.  La diff√©rence ne concernera que le protocole de relais.  Le relais RTMP est √©galement effectu√© via / push et permet de transf√©rer le flux vers des serveurs RTMP tiers et vers des services prenant en charge RTMP Ingest: Youtube, streaming Facebook, etc.  Ainsi, le flux WebRTC peut √™tre relay√© vers RTMP.  Nous pourrions aussi bien relayer tout autre flux entrant dans le serveur, par exemple RTSP ou VOD, √† RTMP. </p><br><p>  Le flux vid√©o est relay√© vers un autre serveur RTMP √† l'aide d'appels REST. </p><br><pre> <code class="plaintext hljs">/push/startup</code> </pre> <br><p>  - appel REST utilis√© </p><br><p></p><br><h3> <strong><a name="repubSIP-RTP"></a></strong>  <strong>Relais SIP / RTP</strong> </h3><br><p><img src="https://habrastorage.org/webt/sl/tt/hj/sltthjlgwbvryka0vgpqel0hcx8.jpeg"><br></p><p>  C'est une fonction rarement utilis√©e.  Le plus souvent, il est utilis√© en entreprise.  Par exemple, lorsque nous devons √©tablir un appel SIP avec un serveur de conf√©rence SIP externe et rediriger le flux audio ou vid√©o vers cet appel afin que le public de la conf√©rence voit une sorte de contenu vid√©o: ¬´Veuillez regarder cette vid√©o¬ª ou ¬´Coll√®gues , regardons maintenant un flux de cam√©ras IP depuis le chantier ¬ª.  Nous devons garder √† l'esprit que dans ce cas, la conf√©rence elle-m√™me existe et est g√©r√©e sur un serveur VKS externe avec prise en charge SIP (r√©cemment, nous avons test√© la solution de Polycom DMA), alors que nous nous connectons et relayons simplement le flux existant √† ce serveur.  La fonction API REST est appel√©e / inject et ne sert que dans ce cas. </p><br><p>  Commande REST API: </p><br><pre> <code class="plaintext hljs">/call/inject_stream/startup</code> </pre> <br><p></p><br><h2><a name="CDN"></a>  Connexion de serveurs √† un r√©seau de traitement de contenu CDN </h2><br><p>  Habituellement, un serveur a une quantit√© limit√©e de ressources.  Par cons√©quent, pour les grandes diffusions en ligne o√π l'audience compte pour des milliers et des dizaines de milliers, une mise √† l'√©chelle est n√©cessaire.  Plusieurs serveurs WCS peuvent √™tre combin√©s en un seul r√©seau de distribution de contenu CDN.  En interne, CDN travaillera via WebRTC pour maintenir une faible latence pendant la diffusion. </p><br><p><img src="https://habrastorage.org/webt/99/sx/gd/99sxgd8frahbmd2trrxsfltfmeg.jpeg"></p><br><p>  Le serveur peut √™tre configur√© dans l'un des r√¥les suivants: origine, p√©riph√©rie ou transcodeur.  Les serveurs de type origine re√ßoivent le trafic et le distribuent aux serveurs Edge, qui sont charg√©s de fournir le flux aux t√©l√©spectateurs.  S'il est n√©cessaire de pr√©parer un flux dans plusieurs r√©solutions, les n≈ìuds de transcodeur sont inclus dans le sch√©ma, qui assument la mission consommatrice de ressources de transcodage des flux. </p><br><p></p><br><h2><a name="summarize"></a>  Pour r√©sumer </h2><br><p>  WCS 5.2 est un serveur de d√©veloppement d'applications avec prise en charge audio et vid√©o en temps r√©el pour les navigateurs et les appareils mobiles.  Quatre API sont fournies pour le d√©veloppement: Web SDK, iOS SDK, Android SDK, REST API.  Nous pouvons publier (alimenter) des flux vid√©o sur le serveur en utilisant cinq protocoles: WebRTC, RTMP, RTSP, VOD, SIP / RTP.  Depuis le serveur, nous pouvons lire des flux avec des joueurs en utilisant cinq protocoles: WebRTC, RTMP, RTSP, MSE, HLS.  Les flux peuvent √™tre contr√¥l√©s et subir des op√©rations telles que l'enregistrement, le d√©coupage d'instantan√©s, le mixage, le transcodage, l'ajout d'un filigrane, le filtrage FPS et la diffusion de tours vid√©o sur des appareils mobiles.  Les flux peuvent √™tre relay√©s vers d'autres serveurs via les protocoles WebRTC et RTMP, ainsi que redirig√©s vers des conf√©rences SIP.  Les serveurs peuvent √™tre combin√©s en un r√©seau de diffusion de contenu et mis √† l'√©chelle pour traiter un nombre arbitraire de flux vid√©o. </p><br><h3>  <strong>Ce qu'Alice doit savoir pour travailler avec le serveur</strong> </h3><br><p>  Le d√©veloppeur doit pouvoir utiliser Linux.  Les commandes suivantes dans la ligne de commande ne doivent pas cr√©er de confusion: </p><br><pre> <code class="plaintext hljs">tar -xvzf wcs5.2.tar.gz</code> </pre> <br><pre> <code class="plaintext hljs">cd wcs5.2</code> </pre> <br><pre> <code class="plaintext hljs">./install.sh</code> </pre> <br><pre> <code class="plaintext hljs">tail -f flashphoner.log</code> </pre> <br><pre> <code class="plaintext hljs">ps aux | grep WebCallServer</code> </pre> <br><pre> <code class="plaintext hljs">top</code> </pre> <br><p>  Il faut √©galement conna√Ætre Vanilla JavaScript en mati√®re de d√©veloppement Web. </p><br><pre> <code class="plaintext hljs">//publishing the stream session.createStream({name:'mystream'}).publish(); //playing the stream session.createStream({name:'mystream'}).play();</code> </pre><br><p>  La possibilit√© de travailler avec le back-end peut √©galement √™tre utile. </p><br><p><img src="https://habrastorage.org/webt/3l/0a/9s/3l0a9shqbhfy4yjheu30ocammzg.jpeg"></p><br><p>  WCS peut non seulement recevoir des commandes de contr√¥le via l'API REST, mais √©galement envoyer des hooks - c'est-√†-dire des notifications sur les √©v√©nements qui s'y produisent.  Par exemple, lorsque vous essayez d'√©tablir une connexion √† partir d'un navigateur ou d'une application mobile, WCS d√©clenchera le hook / connect, et lorsque vous essayez de lire un flux, il d√©clenchera le hook playStream.  Par cons√©quent, le d√©veloppeur devra marcher un peu dans la peau du back ender, qui est capable de cr√©er √† la fois un simple client REST et un petit serveur REST pour le traitement des hooks. </p><br><p>  Exemple d'API REST </p><br><pre> <code class="plaintext hljs">/rest-api/stream/find_all</code> </pre> <br><p>  - exemple d'API REST pour lister les flux sur le serveur </p><br><p>  Exemple de crochet REST </p><br><pre> <code class="plaintext hljs">https://myback-end.com/hook/connect</code> </pre> <br><p>  - Traitement REST hook / connect c√¥t√© backend. </p><br><p>  Linux, JavaScript, REST Client / Serveur - trois √©l√©ments suffisants pour d√©velopper un service de production sur la plate-forme WCS fonctionnant avec des flux vid√©o. </p><br><p>  Le d√©veloppement d'applications mobiles n√©cessitera une connaissance de Java et Objective-C pour Android et iOS, respectivement. </p><br><h3>  <strong>Installation et lancement</strong> </h3><br><p>  Il existe trois fa√ßons de lancer rapidement WCS aujourd'hui: </p><br><p>  1) Installez Ubuntu 16.x LTS ou Ubuntu 18.x LTS etc.  sur votre Centos7.  ou √™tre guid√© par un <a href="https://docs.flashphoner.com/display/WCS52EN/Quick%2Bdeployment%2Band%2Btesting%2Bof%2Bthe%2Bserver">article de la documentation</a> . </p><br><p>  ou </p><br><p>  2) Obtenez une <a href="https://flashphoner.com/amazon-ec2-support-in-web-call-server">image pr√™te √† l'emploi sur Amazon EC2</a> . </p><br><p>  ou </p><br><p>  3) Obtenez une <a href="https://flashphoner.com/web-call-server-on-digital-ocean-marketplace">image pr√™te √† l'emploi du serveur sur Digital Ocean</a> . </p><br><p>  Et commencez un d√©veloppement de projet passionnant avec des fonctionnalit√©s de streaming vid√©o. </p><br><p>  L'article de revue s'est av√©r√© assez volumineux.  Merci pour la patience de le lire. </p><br><p>  Bon streaming! </p><br><p></p><br><h2><a name="Links"></a>  Les liens </h2><br><p>  <a href="https://flashphoner.com/">WCS 5.2</a> - Serveur WebRTC </p><br><h3>  Installation et lancement </h3><br><p>  <a href="https://docs.flashphoner.com/display/WCS52EN/Quick%2Bdeployment%2Band%2Btesting%2Bof%2Bthe%2Bserver">Installation et lancement de WCS</a> <br>  <a href="https://flashphoner.com/amazon-ec2-support-in-web-call-server">Lancer une image pr√™te √† l'emploi sur Amazon EC2</a> <br>  <a href="https://flashphoner.com/web-call-server-on-digital-ocean-marketplace">Lancer l'image pr√™te √† l'emploi du serveur sur DigitalOcean</a> </p><br><h3>  SDK </h3><br><p>  <a href="https://docs.flashphoner.com/display/WCS52EN/Web%2BSDK">SDK Web de documentation</a> <br>  <a href="https://docs.flashphoner.com/display/WCS52EN/Android%2BSDK">Documentation SDK Android</a> <br>  <a href="https://docs.flashphoner.com/display/WCS52EN/iOS%2BSDK">Documentation iOS SDK</a> </p><br><h3>  √âtuis </h3><br><p>  <a href="https://docs.flashphoner.com/display/WCS52EN/Stream%2Bcapturing%2Band%2Bpublishing%2Bto%2Bthe%2Bserver">Flux entrants</a> <br>  <a href="https://docs.flashphoner.com/display/WCS52EN/Playing%2Ba%2Bvideo%2Bstream%2Bfrom%2Bthe%2Bserver">Flux sortants</a> <br>  <a href="https://docs.flashphoner.com/display/WCS52EN/Captured%2Bstream%2Bmanagement">Gestion des flux</a> <br>  <a href="https://docs.flashphoner.com/display/WCS52EN/Republishing%2Ba%2Bvideo%2Bstream">Relais de flux</a> <br>  <a href="">CDN pour le streaming WebRTC √† faible latence</a> </p><br><h3>  La documentation </h3><br><p>  <a href="https://docs.flashphoner.com/display/WCS52EN/Web%2BCall%2BServer%2B5.2%2B-%2BEN">Documentation Web Call Server 5.2</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr482956/">https://habr.com/ru/post/fr482956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr482942/index.html">Mythes et l√©gendes de l'ancien Fediverse</a></li>
<li><a href="../fr482944/index.html">Distributeur de convoyeur multi-composants</a></li>
<li><a href="../fr482946/index.html">1–° DSS et estimation des conditions et co√ªt des projets par la m√©thode COCOMO II</a></li>
<li><a href="../fr482948/index.html">"Un, deux, trois - br√ªlez le sapin de No√´l!" Ou mon premier regard sur le petit contr√¥leur CANNY 3</a></li>
<li><a href="../fr482950/index.html">Java: des choses qui peuvent sembler curieuses √† un d√©veloppeur exp√©riment√©</a></li>
<li><a href="../fr482958/index.html">"R√®gles de croissance: du junior au CTO", r√©sum√© d'un webinaire de Fedor Borshchev</a></li>
<li><a href="../fr482960/index.html">Pr√©sentation de WCS 5.2 - Serveur WebRTC pour les d√©veloppeurs Web de diffusions en ligne et de chat vid√©o</a></li>
<li><a href="../fr482968/index.html">Quarkus - Un nouveau regard sur Java Native Cloud</a></li>
<li><a href="../fr482970/index.html">Hack The Box - Proc√©dure pas √† pas. Nous creusons dans Git, exploitons les vuln√©rabilit√©s de l'API, traitons avec Vault</a></li>
<li><a href="../fr482974/index.html">Soutien en sant√© mentale avec r√©alit√© virtuelle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>