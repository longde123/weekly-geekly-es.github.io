<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎴 🖐🏼 🐪 Examen de WCS 5.2 - Serveur WebRTC pour développeurs Webcast et Webcam 👩‍👩‍👧‍👦 💃🏿 🧞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alice est un développeur expérimenté de pile complète, capable d'écrire un cadre de projet SAAS sur son cadre préféré en utilisant php en une semaine....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Examen de WCS 5.2 - Serveur WebRTC pour développeurs Webcast et Webcam</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flashphoner/blog/482956/"><img src="https://habrastorage.org/webt/za/go/wo/zagowolkguxr8_bdsbwjmkvyd0a.jpeg"><br><br><p>  Alice est un développeur expérimenté de pile complète, capable d'écrire un cadre de projet SAAS sur son cadre préféré en utilisant php en une semaine.  Quant au frontend, elle préfère Vue.js. </p><br><p>  Un client vous contacte via Telegram, vous demandant de développer un site Web qui sera le lieu de rencontre pour l'employeur et l'employé pour mener une entrevue en personne.  En personne signifie en face à face, un contact vidéo direct en temps réel avec vidéo et voix.  "Pourquoi ne pas utiliser Skype?"  Il se trouve que des projets sérieux - et chaque startup se considère sans aucun doute comme un projet sérieux - essaient d'offrir un service de communication interne pour diverses raisons, notamment: </p><a name="habracut"></a><br><p>  1) Ils ne veulent pas prêter ses utilisateurs à des communicateurs tiers (Skype, Hangouts, etc.) et souhaitent les conserver dans le service. </p><br><p>  2) Le désir de surveiller leurs communications, comme l'historique des appels et les résultats des entretiens. </p><br><p>  3) Enregistrez les appels (naturellement, informez les deux parties de l'enregistrement). </p><br><p> 4) Ils ne veulent pas dépendre des politiques et des mises à jour des services tiers.  Tout le monde connaît cette histoire: Skype a été mis à jour, et tout part en fumée ... </p><br><p>  Cela semble être une tâche facile.  WebRTC apparaît lors de la recherche sur le sujet, et il semble que vous pouvez organiser une connexion d'égal à égal entre deux navigateurs, mais il reste des questions: </p><br><p>  1) Où trouver les serveurs STUN / TURN? </p><br><p>  2) Peut-on s'en passer? </p><br><p>  3) Comment enregistrer un appel WebRTC poste à poste? </p><br><p>  4) Que se passera-t-il si nous devons ajouter un tiers à l'appel, par exemple un responsable RH ou un autre spécialiste de l'employeur? </p><br><p>  Il s'avère que WebRTC et peer-to-peer seuls ne suffisent pas, et on ne sait pas quoi faire avec tout cela pour lancer les fonctions vidéo requises du service. </p><br><h2>  Contenu de l'article </h2><br><div class="spoiler">  <b class="spoiler_title">Table des matières</b> <div class="spoiler_text"><ul><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Serveur et API</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Flux entrants</a> <br><ul><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">WebRTC</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">RTMP</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Rtsp</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Vod</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">SIP / RTP</a> </li></ul><br></li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Flux sortants</a> <br><ul><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">WebRTC</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">RTMP</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Rtsp</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">MSE</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Hls</a> </li></ul><br></li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Entrant et sortant</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Manipulation de flux entrant</a> <br><ul><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Enregistrement de flux entrant</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Prendre un instantané</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Ajout d'un flux au mélangeur</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Transcodage de flux</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Ajout d'un filigrane</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Ajout d'un filtre FPS</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Rotation de l'image de 90, 180, 270 degrés</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Gestion des flux entrants</a> </li></ul><br></li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Relais de flux</a> <br><ul><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">WebRTC</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">RTMP</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">SIP / RTP</a> </li></ul><br></li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Connexion de serveurs à un réseau de traitement de contenu CDN</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Pour résumer</a> </li><li>  <a href="https://habr.com/ru/company/flashphoner/blog/482956/">Les liens</a> </li></ul><br></div></div><br><h2><a name="serverapi"></a>  Serveur et API </h2><br><p>  Pour combler ces lacunes, des solutions serveur et une architecture pair-serveur-pair sont utilisées.  Web Call Server 5.2 (ci-après - WCS) est l'une des solutions serveur;  c'est une plate-forme de développement qui vous permet d'ajouter de telles fonctions vidéo au projet et de ne pas vous soucier de la STUN / TURN et de la stabilité de la connexion peer-to-peer. </p><br><p>  Au plus haut niveau, WCS est une partie JavaScript API + serveur.  L'API est utilisée pour le développement en utilisant du JavaScript normal du côté du navigateur, et le serveur traite le trafic vidéo, agissant comme un proxy dynamique pour le trafic multimédia. </p><br><p><img src="https://habrastorage.org/webt/7a/w0/qv/7aw0qvwyfc9tak6ij9ycdr1sju4.png"></p><br><p>  En plus de l'API JavaScript, il existe également le SDK Android et le SDK iOS, qui sont nécessaires pour développer des applications mobiles natives pour iOS et Android, respectivement. </p><br><p>  Par exemple, la publication d'un flux sur le serveur (streaming d'une webcam vers le serveur) ressemble à ceci: </p><br><p>  Web sdk </p><br><pre><code class="plaintext hljs">session.createStream({name:”stream123”}).publish();</code> </pre> <br><p>  SDK Android </p><br><pre> <code class="plaintext hljs">publishStream = session.createStream(streamOptions) publishStream.publish();</code> </pre><br><p>  SDK iOS </p><br><pre> <code class="plaintext hljs">FPWCSApi2Stream *stream = [session createStream:options error:&amp;error]; if(![stream publish:&amp;error]) { //published without errors }</code> </pre><br><p>  En conséquence, nous pouvons mettre en œuvre non seulement une application Web, mais également des mises à jour à part entière pour Google Play et l'App Store avec prise en charge du streaming vidéo.  Si nous ajoutons le SDK mobile à l'image de niveau supérieur, nous obtiendrons ceci: </p><br><p><img src="https://habrastorage.org/webt/tf/z-/ya/tfz-yax_izaf-eyitcvd57y82h0.png"></p><br><p></p><br><h2><a name="Incomingstreams"></a>  Flux entrants </h2><br><p>  Le serveur de streaming, qui est WCS, démarre avec les flux entrants.  Pour distribuer quelque chose, nous devons l'avoir.  Pour distribuer des flux vidéo aux téléspectateurs, il est nécessaire que ces flux entrent dans le serveur, passent par sa RAM et sortent par la carte réseau.  Par conséquent, la première question que nous devons nous poser lorsque nous nous familiarisons avec le serveur multimédia est de savoir quels protocoles et formats ce dernier utilise pour accepter les flux.  Dans le cas de WCS, ce sont les technologies suivantes: WebRTC, RTMP, RTSP, VOD, SIP / RTP. </p><br><p><img src="https://habrastorage.org/webt/du/2r/pc/du2rpcr6ihdkicklwlyusrodjog.png"></p><br><p>  Chacun des protocoles peut être utilisé par divers clients.  Par exemple, non seulement le flux du navigateur peut entrer via WebRTC, mais aussi à partir d'un autre serveur.  Le tableau ci-dessous répertorie les sources possibles de trafic entrant. </p><br><div class="scrollable-table"><table><tbody><tr><td>  <strong>WebRTC</strong> </td><td>  <strong>RTMP</strong> </td><td>  <strong>Rtsp</strong> </td><td>  <strong>Vod</strong> </td><td>  <strong>SIP / RTP</strong> </td></tr><tr><td><ul><li>  Web sdk <br><ul><li>  caméra + micro </li><li>  toile </li><li>  partage d'écran </li></ul><br></li><li>  SDK Android </li><li>  SDK iOS </li><li>  WCS <br><ul><li>  pousser </li><li>  tirer </li></ul><br></li><li>  Cdn </li></ul><br></td><td><ul><li>  Encodeur RTMP <br><ul><li>  ffmpeg </li><li>  Obs </li><li>  Wirecast </li></ul><br></li><li>  Encodeur Adobe </li><li>  WCS <br><ul><li>  pousser </li><li>  tirer </li></ul><br></li><li>  Lecteur Flash </li></ul><br></td><td><ul><li>  Caméra IP </li><li>  Serveur RTSP </li></ul><br></td><td><ul><li>  Système de fichiers </li><li>  AWS S3 </li></ul><br></td><td><ul><li>  Point de terminaison SIP </li><li>  Conférence SIP </li></ul><br></td></tr></tbody></table></div><br><br><p>  Si nous passons par les sources de trafic entrant, nous pouvons ajouter ce qui suit: <br></p><br><h3> <strong><a name="inWebRTC"></a></strong>  <strong>WebRTC entrant</strong> </h3><br><p>  Le SDK Web permet non seulement de capturer la caméra et le microphone, mais également d'utiliser les capacités de l'API du navigateur pour accéder à l'écran via le partage d'écran.  De plus, nous pouvons capturer un élément Canvas arbitraire, et tout ce qui est dessiné dessus pour une diffusion ultérieure est un streaming de toile: </p><br><p>  En raison des spécificités mobiles, le SDK Android et le SDK iOS ont la possibilité de basculer entre les caméras avant et arrière de l'appareil lors de vos déplacements.  Cela nous permet de changer de source pendant la diffusion sans avoir à interrompre le flux. </p><br><p>  Le flux WebRTC entrant peut également être obtenu à partir d'un autre serveur WCS en utilisant les méthodes push, pull et CDN, qui seront discutées plus loin. </p><br><p><img src="https://habrastorage.org/webt/zn/rw/5i/znrw5ikkd8vcjuexwarfzeqkhg4.jpeg"></p><br><p></p><br><h3> <strong><a name="inRTMP"></a></strong>  <strong>Rtmp entrant</strong> </h3><br><p>  Le protocole RTMP est largement utilisé dans l'OBS préféré des streamers, ainsi que dans d'autres encodeurs: Wirecast, Adobe Media Encoder, ffmpeg, etc.  En utilisant l'un de ces encodeurs, nous pouvons capturer le flux et l'envoyer au serveur. </p><br><p>  Nous pouvons également récupérer un flux RTMP à partir d'un autre serveur multimédia ou serveur WCS en utilisant les méthodes push et pull.  En cas de push, l'initiateur est le serveur distant.  Dans le cas de pull, nous nous tournons vers le serveur local pour extraire le flux du serveur distant. </p><br><p><img src="https://habrastorage.org/webt/3o/8x/f8/3o8xf84v5rx2apw_09n_lm2cjoe.jpeg"></p><br><p></p><br><h3> <strong><a name="inRTSP"></a></strong>  <strong>Rtsp entrant</strong> </h3><br><p>  Les sources de trafic RTSP sont généralement des caméras IP ou des serveurs multimédias tiers prenant en charge le protocole RTSP.  Malgré le fait que lors de l'initialisation d'une connexion RTSP, l'initiateur est WCS, le trafic audio et vidéo en direction de la caméra IP se déplace vers le serveur WCS.  Par conséquent, nous considérons que le flux de la caméra est entrant. </p><br><p><img src="https://habrastorage.org/webt/ch/pj/qi/chpjqiof2ipgoqzmwx0zzkewrgm.jpeg"></p><br><p></p><br><h3> <strong><a name="inVOD"></a></strong>  <strong>Vod entrant</strong> </h3><br><p>  À première vue, il peut sembler que la fonction VOD (Video On Demand) est exclusivement associée aux flux sortants et à la lecture des fichiers par les navigateurs.  Mais dans notre cas, ce n'est pas entièrement vrai.  WCS diffuse un fichier mp4 du système de fichiers vers localhost;  en conséquence, un flux entrant est créé, comme s'il provenait d'une source tierce.  De plus, si nous limitons un visualiseur à un fichier mp4, nous obtenons le VOD classique, où le visualiseur obtient le flux et le lit depuis le tout début.  Si nous ne limitons pas une visionneuse à un seul fichier mp4, nous obtenons VOD LIVE - une variation de VOD, dans laquelle les spectateurs peuvent lire le même fichier en tant que flux, se connectant au point de lecture où tous les autres sont actuellement situés (pré- mode de diffusion télévisée enregistré). </p><br><p><img src="https://habrastorage.org/webt/cn/ot/tv/cnottvwwytktaxh9vnbjexlxlaq.jpeg"></p><br><p></p><br><h3> <strong><a name="inSIP-RTP"></a></strong>  <strong>SIP / RTP entrants</strong> </h3><br><p>  Pour recevoir le trafic RTP entrant dans une session SIP, nous devons établir un appel avec une passerelle SIP tierce.  Si la connexion est établie avec succès, le trafic audio et / ou vidéo ira de la passerelle SIP, qui sera enveloppée dans le flux entrant du côté WCS. </p><br><p><img src="https://habrastorage.org/webt/-r/km/io/-rkmio-9lhqlfjioblwkanzuxiq.jpeg"></p><br><p></p><br><h2><a name="Outgoingstreams"></a>  Flux sortants </h2><br><p>  Après avoir reçu le flux sur le serveur, nous pouvons répliquer le flux reçu sur un ou plusieurs téléspectateurs sur demande.  Le spectateur demande un flux au lecteur ou à un autre appareil.  Ces flux sont appelés flux sortants ou «flux de visionneuse», car les sessions de ces flux sont toujours lancées du côté de la visionneuse / du lecteur.  L'ensemble des technologies de lecture comprend les protocoles / formats suivants: WebRTC, RTMP, RTSP, MSE et HLS. </p><br><br><div class="scrollable-table"><table><thead><tr><th>  WebRTC </th><th>  RTMP </th><th>  Rtsp </th><th>  MSE </th><th>  Hls </th></tr></thead><tbody><tr><td><ul><li>  Web sdk </li><li>  SDK Android </li><li>  SDK iOS </li><li>  WC <br><ul><li>  tirer </li><li>  Cdn </li></ul><br></li></ul><br></td><td><ul><li>  Lecteur Flash </li><li>  Lecteurs RTMP </li></ul><br></td><td><ul><li>  Lecteur RTSP <br><ul><li>  VLC </li><li>  WCS </li><li>  etc. </li></ul><br></li></ul><br></td><td><ul><li>  Web sdk </li></ul><br></td><td><ul><li>  Joueurs HLS <br><ul><li>  hls.js </li><li>  safari natif </li></ul><br></li></ul><br></td></tr></tbody></table></div><br><h3> <strong><a name="outWebRTC"></a></strong>  <strong>WebRTC sortant</strong> </h3><br><p>  Dans ce cas, le SDK Web, le SDK Android et le SDK iOS agissent comme l'API du lecteur.  Un exemple de lecture de flux WebRTC ressemble à ceci: </p><br><p>  Web sdk </p><br><pre> <code class="plaintext hljs">session.createStream({name:”stream123”}).play();</code> </pre><br><p>  SDK Android </p><br><pre> <code class="plaintext hljs">playStream = session.createStream(streamOptions); playStream.play();</code> </pre><br><p>  SDK iOS </p><br><pre> <code class="plaintext hljs">FPWCSApi2Stream *stream = [session createStream:options error:nil]; if(![stream play:&amp;error]) { //published without errors }</code> </pre> <br><p>  Ceci est très similaire à l'API de publication, à la seule différence qu'au lieu de stream.publish (), stream.play () est appelé à jouer. </p><br><p>  Un serveur WCS tiers peut être le lecteur, qui sera chargé de récupérer le flux via WebRTC à partir d'un autre serveur à l'aide de la méthode d'extraction ou de récupérer le flux dans CDN. </p><br><p></p><br><h3> <strong><a name="outRTMP"></a></strong>  <strong>Rtmp sortant</strong> </h3><br><p><img src="https://habrastorage.org/webt/in/zq/nb/inzqnbejvsout_d4n5iiej4gozi.png"></p><br><p>  Ici, il y aura principalement des lecteurs RTMP - à la fois le célèbre Flash Player et les applications de bureau et mobiles qui utilisent le protocole RTMP, reçoivent et lisent un flux RTMP.  Malgré le fait que Flash ait quitté le navigateur, il a conservé le protocole RTMP, qui est largement utilisé pour les diffusions vidéo, et le manque de support natif dans les navigateurs n'empêche pas l'utilisation de ce protocole assez réussi dans d'autres applications clientes.  Il est connu que RTMP est largement utilisé dans les lecteurs VR pour les applications mobiles sur Android et iOS. </p><br><p></p><br><h3> <strong><a name="outRTSP"></a></strong>  <strong>Rtsp sortant</strong> </h3><br><p><img src="https://habrastorage.org/webt/ly/xu/r9/lyxur9b3gfzwsubfmrb3afmkfh0.png"></p><br><p>  Le serveur WCS peut agir comme un serveur RTSP et distribuer le flux reçu via RTSP comme une caméra IP standard.  Dans ce cas, le joueur doit établir une connexion RTSP avec le serveur et récupérer le flux pour la lecture, comme s'il s'agissait d'une caméra IP. </p><br><p></p><br><h3> <strong><a name="outMSE"></a></strong>  <strong>MSE sortant</strong> </h3><br><p><img src="https://habrastorage.org/webt/lt/wh/wz/ltwhwz7b8urhlg4m5ay-blpg-d8.jpeg"></p><br><p>  Dans ce cas, le lecteur demande un flux au serveur en utilisant le protocole Websocket.  Le serveur distribue des données audio et vidéo via des sockets Web.  Les données atteignent le navigateur et sont converties en morceaux que le navigateur peut jouer grâce à l'extension native MSE prise en charge dès la sortie de la boîte.  Le lecteur fonctionne finalement sur la base de l'élément vidéo HTML5. </p><br><p></p><br><h3> <strong><a name="outHLS"></a></strong>  <strong>Hls sortants</strong> </h3><br><p><img src="https://habrastorage.org/webt/if/5l/5f/if5l5fdsrgbgaekle2edci9gyws.jpeg"></p><br><p>  Ici, WCS agit comme un serveur HLS ou un serveur Web qui prend en charge HLS (HTTP Live Streaming).  Une fois que le flux entrant apparaît sur le serveur, une liste de lecture HLS .m3u8 est générée, qui est remise au lecteur en réponse à une demande HTTP.  La liste de lecture décrit les segments vidéo que le lecteur doit télécharger et afficher.  Le lecteur télécharge des segments vidéo et les lit sur la page du navigateur, sur l'appareil mobile, sur le bureau, dans le décodeur Apple TV et partout où le support HLS est revendiqué. </p><br><p></p><br><h2><a name="IncomingOutgoing"></a>  Entrant et sortant </h2><br><p>  Au total, nous avons 5 types de flux entrants et sortants.  Ils sont répertoriés dans le tableau: </p><br><br><div class="scrollable-table"><table><thead><tr><th>  <strong>Boîte de réception</strong> </th><th>  <strong>Sortant</strong> </th></tr></thead><tbody><tr><td>  WebRTC </td><td>  WebRTC </td></tr><tr><td>  RTMP </td><td>  RTMP </td></tr><tr><td>  Rtsp </td><td>  Rtsp </td></tr><tr><td>  Vod </td><td>  MSE </td></tr><tr><td>  SIP / RTP </td><td>  Hls </td></tr></tbody></table></div><br><p>  Autrement dit, nous pouvons télécharger les flux sur le serveur, nous y connecter et les lire avec des lecteurs appropriés.  Pour lire un flux WebRTC, utilisez le SDK Web.  Pour lire un flux WebRTC en tant que HLS, utilisez un lecteur HLS, etc.  Un flux peut être joué par de nombreux spectateurs.  Les diffusions un à plusieurs fonctionnent. </p><br><p>  Décrivons maintenant quelles actions peuvent être effectuées avec les flux. </p><br><p></p><br><h2><a name="manipulatingincoming"></a>  Manipulation de flux entrant </h2><br><p>  Les flux sortants avec des spectateurs ne sont pas faciles à manipuler.  En effet, si le visualiseur a établi une session avec le serveur et reçoit déjà une sorte de flux, il n'y a aucun moyen d'y apporter des modifications sans interrompre la session.  Pour cette raison, toutes les manipulations et modifications ont lieu sur les flux entrants, au point où sa réplication ne s'est pas encore produite.  Le flux qui a subi des modifications est ensuite distribué à tous les téléspectateurs connectés. </p><br><p>  Les présentations de flux incluent: </p><br><p>  - enregistrement </p><br><p>  - prendre un instantané </p><br><p>  - ajouter un flux au mélangeur </p><br><p>  - transcodage de flux </p><br><p>  - ajouter un filigrane </p><br><p>  - ajout d'un filtre FPS </p><br><p>  - rotation de l'image de 90, 180, 270 degrés </p><br><p></p><br><h3> <strong><a name="recording"></a></strong>  <strong>Enregistrement de flux entrant</strong> </h3><br><p><img src="https://habrastorage.org/webt/m_/je/j8/m_jej8-gdyvh2e2urt4s75ltsse.jpeg"></p><br><p>  Peut-être la fonction la plus compréhensible et la plus fréquemment rencontrée.  En effet, dans de nombreux cas, les flux doivent être enregistrés: webinaires, cours d'anglais, consultations, etc. <br><img src="https://habrastorage.org/webt/kz/t0/_r/kzt0_rj0y1mvgb4rnob5ix4_bnk.jpeg"><br>  L'enregistrement peut être lancé avec le Web SDK ou l'API REST avec une demande spéciale: </p><br><pre> <code class="plaintext hljs">/stream/startRecording {}</code> </pre> <br><p>  Le résultat est enregistré dans le système de fichiers en tant que fichier mp4. </p><br><p></p><br><h3> <strong><a name="snapshot"></a></strong>  <strong>Prendre un instantané</strong> </h3><br><p><img src="https://habrastorage.org/webt/cg/g6/yh/cgg6yhu_d8lj4tl6tecphzvgsce.jpeg"></p><br><p>  Une tâche tout aussi courante consiste à prendre des photos du flux actuel pour afficher des icônes sur le site.  Par exemple, nous avons 50 flux dans un système de vidéosurveillance, dont chacun a une caméra IP comme source.  L'affichage des 50 discussions sur une seule page est non seulement problématique pour les ressources du navigateur, mais aussi inutile.  Dans le cas de 30 FPS, le FPS total de l'image changeante sera de 1500, et l'œil humain n'acceptera tout simplement pas une telle fréquence d'affichage.  Comme solution, nous pouvons configurer le découpage automatique ou la prise d'instantanés à la demande;  dans ce cas, des images avec une fréquence arbitraire peuvent être affichées sur le site, par exemple, 1 image en 10 secondes.  Les instantanés peuvent être supprimés du SDK via l'API REST ou découpés automatiquement. </p><br><p><img src="https://habrastorage.org/webt/b9/c5/hf/b9c5hfkspnmifm7wfw96aatldl8.jpeg"></p><br><p>  Le serveur WCS prend en charge la méthode REST pour recevoir des instantanés: </p><br><pre> <code class="plaintext hljs">/stream/snapshot</code> </pre> <br><p></p><br><p><img src="https://habrastorage.org/webt/5c/8z/v-/5c8zv-0i7uglnd6t5eyldejyzt0.jpeg"></p><br><p></p><br><h3> <strong><a name="mixer"></a></strong>  <strong>Ajout d'un flux au mélangeur</strong> </h3><br><p><img src="https://habrastorage.org/webt/o3/mx/bj/o3mxbjmxo3evugpsr5td7wko1pc.jpeg"></p><br><p>  Une image provenant de deux sources ou plus peut être combinée en une seule pour être affichée aux téléspectateurs finaux.  Cette procédure est appelée mélange.  Exemples de base: 1) Surveillance vidéo de plusieurs caméras sur l'écran en une seule image.  2) Vidéoconférence, où chaque utilisateur reçoit un flux, dans lequel les autres sont mélangés, pour économiser des ressources.  Le mélangeur est contrôlé via l'API REST et dispose d'un mode de fonctionnement MCU pour créer des vidéoconférences. </p><br><p>  Commande REST pour ajouter un flux au mélangeur: </p><br><pre> <code class="plaintext hljs">/mixer/startup</code> </pre> <br><p></p><br><h3> <strong><a name="transcoding"></a></strong>  <strong>Transcodage de flux</strong> </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d19/7de/e1b/d197dee1b288f44501461f2893f19af6.jpg" alt="transcoding_WebRTC_Android_iOS_SDK_API_WCS_browser_RTMP_RTSP_VOD_SIP_RTP" width="924" height="553"></p><br><p>  Les flux doivent parfois être compressés afin de s'adapter à certains groupes de périphériques clients par résolution et débit binaire.  Pour cela, le transcodage est utilisé.  Le transcodage peut être activé du côté du SDK Web, via l'API REST, ou automatiquement via un nœud de transcodage spécial dans le CDN.  Par exemple, une vidéo de 1280x720 peut être transcodée en 640x360 pour être distribuée aux clients d'une région géographique avec une bande passante traditionnellement faible.  Où sont tes satellites, Elon Musk? </p><br><p><img src="https://habrastorage.org/webt/yn/t2/5g/ynt25g1_9phfzcqtptzb0e0u3gq.jpeg"></p><br><p>  Méthode REST utilisée: </p><br><pre> <code class="plaintext hljs">/transcoder/startup</code> </pre> <br><p></p><br><h3> <strong><a name="watermark"></a></strong>  <strong>Ajout d'un filigrane</strong> </h3><br><p><img src="https://habrastorage.org/webt/l_/7q/-t/l_7q-td_lifwkr5aw3mn-btem1o.png"></p><br><p>  Il est connu que tout contenu peut être volé et transformé en WebRip, quelle que soit la protection du joueur.  Si votre contenu est précieux, vous pouvez y incorporer un filigrane ou un logo qui compliquera considérablement son utilisation ultérieure et son affichage public.  Pour ajouter un filigrane, téléchargez simplement une image PNG et elle sera insérée dans le flux vidéo par transcodage.  Par conséquent, vous devrez préparer quelques cœurs de processeur côté serveur au cas où vous décideriez toujours d'ajouter un filigrane au flux.  Afin de ne pas créer le filigrane sur le serveur par transcodage, il est préférable de l'ajouter directement sur l'encodeur / streamer, ce qui offre souvent une telle opportunité. </p><br><p></p><br><h3> <strong><a name="fpsfilter"></a></strong>  <strong>Ajout d'un filtre FPS</strong> </h3><br><p><img src="https://habrastorage.org/webt/27/oi/bk/27oibkbef1jtrjulbcdcpomi_ts.png"></p><br><p>  Dans certains cas, il est nécessaire que le flux ait un FPS pair (images par seconde).  Cela peut être utile si nous retransmettons le flux vers une ressource tierce comme Youtube ou Facebook ou si nous le lisons avec un lecteur HLS sensible.  Le filtrage nécessite également un transcodage, alors assurez-vous d'évaluer correctement la puissance de votre serveur et préparez 2 cœurs par flux si une telle opération est prévue. </p><br><p></p><br><h3> <strong><a name="rotate"></a></strong>  <strong>Rotation de l'image de 90, 180, 270 degrés</strong> </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8fe/997/147/8fe997147f962e8d2f2d3405c5415f6e.png" alt="rotation_WebRTC_Android_iOS_SDK_API_WCS_browser_RTMP_RTSP_VOD_SIP_RTP" width="628" height="189"></p><br><p>  Les appareils mobiles ont la possibilité de modifier la résolution du flux publié en fonction de l'angle de rotation.  Par exemple, vous avez commencé à diffuser, en tenant l'iPhone horizontalement, puis en le faisant pivoter.  Selon la spécification WebRTC, le navigateur de streamer de l'appareil mobile (dans ce cas iOS Safari) devrait signaler la rotation au serveur.  À son tour, le serveur doit envoyer cet événement à tous les abonnés.  Sinon, ce serait comme ça - le streamer a mis le téléphone sur le côté, mais voit toujours son appareil photo verticalement, tandis que les téléspectateurs voient une image pivotée.  Pour travailler avec des rotations du côté du SDK, l'extension cvoExtension correspondante est incluse. </p><br><p></p><br><h3> <strong><a name="manage"></a></strong>  <strong>Gestion des flux entrants</strong> </h3><br><p>  Automatique - la configuration est généralement définie côté serveur dans les paramètres. </p><br><div class="scrollable-table"><table><thead><tr><th>  Action d'écoulement </th><th>  Web, iOS, SDK Android </th><th>  API REST </th><th>  Automatique </th><th>  Cdn </th></tr></thead><tbody><tr><td>  Record </td><td>  + </td><td>  + </td><td><br></td><td><br></td></tr><tr><td>  Suppression d'instantanés </td><td>  + </td><td>  + </td><td>  + </td><td><br></td></tr><tr><td>  Ajout au mélangeur </td><td>  + </td><td>  + </td><td><br></td><td><br></td></tr><tr><td>  Transcodage de flux </td><td>  + </td><td>  + </td><td><br></td><td>  + </td></tr><tr><td>  Ajout d'eau <br>  signe </td><td><br></td><td><br></td><td>  + </td><td><br></td></tr><tr><td>  Ajout d'un filtre FPS </td><td><br></td><td><br></td><td>  + </td><td><br></td></tr><tr><td>  Faites pivoter l'image de 90, <br>  180, 270 degrés </td><td>  + </td><td><br></td><td><br></td><td><br></td></tr></tbody></table></div><br><p></p><br><h2><a name="Streamrelay"></a>  Relais de flux </h2><br><p>  Le relais est également une option pour manipuler les flux entrant dans le serveur;  il consiste à forcer le flux vers un serveur tiers.  Relayer est synonyme de mots tels que republier, pousser, injecter. </p><br><p>  Le relais peut être implémenté en utilisant l'un des protocoles suivants: WebRTC, RTMP, SIP / RTP.  Le tableau indique la direction dans laquelle le flux peut être relayé. </p><br><br><div class="scrollable-table"><table><thead><tr><th>  WebRTC </th><th>  RTMP </th><th>  SIP / RTP </th></tr></thead><tbody><tr><td>  WCS </td><td>  Serveur RTMP WCS </td><td>  Serveur SIP </td></tr></tbody></table></div><br><br><h3> <strong><a name="repubWebRTC"></a></strong>  <strong>Relais WebRTC</strong> </h3><br><p><img src="https://habrastorage.org/webt/d9/yf/cc/d9yfccsjz8zqvx3jo-3gas2nuu8.jpeg"></p><br><p>  Un flux peut être relayé vers un autre serveur WCS si, pour une raison quelconque, il est nécessaire de rendre le flux disponible sur un autre serveur.  Le relais se fait via la méthode via / push de l'API REST.  À la réception d'une telle demande REST, WCS se connecte au serveur spécifié et y publie un flux serveur-serveur.  Après cela, le flux devient disponible pour la lecture sur une autre machine. </p><br><pre> <code class="plaintext hljs">/pull/push</code> </pre> <br><p>  - méthode REST utilisée </p><br><p></p><br><h3> <strong><a name="rebubRTMP"></a></strong>  <strong>Relais RTMP</strong> </h3><br><p><img src="https://habrastorage.org/webt/y-/hv/tn/y-hvtne9e-vtgry-2or6nhmqzte.jpeg"></p><br><p>  Comme pour le relais WebRTC, le relais RTMP vers un autre serveur est également possible.  La différence ne concernera que le protocole de relais.  Le relais RTMP est également effectué via / push et permet de transférer le flux vers des serveurs RTMP tiers et vers des services prenant en charge RTMP Ingest: Youtube, streaming Facebook, etc.  Ainsi, le flux WebRTC peut être relayé vers RTMP.  Nous pourrions aussi bien relayer tout autre flux entrant dans le serveur, par exemple RTSP ou VOD, à RTMP. </p><br><p>  Le flux vidéo est relayé vers un autre serveur RTMP à l'aide d'appels REST. </p><br><pre> <code class="plaintext hljs">/push/startup</code> </pre> <br><p>  - appel REST utilisé </p><br><p></p><br><h3> <strong><a name="repubSIP-RTP"></a></strong>  <strong>Relais SIP / RTP</strong> </h3><br><p><img src="https://habrastorage.org/webt/sl/tt/hj/sltthjlgwbvryka0vgpqel0hcx8.jpeg"><br></p><p>  C'est une fonction rarement utilisée.  Le plus souvent, il est utilisé en entreprise.  Par exemple, lorsque nous devons établir un appel SIP avec un serveur de conférence SIP externe et rediriger le flux audio ou vidéo vers cet appel afin que le public de la conférence voit une sorte de contenu vidéo: «Veuillez regarder cette vidéo» ou «Collègues , regardons maintenant un flux de caméras IP depuis le chantier ».  Nous devons garder à l'esprit que dans ce cas, la conférence elle-même existe et est gérée sur un serveur VKS externe avec prise en charge SIP (récemment, nous avons testé la solution de Polycom DMA), alors que nous nous connectons et relayons simplement le flux existant à ce serveur.  La fonction API REST est appelée / inject et ne sert que dans ce cas. </p><br><p>  Commande REST API: </p><br><pre> <code class="plaintext hljs">/call/inject_stream/startup</code> </pre> <br><p></p><br><h2><a name="CDN"></a>  Connexion de serveurs à un réseau de traitement de contenu CDN </h2><br><p>  Habituellement, un serveur a une quantité limitée de ressources.  Par conséquent, pour les grandes diffusions en ligne où l'audience compte pour des milliers et des dizaines de milliers, une mise à l'échelle est nécessaire.  Plusieurs serveurs WCS peuvent être combinés en un seul réseau de distribution de contenu CDN.  En interne, CDN travaillera via WebRTC pour maintenir une faible latence pendant la diffusion. </p><br><p><img src="https://habrastorage.org/webt/99/sx/gd/99sxgd8frahbmd2trrxsfltfmeg.jpeg"></p><br><p>  Le serveur peut être configuré dans l'un des rôles suivants: origine, périphérie ou transcodeur.  Les serveurs de type origine reçoivent le trafic et le distribuent aux serveurs Edge, qui sont chargés de fournir le flux aux téléspectateurs.  S'il est nécessaire de préparer un flux dans plusieurs résolutions, les nœuds de transcodeur sont inclus dans le schéma, qui assument la mission consommatrice de ressources de transcodage des flux. </p><br><p></p><br><h2><a name="summarize"></a>  Pour résumer </h2><br><p>  WCS 5.2 est un serveur de développement d'applications avec prise en charge audio et vidéo en temps réel pour les navigateurs et les appareils mobiles.  Quatre API sont fournies pour le développement: Web SDK, iOS SDK, Android SDK, REST API.  Nous pouvons publier (alimenter) des flux vidéo sur le serveur en utilisant cinq protocoles: WebRTC, RTMP, RTSP, VOD, SIP / RTP.  Depuis le serveur, nous pouvons lire des flux avec des joueurs en utilisant cinq protocoles: WebRTC, RTMP, RTSP, MSE, HLS.  Les flux peuvent être contrôlés et subir des opérations telles que l'enregistrement, le découpage d'instantanés, le mixage, le transcodage, l'ajout d'un filigrane, le filtrage FPS et la diffusion de tours vidéo sur des appareils mobiles.  Les flux peuvent être relayés vers d'autres serveurs via les protocoles WebRTC et RTMP, ainsi que redirigés vers des conférences SIP.  Les serveurs peuvent être combinés en un réseau de diffusion de contenu et mis à l'échelle pour traiter un nombre arbitraire de flux vidéo. </p><br><h3>  <strong>Ce qu'Alice doit savoir pour travailler avec le serveur</strong> </h3><br><p>  Le développeur doit pouvoir utiliser Linux.  Les commandes suivantes dans la ligne de commande ne doivent pas créer de confusion: </p><br><pre> <code class="plaintext hljs">tar -xvzf wcs5.2.tar.gz</code> </pre> <br><pre> <code class="plaintext hljs">cd wcs5.2</code> </pre> <br><pre> <code class="plaintext hljs">./install.sh</code> </pre> <br><pre> <code class="plaintext hljs">tail -f flashphoner.log</code> </pre> <br><pre> <code class="plaintext hljs">ps aux | grep WebCallServer</code> </pre> <br><pre> <code class="plaintext hljs">top</code> </pre> <br><p>  Il faut également connaître Vanilla JavaScript en matière de développement Web. </p><br><pre> <code class="plaintext hljs">//publishing the stream session.createStream({name:'mystream'}).publish(); //playing the stream session.createStream({name:'mystream'}).play();</code> </pre><br><p>  La possibilité de travailler avec le back-end peut également être utile. </p><br><p><img src="https://habrastorage.org/webt/3l/0a/9s/3l0a9shqbhfy4yjheu30ocammzg.jpeg"></p><br><p>  WCS peut non seulement recevoir des commandes de contrôle via l'API REST, mais également envoyer des hooks - c'est-à-dire des notifications sur les événements qui s'y produisent.  Par exemple, lorsque vous essayez d'établir une connexion à partir d'un navigateur ou d'une application mobile, WCS déclenchera le hook / connect, et lorsque vous essayez de lire un flux, il déclenchera le hook playStream.  Par conséquent, le développeur devra marcher un peu dans la peau du back ender, qui est capable de créer à la fois un simple client REST et un petit serveur REST pour le traitement des hooks. </p><br><p>  Exemple d'API REST </p><br><pre> <code class="plaintext hljs">/rest-api/stream/find_all</code> </pre> <br><p>  - exemple d'API REST pour lister les flux sur le serveur </p><br><p>  Exemple de crochet REST </p><br><pre> <code class="plaintext hljs">https://myback-end.com/hook/connect</code> </pre> <br><p>  - Traitement REST hook / connect côté backend. </p><br><p>  Linux, JavaScript, REST Client / Serveur - trois éléments suffisants pour développer un service de production sur la plate-forme WCS fonctionnant avec des flux vidéo. </p><br><p>  Le développement d'applications mobiles nécessitera une connaissance de Java et Objective-C pour Android et iOS, respectivement. </p><br><h3>  <strong>Installation et lancement</strong> </h3><br><p>  Il existe trois façons de lancer rapidement WCS aujourd'hui: </p><br><p>  1) Installez Ubuntu 16.x LTS ou Ubuntu 18.x LTS etc.  sur votre Centos7.  ou être guidé par un <a href="https://docs.flashphoner.com/display/WCS52EN/Quick%2Bdeployment%2Band%2Btesting%2Bof%2Bthe%2Bserver">article de la documentation</a> . </p><br><p>  ou </p><br><p>  2) Obtenez une <a href="https://flashphoner.com/amazon-ec2-support-in-web-call-server">image prête à l'emploi sur Amazon EC2</a> . </p><br><p>  ou </p><br><p>  3) Obtenez une <a href="https://flashphoner.com/web-call-server-on-digital-ocean-marketplace">image prête à l'emploi du serveur sur Digital Ocean</a> . </p><br><p>  Et commencez un développement de projet passionnant avec des fonctionnalités de streaming vidéo. </p><br><p>  L'article de revue s'est avéré assez volumineux.  Merci pour la patience de le lire. </p><br><p>  Bon streaming! </p><br><p></p><br><h2><a name="Links"></a>  Les liens </h2><br><p>  <a href="https://flashphoner.com/">WCS 5.2</a> - Serveur WebRTC </p><br><h3>  Installation et lancement </h3><br><p>  <a href="https://docs.flashphoner.com/display/WCS52EN/Quick%2Bdeployment%2Band%2Btesting%2Bof%2Bthe%2Bserver">Installation et lancement de WCS</a> <br>  <a href="https://flashphoner.com/amazon-ec2-support-in-web-call-server">Lancer une image prête à l'emploi sur Amazon EC2</a> <br>  <a href="https://flashphoner.com/web-call-server-on-digital-ocean-marketplace">Lancer l'image prête à l'emploi du serveur sur DigitalOcean</a> </p><br><h3>  SDK </h3><br><p>  <a href="https://docs.flashphoner.com/display/WCS52EN/Web%2BSDK">SDK Web de documentation</a> <br>  <a href="https://docs.flashphoner.com/display/WCS52EN/Android%2BSDK">Documentation SDK Android</a> <br>  <a href="https://docs.flashphoner.com/display/WCS52EN/iOS%2BSDK">Documentation iOS SDK</a> </p><br><h3>  Étuis </h3><br><p>  <a href="https://docs.flashphoner.com/display/WCS52EN/Stream%2Bcapturing%2Band%2Bpublishing%2Bto%2Bthe%2Bserver">Flux entrants</a> <br>  <a href="https://docs.flashphoner.com/display/WCS52EN/Playing%2Ba%2Bvideo%2Bstream%2Bfrom%2Bthe%2Bserver">Flux sortants</a> <br>  <a href="https://docs.flashphoner.com/display/WCS52EN/Captured%2Bstream%2Bmanagement">Gestion des flux</a> <br>  <a href="https://docs.flashphoner.com/display/WCS52EN/Republishing%2Ba%2Bvideo%2Bstream">Relais de flux</a> <br>  <a href="">CDN pour le streaming WebRTC à faible latence</a> </p><br><h3>  La documentation </h3><br><p>  <a href="https://docs.flashphoner.com/display/WCS52EN/Web%2BCall%2BServer%2B5.2%2B-%2BEN">Documentation Web Call Server 5.2</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr482956/">https://habr.com/ru/post/fr482956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr482942/index.html">Mythes et légendes de l'ancien Fediverse</a></li>
<li><a href="../fr482944/index.html">Distributeur de convoyeur multi-composants</a></li>
<li><a href="../fr482946/index.html">1С DSS et estimation des conditions et coût des projets par la méthode COCOMO II</a></li>
<li><a href="../fr482948/index.html">"Un, deux, trois - brûlez le sapin de Noël!" Ou mon premier regard sur le petit contrôleur CANNY 3</a></li>
<li><a href="../fr482950/index.html">Java: des choses qui peuvent sembler curieuses à un développeur expérimenté</a></li>
<li><a href="../fr482958/index.html">"Règles de croissance: du junior au CTO", résumé d'un webinaire de Fedor Borshchev</a></li>
<li><a href="../fr482960/index.html">Présentation de WCS 5.2 - Serveur WebRTC pour les développeurs Web de diffusions en ligne et de chat vidéo</a></li>
<li><a href="../fr482968/index.html">Quarkus - Un nouveau regard sur Java Native Cloud</a></li>
<li><a href="../fr482970/index.html">Hack The Box - Procédure pas à pas. Nous creusons dans Git, exploitons les vulnérabilités de l'API, traitons avec Vault</a></li>
<li><a href="../fr482974/index.html">Soutien en santé mentale avec réalité virtuelle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>