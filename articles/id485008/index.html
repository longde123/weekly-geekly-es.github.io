<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚞 🤟🏽 🏉 Pembungkus properti Swift 🔔 👨‍👧‍👦 🍽️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jika Anda menggunakan SwiftUI, Anda mungkin memperhatikan kata kunci seperti @ObservedObject, @EnvironmentObject, @FetchRequest, dan sebagainya. Pembu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pembungkus properti Swift</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/485008/"><p>  Jika Anda menggunakan SwiftUI, Anda mungkin memperhatikan kata kunci seperti @ObservedObject, @EnvironmentObject, @FetchRequest, dan sebagainya.  Pembungkus Properti (selanjutnya disebut "pembungkus properti") adalah fitur baru dari Swift 5.1.  Artikel ini akan membantu Anda memahami dari mana semua konstruksi dari @ berasal, bagaimana cara menggunakannya di SwiftUI dan dalam proyek Anda. </p><br><img src="https://habrastorage.org/webt/vp/5r/4c/vp5r4ct4rymlk9mzxdlvkb73uqe.jpeg"><br><p>  <em>Diterjemahkan oleh: Evgeny Zavozhansky, pengembang FunCorp.</em> </p><br><p>  <em>Catatan:</em> Pada saat terjemahan disiapkan, bagian dari kode sumber artikel asli telah kehilangan relevansinya karena perubahan bahasa, sehingga beberapa contoh kode sengaja diganti. <a name="habracut"></a></p><br><p> Pembungkus properti pertama kali diperkenalkan di forum <a href="https://forums.swift.org/t/pitch-property-delegates/21895" title="Cepat">Swift</a> pada Maret 2019, beberapa bulan sebelum pengumuman SwiftUI.  Dalam proposal awalnya, Douglas Gregor, anggota tim Swift Core, menggambarkan konstruk ini (kemudian disebut delegasi properti) sebagai "generalisasi yang dapat diakses pengguna dari fungsi yang saat ini disediakan oleh konstruksi bahasa seperti <code>lazy</code> , misalnya." </p><br><p>  Jika sebuah properti dideklarasikan dengan kata kunci <code>lazy</code> , ini berarti ia akan diinisialisasi saat pertama kali diakses.  Sebagai contoh, inisialisasi properti ditangguhkan dapat diimplementasikan menggunakan properti pribadi, diakses melalui properti yang dihitung.  Tetapi menggunakan kata kunci <code>lazy</code> membuat ini lebih mudah. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Structure</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-comment"><span class="hljs-comment">//      lazy    lazy var deferred = …    //            private var _deferred: Type?    var deferred: Type {        get {            if let value = _deferred { return value }            let initialValue = …            _deferred = initialValue            return initialValue        }        set {            _deferred = newValue        }    } }</span></span></code> </pre> <br><p>  <a href="" title="SE-0258: Pembungkus Properti">SE-0258: Property Wrapper dengan</a> sempurna menjelaskan desain dan implementasi pembungkus properti.  Karena itu, alih-alih mencoba meningkatkan deskripsi dalam dokumentasi resmi, pertimbangkan beberapa contoh yang dapat diimplementasikan menggunakan pembungkus properti: </p><br><ul><li>  pembatasan nilai properti; <br></li><li>  konversi nilai saat mengubah properti; <br></li><li>  mengubah semantik persamaan dan membandingkan properti; <br></li><li>  logging akses properti. <br></li></ul><br><h2>  Batasi Nilai Properti </h2><br><p>  <a href="" title="SE-0258">SE-0258: Property Wrapper</a> menyediakan beberapa contoh praktis, termasuk <code>@Clamping</code> , <code>@Copying</code> , <code>@Atomic</code> , <code>@ThreadSpecific</code> , <code>@Box</code> , <code>@UserDefault</code> .  Pertimbangkan bungkus <code>@Clamping</code> , yang memungkinkan Anda membatasi nilai maksimum atau minimum suatu properti. </p><br><pre> <code class="swift hljs">@propertyWrapper <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Clamping</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Value</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comparable</span></span></span><span class="hljs-class">&gt; </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value: <span class="hljs-type"><span class="hljs-type">Value</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> range: <span class="hljs-type"><span class="hljs-type">ClosedRange</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Value</span></span>&gt;    <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(initialValue value: <span class="hljs-type"><span class="hljs-type">Value</span></span>, <span class="hljs-number"><span class="hljs-number">_</span></span> range: <span class="hljs-type"><span class="hljs-type">ClosedRange</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Value</span></span>&gt;) {        <span class="hljs-built_in"><span class="hljs-built_in">precondition</span></span>(range.<span class="hljs-built_in"><span class="hljs-built_in">contains</span></span>(value))        <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value = value        <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.range = range    }    <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wrappedValue: <span class="hljs-type"><span class="hljs-type">Value</span></span> {        <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { value }        <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { value = <span class="hljs-built_in"><span class="hljs-built_in">min</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(range.lowerBound, newValue), range.upperBound) }    } }</code> </pre> <br><p>  <code>@Clamping</code> dapat digunakan, misalnya, untuk mensimulasikan keasaman suatu larutan, yang nilainya dapat mengambil nilai dari 0 hingga 14. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Solution</span></span></span><span class="hljs-class"> </span></span>{    @<span class="hljs-type"><span class="hljs-type">Clamping</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>...<span class="hljs-number"><span class="hljs-number">14</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pH: <span class="hljs-type"><span class="hljs-type">Double</span></span> = <span class="hljs-number"><span class="hljs-number">7.0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> carbonicAcid = <span class="hljs-type"><span class="hljs-type">Solution</span></span>(pH: <span class="hljs-number"><span class="hljs-number">4.68</span></span>)</code> </pre> <br><p>  Mencoba menetapkan nilai pH di luar rentang dari <code>(0...14)</code> akan menyebabkan properti mengambil nilai yang paling dekat dengan interval minimum atau maksimum. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> superDuperAcid = <span class="hljs-type"><span class="hljs-type">Solution</span></span>(pH: -<span class="hljs-number"><span class="hljs-number">1</span></span>) superDuperAcid.pH <span class="hljs-comment"><span class="hljs-comment">// 0</span></span></code> </pre> <br><p>  Pembungkus properti dapat digunakan untuk mengimplementasikan pembungkus properti lainnya.  Misalnya, pembungkus <code>@UnitInterval</code> membatasi nilai properti hingga interval <code>(0...1)</code> menggunakan <code>@Clamping(0...1)</code> : </p><br><pre> <code class="swift hljs">@propertyWrapper <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnitInterval</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Value</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FloatingPoint</span></span></span><span class="hljs-class">&gt; </span></span>{    @<span class="hljs-type"><span class="hljs-type">Clamping</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>...<span class="hljs-number"><span class="hljs-number">1</span></span>)    <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wrappedValue: <span class="hljs-type"><span class="hljs-type">Value</span></span> = .zero    <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(initialValue value: <span class="hljs-type"><span class="hljs-type">Value</span></span>) {        <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.wrappedValue = value    } }</code> </pre> <br><h3>  Ide serupa </h3><br><ul><li>  <code>@Positive</code> / <code>@NonNegative</code> menunjukkan bahwa nilainya dapat berupa angka positif atau negatif. </li><li>  <code>@NonZero</code> menunjukkan bahwa nilai properti tidak boleh 0. </li><li>  <code>@Validated</code> atau <code>@Whitelisted</code> / <code>@Blacklisted</code> membatasi nilai properti ke nilai tertentu. </li></ul><br><h2>  Mengkonversi Nilai Saat Mengubah Properti </h2><br><p>  Memvalidasi nilai-nilai bidang teks adalah sakit kepala konstan untuk pengembang aplikasi.  Ada begitu banyak hal yang harus dilacak: mulai dari kata-kata hampa seperti pengodean hingga upaya jahat untuk memasukkan kode melalui bidang teks.  Pertimbangkan untuk menggunakan pembungkus properti untuk menghapus spasi yang telah dimasukkan pengguna di awal dan di akhir baris. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Foundation let url = URL(string: " https:<span class="hljs-comment"><span class="hljs-comment">//habrahabr.ru") // nil let date = ISO8601DateFormatter().date(from: " 2019-06-24") // nil let words = " Hello, world!".components(separatedBy: .whitespaces) words.count // 3</span></span></code> </pre> <br><p>  <code>Foundation</code> menawarkan metode <code>trimmingCharacters(in:)</code> , yang dengannya Anda dapat menghapus spasi di awal dan akhir baris.  Anda dapat memanggil metode ini kapan pun Anda perlu menjamin kebenaran input, tetapi itu tidak terlalu nyaman.  Anda dapat menggunakan pembungkus properti untuk ini. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Foundation @propertyWrapper struct Trimmed {    private(set) var value: String = ""    var wrappedValue: String {        get { return value }        set { value = newValue.trimmingCharacters(in: .whitespacesAndNewlines) }    }    init(initialValue: String) {        self.wrappedValue = initialValue    } }</code> </pre> <br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Post</span></span></span><span class="hljs-class"> </span></span>{    @<span class="hljs-type"><span class="hljs-type">Trimmed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title: <span class="hljs-type"><span class="hljs-type">String</span></span>    @<span class="hljs-type"><span class="hljs-type">Trimmed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body: <span class="hljs-type"><span class="hljs-type">String</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> quine = <span class="hljs-type"><span class="hljs-type">Post</span></span>(title: <span class="hljs-string"><span class="hljs-string">" Swift Property Wrappers "</span></span>, body: <span class="hljs-string"><span class="hljs-string">"…"</span></span>) quine.title <span class="hljs-comment"><span class="hljs-comment">// "Swift Property Wrappers" —        quine.title = "   @propertyWrapper " // "@propertyWrapper"</span></span></code> </pre> <br><h3>  Ide serupa </h3><br><ul><li>  <code>@Transformed</code> menerapkan <a href="https://developer.apple.com/documentation/foundation/nsstring/1407787-applyingtransform" title="Konversi ICU">konversi ICU</a> ke string <code>@Transformed</code> . </li><li>  <code>@Rounded</code> / <code>@Truncated</code> rounds atau memotong nilai string. </li></ul><br><h2>  Ubah semantik kesetaraan dan perbandingan properti </h2><br><p>  Dalam Swift, dua string sama jika mereka <a href="https://unicode.org/reports/tr15/" title="setara dengan kanonik">setara secara kanonik</a> , yaitu  mengandung karakter yang sama.  Tapi misalkan kita ingin properti string sama, tidak peka huruf besar kecil, yang dikandungnya. </p><br><p>  <code>@CaseInsensitive</code> mengimplementasikan pembungkus untuk properti tipe <code>String</code> atau <code>SubString</code> . </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Foundation @propertyWrapper struct CaseInsensitive&lt;Value: StringProtocol&gt; {    var wrappedValue: Value } extension CaseInsensitive: Comparable {    private func compare(_ other: CaseInsensitive) -&gt; ComparisonResult {        wrappedValue.caseInsensitiveCompare(other.wrappedValue)    }    static func == (lhs: CaseInsensitive, rhs: CaseInsensitive) -&gt; Bool {        lhs.compare(rhs) == .orderedSame    }    static func &lt; (lhs: CaseInsensitive, rhs: CaseInsensitive) -&gt; Bool {        lhs.compare(rhs) == .orderedAscending    }    static func &gt; (lhs: CaseInsensitive, rhs: CaseInsensitive) -&gt; Bool {        lhs.compare(rhs) == .orderedDescending    } }</code> </pre> <br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hello: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">"hello"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">HELLO</span></span>: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">"HELLO"</span></span> hello == <span class="hljs-type"><span class="hljs-type">HELLO</span></span> <span class="hljs-comment"><span class="hljs-comment">// false CaseInsensitive(wrappedValue: hello) == CaseInsensitive(wrappedValue: HELLO) // true</span></span></code> </pre> <br><h3>  Ide serupa </h3><br><ul><li>  <code>@Approximate</code> untuk perbandingan kasar dari properti tipe Double atau Float. </li><li>  <code>@Ranked</code> untuk properti yang nilainya berurutan (misalnya, pangkat kartu remi). </li></ul><br><h2>  Pencatatan Akses Properti </h2><br><p>  <code>@Versioned</code> akan memungkinkan Anda untuk mencegat nilai yang ditugaskan dan mengingat kapan mereka ditetapkan. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Foundation @propertyWrapper struct Versioned&lt;Value&gt; {    private var value: Value    private(set) var timestampedValues: [(Date, Value)] = []    var wrappedValue: Value {        get { value }        set {            defer { timestampedValues.append((Date(), value)) }            value = newValue        }    }    init(initialValue value: Value) {        self.wrappedValue = value    } }</code> </pre> <br><p>  Kelas <code>ExpenseReport</code> memungkinkan <code>ExpenseReport</code> menyimpan stempel waktu status pemrosesan dari laporan pengeluaran. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExpenseReport</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> submitted, received, approved, denied }    @<span class="hljs-type"><span class="hljs-type">Versioned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state: <span class="hljs-type"><span class="hljs-type">State</span></span> = .submitted }</code> </pre> <br><p>  Tetapi contoh di atas menunjukkan batasan serius dalam implementasi pembungkus properti saat ini, yang mengikuti dari pembatasan Swift: properti tidak dapat membuang pengecualian.  Jika kami ingin menambahkan batasan ke <code>@Versioned</code> untuk mencegah nilai berubah menjadi <code>.approved</code> setelah mengambil nilai <code>.denied</code> , maka opsi terbaik adalah <code>fatalError()</code> , yang tidak cocok untuk aplikasi nyata. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExpenseReport</span></span></span><span class="hljs-class"> </span></span>{    @<span class="hljs-type"><span class="hljs-type">Versioned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state: <span class="hljs-type"><span class="hljs-type">State</span></span> = .submitted {        <span class="hljs-keyword"><span class="hljs-keyword">willSet</span></span> {            <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> newValue == .approved,                $state.timestampedValues.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { $<span class="hljs-number"><span class="hljs-number">0.1</span></span> }.<span class="hljs-built_in"><span class="hljs-built_in">contains</span></span>(.denied)            {                <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>(<span class="hljs-string"><span class="hljs-string">""</span></span>)            }        }    } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tripExpenses = <span class="hljs-type"><span class="hljs-type">ExpenseReport</span></span>() tripExpenses.state = .denied tripExpenses.state = .approved <span class="hljs-comment"><span class="hljs-comment">// Fatal error: «»   .</span></span></code> </pre> <br><h3>  Ide serupa </h3><br><ul><li>  <code>@Audited</code> untuk <code>@Audited</code> akses properti. </li><li>  <code>@UserDefault</code> untuk merangkum mekanisme untuk membaca dan menyimpan data di <code>UserDefaults</code> . </li></ul><br><h2>  Keterbatasan </h2><br><h3>  Properti tidak dapat membuang pengecualian </h3><br><p>  Seperti yang telah disebutkan, pembungkus properti hanya dapat menggunakan beberapa metode untuk memproses nilai yang tidak valid: </p><br><ul><li>  abaikan mereka; <br></li><li>  menghentikan aplikasi menggunakan fatalError (). <br></li></ul><br><h3>  Properti yang dibungkus tidak dapat ditandai dengan atribut `typealias` </h3><br><p>  Contoh <code>@UnitInterval</code> atas, yang propertinya dibatasi oleh interval <code>(0...1)</code> , tidak dapat dinyatakan sebagai </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">UnitInterval</span></span> = <span class="hljs-type"><span class="hljs-type">Clamping</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>...<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><h3>  Pembatasan penggunaan komposisi beberapa pembungkus properti </h3><br><p>  Menulis pembungkus properti bukanlah operasi komutatif: urutan deklarasi akan memengaruhi perilaku.  Pertimbangkan contoh di mana properti siput, yang merupakan url posting blog, dinormalisasi.  Dalam hal ini, hasil normalisasi akan bervariasi tergantung pada kapan spasi diganti dengan tanda hubung, sebelum atau setelah penghapusan spasi.  Karenanya, saat ini, komposisi beberapa pembungkus properti tidak didukung. </p><br><pre> <code class="swift hljs">@propertyWrapper <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dasherized</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wrappedValue: <span class="hljs-type"><span class="hljs-type">String</span></span> {        <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { value }        <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { value = newValue.replacingOccurrences(of: <span class="hljs-string"><span class="hljs-string">" "</span></span>, with: <span class="hljs-string"><span class="hljs-string">"-"</span></span>) }    }    <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(initialValue: <span class="hljs-type"><span class="hljs-type">String</span></span>) {        <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.wrappedValue = initialValue    } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Post</span></span></span><span class="hljs-class"> </span></span>{    …    @<span class="hljs-type"><span class="hljs-type">Dasherized</span></span> @<span class="hljs-type"><span class="hljs-type">Trimmed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> slug: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-comment"><span class="hljs-comment">// error: multiple property wrappers are not supported }</span></span></code> </pre> <br><p>  Namun, batasan ini dapat dielakkan dengan menggunakan pembungkus properti bersarang. </p><br><pre> <code class="swift hljs">@propertyWrapper <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TrimmedAndDasherized</span></span></span><span class="hljs-class"> </span></span>{    @<span class="hljs-type"><span class="hljs-type">Dasherized</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wrappedValue: <span class="hljs-type"><span class="hljs-type">String</span></span> {        <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { value }        <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { value = newValue.trimmingCharacters(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: .whitespacesAndNewlines) }    }    <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(initialValue: <span class="hljs-type"><span class="hljs-type">String</span></span>) {        <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.wrappedValue = initialValue    } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Post</span></span></span><span class="hljs-class"> </span></span>{    …    @<span class="hljs-type"><span class="hljs-type">TrimmedAndDasherized</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> slug: <span class="hljs-type"><span class="hljs-type">String</span></span> }</code> </pre> <br><h3>  Pembatasan pembungkus properti lainnya </h3><br><ul><li>  Tidak dapat digunakan di dalam protokol. </li><li>  Contoh properti wrapper tidak dapat dideklarasikan dalam <code>enum</code> . </li><li>  Properti terbungkus yang dideklarasikan di dalam kelas tidak dapat diganti oleh properti lain. </li><li>  Properti terbungkus tidak boleh <code>lazy</code> , <code>@NSCopying</code> , <code>@NSManaged</code> , <code>weak</code> atau <code>unowned</code> . </li><li>  Properti terbungkus harus menjadi satu-satunya dalam definisi (mis., <code>@Lazy var (x, y) = /* ... */</code> ). </li><li>  Properti terbungkus tidak dapat memiliki <code>getter</code> dan <code>setter</code> ditentukan. </li><li>  Jenis properti <code>wrappedValue</code> dan variabel <code>wrappedValue</code> di <code>init(wrappedValue:)</code> harus memiliki tingkat akses yang sama dengan tipe wrapper properti. </li><li>  Tipe properti dari <code>projectedValue</code> harus memiliki tingkat akses yang sama dengan tipe pembungkus dari properti. </li><li>  <code>init()</code> harus memiliki tingkat akses yang sama dengan tipe pembungkus properti. </li></ul><br><p>  Mari kita simpulkan.  Pembungkus properti di Swift memberi penulis perpustakaan akses ke perilaku tingkat tinggi yang sebelumnya disediakan untuk fungsi bahasa.  Potensi mereka untuk meningkatkan keterbacaan dan mengurangi kompleksitas kode sangat besar, dan kami hanya memeriksa kemampuan alat ini secara dangkal. </p><br><p>  Apakah Anda menggunakan pembungkus properti di proyek Anda?  Tulis di komentar! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id485008/">https://habr.com/ru/post/id485008/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id484992/index.html">Lebih cantik dalam proyek-proyek besar: luangkan 20 menit untuk pengaturan, lupakan memformat selamanya</a></li>
<li><a href="../id484996/index.html">Virtual PBX Beeline. Apa yang manajer tidak akan memberi tahu Anda</a></li>
<li><a href="../id485000/index.html">Apakah traffic AS mahal atau tidak?</a></li>
<li><a href="../id485002/index.html">Pola Flutter BloC + Penyedia + tes + ingat keadaan</a></li>
<li><a href="../id485006/index.html">Buku (sedang?). Refleksi pada sifat pikiran. Bagian II</a></li>
<li><a href="../id485010/index.html">Jangan menangis, gadis! Balas ke penulis dengan vc.ru pada surat tentang Habré</a></li>
<li><a href="../id485012/index.html">Cara menggunakan Kontrol Inversi di JavaScript dan Reactjs untuk menyederhanakan penanganan kode</a></li>
<li><a href="../id485014/index.html">Haruskah saya mengeluh tentang wawancara?</a></li>
<li><a href="../id485016/index.html">Database yang Dikelola di Selectel: Selamat Datang di Beta</a></li>
<li><a href="../id485018/index.html">Menulis shader dengan kode di Unity LWRP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>