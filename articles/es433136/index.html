<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧔🏼 🤦 👩🏻 Infraestructura System.Transactions en el mundo .NET 💂 👃🏼 🏴‍☠️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¿Has visto una construcción como using (var scope = new TransactionScope(TransactionScopeOption.Required)) en C #? Esto significa que el código que se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Infraestructura System.Transactions en el mundo .NET</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/custis/blog/433136/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ct/df/aq/ctdfaqnuvdjaw6tobyxja78mk-s.png"></div><br>  ¿Has visto una construcción como <code>using (var scope = new TransactionScope(TransactionScopeOption.Required))</code> en C #?  Esto significa que el código que se ejecuta en el bloque de <code>using</code> está en la transacción y después de salir de este bloque, los cambios se confirmarán o revertirán.  Suena comprensible hasta que comiences a cavar más profundo.  Y cuanto más profundizas, más "extraño y extraño" se vuelve.  En cualquier caso, cuando me familiaricé más con la clase <code>TransactionScope</code> y, en general, con las transacciones .NET, surgieron muchas preguntas. <br><br>  ¿Qué es la clase <code>TransactionScope</code> ?  Tan pronto como usamos la construcción <code>using (var scope = new TransactionScope())</code> , ¿todo en nuestro programa se vuelve transaccional inmediatamente?  ¿Qué son "Administrador de recursos" y "Administrador de transacciones"?  ¿Puedo escribir mi propio administrador de recursos y cómo se "conecta" a la instancia de <code>TransactionScope</code> creada?  ¿Qué es una transacción distribuida y es cierto que una transacción distribuida en SQL Server u Oracle Database es lo mismo que una transacción distribuida .NET? <br><br>  En esta publicación, traté de recopilar material que ayude a encontrar respuestas a estas preguntas y a comprender las transacciones en el mundo .NET. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Contenido</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Introduccion</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¿Qué son las transacciones y qué problemas resuelven?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Qué transacciones se consideran aquí</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TL; sección DR</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Transacciones basadas en el sistema.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Que es esto</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Administradores de recursos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tipos de gerentes de recursos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Usando TransactionScope</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aplicabilidad de transacción de software</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Un ejemplo de un administrador de recursos voluble</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TL; sección DR</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Transacciones distribuidas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Que es esto</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Protocolos transaccionales</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fijación bifásica</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">System.Transations hoja de trucos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Limitaciones y alternativas de transacciones distribuidas por software</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Entonces, ¿está en .NET Core?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Transacciones distribuidas y WCF</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TL; sección DR</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conclusión Cuna</a> </div></div><br><a name="Introduction"></a><h2>  Introduccion </h2><br><a name="Transactions"></a><h4>  ¿Qué son las transacciones y qué problemas resuelven? </h4><br>  Las transacciones en cuestión aquí son operaciones que transfieren el sistema de un estado aceptable a otro y se garantiza que no dejarán el sistema en un estado inaceptable, incluso si surgen situaciones imprevistas.  Qué tipo de condiciones aceptables son, en el caso general, depende del contexto.  Aquí consideraremos una situación aceptable en la que los datos que procesamos son integrales.  Se entiende que los cambios que conforman la transacción se comprometen juntos o no.  Además, los cambios en una transacción pueden aislarse de los cambios realizados en el sistema por otra transacción.  Los requisitos básicos para las transacciones se denotan con el acrónimo ACID.  Para el primer contacto con ellos, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un artículo en Wikipedia es</a> adecuado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4r/p7/2b/4rp72bf2l_qdxmlhawxsjslkj-i.png" width="250"></div><br>  Un ejemplo clásico de una transacción es la transferencia de dinero entre dos cuentas.  En esta situación, retirar dinero de la cuenta No. 1 sin acreditar a la cuenta No. 2 es inaceptable, al igual que acreditar a la cuenta No. 2 sin retirar de la cuenta No. 1. En otras palabras, queremos que ambas operaciones sean tanto retiradas como acreditadas. - Realizado de inmediato.  Si uno de ellos falla, entonces la segunda operación no debe realizarse.  Puedes llamar a este principio "todo o nada".  Además, es deseable que las operaciones se realicen sincrónicamente incluso en caso de fallas sistémicas, como un corte de energía, es decir, que veamos el sistema en un estado aceptable tan pronto como esté disponible después de la restauración. <br><br>  En términos matemáticos, podemos decir que con respecto al sistema hay una invariante que definitivamente nos gustaría preservar.  Por ejemplo, el monto en ambas cuentas: es necesario que después de la transacción (transferencia de dinero) el monto permanezca igual que antes.  Por cierto, en el ejemplo clásico de transferencia de dinero, también aparece la contabilidad, un área temática donde surgió naturalmente el concepto de transacción. <br><br>  Ilustramos el ejemplo de transferir dinero entre dos cuentas.  La primera imagen muestra la situación cuando la transferencia de 50 rublos de la cuenta No. 1 a la cuenta No. 2 se completó con éxito.  El color verde indica que el sistema está en un estado aceptable (los datos están completos). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sn/az/ra/snazracqgy0u8fdxtrtksb8jc7g.png"></div><br>  Ahora imagine que la transferencia se realiza fuera de la transacción y después de retirar el dinero de la cuenta No. 1, ocurrió una falla, debido a la cual el dinero retirado no fue acreditado a la cuenta No. 2. El sistema estará en un estado inaceptable (color rojo). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yj/8h/ph/yj8hphqu7cszpcdvnboh97h3xfe.png"></div><br>  Si se produjo un error entre las operaciones de retiro y acreditación, pero la transferencia se realizó como parte de una transacción, la operación de retiro se cancelará.  Como resultado, el sistema permanecerá en su estado original aceptable. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3d/6b/wi/3d6bwim5vko1yam5mhiv1ekl9ve.png"></div><br>  Daré ejemplos de situaciones de la experiencia de nuestra compañía en las que las transacciones son útiles: contabilizar bienes (contabilizar el número de bienes de varios tipos que están en ciertas tiendas y en el camino), contabilizar los recursos de almacenamiento (contabilizar el volumen de una habitación ocupada por bienes de un cierto tipo, volumen de una habitación, gratis para la colocación de bienes, la cantidad de bienes que los empleados y los sistemas de almacenamiento automatizados pueden mover por día). <br><br>  Los problemas que surgen cuando se viola la integridad de los datos son obvios.  La información proporcionada por el sistema no solo se vuelve falsa, sino que pierde contacto con la realidad y se convierte en una tontería. <br><br><a name="KindsOfTransactions"></a><h4>  Qué transacciones se consideran aquí </h4><br>  Los beneficios proporcionados por las transacciones son conocidos.  Entonces, para mantener la integridad de los datos, ¿necesitamos una base de datos relacional, porque ahí es donde se realizan las transacciones?  En realidad no  Se dijo anteriormente que el concepto de una transacción depende del contexto, y ahora consideraremos brevemente de qué transacciones podemos hablar al discutir los sistemas de información. <br><br>  Para comenzar, separamos los conceptos de transacciones de dominio de materia (transacciones comerciales) y transacciones del sistema.  El segundo puede implementarse en diferentes lugares y de diferentes maneras. <br><br>  Vayamos desde el nivel más alto: el área temática.  La persona interesada puede declarar que hay algunos estados aceptables y que no quiere ver el sistema de información fuera de estos estados.  No presentaremos ejemplos adicionales: aquí es adecuado transferir dinero entre cuentas.  Solo aclaramos que una transferencia no es necesariamente una transferencia de dinero entre las cuentas de liquidación de dos clientes bancarios.  No menos importante es la tarea de contabilidad, cuando las cuentas deben reflejar las fuentes y el propósito de los fondos de la organización, y la transferencia debe reflejar el cambio en la distribución de fondos por estas fuentes y propósito.  Este fue un ejemplo de una <b>transacción de dominio sujeto</b> . <br><br>  Ahora veamos los ejemplos más comunes e interesantes de la implementación de las transacciones del sistema.  En las transacciones del sistema, varios medios técnicos proporcionan los requisitos del área temática.  Una solución clásica probada de este tipo es una <strong>transacción de DBMS relacional</strong> (primer ejemplo).  Los sistemas modernos de administración de bases de datos (tanto relacionales <a href="">como no muy</a> ) proporcionan un mecanismo de transacción que le permite guardar (confirmar) todos los cambios realizados durante el período de trabajo especificado o descartarlos (revertirlos).  Cuando se utiliza dicho mecanismo, las operaciones de retirar dinero de una cuenta y acreditar a otra cuenta que conforman la transacción del área temática, los medios DBMS se combinarán en una transacción del sistema y se ejecutarán juntos o no se realizarán en absoluto. <br><br>  Usar un DBMS, por supuesto, no es necesario.  Hablando en términos generales, generalmente puede implementar el mecanismo de transacción DBMS en su lenguaje de programación favorito y disfrutar del análogo inestable y con errores de las herramientas existentes.  Pero su "bicicleta" se puede optimizar para situaciones específicas en el área temática. <br><br>  Hay más opciones interesantes.  Los lenguajes modernos de programación industrial (C # y Java en primer lugar) ofrecen herramientas diseñadas específicamente para organizar transacciones que involucran subsistemas completamente diferentes, y no solo el DBMS.  En esta publicación, llamaremos a dichas transacciones de software.  En el caso de C #, estas son <b>transacciones del espacio de nombres System.Transactions</b> (el segundo ejemplo), y se describen a continuación. <br><br>  Antes de pasar a las transacciones de <code>System.Transactions</code> , uno no puede dejar de mencionar un fenómeno más interesante.  <code>System.Transactions</code> herramientas <code>System.Transactions</code> permiten al programador implementar de forma independiente la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">memoria de transacciones programáticas</a> .  En este caso, las operaciones de programa que afectan el estado del sistema (en el caso de los lenguajes de programación imperativos clásicos, esta es una operación de asignación) se incluyen por defecto en las transacciones que pueden confirmarse y revertirse de la misma manera que las transacciones DBMS.  Con este enfoque, la necesidad de utilizar mecanismos de sincronización (en C # - <code>lock</code> , en Java - <code>synchronized</code> ) se reduce significativamente.  Otro desarrollo de esta idea es <strong>la memoria transaccional de software, compatible a nivel de plataforma</strong> (tercer ejemplo).  Se espera que tal milagro se encuentre en un lenguaje cuya elegancia sobrepasa su aplicabilidad industrial: Clojure.  Y para los lenguajes de trabajadores y campesinos, hay bibliotecas de complementos que proporcionan la funcionalidad de la memoria transaccional programática. <br><br>  Las transacciones del sistema pueden incluir varios sistemas de información, en cuyo caso se distribuyen.  Distribuido puede ser tanto transacciones DBMS como software;  todo depende de la funcionalidad que admita una herramienta de transacción en particular.  Las transacciones distribuidas más detalladas se analizan en la sección correspondiente.  Daré una imagen para que sea más fácil entender los temas discutidos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/di/yd/4s/diyd4spwelqhd61eoetfacuncjm.png"></div><br><a name="TLDR1"></a><h4>  TL; sección DR </h4><br>  Hay procesos que consisten en varias operaciones indivisibles (atómicas) aplicadas al sistema, en el caso general no necesariamente informativo.  Cada operación indivisible puede dejar el sistema en un estado inaceptable cuando la integridad de los datos se ve comprometida.  Por ejemplo, si una transferencia de dinero entre dos cuentas está representada por dos operaciones indivisibles de retirar de la cuenta No. 1 y acreditar a la cuenta No. 2, entonces solo una de estas operaciones violará la integridad de los datos.  El dinero desaparece en medio de la nada o aparece en medio de la nada.  Una transacción combina operaciones indivisibles para que se realicen todas juntas (por supuesto, secuencialmente, si es necesario) o no se realicen en absoluto.  Podemos hablar sobre transacciones de dominio y transacciones en sistemas técnicos que típicamente implementan transacciones de dominio. <br><br><a name="SystemTransactions"></a><h2>  Transacciones basadas en el sistema. </h2><br><a name="WhatIsIt1"></a><h4>  Que es esto </h4><br>  En el mundo .NET, existe un marco de software diseñado por los creadores de una plataforma de gestión de transacciones.  Desde la perspectiva de un programador transaccional, este marco consiste en los <code>System.Transactions</code> <code>TransactionScope</code> , <code>TransactionScopeOption</code> , <code>TransactionScopeAsyncFlowOption</code> y <code>TransactionOptions</code> <code>System.Transactions</code> nombres <code>System.Transactions</code> .  Si hablamos de .NET Standard, todo esto está disponible a partir de la <a href="">versión 2.0</a> . <br><br>  Transacciones del sistema. El <code>System.Transactions</code> nombres de transacciones se basa en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el estándar X / Open XA de The Open Group</a> .  Este estándar presenta muchos de los términos que se analizan a continuación y, lo que es más importante, describe las transacciones distribuidas, que también se tratan en esta publicación en una sección especial.  La implementación de transacciones de software en otras plataformas, por ejemplo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">, Java, se</a> basa en el mismo estándar. <br><br>  Un caso de uso de transacción típico para un programador de C # es el siguiente: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Transactions.TransactionScope(System.Transactions.TransactionScopeOption.Required)) { <span class="hljs-comment"><span class="hljs-comment">// -  ,    . scope.Complete(); }</span></span></code> </pre> <br>  Dentro del bloque de <code>using</code> está el código que hace el trabajo, cuyos resultados deben confirmarse o cancelarse todos juntos.  Ejemplos clásicos de tal trabajo son leer y escribir en la base de datos o enviar y recibir mensajes desde la cola.  Cuando el control abandona el bloque de <code>using</code> , la transacción se confirmará.  Si elimina la llamada <code>Complete</code> , la transacción se revertirá.  Bastante simple <br><br>  Resulta que durante la reversión de una transacción, ¿se cancelarán todas las operaciones realizadas dentro de dicho bloque de <code>using</code> ?  ¿Y si asigné a una variable un valor diferente, entonces esta variable restaurará el valor anterior?  Cuando vi por primera vez un diseño similar, pensé que sí.  De hecho, por supuesto, no todos los cambios se revertirán, sino solo algunos muy <i>especiales</i> .  Si todos los cambios fueran revertidos, esta sería la memoria transaccional de software descrita anteriormente.  Ahora veamos cuáles son estos cambios especiales que pueden participar en las transacciones del programa basadas en <code>System.Transactions</code> . <br><br><a name="ResourceManagers"></a><h4>  Administradores de recursos </h4><br>  Para que algo respalde las transacciones basadas en <code>System.Transactions</code> , es necesario que posea información de que una transacción está actualmente en curso y que está registrada en algún registro de participantes de la transacción.  Puede obtener información sobre si el trabajo transaccional está en marcha al verificar la propiedad estática <code>Current</code> de la clase <code>System.Transactions.Transaction</code> .  Ingresar el bloque de uso del tipo indicado anteriormente solo establece esta propiedad, si no se ha establecido antes.  Y para registrarse como participante en una transacción, puede usar métodos del tipo <code>Transaction.Enlist <i>Smth</i></code> .  Además, debe implementar la interfaz requerida por estos métodos.  Administrador de recursos: este es un "algo" que admite la interacción con las transacciones de <code>System.Transactions</code> (a continuación se ofrece una definición más específica). <br><br>  ¿Qué son los administradores de recursos?  Si trabajamos desde C # con un DBMS, por ejemplo, SQL Server u Oracle Database, usualmente usamos los controladores apropiados, y son los recursos de gestión.  En el código, están representados por los tipos <code>System.Data.SqlClient.SqlConnection</code> y <code>Oracle.ManagedDataAccess.Client.OracleConnection</code> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">También dicen</a> que MSMQ admite transacciones basadas en <code>System.Transactions</code> .  Guiado por el conocimiento y los ejemplos extraídos de Internet, puede crear su propio administrador de recursos.  El ejemplo más simple se da en la siguiente sección. <br><br>  Además de los administradores de recursos, también debemos tener un Administrador de transacciones, que supervisará la transacción y dará órdenes a los administradores de recursos de manera oportuna.  Dependiendo de qué administradores de recursos estén involucrados en la transacción (qué características tienen y dónde se encuentran), diferentes administradores de transacciones están conectados al trabajo.  En este caso, la selección de la versión adecuada es automática y no requiere la intervención de un programador. <br><br>  Más específicamente, el administrador de recursos es una instancia de una clase que implementa la interfaz especial <code>System.Transactions.IEnlistmentNotification</code> .  La instancia de clase, según las indicaciones del cliente, se registra como participante en la transacción utilizando la propiedad estática <code>System.Transactions.Transaction.Current</code> .  Posteriormente, el administrador de transacciones llama a los métodos de la interfaz especificada según sea necesario. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tw/ea/vp/tweavpimeod539do_fkzpr6yzrw.png"></div><br>  Está claro que en tiempo de ejecución, el conjunto de administradores de recursos involucrados en la transacción puede cambiar.  Por ejemplo, después de ingresar el bloque <code>using</code> , primero podemos hacer algo en SQL Server y luego en Oracle Database.  Dependiendo de este conjunto de administradores de recursos, se determina el administrador de transacciones utilizado.  Para ser más precisos, el protocolo de transacción utilizado está determinado por el conjunto de administradores de recursos, y el administrador de transacciones que lo respalda se determina en función del protocolo.  Examinaremos los protocolos transaccionales <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">más adelante</a> cuando hablemos de transacciones distribuidas.  El mecanismo para seleccionar automáticamente el administrador de transacciones apropiado en tiempo de ejecución al cambiar los administradores de recursos involucrados en la transacción se llama Promoción de transacción. <br><br><a name="KindsOfResourceManagers"></a><h4>  Tipos de gerentes de recursos </h4><br>  Los administradores de recursos se pueden dividir en dos grandes grupos: duraderos y variables. <br><br>  Administrador de recursos duraderos: un administrador de recursos que admite una transacción incluso si el sistema de información no está disponible (por ejemplo, cuando la computadora se reinicia).  Administrador de recursos volátiles: un administrador de recursos que no admite una transacción si el sistema de información no está disponible.  Un administrador de recursos inconsistente solo admite transacciones en la memoria. <br><br>  Los administradores de recursos clásicos a largo plazo son el DBMS (o el controlador DBMS para la plataforma de software).  Pase lo que pase, al menos un mal funcionamiento en el sistema operativo, al menos un corte de energía, el DBMS garantizará la integridad de los datos una vez que vuelva a funcionar.  Para esto, por supuesto, debe pagar algunos inconvenientes, pero en este artículo no los consideraremos.  Un ejemplo de un administrador de recursos no persistente es la memoria transaccional de software mencionada anteriormente. <br><br><a name="TransactionScope"></a><h4>  Usando TransactionScope </h4><br>  Al crear un objeto de tipo <code>TransactionScope</code> puede especificar algunos parámetros. <br><br>  En primer lugar, hay una configuración que le dice al tiempo de ejecución lo que necesita: <br><br><ol><li>  Use una transacción que ya existe en este momento; </li><li>  Asegúrese de crear uno nuevo; </li><li>  por el contrario, ejecute código dentro de un bloque de <code>using</code> fuera de una transacción. </li></ol><br>  La enumeración <code>System.Transactions.TransactionScopeOption</code> es responsable de todo esto. <br><br>  En segundo lugar, puede establecer el nivel de aislamiento de la transacción.  Este es un parámetro que le permite encontrar un compromiso entre la independencia del cambio y la velocidad.  El nivel más independiente, serializable, asegura que no haya situaciones en las que los cambios realizados dentro de una transacción que aún no se hayan confirmado puedan verse en otra transacción.  Cada nivel siguiente agrega una situación específica, cuando las transacciones simultáneas se pueden afectar entre sí.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por defecto, una transacción se abre en el nivel serializable, lo que puede ser desagradable (ver, por ejemplo, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">este comentario</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Establecer el nivel de aislamiento de la transacción durante la creación </font></font><code>TransactionScope</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es una recomendación para los administradores de recursos. Es posible que ni siquiera admitan todos los niveles enumerados </font></font><code>System.Transactions.IsolationLevel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Además, debe tenerse en cuenta que cuando se usa el grupo de conexiones para trabajar con la base de datos, la conexión para la cual se ha cambiado el nivel de aislamiento de la transacción </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retendrá este nivel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> al regresar al grupo </font><font style="vertical-align: inherit;">. Ahora, cuando el programador recibe esta conexión del grupo y se basa en los valores predeterminados, observará un comportamiento inesperado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Escenarios de trabajo típicos c</font></font><code>TransactionScope</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y las trampas significativas (a saber, transacciones anidadas) están bien cubiertas en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">este artículo sobre "Habr"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><a name="Applicability"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aplicabilidad de transacción de software </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debe decirse que en casi cualquier sistema de información en operación comercial, se inician procesos que pueden llevar al sistema a un estado inaceptable. </font><font style="vertical-align: inherit;">Por lo tanto, puede ser necesario controlar estos procesos, averiguar si el estado actual del sistema es aceptable y, si no, restaurarlo. </font><font style="vertical-align: inherit;">Transacciones de software: una herramienta preparada para mantener el sistema en un estado aceptable. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En cada caso, sería constructivo considerar el costo:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">integrar procesos en la infraestructura de transacciones de software (estos procesos también deben ser conscientes </font></font><code>TransactionScope</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de muchas otras cosas);</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mantener esta infraestructura (por ejemplo, el costo de alquilar equipos con Windows a bordo); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> capacitación de empleados (ya que el tema de las transacciones .NET no es común). </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No debemos olvidar que el proceso de transacción puede ser requerido para informar su progreso al "mundo exterior", por ejemplo, para mantener un diario de acciones fuera de la transacción. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, el rechazo de las transacciones de software requerirá la creación o implementación de algún otro medio para mantener la integridad de los datos, que también tendrá su valor. </font><font style="vertical-align: inherit;">Al final, puede haber casos en que las violaciones de la integridad de los datos sean tan raras que sea más fácil restaurar un estado aceptable del sistema mediante intervenciones quirúrgicas que mantener un mecanismo de recuperación automática.</font></font><br><br><a name="Example"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ejemplo de gestor de recursos voluble </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora veamos un ejemplo de un administrador de recursos simple que no admite la recuperación de una falla del sistema. Tendremos un bloque de memoria transaccional de software que almacena algún valor que puede leerse y escribirse. En ausencia de una transacción, este bloque se comporta como una variable regular y, en presencia de una transacción, almacena el valor inicial, que puede restaurarse después de que la transacción se revierta. El código para dicho administrador de recursos se presenta a continuación:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Stm</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">System</span></span>.<span class="hljs-title"><span class="hljs-title">Transactions</span></span>.<span class="hljs-title"><span class="hljs-title">IEnlistmentNotification</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> T _current; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> T _original; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _enlisted; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T Value { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _current; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Enlist()) { _original = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } _current = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stm</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { _current = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; _original = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enlist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_enlisted) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentTx = System.Transactions.Transaction.Current; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentTx == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; currentTx.EnlistVolatile(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, System.Transactions.EnlistmentOptions.None); _enlisted = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> IEnlistmentNotification public void Commit(System.Transactions.Enlistment enlistment) { _original = _current; _enlisted = false; } public void InDoubt(System.Transactions.Enlistment enlistment) { _enlisted = false; } public void Prepare(System.Transactions.PreparingEnlistment preparingEnlistment) { preparingEnlistment.Prepared(); } public void Rollback(System.Transactions.Enlistment enlistment) { _current = _original; _enlisted = false; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> IEnlistmentNotification }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se puede ver que el único requisito formal es la implementación de la interfaz </font></font><code>System.Transactions.IEnlistmentNotification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. De los interesantes, los métodos </font></font><code>Enlist</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(que no son parte </font></font><code>System.Transactions.IEnlistmentNotification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) y </font></font><code>Prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. El método </font></font><code>Enlist</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solo verifica si el código dado funciona dentro del marco de la transacción y, si es así, registra una instancia de su clase como un administrador de recursos no constante. El </font></font><code>Prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">administrador de transacciones llama al </font><font style="vertical-align: inherit;">método </font><font style="vertical-align: inherit;">antes de confirmar los cambios. Nuestro administrador de recursos señala su disposición para comprometerse llamando a un método </font></font><code>System.Transactions.PreparingEnlistment.Prepared</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El siguiente es un código que muestra un ejemplo del uso de nuestro administrador de recursos:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stm = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stm&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Transactions.TransactionScope(System.Transactions.TransactionScopeOption.Required)) { stm.Value = <span class="hljs-number"><span class="hljs-number">2</span></span>; scope.Complete(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si </font></font><code>using</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lee la propiedad </font><font style="vertical-align: inherit;">inmediatamente después de salir del bloque </font></font><code>stm.Value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, se esperará allí el valor esperado </font></font><code>2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Y si elimina la llamada </font></font><code>scope.Complete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la transacción se revertirá y la propiedad </font></font><code>stm.Value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tendrá el valor </font></font><code>1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">establecido antes del inicio de la transacción. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En </font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el siguiente diagrama </font><font style="vertical-align: inherit;">se </font><font style="vertical-align: inherit;">muestra </font><font style="vertical-align: inherit;">una secuencia simplificada de llamadas cuando se trabaja con transacciones </font><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/09/je/1d/09je1dkghhmmwts6rvaufuntpna.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se puede ver que en este ejemplo, no se consideran todas las posibilidades proporcionadas por la infraestructura </font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Los consideraremos más a fondo una vez que nos familiaricemos con los protocolos transaccionales y las transacciones distribuidas en la siguiente sección.</font></font><br><br><a name="TLDR2"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TL; sección DR </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un programador puede usar una clase </font></font><code>TransactionScope</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para ejecutar algún código dentro de una transacción existente o nueva. Una transacción se confirma si y solo si </font></font><code>TransactionScope</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se llama </font><font style="vertical-align: inherit;">al </font><font style="vertical-align: inherit;">método </font><font style="vertical-align: inherit;">en una instancia existente de la clase </font></font><code>Dispose</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, incluso si el método se llamó antes</font></font><code>Complete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Un programador puede indicar si desea comenzar una nueva transacción, aprovechar una existente o, por el contrario, ejecutar código fuera de una transacción existente. Solo los administradores de recursos están involucrados en la transacción: componentes de software que implementan cierta funcionalidad. Los administradores de recursos pueden ser a largo plazo (recuperación de una falla del sistema) e intermitentes (no recuperación). Un DBMS es un ejemplo de un administrador de recursos de larga duración. El administrador de recursos es coordinado por un administrador de transacciones, un componente de software que el tiempo de ejecución selecciona automáticamente sin la participación de un programador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El administrador de recursos inconsistente es una clase que implementa la interfaz </font></font><code>System.Transactions.IEnlistmentNotification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el método</font></font><code>Prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">confirmando su disponibilidad para cometer cambios o, por el contrario, señalando una reversión de los cambios. </font><font style="vertical-align: inherit;">Cuando la persona que llama hace algo con el administrador de recursos, comprueba si la transacción está abierta ahora y, si está abierta, inicia sesión con el método </font></font><code>System.Transactions.Transaction.EnlistVolatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><a name="DistributedTransactions"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transacciones distribuidas </font></font></h2><br><a name="WhatIsIt2"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Que es esto </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una transacción distribuida involucra varios subsistemas de información (de hecho, no todo es tan simple, más sobre esto a continuación). </font><font style="vertical-align: inherit;">Se entiende que los cambios en todos los sistemas involucrados en una transacción distribuida deben confirmarse o revertirse. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anteriormente se presentaron varios medios para implementar transacciones: DBMS, infraestructura </font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y memoria transaccional programática integrada en la plataforma. </font><font style="vertical-align: inherit;">Las transacciones distribuidas también se pueden proporcionar con estas herramientas. </font><font style="vertical-align: inherit;">Por ejemplo, en la base de datos Oracle, el cambio (y la lectura real) de datos en varias bases de datos dentro de una sola transacción la convierte automáticamente en una distribuida. </font><font style="vertical-align: inherit;">A continuación, hablaremos sobre las transacciones distribuidas por software, que pueden incluir administradores de recursos heterogéneos.</font></font><br><br><a name="TransactionProtocols"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Protocolos transaccionales </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un protocolo transaccional es un conjunto de principios por los cuales interactúan las aplicaciones involucradas en una transacción. En el mundo .NET, los siguientes protocolos se encuentran más comúnmente. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ligero</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No se utiliza más de un administrador de recursos duradero. Todas las interacciones transaccionales ocurren dentro del mismo dominio de aplicación, o el administrador de recursos admite la promoción y el compromiso de fase única (implementa </font></font><code>IPromotableSinglePhaseNotification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OleTx.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se permite la interoperabilidad entre múltiples dominios de aplicación y múltiples computadoras. Puede usar muchos administradores de recursos duraderos. Todas las computadoras participantes deben estar ejecutando Windows. Use llamadas a procedimiento remoto (RPC). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WS-AT.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se permite la interoperabilidad entre múltiples dominios de aplicación y múltiples computadoras. Puede usar muchos administradores de recursos duraderos. Las computadoras participantes pueden estar ejecutando varios sistemas operativos, no solo Windows. Se utiliza el Protocolo de transmisión de hipertexto (HTTP). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se señaló anteriormente que el protocolo de transacción actual afecta la elección del administrador de la transacción, y las características de los recursos de control involucrados en la transacción influyen en la elección del protocolo. Ahora enumeramos los gestores de transacciones conocidos. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Administrador de transacciones ligeras (LTM)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Introducido en .NET Framework 2.0 y versiones posteriores. Gestiona transacciones utilizando el protocolo Lightweight. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kernel Transaction Manager (KTM)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Introducido en Windows Vista y Windows Server 2008. Administra las transacciones utilizando el protocolo Lightweight. Puede invocar un Sistema de archivos transaccionales (TxF) y un Registro transaccional (TxR) en Windows Vista y Windows 2008. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coordinador de transacciones distribuidas (MSDTC)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Gestiona transacciones utilizando los protocolos OleTx y WS-AT. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">También debe tenerse en cuenta que algunos administradores de recursos no son compatibles con todos los protocolos enumerados. Por ejemplo, MSMQ y SQL Server 2000 no son compatibles con Lightweight, por lo que las transacciones que involucran MSMQ o SQL Server 2000 serán administradas por MSDTC, incluso si son los únicos participantes. Técnicamente, esta limitación surge del hecho de que los administradores de recursos especificados, implementando, por supuesto, la interfaz</font></font><code>System.Transactions.IEnlistmentNotification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No implemente la interfaz </font></font><code>System.Transactions.IPromotableSinglePhaseNotification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Contiene, entre otras cosas, un método </font></font><code>Promote</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que el tiempo de ejecución invoca, si es necesario, para cambiar a un administrador de transacciones más empinado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La ambigüedad del concepto de transacción distribuida ahora debería ser evidente. </font><font style="vertical-align: inherit;">Por ejemplo, puede definir una transacción distribuida como una transacción en la que participa:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> al menos dos de los administradores de recursos; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> administradores de recursos arbitrariamente variables y al menos dos de larga vida; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> al menos dos de los administradores de recursos necesariamente ubicados en diferentes computadoras. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, es mejor aclarar siempre qué transacciones particulares están involucradas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y en este contexto, MSDTC se discute principalmente. </font><font style="vertical-align: inherit;">Es un componente de software de Windows que administra transacciones distribuidas. </font><font style="vertical-align: inherit;">Hay una interfaz gráfica para configurar y monitorear transacciones, que se puede encontrar en la utilidad "Servicios de componentes", siguiendo la ruta "Computadoras - Mi computadora - Coordinador de transacciones distribuidas - DTC local".</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vo/35/gc/vo35gcdta3c9qx5w5cnsuxkbzz8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para la configuración, seleccione el elemento "Propiedades" en el menú contextual del nodo "DTC local", y para supervisar las transacciones distribuidas, seleccione el elemento "Estadísticas de transacciones" en el panel central. </font></font><br><br><a name="TwoPhaseCommit"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fijación bifásica </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si varios administradores de recursos participan en la transacción, los resultados de su trabajo pueden diferir: por ejemplo, uno de ellos se completó con éxito, y está listo para confirmar los cambios, y el otro tiene un error, y va a revertir los cambios. Sin embargo, la esencia de una transacción distribuida radica en el hecho de que los cambios en todos los recursos de control involucrados en la transacción se confirman todos juntos o se revierten. Por lo tanto, en tales casos, generalmente se usa un protocolo de fijación de dos fases. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En general, la esencia de este protocolo es la siguiente. Durante la </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primera fase</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los administradores de recursos involucrados en la transacción preparan información suficiente para recuperarse de la falla (si es un administrador de recursos a largo plazo) y para completar con éxito como resultado de una confirmación. Desde un punto de vista técnico, el administrador de recursos señala que ha completado la primera fase llamando al método </font></font><code>System.Transactions.PreparingEnlistment.Prepared</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el método </font></font><code>Prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. O el administrador de recursos puede notificarle que los cambios fueron revertidos llamando al método </font></font><code>ForceRollback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando todos los administradores de recursos involucrados en la transacción "votaron", es decir, notificaron al administrador de transacciones si desean confirmar o revertir los cambios, comienza la </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segunda fase</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. En este momento, los gerentes de recursos tienen instrucciones de confirmar sus cambios (si todos los participantes votaron por la reparación) o de rechazar los cambios (si al menos un participante votó por la reversión). Técnicamente, esto se expresa en la invocación de los métodos </font></font><code>Commit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y en </font></font><code>Rollback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la implementación de los administradores de recursos y en la que invocan el método </font></font><code>System.Transactions.Enlistment.Done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El administrador de recursos también puede llamar al método </font></font><code>System.Transactions.Enlistment.Done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">durante la primera fase. En este caso, se entiende que no va a cometer ningún cambio (por ejemplo, solo trabaja para leer) y no participará en la segunda fase. Lea más sobre la confirmación </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dos fases </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">en Microsoft</font></a><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si se pierde la conexión entre el administrador de transacciones y al menos uno de los administradores de recursos, la transacción se congela ("en duda", en duda). </font><font style="vertical-align: inherit;">El administrador de transacciones, mediante métodos de llamada </font></font><code>InDoubt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, notifica a los administradores de recursos disponibles de este evento que pueden responder adecuadamente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todavía hay una </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fijación trifásica</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y sus modificaciones con sus ventajas y desventajas. </font><font style="vertical-align: inherit;">El protocolo de confirmación de tres fases es menos común, quizás porque requiere aún más costos de comunicación entre los subsistemas que interactúan.</font></font><br><br><a name="Interfaces"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cheat sheet en las interfaces de System.Transactions </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algo es dificil. Para ordenar un poco las cosas, describiré brevemente las principales interfaces de espacio de nombres </font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">necesarias para crear un administrador de recursos. Aquí hay un diagrama de clase.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bs/rj/sx/bsrjsxptqz6w3g7l6zxawrzeyco.png"></div><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IEnlistmentNotification.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El administrador de recursos implementa esta interfaz. El administrador de transacciones llama a los métodos implementados en el siguiente orden. Durante la primera fase, llama al método </font></font><code>Prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(a menos que las estrellas se unan para llamar al método </font></font><code>ISinglePhaseNotification.SinglePhaseCommit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, como se describe en el siguiente párrafo). Bajo este método, el administrador de recursos guarda la información necesaria para recuperarse de una falla, se prepara para la confirmación final de los cambios de su lado y vota para confirmar o revertir los cambios. Si llega una segunda fase, en función de la disponibilidad de recursos y el control de los resultados de la votación de la operación de control es uno de tres métodos: </font></font><code>Commit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>InDoubt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>Rollback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ISinglePhaseNotification.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El administrador de recursos implementa esta interfaz si desea brindarle al administrador de transacciones la oportunidad de optimizar la ejecución al reducir la segunda fase de confirmación. Si el administrador de transacciones solo ve un administrador de recursos, entonces, en la primera fase de confirmación, intenta llamar al método del administrador de recursos </font></font><code>SinglePhaseCommit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(en su lugar </font></font><code>IEnlistmentNotification.Prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) y, por lo tanto, excluye la votación y la transición a la segunda fase. Este enfoque tiene ventajas y desventajas, sobre las cuales Microsoft escribió más claramente </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ITransactionPromoter.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El administrador de recursos implementa esta interfaz (no solo directamente, sino a través de la interfaz</font></font><code>IPromotableSinglePhaseNotification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), si desea proporcionar al administrador de transacciones la capacidad de adherirse al protocolo Lightweight incluso cuando llama de forma remota, hasta que surjan otras condiciones que requieran una complicación del protocolo. Cuando necesite complicar el protocolo, se llamará al método </font></font><code>Promote</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IPromotableSinglePhaseNotification.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El administrador de recursos implementa esta interfaz para, en primer lugar, implementar la interfaz </font></font><code>ITransactionPromoter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y, en segundo lugar, para que el administrador de transacciones pueda utilizar la confirmación de una sola fase, métodos de llamada </font></font><code>IPromotableSinglePhaseNotification.SinglePhaseCommit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>IPromotableSinglePhaseNotification.Rollback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. El administrador de transacciones llama a un método </font></font><code>IPromotableSinglePhaseNotification.Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para marcar el registro exitoso del administrador de recursos de manera simplificada. Más o menos, esto se puede entender a partir de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un documento de Microsoft</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Miremos un poco más</font></font><code>System.Transactions.Enlistment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y sus herederos. El administrador de transacciones proporciona este tipo de instancia cuando invoca los métodos de interfaz implementados por el administrador de recursos.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qi/bd/xc/qibdxcddktegq5h2xnpuaelygj0.png"></div><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alistamiento </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El administrador de recursos puede llamar a un único método de este tipo </font></font><code>Done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, para indicar la finalización exitosa de su parte del trabajo. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PreparingEnlistment. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilizando una instancia de este tipo durante la primera fase de confirmación, el administrador de recursos puede indicar su intención de confirmar o revertir los cambios. </font><font style="vertical-align: inherit;">Un administrador de recursos de larga duración también puede obtener la información necesaria para recuperarse de una falla del sistema. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SinglePhaseEnlistment. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando una instancia de este tipo, el administrador de recursos puede transmitir información al administrador de transacciones sobre los resultados de su trabajo utilizando un esquema simplificado (confirmación de fase única).</font></font><br><br><a name="LimitationsAndAlternatives"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Limitaciones y alternativas de transacciones distribuidas por software </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un breve estudio de las opiniones encontradas en Internet muestra que en muchas áreas, las transacciones distribuidas están pasadas de moda. Eche un vistazo a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">este comentario malicioso</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , por ejemplo </font><font style="vertical-align: inherit;">. El principal objeto de crítica, que se menciona brevemente </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , es la naturaleza síncrona (bloqueo) de las transacciones distribuidas. Si el usuario envió una solicitud durante el procesamiento de la cual se organizó una transacción distribuida, recibirá una respuesta solo después (con éxito o con un error) de que todos los subsistemas incluidos en la transacción terminen de funcionar. Al mismo tiempo, existe una opinión respaldada por la investigación de que el protocolo de confirmación de dos fases muestra un rendimiento deficiente, especialmente con un aumento en el número de subsistemas involucrados en la transacción, como se menciona, por ejemplo, en</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esta publicación sobre "Habré"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si el creador del sistema prefiere devolver la respuesta al usuario lo antes posible, posponiendo la coordinación de datos para más adelante, entonces alguna otra solución será más adecuada para él. En el contexto del teorema de Brewer (teorema </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CAP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), podemos decir que las transacciones distribuidas son adecuadas para casos donde la consistencia de los datos es más importante que la disponibilidad.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existen otras restricciones prácticas sobre el uso de transacciones distribuidas por software. Por ejemplo, se estableció experimentalmente que las transacciones distribuidas que utilizan el protocolo OleTx no deberían cruzar dominios de red. En cualquier caso, los intentos largos para que funcionen no tuvieron éxito. Además, se reveló que la interacción entre varias instancias de Oracle Database (transacciones de bases de datos distribuidas) impone serias restricciones a la aplicabilidad de las transacciones distribuidas por software (nuevamente, no se pudo iniciar).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Cuáles son las alternativas a las transacciones distribuidas? Primero, debo decir que será muy difícil prescindir de transacciones técnicas (normal, no distribuido). Es probable que haya procesos en el sistema que puedan alterar temporalmente la integridad de los datos, y será necesario de alguna manera supervisar dichos procesos. Del mismo modo, en términos del área temática, puede surgir un concepto que incluya un proceso implementado por un conjunto de procesos en diferentes sistemas técnicos, que deben comenzar y terminar en el campo de los datos integrales. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pasando a las alternativas a las transacciones distribuidas, podemos observar soluciones basadas en servicios de mensajería, como RabbitMQ y Apache Kafka. En </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esta publicación sobre "Habré"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se consideran cuatro de estas soluciones:</font></font><br><br><ol><li>   ,        ,    ; </li><li>    ,           (Transaction Log Tailing); </li><li>       ,       ; </li><li>             (Event Sourcing). </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otra alternativa es la plantilla Saga. Implica una cascada de subsistemas con sus transacciones locales. Al finalizar el trabajo, cada sistema llama a lo siguiente (independientemente o con la ayuda de un coordinador). Para cada transacción hay una transacción de cancelación correspondiente, y en lugar de transferir el control, el subsistema puede iniciar la cancelación de los cambios realizados anteriormente por los subsistemas anteriores. En "Habré" hay algunos buenos artículos sobre la plantilla "Saga". Por ejemplo, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esta publicación</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> proporciona información general sobre el mantenimiento de los principios de ACID en microservicios, y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">este artículo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> detalla un ejemplo de implementación de la plantilla Saga con un coordinador.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En nuestra empresa, algunos productos utilizan con éxito transacciones distribuidas por software a través de WCF, pero hay otras opciones. Una vez, cuando intentamos hacer amigos un nuevo sistema con transacciones distribuidas, tuvimos muchos problemas, incluida una colisión con las limitaciones descritas anteriormente y problemas paralelos con la actualización de la infraestructura del software. Por lo tanto, en condiciones de escasez de recursos para ejecutar otra decisión de capital, aplicamos las siguientes tácticas. La parte llamada captura los cambios en cualquier caso, pero observa que están en un estado borrador, por lo que estos cambios aún no afectan el funcionamiento del sistema llamado. Luego, la persona que llama, al completar su trabajo a través de una transacción distribuida, el DBMS activa los cambios realizados por el sistema llamado. De esta maneraen lugar de transacciones distribuidas por software, utilizamos transacciones DBMS distribuidas, que en este caso resultaron ser mucho más confiables.</font></font><br><br><a name="NetCore"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entonces, ¿está en .NET Core? </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En .NET Core (e incluso en .NET Standard) existen todos los tipos necesarios para organizar transacciones y crear su propio administrador de recursos. </font><font style="vertical-align: inherit;">Desafortunadamente, en .NET Core, las transacciones basadas </font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tienen una seria limitación: solo funcionan con el protocolo Lightweight. </font><font style="vertical-align: inherit;">Por ejemplo, si se usan dos administradores de recursos duraderos en el código, en tiempo de ejecución, el entorno generará una excepción tan pronto como se llame al segundo administrador.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El hecho es que intentan hacer que .NET Core sea independiente del sistema operativo, por lo que se excluye el enlace a los administradores de transacciones como KTM y MSDTC, es decir, son necesarios para admitir transacciones con las propiedades especificadas. </font><font style="vertical-align: inherit;">Es posible que la conexión de los administradores de transacciones se implemente en forma de complementos, pero hasta ahora esto se ha escrito con un pitchfork, por lo que aún no puede confiar en el uso industrial de las transacciones distribuidas en .NET Core. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por experiencia, puede verificar las diferencias en las transacciones distribuidas en .NET Framework y en .NET Core escribiendo el mismo código, compilándolo y ejecutándolo en diferentes plataformas.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un ejemplo de dicho código que invoca SQL Server y Oracle Database secuencialmente.</font></font></b> <div class="spoiler_text"><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Transactions.TransactionScope(System.Transactions.TransactionScopeOption.Required)) { MsSqlServer(); Oracle(); scope.Complete(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Oracle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> conn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Oracle.ManagedDataAccess.Client.OracleConnection(<span class="hljs-string"><span class="hljs-string">"User Id=some_user;Password=some_password;Data Source=some_db"</span></span>)) { conn.Open(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cmd = conn.CreateCommand()) { cmd.CommandText = <span class="hljs-string"><span class="hljs-string">"update t_hello set id_hello = 2 where id_hello = 1"</span></span>; cmd.ExecuteNonQuery(); } conn.Close(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MsSqlServer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Data.SqlClient.SqlConnectionStringBuilder { DataSource = <span class="hljs-string"><span class="hljs-string">"some_computer\\some_db"</span></span>, UserID = <span class="hljs-string"><span class="hljs-string">"some_user"</span></span>, Password = <span class="hljs-string"><span class="hljs-string">"some_password"</span></span>, InitialCatalog = <span class="hljs-string"><span class="hljs-string">"some_scheme"</span></span>, Enlist = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> conn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Data.SqlClient.SqlConnection(builder.ConnectionString)) { conn.Open(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cmd = conn.CreateCommand()) { cmd.CommandText = <span class="hljs-string"><span class="hljs-string">"update t_hello set id_hello = 2 where id_hello = 1"</span></span>; cmd.ExecuteNonQuery(); } conn.Close(); } }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los proyectos listos para construir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">están en GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La ejecución del ejemplo de .NET Core falla. </font><font style="vertical-align: inherit;">El lugar y el tipo de la excepción lanzada dependen del orden de la llamada DBMS, pero en cualquier caso, esta excepción indica una operación de transacción no válida. </font><font style="vertical-align: inherit;">Ejecutar el ejemplo para .NET Framework tiene éxito si MSDTC se está ejecutando en este momento; </font><font style="vertical-align: inherit;">sin embargo, en la interfaz gráfica de MSDTC, puede observar el registro de una transacción distribuida.</font></font><br><br><a name="WCF"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transacciones distribuidas y WCF </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Windows Communication Foundation (WCF) es el marco .NET para organizar e invocar servicios de red. En comparación con los enfoques REST y ASP.NET Web API más modernos, tiene sus propias ventajas y desventajas. WCF es muy buen amigo de las transacciones .NET, y en el mundo de .NET Framework es conveniente usarlo para organizar transacciones distribuidas entre el cliente y el servicio. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En .NET Core, esta tecnología funciona solo en el lado del cliente, es decir, no puede crear un servicio, pero solo puede referirse a uno existente. Sin embargo, esto no es muy importante porque, como se mencionó anteriormente, con las transacciones distribuidas en .NET Core, las cosas no están funcionando bien. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cómo funciona WCF</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para los lectores que no están familiarizados con WCF, aquí está la información básica más breve sobre lo que esta tecnología es en la práctica. Contexto: dos sistemas de información llamados cliente y servicio. El cliente en tiempo de ejecución accede a otro sistema de información que admite el servicio de interés para el cliente y requiere que se realice alguna operación. Luego la gestión se devuelve al cliente.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para crear un servicio en WCF, generalmente necesita escribir una interfaz que describa el contrato para el servicio que se está creando y una clase que implemente esta interfaz. La clase y la interfaz están marcadas con atributos WCF especiales que los distinguen del resto de los tipos y especifican algunos detalles del comportamiento durante el descubrimiento y la invocación del servicio. Estos tipos están envueltos en algo que funciona como un servidor (por ejemplo, en un archivo DLL en el que se establece IIS), y se complementan con un archivo de configuración (hay opciones), donde se indican los detalles de la implementación del servicio. Después de comenzar, se puede acceder al servicio, por ejemplo, en la dirección de red; En el navegador de Internet puede ver los contratos que implementa el servicio solicitado.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un programador que desea acceder a un servicio WCF existente utiliza una utilidad de consola o una interfaz gráfica integrada en el entorno de desarrollo para formar tipos en C # (o en otro lenguaje compatible) que correspondan a los contratos de servicio en la dirección del servicio. El archivo con los tipos obtenidos se incluye en el proyecto de aplicación del cliente, y luego el programador usa los mismos términos contenidos en la interfaz del servicio, disfrutando de los beneficios del progreso (tipeo estático). Además, el archivo de configuración del cliente especifica las características técnicas del servicio llamado (también se puede configurar en código, sin el archivo de configuración).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WCF admite varios tipos de transporte, cifrado y otros parámetros técnicos más sutiles. </font><font style="vertical-align: inherit;">La mayoría de ellos están unidos por el concepto de "enlace". </font><font style="vertical-align: inherit;">Hay tres parámetros importantes para el servicio WCF:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> la dirección en la que está disponible; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vinculante </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contrato (interfaces). </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todos estos parámetros se establecen en los archivos de configuración del servicio y del cliente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En nuestra empresa, WCF (con y sin transacciones distribuidas) se usa ampliamente en productos implementados, sin embargo, dadas las tendencias de la moda, su uso en nuevos productos aún está en duda. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cómo iniciar transacciones distribuidas en WCF</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para iniciar transacciones basadas en WCF </font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, el programador necesita establecer varios atributos en el código, asegurarse de que los enlaces utilizados admitan transacciones distribuidas, </font></font><code>transactionFlow="true"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que </font><font style="vertical-align: inherit;">esté escrito en el cliente y en el servicio, </font><font style="vertical-align: inherit;">y que el administrador de transacciones apropiado se esté ejecutando en todas las computadoras involucradas (muy probablemente , será MSDTC).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enlaces de transacciones distribuidas: NetTcpBinding, NetNamedPipeBinding, WSHttpBinding, WSDualHttpBinding y WSFederationHttpBinding. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El método (operación) de la interfaz de servicio debe estar marcado con un atributo </font></font><code>System.ServiceModel.TransactionFlowAttribute</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Luego, con ciertos parámetros de atributo y al establecer el parámetro de </font></font><code>TransactionScopeRequired</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atributo </font><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">la </font></font><code>System.ServiceModel.OperationBehaviorAttribute</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transacción se distribuirá entre el cliente y el servicio. </font><font style="vertical-align: inherit;">Además, de manera predeterminada, se considera que el servicio vota para confirmar la transacción, a menos que se lance una excepción en tiempo de ejecución. </font><font style="vertical-align: inherit;">Para cambiar este comportamiento, debe establecer el valor del parámetro de </font></font><code>TransactionAutoComplete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atributo </font><font style="vertical-align: inherit;">correspondiente </font></font><code>System.ServiceModel.OperationBehaviorAttribute</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El código para un servicio WCF simple que admite transacciones distribuidas.</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">System.ServiceModel.ServiceContract</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IMyService</span></span> { [System.ServiceModel.OperationContract] [System.ServiceModel.TransactionFlow(System.ServiceModel.TransactionFlowOption.Mandatory)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyService</span></span> : <span class="hljs-title"><span class="hljs-title">IMyService</span></span> { [System.ServiceModel.OperationBehavior(TransactionScopeRequired = <span class="hljs-literal"><span class="hljs-literal">true</span></span>)] [System.ServiceModel.TransactionFlow(System.ServiceModel.TransactionFlowOption.Mandatory)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (input == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(input)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.Length; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, difiere del código de servicio regular solo en el uso del atributo </font></font><code>System.ServiceModel.TransactionFlow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y en la configuración especial del atributo </font></font><code>System.ServiceModel.OperationBehavior</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configuración de muestra para este servicio.</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs">&lt;system.serviceModel&gt; &lt;services&gt; &lt;service name=<span class="hljs-string"><span class="hljs-string">"WcfWithTransactionsExample.MyService"</span></span> behaviorConfiguration=<span class="hljs-string"><span class="hljs-string">"serviceBehavior"</span></span>&gt; &lt;endpoint address=<span class="hljs-string"><span class="hljs-string">""</span></span> binding=<span class="hljs-string"><span class="hljs-string">"wsHttpBinding"</span></span> bindingConfiguration=<span class="hljs-string"><span class="hljs-string">"mainWsBinding"</span></span> contract=<span class="hljs-string"><span class="hljs-string">"WcfWithTransactionsExample.IMyService"</span></span>/&gt; &lt;endpoint address=<span class="hljs-string"><span class="hljs-string">"mex"</span></span> contract=<span class="hljs-string"><span class="hljs-string">"IMetadataExchange"</span></span> binding=<span class="hljs-string"><span class="hljs-string">"mexHttpBinding"</span></span>/&gt; &lt;/service&gt; &lt;/services&gt; &lt;bindings&gt; &lt;wsHttpBinding&gt; &lt;binding name=<span class="hljs-string"><span class="hljs-string">"mainWsBinding"</span></span> maxReceivedMessageSize=<span class="hljs-string"><span class="hljs-string">"209715200"</span></span> maxBufferPoolSize=<span class="hljs-string"><span class="hljs-string">"209715200"</span></span> transactionFlow=<span class="hljs-string"><span class="hljs-string">"true"</span></span> closeTimeout=<span class="hljs-string"><span class="hljs-string">"00:10:00"</span></span> openTimeout=<span class="hljs-string"><span class="hljs-string">"00:10:00"</span></span> receiveTimeout=<span class="hljs-string"><span class="hljs-string">"00:10:00"</span></span> sendTimeout=<span class="hljs-string"><span class="hljs-string">"00:10:00"</span></span>&gt; &lt;security mode=<span class="hljs-string"><span class="hljs-string">"None"</span></span>/&gt; &lt;readerQuotas maxArrayLength=<span class="hljs-string"><span class="hljs-string">"209715200"</span></span> maxStringContentLength=<span class="hljs-string"><span class="hljs-string">"209715200"</span></span>/&gt; &lt;/binding&gt; &lt;/wsHttpBinding&gt; &lt;/bindings&gt; &lt;/system.serviceModel&gt;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta que el enlace es de tipo WSHttpBinding y se utiliza el atributo </font></font><code>transactionFlow="true"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></div></div><br><a name="TLDR3"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TL; sección DR </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las transacciones distribuidas incluyen varios administradores de recursos, y todos los cambios deben confirmarse o revertirse. Algunos DBMS modernos implementan transacciones distribuidas que proporcionan un mecanismo conveniente para conectar varias bases de datos. Las transacciones distribuidas por software (no implementadas en DBMS) pueden incluir diferentes combinaciones de administradores de recursos en diferentes computadoras que ejecutan diferentes sistemas operativos, pero tienen limitaciones que deben tenerse en cuenta antes de confiar en ellas. Una alternativa moderna a las transacciones distribuidas son las soluciones de mensajería. En .NET Core, las transacciones distribuidas aún no son compatibles.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WCF es una de las herramientas estándar y probadas para crear y acceder a servicios en el mundo .NET, que admite varios tipos de transporte y cifrado. </font><font style="vertical-align: inherit;">WCF es muy amigo de las transacciones distribuidas basadas en </font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La configuración de transacciones distribuidas para WCF consiste en marcar el código con varios atributos y agregar un par de palabras en el servicio y los archivos de configuración del cliente. </font><font style="vertical-align: inherit;">No todos los enlaces WCF admiten transacciones distribuidas. </font><font style="vertical-align: inherit;">Además, está claro que las transacciones en WCF tienen las mismas limitaciones que sin usar WCF. </font><font style="vertical-align: inherit;">La plataforma .NET Core hasta ahora solo le permite acceder a servicios en WCF, en lugar de crearlos.</font></font><br><br><a name="Conclusion"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conclusión Cuna </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta publicación es una descripción general de los conceptos básicos de las transacciones de software .NET. Algunas conclusiones sobre las tendencias en las transacciones de software se pueden encontrar en las secciones sobre la aplicabilidad y las limitaciones de los temas discutidos, y en conclusión, se recopilan las principales tesis de la publicación. Supongo que se pueden usar como una hoja de trucos cuando se consideran las transacciones de software como una de las opciones para implementar un sistema técnico o para actualizar la información relevante en la memoria. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transacciones (área temática, DBMS, software)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Los requisitos de dominio a veces se formulan en forma de transacciones: operaciones que, comenzando en el campo de los datos integrales, una vez completadas (incluidas las no exitosas) también deberían entrar en el campo de los datos integrales (posiblemente ya diferentes). Estos requisitos generalmente se implementan como transacciones del sistema. Un ejemplo clásico de una transacción es la transferencia de dinero entre dos cuentas, que consta de dos operaciones indivisibles: retirar dinero de una cuenta y acreditarlo a otra. Además de las transacciones bien conocidas implementadas por el DBMS, también hay transacciones de software, por ejemplo, en el mundo .NET. Los administradores de recursos son componentes de software que son conscientes de la existencia de tales transacciones y tienen la capacidad de ser incluidos en ellas, es decir, confirmar o revertir los cambios realizados.Los administradores de recursos reciben instrucciones sobre cómo confirmar y deshacer los cambios del administrador de transacciones, que es la base de la infraestructura</font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Administradores de recursos duraderos e intermitentes.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Los administradores de recursos a largo plazo admiten la recuperación de datos después de una falla del sistema. Los controladores DBMS para .NET generalmente ofrecen dicha funcionalidad. Los administradores de recursos intermitentes </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> admiten la recuperación ante desastres. La memoria transaccional programática, una forma de administrar objetos en RAM, puede verse como un ejemplo de un administrador de recursos voluble. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transacciones y .NET Resource Managers.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El programador .NET usa transacciones de software y crea sus propios administradores de recursos usando tipos del espacio de nombres</font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Esta infraestructura permite el uso de transacciones de varios tipos de anidamiento y aislamiento (con limitaciones conocidas). El uso de transacciones no es complicado, y consiste en envolver el código en un bloque </font></font><code>using</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con ciertas características. Sin embargo, los administradores de recursos incluidos de esta manera en la transacción deben mantener la funcionalidad requerida por su parte. El uso de administradores de recursos heterogéneos en una transacción o el uso de un administrador de diferentes maneras puede convertir automáticamente una transacción en una distribuida. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transacciones distribuidas (DBMS, software).</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una transacción distribuida cubre varios subsistemas, cuyos cambios deben sincronizarse, es decir, se confirman todos juntos o se revierten. Las transacciones distribuidas se implementan en algunos DBMS modernos. Las transacciones distribuidas por software (estas no son las implementadas por el DBMS) imponen restricciones adicionales en los procesos y plataformas que interactúan. Las transacciones distribuidas pasan de moda gradualmente, dando paso a soluciones basadas en servicios de mensajería. Para convertir una transacción ordinaria en una distribuida, el programador no necesita hacer nada: cuando se incluye un administrador de recursos con ciertas características en la transacción en tiempo de ejecución, el administrador de transacciones automáticamente hará lo que sea necesario. Las transacciones regulares de software están disponibles en .NET Core y .NET Standard, y las transacciones distribuidas no están disponibles.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transacciones distribuidas a través de WCF. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WCF es una de las herramientas estándar de .NET para crear e invocar servicios, que también admite protocolos estandarizados. </font><font style="vertical-align: inherit;">En otras palabras, se puede acceder a los servicios WCF que están configurados de una manera específica desde cualquier aplicación, no solo .NET o Windows. </font><font style="vertical-align: inherit;">Para crear una transacción distribuida sobre WCF, debe marcar los tipos que componen el servicio con atributos adicionales y realizar cambios mínimos en el servicio y los archivos de configuración del cliente. </font><font style="vertical-align: inherit;">No puede crear servicios WCF en .NET Core y .NET Standard, pero puede crear clientes WCF. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplo para verificar System.Transactions en GitHub</font></font></a> <br><br><div class="spoiler">  <b class="spoiler_title">Referencias</b> <div class="spoiler_text"><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conceptos basicos </font></font></h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ACID</a> ( «») <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  </a> ( Microsoft) <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> ( Microsoft) <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  </a> ( «») <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> ( «») <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> ( «») <br><br><h4>     </h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   X/Open XA</a> ( The Open Group) <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Java Transaction API</a> ( «») <br> <a href="">     Cache</a> (  InterSystems) <br><br><h4>   .NET </h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   .NET</a> (   Tech Blog Collection) <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">     TransactionScope</a> («») <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  ,     </a> ( Microsoft) <br> <a href="">   .NET Standard 2.0</a> ( .NET Standard  GitHub) <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">       </a> ( YarFullStack) <br><br><h4>    </h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">     </a> («») <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">     </a> («») <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">    «»     </a> («») <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">     «»  </a> («») <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">    </a> («») <br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editorial</font></font></b> <div class="spoiler_text"><ul><li> 20.12.2018 . </li><li> 21.12.2018  .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">OlegAxenow</a> . </li><li> 23.12.2018      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">qw1</a> . </li></ul><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es433136/">https://habr.com/ru/post/es433136/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es433122/index.html">React-Hot-Loader v4.6</a></li>
<li><a href="../es433126/index.html">Revisión de Zabbix: Cómo organizar una revisión de código para monitorear la configuración</a></li>
<li><a href="../es433128/index.html">Lo que juegan y no juegan los profesionales de TI (Boletín 2018)</a></li>
<li><a href="../es433130/index.html">Que la fuerza nos acompañe: nuestra propia inmunidad contra el cáncer</a></li>
<li><a href="../es433132/index.html">"Calendario de pruebas" para diciembre. Prueba un enfoque diferente</a></li>
<li><a href="../es433138/index.html">Cinco principios de diseño de producto en Booking</a></li>
<li><a href="../es433140/index.html">Módulo de cliente de Google Pay listo</a></li>
<li><a href="../es433142/index.html">Clásicos atemporales o una descripción general de los nuevos vectores de ataque a través de Microsoft Office</a></li>
<li><a href="../es433144/index.html">.NET Core 2.2 lanzado. Que hay de nuevo (1 de 3)</a></li>
<li><a href="../es433146/index.html">[competencia] Top 25 consolas de juegos (agitar viejos tiempos)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>