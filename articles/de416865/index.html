<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ÅâÔ∏è üñïüèø üòå Retro-Design f√ºr die erste tragbare Konsole aus dem fernen 1979 ü§±üèø üßëüèø‚Äçü§ù‚Äçüßëüèº üçï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1974 brachte Texas Instruments die ersten 4-Bit-Mikrocontroller der TMS1000-Familie auf den Markt, und 1976 begann Intel mit der Produktion von 8-Bit-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Retro-Design f√ºr die erste tragbare Konsole aus dem fernen 1979</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416865/"><img src="https://habrastorage.org/webt/41/yf/ic/41yfickhp7ywna9ls3tj4tigy24.jpeg"><br><br>  1974 brachte Texas Instruments die ersten 4-Bit-Mikrocontroller der TMS1000-Familie auf den Markt, und 1976 begann Intel mit der Produktion von 8-Bit-Mikrocontrollern der ber√ºhmten MCS-48-Serie.  Und dann fing es an. <br><a name="habracut"></a><br>  Aufgrund der Billigkeit und Autarkie von Mikrocontrollern (damals wurden sie direkt als Single-Chip-Mikrocomputer bezeichnet) waren Ger√§te der Unterhaltungselektronik deutlich weiser und ihre Zahl wuchs mehr denn je.  Mit dem Aufkommen von Mikrocontrollern, einer Klasse von Ger√§ten wie tragbaren elektronischen Spielen, kann das Ausma√ü der "Katastrophe" unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser Verbindung</a> gesch√§tzt werden.  Unter all diesen fr√ºhen Spielen stach eines hervor, das ich in diesem Beitrag diskutieren werde - dies ist Milton Bradley Microvision, das erste tragbare elektronische Spiel mit austauschbaren Kassetten, bei dem beide oben genannten Mikrocontroller verwendet wurden.  Ich werde auch versuchen, auf die Besonderheiten der Entwicklung dieser Konsole einzugehen. <br><br><h3>  Allgemeine Beschreibung </h3><br> <a href=""><img src="https://habrastorage.org/webt/9_/vz/pz/9_vzpzmfre7fck4ey-suxwkrgna.jpeg"></a> <br><br>  Microvision wurde 1979 vor fast vierzig Jahren in den USA ver√∂ffentlicht.  Insgesamt wurden 12 Kassetten mit Spielen f√ºr sie verkauft, darunter - komplett mit der Block Buster-Konsole (analog zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Breakout</a> ), Sport - Bowling und Baseball, einer elektronischen Version des ber√ºhmten Brettspiels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Connect Four</a> , Pinball und anderen.  Die meisten Spiele k√∂nnen mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MVEM-</a> Emulator ausgewertet werden, der auf der Grundlage einer interessanten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reihe von Ver√∂ffentlichungen erstellt wurde</a> , aus denen ich auch viele n√ºtzliche Dinge gelernt habe.  Hier werde ich nicht n√§her auf die Beschreibung der urspr√ºnglichen Spiele der Konsole eingehen, sondern mich sofort ihrer inneren Welt zuwenden. <br><br> <a href=""><img src="https://habrastorage.org/webt/gr/gu/lb/grgulbct_3jmlu9830qx2upfble.jpeg"></a> <br><br>  Ein wichtiges Merkmal der Konsole ist ein 2-Zoll-LCD mit einer Aufl√∂sung von 16 x 16 Pixel.  Nach heutigen Ma√üst√§ben recht primitiv, aber im Vergleich zu den LED-Baugruppen und Vakuum-Lumineszenz-Anzeigen, die damals in tragbaren Spielen verwendet wurden, war der Matrix-LCD-Bildschirm ein ziemlich fortschrittlicher Schritt.  Zus√§tzlich zu Microvision wurde im selben Jahr eine Reihe von elektronischen Spielen Mego Mini-Vid mit einem √§hnlichen Bildschirm zum Verkauf angeboten, allerdings 13x20.  Anscheinend waren dies zu dieser Zeit die einzigen Ger√§te, die mit Matrix-LCDs einer solchen Aufl√∂sung verkauft wurden. <br><br><img src="https://habrastorage.org/webt/ga/uh/tv/gauhtvjy3-ltagudiptipvvl6lm.jpeg"><br><br>  Das Display wird vom Hughes SCUS0488-Chip gesteuert - dies ist ein Matrix-LCD-Treiber.  Der Treiber wird von einem UA79MG-Negativspannungsstabilisator mit zwei Kondensatoren und Widerst√§nden gespeist, der die einfachste Elementbasis darstellt. <br> <a href=""><img src="https://habrastorage.org/webt/ws/li/pb/wslipbri9usvwd5o8eztgddsnry.jpeg"></a> <br><br>  Im Geh√§use der Konsole befinden sich auch die Bedienelemente - eine 4x3-Tastenmatrix und ein variabler 10kŒ©-Widerstand als Paddel.  F√ºr die Tonwiedergabe gibt es eine Piezodynamik. <br><br>  Das Wichtigste ist, warum Microvision Geschichte geschrieben hat und jeder das oben erw√§hnte Mini-Vid mit austauschbaren Patronen vergessen hat. <br><br> <a href=""><img src="https://habrastorage.org/webt/12/ke/qw/12keqw-kmdbgoo85q50i2yunnjc.jpeg"></a> <br><br>  √Ñu√üerlich war die Patrone ein abnehmbarer oberer Teil des Geh√§uses.  In der Mitte der Patrone befand sich ein Plastikfenster, das den Bildschirm abdeckte und auf dem f√ºr jedes Spiel Farbspielelemente und individuelle Beschriftungen angebracht waren.  Unten befanden sich die L√∂cher f√ºr die Kn√∂pfe, die von einem d√ºnnen Film bedeckt waren, auf den die Signaturen aufgebracht wurden, und f√ºr jedes Spiel wurden L√∂cher nur f√ºr die verwendeten Kn√∂pfe gemacht.  Wahrscheinlich erm√∂glichte diese Anordnung der Kassette laut den Autoren, die Anpassung der Konsole an ein bestimmtes Spiel zu maximieren. <br><br> <a href=""><img src="https://habrastorage.org/webt/ub/od/ou/ubodouuncl6f7az9o4v8n2slwuq.jpeg"></a> <br>  <i>Block Buster Spielbrett, im Koffer und auf der R√ºckseite</i> <br><br>  Der elektronische Teil der Kassette wurde auf einem von zwei Mikrocontrollern aufgebaut - TMS1100 oder Intel 8021 mit dem erforderlichen Kabelbaum.  Das ‚ÄûGehirn‚Äú einer Konsole in eine Kassette zu stecken, mag wie eine seltsame Entscheidung erscheinen, aber Sie konnten nur mit zwei Chips pro Spiel auskommen.  Dar√ºber hinaus wurde die Vielseitigkeit erh√∂ht.  Gleichzeitig stieg der Preis der Patrone, offenbar aufgrund des Vorhandenseins des Mikrocontrollers, nicht wesentlich an (zum Beispiel betrugen die Kosten f√ºr 8021 in gro√üen Losen 1976 etwa 3 USD). <br><br>  All dies speiste eine oder zwei parallel geschaltete Kronen (8021 war ziemlich uners√§ttlich).  Dar√ºber hinaus wurden in sp√§teren Versionen die Kontakte f√ºr die zweite Batterie entfernt, und es wurde empfohlen, den verbleibenden Platz f√ºr eine Ersatzbatterie zu verwenden.  Anscheinend lag dies an der Tatsache, dass Benutzer h√§ufig die Polarit√§t verwechselten und einen ziemlich gef√§hrlichen Kurzschluss erhielten. <br><br><h3>  Krawatte </h3><br>  Ich habe diese alte Konsole gekauft, um eine Art Spiel daf√ºr zu schreiben, eine Kassette herzustellen und wenn m√∂glich die Elementbasis des Originals so weit wie m√∂glich zu kopieren. <br>  Es gibt jedoch ein signifikantes Problem - dass TMS1100, dass Intel 8021 ein maskiertes ROM hatte, d. H.  werkseitig w√§hrend des Herstellungsprozesses programmiert.  F√ºr Intels Mikrocontroller gibt es einen Ausweg: 8021 ist eine abgespeckte Version von 8048, die ebenfalls √ºber ein maskiertes ROM verf√ºgte. Intel produzierte jedoch ein Analogon von 8048 mit einem programmierbaren ROM - 8748, sowohl im Fall der UV-L√∂schung als auch billiger, sobald es programmierbar ist. <br><br>  Leider ist die Situation f√ºr das TMS1100 viel schlimmer - es gab eine Debug-Version des Chips, die mit einem externen ROM funktioniert - TMS1098, aber es ist sehr schwierig, es jetzt zu kaufen, wenn m√∂glich.  Dar√ºber hinaus wurde der Chip im DIP-64-Geh√§use hergestellt. Er ist an sich riesig und passt nicht in die L√§nge der Kassette, es wird jedoch auch ein ziemlich gro√ües ROM ben√∂tigt. <br><br>  Im Allgemeinen ist der UV-l√∂schbare 8748 genau das, was Sie brauchen, und die endg√ºltige Version der Patrone kann auf einer nicht l√∂schbaren Version hergestellt werden. <br><br> <a href=""><img src="https://habrastorage.org/webt/kg/gs/jp/kggsjpioqodpscq5i9orcdp_0im.jpeg"></a> <br>  <i>Oben ist ein einprogrammierbarer P8748H und unten ein UV-l√∂schbarer D8748H</i> <br><br><h3>  Intel 8021 </h3><br>  Unten ist eine kurze Beschreibung von 8021, nicht 8748, weil  Ich werde nur abgeschnittene Funktionen von 8021 verwenden, um nur Ressourcen zu haben, die urspr√ºnglich von den Entwicklern der Konsole festgelegt wurden. <br><br>  Das Speichersubsystem basiert wie die gesamte MCS-48-Familie auf einer modifizierten Harvard-Architektur.  Der Programmspeicher ist ein internes ROM mit 1024 Bytes, der Datenspeicher besteht aus 64 Bytes dynamischem RAM. <br><br>  Die Organisation des Arbeitsspeichers ist in der folgenden Abbildung dargestellt: <br><br><img src="https://habrastorage.org/webt/ak/9m/2y/ak9m2y_m9qmrnnwbj8a8f55slf4.png"><br><br>  Die Zellen 0‚Äì7 belegen direkt adressierte Arbeitsregister R0 - R7, wobei R0 und R1 als Zeiger f√ºr den indirekten Zugriff auf alle RAM-Zellen verwendet werden.  Die Zellen 8-23 werden f√ºr den 8-Ebenen-Aufrufstapel verwendet, obwohl sie auch √ºber R0-R1 verwendet werden k√∂nnen. <br><br>  Der Mikrocontroller verf√ºgt √ºber einen eingebauten Taktgenerator, die Referenzfrequenz wird durch einen externen Quarz, eine RC-Kette oder eine LC-Kette eingestellt.  Ein Maschinenzyklus dauert 10 Zyklen, und jeder Zyklus dauert 3 Perioden der Referenzfrequenz.  Die maximale Frequenz betr√§gt 3,58 MHz, w√§hrend der Maschinenzyklus 8,38 Œºs dauert.  Die Mindestfrequenz ist durch die Besonderheiten des DRAM begrenzt und betr√§gt 600 kHz. <br><br>  8021 enth√§lt zwei 8-Bit-Ports und einen 4-Bit-Port, √ºber den auch ein E / A-Port-Expander, Chip 8243, angeschlossen werden kann. Alle Ports sind quasi bidirektional. <br><br>  Zus√§tzlich verf√ºgt der Mikrocontroller √ºber einen eingebauten achtstelligen Timer / Z√§hler.  Im Timer-Modus wird der Z√§hler T alle 32 Maschinenzyklen um 1 erh√∂ht.  Bei √úberlauf T wird das TF-Flag gesetzt.  Im Z√§hlermodus werden Impulse am Testeingang T1 gez√§hlt. <br><br>  Das Befehlssystem enth√§lt 64 Anweisungen, von denen 36 in einem Zyklus und 28 in zwei ausgef√ºhrt werden.  Die meisten Anweisungen sind Einzelbytes. <br><br><div class="spoiler">  <b class="spoiler_title">Anweisungsliste mit kurzen Beschreibungen</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/dy/lw/hd/dylwhdauhna9z62ivd8z2slns-s.png"><br></div></div><br><h3>  Vorbereitung </h3><br>  Es gab keine Probleme beim Kauf von 8748, die Hauptsache ist, darauf zu achten, dass die Chips mit verschiedenen Technologien hergestellt wurden.  Die fr√ºhesten NMOPs ben√∂tigten eine Spannung von 25 V f√ºr die Firmware mit der Bezeichnung D8748.  Ende der 70er Jahre wurden diese Mikrocontroller mit HMOP-E-Technologie (einer verbesserten Version von Intels NMOP) gebaut, mit D8748H gekennzeichnet und ben√∂tigten bereits 21 V.  Die gleiche Spannung wurde von einem sp√§teren Klon von NEC (mPD8748H) ben√∂tigt.  Die einmalig programmierbare Version wurde mit P8748H bezeichnet. <br><br>  Der UV-Radierer wurde dem einfachsten und billigsten Chinesen mit einem mechanischen Timer gekauft, der, wie die Praxis gezeigt hat, seine Aufgabe perfekt erf√ºllt (obwohl es in kurzen Abst√§nden keine Timergenauigkeit gibt).  Es l√∂scht zuverl√§ssig den ROM von Chips in ~ 2,5 Minuten.  Sp√§ter kaufte ich einen ZAX Quick-EII-Radiergummi f√ºr einen symbolischen Preis von japanischen H√§nden. Ich wei√ü nicht einmal, welches Jahr es ist, wie es Anfang der 90er Jahre aussah.  Es verwendet einen Xenon-Blitz und l√∂scht 8748 buchst√§blich in 3 (!) Sekunden.  Ein Video (nicht meins) mit einer Demonstration der Arbeit ist hier zu sehen. <br><br>  Das Hauptproblem war der Programmierer.  Die Unterst√ºtzung f√ºr diese veraltete Intel-Familie in modernen Programmierern kostet nur 300 US-Dollar.  Es gibt zwar einen relativ billigen Amateur Willem, der mit dem MCS-48 √ºber einen Adapter arbeiten kann, aber er ben√∂tigt LPT, was mir √ºberhaupt nicht zusagte.  Ich musste mich l√∂ten.  Ich bin zum Beispiel ein unerfahrener Funkamateur, also habe ich ungef√§hr eine Woche mit ihm verbracht und einen der beiden 8748, die bis dahin angekommen waren, √ºber Bord geworfen (obwohl ich den Gedanken mag, dass sie urspr√ºnglich so war).  Ich habe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die hier</a> ver√∂ffentlichte Schaltung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">als</a> Grundlage genommen und sie nur f√ºr Atmega und eine bequemere 24-V-Stromversorgung angepasst.  All dies wurde auf ein Steckbrett gel√∂tet: <br><br><img src="https://habrastorage.org/webt/5c/tt/ut/5cttutbzs817thtcpq37vlakkx0.jpeg"><br><br>  Es stellte sich nat√ºrlich als ziemlich h√§sslich heraus, und einer der Mosfets arbeitet bis an die Grenzen (sogar ein wenig f√ºr), aber am Ende hat der Programmierer seine Aufgabe gemeistert und mir gute Dienste geleistet. <br><br>  Also, alles ist fertig, die Test-Firmware blinkt gl√ºcklich mit der LED, es ist Zeit, eine Patrone herzustellen. <br><br><h3>  Patrone </h3><br>  Der Gro√üteil der Patronen funktionierte auf dem TMS1100, weil  Signetics, das die Intel Intel 8021-Lizenz von Intel herausgab, konnte nicht die erforderliche MB-Chipversorgung bereitstellen.  Sogar einige Spiele, die bereits f√ºr 8021 geschrieben wurden, mussten auf das TMS1100 portiert werden.  Dies erm√∂glichte es uns √ºbrigens, das gef√§hrliche B√ºndel von zwei Batterien aufzugeben, da der Verbrauch an TI-Mikrocontrollern bei Intel nur 0,1 W gegen√ºber 1 W betrug.  Ich habe nur eine von 6 Kassetten mit 8021, dies ist das Connect Four-Spiel, und es wurde als Grundlage genommen. <br><br>  Ich habe versucht, das Board so √§hnlich wie m√∂glich zum Original zu machen, aber nat√ºrlich musste ich √Ñnderungen vornehmen.  Erstens die Gr√∂√üe des Chips (DIP-40 gegen√ºber DIP-28) und eine andere Pinbelegung.  Zweitens mussten wir die Nennwerte im Schwingkreis √§ndern, der die Taktfrequenz einstellt, weil  Der Maschinenzyklus f√ºr HMOS-Versionen von Mikroschaltungen betr√§gt 15 Zyklen und f√ºr MOS-Versionen, die in den Originalpatronen verwendet wurden, 30 Zyklen.  Aus Gr√ºnden der vollst√§ndigen Authentizit√§t arbeitet meine Kassette daher mit 1,25 MHz gegen√ºber den urspr√ºnglichen 2,5 MHz und gew√§hrleistet gleichzeitig die gleiche Leistung. <br><br> <a href=""><img src="https://habrastorage.org/webt/bz/9f/zx/bz9fzxh_7-9-djp9yamoeog5tfe.jpeg"></a> <br><br>  Auf dem Foto oben wurden die fertigen Leiterplatten in China bestellt, und w√§hrend sie eingeschaltet waren, habe ich die Leiterplatte gezeichnet und ge√§tzt und einen solchen "Debugging-Komplex" zusammengesetzt: <br> <a href=""><img src="https://habrastorage.org/webt/yh/gx/vn/yhgxvntybge5njn2cw3dppmogrs.jpeg"></a> <br><br>  Schlie√ülich ist der Hardware-Teil fertig und Sie k√∂nnen mit der Programmierung beginnen. <br><br><h3>  Anzeige </h3><br> <a href=""><img src="https://habrastorage.org/webt/wa/g6/jx/wag6jx-tblcypxvqvgmz-pwau_q.jpeg"></a> <br><br>  Zun√§chst musste ich mich mit der Ausgabe auf dem LCD befassen.  Wie ich oben geschrieben habe, wurde es vom Hughes 0488-Treiber mithilfe von Multiplexing gesteuert (k√ºrzlich wurde auf Habr√© ein interessanter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> √ºber diese Art der LCD-Steuerung ver√∂ffentlicht).  Es handelt sich um einen Treiber und nicht um einen Controller. Sie k√∂nnen also nicht nur ein Pixel einschalten und Ihrem Gesch√§ft nachgehen. Sie m√ºssen den Bildschirminhalt st√§ndig mit einer Frequenz von 30 bis 50 Hz mit Low-Level-Befehlen aktualisieren. <br><br>  Das Anschlussdiagramm lautet wie folgt: <br><br> <a href=""><img src="https://habrastorage.org/webt/ul/ym/rg/ulymrgc1oyensrme_-wjhprv2_u.png"></a> <br><br>  Pinbelegung H0488: <br><br>  <b>Vdd</b> - Stromversorgung (3-8V) <br>  <b>R1-R16</b> - String-Steuerausg√§nge <br>  <b>C1-C16</b> - Spaltensteuerungsausg√§nge <br>  <b>DATA0-DATA3</b> - Datenbus <br>  <b>! Data Clk</b> - <b>Datenaufzeichnungstakteingang</b> <br>  <b>Verriegelungsimpuls</b> - Pinbelegungsstatussignal R0-R15, C0-C15 <br><br>  Die Bedeutung des Chips ist wie folgt: <br><br>  √úber 4 Informationsleitungen wird der notwendige Zustand aller 32 Ausg√§nge der Mikroschaltung nacheinander eingestellt (16 pro Zeile und Spalte).  Das hei√üt,  Wir geben in 4-Bit-Abschnitten den Zustand der Ausg√§nge f√ºr die Zeilen 1 bis 4, dann 5 bis 8, 9 bis 12 und schlie√ülich f√ºr 13 bis 16 an. Au√üerdem geben wir viermal in vier Bits den Zustand der Spalten an.  Jedes neue Datenelement wird durch einen Impuls entlang der! DATA CLK-Leitung getaktet.  Nachdem wir alle 8 Daten gesendet haben, setzt ein Impuls auf der Latch Pulse-Leitung den angezeigten Zustand der Ausg√§nge R1-R16, C1-C16, der bis zum n√§chsten Impuls auf dieser Leitung gehalten wird. <br><br>  Nat√ºrlich k√∂nnen wir in einem solchen Zyklus nicht den Zustand jedes einzelnen Pixels unabh√§ngig von den anderen angeben, sondern nur 16 (durch die Anzahl der Schnittpunkte von Zeilen mit Spalten).  Um den Zustand jedes Pixels unabh√§ngig zu aktualisieren, sind daher 256/16 = 16 Zyklen erforderlich. <br><br>  Dar√ºber hinaus sind wir daf√ºr verantwortlich, die Polarit√§t zu √§ndern, um die konstante Spannung der LCD-Elektroden zu beseitigen, da sich sonst die Anzeige schnell verschlechtert.  Die Polarit√§tsumschaltung erfolgt an der Hinterflanke des Signals am Latch Pulse bei einem niedrigen Eingang! Data Clock.  Es wird empfohlen, die Polarit√§t mit der Bildwiederholfrequenz des Bildschirms zu √§ndern. <br><br>  Das Obige wird durch das folgende Zeitdiagramm aus einem Datenblatt veranschaulicht: <br><br><img src="https://habrastorage.org/webt/58/ok/zu/58okzuokeat3bg6nf98bppvxpco.png"><br><br>  All dies, implementiert in Assembler 8021 (was √ºbrigens im Vergleich zum Assembler der √ºbrigen Familie erheblich reduziert ist, alle f√ºr die gleiche Authentizit√§t, die ich nur von 8021 unterst√ºtzte Anweisungen verwendet habe), k√∂nnte ungef√§hr so ‚Äã‚Äãaussehen: <br><br><pre><code class="hljs ruby">mov R<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-comment"><span class="hljs-comment">#32 ;    . mov r1, #10000000b ;    r1-r2 mov r2, #00000000b ;  . mov r4, #00000010b ;    !DATA CLK. mov r3, #11110000b clr c loop: ;   r1-r16   . mov a, r1 ;   r1 loadNibble ;    R1-R4. mov a, r1 ;  4   r1 rrc a ;      , xch a, r1 ;    . swap a loadNibble ;    R5-R8. mov a, r2 ;   r2 loadNibble ;    R9-R12. mov a, r2 ;  4   r2 rrc a ;      ,  xch a, r2 ;  C,     . swap a loadNibble ;    R13-R16 ;   C1-C16     . mov a, </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@R</span></span></span><span class="hljs-comment">0 ;       loadNibble ;       C1-C4. mov a, </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@R</span></span></span><span class="hljs-comment">0 swap a ;   4 . loadNibble ;     C4-C8. inc R0 ;     mov a, </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@R</span></span></span><span class="hljs-comment">0 ;     , loadNibble ;      4 . mov a, </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@R</span></span></span><span class="hljs-comment">0 swap a ;   4 . loadNibble ;     C9-C12. inc R0 ;    inc a ;   R0-R15  C0-C15, outl p1, a ;  Latch Pulse  1. jnc loop ;      . clr a ; outl p1, a ; . inc a ; outl p1, a ; loadNibble macro anl a, r3 ;    . outl p1, a ;   . orl a, r4 outl p1, a ; !DATA CLK. endm</span></span></code> </pre> <br>  Dies ist meine schnellste Version des Unterprogramms, das das im RAM gespeicherte Bild anzeigt.  Es wird in 1152 Maschinenzyklen durchgef√ºhrt (in unserem Fall ~ 12 Œºs). <br><br>  Die maximale Bildwiederholfrequenz des Bildschirms betr√§gt etwa 70 Bilder pro Sekunde (wenn der Mikrocontroller nichts anderes tut), was im Prinzip redundant ist. Um Register und ROMs zu speichern, habe ich in der Praxis andere Unterprogramme verwendet - langsamer und f√ºr bestimmte Aufgaben besser geeignet.  Bei dieser Frequenz ist es jedoch unter Ber√ºcksichtigung der hohen Inertheit dieser Anzeige m√∂glich, Bilder mit 4 Graustufen (wie ein Niblonog auf KPDV) anzuzeigen, wobei sich die Bilder schnell √§ndern.  Oder auch kurze vierfarbige Animationen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jl/9v/1z/jl9v1zg4fi77u_67qendhuxbtt0.gif"></div><br>  Wie Sie sehen, l√§sst der Kontrast zu w√ºnschen √ºbrig. Besonders auff√§llig, wenn alle Zeilen und Spalten betroffen sind, aber nichts zu tun ist - die Kosten f√ºr die Multiplexsteuerung. <br><br><h3>  Tastatur </h3><br> <a href=""><img src="https://habrastorage.org/webt/yh/96/k4/yh96k4mzlmmxlt7bczu5whiozcg.jpeg"></a> <br><br>  Hier ist alles viel einfacher.  Die Schaltfl√§chen sind in einer Matrix aus 4 Zeilen und 3 Spalten zusammengefasst.  Zeilen sind mit den Pins P0.4-P0.7 verbunden, Spalten sind mit P0.0-P0.2 verbunden. <br><br> <a href=""><img src="https://habrastorage.org/webt/zk/2b/cy/zk2bcyshihgdt_h5ygvmxyu4gqw.png"></a> <br><br>  Wie oben erw√§hnt, sind die Ports von 8021 quasi bidirektional. Um den Status der Terminals zu ermitteln, m√ºssen Sie zun√§chst Einheiten an diese senden.  Das hei√üt,  Bei der Dateneingabe tritt eine Verbindung zwischen den Eingangssignalen und dem Inhalt des Puffers auf, die den neuesten am Port angezeigten Daten entspricht.  Eine Tastaturumfrage sieht ungef√§hr so ‚Äã‚Äãaus: <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">mov</span></span> a, <span class="hljs-comment"><span class="hljs-comment">#01111111b ; 0        1, outl p0, a ; ,      . in a, p0 ; , 0       ;     </span></span></code> </pre><br><h3>  Paddeln </h3><br> <a href=""><img src="https://habrastorage.org/webt/4n/ck/j1/4nckj1to9wuxdqnp4qbuzr4zrku.jpeg"></a> <br><br>  Oder auf Russisch ist das im unteren Teil der Konsole installierte Manipulatorrad ein variabler 10-kŒ©-Widerstand mit einem dekorativen Griff, der gedreht werden kann, um etwas im Spiel zu steuern.  Nat√ºrlich gab es weder im 8021 noch im TMS1100 einen ADC.  Der Drehwinkel wurde durch die Ladegeschwindigkeit des Kondensators bestimmt, der vorsichtig auf die Konsolenplatine gel√∂tet wurde. <br><br> <a href=""><img src="https://habrastorage.org/webt/he/kh/k2/hekhk2fa7hrnv1odcm5lxximh7m.png"></a> <br><br>  Es funktioniert alles wie folgt: W√§hrend die Pins P2.2-P2.3 hoch sind, wird der Kondensator entladen und die logische Einheit befindet sich am Testeingang T1.  Nachdem wir P2.2 auf P2.3 auf einen niedrigen Pegel eingestellt haben, beginnt sich der Kondensator aufzuladen, und nach einiger Zeit, exponentiell abh√§ngig vom Widerstand des variablen Widerstands, wird der Spannungsabfall √ºber ihm so, dass T1 auf 0 gesetzt wird. Es bleibt nur die Zeit zu erfassen bis zum Auftreten von Null auf T1, das proportional zum Drehwinkel des Paddels ist (Weitere Details und interessantere Informationen zu solchen Schemata finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DI HALT'a</a> ).  Im Code k√∂nnte dies folgenderma√üen aussehen: <br><br><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">clr</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r1</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">outl</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">p2</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> ; 0  <span class="hljs-selector-tag"><span class="hljs-selector-tag">P2</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.2-P2</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.3</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">loop</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">inc</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r1</span></span> ; <span class="hljs-selector-tag"><span class="hljs-selector-tag">r1</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">jt1</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">loop</span></span> ;  <span class="hljs-selector-tag"><span class="hljs-selector-tag">T1</span></span>  <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#00110000b</span></span> ; 1  <span class="hljs-selector-tag"><span class="hljs-selector-tag">P2</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.2-P2</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.3</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">outl</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">p2</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> ;    </code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ir/2c/1y/ir2c1yukhpzppj3h9jznphe_s-k.gif"></div><br><br><h3>  Ton </h3><br>  Hier ist es ganz einfach, eine Piezodynamik ist mit den beiden Leitungen des Ports P2.0 und P2.1 verbunden. Alles, was wir tun m√ºssen, ist abwechselnd die Beine mit der richtigen Frequenz zu ruckeln. <br><br><h3>  Was ist passiert? </h3><br>  Als Ergebnis schrieb ich zwei Spiele - Tetris und eine Art Flappy Bird.  Zum Debuggen habe ich Intel D8748H und einen Klon von NEC D8749HD verwendet, der sich nur in der ROM-Gr√∂√üe unterscheidet.  Ich habe die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8048 Integrated Development Environment</a> als Assembler und Debugger verwendet.  Dabei habe ich ein unvergessliches Erlebnis bekommen - den st√§ndigen Fluss von Mikrocontrollern von der Konsole zum Radiergummi, vom Radiergummi zum Programmierer und von dort zur√ºck zur Konsole, und all dies wird von einem Krankenhausgeruch nach ionisierter ultravioletter Luft begleitet ... <br><br>  Ich schrieb die fertigen Programme in den einst programmierbaren Intel P8748H, den ich auf die bis dahin eingetroffenen Leiterplatten gel√∂tet hatte. <br><br> <a href=""><img src="https://habrastorage.org/webt/_p/f8/oo/_pf8ool9qniaa7--uotj-o-bx6i.jpeg"></a> <br>  <i>Vergleich mit den Originalplatinen von links nach rechts: Block Buster, Meine Option, Connect Four</i> <br><br>  Ich musste das Original als Fall verwenden, ich hatte nur eine der beiden verf√ºgbaren Kassetten f√ºr das Block Buster-Spiel, die sich als nicht funktionsf√§hig herausstellten. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/9gqDIIBmB2c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Der Rumpf war nicht genug f√ºr das zweite Spiel: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/zir4Owh1Pxc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3>  Fazit </h3><br>  Microvision MB wurde vor 1981 hergestellt, und obwohl die Verk√§ufe zu Beginn recht erfolgreich waren, werden eine kleine Anzahl von Spielen (insgesamt 13 Kassetten wurden ver√∂ffentlicht) und Qualit√§tsprobleme normalerweise als Gr√ºnde f√ºr den Umsatzr√ºckgang bezeichnet.  Ich w√ºrde dem eine √ºberm√§√üig gro√üe Gr√∂√üe hinzuf√ºgen, insbesondere im Vergleich zu der Nintendo Game &amp; Watch-Serie, die damals erschien und ein Hit wurde. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auf GitHub ver√∂ffentlichte</a> Quellcodes und Schemata </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416865/">https://habr.com/ru/post/de416865/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416851/index.html">Ruhezustand - wor√ºber die Tutorials schweigen</a></li>
<li><a href="../de416855/index.html">Bachelor der St. Petersburg State University</a></li>
<li><a href="../de416857/index.html">Wir bauen Tempel - im Code und im Leben. Meine Erfahrung bei der Entwicklung meiner zweiten Android-Anwendung</a></li>
<li><a href="../de416859/index.html">Treffen Sie alle auf einmal React Boilerplate von Maximilian Stoiber v3.6.0</a></li>
<li><a href="../de416863/index.html">Eine neue Art, Aussteller vorzustellen</a></li>
<li><a href="../de416867/index.html">Forscher haben ein Ger√§t f√ºr lokale Angriffe auf SCADA-Systeme entwickelt</a></li>
<li><a href="../de416871/index.html">Ich bin es leid, Zahlungen √ºber WebView zu akzeptieren. Was kann ich tun?</a></li>
<li><a href="../de416877/index.html">Management der Druckinfrastruktur</a></li>
<li><a href="../de416879/index.html">Agiles B√ºro: Wo k√∂nnen Tausende Entwickler gehostet werden?</a></li>
<li><a href="../de416881/index.html">Einf√ºhrung in intelligente Vertr√§ge. Ihr Potenzial und ihre tats√§chlichen Grenzen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>