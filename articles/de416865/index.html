<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⁉️ 🖕🏿 😌 Retro-Design für die erste tragbare Konsole aus dem fernen 1979 🤱🏿 🧑🏿‍🤝‍🧑🏼 🍕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1974 brachte Texas Instruments die ersten 4-Bit-Mikrocontroller der TMS1000-Familie auf den Markt, und 1976 begann Intel mit der Produktion von 8-Bit-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Retro-Design für die erste tragbare Konsole aus dem fernen 1979</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416865/"><img src="https://habrastorage.org/webt/41/yf/ic/41yfickhp7ywna9ls3tj4tigy24.jpeg"><br><br>  1974 brachte Texas Instruments die ersten 4-Bit-Mikrocontroller der TMS1000-Familie auf den Markt, und 1976 begann Intel mit der Produktion von 8-Bit-Mikrocontrollern der berühmten MCS-48-Serie.  Und dann fing es an. <br><a name="habracut"></a><br>  Aufgrund der Billigkeit und Autarkie von Mikrocontrollern (damals wurden sie direkt als Single-Chip-Mikrocomputer bezeichnet) waren Geräte der Unterhaltungselektronik deutlich weiser und ihre Zahl wuchs mehr denn je.  Mit dem Aufkommen von Mikrocontrollern, einer Klasse von Geräten wie tragbaren elektronischen Spielen, kann das Ausmaß der "Katastrophe" unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser Verbindung</a> geschätzt werden.  Unter all diesen frühen Spielen stach eines hervor, das ich in diesem Beitrag diskutieren werde - dies ist Milton Bradley Microvision, das erste tragbare elektronische Spiel mit austauschbaren Kassetten, bei dem beide oben genannten Mikrocontroller verwendet wurden.  Ich werde auch versuchen, auf die Besonderheiten der Entwicklung dieser Konsole einzugehen. <br><br><h3>  Allgemeine Beschreibung </h3><br> <a href=""><img src="https://habrastorage.org/webt/9_/vz/pz/9_vzpzmfre7fck4ey-suxwkrgna.jpeg"></a> <br><br>  Microvision wurde 1979 vor fast vierzig Jahren in den USA veröffentlicht.  Insgesamt wurden 12 Kassetten mit Spielen für sie verkauft, darunter - komplett mit der Block Buster-Konsole (analog zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Breakout</a> ), Sport - Bowling und Baseball, einer elektronischen Version des berühmten Brettspiels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Connect Four</a> , Pinball und anderen.  Die meisten Spiele können mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MVEM-</a> Emulator ausgewertet werden, der auf der Grundlage einer interessanten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reihe von Veröffentlichungen erstellt wurde</a> , aus denen ich auch viele nützliche Dinge gelernt habe.  Hier werde ich nicht näher auf die Beschreibung der ursprünglichen Spiele der Konsole eingehen, sondern mich sofort ihrer inneren Welt zuwenden. <br><br> <a href=""><img src="https://habrastorage.org/webt/gr/gu/lb/grgulbct_3jmlu9830qx2upfble.jpeg"></a> <br><br>  Ein wichtiges Merkmal der Konsole ist ein 2-Zoll-LCD mit einer Auflösung von 16 x 16 Pixel.  Nach heutigen Maßstäben recht primitiv, aber im Vergleich zu den LED-Baugruppen und Vakuum-Lumineszenz-Anzeigen, die damals in tragbaren Spielen verwendet wurden, war der Matrix-LCD-Bildschirm ein ziemlich fortschrittlicher Schritt.  Zusätzlich zu Microvision wurde im selben Jahr eine Reihe von elektronischen Spielen Mego Mini-Vid mit einem ähnlichen Bildschirm zum Verkauf angeboten, allerdings 13x20.  Anscheinend waren dies zu dieser Zeit die einzigen Geräte, die mit Matrix-LCDs einer solchen Auflösung verkauft wurden. <br><br><img src="https://habrastorage.org/webt/ga/uh/tv/gauhtvjy3-ltagudiptipvvl6lm.jpeg"><br><br>  Das Display wird vom Hughes SCUS0488-Chip gesteuert - dies ist ein Matrix-LCD-Treiber.  Der Treiber wird von einem UA79MG-Negativspannungsstabilisator mit zwei Kondensatoren und Widerständen gespeist, der die einfachste Elementbasis darstellt. <br> <a href=""><img src="https://habrastorage.org/webt/ws/li/pb/wslipbri9usvwd5o8eztgddsnry.jpeg"></a> <br><br>  Im Gehäuse der Konsole befinden sich auch die Bedienelemente - eine 4x3-Tastenmatrix und ein variabler 10kΩ-Widerstand als Paddel.  Für die Tonwiedergabe gibt es eine Piezodynamik. <br><br>  Das Wichtigste ist, warum Microvision Geschichte geschrieben hat und jeder das oben erwähnte Mini-Vid mit austauschbaren Patronen vergessen hat. <br><br> <a href=""><img src="https://habrastorage.org/webt/12/ke/qw/12keqw-kmdbgoo85q50i2yunnjc.jpeg"></a> <br><br>  Äußerlich war die Patrone ein abnehmbarer oberer Teil des Gehäuses.  In der Mitte der Patrone befand sich ein Plastikfenster, das den Bildschirm abdeckte und auf dem für jedes Spiel Farbspielelemente und individuelle Beschriftungen angebracht waren.  Unten befanden sich die Löcher für die Knöpfe, die von einem dünnen Film bedeckt waren, auf den die Signaturen aufgebracht wurden, und für jedes Spiel wurden Löcher nur für die verwendeten Knöpfe gemacht.  Wahrscheinlich ermöglichte diese Anordnung der Kassette laut den Autoren, die Anpassung der Konsole an ein bestimmtes Spiel zu maximieren. <br><br> <a href=""><img src="https://habrastorage.org/webt/ub/od/ou/ubodouuncl6f7az9o4v8n2slwuq.jpeg"></a> <br>  <i>Block Buster Spielbrett, im Koffer und auf der Rückseite</i> <br><br>  Der elektronische Teil der Kassette wurde auf einem von zwei Mikrocontrollern aufgebaut - TMS1100 oder Intel 8021 mit dem erforderlichen Kabelbaum.  Das „Gehirn“ einer Konsole in eine Kassette zu stecken, mag wie eine seltsame Entscheidung erscheinen, aber Sie konnten nur mit zwei Chips pro Spiel auskommen.  Darüber hinaus wurde die Vielseitigkeit erhöht.  Gleichzeitig stieg der Preis der Patrone, offenbar aufgrund des Vorhandenseins des Mikrocontrollers, nicht wesentlich an (zum Beispiel betrugen die Kosten für 8021 in großen Losen 1976 etwa 3 USD). <br><br>  All dies speiste eine oder zwei parallel geschaltete Kronen (8021 war ziemlich unersättlich).  Darüber hinaus wurden in späteren Versionen die Kontakte für die zweite Batterie entfernt, und es wurde empfohlen, den verbleibenden Platz für eine Ersatzbatterie zu verwenden.  Anscheinend lag dies an der Tatsache, dass Benutzer häufig die Polarität verwechselten und einen ziemlich gefährlichen Kurzschluss erhielten. <br><br><h3>  Krawatte </h3><br>  Ich habe diese alte Konsole gekauft, um eine Art Spiel dafür zu schreiben, eine Kassette herzustellen und wenn möglich die Elementbasis des Originals so weit wie möglich zu kopieren. <br>  Es gibt jedoch ein signifikantes Problem - dass TMS1100, dass Intel 8021 ein maskiertes ROM hatte, d. H.  werkseitig während des Herstellungsprozesses programmiert.  Für Intels Mikrocontroller gibt es einen Ausweg: 8021 ist eine abgespeckte Version von 8048, die ebenfalls über ein maskiertes ROM verfügte. Intel produzierte jedoch ein Analogon von 8048 mit einem programmierbaren ROM - 8748, sowohl im Fall der UV-Löschung als auch billiger, sobald es programmierbar ist. <br><br>  Leider ist die Situation für das TMS1100 viel schlimmer - es gab eine Debug-Version des Chips, die mit einem externen ROM funktioniert - TMS1098, aber es ist sehr schwierig, es jetzt zu kaufen, wenn möglich.  Darüber hinaus wurde der Chip im DIP-64-Gehäuse hergestellt. Er ist an sich riesig und passt nicht in die Länge der Kassette, es wird jedoch auch ein ziemlich großes ROM benötigt. <br><br>  Im Allgemeinen ist der UV-löschbare 8748 genau das, was Sie brauchen, und die endgültige Version der Patrone kann auf einer nicht löschbaren Version hergestellt werden. <br><br> <a href=""><img src="https://habrastorage.org/webt/kg/gs/jp/kggsjpioqodpscq5i9orcdp_0im.jpeg"></a> <br>  <i>Oben ist ein einprogrammierbarer P8748H und unten ein UV-löschbarer D8748H</i> <br><br><h3>  Intel 8021 </h3><br>  Unten ist eine kurze Beschreibung von 8021, nicht 8748, weil  Ich werde nur abgeschnittene Funktionen von 8021 verwenden, um nur Ressourcen zu haben, die ursprünglich von den Entwicklern der Konsole festgelegt wurden. <br><br>  Das Speichersubsystem basiert wie die gesamte MCS-48-Familie auf einer modifizierten Harvard-Architektur.  Der Programmspeicher ist ein internes ROM mit 1024 Bytes, der Datenspeicher besteht aus 64 Bytes dynamischem RAM. <br><br>  Die Organisation des Arbeitsspeichers ist in der folgenden Abbildung dargestellt: <br><br><img src="https://habrastorage.org/webt/ak/9m/2y/ak9m2y_m9qmrnnwbj8a8f55slf4.png"><br><br>  Die Zellen 0–7 belegen direkt adressierte Arbeitsregister R0 - R7, wobei R0 und R1 als Zeiger für den indirekten Zugriff auf alle RAM-Zellen verwendet werden.  Die Zellen 8-23 werden für den 8-Ebenen-Aufrufstapel verwendet, obwohl sie auch über R0-R1 verwendet werden können. <br><br>  Der Mikrocontroller verfügt über einen eingebauten Taktgenerator, die Referenzfrequenz wird durch einen externen Quarz, eine RC-Kette oder eine LC-Kette eingestellt.  Ein Maschinenzyklus dauert 10 Zyklen, und jeder Zyklus dauert 3 Perioden der Referenzfrequenz.  Die maximale Frequenz beträgt 3,58 MHz, während der Maschinenzyklus 8,38 μs dauert.  Die Mindestfrequenz ist durch die Besonderheiten des DRAM begrenzt und beträgt 600 kHz. <br><br>  8021 enthält zwei 8-Bit-Ports und einen 4-Bit-Port, über den auch ein E / A-Port-Expander, Chip 8243, angeschlossen werden kann. Alle Ports sind quasi bidirektional. <br><br>  Zusätzlich verfügt der Mikrocontroller über einen eingebauten achtstelligen Timer / Zähler.  Im Timer-Modus wird der Zähler T alle 32 Maschinenzyklen um 1 erhöht.  Bei Überlauf T wird das TF-Flag gesetzt.  Im Zählermodus werden Impulse am Testeingang T1 gezählt. <br><br>  Das Befehlssystem enthält 64 Anweisungen, von denen 36 in einem Zyklus und 28 in zwei ausgeführt werden.  Die meisten Anweisungen sind Einzelbytes. <br><br><div class="spoiler">  <b class="spoiler_title">Anweisungsliste mit kurzen Beschreibungen</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/dy/lw/hd/dylwhdauhna9z62ivd8z2slns-s.png"><br></div></div><br><h3>  Vorbereitung </h3><br>  Es gab keine Probleme beim Kauf von 8748, die Hauptsache ist, darauf zu achten, dass die Chips mit verschiedenen Technologien hergestellt wurden.  Die frühesten NMOPs benötigten eine Spannung von 25 V für die Firmware mit der Bezeichnung D8748.  Ende der 70er Jahre wurden diese Mikrocontroller mit HMOP-E-Technologie (einer verbesserten Version von Intels NMOP) gebaut, mit D8748H gekennzeichnet und benötigten bereits 21 V.  Die gleiche Spannung wurde von einem späteren Klon von NEC (mPD8748H) benötigt.  Die einmalig programmierbare Version wurde mit P8748H bezeichnet. <br><br>  Der UV-Radierer wurde dem einfachsten und billigsten Chinesen mit einem mechanischen Timer gekauft, der, wie die Praxis gezeigt hat, seine Aufgabe perfekt erfüllt (obwohl es in kurzen Abständen keine Timergenauigkeit gibt).  Es löscht zuverlässig den ROM von Chips in ~ 2,5 Minuten.  Später kaufte ich einen ZAX Quick-EII-Radiergummi für einen symbolischen Preis von japanischen Händen. Ich weiß nicht einmal, welches Jahr es ist, wie es Anfang der 90er Jahre aussah.  Es verwendet einen Xenon-Blitz und löscht 8748 buchstäblich in 3 (!) Sekunden.  Ein Video (nicht meins) mit einer Demonstration der Arbeit ist hier zu sehen. <br><br>  Das Hauptproblem war der Programmierer.  Die Unterstützung für diese veraltete Intel-Familie in modernen Programmierern kostet nur 300 US-Dollar.  Es gibt zwar einen relativ billigen Amateur Willem, der mit dem MCS-48 über einen Adapter arbeiten kann, aber er benötigt LPT, was mir überhaupt nicht zusagte.  Ich musste mich löten.  Ich bin zum Beispiel ein unerfahrener Funkamateur, also habe ich ungefähr eine Woche mit ihm verbracht und einen der beiden 8748, die bis dahin angekommen waren, über Bord geworfen (obwohl ich den Gedanken mag, dass sie ursprünglich so war).  Ich habe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die hier</a> veröffentlichte Schaltung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">als</a> Grundlage genommen und sie nur für Atmega und eine bequemere 24-V-Stromversorgung angepasst.  All dies wurde auf ein Steckbrett gelötet: <br><br><img src="https://habrastorage.org/webt/5c/tt/ut/5cttutbzs817thtcpq37vlakkx0.jpeg"><br><br>  Es stellte sich natürlich als ziemlich hässlich heraus, und einer der Mosfets arbeitet bis an die Grenzen (sogar ein wenig für), aber am Ende hat der Programmierer seine Aufgabe gemeistert und mir gute Dienste geleistet. <br><br>  Also, alles ist fertig, die Test-Firmware blinkt glücklich mit der LED, es ist Zeit, eine Patrone herzustellen. <br><br><h3>  Patrone </h3><br>  Der Großteil der Patronen funktionierte auf dem TMS1100, weil  Signetics, das die Intel Intel 8021-Lizenz von Intel herausgab, konnte nicht die erforderliche MB-Chipversorgung bereitstellen.  Sogar einige Spiele, die bereits für 8021 geschrieben wurden, mussten auf das TMS1100 portiert werden.  Dies ermöglichte es uns übrigens, das gefährliche Bündel von zwei Batterien aufzugeben, da der Verbrauch an TI-Mikrocontrollern bei Intel nur 0,1 W gegenüber 1 W betrug.  Ich habe nur eine von 6 Kassetten mit 8021, dies ist das Connect Four-Spiel, und es wurde als Grundlage genommen. <br><br>  Ich habe versucht, das Board so ähnlich wie möglich zum Original zu machen, aber natürlich musste ich Änderungen vornehmen.  Erstens die Größe des Chips (DIP-40 gegenüber DIP-28) und eine andere Pinbelegung.  Zweitens mussten wir die Nennwerte im Schwingkreis ändern, der die Taktfrequenz einstellt, weil  Der Maschinenzyklus für HMOS-Versionen von Mikroschaltungen beträgt 15 Zyklen und für MOS-Versionen, die in den Originalpatronen verwendet wurden, 30 Zyklen.  Aus Gründen der vollständigen Authentizität arbeitet meine Kassette daher mit 1,25 MHz gegenüber den ursprünglichen 2,5 MHz und gewährleistet gleichzeitig die gleiche Leistung. <br><br> <a href=""><img src="https://habrastorage.org/webt/bz/9f/zx/bz9fzxh_7-9-djp9yamoeog5tfe.jpeg"></a> <br><br>  Auf dem Foto oben wurden die fertigen Leiterplatten in China bestellt, und während sie eingeschaltet waren, habe ich die Leiterplatte gezeichnet und geätzt und einen solchen "Debugging-Komplex" zusammengesetzt: <br> <a href=""><img src="https://habrastorage.org/webt/yh/gx/vn/yhgxvntybge5njn2cw3dppmogrs.jpeg"></a> <br><br>  Schließlich ist der Hardware-Teil fertig und Sie können mit der Programmierung beginnen. <br><br><h3>  Anzeige </h3><br> <a href=""><img src="https://habrastorage.org/webt/wa/g6/jx/wag6jx-tblcypxvqvgmz-pwau_q.jpeg"></a> <br><br>  Zunächst musste ich mich mit der Ausgabe auf dem LCD befassen.  Wie ich oben geschrieben habe, wurde es vom Hughes 0488-Treiber mithilfe von Multiplexing gesteuert (kürzlich wurde auf Habré ein interessanter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> über diese Art der LCD-Steuerung veröffentlicht).  Es handelt sich um einen Treiber und nicht um einen Controller. Sie können also nicht nur ein Pixel einschalten und Ihrem Geschäft nachgehen. Sie müssen den Bildschirminhalt ständig mit einer Frequenz von 30 bis 50 Hz mit Low-Level-Befehlen aktualisieren. <br><br>  Das Anschlussdiagramm lautet wie folgt: <br><br> <a href=""><img src="https://habrastorage.org/webt/ul/ym/rg/ulymrgc1oyensrme_-wjhprv2_u.png"></a> <br><br>  Pinbelegung H0488: <br><br>  <b>Vdd</b> - Stromversorgung (3-8V) <br>  <b>R1-R16</b> - String-Steuerausgänge <br>  <b>C1-C16</b> - Spaltensteuerungsausgänge <br>  <b>DATA0-DATA3</b> - Datenbus <br>  <b>! Data Clk</b> - <b>Datenaufzeichnungstakteingang</b> <br>  <b>Verriegelungsimpuls</b> - Pinbelegungsstatussignal R0-R15, C0-C15 <br><br>  Die Bedeutung des Chips ist wie folgt: <br><br>  Über 4 Informationsleitungen wird der notwendige Zustand aller 32 Ausgänge der Mikroschaltung nacheinander eingestellt (16 pro Zeile und Spalte).  Das heißt,  Wir geben in 4-Bit-Abschnitten den Zustand der Ausgänge für die Zeilen 1 bis 4, dann 5 bis 8, 9 bis 12 und schließlich für 13 bis 16 an. Außerdem geben wir viermal in vier Bits den Zustand der Spalten an.  Jedes neue Datenelement wird durch einen Impuls entlang der! DATA CLK-Leitung getaktet.  Nachdem wir alle 8 Daten gesendet haben, setzt ein Impuls auf der Latch Pulse-Leitung den angezeigten Zustand der Ausgänge R1-R16, C1-C16, der bis zum nächsten Impuls auf dieser Leitung gehalten wird. <br><br>  Natürlich können wir in einem solchen Zyklus nicht den Zustand jedes einzelnen Pixels unabhängig von den anderen angeben, sondern nur 16 (durch die Anzahl der Schnittpunkte von Zeilen mit Spalten).  Um den Zustand jedes Pixels unabhängig zu aktualisieren, sind daher 256/16 = 16 Zyklen erforderlich. <br><br>  Darüber hinaus sind wir dafür verantwortlich, die Polarität zu ändern, um die konstante Spannung der LCD-Elektroden zu beseitigen, da sich sonst die Anzeige schnell verschlechtert.  Die Polaritätsumschaltung erfolgt an der Hinterflanke des Signals am Latch Pulse bei einem niedrigen Eingang! Data Clock.  Es wird empfohlen, die Polarität mit der Bildwiederholfrequenz des Bildschirms zu ändern. <br><br>  Das Obige wird durch das folgende Zeitdiagramm aus einem Datenblatt veranschaulicht: <br><br><img src="https://habrastorage.org/webt/58/ok/zu/58okzuokeat3bg6nf98bppvxpco.png"><br><br>  All dies, implementiert in Assembler 8021 (was übrigens im Vergleich zum Assembler der übrigen Familie erheblich reduziert ist, alle für die gleiche Authentizität, die ich nur von 8021 unterstützte Anweisungen verwendet habe), könnte ungefähr so ​​aussehen: <br><br><pre><code class="hljs ruby">mov R<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-comment"><span class="hljs-comment">#32 ;    . mov r1, #10000000b ;    r1-r2 mov r2, #00000000b ;  . mov r4, #00000010b ;    !DATA CLK. mov r3, #11110000b clr c loop: ;   r1-r16   . mov a, r1 ;   r1 loadNibble ;    R1-R4. mov a, r1 ;  4   r1 rrc a ;      , xch a, r1 ;    . swap a loadNibble ;    R5-R8. mov a, r2 ;   r2 loadNibble ;    R9-R12. mov a, r2 ;  4   r2 rrc a ;      ,  xch a, r2 ;  C,     . swap a loadNibble ;    R13-R16 ;   C1-C16     . mov a, </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@R</span></span></span><span class="hljs-comment">0 ;       loadNibble ;       C1-C4. mov a, </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@R</span></span></span><span class="hljs-comment">0 swap a ;   4 . loadNibble ;     C4-C8. inc R0 ;     mov a, </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@R</span></span></span><span class="hljs-comment">0 ;     , loadNibble ;      4 . mov a, </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@R</span></span></span><span class="hljs-comment">0 swap a ;   4 . loadNibble ;     C9-C12. inc R0 ;    inc a ;   R0-R15  C0-C15, outl p1, a ;  Latch Pulse  1. jnc loop ;      . clr a ; outl p1, a ; . inc a ; outl p1, a ; loadNibble macro anl a, r3 ;    . outl p1, a ;   . orl a, r4 outl p1, a ; !DATA CLK. endm</span></span></code> </pre> <br>  Dies ist meine schnellste Version des Unterprogramms, das das im RAM gespeicherte Bild anzeigt.  Es wird in 1152 Maschinenzyklen durchgeführt (in unserem Fall ~ 12 μs). <br><br>  Die maximale Bildwiederholfrequenz des Bildschirms beträgt etwa 70 Bilder pro Sekunde (wenn der Mikrocontroller nichts anderes tut), was im Prinzip redundant ist. Um Register und ROMs zu speichern, habe ich in der Praxis andere Unterprogramme verwendet - langsamer und für bestimmte Aufgaben besser geeignet.  Bei dieser Frequenz ist es jedoch unter Berücksichtigung der hohen Inertheit dieser Anzeige möglich, Bilder mit 4 Graustufen (wie ein Niblonog auf KPDV) anzuzeigen, wobei sich die Bilder schnell ändern.  Oder auch kurze vierfarbige Animationen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jl/9v/1z/jl9v1zg4fi77u_67qendhuxbtt0.gif"></div><br>  Wie Sie sehen, lässt der Kontrast zu wünschen übrig. Besonders auffällig, wenn alle Zeilen und Spalten betroffen sind, aber nichts zu tun ist - die Kosten für die Multiplexsteuerung. <br><br><h3>  Tastatur </h3><br> <a href=""><img src="https://habrastorage.org/webt/yh/96/k4/yh96k4mzlmmxlt7bczu5whiozcg.jpeg"></a> <br><br>  Hier ist alles viel einfacher.  Die Schaltflächen sind in einer Matrix aus 4 Zeilen und 3 Spalten zusammengefasst.  Zeilen sind mit den Pins P0.4-P0.7 verbunden, Spalten sind mit P0.0-P0.2 verbunden. <br><br> <a href=""><img src="https://habrastorage.org/webt/zk/2b/cy/zk2bcyshihgdt_h5ygvmxyu4gqw.png"></a> <br><br>  Wie oben erwähnt, sind die Ports von 8021 quasi bidirektional. Um den Status der Terminals zu ermitteln, müssen Sie zunächst Einheiten an diese senden.  Das heißt,  Bei der Dateneingabe tritt eine Verbindung zwischen den Eingangssignalen und dem Inhalt des Puffers auf, die den neuesten am Port angezeigten Daten entspricht.  Eine Tastaturumfrage sieht ungefähr so ​​aus: <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">mov</span></span> a, <span class="hljs-comment"><span class="hljs-comment">#01111111b ; 0        1, outl p0, a ; ,      . in a, p0 ; , 0       ;     </span></span></code> </pre><br><h3>  Paddeln </h3><br> <a href=""><img src="https://habrastorage.org/webt/4n/ck/j1/4nckj1to9wuxdqnp4qbuzr4zrku.jpeg"></a> <br><br>  Oder auf Russisch ist das im unteren Teil der Konsole installierte Manipulatorrad ein variabler 10-kΩ-Widerstand mit einem dekorativen Griff, der gedreht werden kann, um etwas im Spiel zu steuern.  Natürlich gab es weder im 8021 noch im TMS1100 einen ADC.  Der Drehwinkel wurde durch die Ladegeschwindigkeit des Kondensators bestimmt, der vorsichtig auf die Konsolenplatine gelötet wurde. <br><br> <a href=""><img src="https://habrastorage.org/webt/he/kh/k2/hekhk2fa7hrnv1odcm5lxximh7m.png"></a> <br><br>  Es funktioniert alles wie folgt: Während die Pins P2.2-P2.3 hoch sind, wird der Kondensator entladen und die logische Einheit befindet sich am Testeingang T1.  Nachdem wir P2.2 auf P2.3 auf einen niedrigen Pegel eingestellt haben, beginnt sich der Kondensator aufzuladen, und nach einiger Zeit, exponentiell abhängig vom Widerstand des variablen Widerstands, wird der Spannungsabfall über ihm so, dass T1 auf 0 gesetzt wird. Es bleibt nur die Zeit zu erfassen bis zum Auftreten von Null auf T1, das proportional zum Drehwinkel des Paddels ist (Weitere Details und interessantere Informationen zu solchen Schemata finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DI HALT'a</a> ).  Im Code könnte dies folgendermaßen aussehen: <br><br><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">clr</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r1</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">outl</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">p2</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> ; 0  <span class="hljs-selector-tag"><span class="hljs-selector-tag">P2</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.2-P2</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.3</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">loop</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">inc</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r1</span></span> ; <span class="hljs-selector-tag"><span class="hljs-selector-tag">r1</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">jt1</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">loop</span></span> ;  <span class="hljs-selector-tag"><span class="hljs-selector-tag">T1</span></span>  <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#00110000b</span></span> ; 1  <span class="hljs-selector-tag"><span class="hljs-selector-tag">P2</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.2-P2</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.3</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">outl</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">p2</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> ;    </code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ir/2c/1y/ir2c1yukhpzppj3h9jznphe_s-k.gif"></div><br><br><h3>  Ton </h3><br>  Hier ist es ganz einfach, eine Piezodynamik ist mit den beiden Leitungen des Ports P2.0 und P2.1 verbunden. Alles, was wir tun müssen, ist abwechselnd die Beine mit der richtigen Frequenz zu ruckeln. <br><br><h3>  Was ist passiert? </h3><br>  Als Ergebnis schrieb ich zwei Spiele - Tetris und eine Art Flappy Bird.  Zum Debuggen habe ich Intel D8748H und einen Klon von NEC D8749HD verwendet, der sich nur in der ROM-Größe unterscheidet.  Ich habe die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8048 Integrated Development Environment</a> als Assembler und Debugger verwendet.  Dabei habe ich ein unvergessliches Erlebnis bekommen - den ständigen Fluss von Mikrocontrollern von der Konsole zum Radiergummi, vom Radiergummi zum Programmierer und von dort zurück zur Konsole, und all dies wird von einem Krankenhausgeruch nach ionisierter ultravioletter Luft begleitet ... <br><br>  Ich schrieb die fertigen Programme in den einst programmierbaren Intel P8748H, den ich auf die bis dahin eingetroffenen Leiterplatten gelötet hatte. <br><br> <a href=""><img src="https://habrastorage.org/webt/_p/f8/oo/_pf8ool9qniaa7--uotj-o-bx6i.jpeg"></a> <br>  <i>Vergleich mit den Originalplatinen von links nach rechts: Block Buster, Meine Option, Connect Four</i> <br><br>  Ich musste das Original als Fall verwenden, ich hatte nur eine der beiden verfügbaren Kassetten für das Block Buster-Spiel, die sich als nicht funktionsfähig herausstellten. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/9gqDIIBmB2c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Der Rumpf war nicht genug für das zweite Spiel: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/zir4Owh1Pxc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3>  Fazit </h3><br>  Microvision MB wurde vor 1981 hergestellt, und obwohl die Verkäufe zu Beginn recht erfolgreich waren, werden eine kleine Anzahl von Spielen (insgesamt 13 Kassetten wurden veröffentlicht) und Qualitätsprobleme normalerweise als Gründe für den Umsatzrückgang bezeichnet.  Ich würde dem eine übermäßig große Größe hinzufügen, insbesondere im Vergleich zu der Nintendo Game &amp; Watch-Serie, die damals erschien und ein Hit wurde. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auf GitHub veröffentlichte</a> Quellcodes und Schemata </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416865/">https://habr.com/ru/post/de416865/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416851/index.html">Ruhezustand - worüber die Tutorials schweigen</a></li>
<li><a href="../de416855/index.html">Bachelor der St. Petersburg State University</a></li>
<li><a href="../de416857/index.html">Wir bauen Tempel - im Code und im Leben. Meine Erfahrung bei der Entwicklung meiner zweiten Android-Anwendung</a></li>
<li><a href="../de416859/index.html">Treffen Sie alle auf einmal React Boilerplate von Maximilian Stoiber v3.6.0</a></li>
<li><a href="../de416863/index.html">Eine neue Art, Aussteller vorzustellen</a></li>
<li><a href="../de416867/index.html">Forscher haben ein Gerät für lokale Angriffe auf SCADA-Systeme entwickelt</a></li>
<li><a href="../de416871/index.html">Ich bin es leid, Zahlungen über WebView zu akzeptieren. Was kann ich tun?</a></li>
<li><a href="../de416877/index.html">Management der Druckinfrastruktur</a></li>
<li><a href="../de416879/index.html">Agiles Büro: Wo können Tausende Entwickler gehostet werden?</a></li>
<li><a href="../de416881/index.html">Einführung in intelligente Verträge. Ihr Potenzial und ihre tatsächlichen Grenzen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>