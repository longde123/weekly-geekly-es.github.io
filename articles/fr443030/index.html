<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ¥ üëåüèª üëÉüèΩ Profilage de m√©moire le plus simple sur STM32 et autres microcontr√¥leurs üë©‚Äçüé§ üàÇÔ∏è üë©üèø‚Äçüéì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Avec l'exp√©rience, une approche scientifique standard pour calculer la bonne taille de pile vient: prendre un nombre al√©atoire et esp√©rer le meilleur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Profilage de m√©moire le plus simple sur STM32 et autres microcontr√¥leurs</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443030/"> <i>"Avec l'exp√©rience, une approche scientifique standard pour calculer la bonne taille de pile vient: prendre un nombre al√©atoire et esp√©rer le meilleur."</i> <i><br></i>  <i>- Jack Ganssle, ¬´L'art de concevoir des syst√®mes embarqu√©s¬ª</i> <br><br>  Bonjour, Habr! <br><br>  Aussi √©trange que cela puisse para√Ætre, dans la grande majorit√© des ¬´amorces STM32¬ª que j'ai vues en particulier et des microcontr√¥leurs en g√©n√©ral, il n'y a g√©n√©ralement rien de tel que l'allocation de m√©moire, le placement de la pile et, plus important encore, la pr√©vention du d√©bordement de m√©moire - √† la suite de quoi une zone en frise une autre et tout s'√©croule, g√©n√©ralement avec des effets enchanteurs. <br><br>  Cela est d√ª en partie √† la simplicit√© des projets de formation effectu√©s sur des cartes de d√©bogage avec des microcontr√¥leurs relativement gras, o√π il est difficile de survivre √† une p√©nurie de m√©moire en faisant clignoter une LED - cependant, r√©cemment, m√™me pour les amateurs d√©butants, les r√©f√©rences, par exemple, aux contr√¥leurs de type STM32F030F4P6 sont de plus en plus courantes. , facile √† installer, vaut un sou, mais aussi avec une unit√© de m√©moire de kilo-octets. <br><br>  De tels contr√¥leurs vous permettent de faire des choses assez graves pour vous-m√™me (eh bien, ici, par exemple, une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mesure aussi parfaitement adapt√©e a √©t√©</a> faite pour nous sur STM32F042K6T6 avec 6 Ko de RAM, dont un peu plus de 100 octets restent libres), mais lorsque vous traitez avec de la m√©moire, vous avez besoin d'une certaine quantit√© de m√©moire nettet√©. <br><br>  Je veux parler de cette pr√©cision.  L'article sera court, les professionnels n'apprendront rien de nouveau - mais pour les d√©butants cette connaissance est fortement recommand√©e. <br><br><a name="habracut"></a>  Dans un projet typique sur un microcontr√¥leur bas√© sur un noyau Cortex-M, la RAM a une division conditionnelle en quatre sections: <br><br><ul><li>  data - donn√©es initialis√©es par une valeur sp√©cifique </li><li>  bss - donn√©es initialis√©es √† z√©ro </li><li>  tas - tas (zone dynamique √† partir de laquelle la m√©moire est allou√©e explicitement √† l'aide de malloc) </li><li>  stack - la pile (la r√©gion dynamique √† partir de laquelle la m√©moire est allou√©e par le compilateur implicitement) </li></ul><br>  La zone noinit peut √©galement appara√Ætre occasionnellement (variables non initialis√©es - elles sont pratiques en ce qu'elles conservent la valeur entre les red√©marrages), encore moins souvent, certaines autres zones allou√©es pour des t√¢ches sp√©cifiques. <br><br>  Ils sont situ√©s dans la m√©moire physique d'une mani√®re assez sp√©cifique - le fait est que la pile des microcontr√¥leurs sur les c≈ìurs ARM cro√Æt de haut en bas.  Par cons√©quent, il est situ√© s√©par√©ment des blocs de m√©moire restants, √† la fin de la RAM: <br><br><img src="https://habrastorage.org/webt/so/mq/xc/somqxc24t6u7_f2ol0baenjtoqi.jpeg"><br><br>  Par d√©faut, son adresse est g√©n√©ralement √©gale √† la derni√®re adresse RAM, et √† partir de l√†, elle descend √† mesure qu'elle grandit - et une caract√©ristique extr√™mement d√©sagr√©able de la pile en sort: elle peut atteindre bss et r√©√©crire son sommet, et vous ne le saurez pas de mani√®re explicite. <br><br><h4>  Zones de m√©moire statiques et dynamiques </h4><br>  Toute la m√©moire est divis√©e en deux cat√©gories - allou√©es statiquement, c'est-√†-dire  m√©moire dont le montant total est √©vident d'apr√®s le texte du programme et ne d√©pend pas de l'ordre de son ex√©cution, et allou√© dynamiquement, dont le volume requis d√©pend de l'avancement du programme. <br><br>  Ce dernier comprend un tas (√† partir duquel nous prenons des morceaux en utilisant malloc et retournons en utilisant free) et une pile qui grandit et se r√©tr√©cit d'elle-m√™me. <br><br>  De mani√®re g√©n√©rale, l'utilisation de malloc sur les microcontr√¥leurs est <b>fortement d√©conseill√©e,</b> sauf si vous savez exactement ce que vous faites.  Le principal probl√®me qu'ils apportent est la fragmentation de la m√©moire - si vous allouez 10 morceaux de 10 octets, puis les lib√©rez toutes les secondes, vous n'obtiendrez pas 50 octets gratuits.  Vous obtiendrez 5 pi√®ces gratuites de 10 octets chacune. <br><br>  De plus, au stade de la compilation du programme, le compilateur ne sera pas en mesure de d√©terminer automatiquement la quantit√© de m√©moire dont votre malloc aura besoin (en particulier en tenant compte de la fragmentation, qui d√©pend non seulement de la taille des pi√®ces demand√©es, mais de la s√©quence de leur allocation et de leur lib√©ration), et ne pourra donc pas vous avertir si √† la fin il n'y a pas assez de m√©moire. <br><br>  Il existe des m√©thodes pour contourner ce probl√®me - impl√©mentations sp√©ciales de malloc qui fonctionnent dans une zone allou√©e statiquement, et non toute la RAM, utilisation prudente de malloc en tenant compte de la fragmentation possible au niveau de la logique du programme, etc.  - mais en g√©n√©ral <b>malloc vaut mieux ne pas toucher</b> . <br><br>  Toutes les zones de m√©moire avec des limites et des adresses sont enregistr√©es dans un fichier avec l'extension .LD, sur lequel l'√©diteur de liens est orient√© lors de la construction du projet. <br><br><h4>  M√©moire allou√©e statiquement </h4><br>  Ainsi, √† partir de la m√©moire allou√©e statiquement, nous avons deux zones - bss et data, qui ne diff√®rent que formellement.  Lorsque le syst√®me est initialis√©, le bloc de donn√©es est copi√© √† partir du flash, o√π les valeurs d'initialisation n√©cessaires sont stock√©es pour lui, le bloc bss est simplement rempli de z√©ros (au moins le remplir de z√©ros est consid√©r√© comme une bonne forme). <br><br>  Les deux choses - copier √† partir d'un flash et remplir de z√©ros - sont effectu√©es dans le code du programme <i>sous une forme explicite</i> , mais pas dans votre main (), mais dans un fichier s√©par√© qui est ex√©cut√© en premier, il est √©crit une fois et simplement gliss√© de projet en projet. <br><br>  Cependant, ce n'est pas ce qui nous int√©resse maintenant - mais comment nous comprendrons si nos donn√©es s'ins√®rent m√™me dans la RAM de notre contr√¥leur. <br><br>  Il est reconnu tr√®s simplement - par l'utilitaire arm-none-eabi-size avec un seul param√®tre - le fichier ELF compil√© de notre programme (souvent son appel est ins√©r√© √† la fin du Makefile, car c'est pratique): <br><br><img src="https://habrastorage.org/webt/sz/nh/kg/sznhkgwspg27prcbdikvnkzv98c.png"><br><br>  Ici, le texte est la quantit√© de donn√©es de programme se trouvant dans le flash, et bss et les donn√©es sont nos zones allou√©es statiquement dans la RAM.  Les deux derni√®res colonnes ne nous d√©rangent pas - c'est la somme des trois premi√®res, elle n'a pas de sens pratique. <br><br>  Au total, statiquement dans la RAM, nous avons besoin de bss + octets de donn√©es, dans ce cas - 5324 octets.  Le contr√¥leur dispose de 6144 octets de RAM, nous n'utilisons pas de malloc, il reste 820 octets. <br><br>  Ce qui devrait nous suffire sur la pile. <br><br>  Mais assez?  Parce que sinon, notre pile se d√©veloppera en nos propres donn√©es, puis elle √©crasera d'abord les donn√©es, puis les donn√©es les √©craseront, et ensuite tout plantera.  De plus, entre le premier et le deuxi√®me point, le programme peut continuer √† fonctionner sans se rendre compte qu'il y a des ordures dans les donn√©es qu'il traite.  Dans le pire des cas, ce seront les donn√©es que vous avez not√©es lorsque tout √©tait en ordre avec la pile, et maintenant vous venez de lire - par exemple, les param√®tres d'√©talonnage d'un capteur - et alors vous n'avez aucun moyen √©vident de comprendre que tout va mal avec eux, Ce programme continuera de fonctionner, comme si rien ne s'√©tait pass√©, vous donnant des ordures √† la sortie. <br><br><h4>  M√©moire allou√©e dynamiquement </h4><br>  Et ici commence la partie la plus int√©ressante - si vous r√©duisez le r√©cit √† une phrase, il <i>est presque impossible de d√©terminer √† l'avance la taille de la pile</i> . <br><br>  <i>Th√©oriquement</i> , vous pouvez demander au compilateur de vous donner la taille de pile utilis√©e par chaque fonction individuelle, puis lui demander de renvoyer l'arbre d'ex√©cution de votre programme, et pour chaque branche de celui-ci, calculer la somme des piles de toutes les fonctions pr√©sentes dans cet arbre.  Cela seul pour tout programme plus ou moins complexe vous prendra beaucoup de temps. <br><br>  Ensuite, vous vous souvenez qu'√† tout moment une interruption peut se produire, dont le processeur a √©galement besoin de m√©moire. <br><br>  Ensuite - que deux ou trois interruptions imbriqu√©es peuvent se produire, dont les gestionnaires ... <br><br>  En g√©n√©ral, vous comprenez.  Essayer de compter la pile pour un programme sp√©cifique est une activit√© passionnante et g√©n√©ralement utile, mais souvent vous ne le ferez pas. <br><br>  Par cons√©quent, dans la pratique, une technique est utilis√©e qui vous permet de comprendre au moins en quelque sorte si tout dans notre vie se d√©veloppe bien - ce qu'on appelle la ¬´peinture de m√©moire¬ª (peinture de m√©moire). <br><br>  Ce qui est pratique dans cette m√©thode, c'est qu'elle ne d√©pend pas des outils de d√©bogage que vous utilisez, et si le syst√®me a au moins un moyen de sortie d'informations, vous pouvez vous passer du tout des outils de d√©bogage. <br><br>  Son essence est que nous remplissions le tableau entier de la fin de bss au d√©but de la pile quelque part au tout d√©but de l'ex√©cution du programme, lorsque la pile est encore exactement petite, avec la m√™me valeur. <br><br>  De plus, en v√©rifiant √† quelle adresse cette valeur a d√©j√† disparu, nous comprenons o√π la pile est tomb√©e.  Puisqu'une fois que la couleur effac√©e elle-m√™me ne sera pas restaur√©e, la v√©rification peut √™tre effectu√©e sporadiquement - elle montrera la taille maximale de pile atteinte. <br><br>  D√©finissez la couleur de la peinture - la valeur sp√©cifique n'a pas d'importance, en dessous je tape juste avec deux doigts de ma main gauche.  L'essentiel n'est pas de choisir 0 et FF: <br><br><pre><code class="cpp">#define STACK_CANARY_WORD (0xCACACACAUL)</code></pre><br>
 -  ,    -,      :<br>
<br>
<pre><code class="cpp">volatile unsigned *top, *start;
__asm__ volatile ("mov %[top], sp" : [top] "=r" (top) : : );
start = &amp;_ebss;
while (start &lt; top) {
    *(start++) = STACK_CANARY_WORD;
}</code></pre><br>
   ?     top ,     ‚Äî&nbsp;    ;   start ‚Äî&nbsp;   bss (,    ,  <a href="">    *.ld</a> ‚Äî       libopencm3).        bss        .<br>
<br>
        :<br>
<br>
<pre><code class="cpp">unsigned check_stack_size(void) {
    /* top of data section */
    unsigned *addr = &amp;_ebss;

    /* look for the canary word till the end of RAM */
    while ((addr &lt; &amp;_stack) &amp;&amp; (*addr == STACK_CANARY_WORD)) {
        addr++;
    }
    
    return ((unsigned)&amp;_stack - (unsigned)addr);
}</code></pre><br>
  _ebss   ,   _stack ‚Äî&nbsp; <a href="">   </a>,       ,  ,   ,   .<br>
<br>
        .<br>
<br>
    ‚Äî -      check_stack_size()      ,        ,        ,    .<br>
<br>
    .<br>
<br>
            712  ‚Äî      6          108 .<br>
<br>
<h4>Word of caution</h4><br>
     ‚Äî , ,   100-% .    ,  <i> </i>  , , ,   ,      . ,          ,       -,       10-20 %,      108         .<br>
<br>
     ,              ,                ,            .<br>
<br>
P.S.     RTOS      ‚Äî    MSP,      ,     PSP.     ,          ‚Äî        .</div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr443030/">https://habr.com/ru/post/fr443030/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr443020/index.html">Mon premier jeu vid√©o et celui de ma copine. D√©veloppement avec Unity. Partie 1</a></li>
<li><a href="../fr443022/index.html">Rosserial & STM32</a></li>
<li><a href="../fr443024/index.html">ITMO University Digest: 12 conf√©rences th√©matiques, hackathons et cours MOOC pour les √©tudiants en informatique</a></li>
<li><a href="../fr443026/index.html">Contr√¥le d'acc√®s et avec quoi il est mang√©</a></li>
<li><a href="../fr443028/index.html">√âv√©nements num√©riques √† Moscou du 11 au 17 mars</a></li>
<li><a href="../fr443032/index.html">Composants Web dans le monde r√©el</a></li>
<li><a href="../fr443034/index.html">Nouvelles bornes de recharge Tesla: chargez la batterie sur 120 kilom√®tres en 5 minutes</a></li>
<li><a href="../fr443038/index.html">Si la superglue entre en contact avec les yeux</a></li>
<li><a href="../fr443040/index.html">7 principales raisons pour lesquelles les applications sont bloqu√©es sur Google Play et AppStore</a></li>
<li><a href="../fr443042/index.html">Lancement de 619 mille tetris sur GLSL, leur rendu et un simple bot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>