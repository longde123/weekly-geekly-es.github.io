<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍⚖️ ◾️ 🏕️ AI und 2048. Teil 2: Minimax + Alpha Beta Clipping 👵 🧖🏽 🤑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir haben die Monte-Carlo-Methode untersucht . Heute werden wir sehen, wie der Computergeist im Jahr 2048 mit dem guten alten Minimax mit Alpha-Beta-C...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>AI und 2048. Teil 2: Minimax + Alpha Beta Clipping</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/474680/"><div style="text-align:center;"><img width="690" height="314" src="https://habrastorage.org/webt/9t/ym/10/9tym105d327kylbfpejz4inkdxu.png"></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wir haben die Monte-Carlo-Methode untersucht</a> . Heute werden wir sehen, wie der Computergeist im Jahr 2048 mit dem guten alten Minimax mit Alpha-Beta-Clipping spielt. <a name="habracut"></a><br><br><blockquote> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="EDISON Software - Webentwicklung"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISON Software - Webentwicklung"></a> <br clear="right">  Der Artikel wurde mit Unterstützung von EDISON verfasst, einem Unternehmen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das mobile Anwendungen entwickelt</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Software-Testdienste anbietet</a> . </blockquote><br>  Vom Benutzer-Stackoverflow ausspionierte Lösung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img width="14" height="14" src="https://habrastorage.org/webt/7c/q2/x_/7cq2x_1w7otpr1ksh4yryg83h4c.jpeg"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ovolve</a> , der in der Diskussion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">feststellte</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wie man AI das Spiel 2048 beibringt</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Kommentarübersetzung von ovolve</b> <div class="spoiler_text">  Ich bin der Autor des in diesem Thread erwähnten Programms.  Sie können die KI <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in Aktion sehen</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Code sehen</a> . <br><br>  Gegenwärtig gewinnt das Programm in etwa 90% der Fälle, indem es Java-Skripte in einem Browser auf meinem Laptop ausführt. Dabei werden 100 Millisekunden benötigt, um über den Kurs nachzudenken. Es funktioniert zwar nicht perfekt, aber ziemlich gut. <br><br>  Da das Spiel ein diskreter Zustandsraum mit vollständigen Informationen ist und tatsächlich ein rundenbasiertes Spiel wie Schach und Dame ist, habe ich die gleichen Methoden verwendet, die ihre Leistung in diesen Spielen zeigten, nämlich die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Minimax-Suche</a> mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alpha-Beta-Clipping</a> .  Da die Links viele Informationen zu diesem Algorithmus enthalten, werde ich nur auf die beiden wichtigsten Heuristiken eingehen, die ich in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der statischen Schätzfunktion verwendet habe,</a> und viele der intuitiven Annahmen formalisieren, die andere Personen hier getroffen haben. <br><br><img align="right" width="344" height="343" src="https://habrastorage.org/webt/hm/s0/cu/hms0cuvsvpeyvyvozxm-3f88xui.png"><br clear="left"><h3>  Monotonie </h3><br>  Diese Heuristik versucht sicherzustellen, dass alle Kachelwerte links / rechts und oben / unten entweder erhöht oder verringert werden.  Diese Heuristik allein spiegelt die Vermutung wider, dass viele andere erwähnt haben, dass wertvollere Kacheln in einer Ecke gruppiert werden sollten.  Dies verhindert in der Regel die Ansammlung von weniger wertvollen Kacheln und hält das Spielfeld organisiert, da kleinere Kacheln in größere übergehen. <br><br>  Hier ist ein Screenshot eines komplett eintönigen Gitters.  Ich habe diese Situation durch Ausführen eines Algorithmus mit der installierten Auswertungsfunktion erhalten, um andere Heuristiken zu ignorieren und nur Monotonie zu berücksichtigen. <br><br><img align="right" width="342" height="343" src="https://habrastorage.org/webt/iq/wp/4p/iqwp4pn8rsoynb1u6eknm99gmt8.png"><br clear="left"><h3>  Glätte (Glätte, Ebenheit) </h3><br>  Die obige Heuristik an sich neigt dazu, Strukturen zu erzeugen, in denen benachbarte Zellen an Wert verlieren, aber natürlich sollten Nachbarn die gleiche Bedeutung haben, um sie zu kombinieren.  Daher misst die Heuristik der Glätte einfach die Wertdifferenz zwischen benachbarten Kacheln und versucht, deren Anzahl zu minimieren. <br><br>  Ein Kommentator von Hacker News lieferte eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">interessante</a> graphentheoretische <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Formalisierung</a> dieser Idee. <br><br><div class="spoiler">  <b class="spoiler_title">Übersetzung der Formalisierung mit Hacker News</b> <div class="spoiler_text"><blockquote>  Gestern habe ich dieses Spiel einem Kollegen gezeigt, einem Liebhaber der Graphentheorie, und wir haben uns auch entschlossen, darüber nachzudenken, wie wir dieses Spiel mit KI lösen können. <br><br>  Die einfachste Lösung ist Minimax, die meiner Meinung nach ziemlich gut implementiert ist.  Wenn jemand hier nicht mit minimax vertraut ist, hat OP sehr eleganten und gut kommentierten Code geschrieben, der ein großartiges Tutorial wäre. <br><br>  Der weniger rechenintensive Ansatz, den wir vorgeschlagen haben, bestand darin, den Spielzustand in Form eines Graphen <b>G (V, E)</b> zu modellieren, wobei <b>V</b> eine Menge von aktiven Kacheln und <b>E</b> eine Menge von Kanten ist, die benachbarte Kacheln verbinden, gewichtet nach Funktion <b>c (v1, v2)</b> , die den absoluten Wert der Differenz zwischen den beiden Kacheln zurückgibt.  Für jede Lösung wählt die KI einen Zug, der die Summe der Gewichte aller Kanten im neuen Spielzustand minimiert. <br><br>  Der Grund dafür ist, dass der einzige Weg, um Fortschritte im Spiel zu erzielen, darin besteht, Kacheln mit denselben Werten nebeneinander zu haben, für die das Gewicht in <b>G</b> 0 beträgt. Daher sollte die KI versuchen, das Gesamtgewicht zu minimieren.  Am Ende befindet sich eine große Anzahl an Brettern mit einem großen Gewicht an Kanten zu benachbarten Kacheln. Die KI wird daher versuchen, diese Kacheln neben anderen großen Kacheln zu belassen, um den Unterschied zu minimieren. <br><br>  Da das Spiel stochastisch ist, funktioniert der von mir beschriebene Ansatz möglicherweise nicht im schlimmsten Fall, kann aber auch als Gewichtsfunktion für jeden Knoten im Baum auf die vorhandene Minimax-Lösung angewendet werden. </blockquote></div></div><br><br>  Hier ist ein Screenshot eines perfekt glatten Netzes, freundlicherweise zur Verfügung gestellt von dieser exzellenten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20140315093348/">Scheingabel</a> .  <i>(Link zum Webarchiv, während Java-Skripte auf der Seite funktionieren und Sie die Tastatur verwenden können, um eine Bewegung in eine beliebige Richtung auszuführen - Anmerkung des Übersetzers).</i> <br><br><h3>  Lose Fliesen </h3><br>  Und schließlich gibt es eine Strafe für zu wenig freie Steine, da die Optionen schnell enden können, wenn das Spielfeld zu eng wird. <br><br>  Und das ist alles!  Das Durchsuchen des Spielraums bei gleichzeitiger Optimierung dieser Kriterien bietet eine überraschend gute Leistung.  Einer der Vorteile eines solchen generischen Ansatzes anstelle einer explizit codierten Verschiebestrategie besteht darin, dass der Algorithmus häufig interessante und unerwartete Lösungen findet.  Wenn Sie seinen Fortschritt beobachten, macht er oft erstaunliche, aber effektive Bewegungen, wie zum Beispiel den plötzlichen Wechsel von Wänden oder Ecken, in deren Nähe er sein Spiel baut. <br><br><img align="right" width="345" height="499" src="https://habrastorage.org/webt/tc/oi/hz/tcoihzahmdqlw9cxthywpapiwsa.png"><br clear="left"><h3>  Kleine Änderung </h3><br>  Der Screenshot zeigt die Leistungsfähigkeit dieses Ansatzes.  Ich habe das Kachellimit entfernt (damit sie nach Erreichen von 2048 weiter wachsen), und hier ist das beste Ergebnis nach acht Tests. <br><br>  Ja, das ist 4096 zusammen mit 2048. =) Dies bedeutet, dass er das schwer fassbare 2048-Plättchen auf einem Brett erreicht hat. </div></div><br><hr><hr><hr><hr><hr><br>  Java-Script-Code für minimax mit Alpha-Beta-Clipping und statischer Auswertungsfunktion aus dem Stackoverflow-User-Ovolve ist unten im Artikel angegeben. <br><br>  Die Minimax-Methode ist mehreren ausgezeichneten Habr-Artikeln gewidmet, daher lassen wir die akademische detaillierte Erklärung dessen, woraus sie besteht, weg.  Für diejenigen, <strike>die erst kürzlich der IT-Community beigetreten sind, haben</strike> sie die schönen Begriffe "Minimax" und "Alpha-Beta-Cut-Off" gehört, aber sie wissen nicht, was dies bedeutet. Versuchen wir, in ein paar Absätzen buchstäblich die allgemeinste Bedeutung zu erklären. <br><br><h2>  Minimax </h2><br>  In einigen Spielen kann der Prozess eines Spiels zwischen zwei Spielern (die nacheinander einen Zug machen) als sogenannter Optionsbaum dargestellt werden.  In jeder bestimmten Position hat jeder Spieler normalerweise die Wahl zwischen verschiedenen Optionen für seinen Zug.  Und als Reaktion auf jede dieser Optionen kann ein Gegner auch in vielerlei Hinsicht ähnlich sein. <br><br><div style="text-align:center;"><img width="690" height="525" src="https://habrastorage.org/webt/xi/ye/j2/xiyej2z5e4n-kigoscjrgfpf2i8.png"></div><br>  <sup><em>Fragment eines Baumes von Optionen</em></sup> <br><br>  Da zu jedem Zeitpunkt des Spiels vollständige Informationen über den Zustand des Spielfelds vorliegen, kann der aktuelle Zustand der Position immer genau geschätzt werden.  Eine solche Funktion wird als <strong>statische Bewertungsfunktion</strong> oder abgekürzter <strong>SFO bezeichnet</strong> .  Je wichtiger diese Funktion bei der Bewertung einer bestimmten Position ist, desto vorteilhafter ist außerdem die Position für einen Spieler (nennen wir sie den <strong>maximierenden Spieler</strong> ).  Je kleiner der numerische Wert dieser Funktion bei der Auswertung einer Position ist, desto vorteilhafter ist die Position für den zweiten Spieler (nennen wir es den <strong>minimierenden Spieler</strong> ). <br><br>  Nach jedem Zug ändert sich die Position und damit auch die Punktzahl.  Bei der Betrachtung des Optionsbaums muss jeder Spieler nicht nur die Zweige bevorzugen, in denen die Bewertung für ihn am günstigsten ist.  Sie sollten auch solche Zweige vermeiden, in denen die Bewertung der Position für den Gegner günstig ist. <br><br>  Es wird davon ausgegangen, dass der Gegner sich auch von Rationalismus leiten lässt und auch Optionen vermeidet, die ihn zum Verlieren führen könnten.  Das heißt, jeder Spieler maximiert bei der Auswahl einer Option seinen eigenen Nutzen und minimiert gleichzeitig den Gewinn des Gegners. <br><br>  Das ist Minimax. <br><br><h2>  Alpha Beta Ausschnitt </h2><br>  Es liegt auf der Hand: Wer einen Baum von einer bestimmten Position bis zu einer größeren Tiefe berechnet, hat mehr Gewinnchancen.  Aber es gibt ein Ärgernis: Der Baum der Optionen in Spielen hat die unangenehme Angewohnheit, sich mit jeder Verschachtelungsebene zu verzweigen und exponentiell zu wachsen.  Die Zählfähigkeiten von Programmen und vor allem die der Menschen sind begrenzt, das Zählen "bis zur Matte" ist bei weitem nicht immer möglich.  Es kann sich leicht herausstellen, dass der Spieler zu einer Position gezählt hat, bei der er eine gute Einschätzung des Spielfelds hat, aber auf der nächsten (unlesbaren) Ebene hat der Gegner buchstäblich die Möglichkeit, einen solchen Zug zu machen, der die Positionsschätzung grundlegend zum Gegenteil ändert. <br><br>  Wer ist schuld und was zu tun?  Der Rechenaufwand ist für die vollständige Durchquerung der Bäume verantwortlich, und es wird vorgeschlagen, unnötige Äste abzuschneiden, um zu kämpfen.  Wenn der Spieler, der die Position bewertet, einen Zweig des Optionsbaums sieht: <br><br>  oder weniger rentabel als andere Branchen, die bereits analysiert wurden, <br>  oder vorteilhafter für den Gegner als andere Zweige, die bereits analysiert wurden, <br><br>  dann wirft der Spieler diesen Zweig ab, verschwendet keine Zeit und Ressourcen damit, Unteroptionen aus diesem offensichtlich schlechteren Zweig für ihn in Betracht zu ziehen. <br><br>  Auf diese Weise können Sie mehr Rechenressourcen für die Berechnung günstigerer Verzweigungen einer größeren Rendering-Tiefe im Optionsbaum zuweisen.  Bei der Bewertung des Spielfelds auf verschiedenen Ebenen des Optionsbaums arbeitet der Spieler mit zwei sich dynamisch ändernden Koeffizienten - <strong>Alpha</strong> (der Wert des SFD, der im Zweig minimal angetroffen wird - d. H. Für den minimierenden Spieler günstiger) und <strong>Beta</strong> (der Wert des SFD, der im Zweig am häufigsten angetroffen wird - d. H. günstiger für den maximierenden Spieler).  Wenn Sie die SFD der aktuellen Position mit den <em>Alpha</em> und <em>Beta</em> Koeffizienten vergleichen, können Sie auf jeder Ebene Zweige fegen (ohne sie vollständig zu berechnen), die für den Spieler, der die Position bewertet, <em>ungünstiger</em> und / oder für seinen Gegner <em>vorteilhafter sind</em> . <br><br>  Dies ist Alpha-Beta-Clipping. <br><br><h3>  Rekursive Minimax-Funktion mit Alpha-Beta-Clipping </h3><br><div class="spoiler">  <b class="spoiler_title">2048 mit AI ist als Excel-Anwendung mit VBA-Makros implementiert. So sieht der Minimax-Algorithmus mit Alpha-Beta-Clipping wie eine verabscheuungswürdige visuelle Basis aus.</b> <div class="spoiler_text"><pre><code class="vbscript hljs"><span class="hljs-comment"><span class="hljs-comment">''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' '''''''''''''''''''''''( - )''''''''''''''''''''''''' ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' '       -- 'Position -  4  4     'Depth - ,    'Alpha, Beta -         'MaximisingPlayer -      ? Private Function MiniMaxAlpaBeta_Evaluation(Position As Variant, Depth As Long, _ Alpha As Double, Beta As Double, _ MaximisingPlayer As Boolean, _ Optional MainLevel As Boolean = False) As Double Dim MaxEval As Double '  Dim MinEval As Double '  Dim PositionNext As Variant '     Dim PositionTemp As Variant '     Dim Eval As Double '   Dim Way As Long '   -      Dim Row As Long '     Dim Col As Long '     Dim TileNew As Long '      '   (  ,  '     ) If GameOverPosition(Position) Then '    ? '     MiniMaxAlpaBeta_Evaluation = -1000000 + TileMax(Position) '         ElseIf Depth = 0 Then '     MiniMaxAlpaBeta_Evaluation = StaticEvaluation(Position) '  ,    '     () ElseIf MaximisingPlayer Then MaxEval = -1000000 '      For Way = 1 To 4 ' 4   - (, , , ) ChangeCount = 0 ' ,      ',       PositionNext = StepHuman(Position, Way) If ChangeCount &gt; 0 Then '     '      , '    () Eval = MiniMaxAlpaBeta_Evaluation(PositionNext, Depth - 1, _ Alpha, Beta, False) If Eval &gt; MaxEval Then MaxEval = Eval '  '     If Eval &gt; Alpha Then Alpha = Eval '    ,   '   -    If Beta &gt; Alpha Then Exit For End If Next '          MiniMaxAlpaBeta_Evaluation = MaxEval '  ,    '     () Else 'Not MaximisingPlayer MinEval = 1000000 '      For Row = 1 To 4 '     For Col = 1 To 4 '     If Position(Row, Col) = 0 Then '   For TileNew = 2 To 4 Step 2 '    2  4 ',       '    PositionNext = StepComp(Position, Row, Col, TileNew) '     , '    () Eval = MiniMaxAlpaBeta_Evaluation(PositionNext, Depth - 1, _ Alpha, Beta, True) If Eval &lt; MinEval Then MinEval = Eval '  '     If Eval &lt; Beta Then Beta = Eval '    ,   '   -    If Alpha &lt; Beta Then Exit For Next End If Next Next '          MiniMaxAlpaBeta_Evaluation = MinEval End If End Function</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Ovolve Code in Java-Skript</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AI</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">grid</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.grid = grid; } <span class="hljs-comment"><span class="hljs-comment">//   () AI.prototype.eval = function() { var emptyCells = this.grid.availableCells().length; var smoothWeight = 0.1, //monoWeight = 0.0, //islandWeight = 0.0, mono2Weight = 1.0, emptyWeight = 2.7, maxWeight = 1.0; return this.grid.smoothness() * smoothWeight //+ this.grid.monotonicity() * monoWeight //- this.grid.islands() * islandWeight + this.grid.monotonicity2() * mono2Weight + Math.log(emptyCells) * emptyWeight + this.grid.maxValue() * maxWeight; }; // alpha-beta depth first search AI.prototype.search = function(depth, alpha, beta, positions, cutoffs) { var bestScore; var bestMove = -1; var result; // the maxing player if (this.grid.playerTurn) { bestScore = alpha; for (var direction in [0, 1, 2, 3]) { var newGrid = this.grid.clone(); if (newGrid.move(direction).moved) { positions++; if (newGrid.isWin()) { return { move: direction, score: 10000, positions: positions, cutoffs: cutoffs }; } var newAI = new AI(newGrid); if (depth == 0) { result = { move: direction, score: newAI.eval() }; } else { result = newAI.search(depth-1, bestScore, beta, positions, cutoffs); if (result.score &gt; 9900) { // win result.score--; // to slightly penalize higher depth from win } positions = result.positions; cutoffs = result.cutoffs; } if (result.score &gt; bestScore) { bestScore = result.score; bestMove = direction; } if (bestScore &gt; beta) { cutoffs++ return { move: bestMove, score: beta, positions: positions, cutoffs: cutoffs }; } } } } else { // computer's turn, we'll do heavy pruning to keep the branching factor low bestScore = beta; // try a 2 and 4 in each cell and measure how annoying it is // with metrics from eval var candidates = []; var cells = this.grid.availableCells(); var scores = { 2: [], 4: [] }; for (var value in scores) { for (var i in cells) { scores[value].push(null); var cell = cells[i]; var tile = new Tile(cell, parseInt(value, 10)); this.grid.insertTile(tile); scores[value][i] = -this.grid.smoothness() + this.grid.islands(); this.grid.removeTile(cell); } } // now just pick out the most annoying moves var maxScore = Math.max(Math.max.apply(null, scores[2]), Math.max.apply(null, scores[4])); for (var value in scores) { // 2 and 4 for (var i=0; i&lt;scores[value].length; i++) { if (scores[value][i] == maxScore) { candidates.push( { position: cells[i], value: parseInt(value, 10) } ); } } } // search on each candidate for (var i=0; i&lt;candidates.length; i++) { var position = candidates[i].position; var value = candidates[i].value; var newGrid = this.grid.clone(); var tile = new Tile(position, value); newGrid.insertTile(tile); newGrid.playerTurn = true; positions++; newAI = new AI(newGrid); result = newAI.search(depth, alpha, bestScore, positions, cutoffs); positions = result.positions; cutoffs = result.cutoffs; if (result.score &lt; bestScore) { bestScore = result.score; } if (bestScore &lt; alpha) { cutoffs++; return { move: null, score: alpha, positions: positions, cutoffs: cutoffs }; } } } return { move: bestMove, score: bestScore, positions: positions, cutoffs: cutoffs }; } // performs a search and returns the best move AI.prototype.getBest = function() { return this.iterativeDeep(); } // performs iterative deepening over the alpha-beta search AI.prototype.iterativeDeep = function() { var start = (new Date()).getTime(); var depth = 0; var best; do { var newBest = this.search(depth, -10000, 10000, 0 ,0); if (newBest.move == -1) { break; } else { best = newBest; } depth++; } while ( (new Date()).getTime() - start &lt; minSearchTime); return best } AI.prototype.translate = function(move) { return { 0: 'up', 1: 'right', 2: 'down', 3: 'left' }[move]; }</span></span></code> </pre> </div></div><br><h2>  Statische Auswertungsfunktion </h2><br>  Da Sie auf jeder Ebene im Optionsbaum das Spielfeld bewerten müssen (um zu entscheiden, für welchen der Spieler die geschätzte Position tatsächlich vorteilhafter ist), müssen Sie entscheiden, welche Kriterien eine gute von einer schlechten Position unterscheiden. <br><br>  Wir gehen davon aus, dass der maximierende Spieler die Person (oder KI) ist, die entscheidet, in welche der vier Richtungen (oben, links, rechts, unten) alle Steine ​​verschoben werden.  Ein minimierender Spieler ist diese heimtückische Unterroutine, die zufällig 2 oder 4 an den unangemessensten Stellen generiert. <br><br>  SFO wird aus der Sicht eines maximierenden Spielers zusammengestellt.  Je höher die SFD-Bewertung für das Spielfeld ist, desto besser ist die Position für den „Maximalisten“.  Je niedriger - desto angenehmer ist die Position auf dem Brett für den "Minimalisten". <br><br>  Im Fall von 2048 - welche Faktoren werden für denjenigen als günstig angesehen, der die Kacheln bewegt? <br><br><h3>  Monotonie </h3><img align="right" width="388" height="189" src="https://habrastorage.org/webt/r8/jc/qt/r8jcqtbvrsyvrfwwsmeedgfrzrg.png"><br clear="left">  Erstens ist es wünschenswert, dass die Kacheln in aufsteigender / absteigender Reihenfolge in einigen Richtungen angeordnet sind.  Wenn dies nicht erfolgt, wird das Spielfeld beim Generieren neuer Kacheln schnell durch zufällig angeordnete Kacheln unterschiedlicher Größe verstopft, die nicht sofort normal miteinander verbunden werden können. <br><br>  Im Sibirischen Bundesdistrikt müssen Sie in alle vier Richtungen schauen (von oben nach unten, von links nach rechts, von rechts nach links, von unten nach oben) und berechnen, wo die Kacheln eine abnehmende oder zunehmende Progression aufweisen.  Wenn es im Laufe der Zeit Kacheln gibt, die nicht in die allgemeine Reihe passen, verringert dies den numerischen Monotoniekoeffizienten.  Dann wird aus den 4 Koeffizienten für alle Richtungen der beste ausgewählt, der im Gesamtwert des Sibirischen Bundesdistrikts berücksichtigt wird. <br><br><h3>  Glätte </h3><img align="right" width="387" height="189" src="https://habrastorage.org/webt/uw/mq/wh/uwmqwht6dm82fc_zptwwdqdar2c.png"><br clear="left">  Darüber hinaus wäre es vorzuziehen, wenn der Fortschritt vom Stehen in einer Reihe von Kacheln nicht nur zunimmt, sondern nicht abnimmt (oder statt der Reihe zu verringern, ist es vorzuziehen, nicht zuzunehmen), das heißt, es ist gut, wenn dieselben Kacheln in der Nähe sind, was es ihnen ermöglicht, zu einer zusammenzufallen, Punkte zu gewinnen und Erhöhung des freien Platzes auf dem Spielfeld. <br><br>  Daher sucht der Sibirische Bundesdistrikt auf dem Spielfeld nach denselben benachbarten Kacheln und berücksichtigt die Anzahl solcher Paare in einem speziellen Koeffizienten. <br><br><h3>  Leere Zellen </h3><img align="right" width="387" height="193" src="https://habrastorage.org/webt/qj/as/ay/qjasayisfgowdqcciifm0igt3ru.png"><br clear="left">  Je mehr Freiraum vorhanden ist, desto mehr Spielraum ist vorhanden und desto geringer ist die Wahrscheinlichkeit, schnell zu verlieren. <br><br>  SFO betrachtet leere Zellen auf dem Spielfeld und je mehr davon, desto profitabler wird die Position für den maximierenden Spieler. <br><br><h3>  Maximale Kachel </h3><br>  Da die Hauptsache in diesem Spiel darin besteht, ein großes Plättchen auf das Spielfeld zu bringen, sollten die Optionen, bei denen der maximale Plättchenwert höher ist, als das rentabelste SFD angesehen werden, je mehr desto besser - 2048, 4096, 8192 (oder was auch immer Sie die Stärke und Geduld dafür haben). <br><br><h3>  Sibirischer Bundesdistrikt für 2048 </h3><br><div class="spoiler">  <b class="spoiler_title">Implementierung des Sibirischen Bundesdistrikts als VBA-Makro</b> <div class="spoiler_text"><pre> <code class="vbscript hljs"><span class="hljs-comment"><span class="hljs-comment">''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' '''''''''''''''''''''''  '''''''''''''''''''''''' ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' '     'Position -  4  4     Private Function StaticEvaluation(Position As Variant) As Double Dim Smoothness As Double ' Dim Monotonicity As Double ' Dim EmptyCount As Double '  Dim MaxValue As Long '  '   Const SmoothWeight = 0.1 Const MonoWeight = 1 Const EmptyWeight = 2.7 Const MaxWeight = 1 Dim k As Long '   Dim i As Long '  Dim j As Long '  Dim x As Long '  Dim y As Long '  ' Dim Value As Double '       '         Dim TargetValue As Double Smoothness = 0 '    For i = 1 To 4 '     For j = 1 To 4 '     If Position(i, j) &gt; 0 Then '   Value = Log(Position(i, j)) / Log(2) If i &lt; 4 Then '       For x = i + 1 To 4 '    If Position(x, j) &gt; 0 Then '    '    TargetValue = Log(Position(x, j)) / Log(2) ',   Smoothness = Abs(Value - TargetValue) '       Exit For End If Next End If If j &lt; 4 Then '       For y = j + 1 To 4 '    If Position(i, y) &gt; 0 Then '    '    TargetValue = Log(Position(i, y)) / Log(2) ',   Smoothness = Abs(Value - TargetValue) '        Exit For End If Next End If End If Next Next ' Dim arrTotals(1 To 4) As Double '     Dim Current As Long '   Dim Next_ As Long '      Dim CurrentValue As Double '      Dim NextValue As Double '        Monotonicity = 0 '    '      For k = 1 To 4 arrTotals(k) = 0 Next ' -  - For x = 1 To 4 '   Current = 1 '      '   (     )  Next_ = Current + 1 Do While Next_ &lt;= 4 '       '      '(       ) Do While Next_ &lt;= 4 '       If Position(x, Next_) = 0 Then '     Next_ = Next_ + 1 '   Else ' -    Exit Do ' ,  ,   End If Loop '         If Next_ &gt; 4 Then Next_ = 4 '          If Position(x, Current) &gt; 0 Then CurrentValue = Log(Position(x, Current)) / Log(2) Else CurrentValue = 0 End If ' MsgBox "Position[" &amp; x &amp; ", " &amp; Next_ &amp; "]=" &amp; Position(x, Next_) If Position(x, Next_) &gt; 0 Then NextValue = Log(Position(x, Next_)) / Log(2) Else NextValue = 0 End If If CurrentValue &gt; NextValue Then '   ? arrTotals(Up) = arrTotals(Up) + NextValue - CurrentValue ElseIf NextValue &gt; CurrentValue Then '   ? arrTotals(Down) = arrTotals(Down) + CurrentValue - NextValue End If Current = Next_ '       Next_ = Next_ + 1 '    Loop Next '      -  - Monotonicity = IIf(arrTotals(Up) &gt;= arrTotals(Down), _ Monotonicity + arrTotals(Up), _ Monotonicity + arrTotals(Down)) ' -  - For y = 1 To 4 '   Current = 1 '      '   (     )  Next_ = Current + 1 Do While Next_ &lt;= 4 '       '      '(       ) Do While Next_ &lt;= 4 '       If Position(Next_, y) = 0 Then '     Next_ = Next_ + 1 '   Else ' -    Exit Do ' ,  ,   End If Loop '         If Next_ &gt; 4 Then Next_ = 4 '          If Position(Current, y) &gt; 0 Then CurrentValue = Log(Position(Current, y)) / Log(2) Else CurrentValue = 0 End If If Position(Next_, y) &gt; 0 Then NextValue = Log(Position(Next_, y)) / Log(2) Else NextValue = 0 End If If CurrentValue &gt; NextValue Then '   ? arrTotals(Left) = arrTotals(Left) + NextValue - CurrentValue ElseIf NextValue &gt; CurrentValue Then '   ? arrTotals(Right) = arrTotals(Right) + CurrentValue - NextValue End If Current = Next_ '       Next_ = Next_ + 1 '    Loop Next '      -  - Monotonicity = IIf(arrTotals(Left) &gt;= arrTotals(Right), _ Monotonicity + arrTotals(Left), _ Monotonicity + arrTotals(Right)) '     EmptyCount = 0 '      MaxValue = 0 '    For i = 1 To 4 '     For j = 1 To 4 '     If Position(i, j) = 0 Then '  ... '...     EmptyCount = EmptyCount + 1 '     ... ElseIf Position(i, j) &gt; MaxValue Then MaxValue = Position(i, j) '...    End If Next Next '   StaticEvaluation = Smoothness * SmoothWeight + _ Monotonicity * MonoWeight + _ Log_Base_Arg(EmptyCount) * EmptyWeight + _ MaxValue * MaxWeight End Function</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Ovolve-Code im Java-Skript</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Grid</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">size</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size = size; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.startTiles = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cells = []; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.build(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.playerTurn = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// pre-allocate these objects (for speed) Grid.prototype.indexes = []; for (var x=0; x&lt;4; x++) { Grid.prototype.indexes.push([]); for (var y=0; y&lt;4; y++) { Grid.prototype.indexes[x].push( {x:x, y:y} ); } } // Build a grid of the specified size Grid.prototype.build = function () { for (var x = 0; x &lt; this.size; x++) { var row = this.cells[x] = []; for (var y = 0; y &lt; this.size; y++) { row.push(null); } } }; // Find the first available random position Grid.prototype.randomAvailableCell = function () { var cells = this.availableCells(); if (cells.length) { return cells[Math.floor(Math.random() * cells.length)]; } }; Grid.prototype.availableCells = function () { var cells = []; var self = this; this.eachCell(function (x, y, tile) { if (!tile) { //cells.push(self.indexes[x][y]); cells.push( {x:x, y:y} ); } }); return cells; }; // Call callback for every cell Grid.prototype.eachCell = function (callback) { for (var x = 0; x &lt; this.size; x++) { for (var y = 0; y &lt; this.size; y++) { callback(x, y, this.cells[x][y]); } } }; // Check if there are any cells available Grid.prototype.cellsAvailable = function () { return !!this.availableCells().length; }; // Check if the specified cell is taken Grid.prototype.cellAvailable = function (cell) { return !this.cellOccupied(cell); }; Grid.prototype.cellOccupied = function (cell) { return !!this.cellContent(cell); }; Grid.prototype.cellContent = function (cell) { if (this.withinBounds(cell)) { return this.cells[cell.x][cell.y]; } else { return null; } }; // Inserts a tile at its position Grid.prototype.insertTile = function (tile) { this.cells[tile.x][tile.y] = tile; }; Grid.prototype.removeTile = function (tile) { this.cells[tile.x][tile.y] = null; }; Grid.prototype.withinBounds = function (position) { return position.x &gt;= 0 &amp;&amp; position.x &lt; this.size &amp;&amp; position.y &gt;= 0 &amp;&amp; position.y &lt; this.size; }; Grid.prototype.clone = function() { newGrid = new Grid(this.size); newGrid.playerTurn = this.playerTurn; for (var x = 0; x &lt; this.size; x++) { for (var y = 0; y &lt; this.size; y++) { if (this.cells[x][y]) { newGrid.insertTile(this.cells[x][y].clone()); } } } return newGrid; }; // Set up the initial tiles to start the game with Grid.prototype.addStartTiles = function () { for (var i=0; i&lt;this.startTiles; i++) { this.addRandomTile(); } }; // Adds a tile in a random position Grid.prototype.addRandomTile = function () { if (this.cellsAvailable()) { var value = Math.random() &lt; 0.9 ? 2 : 4; //var value = Math.random() &lt; 0.9 ? 256 : 512; var tile = new Tile(this.randomAvailableCell(), value); this.insertTile(tile); } }; // Save all tile positions and remove merger info Grid.prototype.prepareTiles = function () { this.eachCell(function (x, y, tile) { if (tile) { tile.mergedFrom = null; tile.savePosition(); } }); }; // Move a tile and its representation Grid.prototype.moveTile = function (tile, cell) { this.cells[tile.x][tile.y] = null; this.cells[cell.x][cell.y] = tile; tile.updatePosition(cell); }; Grid.prototype.vectors = { 0: { x: 0, y: -1 }, // up 1: { x: 1, y: 0 }, // right 2: { x: 0, y: 1 }, // down 3: { x: -1, y: 0 } // left } // Get the vector representing the chosen direction Grid.prototype.getVector = function (direction) { // Vectors representing tile movement return this.vectors[direction]; }; // Move tiles on the grid in the specified direction // returns true if move was successful Grid.prototype.move = function (direction) { // 0: up, 1: right, 2:down, 3: left var self = this; var cell, tile; var vector = this.getVector(direction); var traversals = this.buildTraversals(vector); var moved = false; var score = 0; var won = false; // Save the current tile positions and remove merger information this.prepareTiles(); // Traverse the grid in the right direction and move tiles traversals.x.forEach(function (x) { traversals.y.forEach(function (y) { cell = self.indexes[x][y]; tile = self.cellContent(cell); if (tile) { //if (debug) { //console.log('tile @', x, y); //} var positions = self.findFarthestPosition(cell, vector); var next = self.cellContent(positions.next); // Only one merger per row traversal? if (next &amp;&amp; next.value === tile.value &amp;&amp; !next.mergedFrom) { var merged = new Tile(positions.next, tile.value * 2); merged.mergedFrom = [tile, next]; self.insertTile(merged); self.removeTile(tile); // Converge the two tiles' positions tile.updatePosition(positions.next); // Update the score score += merged.value; // The mighty 2048 tile if (merged.value === 2048) { won = true; } } else { //if (debug) { //console.log(cell); //console.log(tile); //} self.moveTile(tile, positions.farthest); } if (!self.positionsEqual(cell, tile)) { self.playerTurn = false; //console.log('setting player turn to ', self.playerTurn); moved = true; // The tile moved from its original cell! } } }); }); //console.log('returning, playerturn is', self.playerTurn); //if (!moved) { //console.log('cell', cell); //console.log('tile', tile); //console.log('direction', direction); //console.log(this.toString()); //} return {moved: moved, score: score, won: won}; }; Grid.prototype.computerMove = function() { this.addRandomTile(); this.playerTurn = true; } // Build a list of positions to traverse in the right order Grid.prototype.buildTraversals = function (vector) { var traversals = { x: [], y: [] }; for (var pos = 0; pos &lt; this.size; pos++) { traversals.x.push(pos); traversals.y.push(pos); } // Always traverse from the farthest cell in the chosen direction if (vector.x === 1) traversals.x = traversals.x.reverse(); if (vector.y === 1) traversals.y = traversals.y.reverse(); return traversals; }; Grid.prototype.findFarthestPosition = function (cell, vector) { var previous; // Progress towards the vector direction until an obstacle is found do { previous = cell; cell = { x: previous.x + vector.x, y: previous.y + vector.y }; } while (this.withinBounds(cell) &amp;&amp; this.cellAvailable(cell)); return { farthest: previous, next: cell // Used to check if a merge is required }; }; Grid.prototype.movesAvailable = function () { return this.cellsAvailable() || this.tileMatchesAvailable(); }; // Check for available matches between tiles (more expensive check) // returns the number of matches Grid.prototype.tileMatchesAvailable = function () { var self = this; //var matches = 0; var tile; for (var x = 0; x &lt; this.size; x++) { for (var y = 0; y &lt; this.size; y++) { tile = this.cellContent({ x: x, y: y }); if (tile) { for (var direction = 0; direction &lt; 4; direction++) { var vector = self.getVector(direction); var cell = { x: x + vector.x, y: y + vector.y }; var other = self.cellContent(cell); if (other &amp;&amp; other.value === tile.value) { return true; //matches++; // These two tiles can be merged } } } } } //console.log(matches); return false; //matches; }; Grid.prototype.positionsEqual = function (first, second) { return first.x === second.x &amp;&amp; first.y === second.y; }; Grid.prototype.toString = function() { string = ''; for (var i=0; i&lt;4; i++) { for (var j=0; j&lt;4; j++) { if (this.cells[j][i]) { string += this.cells[j][i].value + ' '; } else { string += '_ '; } } string += '\n'; } return string; } // counts the number of isolated groups. Grid.prototype.islands = function() { var self = this; var mark = function(x, y, value) { if (x &gt;= 0 &amp;&amp; x &lt;= 3 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt;= 3 &amp;&amp; self.cells[x][y] &amp;&amp; self.cells[x][y].value == value &amp;&amp; !self.cells[x][y].marked ) { self.cells[x][y].marked = true; for (direction in [0,1,2,3]) { var vector = self.getVector(direction); mark(x + vector.x, y + vector.y, value); } } } var islands = 0; for (var x=0; x&lt;4; x++) { for (var y=0; y&lt;4; y++) { if (this.cells[x][y]) { this.cells[x][y].marked = false } } } for (var x=0; x&lt;4; x++) { for (var y=0; y&lt;4; y++) { if (this.cells[x][y] &amp;&amp; !this.cells[x][y].marked) { islands++; mark(x, y , this.cells[x][y].value); } } } return islands; } // measures how smooth the grid is (as if the values of the pieces // were interpreted as elevations). Sums of the pairwise difference // between neighboring tiles (in log space, so it represents the // number of merges that need to happen before they can merge). // Note that the pieces can be distant Grid.prototype.smoothness = function() { var smoothness = 0; for (var x=0; x&lt;4; x++) { for (var y=0; y&lt;4; y++) { if ( this.cellOccupied( this.indexes[x][y] )) { var value = Math.log(this.cellContent( this.indexes[x][y] ).value) / Math.log(2); for (var direction=1; direction&lt;=2; direction++) { var vector = this.getVector(direction); var targetCell = this.findFarthestPosition(this.indexes[x][y], vector).next; if (this.cellOccupied(targetCell)) { var target = this.cellContent(targetCell); var targetValue = Math.log(target.value) / Math.log(2); smoothness -= Math.abs(value - targetValue); } } } } } return smoothness; } Grid.prototype.monotonicity = function() { var self = this; var marked = []; var queued = []; var highestValue = 0; var highestCell = {x:0, y:0}; for (var x=0; x&lt;4; x++) { marked.push([]); queued.push([]); for (var y=0; y&lt;4; y++) { marked[x].push(false); queued[x].push(false); if (this.cells[x][y] &amp;&amp; this.cells[x][y].value &gt; highestValue) { highestValue = this.cells[x][y].value; highestCell.x = x; highestCell.y = y; } } } increases = 0; cellQueue = [highestCell]; queued[highestCell.x][highestCell.y] = true; markList = [highestCell]; markAfter = 1; // only mark after all queued moves are done, as if searching in parallel var markAndScore = function(cell) { markList.push(cell); var value; if (self.cellOccupied(cell)) { value = Math.log(self.cellContent(cell).value) / Math.log(2); } else { value = 0; } for (direction in [0,1,2,3]) { var vector = self.getVector(direction); var target = { x: cell.x + vector.x, y: cell.y+vector.y } if (self.withinBounds(target) &amp;&amp; !marked[target.x][target.y]) { if ( self.cellOccupied(target) ) { targetValue = Math.log(self.cellContent(target).value ) / Math.log(2); if ( targetValue &gt; value ) { //console.log(cell, value, target, targetValue); increases += targetValue - value; } } if (!queued[target.x][target.y]) { cellQueue.push(target); queued[target.x][target.y] = true; } } } if (markAfter == 0) { while (markList.length &gt; 0) { var cel = markList.pop(); marked[cel.x][cel.y] = true; } markAfter = cellQueue.length; } } while (cellQueue.length &gt; 0) { markAfter--; markAndScore(cellQueue.shift()) } return -increases; } // measures how monotonic the grid is. This means the values of the tiles are strictly increasing // or decreasing in both the left/right and up/down directions Grid.prototype.monotonicity2 = function() { // scores for all four directions var totals = [0, 0, 0, 0]; // up/down direction for (var x=0; x&lt;4; x++) { var current = 0; var next = current+1; while ( next&lt;4 ) { while ( next&lt;4 &amp;&amp; !this.cellOccupied( this.indexes[x][next] )) { next++; } if (next&gt;=4) { next--; } var currentValue = this.cellOccupied({x:x, y:current}) ? Math.log(this.cellContent( this.indexes[x][current] ).value) / Math.log(2) : 0; var nextValue = this.cellOccupied({x:x, y:next}) ? Math.log(this.cellContent( this.indexes[x][next] ).value) / Math.log(2) : 0; if (currentValue &gt; nextValue) { totals[0] += nextValue - currentValue; } else if (nextValue &gt; currentValue) { totals[1] += currentValue - nextValue; } current = next; next++; } } // left/right direction for (var y=0; y&lt;4; y++) { var current = 0; var next = current+1; while ( next&lt;4 ) { while ( next&lt;4 &amp;&amp; !this.cellOccupied( this.indexes[next][y] )) { next++; } if (next&gt;=4) { next--; } var currentValue = this.cellOccupied({x:current, y:y}) ? Math.log(this.cellContent( this.indexes[current][y] ).value) / Math.log(2) : 0; var nextValue = this.cellOccupied({x:next, y:y}) ? Math.log(this.cellContent( this.indexes[next][y] ).value) / Math.log(2) : 0; if (currentValue &gt; nextValue) { totals[2] += nextValue - currentValue; } else if (nextValue &gt; currentValue) { totals[3] += currentValue - nextValue; } current = next; next++; } } return Math.max(totals[0], totals[1]) + Math.max(totals[2], totals[3]); } Grid.prototype.maxValue = function() { var max = 0; for (var x=0; x&lt;4; x++) { for (var y=0; y&lt;4; y++) { if (this.cellOccupied(this.indexes[x][y])) { var value = this.cellContent(this.indexes[x][y]).value; if (value &gt; max) { max = value; } } } } return Math.log(max) / Math.log(2); } // WIP. trying to favor top-heavy distributions (force consolidation of higher value tiles) /* Grid.prototype.valueSum = function() { var valueCount = []; for (var i=0; i&lt;11; i++) { valueCount.push(0); } for (var x=0; x&lt;4; x++) { for (var y=0; y&lt;4; y++) { if (this.cellOccupied(this.indexes[x][y])) { valueCount[Math.log(this.cellContent(this.indexes[x][y]).value) / Math.log(2)]++; } } } var sum = 0; for (var i=1; i&lt;11; i++) { sum += valueCount[i] * Math.pow(2, i) + i; } return sum; } */ // check for win Grid.prototype.isWin = function() { var self = this; for (var x=0; x&lt;4; x++) { for (var y=0; y&lt;4; y++) { if (self.cellOccupied(this.indexes[x][y])) { if (self.cellContent(this.indexes[x][y]).value == 2048) { return true; } } } } return false; } //Grid.prototype.zobristTable = {} //for //Grid.prototype.hash = function() { //}</span></span></code> </pre> </div></div><br><h2>  2048.xlsm </h2><br>  Die Excel-Anwendung selbst <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kann von Google heruntergeladen werden</a> . <br><br>  Die Funktionalität der Anwendung wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in einem früheren Artikel beschrieben, in dem AI nach der Monte-Carlo-Methode spielt</a> .  Die heutige Lösung wurde dem bestehenden Monte Carlo hinzugefügt. <br><br><h3>  Alle Artikel der AI- und 2048-Serie </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Monte Carlo</a> </li><li>  <strong>Minimax + Alpha-Beta-Ausschnitt</strong> </li><li>  Warten auf Maximum </li><li>  Neuronales Netz </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de474680/">https://habr.com/ru/post/de474680/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de474668/index.html">GitHub-Aktionen als CI / CD für eine Site auf einem statischen Generator und GitHub-Seiten</a></li>
<li><a href="../de474672/index.html">Reagieren, JSX, Importieren von ES-Modulen (auch dynamisch) in einen Browser ohne Webpack</a></li>
<li><a href="../de474674/index.html">Bildverarbeitung und Medizin</a></li>
<li><a href="../de474676/index.html">Der Interaktionsalgorithmus von Hunderttausenden eindeutigen Partikeln auf der GPU in GLES3 und WebGL2</a></li>
<li><a href="../de474678/index.html">Die Khronos Group hat ein einheitliches Repository mit Vulkan-Beispielen erstellt</a></li>
<li><a href="../de474686/index.html">Fantastische Geschichte "Erlösung" (10 Min.)</a></li>
<li><a href="../de474688/index.html">Retro Zug mit einer Dampflokomotive</a></li>
<li><a href="../de474690/index.html">Erstellen einer Konsole mit variabler Höhe für komfortableres Arbeiten am Computer</a></li>
<li><a href="../de474692/index.html">Skaffold Review für Kubernetes Development</a></li>
<li><a href="../de474694/index.html">Wie wir das Framework für Leistungstests ausgewählt und verdreht haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>