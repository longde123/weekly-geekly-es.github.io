<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äç‚öñÔ∏è ‚óæÔ∏è üèïÔ∏è AI und 2048. Teil 2: Minimax + Alpha Beta Clipping üëµ üßñüèΩ ü§ë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir haben die Monte-Carlo-Methode untersucht . Heute werden wir sehen, wie der Computergeist im Jahr 2048 mit dem guten alten Minimax mit Alpha-Beta-C...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>AI und 2048. Teil 2: Minimax + Alpha Beta Clipping</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/474680/"><div style="text-align:center;"><img width="690" height="314" src="https://habrastorage.org/webt/9t/ym/10/9tym105d327kylbfpejz4inkdxu.png"></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wir haben die Monte-Carlo-Methode untersucht</a> . Heute werden wir sehen, wie der Computergeist im Jahr 2048 mit dem guten alten Minimax mit Alpha-Beta-Clipping spielt. <a name="habracut"></a><br><br><blockquote> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="EDISON Software - Webentwicklung"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISON Software - Webentwicklung"></a> <br clear="right">  Der Artikel wurde mit Unterst√ºtzung von EDISON verfasst, einem Unternehmen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das mobile Anwendungen entwickelt</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Software-Testdienste anbietet</a> . </blockquote><br>  Vom Benutzer-Stackoverflow ausspionierte L√∂sung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img width="14" height="14" src="https://habrastorage.org/webt/7c/q2/x_/7cq2x_1w7otpr1ksh4yryg83h4c.jpeg"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ovolve</a> , der in der Diskussion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">feststellte</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wie man AI das Spiel 2048 beibringt</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Kommentar√ºbersetzung von ovolve</b> <div class="spoiler_text">  Ich bin der Autor des in diesem Thread erw√§hnten Programms.  Sie k√∂nnen die KI <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in Aktion sehen</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Code sehen</a> . <br><br>  Gegenw√§rtig gewinnt das Programm in etwa 90% der F√§lle, indem es Java-Skripte in einem Browser auf meinem Laptop ausf√ºhrt. Dabei werden 100 Millisekunden ben√∂tigt, um √ºber den Kurs nachzudenken. Es funktioniert zwar nicht perfekt, aber ziemlich gut. <br><br>  Da das Spiel ein diskreter Zustandsraum mit vollst√§ndigen Informationen ist und tats√§chlich ein rundenbasiertes Spiel wie Schach und Dame ist, habe ich die gleichen Methoden verwendet, die ihre Leistung in diesen Spielen zeigten, n√§mlich die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Minimax-Suche</a> mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alpha-Beta-Clipping</a> .  Da die Links viele Informationen zu diesem Algorithmus enthalten, werde ich nur auf die beiden wichtigsten Heuristiken eingehen, die ich in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der statischen Sch√§tzfunktion verwendet habe,</a> und viele der intuitiven Annahmen formalisieren, die andere Personen hier getroffen haben. <br><br><img align="right" width="344" height="343" src="https://habrastorage.org/webt/hm/s0/cu/hms0cuvsvpeyvyvozxm-3f88xui.png"><br clear="left"><h3>  Monotonie </h3><br>  Diese Heuristik versucht sicherzustellen, dass alle Kachelwerte links / rechts und oben / unten entweder erh√∂ht oder verringert werden.  Diese Heuristik allein spiegelt die Vermutung wider, dass viele andere erw√§hnt haben, dass wertvollere Kacheln in einer Ecke gruppiert werden sollten.  Dies verhindert in der Regel die Ansammlung von weniger wertvollen Kacheln und h√§lt das Spielfeld organisiert, da kleinere Kacheln in gr√∂√üere √ºbergehen. <br><br>  Hier ist ein Screenshot eines komplett eint√∂nigen Gitters.  Ich habe diese Situation durch Ausf√ºhren eines Algorithmus mit der installierten Auswertungsfunktion erhalten, um andere Heuristiken zu ignorieren und nur Monotonie zu ber√ºcksichtigen. <br><br><img align="right" width="342" height="343" src="https://habrastorage.org/webt/iq/wp/4p/iqwp4pn8rsoynb1u6eknm99gmt8.png"><br clear="left"><h3>  Gl√§tte (Gl√§tte, Ebenheit) </h3><br>  Die obige Heuristik an sich neigt dazu, Strukturen zu erzeugen, in denen benachbarte Zellen an Wert verlieren, aber nat√ºrlich sollten Nachbarn die gleiche Bedeutung haben, um sie zu kombinieren.  Daher misst die Heuristik der Gl√§tte einfach die Wertdifferenz zwischen benachbarten Kacheln und versucht, deren Anzahl zu minimieren. <br><br>  Ein Kommentator von Hacker News lieferte eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">interessante</a> graphentheoretische <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Formalisierung</a> dieser Idee. <br><br><div class="spoiler">  <b class="spoiler_title">√úbersetzung der Formalisierung mit Hacker News</b> <div class="spoiler_text"><blockquote>  Gestern habe ich dieses Spiel einem Kollegen gezeigt, einem Liebhaber der Graphentheorie, und wir haben uns auch entschlossen, dar√ºber nachzudenken, wie wir dieses Spiel mit KI l√∂sen k√∂nnen. <br><br>  Die einfachste L√∂sung ist Minimax, die meiner Meinung nach ziemlich gut implementiert ist.  Wenn jemand hier nicht mit minimax vertraut ist, hat OP sehr eleganten und gut kommentierten Code geschrieben, der ein gro√üartiges Tutorial w√§re. <br><br>  Der weniger rechenintensive Ansatz, den wir vorgeschlagen haben, bestand darin, den Spielzustand in Form eines Graphen <b>G (V, E)</b> zu modellieren, wobei <b>V</b> eine Menge von aktiven Kacheln und <b>E</b> eine Menge von Kanten ist, die benachbarte Kacheln verbinden, gewichtet nach Funktion <b>c (v1, v2)</b> , die den absoluten Wert der Differenz zwischen den beiden Kacheln zur√ºckgibt.  F√ºr jede L√∂sung w√§hlt die KI einen Zug, der die Summe der Gewichte aller Kanten im neuen Spielzustand minimiert. <br><br>  Der Grund daf√ºr ist, dass der einzige Weg, um Fortschritte im Spiel zu erzielen, darin besteht, Kacheln mit denselben Werten nebeneinander zu haben, f√ºr die das Gewicht in <b>G</b> 0 betr√§gt. Daher sollte die KI versuchen, das Gesamtgewicht zu minimieren.  Am Ende befindet sich eine gro√üe Anzahl an Brettern mit einem gro√üen Gewicht an Kanten zu benachbarten Kacheln. Die KI wird daher versuchen, diese Kacheln neben anderen gro√üen Kacheln zu belassen, um den Unterschied zu minimieren. <br><br>  Da das Spiel stochastisch ist, funktioniert der von mir beschriebene Ansatz m√∂glicherweise nicht im schlimmsten Fall, kann aber auch als Gewichtsfunktion f√ºr jeden Knoten im Baum auf die vorhandene Minimax-L√∂sung angewendet werden. </blockquote></div></div><br><br>  Hier ist ein Screenshot eines perfekt glatten Netzes, freundlicherweise zur Verf√ºgung gestellt von dieser exzellenten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20140315093348/">Scheingabel</a> .  <i>(Link zum Webarchiv, w√§hrend Java-Skripte auf der Seite funktionieren und Sie die Tastatur verwenden k√∂nnen, um eine Bewegung in eine beliebige Richtung auszuf√ºhren - Anmerkung des √úbersetzers).</i> <br><br><h3>  Lose Fliesen </h3><br>  Und schlie√ülich gibt es eine Strafe f√ºr zu wenig freie Steine, da die Optionen schnell enden k√∂nnen, wenn das Spielfeld zu eng wird. <br><br>  Und das ist alles!  Das Durchsuchen des Spielraums bei gleichzeitiger Optimierung dieser Kriterien bietet eine √ºberraschend gute Leistung.  Einer der Vorteile eines solchen generischen Ansatzes anstelle einer explizit codierten Verschiebestrategie besteht darin, dass der Algorithmus h√§ufig interessante und unerwartete L√∂sungen findet.  Wenn Sie seinen Fortschritt beobachten, macht er oft erstaunliche, aber effektive Bewegungen, wie zum Beispiel den pl√∂tzlichen Wechsel von W√§nden oder Ecken, in deren N√§he er sein Spiel baut. <br><br><img align="right" width="345" height="499" src="https://habrastorage.org/webt/tc/oi/hz/tcoihzahmdqlw9cxthywpapiwsa.png"><br clear="left"><h3>  Kleine √Ñnderung </h3><br>  Der Screenshot zeigt die Leistungsf√§higkeit dieses Ansatzes.  Ich habe das Kachellimit entfernt (damit sie nach Erreichen von 2048 weiter wachsen), und hier ist das beste Ergebnis nach acht Tests. <br><br>  Ja, das ist 4096 zusammen mit 2048. =) Dies bedeutet, dass er das schwer fassbare 2048-Pl√§ttchen auf einem Brett erreicht hat. </div></div><br><hr><hr><hr><hr><hr><br>  Java-Script-Code f√ºr minimax mit Alpha-Beta-Clipping und statischer Auswertungsfunktion aus dem Stackoverflow-User-Ovolve ist unten im Artikel angegeben. <br><br>  Die Minimax-Methode ist mehreren ausgezeichneten Habr-Artikeln gewidmet, daher lassen wir die akademische detaillierte Erkl√§rung dessen, woraus sie besteht, weg.  F√ºr diejenigen, <strike>die erst k√ºrzlich der IT-Community beigetreten sind, haben</strike> sie die sch√∂nen Begriffe "Minimax" und "Alpha-Beta-Cut-Off" geh√∂rt, aber sie wissen nicht, was dies bedeutet. Versuchen wir, in ein paar Abs√§tzen buchst√§blich die allgemeinste Bedeutung zu erkl√§ren. <br><br><h2>  Minimax </h2><br>  In einigen Spielen kann der Prozess eines Spiels zwischen zwei Spielern (die nacheinander einen Zug machen) als sogenannter Optionsbaum dargestellt werden.  In jeder bestimmten Position hat jeder Spieler normalerweise die Wahl zwischen verschiedenen Optionen f√ºr seinen Zug.  Und als Reaktion auf jede dieser Optionen kann ein Gegner auch in vielerlei Hinsicht √§hnlich sein. <br><br><div style="text-align:center;"><img width="690" height="525" src="https://habrastorage.org/webt/xi/ye/j2/xiyej2z5e4n-kigoscjrgfpf2i8.png"></div><br>  <sup><em>Fragment eines Baumes von Optionen</em></sup> <br><br>  Da zu jedem Zeitpunkt des Spiels vollst√§ndige Informationen √ºber den Zustand des Spielfelds vorliegen, kann der aktuelle Zustand der Position immer genau gesch√§tzt werden.  Eine solche Funktion wird als <strong>statische Bewertungsfunktion</strong> oder abgek√ºrzter <strong>SFO bezeichnet</strong> .  Je wichtiger diese Funktion bei der Bewertung einer bestimmten Position ist, desto vorteilhafter ist au√üerdem die Position f√ºr einen Spieler (nennen wir sie den <strong>maximierenden Spieler</strong> ).  Je kleiner der numerische Wert dieser Funktion bei der Auswertung einer Position ist, desto vorteilhafter ist die Position f√ºr den zweiten Spieler (nennen wir es den <strong>minimierenden Spieler</strong> ). <br><br>  Nach jedem Zug √§ndert sich die Position und damit auch die Punktzahl.  Bei der Betrachtung des Optionsbaums muss jeder Spieler nicht nur die Zweige bevorzugen, in denen die Bewertung f√ºr ihn am g√ºnstigsten ist.  Sie sollten auch solche Zweige vermeiden, in denen die Bewertung der Position f√ºr den Gegner g√ºnstig ist. <br><br>  Es wird davon ausgegangen, dass der Gegner sich auch von Rationalismus leiten l√§sst und auch Optionen vermeidet, die ihn zum Verlieren f√ºhren k√∂nnten.  Das hei√üt, jeder Spieler maximiert bei der Auswahl einer Option seinen eigenen Nutzen und minimiert gleichzeitig den Gewinn des Gegners. <br><br>  Das ist Minimax. <br><br><h2>  Alpha Beta Ausschnitt </h2><br>  Es liegt auf der Hand: Wer einen Baum von einer bestimmten Position bis zu einer gr√∂√üeren Tiefe berechnet, hat mehr Gewinnchancen.  Aber es gibt ein √Ñrgernis: Der Baum der Optionen in Spielen hat die unangenehme Angewohnheit, sich mit jeder Verschachtelungsebene zu verzweigen und exponentiell zu wachsen.  Die Z√§hlf√§higkeiten von Programmen und vor allem die der Menschen sind begrenzt, das Z√§hlen "bis zur Matte" ist bei weitem nicht immer m√∂glich.  Es kann sich leicht herausstellen, dass der Spieler zu einer Position gez√§hlt hat, bei der er eine gute Einsch√§tzung des Spielfelds hat, aber auf der n√§chsten (unlesbaren) Ebene hat der Gegner buchst√§blich die M√∂glichkeit, einen solchen Zug zu machen, der die Positionssch√§tzung grundlegend zum Gegenteil √§ndert. <br><br>  Wer ist schuld und was zu tun?  Der Rechenaufwand ist f√ºr die vollst√§ndige Durchquerung der B√§ume verantwortlich, und es wird vorgeschlagen, unn√∂tige √Ñste abzuschneiden, um zu k√§mpfen.  Wenn der Spieler, der die Position bewertet, einen Zweig des Optionsbaums sieht: <br><br>  oder weniger rentabel als andere Branchen, die bereits analysiert wurden, <br>  oder vorteilhafter f√ºr den Gegner als andere Zweige, die bereits analysiert wurden, <br><br>  dann wirft der Spieler diesen Zweig ab, verschwendet keine Zeit und Ressourcen damit, Unteroptionen aus diesem offensichtlich schlechteren Zweig f√ºr ihn in Betracht zu ziehen. <br><br>  Auf diese Weise k√∂nnen Sie mehr Rechenressourcen f√ºr die Berechnung g√ºnstigerer Verzweigungen einer gr√∂√üeren Rendering-Tiefe im Optionsbaum zuweisen.  Bei der Bewertung des Spielfelds auf verschiedenen Ebenen des Optionsbaums arbeitet der Spieler mit zwei sich dynamisch √§ndernden Koeffizienten - <strong>Alpha</strong> (der Wert des SFD, der im Zweig minimal angetroffen wird - d. H. F√ºr den minimierenden Spieler g√ºnstiger) und <strong>Beta</strong> (der Wert des SFD, der im Zweig am h√§ufigsten angetroffen wird - d. H. g√ºnstiger f√ºr den maximierenden Spieler).  Wenn Sie die SFD der aktuellen Position mit den <em>Alpha</em> und <em>Beta</em> Koeffizienten vergleichen, k√∂nnen Sie auf jeder Ebene Zweige fegen (ohne sie vollst√§ndig zu berechnen), die f√ºr den Spieler, der die Position bewertet, <em>ung√ºnstiger</em> und / oder f√ºr seinen Gegner <em>vorteilhafter sind</em> . <br><br>  Dies ist Alpha-Beta-Clipping. <br><br><h3>  Rekursive Minimax-Funktion mit Alpha-Beta-Clipping </h3><br><div class="spoiler">  <b class="spoiler_title">2048 mit AI ist als Excel-Anwendung mit VBA-Makros implementiert. So sieht der Minimax-Algorithmus mit Alpha-Beta-Clipping wie eine verabscheuungsw√ºrdige visuelle Basis aus.</b> <div class="spoiler_text"><pre><code class="vbscript hljs"><span class="hljs-comment"><span class="hljs-comment">''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' '''''''''''''''''''''''( - )''''''''''''''''''''''''' ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' '       -- 'Position -  4  4     'Depth - ,    'Alpha, Beta -         'MaximisingPlayer -      ? Private Function MiniMaxAlpaBeta_Evaluation(Position As Variant, Depth As Long, _ Alpha As Double, Beta As Double, _ MaximisingPlayer As Boolean, _ Optional MainLevel As Boolean = False) As Double Dim MaxEval As Double '  Dim MinEval As Double '  Dim PositionNext As Variant '     Dim PositionTemp As Variant '     Dim Eval As Double '   Dim Way As Long '   -      Dim Row As Long '     Dim Col As Long '     Dim TileNew As Long '      '   (  ,  '     ) If GameOverPosition(Position) Then '    ? '     MiniMaxAlpaBeta_Evaluation = -1000000 + TileMax(Position) '         ElseIf Depth = 0 Then '     MiniMaxAlpaBeta_Evaluation = StaticEvaluation(Position) '  ,    '     () ElseIf MaximisingPlayer Then MaxEval = -1000000 '      For Way = 1 To 4 ' 4   - (, , , ) ChangeCount = 0 ' ,      ',       PositionNext = StepHuman(Position, Way) If ChangeCount &gt; 0 Then '     '      , '    () Eval = MiniMaxAlpaBeta_Evaluation(PositionNext, Depth - 1, _ Alpha, Beta, False) If Eval &gt; MaxEval Then MaxEval = Eval '  '     If Eval &gt; Alpha Then Alpha = Eval '    ,   '   -    If Beta &gt; Alpha Then Exit For End If Next '          MiniMaxAlpaBeta_Evaluation = MaxEval '  ,    '     () Else 'Not MaximisingPlayer MinEval = 1000000 '      For Row = 1 To 4 '     For Col = 1 To 4 '     If Position(Row, Col) = 0 Then '   For TileNew = 2 To 4 Step 2 '    2  4 ',       '    PositionNext = StepComp(Position, Row, Col, TileNew) '     , '    () Eval = MiniMaxAlpaBeta_Evaluation(PositionNext, Depth - 1, _ Alpha, Beta, True) If Eval &lt; MinEval Then MinEval = Eval '  '     If Eval &lt; Beta Then Beta = Eval '    ,   '   -    If Alpha &lt; Beta Then Exit For Next End If Next Next '          MiniMaxAlpaBeta_Evaluation = MinEval End If End Function</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Ovolve Code in Java-Skript</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AI</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">grid</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.grid = grid; } <span class="hljs-comment"><span class="hljs-comment">//   () AI.prototype.eval = function() { var emptyCells = this.grid.availableCells().length; var smoothWeight = 0.1, //monoWeight = 0.0, //islandWeight = 0.0, mono2Weight = 1.0, emptyWeight = 2.7, maxWeight = 1.0; return this.grid.smoothness() * smoothWeight //+ this.grid.monotonicity() * monoWeight //- this.grid.islands() * islandWeight + this.grid.monotonicity2() * mono2Weight + Math.log(emptyCells) * emptyWeight + this.grid.maxValue() * maxWeight; }; // alpha-beta depth first search AI.prototype.search = function(depth, alpha, beta, positions, cutoffs) { var bestScore; var bestMove = -1; var result; // the maxing player if (this.grid.playerTurn) { bestScore = alpha; for (var direction in [0, 1, 2, 3]) { var newGrid = this.grid.clone(); if (newGrid.move(direction).moved) { positions++; if (newGrid.isWin()) { return { move: direction, score: 10000, positions: positions, cutoffs: cutoffs }; } var newAI = new AI(newGrid); if (depth == 0) { result = { move: direction, score: newAI.eval() }; } else { result = newAI.search(depth-1, bestScore, beta, positions, cutoffs); if (result.score &gt; 9900) { // win result.score--; // to slightly penalize higher depth from win } positions = result.positions; cutoffs = result.cutoffs; } if (result.score &gt; bestScore) { bestScore = result.score; bestMove = direction; } if (bestScore &gt; beta) { cutoffs++ return { move: bestMove, score: beta, positions: positions, cutoffs: cutoffs }; } } } } else { // computer's turn, we'll do heavy pruning to keep the branching factor low bestScore = beta; // try a 2 and 4 in each cell and measure how annoying it is // with metrics from eval var candidates = []; var cells = this.grid.availableCells(); var scores = { 2: [], 4: [] }; for (var value in scores) { for (var i in cells) { scores[value].push(null); var cell = cells[i]; var tile = new Tile(cell, parseInt(value, 10)); this.grid.insertTile(tile); scores[value][i] = -this.grid.smoothness() + this.grid.islands(); this.grid.removeTile(cell); } } // now just pick out the most annoying moves var maxScore = Math.max(Math.max.apply(null, scores[2]), Math.max.apply(null, scores[4])); for (var value in scores) { // 2 and 4 for (var i=0; i&lt;scores[value].length; i++) { if (scores[value][i] == maxScore) { candidates.push( { position: cells[i], value: parseInt(value, 10) } ); } } } // search on each candidate for (var i=0; i&lt;candidates.length; i++) { var position = candidates[i].position; var value = candidates[i].value; var newGrid = this.grid.clone(); var tile = new Tile(position, value); newGrid.insertTile(tile); newGrid.playerTurn = true; positions++; newAI = new AI(newGrid); result = newAI.search(depth, alpha, bestScore, positions, cutoffs); positions = result.positions; cutoffs = result.cutoffs; if (result.score &lt; bestScore) { bestScore = result.score; } if (bestScore &lt; alpha) { cutoffs++; return { move: null, score: alpha, positions: positions, cutoffs: cutoffs }; } } } return { move: bestMove, score: bestScore, positions: positions, cutoffs: cutoffs }; } // performs a search and returns the best move AI.prototype.getBest = function() { return this.iterativeDeep(); } // performs iterative deepening over the alpha-beta search AI.prototype.iterativeDeep = function() { var start = (new Date()).getTime(); var depth = 0; var best; do { var newBest = this.search(depth, -10000, 10000, 0 ,0); if (newBest.move == -1) { break; } else { best = newBest; } depth++; } while ( (new Date()).getTime() - start &lt; minSearchTime); return best } AI.prototype.translate = function(move) { return { 0: 'up', 1: 'right', 2: 'down', 3: 'left' }[move]; }</span></span></code> </pre> </div></div><br><h2>  Statische Auswertungsfunktion </h2><br>  Da Sie auf jeder Ebene im Optionsbaum das Spielfeld bewerten m√ºssen (um zu entscheiden, f√ºr welchen der Spieler die gesch√§tzte Position tats√§chlich vorteilhafter ist), m√ºssen Sie entscheiden, welche Kriterien eine gute von einer schlechten Position unterscheiden. <br><br>  Wir gehen davon aus, dass der maximierende Spieler die Person (oder KI) ist, die entscheidet, in welche der vier Richtungen (oben, links, rechts, unten) alle Steine ‚Äã‚Äãverschoben werden.  Ein minimierender Spieler ist diese heimt√ºckische Unterroutine, die zuf√§llig 2 oder 4 an den unangemessensten Stellen generiert. <br><br>  SFO wird aus der Sicht eines maximierenden Spielers zusammengestellt.  Je h√∂her die SFD-Bewertung f√ºr das Spielfeld ist, desto besser ist die Position f√ºr den ‚ÄûMaximalisten‚Äú.  Je niedriger - desto angenehmer ist die Position auf dem Brett f√ºr den "Minimalisten". <br><br>  Im Fall von 2048 - welche Faktoren werden f√ºr denjenigen als g√ºnstig angesehen, der die Kacheln bewegt? <br><br><h3>  Monotonie </h3><img align="right" width="388" height="189" src="https://habrastorage.org/webt/r8/jc/qt/r8jcqtbvrsyvrfwwsmeedgfrzrg.png"><br clear="left">  Erstens ist es w√ºnschenswert, dass die Kacheln in aufsteigender / absteigender Reihenfolge in einigen Richtungen angeordnet sind.  Wenn dies nicht erfolgt, wird das Spielfeld beim Generieren neuer Kacheln schnell durch zuf√§llig angeordnete Kacheln unterschiedlicher Gr√∂√üe verstopft, die nicht sofort normal miteinander verbunden werden k√∂nnen. <br><br>  Im Sibirischen Bundesdistrikt m√ºssen Sie in alle vier Richtungen schauen (von oben nach unten, von links nach rechts, von rechts nach links, von unten nach oben) und berechnen, wo die Kacheln eine abnehmende oder zunehmende Progression aufweisen.  Wenn es im Laufe der Zeit Kacheln gibt, die nicht in die allgemeine Reihe passen, verringert dies den numerischen Monotoniekoeffizienten.  Dann wird aus den 4 Koeffizienten f√ºr alle Richtungen der beste ausgew√§hlt, der im Gesamtwert des Sibirischen Bundesdistrikts ber√ºcksichtigt wird. <br><br><h3>  Gl√§tte </h3><img align="right" width="387" height="189" src="https://habrastorage.org/webt/uw/mq/wh/uwmqwht6dm82fc_zptwwdqdar2c.png"><br clear="left">  Dar√ºber hinaus w√§re es vorzuziehen, wenn der Fortschritt vom Stehen in einer Reihe von Kacheln nicht nur zunimmt, sondern nicht abnimmt (oder statt der Reihe zu verringern, ist es vorzuziehen, nicht zuzunehmen), das hei√üt, es ist gut, wenn dieselben Kacheln in der N√§he sind, was es ihnen erm√∂glicht, zu einer zusammenzufallen, Punkte zu gewinnen und Erh√∂hung des freien Platzes auf dem Spielfeld. <br><br>  Daher sucht der Sibirische Bundesdistrikt auf dem Spielfeld nach denselben benachbarten Kacheln und ber√ºcksichtigt die Anzahl solcher Paare in einem speziellen Koeffizienten. <br><br><h3>  Leere Zellen </h3><img align="right" width="387" height="193" src="https://habrastorage.org/webt/qj/as/ay/qjasayisfgowdqcciifm0igt3ru.png"><br clear="left">  Je mehr Freiraum vorhanden ist, desto mehr Spielraum ist vorhanden und desto geringer ist die Wahrscheinlichkeit, schnell zu verlieren. <br><br>  SFO betrachtet leere Zellen auf dem Spielfeld und je mehr davon, desto profitabler wird die Position f√ºr den maximierenden Spieler. <br><br><h3>  Maximale Kachel </h3><br>  Da die Hauptsache in diesem Spiel darin besteht, ein gro√ües Pl√§ttchen auf das Spielfeld zu bringen, sollten die Optionen, bei denen der maximale Pl√§ttchenwert h√∂her ist, als das rentabelste SFD angesehen werden, je mehr desto besser - 2048, 4096, 8192 (oder was auch immer Sie die St√§rke und Geduld daf√ºr haben). <br><br><h3>  Sibirischer Bundesdistrikt f√ºr 2048 </h3><br><div class="spoiler">  <b class="spoiler_title">Implementierung des Sibirischen Bundesdistrikts als VBA-Makro</b> <div class="spoiler_text"><pre> <code class="vbscript hljs"><span class="hljs-comment"><span class="hljs-comment">''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' '''''''''''''''''''''''  '''''''''''''''''''''''' ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' '     'Position -  4  4     Private Function StaticEvaluation(Position As Variant) As Double Dim Smoothness As Double ' Dim Monotonicity As Double ' Dim EmptyCount As Double '  Dim MaxValue As Long '  '   Const SmoothWeight = 0.1 Const MonoWeight = 1 Const EmptyWeight = 2.7 Const MaxWeight = 1 Dim k As Long '   Dim i As Long '  Dim j As Long '  Dim x As Long '  Dim y As Long '  ' Dim Value As Double '       '         Dim TargetValue As Double Smoothness = 0 '    For i = 1 To 4 '     For j = 1 To 4 '     If Position(i, j) &gt; 0 Then '   Value = Log(Position(i, j)) / Log(2) If i &lt; 4 Then '       For x = i + 1 To 4 '    If Position(x, j) &gt; 0 Then '    '    TargetValue = Log(Position(x, j)) / Log(2) ',   Smoothness = Abs(Value - TargetValue) '       Exit For End If Next End If If j &lt; 4 Then '       For y = j + 1 To 4 '    If Position(i, y) &gt; 0 Then '    '    TargetValue = Log(Position(i, y)) / Log(2) ',   Smoothness = Abs(Value - TargetValue) '        Exit For End If Next End If End If Next Next ' Dim arrTotals(1 To 4) As Double '     Dim Current As Long '   Dim Next_ As Long '      Dim CurrentValue As Double '      Dim NextValue As Double '        Monotonicity = 0 '    '      For k = 1 To 4 arrTotals(k) = 0 Next ' -  - For x = 1 To 4 '   Current = 1 '      '   (     )  Next_ = Current + 1 Do While Next_ &lt;= 4 '       '      '(       ) Do While Next_ &lt;= 4 '       If Position(x, Next_) = 0 Then '     Next_ = Next_ + 1 '   Else ' -    Exit Do ' ,  ,   End If Loop '         If Next_ &gt; 4 Then Next_ = 4 '          If Position(x, Current) &gt; 0 Then CurrentValue = Log(Position(x, Current)) / Log(2) Else CurrentValue = 0 End If ' MsgBox "Position[" &amp; x &amp; ", " &amp; Next_ &amp; "]=" &amp; Position(x, Next_) If Position(x, Next_) &gt; 0 Then NextValue = Log(Position(x, Next_)) / Log(2) Else NextValue = 0 End If If CurrentValue &gt; NextValue Then '   ? arrTotals(Up) = arrTotals(Up) + NextValue - CurrentValue ElseIf NextValue &gt; CurrentValue Then '   ? arrTotals(Down) = arrTotals(Down) + CurrentValue - NextValue End If Current = Next_ '       Next_ = Next_ + 1 '    Loop Next '      -  - Monotonicity = IIf(arrTotals(Up) &gt;= arrTotals(Down), _ Monotonicity + arrTotals(Up), _ Monotonicity + arrTotals(Down)) ' -  - For y = 1 To 4 '   Current = 1 '      '   (     )  Next_ = Current + 1 Do While Next_ &lt;= 4 '       '      '(       ) Do While Next_ &lt;= 4 '       If Position(Next_, y) = 0 Then '     Next_ = Next_ + 1 '   Else ' -    Exit Do ' ,  ,   End If Loop '         If Next_ &gt; 4 Then Next_ = 4 '          If Position(Current, y) &gt; 0 Then CurrentValue = Log(Position(Current, y)) / Log(2) Else CurrentValue = 0 End If If Position(Next_, y) &gt; 0 Then NextValue = Log(Position(Next_, y)) / Log(2) Else NextValue = 0 End If If CurrentValue &gt; NextValue Then '   ? arrTotals(Left) = arrTotals(Left) + NextValue - CurrentValue ElseIf NextValue &gt; CurrentValue Then '   ? arrTotals(Right) = arrTotals(Right) + CurrentValue - NextValue End If Current = Next_ '       Next_ = Next_ + 1 '    Loop Next '      -  - Monotonicity = IIf(arrTotals(Left) &gt;= arrTotals(Right), _ Monotonicity + arrTotals(Left), _ Monotonicity + arrTotals(Right)) '     EmptyCount = 0 '      MaxValue = 0 '    For i = 1 To 4 '     For j = 1 To 4 '     If Position(i, j) = 0 Then '  ... '...     EmptyCount = EmptyCount + 1 '     ... ElseIf Position(i, j) &gt; MaxValue Then MaxValue = Position(i, j) '...    End If Next Next '   StaticEvaluation = Smoothness * SmoothWeight + _ Monotonicity * MonoWeight + _ Log_Base_Arg(EmptyCount) * EmptyWeight + _ MaxValue * MaxWeight End Function</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Ovolve-Code im Java-Skript</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Grid</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">size</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size = size; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.startTiles = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cells = []; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.build(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.playerTurn = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// pre-allocate these objects (for speed) Grid.prototype.indexes = []; for (var x=0; x&lt;4; x++) { Grid.prototype.indexes.push([]); for (var y=0; y&lt;4; y++) { Grid.prototype.indexes[x].push( {x:x, y:y} ); } } // Build a grid of the specified size Grid.prototype.build = function () { for (var x = 0; x &lt; this.size; x++) { var row = this.cells[x] = []; for (var y = 0; y &lt; this.size; y++) { row.push(null); } } }; // Find the first available random position Grid.prototype.randomAvailableCell = function () { var cells = this.availableCells(); if (cells.length) { return cells[Math.floor(Math.random() * cells.length)]; } }; Grid.prototype.availableCells = function () { var cells = []; var self = this; this.eachCell(function (x, y, tile) { if (!tile) { //cells.push(self.indexes[x][y]); cells.push( {x:x, y:y} ); } }); return cells; }; // Call callback for every cell Grid.prototype.eachCell = function (callback) { for (var x = 0; x &lt; this.size; x++) { for (var y = 0; y &lt; this.size; y++) { callback(x, y, this.cells[x][y]); } } }; // Check if there are any cells available Grid.prototype.cellsAvailable = function () { return !!this.availableCells().length; }; // Check if the specified cell is taken Grid.prototype.cellAvailable = function (cell) { return !this.cellOccupied(cell); }; Grid.prototype.cellOccupied = function (cell) { return !!this.cellContent(cell); }; Grid.prototype.cellContent = function (cell) { if (this.withinBounds(cell)) { return this.cells[cell.x][cell.y]; } else { return null; } }; // Inserts a tile at its position Grid.prototype.insertTile = function (tile) { this.cells[tile.x][tile.y] = tile; }; Grid.prototype.removeTile = function (tile) { this.cells[tile.x][tile.y] = null; }; Grid.prototype.withinBounds = function (position) { return position.x &gt;= 0 &amp;&amp; position.x &lt; this.size &amp;&amp; position.y &gt;= 0 &amp;&amp; position.y &lt; this.size; }; Grid.prototype.clone = function() { newGrid = new Grid(this.size); newGrid.playerTurn = this.playerTurn; for (var x = 0; x &lt; this.size; x++) { for (var y = 0; y &lt; this.size; y++) { if (this.cells[x][y]) { newGrid.insertTile(this.cells[x][y].clone()); } } } return newGrid; }; // Set up the initial tiles to start the game with Grid.prototype.addStartTiles = function () { for (var i=0; i&lt;this.startTiles; i++) { this.addRandomTile(); } }; // Adds a tile in a random position Grid.prototype.addRandomTile = function () { if (this.cellsAvailable()) { var value = Math.random() &lt; 0.9 ? 2 : 4; //var value = Math.random() &lt; 0.9 ? 256 : 512; var tile = new Tile(this.randomAvailableCell(), value); this.insertTile(tile); } }; // Save all tile positions and remove merger info Grid.prototype.prepareTiles = function () { this.eachCell(function (x, y, tile) { if (tile) { tile.mergedFrom = null; tile.savePosition(); } }); }; // Move a tile and its representation Grid.prototype.moveTile = function (tile, cell) { this.cells[tile.x][tile.y] = null; this.cells[cell.x][cell.y] = tile; tile.updatePosition(cell); }; Grid.prototype.vectors = { 0: { x: 0, y: -1 }, // up 1: { x: 1, y: 0 }, // right 2: { x: 0, y: 1 }, // down 3: { x: -1, y: 0 } // left } // Get the vector representing the chosen direction Grid.prototype.getVector = function (direction) { // Vectors representing tile movement return this.vectors[direction]; }; // Move tiles on the grid in the specified direction // returns true if move was successful Grid.prototype.move = function (direction) { // 0: up, 1: right, 2:down, 3: left var self = this; var cell, tile; var vector = this.getVector(direction); var traversals = this.buildTraversals(vector); var moved = false; var score = 0; var won = false; // Save the current tile positions and remove merger information this.prepareTiles(); // Traverse the grid in the right direction and move tiles traversals.x.forEach(function (x) { traversals.y.forEach(function (y) { cell = self.indexes[x][y]; tile = self.cellContent(cell); if (tile) { //if (debug) { //console.log('tile @', x, y); //} var positions = self.findFarthestPosition(cell, vector); var next = self.cellContent(positions.next); // Only one merger per row traversal? if (next &amp;&amp; next.value === tile.value &amp;&amp; !next.mergedFrom) { var merged = new Tile(positions.next, tile.value * 2); merged.mergedFrom = [tile, next]; self.insertTile(merged); self.removeTile(tile); // Converge the two tiles' positions tile.updatePosition(positions.next); // Update the score score += merged.value; // The mighty 2048 tile if (merged.value === 2048) { won = true; } } else { //if (debug) { //console.log(cell); //console.log(tile); //} self.moveTile(tile, positions.farthest); } if (!self.positionsEqual(cell, tile)) { self.playerTurn = false; //console.log('setting player turn to ', self.playerTurn); moved = true; // The tile moved from its original cell! } } }); }); //console.log('returning, playerturn is', self.playerTurn); //if (!moved) { //console.log('cell', cell); //console.log('tile', tile); //console.log('direction', direction); //console.log(this.toString()); //} return {moved: moved, score: score, won: won}; }; Grid.prototype.computerMove = function() { this.addRandomTile(); this.playerTurn = true; } // Build a list of positions to traverse in the right order Grid.prototype.buildTraversals = function (vector) { var traversals = { x: [], y: [] }; for (var pos = 0; pos &lt; this.size; pos++) { traversals.x.push(pos); traversals.y.push(pos); } // Always traverse from the farthest cell in the chosen direction if (vector.x === 1) traversals.x = traversals.x.reverse(); if (vector.y === 1) traversals.y = traversals.y.reverse(); return traversals; }; Grid.prototype.findFarthestPosition = function (cell, vector) { var previous; // Progress towards the vector direction until an obstacle is found do { previous = cell; cell = { x: previous.x + vector.x, y: previous.y + vector.y }; } while (this.withinBounds(cell) &amp;&amp; this.cellAvailable(cell)); return { farthest: previous, next: cell // Used to check if a merge is required }; }; Grid.prototype.movesAvailable = function () { return this.cellsAvailable() || this.tileMatchesAvailable(); }; // Check for available matches between tiles (more expensive check) // returns the number of matches Grid.prototype.tileMatchesAvailable = function () { var self = this; //var matches = 0; var tile; for (var x = 0; x &lt; this.size; x++) { for (var y = 0; y &lt; this.size; y++) { tile = this.cellContent({ x: x, y: y }); if (tile) { for (var direction = 0; direction &lt; 4; direction++) { var vector = self.getVector(direction); var cell = { x: x + vector.x, y: y + vector.y }; var other = self.cellContent(cell); if (other &amp;&amp; other.value === tile.value) { return true; //matches++; // These two tiles can be merged } } } } } //console.log(matches); return false; //matches; }; Grid.prototype.positionsEqual = function (first, second) { return first.x === second.x &amp;&amp; first.y === second.y; }; Grid.prototype.toString = function() { string = ''; for (var i=0; i&lt;4; i++) { for (var j=0; j&lt;4; j++) { if (this.cells[j][i]) { string += this.cells[j][i].value + ' '; } else { string += '_ '; } } string += '\n'; } return string; } // counts the number of isolated groups. Grid.prototype.islands = function() { var self = this; var mark = function(x, y, value) { if (x &gt;= 0 &amp;&amp; x &lt;= 3 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt;= 3 &amp;&amp; self.cells[x][y] &amp;&amp; self.cells[x][y].value == value &amp;&amp; !self.cells[x][y].marked ) { self.cells[x][y].marked = true; for (direction in [0,1,2,3]) { var vector = self.getVector(direction); mark(x + vector.x, y + vector.y, value); } } } var islands = 0; for (var x=0; x&lt;4; x++) { for (var y=0; y&lt;4; y++) { if (this.cells[x][y]) { this.cells[x][y].marked = false } } } for (var x=0; x&lt;4; x++) { for (var y=0; y&lt;4; y++) { if (this.cells[x][y] &amp;&amp; !this.cells[x][y].marked) { islands++; mark(x, y , this.cells[x][y].value); } } } return islands; } // measures how smooth the grid is (as if the values of the pieces // were interpreted as elevations). Sums of the pairwise difference // between neighboring tiles (in log space, so it represents the // number of merges that need to happen before they can merge). // Note that the pieces can be distant Grid.prototype.smoothness = function() { var smoothness = 0; for (var x=0; x&lt;4; x++) { for (var y=0; y&lt;4; y++) { if ( this.cellOccupied( this.indexes[x][y] )) { var value = Math.log(this.cellContent( this.indexes[x][y] ).value) / Math.log(2); for (var direction=1; direction&lt;=2; direction++) { var vector = this.getVector(direction); var targetCell = this.findFarthestPosition(this.indexes[x][y], vector).next; if (this.cellOccupied(targetCell)) { var target = this.cellContent(targetCell); var targetValue = Math.log(target.value) / Math.log(2); smoothness -= Math.abs(value - targetValue); } } } } } return smoothness; } Grid.prototype.monotonicity = function() { var self = this; var marked = []; var queued = []; var highestValue = 0; var highestCell = {x:0, y:0}; for (var x=0; x&lt;4; x++) { marked.push([]); queued.push([]); for (var y=0; y&lt;4; y++) { marked[x].push(false); queued[x].push(false); if (this.cells[x][y] &amp;&amp; this.cells[x][y].value &gt; highestValue) { highestValue = this.cells[x][y].value; highestCell.x = x; highestCell.y = y; } } } increases = 0; cellQueue = [highestCell]; queued[highestCell.x][highestCell.y] = true; markList = [highestCell]; markAfter = 1; // only mark after all queued moves are done, as if searching in parallel var markAndScore = function(cell) { markList.push(cell); var value; if (self.cellOccupied(cell)) { value = Math.log(self.cellContent(cell).value) / Math.log(2); } else { value = 0; } for (direction in [0,1,2,3]) { var vector = self.getVector(direction); var target = { x: cell.x + vector.x, y: cell.y+vector.y } if (self.withinBounds(target) &amp;&amp; !marked[target.x][target.y]) { if ( self.cellOccupied(target) ) { targetValue = Math.log(self.cellContent(target).value ) / Math.log(2); if ( targetValue &gt; value ) { //console.log(cell, value, target, targetValue); increases += targetValue - value; } } if (!queued[target.x][target.y]) { cellQueue.push(target); queued[target.x][target.y] = true; } } } if (markAfter == 0) { while (markList.length &gt; 0) { var cel = markList.pop(); marked[cel.x][cel.y] = true; } markAfter = cellQueue.length; } } while (cellQueue.length &gt; 0) { markAfter--; markAndScore(cellQueue.shift()) } return -increases; } // measures how monotonic the grid is. This means the values of the tiles are strictly increasing // or decreasing in both the left/right and up/down directions Grid.prototype.monotonicity2 = function() { // scores for all four directions var totals = [0, 0, 0, 0]; // up/down direction for (var x=0; x&lt;4; x++) { var current = 0; var next = current+1; while ( next&lt;4 ) { while ( next&lt;4 &amp;&amp; !this.cellOccupied( this.indexes[x][next] )) { next++; } if (next&gt;=4) { next--; } var currentValue = this.cellOccupied({x:x, y:current}) ? Math.log(this.cellContent( this.indexes[x][current] ).value) / Math.log(2) : 0; var nextValue = this.cellOccupied({x:x, y:next}) ? Math.log(this.cellContent( this.indexes[x][next] ).value) / Math.log(2) : 0; if (currentValue &gt; nextValue) { totals[0] += nextValue - currentValue; } else if (nextValue &gt; currentValue) { totals[1] += currentValue - nextValue; } current = next; next++; } } // left/right direction for (var y=0; y&lt;4; y++) { var current = 0; var next = current+1; while ( next&lt;4 ) { while ( next&lt;4 &amp;&amp; !this.cellOccupied( this.indexes[next][y] )) { next++; } if (next&gt;=4) { next--; } var currentValue = this.cellOccupied({x:current, y:y}) ? Math.log(this.cellContent( this.indexes[current][y] ).value) / Math.log(2) : 0; var nextValue = this.cellOccupied({x:next, y:y}) ? Math.log(this.cellContent( this.indexes[next][y] ).value) / Math.log(2) : 0; if (currentValue &gt; nextValue) { totals[2] += nextValue - currentValue; } else if (nextValue &gt; currentValue) { totals[3] += currentValue - nextValue; } current = next; next++; } } return Math.max(totals[0], totals[1]) + Math.max(totals[2], totals[3]); } Grid.prototype.maxValue = function() { var max = 0; for (var x=0; x&lt;4; x++) { for (var y=0; y&lt;4; y++) { if (this.cellOccupied(this.indexes[x][y])) { var value = this.cellContent(this.indexes[x][y]).value; if (value &gt; max) { max = value; } } } } return Math.log(max) / Math.log(2); } // WIP. trying to favor top-heavy distributions (force consolidation of higher value tiles) /* Grid.prototype.valueSum = function() { var valueCount = []; for (var i=0; i&lt;11; i++) { valueCount.push(0); } for (var x=0; x&lt;4; x++) { for (var y=0; y&lt;4; y++) { if (this.cellOccupied(this.indexes[x][y])) { valueCount[Math.log(this.cellContent(this.indexes[x][y]).value) / Math.log(2)]++; } } } var sum = 0; for (var i=1; i&lt;11; i++) { sum += valueCount[i] * Math.pow(2, i) + i; } return sum; } */ // check for win Grid.prototype.isWin = function() { var self = this; for (var x=0; x&lt;4; x++) { for (var y=0; y&lt;4; y++) { if (self.cellOccupied(this.indexes[x][y])) { if (self.cellContent(this.indexes[x][y]).value == 2048) { return true; } } } } return false; } //Grid.prototype.zobristTable = {} //for //Grid.prototype.hash = function() { //}</span></span></code> </pre> </div></div><br><h2>  2048.xlsm </h2><br>  Die Excel-Anwendung selbst <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kann von Google heruntergeladen werden</a> . <br><br>  Die Funktionalit√§t der Anwendung wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in einem fr√ºheren Artikel beschrieben, in dem AI nach der Monte-Carlo-Methode spielt</a> .  Die heutige L√∂sung wurde dem bestehenden Monte Carlo hinzugef√ºgt. <br><br><h3>  Alle Artikel der AI- und 2048-Serie </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Monte Carlo</a> </li><li>  <strong>Minimax + Alpha-Beta-Ausschnitt</strong> </li><li>  Warten auf Maximum </li><li>  Neuronales Netz </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de474680/">https://habr.com/ru/post/de474680/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de474668/index.html">GitHub-Aktionen als CI / CD f√ºr eine Site auf einem statischen Generator und GitHub-Seiten</a></li>
<li><a href="../de474672/index.html">Reagieren, JSX, Importieren von ES-Modulen (auch dynamisch) in einen Browser ohne Webpack</a></li>
<li><a href="../de474674/index.html">Bildverarbeitung und Medizin</a></li>
<li><a href="../de474676/index.html">Der Interaktionsalgorithmus von Hunderttausenden eindeutigen Partikeln auf der GPU in GLES3 und WebGL2</a></li>
<li><a href="../de474678/index.html">Die Khronos Group hat ein einheitliches Repository mit Vulkan-Beispielen erstellt</a></li>
<li><a href="../de474686/index.html">Fantastische Geschichte "Erl√∂sung" (10 Min.)</a></li>
<li><a href="../de474688/index.html">Retro Zug mit einer Dampflokomotive</a></li>
<li><a href="../de474690/index.html">Erstellen einer Konsole mit variabler H√∂he f√ºr komfortableres Arbeiten am Computer</a></li>
<li><a href="../de474692/index.html">Skaffold Review f√ºr Kubernetes Development</a></li>
<li><a href="../de474694/index.html">Wie wir das Framework f√ºr Leistungstests ausgew√§hlt und verdreht haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>