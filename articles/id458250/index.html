<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆕 💅🏽 🤳🏼 BTRFS untuk yang terkecil 💃🏼 🦕 🏯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selamat siang, Khabravchane. Saya bekerja di Veeam Software dan saya adalah salah satu pengembang solusi cadangan Linux kami. Berdasarkan pekerjaan, s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>BTRFS untuk yang terkecil</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/veeam/blog/458250/"> Selamat siang, Khabravchane.  Saya bekerja di Veeam Software dan saya adalah salah satu pengembang solusi cadangan Linux kami.  Berdasarkan pekerjaan, saya kebetulan bertemu BTRFS.  Baru-baru ini, telah beralih dari status "belum cocok" ke status "stabil".  Dan sementara pengguna pertamanya di jaringan mendiskusikan masalah area dan masalah stabilitas, kami di Veeam menyodoknya dengan tongkat dan mencoba untuk mencadangkannya.  Ternyata, secara halus, tidak terlalu banyak - itu terlalu berbeda, tidak seperti sistem file tradisional.  Saya harus mempelajari banyak aspek dan mengumpulkan banyak garu sebelum kami belajar bagaimana cara menggunakannya.  Dalam proses belajar, BTRFS berhasil membuat saya terkesan, baik dengan cara yang baik maupun tidak.  Saya yakin dia tidak akan meninggalkan acuh tak acuh spesialis IT dari dunia Linux: beberapa akan meludah, yang lain akan memuji. <br><br>  Jika Anda pernah mendengar tentang sistem file ini, tetapi tidak tahu mengapa, tertarik pada detailnya, atau mencari di mana harus mulai mengetahuinya, saya mengundang Anda ke kucing. <br><a name="habracut"></a><br><h1>  Pendahuluan </h1><br>  BTRFS (B-Tree Filesystem) - sistem file untuk sistem operasi mirip Unix, berdasarkan teknik Copy on Write (CoW), yang dirancang untuk memberikan kemudahan penskalaan sistem file, keandalan dan keamanan data tingkat tinggi, fleksibilitas konfigurasi dan kemudahan administrasi, dengan tetap mempertahankan pada saat yang sama kecepatan tinggi.  Setidaknya itulah yang dikatakan halaman <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">utama wiki</a> . <br><br>  Untuk mematuhi formalitas, kami mencantumkan fitur utama btrf: <br><br><ul><li>  Ukuran file maksimum 2 ^ 64 byte <br></li><li>  Tabel inode dinamis <br></li><li>  Deduplikasi data <br></li><li>  Penyimpanan file yang efektif baik ukurannya sangat kecil dan sangat besar <br></li><li>  Membuat Subwolums dan Snapshots <br></li><li>  Subvolume Quota <br></li><li>  Checksum untuk data dan metadata <br></li><li>  Kemampuan untuk menggabungkan beberapa drive menjadi satu sistem file <br></li><li>  Membuat konfigurasi RAID di tingkat sistem file <br></li><li>  Kompresi data <br></li><li>  Defragmentasi data dengan cepat <br></li></ul><br>  Saya ingin segera memperingatkan Anda bahwa BTRFS sedang aktif berkembang, dan beberapa poin mungkin berbeda dari versi ke versi.  Tautan - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://btrfs.wiki.kernel.org/index.php/Changelog,</a> Anda dapat mengetahui kapan fungsionalitas ditambahkan, diubah, atau diperbaiki. <br><br>  Ya, BTRFS adalah sistem file muda dan modern yang menyelesaikan berbagai tugas, tetapi tidak tanpa kekurangannya: <br><br><ul><li>  Pengembangan aktifnya mengarah pada perubahan pada poin-poin penting yang dapat diandalkan utilitas pihak ketiga saat bekerja dengannya. <br></li><li>  Meskipun ada jaminan dari pengembang tentang stabilitas BTRFS, pengguna secara teratur menghadapi masalah yang berpotensi menyebabkan hilangnya data.  Sebagai aturan, mereka "mengambang" di alam, sebagai akibatnya mereka belum dipelajari dan diperbaiki. <br></li><li>  Kerentanan tinggi terhadap fragmentasi. <br></li><li>  Dokumentasi yang minim dan terkadang ketinggalan jaman. <br></li></ul><br>  Seluruh halaman dikhususkan untuk masalah sistem file pada versi yang berbeda dari kernel - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://btrfs.wiki.kernel.org/index.php/Gotcha</a> .  Saya sangat menyarankan Anda untuk melihat di sana - ternyata banyak yang menarik dan tidak jelas. <br><br><h1>  Struktur BTRFS </h1><br>  Perangkat BTRFS yang disederhanakan dapat dibagi ke dalam level berikut: <br><br><img src="https://habrastorage.org/webt/zz/n8/zj/zzn8zjyt0dai6ge9rifhgcdwg0q.png"><br><br>  Perangkat blok terletak di tingkat terendah, mewakili satu atau beberapa ruang alamat fisik yang terpisah ("fisik" yang sama dengan perangkat blok itu sendiri, tetapi ini sudah detail).  Melalui struktur khusus, blok memori fisik yang dialokasikan digabungkan menjadi satu ruang alamat virtual. <br><br>  Struktur dan blok metadata dengan data pengguna (luasan) sudah ditangani pada tingkat logis.  Akibatnya, data yang ditempatkan secara berurutan pada tingkat logis dapat secara fisik berada pada perangkat blok yang berbeda. <br><br>  Struktur metadata dapat dibagi menjadi beberapa tingkatan.  Tentu saja, saya tidak akan mengklasifikasikan mereka - ada banyak dari mereka, dan rincian tingkat rendah seperti itu adalah topik dari artikel terpisah.  Penting di sini bahwa beberapa struktur dalam hierarki akan berubah menjadi tingkat yang lebih tinggi daripada yang lain, dan di bagian paling atas akan ada struktur yang merupakan subvolume. <br><br>  Subvolume adalah semacam titik masuk, atau lebih tepatnya, elemen root dari sistem file.  Mereka membentuk lapisan representasi data yang terpisah, yang merangkum pekerjaan lapisan bawah, menyajikan data pengguna dalam bentuk biasa: direktori dan file.  Selain itu, subwolves adalah elemen kunci dari mekanisme KK pada BTRFS.  File yang sama dalam dua subvolume mungkin berubah menjadi set data yang sama di tingkat bawah. <br><br>  Lapisan terakhir adalah lapisan data.  Seperti yang dilihat pengguna.  Ini adalah file dan direktori yang terletak di subvolume. <br><br>  Tapi cukup teori.  Sudah waktunya untuk melanjutkan berlatih! <br><br><h1>  Btrfs-prog </h1><br>  Ini adalah seperangkat utilitas standar untuk mengelola BTRFS.  Bergantung pada paket distribusi, paket dengan utilitas ini di repositori mungkin memiliki nama yang berbeda: <b>btrfsprogs</b> , <b>btrfs-progs</b> , <b>btrfs-tools</b> , dll.  Jika repositori Anda tidak memiliki yang serupa, Anda selalu dapat mengompilasinya secara manual, sumbernya tidak jauh - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/kdave/btrfs-progs</a> . <br>  Utilitas yang paling penting dalam paket ini adalah <b>btrfs</b> dan <b>mkfs.btrfs</b> .  Dari yang kedua, saya pikir, semuanya sangat jelas - perlu untuk membuat BTRFS pada perangkat blok.  Pertama, <b>btrfs</b> adalah utilitas utama yang memungkinkan Anda melakukan sisanya.  Semacam "pisau Swiss." <br><br>  Pada artikel ini, saya menggunakan versi v4.15.1.  Utilitas berkembang sangat aktif, dan ada perbedaan nyata dari versi ke versi.  Jadi jika Anda tidak memiliki perintah yang diperlukan, periksa versi utilitas <b>btrf</b> , mungkin sudah ketinggalan zaman. <br><br>  Juga, kemungkinan besar, utilitas <b>btrfsck</b> dan <b>btrfstune</b> ditemukan dalam paket. <br><br><ul><li>  Yang pertama dari mereka berfungsi untuk memeriksa kesalahan sistem file dan untuk koreksi selanjutnya, namun, saya tidak merekomendasikan menggunakannya - itu dalam status <i>usang</i> , fungsinya telah dipindahkan ke perintah <b>cek btrfs</b> . </li><li>  Yang kedua memungkinkan Anda untuk melakukan beberapa operasi yang bermanfaat pada btrfs, misalnya, mengubah pengidentifikasi unik sistem file (FS UUID), atau mengaktifkan fungsionalitas tertentu dari sistem file. </li></ul><br>  Selain utilitas yang tercantum di atas, ada beberapa utilitas lagi dalam paket, tetapi mereka terutama diperlukan untuk debugging btrfs dan tidak akan berguna bagi kami dalam artikel ini. <br><br><h1>  Memformat disk di BTRFS </h1><br>  Dalam praktiknya, semuanya lebih sederhana.  Mari kita mulai dengan satu drive. <br>  Memformat disk tunggal dalam btrfs terjadi dengan perintah biasa: <br><br><pre><code class="bash hljs">mkfs.btrfs /dev/sdc -L single_drive</code> </pre> <br>  Sebagai tanggapan, utilitas akan menampilkan parameter sistem file yang dibuat ke konsol: <br><br><pre> <code class="bash hljs">btrfs-progs v4.15.1 See http://btrfs.wiki.kernel.org <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> more information. Label:       single_drive UUID:        59307d69-6d2f-4d2e-aae2-a5189ad3c256 Node size:     16384 Sector size:    4096 Filesystem size:  1.00GiB Block group profiles: Data:       single 8.00MiB Metadata:     DUP 51.19MiB System:      DUP 8.00MiB SSD detected:    no Incompat features: extref, skinny-metadata Number of devices: 1 Devices:  ID    SIZE PATH   1   1.00GiB /dev/sdc</code> </pre><br>  Mari kita lihat parameter yang disajikan. <br><br><ul><li>  <b>Label</b> - Label atau nama sistem file.  Ini ditentukan oleh saklar <code>-L</code> dan merupakan parameter opsional. </li><li>  <b>UUID</b> adalah pengidentifikasi unik yang membuat kernel btrf membedakan instance dari satu sama lain. </li><li>  <b>Ukuran simpul</b> - ukuran elemen B-tree tempat metadata disimpan.  Ini dapat diatur menggunakan <code>-n | --nodesize</code>  <code>-n | --nodesize</code> , dan itu harus kelipatan dari ukuran ukuran <b>Sektor</b> .  Ukuran simpul yang kecil menyebabkan peningkatan ketinggian pohon-B (peningkatan jumlah simpul) dan, sebagai akibatnya, terjadi penurunan kompetisi untuk memblokir simpul individu.  Di sisi lain, ukuran simpul yang kecil membuat instance sistem file lebih rentan terhadap fragmentasi.  Node besar, di sisi lain, berkontribusi pada pengemasan metadata yang lebih baik pada disk, yang mengurangi fragmentasi. <br>  Kelemahannya adalah peningkatan waktu akses data untuk memperbarui simpul yang sama dengan banyak utas.  Pada kernel yang lebih tua dari 3.11, secara default, ukuran node adalah 16384 byte atau ukuran halaman memori OS (lebih besar dari kedua nilai ini). </li><li>  <b>Ukuran sektor</b> - jumlah ruang yang merupakan kelipatan dari ruang mana yang dialokasikan dan dibebaskan pada tingkat fisik.  Ini sama dengan ukuran halaman dari memori virtual OS, kecuali ditentukan lain dengan <code>-s</code> . </li><li>  <b>Ukuran Filesystem</b> - total kapasitas sistem file (data plus metadata).  Diatur secara manual dengan <code>-b</code> switch.  Secara default, seluruh volume perangkat blok ditempati. </li><li>  <b>Fitur Incompat</b> - daftar fitur yang disertakan pada btrf yang dibuat yang merusak kompatibilitas dengan versi kernel yang lebih lama.  Jika kompatibilitas diperlukan, maka Anda dapat menonaktifkan: <br><br><pre> <code class="bash hljs">--features ^extref,^skinny-metadata.</code> </pre> <br>  Omong-omong, Anda dapat memeriksa fitur apa yang didukung kernel saat ini dengan panggilan berikut: <br><br><pre> <code class="bash hljs">mkfs.btrfs --features list-all</code> </pre> </li><li>  <b>Jumlah perangkat dan Perangkat</b> - berapa banyak perangkat blok yang terlibat dalam instance btrfs yang dibuat, dan daftar semua perangkat, masing-masing. </li><li>  Kita juga harus berbicara tentang parameter <b>Profil Grup Blok</b> .  Ini menunjukkan profil rekaman yang berlaku untuk masing-masing dari tiga tipe data: Data, Metadata, dan Sistem.  Kembali ke struktur umum btrf, kita dapat mengatakan bahwa: <br><br><ul><li>  Data adalah data pengguna; </li><li>  Metadata adalah kombinasi dari lapisan subvolume dan lapisan metadata dan luasan; </li><li>  Sistem adalah struktur untuk memetakan ruang alamat memori fisik ke ruang terus menerus dari alamat logis. </li></ul><br>  Profil rekaman adalah cara menyimpan data di tingkat fisik: <br><br><ul><li>  Penyimpanan data tunggal dalam satu salinan; </li><li>  DUP - duplikasi data pada satu media; </li><li>  RAIDX adalah salah satu konfigurasi RAID0, RAID1, RAID10, RAID5 dan RAID6. </li></ul><br></li></ul><br>  Saat menandai satu perangkat blok, btrf akan menerapkan duplikasi ke metadata dan data sistem secara default, dan data pengguna akan tetap ada di media dalam satu salinan.  Membuat btrf pada beberapa disk sekaligus akan menerapkan profil "RAID0" ke data pengguna secara default, dan "RAID1" ke metadata. <br>  Kelompok parameter ini dikendalikan menggunakan dua kunci: <code>-d</code> untuk data dan <code>-m</code> untuk metadata dan data sistem. <br><br>  Tapi ada nuansa ... Ada yang berbeda dengan SSD.  Faktanya adalah jika kita menandai drive SSD (atau flash drive), maka secara default sistem file tidak akan menduplikasi metadata.  SSD dapat memperpanjang deduplikasi data untuk memperpanjang masa pakai elemen memori.  Yaitu  memiliki dua salinan logis dari data, pada kenyataannya hanya satu yang akan direkam pada media.  Akibatnya, ketika segmen memori gagal, "kedua salinan" dari data akan rusak.  Selain itu, dengan menulis data dua kali, sumber daya SSD dikonsumsi lebih cepat. <br><br>  Untuk menentukan jenis media, btrfs memeriksa konten file <i>/ sys / block / DEV / antrian / rotasi</i> , di mana "DEV" adalah nama perangkat blok yang sedang diperiksa. <br>  Tentu saja, bahkan dalam kasus SSD, profil penyimpanan dapat dipaksa. <br><br>  Untuk membuat instance btrfs di beberapa perangkat, cukup tentukan dengan spasi: <br><br><pre> <code class="bash hljs">sudo mkfs.btrfs /dev/sdc /dev/sdd -L double_drive</code> </pre> <br>  atau dengan profil: <br><br><pre> <code class="bash hljs">sudo mkfs.btrfs /dev/sdc /dev/sdd -d raid1 -m raid1 -L raid1_drive</code> </pre> <br>  Perlu dicatat bahwa media tidak harus memiliki ukuran yang sama, bahkan jika mirroring penuh digunakan.  Namun, segera setelah tidak ada cukup ruang pada drive terkecil untuk mengalokasikan memori, sistem file akan menampilkan pesan yang menunjukkan bahwa tidak ada ruang kosong, meskipun secara fisik mungkin masih ada ruang kosong di media lain. <br><br><h1>  Pemasangan </h1><br>  Mount pertama dari btrf yang baru dibuat tidak berbeda dari sistem file lain: <br><br><pre> <code class="bash hljs">mount /dev/sdc /mnt</code> </pre> <br>  Jika sistem file terletak pada beberapa disk, maka untuk pemasangan cukup untuk menentukan salah satu dari mereka. <br><br>  Secara umum, pemasangan btrf selalu melibatkan pemasangan satu atau lebih dari subvolume-nya.  Jika perintah mount tidak ditentukan subvolume mana yang harus dipasang, maka btrfs akan membaca dari catatan khusus ID subvolume, yang harus dipasang secara default.  Entri ini nantinya dapat diubah dengan perintah <code>btrfs set-default</code> , tetapi ketika Anda pertama kali memasangnya pada btrfs, hanya ada satu subvolume - root.  Ia ditentukan secara default untuk pemasangan. <br><br>  Root subworld di btrfs selalu ada.  Itu muncul bersama dengan sistem file dan tidak mengalami perubahan apa pun di masa depan. <br><br>  Ada dua cara untuk memasang subvolume selain yang default: <br>  tentukan path dari root subvolume btrfs: <br><br><pre> <code class="bash hljs">mount -o subvol=/path/to/subvol /dev/sdc /mnt</code> </pre> <br>  tentukan ID subvolume: <br><br><pre> <code class="bash hljs">mount -o subvolid=257 /dev/sdc /mnt</code> </pre> <br>  Seperti yang telah disebutkan, salah satu subvolume btrf ditentukan secara default.  Cari tahu mana yang mungkin dengan melakukan: <br><br><pre> <code class="bash hljs">btrfs subvolume get-default /path/to/any/subvolume</code> </pre> <br>  Untuk menginstal submount default, Anda dapat menggunakan perintah: <br><br><pre> <code class="bash hljs">btrfs subvolume <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-default 258 /path/to/any/subvolume</code> </pre> <br>  Path ke subvolume dalam kasus ini diperlukan hanya untuk menunjukkan contoh btrfs spesifik yang digunakan perintah.  Omong-omong, ini tidak harus menjadi subworld, jalur ke direktori mana pun juga cocok. <br><br>  Perintah <code>mount</code> menerima sejumlah besar opsi untuk mengendalikan kapabilitas btrf: defragmentasi, flushing cache, kompresi, cow, logging, balance, dukungan ssd, dan banyak hal lain khusus untuk btrfs.  Saya tidak akan mempertimbangkannya dalam kerangka artikel ini, karena  mereka diperlukan untuk memperbaiki sistem file, dan dalam sebagian besar kasus Anda dapat melakukannya tanpa mereka. <br><br><h1>  Subvolume adalah </h1><br>  Subvolume adalah elemen kunci btrf yang melakukan berbagai fungsi: <br><br><ul><li>  penyimpanan data pengguna dan subvolume lainnya, <br></li><li>  menyediakan akses ke data (pemasangan), <br></li><li>  Mekanisme KK <br></li><li>  membuat snapshot. <br></li></ul><br>  Pada perkiraan pertama, subvolume adalah direktori normal.  Anda dapat mengganti nama / memindahkannya, melihat isinya, menempatkan dan memodifikasi file di dalamnya.  Tidak diperlukan utilitas khusus. <br><br>  Membuat dan menghapus subvolume dilakukan pada btrf yang terpasang menggunakan perintah khusus: <br><br><pre> <code class="bash hljs">btrfs subvolume create /mnt/subvolume_name btrfs subvolume delete /mnt/subvolume_name</code> </pre> <br>  Saya perhatikan bahwa jika Anda mencoba untuk menghapus subvolume menggunakan manajer file atau utilitas <b>rm</b> , operasi akan berakhir dengan <i>operasi yang tidak diizinkan</i> kesalahan (operasi tidak diperbolehkan). <br><br>  <b>UPD:</b> Dimulai dengan kernel versi 4.18.0, sub-volley dapat dihapus menggunakan utilitas <b>rm</b> atau alat manajer file.  Rupanya, itu adalah bug, bukan fitur.  Terima kasih kepada Prototik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">habravchanin</a> untuk klarifikasi. <br><br>  Setelah membuat subvolume, Anda dapat melihat propertinya: <br><br><pre> <code class="bash hljs">btrfs subvolume show /mnt/subvolume_name Name:          subx UUID:          09af45e8-d2b2-b342-8a92-fa270ac82d0a Parent UUID:      - Received UUID:     - Creation time:     2019-03-23 17:59:28 +0100 Subvolume ID:      268 Generation:       39 Gen at creation:    35 Parent ID:       260 Top level ID:      260 Flags:         - Snapshot(s):</code> </pre> <br>  Mari kita mempelajari sifat-sifat utama dari subwolume: <br><br><ul><li>  <b>Nama</b> - nama subvolume <br></li><li>  <b>UUID</b> adalah pengidentifikasi unik universal yang berfungsi terutama untuk menentukan hubungan subwoofer-snapshot, <br></li><li>  <b>Parent UUID</b> - pengidentifikasi leluhur subvolume dari mana leluhur saat ini diturunkan, <br></li><li>  <b>Menerima UUID</b> - pengidentifikasi leluhur subvolume yang dikirim melalui <i>btrfs send</i> , <br></li><li>  <b>Subvolume ID</b> - pengidentifikasi unik untuk penempatan di B-tree, <br></li><li>  <b>Pembuatan</b> - nomor transaksi pada pembaruan terakhir dari metadata subvolume, <br></li><li>  <b>Gen at creation</b> - nomor transaksi pada saat subvolume dibuat, <br></li><li>  <b>ID Induk</b> - pengidentifikasi dari subvolume di mana yang saat ini tertanam, <br></li><li>  <b>ID tingkat atas</b> persis sama dengan ID Induk, <br></li><li>  <b>Bendera</b> - bendera (sebenarnya hanya 1 bendera yang dapat <i>dibaca</i> ), <br></li><li>  <b>Snapshots</b> - daftar snapshot yang diambil dari subvolume ini. <br></li></ul><br>  Subvolume memiliki satu parameter lagi - ini adalah path-nya dari btrf elemen root.  Path ditampilkan saat mendaftar subvolume: <br><br><pre> <code class="plaintext hljs">btrfs subvolume list /path/to/any/btrfs/mountpoint</code> </pre> <br>  Tapi di sini semuanya sederhana dan jelas - bahkan tidak masuk akal untuk membawa output dari perintah. <br>  Seperti halnya dengan perintah <code>get-default</code> dan <code>set-default</code> , di sini Anda dapat menentukan path ke subvolume apa pun, hasilnya tidak akan berubah.  Jalur ini digunakan untuk menemukan root subbolum btrfs.  Setelah itu seluruh pohon subwolum dibaca. <br><br>  Jika Anda mencoba menyalin subvolume, misalnya, dengan utilitas <b>cp</b> , operasi salin akan berhasil, tetapi sebagai hasilnya, bukan subvolume yang akan dibuat, tetapi direktori yang biasa.  Namun, btrfs menyediakan alat yang jauh lebih fleksibel untuk membuat salinan seperti itu - snapshot. <br><br><h1>  Snapshot adalah </h1><br>  Snapshot juga merupakan subworld, hanya memiliki properti tingkat lanjut. <br><br>  Perbedaan utama mereka adalah bahwa foto itu memiliki catatan dari mana subwolum itu diproduksi.  Ini adalah bidang <b>UUID Induk</b> dan <b>Penerimaan UUID</b> .  Di subwoofer, bidang ini juga ada, tetapi selalu kosong.  Jadi, pada kenyataannya, snapshot dan subvolume adalah satu dan sama. <br>  Saat membuat, Anda dapat memblokir snapshot untuk perubahan menggunakan <code>-r</code> switch. <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot -r /path/to/subvol /path/to/snapshot</code> </pre> <br>  Dalam hal ini, file dijamin tetap dalam keadaan di mana mereka dibuat pada saat snapshot dibuat. <br><br>  Bendera read-only juga dapat dikontrol secara manual, ini berfungsi untuk setiap subvolume: <br><br><pre> <code class="plaintext hljs">btrfs property get /path/to/subvol ro btrfs property set /path/to/subvol ro true</code> </pre> <br>  Jika sekarang kita melihat properti snapshot, kita akan melihat isian <b>UUID Induk yang</b> diisi: <br><br><pre> <code class="plaintext hljs">btrfs subvolume show /path/to/snapshot Name:          subx UUID:          d08612d8-596a-11e9-8647-d663bd873d93 Parent UUID:      09af45e8-d2b2-b342-8a92-fa270ac82d0a Received UUID:     - Creation time:     2019-03-23 17:59:28 +0100 Subvolume ID:      269 Generation:       39 Gen at creation:    35 Parent ID:       260 Top level ID:      260 Flags:         - Snapshot(s):</code> </pre> <br>  Fitur penting dari operasi snapshot adalah ia tidak rekursif.  Alih-alih subvolume bersarang, direktori kosong akan dibuat dalam snapshot. <br><br>  Mari kita beralih ke contoh berikut. <br><br>  Pada sistem file ada subwoofer "sub0", di dalamnya ada <i>subAwo subAwo</i> dan direktori <i>dirB</i> .  Di dalamnya masing-masing adalah <i>fileA</i> dan <i>fileB,</i> masing-masing. <br><br>  Hapus foto: <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot sub0 snap0</code> </pre> <br><img src="https://habrastorage.org/webt/cf/or/w-/cforw-vhzoma9iub2hcyejkbh84.png"><br><br>  <i>Snap0</i> snapshot yang <i>dibuat</i> akan mewarisi semua file dan direktori induknya, namun <i>subwoofer</i> subA tidak akan muncul di dalam snapshot.  Alih-alih, hanya direktori kosong yang akan muncul dalam snapshot, mis.  isi <i>subvolume</i> subA tidak akan diwarisi. <br><br>  Di satu sisi, ini bagus - kami menghapus snapshot dari subvolume tertentu, dan semua yang bersarang tidak menarik bagi kami.  Di sisi lain, jika snapshot rekursif diperlukan, maka btrf tidak memiliki solusi untuk masalah ini.  Kita harus mencari putaran pekerjaan. <br><br>  Solusi pertama didasarkan pada kenyataan bahwa foto itu dihapus tanpa bendera read-only, yang memungkinkan Anda untuk memperbaiki situasi dengan cukup sederhana: <br><br><ul><li>  hapus direktori tambahan dari snapshot <br><br><pre> <code class="plaintext hljs">rmdir snap0/subA</code> </pre> <br></li><li>  hapus snapshot dari subvolume bersarang <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot sub0/subA snap0/subA</code> </pre> <br></li></ul><br><img src="https://habrastorage.org/webt/ja/u3/fy/jau3fyzmzjxzxweajh-tmjld-iw.png"><br><br>  Jika snapshot dihapus dengan flag read-only, maka opsi di atas tidak akan berfungsi, karena  di <i>snap0</i> Anda tidak dapat menghapus direktori atau menempatkan snapshot.  Hanya ada satu opsi - letakkan foto di suatu tempat dekat <i>subwoofer</i> snap0: <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot sub0/subA snapA</code> </pre> <br>  dan kemudian <i>pasang snapA</i> di dalam snapshot <i>snap0</i> , direktori untuk ini sudah ada: <br><br><pre> <code class="plaintext hljs">mount -o subvol=snapA snap0/subA</code> </pre> <br><img src="https://habrastorage.org/webt/mu/-w/nn/mu-wnnj0jiyyinnxokz08nuipag.png"><br><br>  Dalam kasus apa pun, penting untuk dipahami bahwa foto rekursif semua akan diambil dalam operasi yang berbeda, pada waktu yang berbeda.  Tidak ada pembicaraan tentang penghapusan atom dari snapshot dari beberapa subvolume. <br><br><h1>  Salin saat menulis </h1><br>  Sedikit tentang pendekatan subvolume dan Kontrak Karya.  Bayangkan sebuah subvolume ada pada sistem file dan sebuah file terletak di dalamnya (ambil kasus ideal - file tidak terfragmentasi).  Selanjutnya, foto dihapus dari subwolly. <br><br><img src="https://habrastorage.org/webt/hg/yo/sl/hgyoslduv5eeenpopaqu3dk7qyw.png"><br><br>  Subvolume baru (snapshot) akan muncul pada sistem file dengan konten yang persis sama dengan subvolume asli.  Proses pembuatan snapshot hampir instan - data file itu sendiri tidak disalin.  Alih-alih, metadata tambahan dibuat, dan snapshot bersama dengan subvolume induk menjadi pemilik file.  Faktanya, hanya ada satu file pada disk, tetapi sekarang file tersebut milik subvolume dan snapshot. <br>  Jika sekarang Anda mengubah file dalam subvolume, maka perubahan tidak akan memengaruhi file dalam snapshot.  Jika bendera hanya baca tidak disetel saat membuat snapshot, maka file dalam snapshot juga dapat dimodifikasi. <br><br><img src="https://habrastorage.org/webt/7n/1e/0t/7n1e0tkdlxsuqkpjmtinix0yiys.png"><br><br>  Secara teknis, ketika file diubah, hanya perubahan ini yang dicatat.  Jadi file sumber akan disimpan pada disk plus beberapa delta yang membedakan file asli dari yang dimodifikasi.  Jika Anda menghapus salah satu subvolume (yang saya maksud adalah snapshot), maka kelebihan data yang tidak lagi digunakan oleh siapa pun akan terhapus dari disk, dan hanya versi file saat ini yang akan tetap berada di disk (dari sudut pandang subvolume yang tersisa). <br><br>  <i>Catatan singkat</i> : Setelah dilepaskan, subwoofer akan menghilang dari mata pengguna secara instan, dan utilitas akan mengembalikan kontrol ke terminal, namun, data pada disk akan dibersihkan oleh proses latar belakang untuk beberapa waktu.  Artinya, tidak seperti penghapusan direktori biasa, tidak perlu menunggu penyelesaian operasi penghapusan yang sebenarnya.  Jika Anda perlu menyinkronkan dengan proses ini dan menunggu sampai selesai, Anda dapat menentukan <code>--commit-after</code> saat memanggil <b>hapus</b> .  Perintah <b>daftar subvolume btrfs</b> , <b>dipanggil</b> dengan <code>-d</code> switch, menampilkan daftar subvolume yang telah dihapus oleh pengguna dan saat ini sedang dalam proses dihapus dari disk. <br><br>  Selain itu, btrfs memungkinkan Anda untuk mengkloning file pada sistem file tanpa menggunakan snapshot.  Ini dilakukan dengan menyalin secara teratur dengan <code>--reflink</code> : <br><br><pre> <code class="plaintext hljs">cp -ax --reflink=always /original/file /copied/file</code> </pre> <br>  Kunci <code>reflink=always</code> memberi tahu sistem file bahwa kita ingin menggunakan mekanisme CoW saat menyalin.  Setelah menyalin, file dapat diubah secara independen satu sama lain, sehingga kami mendapatkan perilaku yang sama seperti setelah membuat snapshot.  Jadi mengapa kita perlu subbolum? <br><br>  Subtolum pada btrf memainkan peran alat kontrol tingkat tinggi untuk seluruh set data: pertama, itu adalah penghapusan snapshot atom dari semua data subvolume (dalam kasus --reflink atomicity hanya pada tingkat file), dan kedua, dimungkinkan untuk melihat siapa yang diwarisi dari , atau dengan cepat "memutar kembali" data yang disetel ke versi sebelumnya, dll <br>  Dengan demikian, btrf menyediakan kemampuan untuk menangkap status file pada titik waktu yang diinginkan, menggunakan subvolume sebagai sarana tingkat tinggi untuk mengelola status ini. <br><br><h1>  Pemulihan Subvolume </h1><br>  Dalam bentangan luas, pertanyaan sering muncul: "Saya punya subwoofer, saya punya snapshot, bagaimana cara membalikkan?"  Pendekatan ini tidak berlaku untuk btrfs, karena  tidak ada kesempatan untuk "memutar kembali subwolly."  Sebaliknya, btrfs menawarkan strategi untuk menggantikan subwolly dengan snapshot-nya.  Memang, mengapa mengembalikan sesuatu, jika snapshot itu sendiri adalah objek yang ingin kita dapatkan dengan mengembalikan. <br><br>  Bayangkan skenario ini: pada btrfs ada subvolume di mana file-file database berada (well, atau data penting lainnya).  Snapshots secara berkala dihapus dari subvolume ini, dan di beberapa titik ada kebutuhan untuk memutar kembali data.  Dalam hal ini, kami cukup menyingkirkan subwolum dan alih-alih mulai menggunakan snapshot yang diambil darinya, atau - jika kami tidak ingin merusak data ini juga - kami menghapus snapshot lain dari snapshot tersebut.  Jika subworld asli tidak dipasang dan digunakan sebagai direktori normal, maka itu harus dihapus atau dipindahkan / diganti namanya, dan snapshot harus diletakkan di tempatnya. <br><br><img src="https://habrastorage.org/webt/sn/os/od/snosodoezxac3a-2s7xzmpqa-js.png"><br><br>  Di konsol, mungkin terlihat seperti ini: <br><br><ul><li>  ganti nama subwolly <br><br><pre> <code class="plaintext hljs">mv the_subvolume the_subvol.old</code> </pre> </li><li>  meletakkan snapshot-nya sebagai pengganti subvolume <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot the_snapshot the_subvolume</code> </pre> </li></ul><br>  Jika subvolume di-mount dan digunakan melalui titik mount, maka itu cukup untuk melepas mount subvolume dan memasang snapshot di tempatnya. <br><br><img src="https://habrastorage.org/webt/4z/mi/sw/4zmisws4w5keyk7mhsr6eaav-ri.png"><br><br><ul><li>  Lepaskan subwoofer <br><br><pre> <code class="plaintext hljs">umount /mnt/</code> </pre> </li><li>  Anda dapat membuat snapshot dari snapshot agar tidak merusak data yang bertahan terakhir: <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot /path/to/snapshot /path/to/snapshot_copy</code> </pre> </li><li>  pasang snapshot: <br><br><pre> <code class="plaintext hljs">mount -o subvol=path/to/snapshot_copy /mnt</code> </pre> </li></ul><br>  Untuk kelengkapan, saya akan coba lagi dan sedikit berbeda.  Subvolume tempat perubahan terjadi adalah cabang <i>utama</i> . <br><br><img src="https://habrastorage.org/webt/gh/pt/m7/ghptm7ykmordfcur4bdddehng6c.jpeg"><br><br>  Saat membuat snapshot, status file pada disk diperbaiki.  Mulai sekarang, foto adalah brunch dari cabang <i>utama</i> .  Semua perubahan lebih lanjut ke <i>utama</i> tidak akan memengaruhi snapshot dengan cara apa pun.  Kembalikan ke snapshot berarti menghentikan penggunaan cabang <i>utama</i> dan sepenuhnya beralih ke brunch.  Cabang <i>utama</i> dapat dihapus jika tidak perlu.  Dengan demikian, btrf secara praktis adalah sistem kontrol versi, tetapi tanpa kemampuan untuk menggabungkan cabang kembali. <br><br><h1>  Pohon sistem file </h1><br>  Salah satu poin tidak jelas yang terkait dengan penggunaan btrfs adalah bagaimana membagi data sistem menjadi subvolume.  Tentu saja, tidak ada pendekatan "benar" untuk masalah ini.  Tetapi ada 3 cara untuk mengatur struktur subvolume: struktur datar, bersarang dan dicampur. <br><br>  Struktur datar berarti bahwa subvolume ditempatkan dalam daftar datar di subvolume root.  Sebagai contoh, Anda dapat memilih root dari sistem file (sebut saja <i>root</i> ), <i>home</i> direktori pengguna, direktori dengan situs <i>/ var / www</i> dan database yang terletak misalnya di <i>/ var / database</i> sebagai subvolum terpisah. <br><br><img src="https://habrastorage.org/webt/ga/yp/ma/gaypma96_mzvjtlwjyh3atw5qgm.png"><br><br>  Untuk kenyamanan, beberapa subvolume dapat ditempatkan di direktori, seperti, misalnya, dalam kasus subvolume <i>var / www</i> . <br><br>  Dengan pendekatan ini, semua subvolume harus dipasang.  Sub <i>root</i> harus memiliki titik mount /, dan di dalamnya berisi direktori <i>home</i> dan <i>var</i> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah pemasangan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ home</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> harus diinstal sabvolyum </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rumah</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan di </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ var / www</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ var / databas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e - sabvolyumy </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">var / www</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basis data</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , masing-masing. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan demikian, pohon btrfs-subvolume dapat secara sewenang-wenang ditampilkan dalam sistem file virtual OS, dan sudah ada cukup untuk itu.</font></font><br><br>  Pro: <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pengguna hanya melihat subvolume yang dipasang, </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mudah untuk mengganti subwoofer (unmount satu, pasang yang lain), </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mudah untuk menghapus subwoofer. </font></font><br></li></ul><br>  Cons: <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mudah bingung tentang di mana menginstalnya, </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk setiap subvolume harus ada entri di fstab, dan jika ada "kembalikan" ke snapshot, maka entri yang sesuai di fstab juga harus diperbarui. </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Struktur bersarang dari subvolume menunjukkan penggunaan sederhana dari subvolume alih-alih beberapa direktori. </font></font><br><br><img src="https://habrastorage.org/webt/v2/41/e5/v241e5bwrguy3_f76frc2k3ygwk.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam hal ini, selain subvolume root, tidak perlu lagi dipasang.</font></font><br><br>  Pro: <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> semua subvolume terlihat, strukturnya mudah dipahami, </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anda tidak perlu memasang apa pun lagi, semuanya seperti dengan sistem file "biasa". </font></font><br></li></ul><br>  Cons: <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> semua subvolume terlihat, mungkin beberapa ingin bersembunyi dari pengguna, </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sulit untuk menghapus / mengganti subwolum (alasan untuk ini adalah subwolves bersarang). </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nah, pendekatan ketiga adalah pendekatan campuran. </font><font style="vertical-align: inherit;">Ini melibatkan kombinasi dari dua yang pertama untuk memaksimalkan manfaat keduanya. </font><font style="vertical-align: inherit;">Namun, ada kemungkinan bahwa pendekatan khusus ini akan mengarah pada struktur yang rumit, sulit untuk diubah, bingung dengan sejumlah besar entri di fstab. </font><font style="vertical-align: inherit;">Itu semua tergantung pada </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ketenangan</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> administrator sistem.</font></font><br><br><img src="https://habrastorage.org/webt/bv/qw/zv/bvqwzvl0wqspgvlaknnd3l9eyqo.png"><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tambah / hapus disk, keseimbangan </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> btrfs menawarkan fungsionalitas luar biasa - kemampuan untuk "menambah panas" perangkat secara langsung selama pengoperasian sistem file: </font></font><br><br><pre> <code class="plaintext hljs">btrfs device add /path/to/device /path/to/btrfs</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Atau hapus: </font></font><br><br><pre> <code class="plaintext hljs">btrfs device remove /path/to/device /path/to/btrfs</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ngomong-ngomong, dalam satu panggilan tambah / hapus Anda dapat menentukan beberapa disk. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekali lagi, path yang ditentukan adalah path ke subvolume dari btrfs dimana perintah akan diterapkan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita periksa berapa banyak dan perangkat blok mana yang di bawah kendali btrfs:</font></font><br><br><pre> <code class="plaintext hljs">btrfs filesystem show /path/to/btrfs Label: none uuid: 52961dda-df84-4e2d-9727-e93e7738df81       Total devices 2 FS bytes used 192.00KiB       devid  1 size 20.00GiB used 132.00MiB path /dev/sdc       devid  2 size 50.00GiB used 0.00B path /dev/sdd</code> </pre><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.00B</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pada bidang yang </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">digunakan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memberitahu kita bahwa disk yang ditambahkan kosong. </font><font style="vertical-align: inherit;">Untuk mengisinya dengan data sesuai dengan profil rekaman, Anda harus menyeimbangkan:</font></font><br><br><pre> <code class="plaintext hljs">btrfs balance start /path/to/btrfs</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perintah </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">balance</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mendistribusikan ulang data pada disk sesuai dengan profil rekaman yang dipilih. Misalnya, dalam kasus RAID1, keseimbangan akan mengarah pada kloning data dari perangkat asli, dalam kasus RAID0, itu akan menyebabkan distribusi data yang lebih merata di dua disk, dll. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai hasil dari keseimbangan, jika sebelumnya ada kekosongan pada disk, maka data pada disk tersebut akan ditulis dengan cara yang lebih padat, mis. defragmentasi akan berubah. Namun, penting untuk dipahami bahwa ini bukan defragmentasi "persis". Dalam hal ini, perintah </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">keseimbangan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak melihat konten logis, tetapi hanya beroperasi pada blok data. Dia tidak memperhatikan fakta bahwa file apa pun tersebar di disk. Sebaliknya, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menyeimbangkan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> transfer blok data dari satu tempat ke tempat lain.</font></font> Yaitu<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">file yang difragmentasi menjadi seimbang akan tetap terfragmentasi setelahnya. Tapi! Fragmentasi pada tingkat blok data masih akan menurun, dan ini dapat digunakan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menghindari kebingungan, katakanlah ini: operasi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">keseimbangan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mengurangi fragmentasi pada tingkat blok data, tetapi tidak memengaruhi fragmentasi file. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, perintah </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">keseimbangan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menyediakan kemampuan untuk mengubah profil perekaman. Misalnya, profil DUP digunakan pada disk, dan setelah menambahkan disk mereka memutuskan untuk membuat RAID1 penuh. Untuk melakukan ini, gunakan filter </font></font><code>convert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="plaintext hljs">btrfs balance start -dconvert=raid1 -mconvert=raid1 /path/to/btrfs</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan </font></font><code>-dconvert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font><font style="vertical-align: inherit;">opsi </font></font><code>-mconvert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, masing-masing profil catatan baru ditetapkan untuk data dan metadata. </font><font style="vertical-align: inherit;">Ada juga opsi -sconvert, yang dirancang untuk mengubah profil penulisan data sistem, namun, Anda juga harus menambahkan sakelar -f (--force) untuk memaksa operasi.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara umum, tujuan utama filter adalah untuk menetapkan aturan operasi keseimbangan: blok mana yang harus diproses dan mana yang tidak boleh disentuh. </font><font style="vertical-align: inherit;">Jadi, misalnya, Anda dapat memengaruhi hanya blok yang direkam dengan profil rekaman tertentu (profil filter), atau blok yang ditempati di atas persentase tertentu (filter penggunaan), atau memengaruhi hanya grup blok yang terkait dengan disk tertentu (filter devida), dll. </font><font style="vertical-align: inherit;">Ngomong-ngomong, mereka masih bisa digabungkan. </font><font style="vertical-align: inherit;">Secara umum, kemampuan filter sangat luas dan terutama diperlukan untuk melakukan keseimbangan data secara selektif.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fragmentasi </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sayangnya, btrfs, karena arsitekturnya, sangat rentan terhadap fenomena seperti fragmentasi. </font><font style="vertical-align: inherit;">Faktanya adalah bahwa data selalu ditulis ke lokasi baru pada disk. </font><font style="vertical-align: inherit;">Bahkan jika Anda membaca file, tidak melakukan apa-apa dengan data dan menulis kembali ke file yang sama, data akan masuk ke area baru pada disk. </font><font style="vertical-align: inherit;">Hal yang sama terjadi jika Anda memperbarui data dalam file hanya sebagian - perubahan ditulis ke area baru pada disk. </font><font style="vertical-align: inherit;">Dengan demikian, perubahan sering file fragmen sangat kuat, meningkatkan "dispersi" fragmen, dalam kasus umum, di beberapa disk. </font><font style="vertical-align: inherit;">Hal ini menyebabkan peningkatan beban pada CPU dan konsumsi memori yang tidak perlu. </font><font style="vertical-align: inherit;">Yang paling terfragmentasi adalah database dan gambar mesin virtual. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat mengevaluasi fragmentasi file menggunakan utilitas </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">filefrag</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (tidak termasuk dalam btrfs-progs). </font></font><br><br><pre> <code class="plaintext hljs">filefrag /path/to/your/file</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini menunjukkan jumlah luasan yang digunakan untuk menyimpan file. </font><font style="vertical-align: inherit;">Sederhananya - semakin sedikit luasan yang terlibat, semakin sedikit file terfragmentasi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada dua metode untuk memerangi fragmentasi pada btrf: defragmentasi dan flag </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Defragmentasi dapat diterapkan ke satu file atau ke subvolume / direktori, termasuk secara rekursif. </font><font style="vertical-align: inherit;">Perintahnya adalah sebagai berikut:</font></font><br><br><pre> <code class="plaintext hljs">btrfs filesystem defragment /path/to/file/or/dir</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya harus mengatakan bahwa tim ini tidak selalu mengarah pada hasil yang diharapkan. </font><font style="vertical-align: inherit;">File-file kecil, sedikit terfragmentasi (10 - 20 extents) setelah defragmentasi dapat dipecah menjadi lebih banyak bagian. </font><font style="vertical-align: inherit;">Selain itu, defragmentasi btrf pada beberapa versi kernel memecah deduplikasi file, menjadikannya salinan fisik yang nyata.</font></font> Yaitu<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foto-foto di tingkat fisik akan menjadi salinan penuh. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara kedua untuk memerangi fragmentasi adalah dengan atribut file </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="plaintext hljs">chattr +C /path/to/file</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atribut </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hanya dapat diatur ke file baru atau kosong. </font><font style="vertical-align: inherit;">Ini menonaktifkan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">salinan pada</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mekanisme </font><i><font style="vertical-align: inherit;">tulis</font></i><font style="vertical-align: inherit;"> , sehingga btrfs akan selalu bekerja dengan area disk tetap saat memperbarui konten file, menulis data dari yang sudah ada (pada tingkat fisik). </font><font style="vertical-align: inherit;">Dari minus dari </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nocow</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - itu juga menonaktifkan memeriksa checksum untuk file ini. </font><font style="vertical-align: inherit;">Dengan kata lain, tidak ada sapi - tidak ada checksum. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentu saja, atur atribut secara manual</font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setiap file adalah tugas tanpa pamrih. Jika flag dari direktori / subvolume ini diset, maka semua file baru yang dibuat di dalamnya akan mewarisi flag secara otomatis. Hal yang sama berlaku untuk direktori bersarang yang dibuat. Jika pada saat atribut dihidupkan data apa pun sudah ada di direktori, ini tidak akan memengaruhi mereka dengan cara apa pun - atribut </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hanya dapat diatur ke file baru atau kosong. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan cara lain untuk mengatur bendera secara otomatis </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adalah dengan memasang sistem file dengan opsi </font></font><code>nodatacow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="plaintext hljs">mount -o subvol=path/to/subvol,nodatacow /dev/sdXX /path/to/mountpoint</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opsi ini akan menyebabkan opsi terhubung secara otomatis </font></font><code>nodatasum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sehingga untuk file yang baru dibuat, checksum tidak akan dihitung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti biasa, ada nuansa: Anda tidak dapat memasang hanya satu subwoofer dengan opsi </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Entah semua subvolume akan memiliki opsi </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, atau tidak ada. Semuanya diputuskan oleh subvolume pertama yang dipasang: jika memiliki opsi yang ditentukan </font></font><code>nodatacow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, maka semua pemasangan berikutnya akan berjalan dengan opsi ini secara otomatis. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Momen tidak jelas muncul jika Anda meletakkan bendera pada file </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan menghapus snapshot dari subvolume di mana file ini berada. Dalam hal ini, btrf mengabaikan flag </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jika lebih dari satu subvolume mengacu pada blok data yang diperbarui. Karena itu, meski ada bendera</font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Ngomong-ngomong, file juga akan mewarisi dalam snapshot), perubahan pada salah satu file akan pergi ke area baru pada disk, dan file akan kembali menjadi terfragmentasi. </font><font style="vertical-align: inherit;">Jika blok data dalam file diperbarui beberapa kali, maka pertama kali itu akan jatuh ke area baru pada disk, dan dengan entri berikutnya akan diperbarui di area baru ini "di tempat".</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Trik dan Gagal </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saat menggunakan btrfs-progs, Anda dapat menghilangkan nama lengkap dari perintah: </font></font><br><br><pre> <code class="plaintext hljs">btrfs sub cre = btrfs subvolume create</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cukup hanya kebetulan karakter pertama, yang secara unik menentukan perintah: </font></font><br><br><pre> <code class="plaintext hljs">su = subvolume, fi = filesystem, ba = balance, de = device;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya pikir prinsipnya jelas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sayangnya, btrfs tidak dapat membuat snapshot dari direktori, tetapi ada solusinya:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> buat subvolume </font></font><br><br><pre> <code class="plaintext hljs">btrfs subvolume create ./subvol</code> </pre> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> salin file dari direktori ke subvolume: </font></font><br><br><pre> <code class="plaintext hljs">cp -ax --reflink=always your/dir/. ./subvol</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kuncinya </font></font><code>reflink=always</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan menggunakan mekanisme Kontrak Karya, mis. </font><font style="vertical-align: inherit;">data tidak akan disalin, tetapi tautan ke sana akan dibuat pada btrf tingkat rendah.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekarang subworld berisi semua file yang ada di direktori, dan Anda dapat menghapus snapshot darinya. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak dapat mengatur </font><font style="vertical-align: inherit;">atribut ke </font><font style="vertical-align: inherit;">file data yang ada. </font><font style="vertical-align: inherit;">Namun, Anda dapat pergi dengan cara berikut:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> buat file kosong </font></font><br><br><pre> <code class="plaintext hljs">touch nocowfile</code> </pre> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> beri dia bendera </font></font><code>nocow</code> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mengalokasikan ruang disk untuk file baru </font></font><br><br><pre> <code class="plaintext hljs">fallocate -l10g nocowfile</code> </pre> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> salin konten file yang ada ke </font></font><br><br><pre> <code class="plaintext hljs">cp -v oldcowfile nocowfile</code> </pre> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika btrf kehabisan ruang, bahkan menghapus file dapat menyebabkan kesalahan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“Tidak ada ruang tersisa di perangkat”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Untuk solusinya, disarankan untuk menghubungkan drive sementara dengan ukuran sebaiknya minimal 1GB ke btrfs. </font><font style="vertical-align: inherit;">Lalu bersihkan datanya. </font><font style="vertical-align: inherit;">Kemudian lepaskan drive sementara. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operasi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">keseimbangan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dijalankan tanpa menentukan profil tulis, secara implisit mengubahnya dari </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dup</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">raid1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Apa, yang kebetulan, tertulis di halaman </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gotchas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ini terjadi setelah menambahkan disk ke btrfs, yang menggunakan profil tulis </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dup</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ingatlah bahwa memformat satu drive dalam btrfs menggunakan profil </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dup</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> default untuk metadata dan data sistem.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mungkin yang paling penting </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hindari membuat klon perangkat blok tingkat rendah dengan btrfs. Menjadi sistem file "pintar", untuk beberapa operasi (paling sering, ketika pemasangan) btrf membaca kembali data sistem pada perangkat blok untuk menemukan semua bagian dari sistem file. Jika dua perangkat blok dengan UUID yang sama ditemukan dalam proses pencarian, maka btrf akan menerimanya sebagai bagian dari instance yang sama. Jika pada saat yang sama kedua perangkat ini ternyata asli dan tiruannya, maka setelah menginstal driver sendiri tahu bagaimana sistem file akan bekerja, tetapi jelas bahwa ini tidak akan berakhir dengan sesuatu yang baik. Dalam kasus terburuk, itu akan menghasilkan korupsi data yang tidak dapat dipulihkan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda benar-benar ingin mengkloning disk dengan btrfs dengan cara tingkat rendah, Anda harus sangat berhati-hati. </font><font style="vertical-align: inherit;">Secara umum, klon tidak boleh terlihat oleh kernel OS sebagai perangkat blok sementara yang asli hadir dalam sistem, dan sebaliknya. </font><font style="vertical-align: inherit;">Dengan ketentuan ini, Anda dapat mengubah UUID klon (baik, atau asli, di sini opsional). </font><font style="vertical-align: inherit;">Utilitas </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">btrfstune</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang datang dengan paket </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">btrfs-progs akan membantu</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="plaintext hljs">btrfstune -u /path/to/device</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan lagi: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">btrfstune</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , menjadi utilitas "pintar", akan mengubah UUID tidak hanya pada disk, tetapi pada seluruh sistem file. </font><font style="vertical-align: inherit;">Ini berarti bahwa ketika dipanggil, ia akan membaca semua perangkat blok untuk mengganti UUID pada semua perangkat yang terkait dengan sistem file.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alih-alih sebuah kesimpulan </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika saat ini Anda tidak mengerti apa-apa - ini normal. Btrfs nontrivial dan mungkin tidak segera menyerah. Setiap kali saya merasa bahwa sekarang saya memahaminya, dia membuat kejutan dan membuatnya memikirkan hal-hal yang ada. Saya tidak bisa mengatakan bahwa saya mengerti segalanya pada saat ini - dalam proses penulisan saya menemukan sesuatu yang baru, walaupun saya sudah menulis berdasarkan pengalaman saya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya akan membandingkan proses penguasaan btrf dengan transisi dari gaya pemrograman prosedural ke yang berorientasi objek. Kesan pertama adalah "wow, betapa mengagumkan", tetapi kemudian Anda terus menulis kode prosedural yang dibungkus dalam kelas.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam artikel itu, saya berusaha untuk tidak menuangkan air - untuk menulis segala sesuatu tentang kasus ini. </font><font style="vertical-align: inherit;">Meskipun demikian, ini ternyata cukup banyak. </font><font style="vertical-align: inherit;">Tetapi jauh dari segalanya adalah mungkin untuk diceritakan - Anda masih dapat menulis dan menulis tentang btrfs. </font><font style="vertical-align: inherit;">Artikel ini hanyalah puncak gunung es. </font><font style="vertical-align: inherit;">Awal mulanya adalah memahami filosofi dan mulai menggunakannya. </font><font style="vertical-align: inherit;">Dan sekarang saatnya untuk mengakhiri. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terima kasih sudah membaca sampai akhir. </font><font style="vertical-align: inherit;">Saya harap tidak lelah. </font><font style="vertical-align: inherit;">Tuliskan di komentar tentang apa lagi yang Anda tertarik untuk tahu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buat cadangan, tuan-tuan. </font><font style="vertical-align: inherit;">Dan biarkan mereka tidak pernah berguna.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458250/">https://habr.com/ru/post/id458250/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458240/index.html">Bagaimana kecerdasan buatan, drone, dan kamera memastikan keamanan jalan dan jembatan</a></li>
<li><a href="../id458242/index.html">Operator pesawat ruang angkasa baru di C ++ 20</a></li>
<li><a href="../id458244/index.html">Daftar tak berujung dan konyol tentang apa yang perlu Anda ketahui agar dapat menggunakan jaringan Wi-Fi publik dengan aman</a></li>
<li><a href="../id458246/index.html">Kebetulan kebetulan dalam hidup, atau ternyata Anda dihadiahi kue di pabrik traktor</a></li>
<li><a href="../id458248/index.html">Sederhanakan Kode Anda Dengan Ilmu Roket: Operator Pesawat Luar Angkasa C ++ 20</a></li>
<li><a href="../id458252/index.html">Model matematika teleskop radio super panjang</a></li>
<li><a href="../id458256/index.html">Bukankah sudah waktunya untuk cuci otak?</a></li>
<li><a href="../id458260/index.html">Cara lain untuk mengoptimalkan gambar buruh pelabuhan untuk aplikasi Java</a></li>
<li><a href="../id458262/index.html">Perancang ruang pertemuan online - pemilihan solusi optimal untuk konferensi video</a></li>
<li><a href="../id458264/index.html">10 prinsip kode dokumentasi diri</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>