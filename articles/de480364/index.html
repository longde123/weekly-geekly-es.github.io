<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üß¢ üë©‚Äçüç≥ üë©üèª‚Äçüç≥ Metaphysik der Abh√§ngigkeitsinjektion üöè üç∑ üéÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Abh√§ngigkeitsinjektion ist eine h√§ufig verwendete Technik in der objektorientierten Programmierung, mit der die Konnektivit√§t von Komponenten redu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Metaphysik der Abh√§ngigkeitsinjektion</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480364/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/bp/ha/dz/bphadz2idyr738uoocd_ykof4zm.png" alt="Bild"></div><br><br>  Die Abh√§ngigkeitsinjektion ist eine h√§ufig verwendete Technik in der objektorientierten Programmierung, mit der die Konnektivit√§t von Komponenten reduziert werden soll.  Bei richtiger Anwendung k√∂nnen Sie nicht nur dieses Ziel erreichen, sondern auch wirklich magische Eigenschaften f√ºr Ihre Anwendungen erzielen.  Wie jede Magie wird diese Technik als eine Reihe von Zauberspr√ºchen wahrgenommen und nicht als rigorose wissenschaftliche Abhandlung.  Dies f√ºhrt zu einer Fehlinterpretation der Ph√§nomene und folglich zum Missbrauch von Artefakten.  In meinem Autorenmaterial schlage ich vor, dass der Leser Schritt f√ºr Schritt, kurz und im Wesentlichen, den logischen Weg von den entsprechenden Grundlagen des objektorientierten Designs bis zur Magie der automatischen Abh√§ngigkeitsinjektion beschreitet. <br><a name="habracut"></a><br>  Das Material basiert auf der Entwicklung des <a href="https://github.com/cylon-v/hypo" rel="nofollow">Hypo IoC-Containers</a> , den ich in einem <a href="https://habr.com/ru/post/474504/">fr√ºheren Artikel erw√§hnt habe</a> .  In Miniatur-Codebeispielen verwende ich Ruby als eine der √ºbersichtlichsten objektorientierten Sprachen, um kurze Beispiele zu schreiben.  Dies sollte Entwicklern in anderen Sprachen keine Probleme bereiten. <br><br><h2>  Stufe 1: Prinzip der Abh√§ngigkeitsinversion </h2><br>  Entwickler im objektorientierten Paradigma sind t√§glich mit der Schaffung von Objekten konfrontiert, die wiederum von anderen Objekten abh√§ngen k√∂nnen.  Dies f√ºhrt zu einem Abh√§ngigkeitsgraphen.  Angenommen, wir haben es mit einem Objektmodell der Form zu tun: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ih/b7/vy/ihb7vyogm2d5rt-ugz_udhskzpy.png" alt="Bild"></div><br>  - ein Abrechnungsservice (InvoiceProcessor) und ein Benachrichtigungsservice (NotificationService).  Der Rechnungsbearbeitungsdienst sendet Benachrichtigungen, wenn bestimmte Bedingungen erf√ºllt sind. Wir werden diese Logik aus dem Geltungsbereich entfernen.  Grunds√§tzlich ist dieses Modell bereits insofern gut, als einzelne Komponenten f√ºr unterschiedliche Verantwortlichkeiten verantwortlich sind.  Das Problem liegt darin, wie wir diese Abh√§ngigkeiten implementieren.  Ein h√§ufiger Fehler besteht darin, eine Abh√§ngigkeit zu initialisieren, in der diese Abh√§ngigkeit verwendet wird: <br><br><pre><code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvoiceProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">process</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice</span></span></span><span class="hljs-class">) </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#      notificationService = NotificationService.new notificationService.notify(invoice.owner) end end</span></span></span></span></code> </pre> <br>  Dies ist ein Fehler angesichts der Tatsache, dass wir eine hohe Konnektivit√§t von logisch unabh√§ngigen Objekten erhalten (High Coupling).  Dies f√ºhrt zu einer Verletzung des Grundsatzes der einheitlichen Verantwortung - ein abh√§ngiges Objekt muss zus√§tzlich zu seiner unmittelbaren Verantwortung seine Abh√§ngigkeiten initialisieren;  und auch die Schnittstelle des Abh√§ngigkeitskonstruktors ‚Äûkennen‚Äú, was zu einem zus√§tzlichen √Ñnderungsgrund f√ºhrt ( <a href="https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html" rel="nofollow">‚Äû√Ñnderungsgrund‚Äú, R. Martin</a> ).  Es ist richtiger, diese Art von Abh√§ngigkeit zu √ºbergeben, die au√üerhalb des abh√§ngigen Objekts initialisiert wurde: <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvoiceProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">initialize</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">notificationService</span></span></span><span class="hljs-class">) @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">notificationService</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">notificationService</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">process</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice</span></span></span><span class="hljs-class">) @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">notificationService</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">notify</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">owner</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">notificationService</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NotificationService</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoiceProcessor</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvoiceProcessor</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">notificationService</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  Dieser Ansatz steht im Einklang mit dem Prinzip der Abh√§ngigkeitsinversion.  Jetzt √ºbertragen wir ein Objekt mit einer Schnittstelle zum Senden von Nachrichten. Der Abrechnungsdienst muss nicht mehr wissen, wie er das Benachrichtigungsdienstobjekt erstellt.  Beim Schreiben von Komponententests f√ºr einen Rechnungsverarbeitungsdienst muss der Entwickler nicht √ºberlegen, wie die Implementierung der Benachrichtigungsdienstschnittstelle durch einen Stub ersetzt werden soll.  In Sprachen mit dynamischer Typisierung wie Ruby k√∂nnen Sie jedes Objekt ersetzen, das der Benachrichtigungsmethode entspricht.  Mit statischer Typisierung wie C # / Java k√∂nnen Sie die INotificationService-Schnittstelle verwenden, f√ºr die es einfach ist, einen Mock zu erstellen.  Das Thema der Abh√§ngigkeitsinversion wurde von Alexander Byndyu <a href="https://blog.byndyu.ru/2009/12/blog-post.html" rel="nofollow">in einem Artikel</a> , der k√ºrzlich sein 10-j√§hriges Bestehen feierte, ausf√ºhrlich beschrieben! <br><br><h2>  Ebene 2: Registrierung verwandter Objekte </h2><br>  Die Anwendung des Prinzips der Abh√§ngigkeitsinversion scheint keine komplizierte √úbung zu sein.  Im Laufe der Zeit treten jedoch aufgrund der zunehmenden Anzahl von Objekten und Beziehungen neue Herausforderungen auf.  NotificationService kann von anderen Diensten als InvoiceProcessor verwendet werden.  Dar√ºber hinaus kann er selbst von anderen Diensten abh√§ngig sein, die wiederum von Dritten abh√§ngen, usw.  Einige Komponenten k√∂nnen auch nicht immer in einer einzigen Kopie verwendet werden.  Die Hauptaufgabe besteht darin, die Antwort auf die Frage zu finden: Wann m√ºssen Abh√§ngigkeiten erstellt werden? <br>  Um dieses Problem zu beheben, k√∂nnen Sie versuchen, eine L√∂sung zu erstellen, die auf einem assoziativen Array von Abh√§ngigkeiten basiert.  Eine beispielhafte Oberfl√§che seiner Arbeit k√∂nnte folgenderma√üen aussehen: <br><br><pre> <code class="ruby hljs">registry.add(InvoiceProcessor) .depends_on(NotificationService) registry.add(NotificationService) .depends_on(ServiceX) invoiceProcessor = registry.resolve(InvoiceProcessor) invoiceProcessor.process(invoice)</code> </pre><br>  Es ist nicht schwer in die Praxis umzusetzen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rd/bj/v4/rdbjv49agcxw3fhhask4uv5ysew.png" alt="Bild"></div><br>  Bei jedem Aufruf von container.resolve () wenden wir uns an die Factory, die Abh√§ngigkeitsinstanzen erstellt und dabei das in der Registrierung beschriebene Abh√§ngigkeitsdiagramm rekursiv umgeht.  Im Falle von container.resolve (InvoiceProcessor) wird folgendes ausgef√ºhrt: <br><br><ol><li>  factory.resolve (InvoiceProcessor) - Die Factory fordert die InvoiceProcessor-Abh√§ngigkeiten im Register an und erh√§lt einen NotificationService, der ebenfalls zusammengestellt werden muss. </li><li>  factory.resolve (NotificationService) - Die Factory, die NotificationService-Abh√§ngigkeiten im Register anfordert, empf√§ngt ServiceX, das ebenfalls zusammengestellt werden muss. </li><li>  factory.resolve (ServiceX) - hat keine Abh√§ngigkeiten, erstellt, kehrt zum Aufrufstapel zu Schritt 1 zur√ºck und ruft ein zusammengesetztes Objekt vom Typ InvoiceProcessor ab. </li></ol><br>  Jede Komponente kann von mehreren anderen abh√§ngen. Die naheliegende Frage lautet also: Wie werden die Designer-Parameter den resultierenden Abh√§ngigkeitsinstanzen korrekt zugeordnet?  Ein Beispiel: <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvoiceProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">initialize</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">notificationService</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">paymentService</span></span></span><span class="hljs-class">) </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment"># ... end end</span></span></span></span></code> </pre><br>  In Sprachen mit statischer Typisierung kann der Parametertyp als Selektor dienen: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvoiceProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(notificationService: NotificationService, paymentService: PaymentService) { <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre><br>  In Ruby k√∂nnen Sie die Konvention verwenden - verwenden Sie einfach den Typnamen im Format snake_case. Dies ist der erwartete Parametername. <br><br><h2>  Stufe 3: Verwaltung der Lebensdauer von Abh√§ngigkeiten </h2><br>  Wir haben bereits eine gute L√∂sung f√ºr das Abh√§ngigkeitsmanagement.  Die einzige Einschr√§nkung besteht darin, dass bei jedem Aufruf eine neue Instanz der Abh√§ngigkeit erstellt werden muss.  Was aber, wenn wir nicht mehr als eine Instanz einer Komponente erstellen k√∂nnen?  Zum Beispiel ein Pool von Verbindungen zur Datenbank.  Tiefer graben, und wenn wir eine kontrollierte Lebensdauer von Abh√§ngigkeiten bieten m√ºssen?  Schlie√üen Sie beispielsweise die Verbindung zur Datenbank nach Abschluss der HTTP-Anforderung. <br>  Es wird deutlich, dass InstanceFactory als Ersatzkandidat f√ºr die urspr√ºngliche L√∂sung in Frage kommt.  Aktualisiertes Diagramm: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hf/ed/xl/hfedxlxxnqjmm22oevtbwqrle2k.png" alt="Bild"></div><br>  Die logische L√∂sung besteht darin, eine Reihe von Strategien ( <a href="https://refactoring.guru/ru/design-patterns/strategy" rel="nofollow">Strategy, GoF</a> ) zu verwenden, um Instanzen von Komponenten zu erhalten.  Jetzt erstellen wir beim Aufrufen von Container :: resolve nicht immer neue Instanzen. Daher ist es angebracht, Factory in Resolver umzubenennen.  Bitte beachten Sie, dass die Container :: register-Methode einen neuen Parameter hat - life_time (lifetime).  Dieser Parameter ist optional. Standardm√§√üig ist sein Wert "transient" (transient), was dem zuvor implementierten Verhalten entspricht.  Die Singleton-Strategie ist auch offensichtlich: Bei ihrer Verwendung wird nur eine Instanz der Komponente erstellt, die jedes Mal zur√ºckgegeben wird. <br>  Scope ist eine etwas komplexere Strategie.  Anstelle von ‚Äûvor√ºbergehenden Pfaden‚Äú und ‚ÄûEinzelg√§ngern‚Äú muss h√§ufig etwas dazwischen verwendet werden - eine Komponente, die w√§hrend des gesamten Lebens einer anderen Komponente vorhanden ist.  Ein √§hnliches Beispiel kann ein Webanwendungsanforderungsobjekt sein, bei dem es sich um den Kontext des Vorhandenseins von Objekten handelt, z. B. HTTP-Parameter, Datenbankverbindung, Modellaggregate.  W√§hrend der gesamten G√ºltigkeitsdauer der Anforderung sammeln und verwenden wir diese Abh√§ngigkeiten. Nach deren Zerst√∂rung gehen wir davon aus, dass auch alle diese Abh√§ngigkeiten zerst√∂rt werden.  Um diese Funktionalit√§t zu implementieren, muss eine ziemlich komplexe, geschlossene Objektstruktur entwickelt werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vd/97/hh/vd97hhi_p41keoxph7ku9sdxrdm.png" alt="Bild"></div><br>  Das Diagramm zeigt ein Fragment, das √Ñnderungen in den Klassen Component und LifetimeStrategy im Kontext der Implementierung der G√ºltigkeitsdauer des G√ºltigkeitsbereichs widerspiegelt.  Das Ergebnis war eine Art ‚ÄûDoppelbr√ºcke‚Äú (√§hnlich der <a href="https://refactoring.guru/ru/design-patterns/bridge" rel="nofollow">Bridge, GoF-</a> Vorlage).  Mithilfe der komplexen Vererbungs- und Aggregationstechniken wird Component zum Kern des Containers.  Das Diagramm ist √ºbrigens mehrfach vererbt.  Wo Programmiersprache und Gewissen es erlauben, k√∂nnen Sie es so belassen.  In Ruby verwende ich Verunreinigungen. In anderen Sprachen k√∂nnen Sie die Vererbung durch eine andere Br√ºcke ersetzen: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ri/dj/h7/ridjh7shgaolxp_mxujgvkueta4.png" alt="Bild"></div><br>  Das Sequenzdiagramm zeigt den Lebenszyklus der Sitzungskomponente, der an die Lebensdauer der Anforderungskomponente gebunden ist: <br><br><img src="https://habrastorage.org/webt/-c/im/bt/-cimbtr3sktosriryzoyrtqxht4.png" alt="Bild"><br><br>  Wie Sie aus dem Diagramm ersehen k√∂nnen, wird zu einem bestimmten Zeitpunkt, wenn die Anforderungskomponente ihre Mission abgeschlossen hat, die Freigabemethode aufgerufen, mit der der Prozess des Zerst√∂rens des G√ºltigkeitsbereichs gestartet wird. <br><br><h2>  Stufe 4: Abh√§ngigkeitsinjektion </h2><br>  Bisher habe ich dar√ºber gesprochen, wie man die Registrierung von Abh√§ngigkeiten ermittelt und dann Komponenten gem√§√ü dem Diagramm der gebildeten Beziehungen erstellt und zerst√∂rt.  Und wof√ºr ist es?  Angenommen, wir verwenden dies als Teil von Ruby on Rails: <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvoiceController</span></span></span><span class="hljs-class"> &lt; ApplicationController </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pay</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">params</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice_repository</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">registry</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resolve</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvoiceRepository</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice_processor</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">registry</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resolve</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvoiceProcessor</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice_repository</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">find</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">params</span></span></span><span class="hljs-class">[:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">]) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice_processor</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pay</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre><br>  Code, der auf diese Weise geschrieben wird, ist nicht lesbarer, testbarer oder flexibler.  Rails kann nicht dazu gezwungen werden, Controller-Abh√§ngigkeiten √ºber seinen Konstruktor zu injizieren, da dies nicht vom Framework bereitgestellt wird.  In ASP.NET MVC wird dies jedoch beispielsweise auf einer grundlegenden Ebene implementiert.  Um den automatischen Mechanismus zur Aufl√∂sung von Abh√§ngigkeiten optimal zu nutzen, m√ºssen Sie die Inversion of Control-Technik (IoC, Inversion of Control) implementieren.  Dies ist ein Ansatz, bei dem die Verantwortung f√ºr das Aufl√∂sen von Abh√§ngigkeiten √ºber den Anwendungscode hinausgeht und beim Framework liegt.  Betrachten Sie ein Beispiel. <br>  Stellen Sie sich vor, wir entwerfen so etwas wie Rails von Grund auf neu.  Wir implementieren das folgende Schema: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/y1/bg/bh/y1bgbh_27yevoryv4ntb58nej9w.png" alt="Bild"></div><br>  Die Anwendung empf√§ngt die Anforderung, der Router ruft die Parameter ab und weist den entsprechenden Controller an, diese Anforderung zu verarbeiten.  Ein solches Schema kopiert bedingt das Verhalten eines typischen Webframeworks mit nur geringem Unterschied - der IoC-Container ist an der Erstellung und Implementierung von Abh√§ngigkeiten beteiligt.  Aber hier stellt sich die Frage, wo der Container selbst entsteht.  Um m√∂glichst viele Objekte der zuk√ºnftigen Anwendung abzudecken, muss unser Framework bereits in einem sehr fr√ºhen Stadium seines Betriebs einen Container erstellen.  Offensichtlich gibt es keinen passenderen Ort als die App Builder App.  Es ist auch der am besten geeignete Ort, um alle Abh√§ngigkeiten zu konfigurieren: <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#   - ,      . def initialize </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@container</span></span></span></span><span class="hljs-class"><span class="hljs-comment"> = Container.new </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@container</span></span></span></span><span class="hljs-class"><span class="hljs-comment"> .register(Controller) .using_lifetime(:transient) # ,     </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@container</span></span></span></span><span class="hljs-class"><span class="hljs-comment"> .register(InvoiceService) .using_lifetime(:singleton) # ,     </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@container</span></span></span></span><span class="hljs-class"><span class="hljs-comment"> .register(Router) .using_lifetime(:singleton) #  end #     -     , #      . def call(env) router = </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@container</span></span></span></span><span class="hljs-class"><span class="hljs-comment">.resolve(Router) router.handle(env.path, env.method, env.params) end end</span></span></span></span></code> </pre><br>  Jede Anwendung hat einen Einstiegspunkt, beispielsweise die Hauptmethode.  In diesem Beispiel ist der Einstiegspunkt die Aufrufmethode.  Ziel dieser Methode ist es, den Router aufzurufen, um eingehende Anforderungen zu verarbeiten.  Der Einstiegspunkt sollte der einzige Ort sein, an dem der Container direkt angerufen werden kann - von diesem Moment an sollte der Container auf der Strecke bleiben, und alle nachfolgenden Zaubereien sollten ‚Äûunter der Haube‚Äú stattfinden.  Die Implementierung des Controllers in einer solchen Architektur sieht wirklich ungew√∂hnlich aus.  Obwohl wir es nicht explizit instanziieren, hat es einen Konstruktor mit Parametern: <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Controller</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#   . #    . def initialize(invoice_service) </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@invoice</span></span></span></span><span class="hljs-class"><span class="hljs-comment">_service = invoice_service end def create_invoice(params) </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@invoice</span></span></span></span><span class="hljs-class"><span class="hljs-comment">_service.create(params) end end</span></span></span></span></code> </pre><br>  Die Umgebung "versteht", wie Controller-Instanzen erstellt werden.  Dies ist dank des Abh√§ngigkeitsinjektionsmechanismus m√∂glich, der durch den im Herzen der Webanwendung eingebetteten IoC-Container bereitgestellt wird.  Im Konstruktor des Controllers k√∂nnen Sie nun alles auflisten, was f√ºr dessen Betrieb erforderlich ist.  Hauptsache, die entsprechenden Komponenten sind im Container registriert.  Wenden wir uns nun der Router-Implementierung zu: <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Router</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#         -  #      #     . def initialize(controller) </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@controller</span></span></span></span><span class="hljs-class"><span class="hljs-comment"> = controller end def handle(path, method, params) #  ""- if path == '/invoices' &amp;&amp; method == 'POST' </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@controller</span></span></span></span><span class="hljs-class"><span class="hljs-comment">.create(params) end end end</span></span></span></span></code> </pre><br>  Beachten Sie, dass der Router vom Controller abh√§ngig ist.  Wenn wir uns an die Abh√§ngigkeitseinstellungen erinnern, ist der Controller eine kurzlebige Komponente und der Router ein st√§ndiger Einzelg√§nger.  Wie kann das sein?  Die Antwort ist, dass die Komponenten keine Instanzen der entsprechenden Klassen sind, wie es von au√üen aussieht.  Tats√§chlich handelt es sich hierbei um Proxy-Objekte ( <a href="https://refactoring.guru/ru/design-patterns/proxy" rel="nofollow">Proxy, GoF</a> ) mit der Instanz der Factory-Methode ( <a href="https://refactoring.guru/ru/design-patterns/factory-method" rel="nofollow">Factory-Methode, GoF</a> ).  Sie geben eine Instanz der Komponente gem√§√ü der zugewiesenen Strategie zur√ºck.  Da der Controller als "transient" registriert ist, behandelt der Router beim Zugriff immer seine neue Instanz.  Das Sequenzdiagramm zeigt einen ungef√§hren Arbeitsmechanismus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tl/ng/1y/tlng1yrikuvxkenacsx-gy0x7mu.png" alt="Bild"></div><br>  Das hei√üt  Neben dem Abh√§ngigkeitsmanagement √ºbernimmt ein gutes Framework, das auf einem IoC-Container basiert, auch die Verantwortung f√ºr das korrekte Management der Lebensdauer von Komponenten. <br><br><h2>  Fazit </h2><br>  Die Abh√§ngigkeitsinjektionstechnik kann eine ziemlich ausgefeilte interne Implementierung haben.  Dies ist der Preis f√ºr die √úbertragung der Komplexit√§t der Implementierung flexibler Anwendungen in den Kern des Frameworks.  Der Benutzer solcher Frameworks kann sich nicht um die rein technischen Aspekte k√ºmmern, sondern mehr Zeit f√ºr die komfortable Entwicklung der Gesch√§ftslogik von Anwendungsprogrammen aufwenden.  Mit einer hochwertigen DI-Implementierung schreibt ein Anwendungsprogrammierer zun√§chst testbaren, gut unterst√ºtzten Code.  Ein gutes Beispiel f√ºr die Implementierung von Dependency Injection ist das <a href="https://github.com/cylon-v/dandy" rel="nofollow">Dandy-</a> Framework, das in meinem vorherigen Artikel <a href="https://habr.com/ru/post/474504/">Orthodox Backend beschrieben wurde</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de480364/">https://habr.com/ru/post/de480364/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de480352/index.html">Der Harvard-Genetiker entwickelt eine Prototyp-DNA-Analyse-Dating-App</a></li>
<li><a href="../de480354/index.html">Erste Schritte mit den JavaScript-Array-Methoden .map (), .filter () und .reduce ()</a></li>
<li><a href="../de480356/index.html">N√ºtzliche Python-Tipps, die Sie noch nicht kennengelernt haben</a></li>
<li><a href="../de480358/index.html">Der verborgene Preis von CSS-in-JS-Bibliotheken in React-Anwendungen</a></li>
<li><a href="../de480362/index.html">Abenteuer von deutschem abgereichertem Uranhexafluorid in Russland. Teil 1. Geschichte und Anreicherungstechnologien</a></li>
<li><a href="../de480368/index.html">Abfangen von Speicherverlusten in C / C ++</a></li>
<li><a href="../de480376/index.html">Von Computerspielen bis zu geheimen Nachrichten: Diskutieren Sie Ostereier in Vinyl-Ver√∂ffentlichungen</a></li>
<li><a href="../de480386/index.html">Auto-Backups von Netzwerkger√§ten und deren Speicherung im Versionskontrollsystem</a></li>
<li><a href="../de480388/index.html">HACKTIVITY-Konferenz 2012. Die Urknalltheorie: Die Entwicklung des Pentesting f√ºr mehr Sicherheit. Teil 1</a></li>
<li><a href="../de480390/index.html">ONYX BOOX Livingstone - ein Leser eines beliebten Formats in ungew√∂hnlichem Design</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>