<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚ÄçüöÄ üöë ü§òüèª Ariadnes Faden: Wie man sich in JSR-133 verliebt. Yandex-Bericht üßõüèº üêë üôÖ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mehrkernprozessoren sind an der Tagesordnung. Fr√ºher oder sp√§ter muss sich jeder praktische Programmierer in das Labyrinth der Multithread-Programmier...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ariadnes Faden: Wie man sich in JSR-133 verliebt. Yandex-Bericht</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/477074/">  Mehrkernprozessoren sind an der Tagesordnung.  Fr√ºher oder sp√§ter muss sich jeder praktische Programmierer in das Labyrinth der Multithread-Programmierung begeben und sich mit den "Monstern" treffen, die dort leben.  Sprechen wir dar√ºber, wo wir auf diese Weise beginnen sollen und welche Tools und Ans√§tze dazu beitragen, dass wir als Sieger hervorgehen.  Diesen Bericht habe ich zuk√ºnftigen Teilnehmern des <a href="https://ya.cc/7w_Dq">ganzj√§hrigen Praktikums von</a> Yandex gemacht. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/veYXsOlYb2A" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - Ich hei√üe Seva Minkov.  Ich arbeite in der Cloud-Infrastrukturabteilung der Suchabteilung.  Ich besch√§ftige mich haupts√§chlich mit dem Backend.  Ich schreibe in verschiedenen Sprachen, aber meistens handelt es sich um Java und Sprachen, die auf der Java Virtual Machine (JVM) ausgef√ºhrt werden. <br><a name="habracut"></a><br>  Unser Team entwickelt eine interne Cloud, in der fast alle Yandex-Dienste gestartet werden - sowohl √∂ffentlich bekannte wie Search, Mail und Alice als auch verschiedene interne Dienste, virtuelle Maschinen sowie kurzlebige MapReduce-Aufgaben und maschinelles Lernen. <br><br>  Unsere Cloud ist nicht statisch: Das Unternehmen w√§chst, die Anzahl der Dienste und die Ressourcen, die sie verbrauchen, steigen.  Und unser Team steht sehr oft vor der Herausforderung, die Leistung zu skalieren und zu verbessern.  Dies erreichen wir durch die Verwendung aller verf√ºgbaren Tools, einschlie√ülich der vertikalen Skalierung, dh durch die Beschleunigung einzelner Systemkomponenten, um einige Singlethread-Algorithmen so umzuschreiben, dass sie schneller arbeiten.  Wir machen horizontale Skalierung: Zerkleinern des Systems in kleine Teile, um durch Hinzuf√ºgen von Servern, Prozessoren, Kernen usw. eine bessere Leistung zu erzielen. <br><br>  Und die Multithread-Programmierung hilft uns dabei sehr.  Wir werden heute √ºber ihn sprechen - woher kam es, warum ist es relevant?  Was ist ein Speichermodell und wie wird es in Java allgemein dargestellt?  Wir werden auf einige praktische Aspekte eingehen, um Ihre Anwendungen zu testen und ihre Richtigkeit zu √ºberpr√ºfen. <br><br><img src="https://habrastorage.org/webt/me/f6/9z/mef69z0p-acv-chewvn7tuhphpk.jpeg"><br><br>  Schauen wir uns zun√§chst dieses interessante Diagramm an, das die Entwicklung der Eigenschaften von Mikroprozessoren in den letzten 40 Jahren zeigt.  Vor ungef√§hr 10-15 Jahren, als das Gras gr√ºner war und die Prozessoren Single-Threaded waren, konnte ein gew√∂hnlicher Programmierer einmal ein korrektes Single-Threaded-Programm schreiben und sich dann auf Moores empirisches Gesetz verlassen.  Er sagt, dass Prozessoren alle zwei Jahre doppelt so schnell sind.  Wie Sie sehen, haben die Hersteller von Mikroprozessoren aus verschiedenen Gr√ºnden irgendwann um 2005 auf die Multi-Core-Architektur umgestellt und damit begonnen, die Anzahl der logischen Kerne zu erh√∂hen.  Und der Leistungszuwachs eines einzelnen Kerns h√∂rte auf, Moores Gesetz zu befolgen, und die Verarbeitungsleistung eines Kerns begann langsamer zu wachsen.  Dies war eine Revolution, und gew√∂hnliche Programmierer mussten parallel programmieren, um genau diesen Leistungsgewinn zu nutzen. <br><br>  Da wir gerade √ºben, werden wir versuchen, ein einfaches Multithread-Programm zu schreiben und selbst zu sehen, wie es funktioniert. <br><br><img src="https://habrastorage.org/webt/rl/tv/gz/rltvgzwhsnhczo7tlpu5otwekuw.jpeg"><br><br>  Nehmen wir als Beispiel eine ziemlich einfache Aufgabe zum Kreuzlesen von Datens√§tzen.  Lassen Sie uns zwei gemeinsam genutzte Variablen X und Y, die zuerst mit dem Standardwert (Null) initialisiert wurden, und zwei Streams haben.  Jeder Thread schreibt in eine Variable und liest eine andere.  In diesem Fall schreibt Thread1 eine Einheit in X und liest Y. Der zweite Thread macht dasselbe, nur r√ºckw√§rts. <br><br>  Eine einfache Java-Implementierung k√∂nnte ungef√§hr so ‚Äã‚Äãaussehen. <br><br><img src="https://habrastorage.org/webt/xz/dw/8g/xzdw8gsz8vr8f2p-0dvtdr1y6qw.jpeg"><br><br>  Wir werden die ReadWriteTest-Klasse schreiben, sie wird zwei statische Variablen X und Y haben. Direkt in der Hauptmethode konstruieren wir zwei Threads Thread1 und Thread2 und geben jedem von ihnen eine Lambda-Funktion ein, die ausgef√ºhrt wird, wenn der Thread ausgef√ºhrt wird.  Setzen Sie den Code von der vorherigen Folie dort und starten Sie zwei Threads. <br><br>  Die Reihenfolge, in der die Threads beginnen, ist in gewisser Weise unvorhersehbar.  Dies h√§ngt davon ab, wie das Betriebssystem Threads ausf√ºhrt.  Dementsprechend k√∂nnen wir unterschiedliche Versionen haben.  Es scheint zu verstehen, wie das alles funktioniert, wir m√ºssen dieses Programm viele Male ausf√ºhren, dann die Ausgabe aggregieren und sehen, wie oft diese oder jene Antwort im Programm gefunden wird. <br><br><img src="https://habrastorage.org/webt/ij/os/e3/ijose3q1hdbyts7brwd31pujhou.jpeg"><br><h5>  <sup><sub><a href="https://openjdk.java.net/projects/code-tools/jcstress/">Link von der Folie</a></sub></sup> </h5><br>  Um das Rad nicht neu zu erfinden, k√∂nnen wir ein fertiges Werkzeug verwenden.  Dies nennt sich jcstress, das Java Concurrency Stresstest-Dienstprogramm, das Teil des OpenJDK-Projekts ist. <br><br>  Dieses Dienstprogramm bietet einen Rahmen f√ºr das Schreiben von Stresstests.  In diesem Fall l√§sst sich der Code der vorherigen Folie leicht umschreiben.  Zun√§chst h√§ngen wir die Anmerkung jcstress Test an die Klasse, wodurch unsere Testskripte f√ºr das Dienstprogramm einfach sichtbar werden.  Wir kennzeichnen es auch mit der State-Klasse, die besagt, dass die Klasse Daten enth√§lt, die sich √§ndern k√∂nnen: Sie werden sowohl modifiziert als auch aus verschiedenen Streams gelesen.  Wir deklarieren zwei Methoden, thread1 und thread2, und markieren sie mit der Annotation Actor.  Actor Annotation bedeutet, dass die Methode in einem separaten Thread ausgef√ºhrt werden muss.  jcstress garantiert, dass jede dieser Methoden in genau einer Instanz der State-Klasse in einem separaten Thread ausgef√ºhrt wird.  Die Reihenfolge, in der sie gestartet werden, ist nicht speziell festgelegt.  Das Ergebnis wird in ein II_Result-Objekt geschrieben, das auf der Folie angezeigt wird.  Wir k√∂nnen davon ausgehen, dass es sich um ein Tupel von zwei numerischen Werten handelt, die nur durch die Abh√§ngigkeitsinjektionsmethode dargestellt werden, √ºber die Kirill in einem fr√ºheren Bericht gesprochen hat. <br><br>  Bevor wir mit diesem Test beginnen, √ºberlegen wir uns, welche Schlussfolgerungen die Befehle geben k√∂nnen und welche Werte wir in r1 und in r2 hinzuf√ºgen k√∂nnen. <br><br><img src="https://habrastorage.org/webt/na/ik/dn/naikdng1aeysfm7tc0fe7drjbfs.jpeg"><br><br>  Dazu verwenden wir das sogenannte Alternationsmodell.  Die Operationen Lesen oder Schreiben werden auf die eine oder andere Weise in einer bestimmten Reihenfolge ausgef√ºhrt.  Es reicht aus, alle diese Optionen zusammen durchzugehen und zu sehen, welche Ergebnisse wir erzielen werden. <br><br><img src="https://habrastorage.org/webt/i5/4y/fk/i54yfklqj0mjn1jjhkwhqs8vna0.jpeg"><br><br>  Angenommen, eine der m√∂glichen Varianten von Ereignissen ist, dass Thread eins vollst√§ndig vor Thread zwei ausgef√ºhrt wird.  Zuerst haben wir Eins zu X hinzugef√ºgt und Null von Y gelesen, da es keine Eintr√§ge gab.  Dann schrieben sie eine in Y und lasen eine aus X, da der erste Stream dies bereits geschafft hatte. <br><br>  Die erste Antwort ist null und eins. <br><br><img src="https://habrastorage.org/webt/ot/7p/ax/ot7paxx6szikzgwp9xjiusgnfny.jpeg"><br><br>  Die zweite Variante der Ereignisentwicklung ist genau das Gegenteil: Stream zwei wurde vor Stream eins ausgef√ºhrt. <br><br><img src="https://habrastorage.org/webt/_r/b5/sg/_rb5sgbawfh8cczgwyz9yzomji8.jpeg"><br><br>  Dementsprechend erhalten wir ein Spiegelergebnis von Eins-Null. <br><br><img src="https://habrastorage.org/webt/ja/ft/fi/jaftfi3gbc6cwnliw1nufl66x50.jpeg"><br><br>  Es gibt ungef√§hr vier weitere Optionen, die dasselbe Ergebnis liefern, wenn die Threadausf√ºhrung v√∂llig durcheinander ist.  Zum Beispiel haben wir eine Einheit in einem Stream in X aufgezeichnet, in der zweiten haben wir es geschafft, eine Einheit in Y zu haben, und wir berechnen eins zu eins.  Sie k√∂nnen dann sehen, welche anderen Optionen es als Heim√ºbung gibt. <br><br><img src="https://habrastorage.org/webt/w2/bf/tr/w2bftrexoxplrdq_v81fuxeoxic.jpeg"><br><br>  Es scheint, dass wir alle m√∂glichen Optionen durchgegangen sind, mehr gibt es nicht.  Lassen Sie uns das Dienstprogramm ausf√ºhren und sehen, welche Schlussfolgerungen es zieht. <br><br><img src="https://habrastorage.org/webt/8-/2k/p7/8-2kp79h_iv-0il5eo9ftko91ye.jpeg"><br><h5>  <sup><sub><a href="https://openjdk.java.net/projects/code-tools/jcstress/">Link von der Folie</a></sub></sup> </h5><br>  Die Ausgabe sieht aus wie eine Tabelle.  In der ersten Spalte werden die Ergebnisse aufgelistet, die wir in II_Result hinzugef√ºgt haben - das Dienstprogramm f√ºhrt diesen Code millionenfach aus - und die Anzahl der F√§lle, in denen √ºberhaupt ein bestimmtes Ergebnis festgestellt wurde.  Aber wahrscheinlich w√§re dieser Bericht nicht gewesen, wenn alles so einfach gewesen w√§re. <br><br>  Tats√§chlich k√∂nnen wir in dieser Schlussfolgerung auch das Null-Null-Ergebnis sehen, das mit dem Alternationsmodell schwer zu erkl√§ren ist.  Es scheint, dass eine der m√∂glichen Optionen darin besteht, dass jemand direkt im Stream-Code die Zeilen √ºbernommen und neu angeordnet hat. <br><br>  √úberlegen wir, warum es passiert ist und wie wir damit leben k√∂nnen.  Ich bitte Sie auch, darauf zu achten, dass die One-One-Option nur √§u√üerst selten speziell auf meinem Computer gefunden wurde.  Von 130 Millionen Vorstellungen f√ºhrten nur 154 Vorstellungen zum Ergebnis von eins zu eins.  Und im Gegenteil, in fast 30% der F√§lle tritt Null-Null sehr h√§ufig auf. <br><br><img src="https://habrastorage.org/webt/kw/sb/24/kwsb24gow4nmkjkdtmhzxnnvreo.jpeg"><br><br>  Um ein Zwischenergebnis zusammenzufassen, das wir alle mit Ihnen gesehen haben.  Zuallererst konnten wir verstehen, dass die Interaktion von Fl√ºssen durch das Ged√§chtnis nicht trivial ist.  Das von uns verwendete Rotationsmodell funktioniert nicht.  Wir haben eine Umlagerung gesehen.  Das kann viele Gr√ºnde haben. <br><br>  Zum Beispiel konnten wir einige ‚Äûrelativistische Effekte‚Äú von Eisen beobachten.  Dies kann auf folgende Weise gedacht werden: In einem Taktzyklus eines 3-GHz-Prozessors bewegt sich das Licht im Vakuum etwa 10 cm. Das Protokoll zum Lesen und Schreiben in den Prozessorspeicher ist kompliziert und manchmal dauert es mehrere hundert Taktzyklen, um den Wert von einem Kern auf einen anderen zu √ºbertragen.  Dementsprechend kann ein Kern scheinen, die Vergangenheit zu sehen.  Das Ergebnis nach dem Datensatz ist aufgetreten, aber wir sehen den alten Wert.  Au√üerdem stehen Prozessoren auch nicht still und k√∂nnen Anweisungen stellenweise √§ndern. <br><br>  Moderne Optimierungscompiler k√∂nnen zu derselben Permutation f√ºhren.  Um eine maximale Single-Thread-Leistung zu erzielen, k√∂nnen sie auch Anweisungen austauschen, sodass die Richtigkeit eines Single-Thread-Programms nicht beeintr√§chtigt wird.  Aber in Multithread-Programmen kann es zu interessanten Effekten kommen, die wir gesehen haben. <br><br>  Und die zweite - wahrscheinlich die wichtigste Schlussfolgerung: Wir haben gesehen, dass Multithread-Programme grunds√§tzlich nicht festgelegt sind.  Singlethread-Programme st√ºtzen sich haupts√§chlich auf einige Invarianten bei der Eingabe und Ausgabe und sind deterministisch.  vorausgesetzt, der Zufallszahlengenerator und die Benutzereingabe sind Eingabeparameter. <br><br>  Dies macht die Dinge sehr kompliziert: Es ist schwierig zu verstehen, was das Programm tut, und es ist schwierig, es zu testen. <br><br>  In Bezug auf die Komplexit√§t der Tests k√∂nnen wir hinzuf√ºgen, dass dasselbe Ergebnis nur 154 Mal bei 130 Millionen Anrufen gefunden wurde.  Die Eintrittswahrscheinlichkeit dieses Ergebnisses betr√§gt ein Millionstel.  In der Produktion bedeutet dies, dass ein solcher Fehler nach Wochen reproduziert werden kann.  Und es wird sicherlich irgendwo am Sonntagabend passieren, wenn Sie das √ºberhaupt nicht erwartet haben. <br><br><img src="https://habrastorage.org/webt/sd/u8/hg/sdu8hgj5xiqhrnnganz3ltxzyp0.jpeg"><br><br>  Lassen Sie uns dar√ºber nachdenken, wie wir sein sollten und was wir im Allgemeinen von unserer Zunge erwarten, um am Sonntagabend friedlich zu schlafen.  Erstens ben√∂tigen wir ein Tool, mit dem wir das Verhalten des Programms vorhersagen und Beurteilungen √ºber dessen Ausf√ºhrung vornehmen k√∂nnen.  Zweitens brauchen wir Sprachwerkzeuge, mit denen wir die Permutationen und Effekte beeinflussen k√∂nnen - sie k√∂nnen von der Hardware, dem Compiler usw. stammen. Ich m√∂chte weniger dar√ºber wissen, wie ein bestimmter Prozessor funktioniert, welche Optimierungen der Compiler ausf√ºhren kann und welche Abk√ºrzung verwendet wird das kam aus der Java-Welt.  Einmal schreiben, √ºberall ausf√ºhren - Schreiben Sie einmal den richtigen Multithread-Code, damit er auf allen Plattformen funktioniert. <br><br><img src="https://habrastorage.org/webt/tx/lr/du/txlrdugf3x6nxzxnraij4qn9yzq.jpeg"><br><br>  Diese Fragen und Anforderungen, die wir aufgelistet haben, stellten sich seit langem in den K√∂pfen von Entwicklern und Theoretikern und Praktikern.  Wie jede komplexe Aufgabe mit einem hohen Grad an Komplexit√§t wurde sie durch die Einf√ºhrung des Konzepts einer abstrakten Maschine gel√∂st.  Wir alle, Entwickler in h√∂heren Programmiersprachen, schreiben nicht f√ºr eine bestimmte Hardware, nicht f√ºr ein solches Prozessormodell, sondern schreiben eine abstrakte Maschine.  Und die Spezifikation der Sprache soll ihr Verhalten so beschreiben, dass diese drei Welten in Einklang gebracht werden.  Einerseits lassen Sie Entwickler von Compilern und Prozessoren ihre Optimierungen vornehmen und uns Programmierern, die bereits in einer bestimmten Sprache schreiben, den Kopf in den Kopf sprengen. <br><br>  Das Speichermodell nimmt in dieser abstrakten Maschine eine zentrale Position ein.  Sie sollte eine Frage beantworten: Wenn ich eine Variable X in einem Stream lese, welches Ergebnis der letzten Eintr√§ge kann ich dort √ºberhaupt sehen?  Es wurde erstmals versucht, das Speichermodell in der Sprache Java zu formalisieren, alle anderen Speichermodelle erschienen sp√§ter.  Angenommen, C ++ 11 ist mit einigen √Ñnderungen fast eine Kopie des Java-Speichermodells. <br><br>  In Java gab es mehrere Speichermodelle.  Urspr√ºnglich wurde das sogenannte "glockenf√∂rmige" Speichermodell als erfolglos erkannt, da es die Arbeit von Programmierern behinderte, die in Java schreiben, und dem Compiler einige Optimierungen verbot, die f√ºr sich selbst durchaus angemessen sind.  Dementsprechend wurde im Rahmen des Community-Prozesses JSR-133 ein modernes Speichermodell geschrieben. <br><br>  Da wir die Schriftstelle in Form einer Spezifikation haben, versuchen wir, sie zu untersuchen und zu verstehen, was wirklich im Inneren vor sich geht. <br><br><img src="https://habrastorage.org/webt/3f/w6/qi/3fw6qiwjhoeqgtrdn3jngdqntfs.jpeg"><br><br>  Es gibt ein Problem.  Heben Sie Ihre H√§nde, der die Spezifikation der Sprache √∂ffnete und las, was dort geschah.  Und wie viele von Ihnen haben das Speichermodell von Absatz 17.4 gelesen?  Eine kleine √úberraschung erwartet Sie.  Die Sprachspezifikation wird grunds√§tzlich in einer verst√§ndlichen Sprache beschrieben.  Aber das Speichermodell ist voller mathematischer Hardcore.  Es gibt Einschl√ºsse in Griechisch, viele mathematische Begriffe aus der Reihe transitiver Abschl√ºsse, der Vereinigung zweier Ordnungen usw. <br><br>  Leider gibt es keinen anderen Weg.  Das einzige, worauf Sie sich beim Schreiben von Multithread-Programmen verlassen k√∂nnen, ist die Spezifikation.  Sie muss lesen und verstehen.  Ich kann Sie nur empfehlen.  Au√üerdem hatte ich, als ich die Spezifikation zum ersten Mal las, solche Eindr√ºcke. <br><br>  Warum ist es so kompliziert?  Ich bin den falschen Weg gegangen und ich warne Sie sehr, sich wie ich zu verhalten. <br><br>  Ich habe es genommen, im Internet gesucht, was ein Speichermodell ist.  Ich habe ein Buch namens JSR-133 Cookbook for Compiler Writers gefunden.  Sie beschreibt, wie ein Compiler-Entwickler dieses Speichermodell auf einfache Weise implementieren kann.  Das Problem ist, dass dies eine spezifische Implementierung ist und nicht zur Beurteilung des gesamten Speichermodells im Allgemeinen verwendet werden kann. <br><br>  Versuchen wir auf jeden Fall, einen kleinen Versuch zu den wichtigsten Schlussfolgerungen zu machen, die sich aus dem Java-Speichermodell ergeben. <br><br><img src="https://habrastorage.org/webt/ii/tn/by/iitnbypnfohtdb0y3gyxuhv1fea.jpeg"><br><br>  M√∂glicherweise gibt es viele Ausf√ºhrungen Ihres Multithread-Programms.  Das haben wir selbst am Beispiel unseres Programms gesehen.  Im einfachsten Beispiel hatten wir bereits vier Ergebnisse seiner Implementierung.  Und die Aufgabe des Java-Speichermodells besteht darin, zu sagen, welche dieser Ausf√ºhrungen korrekt sind und welche davon verboten werden sollten.  Und postuliert drei Dinge.  Die erste ist, dass Ihre Aufgabe im Rahmen eines Threads pseudosequenziell ausgef√ºhrt wird.  Dies impliziert, dass der Compiler Operationen austauschen kann, der Prozessor auch Anweisungen parallel ausf√ºhren kann, sie austauschen kann.  Dies muss jedoch so erfolgen, dass die sichtbaren Auswirkungen der Ausf√ºhrung Ihres Programms so sind, als ob es direkt nacheinander ausgef√ºhrt w√ºrde. <br><br>  Zweitens sind die sogenannten aus dem Nichts stammenden Bedeutungen in der Sprache verboten.  Leider haben wir keine Zeit, dies zu zeigen, aber es gibt F√§lle, in denen der Compiler eine solche Konvertierung durchf√ºhren kann, dass in einem Single-Thread-Programm alles korrekt ist und Sie m√∂glicherweise einen Datensatz in einem Multi-Thread-Programm haben, den Sie nicht ausgef√ºhrt haben. <br><br>  Dementsprechend gibt das Speichermodell an, dass beim Lesen einer Variablen entweder der Standardwert oder einige der Ergebnisse der Aufzeichnung zur√ºckgegeben werden, die einmal von einem anderen Befehl ausgef√ºhrt wurden.  Und die restlichen Aktionen k√∂nnen als sequentiell interpretiert werden, wenn sie durch eine Teilordnungsbeziehung verbunden sind - bevor dies geschieht.  Und dies ist jetzt der einzige Ort, an dem wir Mathe brauchen.  Teilweise Beziehung, da nicht alle Lese- und Schreiboperationen von Variablen durch Relationen verbunden sind.  Es hat die Eigenschaften Reflexivit√§t, Transitivit√§t und Antisymmetrie. <br><br><img src="https://habrastorage.org/webt/vq/vp/11/vqvp11dmptcgzyedx4hazndvmeo.jpeg"><br><br>  Lassen Sie uns detaillierter dar√ºber sprechen, was vor sich geht.  Die erste Regel ist, dass alle Operationen in einem einzigen Thread verkn√ºpft werden.  Wenn Sie in einem Thread geschrieben haben, dass X gleich eins ist, ist Y gleich eins;  Es wird angegeben, dass die Schreiboperationen in X mit Vorg√§ngen vor Y zusammenh√§ngen. Das hei√üt, X geschieht vor Y. Au√üerdem werden einige spezielle Aktionen, die sogenannten Synchronisationsaktionen, gebunden.  Lesen Sie mehr in der Spezifikation.  Dies ist beispielsweise das Schreiben und Lesen einer fl√ºchtigen Variablen, das Sperren / Entsperren auf einem Monitor, das Betreten des synchronisierten Blocks und das Verlassen des synchronisierten Blocks.  Ein sehr wichtiger Punkt ist, dass alle Synchronisationsaktionen in Ihrem Programm Threads in genau derselben Reihenfolge sehen, als w√ºrden sie einzeln ausgef√ºhrt. <br><br>  Und passiert, bevor einige Paare dieser Aktionen verkn√ºpft werden.  Es spielt keine Rolle, in welchem ‚Äã‚ÄãThread Synchronisationsaktionen stattfinden.  Es ist wichtig, dass sie zum Beispiel eine fl√ºchtige Variable passieren.  In der Spezifikation hei√üt es beispielsweise, dass in die fl√ºchtige Variable geschrieben wird, bevor eine andere nachfolgende Aktion ausgef√ºhrt wird.  Dies bezieht sich genau auf die Art und Weise, in der wir Synchronisationsaktionen hatten. <br><br>  Und das Wichtigste dabei ist, dass die Regel vor der Konsistenz abl√§uft, die nur die wichtigste Frage zum Speichermodell beantwortet.  Es kann wie folgt interpretiert werden.  Wenn eine Variable eine Kette von Lese- / Schreibvorg√§ngen enth√§lt und diese durch eine Kette von Vorg√§ngen vor Beziehungen verbunden sind, sollte beim Lesen auf jeden Fall der letzte Datensatz in dieser Kette angezeigt werden.  Ist dies nicht der Fall, k√∂nnen Sie einen anderen Wert, einen anderen Datensatz oder einen Standardwert anzeigen.  Jetzt k√∂nnen Sie ausatmen, mit den grundlegenden Definitionen sind wir fertig. <br><br><img src="https://habrastorage.org/webt/q6/jv/qq/q6jvqqzesul_tjyflrgcuy8s__4.jpeg"><br><br>  Versuchen wir die Theorie in der Praxis zu testen?  Nehmen wir ein Beispiel mit einem Kreuzlesen von Datens√§tzen und f√ºgen den fl√ºchtigen Modifikator zu den Variablen X und Y hinzu. Versuchen wir zu beweisen, dass wir den Wert Null-Null nicht mehr sehen werden.  Verwenden Sie dazu einfach die Regeln, die ich oben ausgesprochen habe. <br><br>  Wir werden die Vorkommnisse in einem Thread arrangieren.  Vor dem Lesen von Y und im zweiten Thread wird in X geschrieben.  Schreiben an Y geschieht, bevor von X gelesen wird. <br><br>  Und dann haben wir vier Synchronisationsaktionen: Schreiben in X, Schreiben in Y, Lesen aus X, Lesen aus Y. Sie k√∂nnen in einer bestimmten Reihenfolge auftreten, und ein Paar kann in zwei F√§llen auftreten. <br><br><img src="https://habrastorage.org/webt/yz/mu/vr/yzmuvrfkneks1-usipllgsgxanc.jpeg"><br><br>  Das Schreiben in X in Stream 1 erfolgte beispielsweise fr√ºher als das Lesen aus X in Stream 2 ("happen-before").  Wie Sie hier sehen k√∂nnen, h√§ngt die Beziehung nicht mit Y zusammen. Das Ergebnis des Lesens von Y kann entweder den Standardwert oder den Wert, den der zweite Stream aufgezeichnet hat, an uns zur√ºckgeben.  Ein Messwert von X muss immer eine Einheit enthalten.  Dementsprechend k√∂nnen unsere Optionen null-eins, eins-eins sein. <br><br><img src="https://habrastorage.org/webt/yc/zi/rm/yczirmhlmh3r0c2whc-g8dpxtvu.jpeg"><br><br>  Der zweite Fall ist, wenn eine Verbindung entsteht.  Dies ist dasselbe - das Schreiben in Y geschieht, bevor aus Y gelesen wird. Es gibt auch keine Verbindung zwischen X. Dementsprechend ist das Ergebnis dasselbe, nur dort erhalten Sie Eins-Null, Null-Eins.  Theoretisch k√∂nnen wir unser neues Programmverhalten nachweisen. <br><br><img src="https://habrastorage.org/webt/ui/zs/7o/uizs7ojlz4smbqktuvisojvjxte.jpeg"><br><br>  Sie k√∂nnen es in der Praxis √ºberpr√ºfen.  Nehmen Sie das fl√ºchtige Schl√ºsselwort und f√ºgen Sie es in unseren Test ein.  Laufen Sie und sehen Sie, dass in der Tat in unserem Land dieser Wert nie reproduziert wird.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also, happen-before ist ein sehr gutes Werkzeug, um die Korrektheit Ihrer Programme zu beweisen. </font><font style="vertical-align: inherit;">Es hat eine weitere interessante und n√ºtzliche Eigenschaft. </font></font><br><br><img src="https://habrastorage.org/webt/p8/xp/ao/p8xpaoj1prrfkwto0t3w7unlsli.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nehmen wir an, wir haben noch so ein kleines St√ºck Code. </font><font style="vertical-align: inherit;">Eine fl√ºchtige Variable X und Variable Z sind nicht fl√ºchtig, kein Unterschied. </font><font style="vertical-align: inherit;">Es gibt einen Thread, der nur in die Variablen X und Z schreibt. </font><font style="vertical-align: inherit;">und der zweite Thread, der wartet, wenn X den Wert eins annimmt und erst dann Z ausgibt. Auf die gleiche Weise k√∂nnen wir die Vor-Ereignis-Beziehung innerhalb desselben Threads und zwischen Threads aufbauen. </font><font style="vertical-align: inherit;">Wir werden sehen, dass der Datensatz in Z im ersten Stream transitiv ist, sein Wert wird immer in Stream 2 gelesen. </font><font style="vertical-align: inherit;">Dies ist tats√§chlich ein ziemlich leistungsf√§higer Mechanismus zum Ver√∂ffentlichen von Daten zwischen Threads.</font></font><br><br>  , ,        ‚Äî       put value.    ‚Äî   get value    .   happens-before   ,       ,  put value happens-before get value.           ,        happens-before   ,   volatile,     .      ,    ,  ‚Äî put  happens-before get. <br><br><img src="https://habrastorage.org/webt/m6/br/hd/m6brhdf3iyak436nje-p-fyrq2a.jpeg"><br><br> ,    . -,  .  ,    ,    .         ,     .  ,     ,     .  ,         .    ,      ,      ,     ,       . <br><br> -,     ,  jcstress.       :     ,   JVM   .      ,        . <br><br>    ,   .  ‚Äî ¬´The Art of Multiprocessor Programming¬ª  .        ,   happens-before,  ,   . .     ‚Äî ¬´Java Concurrency in Practice¬ª  .     ,       .     ,   ,    . .    .       <a href="https://shipilev.net/"> </a> ,   performance-  Oracle,     Red Hat.      ,  Java-  ,   .        JMM. <br><br>    <a href="https://elizarov.livejournal.com/"> </a> .  , -,    .     ,   ,       YouTube.  ,  , .  Danke an alle. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477074/">https://habr.com/ru/post/de477074/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477054/index.html">Webasto k√ºndigt modulares Fahrzeugbatteriesystem an</a></li>
<li><a href="../de477058/index.html">Enterprise Agile Russia bei der Raiffeisenbank 26/11 + Broadcast</a></li>
<li><a href="../de477060/index.html">DataArt wird einen offenen Vortrag von Andrei Terekhov, Leiter der Abteilung f√ºr Systemprogrammierung, Matmekh, St. Petersburg State University, halten</a></li>
<li><a href="../de477062/index.html">Wie der optimierende Compiler funktioniert</a></li>
<li><a href="../de477072/index.html">Kundenentwicklung oder wie man ein Produkt ohne Fehler einf√ºhrt?</a></li>
<li><a href="../de477078/index.html">WebStorm 2019.3: schnellerer Start, verbesserte Unterst√ºtzung f√ºr Vue.js und andere Verbesserungen</a></li>
<li><a href="../de477082/index.html">US-Kongress gegen Zuckerberg: Welche Behauptungen erheben die Aufsichtsbeh√∂rden gegen eine stabile Waage von Facebook</a></li>
<li><a href="../de477084/index.html">Das Gehirn der Firma. Teil 2</a></li>
<li><a href="../de477092/index.html">√úbersicht √ºber die GitHub Repository-Sicherheitstools</a></li>
<li><a href="../de477096/index.html">Wird 5G unserer Gesundheit schaden?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>