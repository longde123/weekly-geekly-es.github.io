<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üó≥Ô∏è üéµ ü•† Karakter sprite modular dan animasinya üëºüèª üíáüèº üñïüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Posting blog ini sepenuhnya dikhususkan untuk sistem animasi karakter saya, diisi dengan tips dan cuplikan kode yang bermanfaat. 

 Selama dua bulan t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Karakter sprite modular dan animasinya</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468991/"> Posting blog ini sepenuhnya dikhususkan untuk sistem animasi karakter saya, diisi dengan tips dan cuplikan kode yang bermanfaat. <br><br>  Selama dua bulan terakhir, saya telah menciptakan sebanyak 9 aksi pemain baru (hal-hal lucu seperti memblokir dengan perisai, menghindari lompatan dan senjata), 17 item yang bisa dipakai, 3 set baju besi (piring, sutra dan kulit) dan 6 jenis gaya rambut.  Saya juga selesai membuat semua otomatisasi dan peralatan, jadi semuanya sudah digunakan dalam game.  Dalam artikel saya akan memberi tahu bagaimana saya mencapai ini! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ef/52a/188/2ef52a1887cdbe639fd35d9df414c38d.gif"></div><br>  <i>Saya harap informasi ini bermanfaat dan membuktikan bahwa tidak perlu menjadi jenius untuk secara mandiri membuat alat / otomasi tersebut.</i> <br><br><h2>  Deskripsi singkat </h2><br>  Awalnya, saya ingin memeriksa apakah mungkin untuk menggabungkan sprite yang ditumpangkan satu sama lain dengan animator yang disinkronkan untuk membuat karakter modular dengan gaya rambut yang dapat diganti, peralatan, dan barang yang bisa dipakai.  Apakah mungkin untuk menggabungkan animasi piksel yang digambar dengan tangan dengan karakter yang benar-benar dapat disesuaikan. <br><br>  Tentu saja, fungsi-fungsi tersebut secara aktif digunakan dalam game 3D dan 2D dengan sprite yang dibuat sebelumnya atau dalam game 2D dengan animasi skeletal, tetapi sejauh yang saya tahu, tidak banyak game yang menggabungkan animasi yang dibuat secara manual dan karakter modular (biasanya karena prosesnya ternyata merupakan terlalu monoton). <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/412/7a9/d23/4127a9d23d4d84e28671deee781495cb.gif"></div><br>  <i>Saya menemukan GIF kuno ini pada bulan pertama saya bersama Unity.</i>  <i>Faktanya, sprite modular ini adalah salah satu percobaan pertama saya dalam pengembangan game!</i> <br><br>  Saya membuat prototipe menggunakan sistem animasi Unity, dan kemudian menambahkan satu kemeja, sepasang celana, satu gaya rambut, dan tiga item untuk menguji konsep tersebut.  Ini membutuhkan 26 animasi terpisah. <br><br>  Pada saat itu, saya membuat semua animasi saya di Photoshop dan tidak repot dengan otomatisasi prosesnya, jadi itu sangat membosankan.  Lalu saya berpikir: "Jadi, ide dasarnya berhasil, nanti saya akan menambahkan animasi dan peralatan baru."  Ternyata "nanti" adalah beberapa tahun kemudian. <br><br>  Pada bulan Maret tahun ini, saya menggambar desain sejumlah besar baju besi (lihat posting saya sebelumnya), dan memperhatikan bagaimana proses ini dapat dibuat lebih nyaman.  Saya terus menunda implementasi, karena bahkan dengan otomatisasi saya merasa gugup bahwa tidak ada yang akan berhasil. <br><br>  Saya berharap bahwa saya harus meninggalkan kustomisasi karakter dan membuat satu-satunya karakter utama, seperti pada kebanyakan game dengan animasi manual.  Tapi aku punya rencana aksi, dan sudah waktunya untuk memeriksa apakah aku bisa mengalahkan monster ini! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/88b/030/c5a/88b030c5a82c6cd801f7ce4d8b08ff6d.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddd/55f/12c/ddd55f12cb35e4fa22093cdddecd63d4.gif" width="500"></div><br>  <i>Spoiler: Semuanya ternyata hebat.</i>  <i>Di bawah ini saya akan mengungkapkan rahasia saya ***</i> <br><br><h2>  Sistem sprite modular </h2><br><h4>  I. Ketahui batasan Anda </h4><br>  Saya menghabiskan banyak pra-pengujian dan seni pemantauan waktu untuk mencari tahu berapa banyak mungkin mengambil pekerjaan tersebut, dan apakah atau tidak terjangkau bagi saya tingkat yang sama kualitas. <br><br>  Saya menuliskan semua ide saya untuk animasi, menyatukannya dalam spreadsheet, dan mengaturnya sesuai dengan berbagai kriteria, seperti kegunaan, keindahan, dan penggunaan berulang.  Untuk mengejutkan saya, pertama dalam daftar ini adalah subjek animasi lemparan (ramuan, bom, pisau, kapak, bola). <br><br>  Saya datang dengan skor numerik untuk setiap animasi dan meninggalkan semuanya dengan kinerja buruk.  Awalnya, saya berencana untuk membuat 6 set baju besi, tetapi segera menyadari bahwa itu terlalu banyak, dan membuang tiga jenis baju besi. <br><br>  Aspek pelacakan waktu ternyata sangat penting, dan saya sangat merekomendasikan menggunakannya untuk menjawab pertanyaan seperti: "Berapa banyak musuh yang mampu saya hasilkan dalam permainan?".  Setelah hanya beberapa tes, saya berhasil memperkirakan perkiraan yang cukup akurat.  Dengan pekerjaan lebih lanjut tentang animasi, saya terus melacak waktu dan merevisi harapan saya. <br><br>  <i>Saya akan membagikan salinan jurnal kerja saya selama dua bulan terakhir.</i>  <i>Harap dicatat bahwa waktu ini merupakan tambahan dari pekerjaan saya yang biasa, di mana saya menghabiskan 30 jam seminggu:</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://docs.google.com/spreadsheets/d/1Nbr7lujZTB4pWMsuedVcgBYS6n5V-rHrk1PxeGxr6Ck/edit?usp=sharing</a> <br><br><h4>  II  Mengubah palet untuk masa depan yang lebih cerah </h4><br>  Dengan menggunakan warna-warna dalam desain sprite dengan bijak, Anda dapat menggambar satu sprite dan membuat banyak variasi berbeda dengan mengubah palet.  Anda dapat mengubah tidak hanya warna, tetapi juga membuat berbagai elemen on dan off (misalnya, mengganti warna dengan transparansi). <br><br>  Setiap set baju besi memiliki 3 variasi, dan dengan mencampur bagian atas dan bawah, Anda bisa mendapatkan banyak kombinasi.  Saya berencana untuk menerapkan sistem di mana Anda dapat mengumpulkan satu set baju besi untuk penampilan karakter, dan yang lain untuk karakteristiknya (seperti dalam Terraria). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/873/80c/0b9/87380c0b99d150828af05b1a0cf33ef6.gif"></div><br>  <i>Dalam prosesnya, saya terkejut dengan kombinasi yang aneh.</i>  <i>Jika Anda menghubungkan bagian atas piring dengan bagian bawah sutra, Anda bisa mendapatkan sesuatu dengan gaya seorang penyihir perang.</i> <br><br>  Yang terbaik adalah mengubah palet menggunakan warna yang menyandikan nilai dalam sprite sehingga Anda nantinya dapat menggunakannya untuk menemukan warna asli dari palet.  Saya tahu saya sedikit menyederhanakan, jadi inilah video untuk Anda mulai: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/u4Iz5AJa31Q" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Saya tidak akan menjelaskan semuanya secara terperinci, tetapi saya akan berbicara tentang cara menerapkan teknik ini dalam Unity, dan pro dan kontra mereka. <br><br><h4>  1. Cari tekstur untuk setiap palet </h4><br>  Ini adalah strategi terbaik untuk membuat variasi musuh, latar belakang, dan semua itu di mana banyak sprite memiliki palet / bahan yang sama.  Bahan-bahan yang berbeda tidak dapat dikelompokkan ke dalam kelompok, bahkan jika mereka menggunakan sprite / atlas yang sama.  Bekerja dengan tekstur cukup menyakitkan, tetapi Anda dapat mengubah palet secara real time dengan mengganti bahan menggunakan SpriteRenderer. SharedMaterial.SetTexture atau MaterialPropertyBlock jika Anda membutuhkan palet yang berbeda untuk setiap contoh materi.  Berikut adalah contoh fungsi fragmen shader: <br><br><pre><code class="cpp hljs">sampler2D _MainTex; sampler2D _PaletteTex; float4 _PaletteTex_TexelSize; <span class="hljs-function"><span class="hljs-function">half4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v2f input)</span></span></span><span class="hljs-function"> : SV_TARGET </span></span>{ half4 lookup = tex2D(_MainTex, input.uv); half4 color = tex2D(_PaletteTex, half2(lookup.r * (_PaletteTex_TexelSize.x / <span class="hljs-number"><span class="hljs-number">0.00390625f</span></span>), <span class="hljs-number"><span class="hljs-number">0.5</span></span>)); color.a *= lookup.a; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> color * input.color; }</code> </pre> <br><h4>  2. Array warna </h4><br>  Aku berhenti di keputusan ini, karena saya harus mengganti palet setiap kali mengubah tampilan karakter (misalnya, untuk menempatkan artikel), dan untuk membuat beberapa palet dinamis (untuk menampilkan yang dipilih warna pemain rambut dan kulit).  Sepertinya saya bahwa pada saat runtime dan editor untuk keperluan ini akan lebih mudah untuk bekerja dengan array. <br><br>  Kode: <br><br><pre> <code class="cpp hljs">sampler2D _MainTex; half4 _Colors[<span class="hljs-number"><span class="hljs-number">32</span></span>]; <span class="hljs-function"><span class="hljs-function">half4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v2f input)</span></span></span><span class="hljs-function"> : SV_TARGET </span></span>{ half4 lookup = tex2D(_MainTex, input.uv); half4 color = _Colors[round(lookup.r * <span class="hljs-number"><span class="hljs-number">255</span></span>)]; color.a *= lookup.a; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> color * input.color; }</code> </pre> <br>  Saya menyajikan palet saya sebagai jenis ScriptableObject dan menggunakan alat MonoBehaviour untuk mengeditnya.  Setelah bekerja lama untuk mengedit palet dalam proses membuat animasi di Aseprite, saya menyadari alat apa yang saya butuhkan dan menulis skrip ini sesuai.  Jika Anda ingin menulis alat Anda sendiri untuk mengedit palet, maka berikut adalah beberapa fungsi yang saya sarankan untuk diterapkan: <br><br>  - Memperbarui palet pada berbagai bahan saat mengedit warna untuk menampilkan perubahan secara real time. <br><br>  - Menetapkan nama dan mengubah urutan warna dalam palet (gunakan bidang untuk menyimpan indeks warna, bukan urutannya dalam array). <br><br>  - Pilih dan edit beberapa warna sekaligus.  (Kiat: Anda dapat menyalin dan menempel bidang Warna di Persatuan: cukup klik satu warna, salin, klik pada warna lain, tempel - sekarang semuanya sama!) <br><br>  - Terapkan warna overlay ke seluruh palet <br><br>  - Rekam palet dalam tekstur <br><br><h4>  3. Tekstur pencarian tunggal untuk semua palet </h4><br>  Jika Anda ingin mengganti palet dengan cepat, tetapi pada saat yang sama Anda perlu batch untuk mengurangi jumlah panggilan draw, maka Anda dapat menggunakan teknik ini.  Ini mungkin berguna untuk platform seluler, tetapi menggunakannya cukup merepotkan. <br><br>  Pertama, Anda harus mengemas semua palet menjadi satu tekstur besar.  Kemudian Anda menggunakan warna yang ditentukan dalam komponen SpriteRenderer (warna titik AKA) untuk menentukan garis yang akan dibaca dari tekstur palet ke dalam shader.  Yaitu, palet sprite ini dikendalikan melalui SpriteRenderer.color.  Warna verteks adalah satu-satunya properti SpriteRenderer yang dapat diubah tanpa merusak kondisinya (asalkan semua bahannya sama). <br><br>  Dalam kebanyakan kasus, yang terbaik adalah menggunakan saluran alfa untuk mengontrol indeks, karena Anda mungkin tidak akan membutuhkan banyak sprite dengan transparansi yang berbeda. <br><br>  Kode: <br><br><pre> <code class="cpp hljs">sampler2D _MainTex; sampler2D _PaletteTex; float4 _PaletteTex_TexelSize; <span class="hljs-function"><span class="hljs-function">half4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v2f input)</span></span></span><span class="hljs-function"> : SV_TARGET </span></span>{ half4 lookup = tex2D(_MainTex, input.uv); half2 paletteUV = half2( lookup.r * _(PaletteTex_TexelSize.x / <span class="hljs-number"><span class="hljs-number">0.00390625f</span></span>), input.color.a * _(PaletteTex_TexelSize.y / <span class="hljs-number"><span class="hljs-number">0.00390625f</span></span>) ) half4 color = tex2D(_PaletteTex, paletteUV); color.a *= lookup.a; color.rgb *= input.color.rgb; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> color; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/47c/f90/895/47cf908951a0ba9f8f65a57711a5c85c.gif"></div><br>  <i>Keajaiban mengganti palet dan lapisan sprite.</i>  <i>Begitu banyak kombinasi.</i> <br><br><h4>  III.  Otomasi semuanya dan gunakan alat yang tepat. </h4><br>  Untuk mengimplementasikan fungsi ini, otomatisasi mutlak diperlukan, karena sebagai hasilnya saya mendapat sekitar 300 animasi dan ribuan sprite. <br><br>  Langkah pertama saya adalah membuat eksportir untuk Aseprite untuk mengelola skema lapisan sprite gila saya menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">antarmuka baris perintah yang</a> nyaman.  Ini hanya skrip perl yang mem-bypass semua layer dan label dalam file Aseprite saya dan mengekspor gambar dalam direktori dan struktur nama tertentu sehingga saya bisa membacanya nanti. <br><br>  Lalu saya menulis importir untuk Unity.  Aseprite menampilkan file JSON yang nyaman dengan data bingkai, sehingga Anda dapat membuat aset animasi secara terprogram.  Pengolahan Aseprite JSON dan menulis jenis data terbukti cukup membosankan, jadi saya membawa mereka di sini.  Anda dapat dengan mudah memuatnya ke Unity menggunakan JsonUtility.FromJson &lt;AespriteData&gt;, ingatlah untuk menjalankan Aseprite dengan opsi --format 'json-array'. <br><br>  Kode: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">System.Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> AespriteData { [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Size { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> h; } [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Position { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> h; } [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Frame { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> filename; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Position frame; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> rotated; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> trimmed; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Position spriteSourceSize; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Size sourceSize; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> duration; } [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Metadata { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> app; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> version; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> format; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Size size; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> scale; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Frame[] frames; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Metadata meta; }</code> </pre> <br>  Di sisi Unity, saya punya masalah serius di dua tempat: memuat / mengiris sprite sheet dan membuat klip animasi.  Contoh yang jelas akan banyak membantu saya, jadi di sini ada potongan kode dari importir saya sehingga Anda tidak terlalu menderita: <br><br>  Kode: <br><br><pre> <code class="cs hljs">TextureImporter textureImporter = AssetImporter.GetAtPath(spritePath) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> TextureImporter; textureImporter.spriteImportMode = SpriteImportMode.Multiple; SpriteMetaData[] spriteMetaData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpriteMetaData[aespriteData.frames.Length]; <span class="hljs-comment"><span class="hljs-comment">// Slice the spritesheet according to the aesprite data. for (int i = 0; i &lt; aespriteData.frames.Length; i++) { AespriteData.Position spritePosition = aespriteData.frames[i].frame; spriteMetaData[i].name = aespriteData.frames[i].filename; spriteMetaData[i].rect = new Rect(spritePosition.x, spritePosition.y, spritePosition.w, spritePosition.h); spriteMetaData[i].alignment = (int)SpriteAlignment.Custom; // Same as "Pivot" in Sprite Editor. spriteMetaData[i].pivot = new Vector2(0.5f, 0f); // Same as "Custom Pivot" in Sprite Editor. Ignored if alignment isn't "Custom". } textureImporter.spritesheet = spriteMetaData; AssetDatabase.ImportAsset(spritePath, ImportAssetOptions.ForceUpdate); Object[] assets = AssetDatabase.LoadAllAssetsAtPath(spritePath); // The first element in this array is actually a Texture2D (ie the sheet itself). for (int i = 1; i &lt; assets.Length; i++) { sprites[i - 1] = assets[i] as Sprite; } // Create the animation. AnimationClip clip = new AnimationClip(); clip.frameRate = 40f; float frameLength = 1f / clip.frameRate; ObjectReferenceKeyframe[] keyframes = new ObjectReferenceKeyframe[aespriteData.frames.Length + 1]; // One extra keyframe is required at the end to express the last frame's duration. float time = 0f; for (int i = 0; i &lt; keyframes.Length; i++) { bool lastFrame = i == keyframes.Length - 1; ObjectReferenceKeyframe keyframe = new ObjectReferenceKeyframe(); keyframe.value = sprites[lastFrame ? i - 1 : i]; keyframe.time = time - (lastFrame ? frameLength : 0f); keyframes[i] = keyframe; time += lastFrame ? 0f : aespriteData.frames[i].duration / 1000f; } EditorCurveBinding binding = new EditorCurveBinding(); binding.type = typeof(SpriteRenderer); binding.path = ""; binding.propertyName = "m_Sprite"; AnimationUtility.SetObjectReferenceCurve(clip, binding, keyframes); AssetDatabase.CreateAsset(clip, "Assets/Animation/" + name + ".anim"); AssetDatabase.SaveAssets();</span></span></code> </pre> <br>  Jika Anda belum melakukannya, percayalah - sangat mudah untuk mulai membuat alat Anda sendiri.  Trik termudah adalah dengan menempatkan GameObject di tempat kejadian dengan MonoBehaviour terpasang, yang memiliki atribut [ExecuteInEditMode].  Tambahkan tombol dan Anda siap bertempur!  Ingatlah bahwa alat pribadi Anda tidak harus terlihat bagus, mereka bisa murni utilitarian. <br><br>  Kode: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">ExecuteInEditMode</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyCoolTool</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> button; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (button) { button = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; DoThing(); } } }</code> </pre> <br>  Ketika bekerja dengan sprite, cukup mudah untuk mengotomatisasi tugas standar (misalnya, membuat tekstur palet atau mengganti warna dalam beberapa file sprite).  Berikut adalah contoh dari mana Anda bisa mulai belajar bagaimana mengubah sprite Anda. <br><br>  Kode: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = <span class="hljs-string"><span class="hljs-string">"Assets/Whatever/Sprite.png"</span></span>; Texture2D texture = AssetDatabase.LoadAssetAtPath&lt;Texture2D&gt;(path); TextureImporter textureImporter = AssetImporter.GetAtPath(path) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> TextureImporter; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!textureImporter.isReadable) { textureImporter.isReadable = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; AssetDatabase.ImportAsset(path, ImportAssetOptions.ForceUpdate); } Color[] pixels = texture.GetPixels(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, texture.width, texture.height); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; pixels.Length; i++) { <span class="hljs-comment"><span class="hljs-comment">// Do something with the pixels, eg replace one color with another. } texture.SetPixels(pixels); texture.Apply(); textureImporter.isReadable = false; // Make sure textures are marked as un-readable when you're done. There's a performance cost to using readable textures in your project that you should avoid unless you plan to change a sprite at runtime. byte[] bytes = ImageConversion.EncodeToPNG(texture); File.WriteAllBytes(Application.dataPath + path.Substring(6), bytes); AssetDatabase.ImportAsset(path, ImportAssetOptions.ForceUpdate);</span></span></code> </pre> <br><h4>  Bagaimana Saya Mengatasi Peluang Mecanim: Keluhan </h4><br>  Seiring waktu, sistem sprite modular prototipe yang saya buat menggunakan Mecanim menjadi masalah terbesar ketika meningkatkan Unity, karena API terus berubah dan kurang didokumentasikan.  Dalam kasus mesin keadaan sederhana, akan lebih bijaksana untuk dapat menanyakan status setiap klip atau mengubah klip saat runtime.  Tapi tidak!  Untuk alasan kinerja, Unity membuat klip di negara mereka dan memaksa kami untuk menggunakan sistem redefinisi yang ceroboh untuk mengubahnya. <br><br>  Mecanim sendiri bukanlah sistem yang buruk, tetapi bagi saya tampaknya tidak berhasil mewujudkan fitur utama yang dinyatakan - kesederhanaan.  Gagasan para pengembang adalah mengganti apa yang tampak rumit dan menyakitkan (scripting) dengan sesuatu yang sederhana (mesin visual state).  Namun: <br><br>  - Setiap mesin negara terbatas non-sepele dengan cepat berubah menjadi web liar node dan koneksi, logika yang tersebar di berbagai lapisan. <br><br>  - Kasing penggunaan sederhana terhalang oleh persyaratan sistem umum.  Untuk memainkan satu atau dua animasi, Anda perlu membuat controller baru dan menetapkan status / transisi.  Tentu saja, ada pemborosan sumber daya yang berlebihan. <br><br>  - Sangat lucu bahwa sebagai hasilnya, Anda masih harus menulis kode, karena agar mesin negara dapat melakukan sesuatu yang menarik, Anda memerlukan skrip yang memanggil Animator. SetBool dan metode serupa. <br><br>  - Untuk beberapa penggunaan mesin negara dengan klip lain, Anda perlu menduplikat dan mengganti klip secara manual.  Di masa depan, Anda harus membuat perubahan di beberapa tempat. <br><br>  - Jika Anda ingin mengubah apa yang ada dalam keadaan saat runtime, maka Anda memiliki masalah.  Solusinya adalah API yang buruk atau grafik gila dengan satu simpul untuk setiap animasi yang mungkin. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/8VgQ5PpTqjc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Kisah tentang bagaimana pengembang Firewatch masuk ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">neraka scripting visual</a> .</i>  <i>Lucunya ketika pembicara menunjukkan contoh paling sederhana, mereka tetap terlihat gila.</i>  <i>Penonton benar-benar mengerang pada jam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">12:41</a> .</i>  <i>Tambahkan biaya perawatan besar, dan Anda akan mengerti mengapa saya sangat tidak menyukai sistem ini.</i> <br><br>  Banyak dari masalah ini bahkan bukan kesalahan pengembang Mecanim, tetapi hanya hasil alami dari ide-ide yang tidak kompatibel: Anda tidak dapat membuat sistem sederhana yang umum dan pada saat yang sama, dan menggambarkan logika menggunakan gambar lebih sulit dari sekedar kata / simbol (apakah ada yang ingat diagram alur UML?) .  Saya ingat sebagian dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan Zack McClendon di Praktik NYC 2018</a> , dan jika Anda punya waktu, saya sarankan Anda menonton seluruh video! <br><br>  Namun, saya menemukan jawabannya.  Visual scripting selalu dikecam oleh kutu buku agresif "tulis mesin Anda sendiri" yang tidak mengerti kebutuhan artis.  Selain itu, tidak dapat dipungkiri bahwa sebagian besar kode tampak seperti jargon teknis yang tidak dapat dipahami. <br><br>  Jika Anda sudah menjadi programmer kecil dan membuat game dengan sprite, maka Anda mungkin perlu berpikir dua kali.  Ketika saya mulai, saya yakin bahwa saya tidak akan pernah bisa menulis sesuatu yang berhubungan dengan mesin lebih baik daripada pengembang Unity. <br><br>  Dan tahukah Anda?  Ternyata sprite animator hanyalah sebuah skrip yang mengubah sprite setelah beberapa detik.  Meskipun demikian, saya masih harus menulis sendiri.  Sejak itu saya telah menambahkan acara animasi dan fungsi lainnya ke proyek spesifik saya, tetapi versi dasar yang saya tulis setengah hari mencakup 90% dari kebutuhan saya.  Ini terdiri dari hanya 120 baris dan dapat diunduh secara gratis dari sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://pastebin.com/m9Lfmd94</a> .  Terima kasih telah membaca artikel saya.  Sampai ketemu lagi! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id468991/">https://habr.com/ru/post/id468991/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468967/index.html">"Teknologi" untuk mendapatkan persamaan dinamika TAU. Dan mengapa Sistem Identifikasi menyebalkan, dan "fisika jujur" berkuasa</a></li>
<li><a href="../id468969/index.html">Buat pengguna Google dari PowerShell via API</a></li>
<li><a href="../id468971/index.html">Menulis di Java untuk Nintendo DS</a></li>
<li><a href="../id468973/index.html">Jaringan saraf untuk mengklasifikasikan gambar satelit menggunakan Tensorflow in Python</a></li>
<li><a href="../id468989/index.html">Pasar UEBA Meninggal - UEBA Langsung Lama</a></li>
<li><a href="../id468993/index.html">Oculus Quest terhubung ke PC dan melihat tangan</a></li>
<li><a href="../id468995/index.html">Kebijakan keterbukaan: bagaimana pengguna memengaruhi proyek</a></li>
<li><a href="../id468997/index.html">Mentoring - bonus yang harus dimiliki atau bagus?</a></li>
<li><a href="../id468999/index.html">Negara mana yang memiliki Internet "paling lambat" dan yang memperbaiki situasi di wilayah yang sulit dijangkau</a></li>
<li><a href="../id469001/index.html">Cara memasak bubur dari microservices</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>