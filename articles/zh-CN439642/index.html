<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏲️ 🧝 🌠 Java的陷阱。 第一部分 🧛🏻 👩‍👧 🏟️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="你好 我想提请您注意一篇简短的文章。 本文适用于初学者。 但是，即使您是经验丰富的开发人员，也请不要下结论。 
 我希望该出版物不仅对初学者有用。 

 本出版物的目的： 
 向初学者展示最常见的错误以及一些纠正错误的技巧。 显然，某些错误可能很复杂，并且由于某种原因或另一种原因而发生。 该出版物的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Java的陷阱。 第一部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439642/">你好 我想提请您注意一篇简短的文章。 本文适用于初学者。 但是，即使您是经验丰富的开发人员，也请不要下结论。 <br> 我希望该出版物不仅对初学者有用。 <br><br>  <i>本出版物的目的：</i> <br> 向初学者展示最常见的错误以及一些纠正错误的技巧。 显然，某些错误可能很复杂，并且由于某种原因或另一种原因而发生。 该出版物的目的是在某种程度上分析它们并帮助及早识别。 我希望该出版物对初学者有用。 <br><br> 错误清单： <br><a name="habracut"></a><br>  1.错别字。 烦人的错别字不会立即显示 <br>  2.条件分配而不是比较 <br>  3.条件中的逻辑错误 <br>  4.错误的字符串比较 <br>  5.基本类型变量的初始化不正确 <br>  6.双重使用不当 <br>  7.构造函数中返回值的类型错误。 <br>  8.除以零。  POSITIVE_INFINITY <br>  9.不考虑类的初始化顺序 <br>  10.局部变量隐藏了一个类变量 <br>  11.忽略算术表达式中的自动转换 <br>  12.带字节的无限循环，难以检测。 <br>  13.类的名称与存储它的文件的名称不同。 <br>  14.作为数组元素的对象未初始化。 <br>  15.使用public修饰符一次将多个类放在一个文件中 <br><cut></cut><br><h3>  Java陷阱 </h3><br> 所有编程语言都有其优点和缺点。 这是由于许多原因。  Java也不例外。 我试图收集新手Java程序员遇到的一些明显的和不明显的困难。 我相信有经验的程序员也会在我的文章中找到有用的东西。 练习，专心和积累的编程经验将帮助您避免许多错误。 但是最好事先考虑一些错误和困难。 我将给出一些带有代码和解释的示例。 通过对代码的注释，许多解释将对您清晰明了。 由于一些规则不是很明显，实践给了很多。 有些位于表面上，有些则隐藏在语言库或Java虚拟机中。 请记住，java不仅是具有一组库的编程语言，还是Java虚拟机。 <br><br> 对于这篇文章，我专门编写了带有详细注释的工作代码。 为了编写带有代码示例的文章，使用了Java 8，为了进行测试，将Java代码放在单独的程序包中。 <br><br> 示例：“ packageunderwaterRocks.simple;” <br><br> 初学者面临什么困难？ <br><br><h3> 错别字 </h3><br> 碰巧的是，新手程序员所做的错别字一目了然。 <br><br><cut></cut><br>  <i>代码示例：</i> <br><br> 文件：“ Simple.java” <br><br><pre><code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/*   ;     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">package</span></span> underwaterRocks.simple; <span class="hljs-comment"><span class="hljs-comment">/** * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@author</span></span></span><span class="hljs-comment"> Ar20L80 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Simple</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ival = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ival&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>); { System.out.println(<span class="hljs-string"><span class="hljs-string">"     "</span></span>); } } }</code> </pre> <br><cut></cut><br>  <i>说明</i> ：“分号表示语句的结尾。 在这种情况下； 空语句的结尾。 这是一个逻辑错误。 这样的错误可能很难检测到。 <br><br> 编译器将认为一切正确。 条件（ival&gt; 0）; 在这种情况下没有意义。 因为这意味着：如果ival大于零，则不执行任何操作并继续。” <br><br><h3> 条件分配而不是比较 </h3><br> 条件是变量分配。 <br><br> 这不是一个错误，但是应该证明使用这种技术是合理的。 <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> myBool = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(myBool = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) System.out.println(myBool);</code> </pre> <br> 在这段代码中，如果（myBool = true）表示：“将变量myBool设置为true， <br> 如果表达式为真，则遵循括号后面的条件。” <br><br> 在此代码中，条件将始终为true。 和System.out.println（myBool）; 无论条件如何，都将始终执行。 <br><br>  ==是相等性的比较。 <br>  =是一项作业，可以说a = 10； 例如：“但指定值为10”。 <br><br> 括号中的条件返回布尔值。 <br> 编写顺序无关紧要。 您可以像这样比较：（0 == a）或（5 == a） <br> 如果忘记一个等号，例如（0 = a）或（5 = a），则编译器将通知您错误。 您分配一个值，而不是一个比较。 <br> 您也可以以可读的形式写一些时间间隔。 <br> 例如：您需要写：大于5小于10。 <br> 您可以这样写：（a&gt; 4 &amp;&amp; a &lt;10），但是成功的话，您可以这样写：（4 &lt;a &amp;&amp; a &lt;10）， <br> 现在您看到a在4到10之间，不包括这些值。 这更加明显。 显然，不包括这些值的a在4到10之间。 <br><br> 代码示例（间隔为3.9 []）： <br> 如果（3 &lt;a &amp;&amp; a &lt;9）执行; <br><br><h3> 逻辑错误 </h3><br>  if（condition）{} if（condition）{} else {}-else表示最接近的if。 <br> 这通常是初学者错误的原因。 <br><br><h3> 无效的字符串比较 </h3><h3> 初学者经常使用==代替.equals来比较字符串。 <br><br></h3><h3> 变量初始化 </h3><br> 考虑初始化基本类型的变量。 <br><br> 基元（字节，短整数，整数，长整数，字符，浮点数，双精度，布尔值）。 <br><br> 初始值。 <br><cut></cut><br><pre> <code class="plaintext hljs">byte 0 short 0 int 0 long 0L float 0.0f double 0.0d char '\u0000' String (or any object) null boolean false (  jvm)</code> </pre> <br><cut></cut><br>  <i>注意事项：</i> <br><br> 局部变量略有不同。 <br> 编译器永远不会将默认值分配给未初始化的局部变量。 <br><br> 如果您无法在声明它的地方初始化本地变量， <br> 请记住在尝试使用之前为其分配一个值。 <br><br> 访问未初始化的局部变量将导致编译时错误。 <br><br>  <i>在代码中确认此注释：</i> <br><br> 文件：“ MyInitLocal.java” <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/*         */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">package</span></span> underwaterRocks.myInit; <span class="hljs-comment"><span class="hljs-comment">/** * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@author</span></span></span><span class="hljs-comment"> Ar20L80 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInitLocal</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> classes_f; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> classes_gi; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> f; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; MyInitLocal myInit = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyInitLocal(); <span class="hljs-comment"><span class="hljs-comment">/*         .*/</span></span> System.out.println(<span class="hljs-string"><span class="hljs-string">"myInit.classes_f = "</span></span> + myInit.classes_f); System.out.println(<span class="hljs-string"><span class="hljs-string">"myInit.classes_gi = "</span></span> + myInit.classes_gi); <span class="hljs-comment"><span class="hljs-comment">// System.out.println("f = " + f); // .     // System.out.println("f = " + i); // .     } }</span></span></code> </pre> <br><br> 值范围： <br><br> <code>byte ( , 1 , [-128, 127]) <br> short ( , 2 , [-32768, 32767]) <br> int ( , 4 , [-2147483648, 2147483647]) <br> long ( , 8 , [-922372036854775808,922372036854775807]) <br> float ( , 4 ) <br> double ( , 8 ) <br> char ( Unicode, 2 , 16 , [0, 65535]) <br> boolean ( /,  int,   JVM)</code> <br> <blockquote>  char：char数据类型是单个16位Unicode字符。 它的最小值为“ \ u0000”（或0），最大值为“ \ uffff”（或65,535（含））。 </blockquote><br><br>  Oracle文档<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">&gt;&gt;</a> <br><br> 让我们尝试初始化一个数字类型为long的变量：922372036854775807。 <br> 没有任何事情对我们有利。 因为它是int类型的整数文字。 <br> 使用长文字正确初始化：922372036854775807L; <br><br>  <i>代码示例：</i> <br><br> 文件：“ MyInitLocalLong.java” <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/*    long  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">package</span></span> underwaterRocks.myInit; <span class="hljs-comment"><span class="hljs-comment">/** * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@author</span></span></span><span class="hljs-comment"> Ar20L80 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInitLocalLong</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// long al = 922372036854775807; // integer number too large long bl = 922372036854775807L; //   } }</span></span></code> </pre><br><br> 初始化变量时要查找什么。 <br><br> 此类型的变量的值范围。 用某种类型的文字初始化变量的事实。 用于显式和隐式强制转换。 关于类型兼容性。 <br><br> 使用Integer类型的shell时，应注意这些类型的自动打包和自动拆包。 <br><br><h3> 双重使用不当 </h3><br> 在这里您需要澄清。 这与滥用double类型无关。 <br> 我们正确使用。 只有结果才能使新手程序员感到惊讶。 <br> 文件：“ MinusDouble.java” <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">package</span></span> underwaterRocks.tstDouble; <span class="hljs-comment"><span class="hljs-comment">/** * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@author</span></span></span><span class="hljs-comment"> vvm */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MinusDouble</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> a = <span class="hljs-number"><span class="hljs-number">4.64</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> b = <span class="hljs-number"><span class="hljs-number">2.64</span></span>; System.out.println(<span class="hljs-string"><span class="hljs-string">"ab = "</span></span>+(ab)); } } <span class="hljs-comment"><span class="hljs-comment">/*   run: ab = 1.9999999999999996 */</span></span></code> </pre><br><br>  <i>注意有关双精度型。</i> 浮点数可让您以给定的相对误差和很大的范围进行计数。 在科学计算中，经常需要相对误差。 <br><br><h3> 无效的双重比较 </h3><br> 考虑双重类型。 <br><br>  <i>代码示例：</i> <br><br> 文件：“ MyDouble.java” <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/*    double  - double. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">package</span></span> underwaterRocks.myDouble; <span class="hljs-comment"><span class="hljs-comment">/** * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@author</span></span></span><span class="hljs-comment"> Ar20L80 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyDouble</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> dx = <span class="hljs-number"><span class="hljs-number">1.4</span></span> - <span class="hljs-number"><span class="hljs-number">0.1</span></span> - <span class="hljs-number"><span class="hljs-number">0.1</span></span> - <span class="hljs-number"><span class="hljs-number">0.1</span></span> - <span class="hljs-number"><span class="hljs-number">0.1</span></span>; System.out.println(<span class="hljs-string"><span class="hljs-string">"dx = "</span></span> + dx); <span class="hljs-comment"><span class="hljs-comment">// dx = 0.9999999999999997 System.out.print(" (dx == 1.0):"); System.out.println(dx == 1.0); // false,   1.0   0.9999999999999997 /*   double*/ final double EPSILON = 1E-14; double xx = 1.4 - 0.1 - 0.1 - 0.1 - 0.1; double xy = 1.0; /*  xx c xy */ if (Math.abs(xx - xy) &lt; EPSILON) System.out.println(xx + "    " + xy + " EPSILON = " + EPSILON); } }</span></span></code> </pre><br> 双精度型在不需要高精度的地方很方便。 对于金融交易，此类型不合适。 尽管有些公司不是很诚实，但使用double型将其舍入到所需的一侧。 对于财务操作，BigDecimal类用于财务计算，因为由于精度损失和舍入结果错误的原因，实际原始类型不适用于该目的。 但是，使用BigInteger类可以获得更准确的结果。 <br><br><h3> 类构造器 </h3><br> 类构造函数与类名称匹配，不返回任何内容，甚至不返回void。 <br><br>  <i>代码示例：</i> <br><br> 文件：“ MyConstructor.java” <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/*      ,  void    void -    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">package</span></span> underwaterRocks.myConstructor; <span class="hljs-comment"><span class="hljs-comment">/** * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@author</span></span></span><span class="hljs-comment"> Ar20L80 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyConstructor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyConstructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"   void"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyConstructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"  c void"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ MyConstructor myconst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyConstructor(); myconst.MyConstructor(); <span class="hljs-comment"><span class="hljs-comment">//    } }</span></span></code> </pre><br> 正如我们在代码中看到的，两个具有相同名称的方法：MyConstructor（）和MyConstructor（）。 其中一种方法不返回任何内容。 这是我们类的构造函数。 另一个带有void的方法是常规类方法。 如果您没有创建构造函数，或者您认为创建的类的构造函数为void，则编译器将创建默认构造函数，您会惊讶为什么构造函数不起作用。 <br><br><h3> 被零除 </h3><br> 您认为将是执行此类代码的结果。 <br><br> 文件：“ DivisionByZero.java” <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/* */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">package</span></span> divisionByZero; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> java.lang.Double.POSITIVE_INFINITY; <span class="hljs-comment"><span class="hljs-comment">/** * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@author</span></span></span><span class="hljs-comment"> Ar20L80 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DivisionByZero</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> f = <span class="hljs-number"><span class="hljs-number">12.2f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d = <span class="hljs-number"><span class="hljs-number">8098098.8790</span></span>d; System.out.println(f/<span class="hljs-number"><span class="hljs-number">0</span></span>); System.out.println(d/<span class="hljs-number"><span class="hljs-number">0</span></span>); System.out.println(POSITIVE_INFINITY == f/<span class="hljs-number"><span class="hljs-number">0</span></span>); System.out.println(POSITIVE_INFINITY == d/<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (NumberFormatException ex) { System.out.println(<span class="hljs-string"><span class="hljs-string">"NumberFormatException"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ArithmeticException ex) { System.out.println(<span class="hljs-string"><span class="hljs-string">"ArithmeticException"</span></span>); } } }</code> </pre><br> 执行代码将输出： <br><br><pre> <code class="plaintext hljs">Infinity Infinity true true</code> </pre> <br> 将整数类型除以零将产生ArithmeticException。 <br><br>  java.lang.Double类定义常量<code>POSITIVE_INFINITY;</code> <br><br><pre> <code class="1c hljs">public static final float POSITIVE_INFINITY = <span class="hljs-number"><span class="hljs-number">1.0</span></span>d / <span class="hljs-number"><span class="hljs-number">0.0</span></span>d;</code> </pre> <br> 它将转换为等于Infinity的字符串。 <br><br><h3> 初始化顺序 </h3><br> 文件：“ InitClass.java” <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">package</span></span> myInitClass; <span class="hljs-comment"><span class="hljs-comment">/** * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@author</span></span></span><span class="hljs-comment"> Ar20L80 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InitClass</span></span></span><span class="hljs-class"> </span></span>{ InitClass(){ <span class="hljs-comment"><span class="hljs-comment">//   System.out.print(""); } { //   System.out.print("3 "); } public static void main(String[] args) { System.out.print("2"); new InitClass(); } static { //    System.out.print("1"); } }</span></span></code> </pre><br> 首先，执行所有静态块，然后执行初始化块，然后执行类构造函数。 <br><br> 它将显示：“ 123 Constructor” <br><br>  <b>局部变量隐藏了类变量</b> <br> 尽管现代的IDE可以轻松检测到此错误，但我想更详细地考虑这种错误。 让我们从构造函数中的经典变量赋值开始。 这个例子是正确的。 没有错 <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.val = val; } }</code> </pre><br> 但是，如果在方法中而不是在类构造函数中使用此技术，会发生什么？ 在通常的方法中，不建议使用此技术。 问题与班级的正确设计有关。 <br><br>  <i>一个简单的解释：</i>在方法中，与类变量同名的变量是该方法的局部变量。 您可以使用this.val访问类变量。 但是，如果类的设计不当，则这种方法的吸引力只会导致副作用，并且可能会降低代码的可读性。 <br><br>  <b>算术类型转换是自动完成的</b> <br><br> 这会导致烦人的错误。 <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// byte a = 1; // byte b = 1; // byte  = a + b; //  // byte a = (byte) 1; // byte b = (byte) 1; // byte  = a + b; // </span></span></code> </pre><br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//     —     . byte a = 1; byte b = 1; byte c = (byte) (a + b);</span></span></code> </pre><br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//     —  final // final byte a = 1; // final byte b = 1; // byte c = a + b; //    ,  a  b final</span></span></code> </pre><br><br> 使用字符串时，一种可能的解决方案： <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> bHundr = Byte.parseByte(<span class="hljs-string"><span class="hljs-string">"100"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      byte</span></span></code> </pre> <br><br> 以下代码给出了另一个错误。 <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">128</span></span>; i++) { System.out.println(i); }</code> </pre><br> 在这种情况下，我们得到一个无限循环。 <br><br>  <i>的解释。</i> 键入字节[-128，127]。  128不再在此范围内。 发生溢出，并且循环重复。 在这种情况下使用字节的必要性令人怀疑。 尽管这种情况很少发生。 建议使用int而不是字节。 另一个建议是不要在算法中使用循环。 <br><br>  <b>数组元素的对象未初始化</b> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] cats = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;cats.length;i++){ System.out.println(<span class="hljs-string"><span class="hljs-string">"cats "</span></span> + i + <span class="hljs-string"><span class="hljs-string">" = "</span></span> + cats[i]); }</code> </pre><br><br> 在这个例子中，我们有一个原始类型元素的数组。 如果不初始化它们，也不会发生任何不良情况。 它们将被分配默认值。 在这种情况下，值= 0。 <br><br> 让我们考虑另一个示例，该示例不在数组中包含基元，而是在数组中包含对象。 <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArrInitObj</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ MyObj[] cats = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyObj[<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;cats.length;i++){ System.out.println(<span class="hljs-string"><span class="hljs-string">"cats "</span></span> + i + <span class="hljs-string"><span class="hljs-string">" = "</span></span> + cats[i]); System.out.println(<span class="hljs-string"><span class="hljs-string">"cats "</span></span> + i + <span class="hljs-string"><span class="hljs-string">".val = "</span></span> + cats[i].val); <span class="hljs-comment"><span class="hljs-comment">//    java.lang.NullPointerException } } } class MyObj{ public int val; }</span></span></code> </pre><br><br> 解决此问题的方法是在使用它们之前初始化所有对象变量。 可以在MyObj类的构造函数中完成初始化。 <br><br>  <b>类名与存储它的文件名不同</b> <br> 现代IDE可以轻松检测到此类错误。 但是，尽管很少遇到这种错误。 考虑到大小写字母名称的差异，这将有助于注意。 <br><br>  <b>使用public修饰符一次将多个类放在一个文件中</b> <br> 该错误非常罕见。  IDE将立即向您发出警告。 <br> 文件名必须与公共类的名称匹配。 <br><br>  <b>结论</b> <br> 乍看之下，许多错误并不明显。 即使是经验丰富的程序员也可以这样做，但数量较少。 细心，实际经验，使用调试器和阅读文档将帮助您避免许多错误。 <br><br> 我希望您喜欢这篇文章并发现对您有所帮助。 我很高兴您的意见，评论，建议和愿望。 待续。 相反，添加如下。 <br><br>  <b>参考文献</b> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Oracle Java代码设计指南&gt;&gt;&gt;</a> <br><br>  PS。 我的朋友们 没有您的帮助，我无法继续发布。 也就是说，没有经济机会。 如果该出版物确实对您有所帮助，并且您想继续，请支持我。 某个地方有一个按钮：“支持作者”。 <br> 希望您的理解。 谢谢啦 感谢Habr发布的机会。 <br><br> 如果缺乏支持，作者将被迫删除自己的出版物或将其隐藏在草稿中。 这不是最后通.。 如果有机会，它会派上用场，您可以提供帮助，然后单击作者支持按钮。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN439642/">https://habr.com/ru/post/zh-CN439642/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN439628/index.html">ASP.NET Web API中的并行数据刷新</a></li>
<li><a href="../zh-CN439632/index.html">如何为您的项目设置持续部署：个人经验</a></li>
<li><a href="../zh-CN439636/index.html">改善道路安全的概念危机和解决之道的新概念</a></li>
<li><a href="../zh-CN439638/index.html">在Python中获取FPGA</a></li>
<li><a href="../zh-CN439640/index.html">乙烯基又回来了，他与众不同</a></li>
<li><a href="../zh-CN439644/index.html">抗衰老：Senolytics和干细胞置换疗法</a></li>
<li><a href="../zh-CN439646/index.html">由于价格下跌，软银控股出售Nvidia的股份，但仍获得33亿美元</a></li>
<li><a href="../zh-CN439652/index.html">如何将您的初创公司运送到美国：4个重要步骤</a></li>
<li><a href="../zh-CN439654/index.html">完全沉浸式：我们如何在Bitfury上冷却ASIC芯片</a></li>
<li><a href="../zh-CN439656/index.html">C＃中的字符计算器</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>