<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤽🏽 🍔 🧙🏼 Cartes hexagonales dans Unity: brouillard de guerre, recherche cartographique, génération procédurale 👩🏾‍🤝‍👨🏼 🥖 🙅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parties 1-3: maillage, couleurs et hauteurs de cellule 

 Parties 4-7: bosses, rivières et routes 

 Parties 8-11: eau, reliefs et remparts 

 Parties...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cartes hexagonales dans Unity: brouillard de guerre, recherche cartographique, génération procédurale</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427003/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 1-3: maillage, couleurs et hauteurs de cellule</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 4-7: bosses, rivières et routes</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 8-11: eau, reliefs et remparts</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 12-15: sauvegarde et chargement, textures, distances</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 16-19: trouver le chemin, équipes de joueurs, animations</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 20-23: Brouillard de guerre, recherche cartographique, génération procédurale</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 24-27: cycle de l'eau, érosion, biomes, carte cylindrique</a> <br><br><h1>  Partie 20: le brouillard de la guerre </h1><br><ul><li>  Enregistrez les données de cellule dans la texture. </li><li>  Modifiez les types de relief sans triangulation. </li><li>  Nous suivons la visibilité. </li><li>  Obscurcissez tout ce qui est invisible. </li></ul><br>  Dans cette partie, nous ajouterons l'effet de brouillard de guerre à la carte. <br><br>  Maintenant, la série sera créée sur Unity 2017.1.0. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/716/b6b/8a9/716b6b8a9d024dc87b2d645b5d4bdbb6.jpg"></div><br>  <i>Maintenant, nous voyons que nous pouvons et ne pouvons pas voir.</i> <br><a name="habracut"></a><br><h2>  Données de cellule dans le shader </h2><br>  De nombreux jeux de stratégie utilisent le concept du brouillard de guerre.  Cela signifie que la vision du joueur est limitée.  Il ne peut voir que ce qui est proche de ses unités ou de sa zone contrôlée.  Bien que nous puissions voir le soulagement, nous ne savons pas ce qui se passe là-bas.  Habituellement, le terrain invisible est rendu plus sombre.  Pour réaliser cela, nous devons suivre la visibilité de la cellule et la rendre en conséquence. <br><br>  Le moyen le plus simple de modifier l'apparence des cellules masquées consiste à ajouter une métrique de visibilité aux données de maillage.  Cependant, en même temps, nous devrons commencer une nouvelle triangulation en relief avec un changement de visibilité.  C'est une mauvaise décision car la visibilité change constamment pendant le match. <br><br>  La technique de rendu sur la topographie d'une surface translucide est souvent utilisée, qui masque partiellement les cellules invisibles au joueur.  Cette méthode convient aux terrains relativement plats en combinaison avec un angle de vision limité.  Mais comme notre terrain peut contenir des hauteurs et des objets très variables qui peuvent être vus sous différents angles, nous avons besoin pour cela d'un maillage très détaillé qui correspond à la forme du terrain.  Cette méthode sera plus coûteuse que l'approche la plus simple mentionnée ci-dessus. <br><br>  Une autre approche consiste à transférer les données des cellules vers le shader lors du rendu séparément du maillage en relief.  Cela nous permettra d'effectuer une triangulation une seule fois.  Les données des cellules peuvent être transférées en utilisant la texture.  Changer la texture est un processus beaucoup plus simple que de trianguler le terrain.  De plus, l'exécution de plusieurs échantillons de texture supplémentaires est plus rapide que le rendu d'une seule couche translucide. <br><br><div class="spoiler">  <b class="spoiler_title">Qu'en est-il de l'utilisation de tableaux de shaders?</b> <div class="spoiler_text">  Vous pouvez également transférer des données de cellule vers le shader à l'aide d'un tableau de vecteurs.  Cependant, les tableaux de shaders ont une limite de taille, mesurée en milliers d'octets, et les textures peuvent contenir des millions de pixels.  Pour prendre en charge de grandes cartes, nous utiliserons des textures. </div></div><br><h3>  Gestion des données cellulaires </h3><br>  Nous avons besoin d'un moyen de contrôler la texture contenant les données des cellules.  Créons un nouveau composant <code>HexCellShaderData</code> qui fera cela. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCellShaderData</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { Texture2D cellTexture; }</code> </pre> <br>  Lors de la création ou du chargement d'une nouvelle carte, nous devons créer une nouvelle texture avec la bonne taille.  Par conséquent, nous y ajoutons une méthode d'initialisation qui crée une texture.  Nous utilisons une texture RGBA sans textures de mip et espace colorimétrique linéaire.  Nous n'avons pas besoin de mélanger les données des cellules, nous utilisons donc le filtrage ponctuel.  De plus, les données ne doivent pas être réduites.  Chaque pixel de la texture contiendra les données d'une cellule. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { cellTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D( x, z, TextureFormat.RGBA32, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); cellTexture.filterMode = FilterMode.Point; cellTexture.wrapMode = TextureWrapMode.Clamp; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">La taille de la texture doit-elle correspondre à la taille de la carte?</b> <div class="spoiler_text">  Non, il suffit d'avoir suffisamment de pixels pour contenir toutes les cellules.  Avec une correspondance exacte avec la taille de la carte, une texture avec des tailles qui ne sont pas des puissances de deux (non-puissance de deux, NPOT) sera très probablement créée, et ce format de texture n'est pas le plus efficace.  Bien que nous puissions configurer le code pour qu'il fonctionne avec des textures de la taille d'une puissance de deux, il s'agit d'une optimisation mineure, qui complique l'accès aux données des cellules. </div></div><br>  En fait, nous n'avons pas à créer une nouvelle texture chaque fois que nous créons une nouvelle carte.  Il suffit de redimensionner la texture si elle existe déjà.  Nous n'avons même pas besoin de vérifier si nous avons déjà la bonne taille, car <code>Texture2D.Resize</code> est assez intelligent pour le faire pour nous. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellTexture) { cellTexture.Resize(x, z); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cellTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D( cellCountX, cellCountZ, TextureFormat.RGBA32, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); cellTexture.filterMode = FilterMode.Point; cellTexture.wrapMode = TextureWrapMode.Clamp; } }</code> </pre> <br>  Au lieu d'appliquer des données de cellule un pixel à la fois, nous utilisons un tampon de couleur et appliquons les données de toutes les cellules à la fois.  Pour ce faire, nous utiliserons le tableau <code>Color32</code> .  Si nécessaire, nous créerons une nouvelle instance de tableau à la fin de <code>Initialize</code> .  Si nous avons déjà un tableau de la bonne taille.  puis nous effaçons son contenu. <br><br><pre> <code class="cs hljs"> Texture2D cellTexture; Color32[] cellTextureData; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellTextureData == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || cellTextureData.Length != x * z) { cellTextureData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color32[x * z]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellTextureData.Length; i++) { cellTextureData[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color32(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); } } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Qu'est-ce que color32?</b> <div class="spoiler_text">  Les textures RGBA non compressées standard contiennent des pixels de quatre octets.  Chacun des quatre canaux de couleur reçoit un octet, c'est-à-dire qu'il a 256 valeurs possibles.  Lorsque vous utilisez la structure Unity <code>Color</code> , ses composants à virgule flottante dans l'intervalle 0–1 sont convertis en octets dans l'intervalle 0–255.  Lors de l'échantillonnage, le GPU effectue la transformation inverse. <br><br>  La structure <code>Color32</code> fonctionne directement avec les octets, donc ils prennent moins d'espace et ne nécessitent pas de conversion, ce qui augmente l'efficacité de leur utilisation.  Étant donné que nous stockons des données de cellule au lieu de couleurs, il sera plus logique de travailler directement avec des données de texture brutes et non avec <code>Color</code> . </div></div><br>  <code>HexGrid</code> doit gérer la création et l'initialisation de ces cellules dans le shader.  Par conséquent, nous y ajouterons un champ <code>cellShaderData</code> et créerons un composant dans <code>Awake</code> . <br><br><pre> <code class="cs hljs"> HexCellShaderData cellShaderData; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; cellShaderData = gameObject.AddComponent&lt;HexCellShaderData&gt;(); CreateMap(cellCountX, cellCountZ); }</code> </pre> <br>  Lors de la création d'une nouvelle carte, <code>cellShaderData</code> doit également être <code>cellShaderData</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … cellCountX = x; cellCountZ = z; chunkCountX = cellCountX / HexMetrics.chunkSizeX; chunkCountZ = cellCountZ / HexMetrics.chunkSizeZ; cellShaderData.Initialize(cellCountX, cellCountZ); CreateChunks(); CreateCells(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3>  Modification des données de cellule </h3><br>  Jusqu'à présent, lors de la modification des propriétés d'une cellule, il était nécessaire de mettre à jour un ou plusieurs fragments, mais maintenant il peut être nécessaire de mettre à jour les données des cellules.  Cela signifie que les cellules doivent avoir un lien vers les données de cellule dans le shader.  Pour ce faire, ajoutez une propriété à <code>HexCell</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCellShaderData ShaderData { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br>  Dans <code>HexGrid.CreateCell</code> nous assignerons un composant de données shader à cette propriété. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { … HexCell cell = cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab); cell.transform.localPosition = position; cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); cell.ShaderData = cellShaderData; … }</code> </pre> <br>  Nous pouvons maintenant demander aux cellules de mettre à jour leurs données de shader.  Bien que nous ne surveillions pas la visibilité, nous pouvons utiliser des données de shader pour autre chose.  Le type de relief de la cellule détermine la texture utilisée pour la rendre.  Cela n'affecte pas la géométrie de la cellule, nous pouvons donc stocker l'indice de type d'élévation dans les données de la cellule, et non dans les données du maillage.  Cela nous permettra de nous débarrasser du besoin de triangulation lors du changement du type de relief de la cellule. <br><br>  Ajoutez une méthode <code>HexCellShaderData</code> à <code>RefreshTerrain</code> pour simplifier cette tâche pour une cellule spécifique.  Laissons cette méthode vide pour l'instant. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br>  Modifiez <code>HexCell.TerrainTypeIndex</code> afin qu'il <code>HexCell.TerrainTypeIndex</code> cette méthode et n'ordonne pas de mettre à jour les fragments. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TerrainTypeIndex { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> terrainTypeIndex; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (terrainTypeIndex != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { terrainTypeIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Refresh(); ShaderData.RefreshTerrain(this); } } }</span></span></code> </pre> <br>  Nous l'appellerons également dans <code>HexCell.Load</code> après avoir reçu le type de topographie de cellule. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadByte(); ShaderData.RefreshTerrain(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); elevation = reader.ReadByte(); RefreshPosition(); … }</code> </pre> <br><h3>  Index des cellules </h3><br>  Pour changer ces cellules, nous devons connaître l'indice de la cellule.  La façon la plus simple de procéder consiste à ajouter la propriété <code>Index</code> à <code>HexCell</code> .  Il indiquera l'index de la cellule dans la liste des cellules de la carte, ce qui correspond à son index dans les cellules données du shader. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Index { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br>  Cet index est déjà dans <code>HexGrid.CreateCell</code> , il suffit donc de l'affecter à la cellule créée. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { … cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); cell.Index = i; cell.ShaderData = cellShaderData; … }</code> </pre> <br>  Désormais, <code>HexCellShaderData.RefreshTerrain</code> peut utiliser cet index pour spécifier des données de cellule.  Enregistrons l'index du type d'élévation dans la composante alpha de son pixel en convertissant simplement le type en octet.  Cela supportera jusqu'à 256 types de terrains, ce qui nous suffira. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cellTextureData[cell.Index].a = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)cell.TerrainTypeIndex; }</code> </pre> <br>  Pour appliquer des données à une texture et les transmettre au GPU, nous devons appeler <code>Texture2D.SetPixels32</code> , puis <code>Texture2D.Apply</code> .  Comme pour les fragments, nous reporterons ces opérations sur <code>LateUpdate</code> afin qu'elles ne puissent être effectuées plus d'une fois par trame, quel que soit le nombre de cellules modifiées. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cellTextureData[cell.Index].a = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)cell.TerrainTypeIndex; enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LateUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { cellTexture.SetPixels32(cellTextureData); cellTexture.Apply(); enabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Pour vous assurer que les données seront mises à jour après la création d'une nouvelle carte, activez le composant après l'initialisation. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3>  Triangulation des indices cellulaires </h3><br>  Puisque nous stockons maintenant l'indice de type d'élévation dans ces cellules, nous n'avons plus besoin de les inclure dans le processus de triangulation.  Mais pour utiliser les données de cellule, le shader doit savoir quels index utiliser.  Par conséquent, vous devez stocker les indices de cellule dans les données de maillage, en remplaçant les indices de type d'élévation.  De plus, nous avons toujours besoin du canal de couleur du maillage pour mélanger les cellules lors de l'utilisation de ces cellules. <br><br>  Nous <code>useColors</code> champs communs obsolètes <code>useColors</code> et <code>useTerrainTypes</code> .  Remplacez-les par un champ <code>useCellData</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public bool useCollider, useColors, useUVCoordinates, useUV2Coordinates; // public bool useTerrainTypes; public bool useCollider, useCellData, useUVCoordinates, useUV2Coordinates;</span></span></code> </pre><br>  Nous refactorisons le changement de nom de la liste <code>cellIndices</code> en <code>cellIndices</code> .  Refactorisons également les <code>colors</code> en <code>cellWeights</code> - ce nom fera mieux. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// [NonSerialized] List&lt;Vector3&gt; vertices, terrainTypes; // [NonSerialized] List&lt;Color&gt; colors; [NonSerialized] List&lt;Vector3&gt; vertices, cellIndices; [NonSerialized] List&lt;Color&gt; cellWeights; [NonSerialized] List&lt;Vector2&gt; uvs, uv2s; [NonSerialized] List&lt;int&gt; triangles;</span></span></code> </pre><br>  Modifiez <code>Clear</code> sorte que lorsque vous utilisez ces cellules, il obtienne deux listes ensemble, et non séparément. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Clear(); vertices = ListPool&lt;Vector3&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useCellData) { cellWeights = ListPool&lt;Color&gt;.Get(); cellIndices = ListPool&lt;Vector3&gt;.Get(); } <span class="hljs-comment"><span class="hljs-comment">// if (useColors) { // colors = ListPool&lt;Color&gt;.Get(); // } if (useUVCoordinates) { uvs = ListPool&lt;Vector2&gt;.Get(); } if (useUV2Coordinates) { uv2s = ListPool&lt;Vector2&gt;.Get(); } // if (useTerrainTypes) { // terrainTypes = ListPool&lt;Vector3&gt;.Get(); // } triangles = ListPool&lt;int&gt;.Get(); }</span></span></code> </pre> <br>  Effectuez le même regroupement dans <code>Apply</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.SetVertices(vertices); ListPool&lt;Vector3&gt;.Add(vertices); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useCellData) { hexMesh.SetColors(cellWeights); ListPool&lt;Color&gt;.Add(cellWeights); hexMesh.SetUVs(<span class="hljs-number"><span class="hljs-number">2</span></span>, cellIndices); ListPool&lt;Vector3&gt;.Add(cellIndices); } <span class="hljs-comment"><span class="hljs-comment">// if (useColors) { // hexMesh.SetColors(colors); // ListPool&lt;Color&gt;.Add(colors); // } if (useUVCoordinates) { hexMesh.SetUVs(0, uvs); ListPool&lt;Vector2&gt;.Add(uvs); } if (useUV2Coordinates) { hexMesh.SetUVs(1, uv2s); ListPool&lt;Vector2&gt;.Add(uv2s); } // if (useTerrainTypes) { // hexMesh.SetUVs(2, terrainTypes); // ListPool&lt;Vector3&gt;.Add(terrainTypes); // } hexMesh.SetTriangles(triangles, 0); ListPool&lt;int&gt;.Add(triangles); hexMesh.RecalculateNormals(); if (useCollider) { meshCollider.sharedMesh = hexMesh; } }</span></span></code> </pre> <br>  <code>AddTriangleColor</code> toutes les <code>AddTriangleTerrainTypes</code> <code>AddTriangleColor</code> et <code>AddTriangleTerrainTypes</code> .  Remplacez-les par les méthodes <code>AddTriangleCellData</code> appropriées, qui ajoutent des index et des pondérations à la fois. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 indices, Color weights1, Color weights2, Color weights3 </span></span></span><span class="hljs-function">)</span></span> { cellIndices.Add(indices); cellIndices.Add(indices); cellIndices.Add(indices); cellWeights.Add(weights1); cellWeights.Add(weights2); cellWeights.Add(weights3); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 indices, Color weights</span></span></span><span class="hljs-function">)</span></span> { AddTriangleCellData(indices, weights, weights, weights); }</code> </pre> <br>  Faites de même dans la méthode <code>AddQuad</code> appropriée. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 indices, Color weights1, Color weights2, Color weights3, Color weights4 </span></span></span><span class="hljs-function">)</span></span> { cellIndices.Add(indices); cellIndices.Add(indices); cellIndices.Add(indices); cellIndices.Add(indices); cellWeights.Add(weights1); cellWeights.Add(weights2); cellWeights.Add(weights3); cellWeights.Add(weights4); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 indices, Color weights1, Color weights2 </span></span></span><span class="hljs-function">)</span></span> { AddQuadCellData(indices, weights1, weights1, weights2, weights2); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 indices, Color weights</span></span></span><span class="hljs-function">)</span></span> { AddQuadCellData(indices, weights, weights, weights, weights); }</code> </pre> <br><h3>  Refactorisation HexGridChunk </h3><br>  À ce stade, nous obtenons de nombreuses erreurs de compilation dans <code>HexGridChunk</code> qui doivent être <code>HexGridChunk</code> .  Mais d'abord, par souci de cohérence, nous refactorisons-renommons les couleurs statiques en poids. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color weights1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color weights2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color weights3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br>  Commençons par fixer <code>TriangulateEdgeFan</code> .  Il avait besoin d'un type, mais maintenant il a besoin d'un index de cellule.  <code>AddTriangleColor</code> code <code>AddTriangleColor</code> et <code>AddTriangleTerrainTypes</code> par le code <code>AddTriangleCellData</code> correspondant. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { terrain.AddTriangle(center, edge.v1, edge.v2); terrain.AddTriangle(center, edge.v2, edge.v3); terrain.AddTriangle(center, edge.v3, edge.v4); terrain.AddTriangle(center, edge.v4, edge.v5); Vector3 indices; indices.x = indices.y = indices.z = index; terrain.AddTriangleCellData(indices, weights1); terrain.AddTriangleCellData(indices, weights1); terrain.AddTriangleCellData(indices, weights1); terrain.AddTriangleCellData(indices, weights1); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights1); // terrain.AddTriangleColor(weights1); // terrain.AddTriangleColor(weights1); // terrain.AddTriangleColor(weights1); // Vector3 types; // types.x = types.y = types.z = type; // terrain.AddTriangleTerrainTypes(types); // terrain.AddTriangleTerrainTypes(types); // terrain.AddTriangleTerrainTypes(types); // terrain.AddTriangleTerrainTypes(types); }</span></span></code> </pre> <br>  Cette méthode est appelée à plusieurs endroits.  Examinons-les et assurons-nous que l'index de la cellule y est transféré, et non le type de terrain. <br><br><pre> <code class="cs hljs"> TriangulateEdgeFan(center, e, cell.Index);</code> </pre> <br>  Vient ensuite <code>TriangulateEdgeStrip</code> .  Tout est un peu plus compliqué ici, mais nous utilisons la même approche.  Renommez également les noms des paramètres <code>c1</code> et <code>c2</code> en <code>w1</code> et <code>w2</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color w1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index1, EdgeVertices e2, Color w2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { terrain.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); terrain.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); terrain.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); terrain.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); Vector3 indices; indices.x = indices.z = index1; indices.y = index2; terrain.AddQuadCellData(indices, w1, w2); terrain.AddQuadCellData(indices, w1, w2); terrain.AddQuadCellData(indices, w1, w2); terrain.AddQuadCellData(indices, w1, w2); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddQuadColor(c1, c2); // terrain.AddQuadColor(c1, c2); // terrain.AddQuadColor(c1, c2); // terrain.AddQuadColor(c1, c2); // Vector3 types; // types.x = types.z = type1; // types.y = type2; // terrain.AddQuadTerrainTypes(types); // terrain.AddQuadTerrainTypes(types); // terrain.AddQuadTerrainTypes(types); // terrain.AddQuadTerrainTypes(types); if (hasRoad) { TriangulateRoadSegment(e1.v2, e1.v3, e1.v4, e2.v2, e2.v3, e2.v4); } }</span></span></code> </pre> <br>  Modifiez les appels à cette méthode afin que l'index de cellule leur soit transmis.  Nous gardons également les noms de variables cohérents. <br><br><pre> <code class="cs hljs"> TriangulateEdgeStrip( m, weights1, cell.Index, e, weights1, cell.Index ); … TriangulateEdgeStrip( e1, weights1, cell.Index, e2, weights2, neighbor.Index, hasRoad ); … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color w2 = HexMetrics.TerraceLerp(weights1, weights2, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> i1 = beginCell.Index; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> i2 = endCell.Index; TriangulateEdgeStrip(begin, weights1, i1, e2, w2, i2, hasRoad); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color w1 = w2; e2 = EdgeVertices.TerraceLerp(begin, end, i); w2 = HexMetrics.TerraceLerp(weights1, weights2, i); TriangulateEdgeStrip(e1, w1, i1, e2, w2, i2, hasRoad); } TriangulateEdgeStrip(e2, w2, i1, end, weights2, i2, hasRoad); }</code> </pre> <br>  Passons maintenant aux méthodes d'angle.  Ces modifications sont simples, mais elles doivent être effectuées dans une grande quantité de code.  Tout d'abord chez <code>TriangulateCorner</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangle(bottom, left, right); Vector3 indices; indices.x = bottomCell.Index; indices.y = leftCell.Index; indices.z = rightCell.Index; terrain.AddTriangleCellData(indices, weights1, weights2, weights3); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights1, weights2, weights3); // Vector3 types; // types.x = bottomCell.TerrainTypeIndex; // types.y = leftCell.TerrainTypeIndex; // types.z = rightCell.TerrainTypeIndex; // terrain.AddTriangleTerrainTypes(types); } features.AddWall(bottom, bottomCell, left, leftCell, right, rightCell); }</span></span></code> </pre> <br>  Venir à <code>TriangulateCornerTerraces</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { Vector3 v3 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 v4 = HexMetrics.TerraceLerp(begin, right, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color w3 = HexMetrics.TerraceLerp(weights1, weights2, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color w4 = HexMetrics.TerraceLerp(weights1, weights3, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 indices; indices.x = beginCell.Index; indices.y = leftCell.Index; indices.z = rightCell.Index; terrain.AddTriangle(begin, v3, v4); terrain.AddTriangleCellData(indices, weights1, w3, w4); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights1, w3, w4); // terrain.AddTriangleTerrainTypes(indices); for (int i = 2; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v3; Vector3 v2 = v4; Color w1 = w3; Color w2 = w4; v3 = HexMetrics.TerraceLerp(begin, left, i); v4 = HexMetrics.TerraceLerp(begin, right, i); w3 = HexMetrics.TerraceLerp(weights1, weights2, i); w4 = HexMetrics.TerraceLerp(weights1, weights3, i); terrain.AddQuad(v1, v2, v3, v4); terrain.AddQuadCellData(indices, w1, w2, w3, w4); // terrain.AddQuadColor(w1, w2, w3, w4); // terrain.AddQuadTerrainTypes(indices); } terrain.AddQuad(v3, v4, left, right); terrain.AddQuadCellData(indices, w3, w4, weights2, weights3); // terrain.AddQuadColor(w3, w4, weights2, weights3); // terrain.AddQuadTerrainTypes(indices); }</span></span></code> </pre> <br>  Puis dans <code>TriangulateCornerTerracesCliff</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } Vector3 boundary = Vector3.Lerp( HexMetrics.Perturb(begin), HexMetrics.Perturb(right), b ); Color boundaryWeights = Color.Lerp(weights1, weights3, b); Vector3 indices; indices.x = beginCell.Index; indices.y = leftCell.Index; indices.z = rightCell.Index; TriangulateBoundaryTriangle( begin, weights1, left, weights2, boundary, boundaryWeights, indices ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, weights2, right, weights3, boundary, boundaryWeights, indices ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleCellData( indices, weights2, weights3, boundaryWeights ); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights2, weights3, boundaryColor); // terrain.AddTriangleTerrainTypes(indices); } }</span></span></code> </pre> <br>  Et un peu différemment dans <code>TriangulateCornerCliffTerraces</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerCliffTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (leftCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } Vector3 boundary = Vector3.Lerp( HexMetrics.Perturb(begin), HexMetrics.Perturb(left), b ); Color boundaryWeights = Color.Lerp(weights1, weights2, b); Vector3 indices; indices.x = beginCell.Index; indices.y = leftCell.Index; indices.z = rightCell.Index; TriangulateBoundaryTriangle( right, weights3, begin, weights1, boundary, boundaryWeights, indices ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, weights2, right, weights3, boundary, boundaryWeights, indices ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleCellData( indices, weights2, weights3, boundaryWeights ); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights2, weights3, boundaryWeights); // terrain.AddTriangleTerrainTypes(indices); } }</span></span></code> </pre> <br>  Les deux méthodes précédentes utilisent le <code>TriangulateBoundaryTriangle</code> , qui nécessite également une mise à jour. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, Color beginWeights, Vector3 left, Color leftWeights, Vector3 boundary, Color boundaryWeights, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>)); Color w2 = HexMetrics.TerraceLerp(beginWeights, leftWeights, <span class="hljs-number"><span class="hljs-number">1</span></span>); terrain.AddTriangleUnperturbed(HexMetrics.Perturb(begin), v2, boundary); terrain.AddTriangleCellData(indices, beginWeights, w2, boundaryWeights); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(beginColor, c2, boundaryColor); // terrain.AddTriangleTerrainTypes(types); for (int i = 2; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color w1 = w2; v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, i)); w2 = HexMetrics.TerraceLerp(beginWeights, leftWeights, i); terrain.AddTriangleUnperturbed(v1, v2, boundary); terrain.AddTriangleCellData(indices, w1, w2, boundaryWeights); // terrain.AddTriangleColor(c1, c2, boundaryColor); // terrain.AddTriangleTerrainTypes(types); } terrain.AddTriangleUnperturbed(v2, HexMetrics.Perturb(left), boundary); terrain.AddTriangleCellData(indices, w2, leftWeights, boundaryWeights); // terrain.AddTriangleColor(c2, leftColor, boundaryColor); // terrain.AddTriangleTerrainTypes(types); }</span></span></code> </pre> <br>  La dernière méthode qui doit être modifiée est <code>TriangulateWithRiver</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … terrain.AddTriangle(centerL, m.v1, m.v2); terrain.AddQuad(centerL, center, m.v2, m.v3); terrain.AddQuad(center, centerR, m.v3, m.v4); terrain.AddTriangle(centerR, m.v4, m.v5); Vector3 indices; indices.x = indices.y = indices.z = cell.Index; terrain.AddTriangleCellData(indices, weights1); terrain.AddQuadCellData(indices, weights1); terrain.AddQuadCellData(indices, weights1); terrain.AddTriangleCellData(indices, weights1); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights1); // terrain.AddQuadColor(weights1); // terrain.AddQuadColor(weights1); // terrain.AddTriangleColor(weights1); // Vector3 types; // types.x = types.y = types.z = cell.TerrainTypeIndex; // terrain.AddTriangleTerrainTypes(types); // terrain.AddQuadTerrainTypes(types); // terrain.AddQuadTerrainTypes(types); // terrain.AddTriangleTerrainTypes(types); … }</span></span></code> </pre> <br>  Pour que tout fonctionne, nous devons indiquer que nous utiliserons les données de cellule pour l'élément enfant du relief du fragment préfabriqué. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/919/b8c/731/919b8c7317b2aa3c06f1077eef27fe96.png"></div><br>  <i>Le relief utilise des données cellulaires.</i> <br><br>  À ce stade, le maillage contient des index de cellules au lieu d'indices de type d'élévation.  Comme le shader d'élévation les interprète toujours comme des indices d'élévation, nous verrons que la première cellule est rendue avec la première texture et ainsi de suite jusqu'à ce que la dernière texture en relief soit atteinte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a5/a23/ce8/8a5a23ce850af789e759dde6879f93eb.png"></div><br>  <i>Utilisation d'indices de cellule comme indices de texture d'élévation.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Je ne peux pas faire fonctionner le code refactorisé.</b>  <b class="spoiler_title">Qu'est-ce que je fais mal?</b> <div class="spoiler_text">  À un moment donné, nous avons modifié une grande quantité de code de triangulation, il y a donc une forte probabilité d'erreurs ou d'oubli.  Si vous ne trouvez pas l'erreur, essayez de télécharger le package à partir de cette section et extrayez les fichiers appropriés.  Vous pouvez les importer dans un projet distinct et les comparer avec votre propre code. </div></div><br><h3>  Transférer des données de cellule vers un shader </h3><br>  Pour utiliser ces cellules, le shader de terrain doit y avoir accès.  Cela peut être implémenté via la propriété shader.  Cela nécessitera <code>HexCellShaderData</code> définir la propriété matérielle du relief.  Ou nous pouvons rendre la texture de ces cellules globalement visible à tous les shaders.  C'est pratique car nous en avons besoin dans plusieurs shaders, nous allons donc utiliser cette approche. <br><br>  Après avoir créé la texture de cellule, appelez la méthode statique <code>Shader.SetGlobalTexture</code> pour la rendre globalement visible en tant que <em>_HexCellData</em> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cellTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D( x, z, TextureFormat.RGBA32, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); cellTexture.filterMode = FilterMode.Point; cellTexture.wrapMode = TextureWrapMode.Clamp; Shader.SetGlobalTexture(<span class="hljs-string"><span class="hljs-string">"_HexCellData"</span></span>, cellTexture); } … }</code> </pre> <br>  Lorsque vous utilisez la propriété shader, Unity met la taille de texture à la disposition du shader via la variable <em>textureName_TexelSize</em> .  Il s'agit d'un vectoriseur à quatre composants contenant des valeurs qui sont inverses à la largeur et à la hauteur, ainsi qu'à la largeur et à la hauteur elles-mêmes.  Mais lors de la définition de la texture globale, cela n'est pas effectué.  Par conséquent, nous le ferons nous-mêmes en utilisant le <code>Shader.SetGlobalVector</code> après avoir créé ou redimensionné la texture. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cellTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D( x, z, TextureFormat.RGBA32, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); cellTexture.filterMode = FilterMode.Point; cellTexture.wrapMode = TextureWrapMode.Clamp; Shader.SetGlobalTexture(<span class="hljs-string"><span class="hljs-string">"_HexCellData"</span></span>, cellTexture); } Shader.SetGlobalVector( <span class="hljs-string"><span class="hljs-string">"_HexCellData_TexelSize"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector4(<span class="hljs-number"><span class="hljs-number">1f</span></span> / x, <span class="hljs-number"><span class="hljs-number">1f</span></span> / z, x, z) );</code> </pre> <br><h3>  Accès aux données du shader </h3><br>  Créez un nouveau fichier d'inclusion de shader dans le dossier des matériaux appelé <em>HexCellData</em> .  À l'intérieur, nous définissons des variables pour obtenir des informations sur la texture et la taille de ces cellules.  Nous créons également une fonction pour obtenir les données de cellule pour les données de maillage de sommet données. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">sampler2D</span></span> _HexCellData; <span class="hljs-attribute"><span class="hljs-attribute">float4</span></span> _HexCellData_TexelSize; <span class="hljs-attribute"><span class="hljs-attribute">float4</span></span> GetCellData (appdata_full v) { }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a64/604/dbc/a64604dbc7d3ad5ff1e1578bd0c84eec.png"></div><br>  <i>Nouveau fichier d'inclusion.</i> <br><br>  Les indices de cellule sont stockés dans <code>v.texcoord2</code> , comme c'était le cas avec les types de terrain.  Commençons par le premier index - <code>v.texcoord2.x</code> .  Malheureusement, nous ne pouvons pas utiliser directement l'index pour échantillonner la texture de ces cellules.  Nous devrons le convertir en coordonnées UV. <br><br>  La première étape de la création de la coordonnée U consiste à diviser l'indice de cellule par la largeur de la texture.  Nous pouvons le faire en le multipliant par <code>_HexCellData_TexelSize.x</code> . <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">appdata_full v</span></span></span><span class="hljs-function">)</span></span> { float2 uv; uv.x = v.texcoord2.x * _HexCellData_TexelSize.x; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le résultat sera un nombre sous la forme ZU, où Z est l'index de ligne et U est la coordonnée de la cellule U. </font><font style="vertical-align: inherit;">Nous pouvons extraire la chaîne en arrondissant le nombre vers le bas puis en le soustrayant du nombre pour obtenir la coordonnée U.</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v) { float2 uv; uv.x = v.texcoord2.x * _HexCellData_TexelSize.x; <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> = floor(uv.x); uv.x -= <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La coordonnée V divise la ligne par la hauteur de la texture. </font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v) { float2 uv; uv.x = v.texcoord2.x * _HexCellData_TexelSize.x; <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> = floor(uv.x); uv.x -= <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>; uv.y = <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> * _HexCellData_TexelSize.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisque nous échantillonnons la texture, nous devons utiliser les coordonnées au centre des pixels, pas à leurs bords. </font><font style="vertical-align: inherit;">De cette façon, nous garantissons que les bons pixels sont échantillonnés. </font><font style="vertical-align: inherit;">Par conséquent, après avoir divisé par la taille de la texture, ajoutez ½.</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v) { float2 uv; uv.x = (v.texcoord2.x + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.x; <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> = floor(uv.x); uv.x -= <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>; uv.y = (<span class="hljs-keyword"><span class="hljs-keyword">row</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela nous donne les coordonnées UV correctes pour l'indice de la première cellule stockée dans les données de sommet. </font><font style="vertical-align: inherit;">Mais en plus, nous pouvons avoir jusqu'à trois indices différents. </font><font style="vertical-align: inherit;">Par conséquent, nous allons le faire </font></font><code>GetCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fonctionner pour n'importe quel index. </font><font style="vertical-align: inherit;">Ajoutez-y un paramètre entier </font></font><code>index</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que nous utiliserons pour accéder à la composante vectorielle avec l'index de cellule.</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float2 uv; uv.x = (v.texcoord2[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>] + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.x; <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> = floor(uv.x); uv.x -= <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>; uv.y = (<span class="hljs-keyword"><span class="hljs-keyword">row</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que nous avons toutes les coordonnées nécessaires pour ces cellules, nous pouvons échantillonner </font></font><code>_HexCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Puisque nous échantillonnons la texture dans le programme vertex, nous devons dire explicitement au shader quelle texture de mip utiliser. </font><font style="vertical-align: inherit;">Cela peut être fait en utilisant une fonction </font></font><code>tex2Dlod</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui nécessite les coordonnées de quatre textures. </font><font style="vertical-align: inherit;">Puisque ces cellules n'ont pas de textures mip, nous attribuons des valeurs nulles aux coordonnées supplémentaires.</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float2 uv; uv.x = (v.texcoord2[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>] + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.x; <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> = floor(uv.x); uv.x -= <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>; uv.y = (<span class="hljs-keyword"><span class="hljs-keyword">row</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> data = tex2Dlod(_HexCellData, <span class="hljs-type"><span class="hljs-type">float4</span></span>(uv, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le quatrième composant de données contient un index de type d'élévation, que nous stockons directement sous forme d'octets. </font><font style="vertical-align: inherit;">Cependant, le GPU l'a automatiquement converti en une valeur à virgule flottante comprise entre 0 et 1. </font><font style="vertical-align: inherit;">Pour le reconvertir à la valeur correcte, multipliez-le par 255. Après cela, vous pouvez renvoyer les données.</font></font><br><br><pre> <code class="hljs kotlin"> float4 <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = tex2Dlod(_HexCellData, float4(uv, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.w *= <span class="hljs-number"><span class="hljs-number">255</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour utiliser cette fonctionnalité, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">activez HexCellData</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans le shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Depuis que j'ai placé ce shader dans </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matériaux / Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , j'ai besoin d'utiliser le chemin relatif </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">../HexCellData.cginc</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs lisp"> #include <span class="hljs-string"><span class="hljs-string">"../HexCellData.cginc"</span></span> UNITY_DECLARE_TEX2DARRAY(<span class="hljs-name"><span class="hljs-name">_MainTex</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le programme vertex, nous obtenons des données de cellule pour les trois indices cellulaires stockés dans les données de vertex. </font><font style="vertical-align: inherit;">Attribuez ensuite </font></font><code>data.terrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">leurs indices d'élévation.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); // data.terrain = v.texcoord2.xyz; <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell2 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">2</span></span>); data.terrain.x = cell0.w; data.terrain.y = cell1.w; data.terrain.z = cell2.w; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À ce stade, la carte a de nouveau commencé à afficher le terrain correct. </font><font style="vertical-align: inherit;">La grande différence est que la modification des types de terrain ne conduit plus à de nouvelles triangulations. </font><font style="vertical-align: inherit;">Si, lors de la modification, toute autre donnée de cellule est modifiée, la triangulation sera effectuée comme d'habitude. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visibilité </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après avoir créé la base de ces cellules, nous pouvons continuer à soutenir la visibilité. </font><font style="vertical-align: inherit;">Pour ce faire, nous utilisons le shader, les cellules elles-mêmes et les objets qui déterminent la visibilité. </font><font style="vertical-align: inherit;">Notez que le processus de triangulation n'en sait absolument rien.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commençons par expliquer au shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain la</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> visibilité. </font><font style="vertical-align: inherit;">Il recevra les données de visibilité du programme vertex et les transmettra au programme de fragments à l'aide de la structure </font></font><code>Input</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Puisque nous passons trois indices d'élévation distincts, nous passerons également trois valeurs de visibilité.</font></font><br><br><pre> <code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span></span>{ float4 color : <span class="hljs-type"><span class="hljs-type">COLOR</span></span>; float3 worldPos; float3 terrain; float3 visibility; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour stocker la visibilité, nous utilisons le premier composant de ces cellules. </font></font><br><br><pre> <code class="hljs kotlin"> void vert (inout appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Input <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { UNITY_INITIALIZE_OUTPUT(Input, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); float4 cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); float4 cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); float4 cell2 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.terrain.x = cell0.w; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.terrain.y = cell1.w; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.terrain.z = cell2.w; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = cell0.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.y = cell1.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.z = cell2.x; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une visibilité de 0 signifie que la cellule est actuellement invisible. </font><font style="vertical-align: inherit;">S'il était visible, il aurait la valeur de visibilité 1. On peut donc assombrir le terrain en multipliant le résultat </font></font><code>GetTerrainColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par le vecteur de visibilité correspondant. </font><font style="vertical-align: inherit;">Ainsi, nous modulons individuellement la couleur du relief de chaque cellule mixte.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float4</span></span> GetTerrainColor (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float3 uvw = float3(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.terrain[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]); <span class="hljs-type"><span class="hljs-type">float4</span></span> c = UNITY_SAMPLE_TEX2DARRAY(_MainTex, uvw); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c * (<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.color[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>] * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bf/183/e69/1bf183e695a42f4691f63cec72255993.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les cellules sont devenues noires.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ne pouvons-nous pas plutôt combiner la visibilité dans un programme de vertex?</font></font></b> <div class="spoiler_text">   ,           .              .           .        ,      .   ,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'obscurité totale est un buste pour les cellules temporairement invisibles. </font><font style="vertical-align: inherit;">Pour que nous puissions toujours voir le relief, nous devons augmenter l'indicateur utilisé pour les cellules cachées. </font><font style="vertical-align: inherit;">Passons de 0–1 à ¼ - 1, ce qui peut être fait en utilisant la fonction </font></font><code>lerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à la fin du programme vertex.</font></font><br><br><pre> <code class="hljs kotlin"> void vert (inout appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Input <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { … <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = cell0.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.y = cell1.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.z = cell2.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a20/090/3e2/a200903e2f31f3bdcd0c996d42f91a02.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cellules ombrées.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suivi de la visibilité des cellules </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour que la visibilité fonctionne, les cellules doivent suivre leur visibilité. Mais comment une cellule détermine-t-elle si elle est visible? Nous pouvons le faire en suivant le nombre d'entités qui le voient. Lorsque quelqu'un commence à voir une cellule, il doit signaler cette cellule. Et lorsque quelqu'un arrête de voir la cellule, il doit également l'en informer. La cellule garde simplement une trace du nombre d'observateurs, quelles que soient ces entités. Si une cellule a une valeur de visibilité d'au moins 1, elle est visible, sinon elle est invisible. Pour implémenter ce comportement, nous ajoutons </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deux méthodes et une propriété </font><font style="vertical-align: inherit;">à la </font><font style="vertical-align: inherit;">variable.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsVisible { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> visibility &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } } … <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> visibility; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { visibility += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { visibility -= <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, ajoutez à la </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">méthode </font></font><code>RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui fait la même chose que </font></font><code>RefreshTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, juste pour des raisons de visibilité. </font><font style="vertical-align: inherit;">Enregistrez les données dans le composant R des cellules de données. </font><font style="vertical-align: inherit;">Comme nous travaillons avec des octets convertis en valeurs 0–1, nous utilisons pour indiquer la visibilité </font></font><code>(byte)255</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cellTextureData[cell.Index].r = cell.IsVisible ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous appellerons cette méthode avec une visibilité croissante et décroissante, en changeant la valeur entre 0 et 1. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { visibility += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (visibility == <span class="hljs-number"><span class="hljs-number">1</span></span>) { ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { visibility -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (visibility == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Créer la visibilité de l'escouade </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faisons en sorte que les unités puissent voir la cellule qu'elles occupent. </font><font style="vertical-align: inherit;">Ceci est accompli en utilisant un appel </font></font><code>IncreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">au nouvel emplacement de l'unité pendant la tâche </font></font><code>HexUnit.Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous demandons également l'ancien emplacement (s'il existe) </font></font><code>DecreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> location; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { location.DecreaseVisibility(); location.Unit = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } location = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Unit = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.IncreaseVisibility(); transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Position; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bc/f95/a07/7bcf95a07fdf4c10ed1d53055dddf6a4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les unités peuvent voir où elles se trouvent. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin nous avons utilisé la visibilité! </font><font style="vertical-align: inherit;">Lorsqu'elles sont ajoutées à une carte, les unités rendent leur cellule visible. </font><font style="vertical-align: inherit;">De plus, leur portée est téléportée lors du déplacement vers leur nouvel emplacement. </font><font style="vertical-align: inherit;">Mais leur portée reste active lors de la suppression d'unités de la carte. </font><font style="vertical-align: inherit;">Pour résoudre ce problème, nous réduirons la visibilité de leur emplacement lors de la destruction d'unités.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Die</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { location.DecreaseVisibility(); } location.Unit = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; Destroy(gameObject); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plage de visibilité </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'à présent, nous ne voyons que la cellule dans laquelle se trouve le détachement, ce qui limite les possibilités. Au moins, nous devons voir les cellules voisines. Dans le cas général, les unités peuvent voir toutes les cellules à une certaine distance, qui dépend de l'unité. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutons à la </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">méthode pour trouver toutes les cellules visibles d'une cellule en tenant compte de la plage. Nous pouvons créer cette méthode en dupliquant et en changeant </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Modifiez ses paramètres et faites-lui retourner une liste de cellules pour lesquelles vous pouvez utiliser le pool de listes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À chaque itération, la cellule actuelle est ajoutée à la liste. Il n'y a plus de cellule finale, la recherche ne se terminera donc jamais lorsqu'elle atteindra ce point. Nous nous débarrassons également de la logique des déplacements et du coût du déplacement. Faire les propriétés</font></font><code>PathFrom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on ne les a plus posées car nous n'en avons pas besoin et nous ne voulons pas interférer avec le chemin le long de la grille. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À chaque étape, la distance augmente simplement de 1. Si elle dépasse la plage, cette cellule est ignorée. </font><font style="vertical-align: inherit;">Et nous n'avons pas besoin d'une heuristique de recherche, nous l'initialisons donc avec une valeur de 0. Autrement dit, nous sommes revenus à l'algorithme de Dijkstra.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">List&lt;HexCell&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetVisibleCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> range</span></span></span><span class="hljs-function">)</span></span> { List&lt;HexCell&gt; visibleCells = ListPool&lt;HexCell&gt;.Get(); searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchFrontier.Clear(); } fromCell.SearchPhase = searchFrontierPhase; fromCell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(fromCell); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); current.SearchPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; visibleCells.Add(current); <span class="hljs-comment"><span class="hljs-comment">// if (current == toCell) { // return true; // } // int currentTurn = (current.Distance - 1) / speed; for (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); if ( neighbor == null || neighbor.SearchPhase &gt; searchFrontierPhase ) { continue; } // … // int moveCost; // … int distance = current.Distance + 1; if (distance &gt; range) { continue; } // int turn = (distance - 1) / speed; // if (turn &gt; currentTurn) { // distance = turn * speed + moveCost; // } if (neighbor.SearchPhase &lt; searchFrontierPhase) { neighbor.SearchPhase = searchFrontierPhase; neighbor.Distance = distance; // neighbor.PathFrom = current; neighbor.SearchHeuristic = 0; searchFrontier.Enqueue(neighbor); } else if (distance &lt; neighbor.Distance) { int oldPriority = neighbor.SearchPriority; neighbor.Distance = distance; // neighbor.PathFrom = current; searchFrontier.Change(neighbor, oldPriority); } } } return visibleCells; }</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ne pouvons-nous pas utiliser un algorithme plus simple pour trouver toutes les cellules à portée?</font></font></b> <div class="spoiler_text"> ,          ,      . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez également des </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">méthodes </font></font><code>IncreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>DecreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ils obtiennent la cellule et la plage, prennent une liste des cellules correspondantes et augmentent / diminuent leur visibilité. </font><font style="vertical-align: inherit;">Une fois terminé, ils devraient retourner la liste dans son pool.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> range</span></span></span><span class="hljs-function">)</span></span> { List&lt;HexCell&gt; cells = GetVisibleCells(fromCell, range); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Count; i++) { cells[i].IncreaseVisibility(); } ListPool&lt;HexCell&gt;.Add(cells); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> range</span></span></span><span class="hljs-function">)</span></span> { List&lt;HexCell&gt; cells = GetVisibleCells(fromCell, range); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Count; i++) { cells[i].DecreaseVisibility(); } ListPool&lt;HexCell&gt;.Add(cells); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour utiliser ces méthodes </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nécessite un accès à la grille, ajoutez-y donc une propriété </font></font><code>Grid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid Grid { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque vous ajoutez une escouade à une grille, elle attribue une grille à cette propriété </font></font><code>HexGrid.AddUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexUnit unit, HexCell location, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> orientation</span></span></span><span class="hljs-function">)</span></span> { units.Add(unit); unit.Grid = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; unit.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); unit.Location = location; unit.Orientation = orientation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour commencer, une plage de visibilité de trois cellules sera suffisante. </font><font style="vertical-align: inherit;">Pour ce faire, nous ajoutons à la </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constante, qui à l'avenir peut toujours se transformer en variable. </font><font style="vertical-align: inherit;">Ensuite, nous ferons en sorte que l'équipe invoque des méthodes pour la grille </font></font><code>IncreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>DecreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en transmettant également sa plage de visibilité, et non pas simplement aller à cet endroit.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> visionRange = <span class="hljs-number"><span class="hljs-number">3</span></span>; … <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> location; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { <span class="hljs-comment"><span class="hljs-comment">// location.DecreaseVisibility(); Grid.DecreaseVisibility(location, visionRange); location.Unit = null; } location = value; value.Unit = this; // value.IncreaseVisibility(); Grid.IncreaseVisibility(value, visionRange); transform.localPosition = value.Position; } } … public void Die () { if (location) { // location.DecreaseVisibility(); Grid.DecreaseVisibility(location, visionRange); } location.Unit = null; Destroy(gameObject); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cd/c45/ccb/8cdc45ccb01449b3c7d50a7bef9b249c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unités avec une plage de visibilité pouvant se chevaucher.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visibilité lors du déplacement </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À l'heure actuelle, la zone de visibilité de l'escouade après la commande de déplacement est immédiatement téléportée au point final. </font><font style="vertical-align: inherit;">Il aurait été préférable que l'unité et son champ de visibilité se rapprochent. </font><font style="vertical-align: inherit;">La première étape consiste à ne plus définir la propriété </font></font><code>Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c </font></font><code>HexUnit.Travel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Au lieu de cela, nous changerons directement le champ </font></font><code>location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en évitant le code de propriété. </font><font style="vertical-align: inherit;">Par conséquent, nous effacerons manuellement l'ancien emplacement et configurerons un nouvel emplacement. </font><font style="vertical-align: inherit;">La visibilité restera inchangée.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Travel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;HexCell&gt; path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Location = path[path.Count - 1]; location.Unit = null; location = path[path.Count - 1]; location.Unit = this; pathToTravel = path; StopAllCoroutines(); StartCoroutine(TravelPath()); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À l'intérieur des coroutines, </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous ne réduirons la visibilité de la première cellule qu'après l'achèvement </font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Après cela, avant de passer à une nouvelle cellule, nous augmenterons la visibilité de cette cellule. </font><font style="vertical-align: inherit;">Cela fait, nous en réduisons encore la visibilité. </font><font style="vertical-align: inherit;">Enfin, augmentez la visibilité depuis la dernière cellule.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-comment"><span class="hljs-comment">// transform.localPosition = c; yield return LookAt(pathToTravel[1].Position); Grid.DecreaseVisibility(pathToTravel[0], visionRange); float t = Time.deltaTime * travelSpeed; for (int i = 1; i &lt; pathToTravel.Count; i++) { a = c; b = pathToTravel[i - 1].Position; c = (b + pathToTravel[i].Position) * 0.5f; Grid.IncreaseVisibility(pathToTravel[i], visionRange); for (; t &lt; 1f; t += Time.deltaTime * travelSpeed) { … } Grid.DecreaseVisibility(pathToTravel[i], visionRange); t -= 1f; } a = c; b = location.Position; // We can simply use the destination here. c = b; Grid.IncreaseVisibility(location, visionRange); for (; t &lt; 1f; t += Time.deltaTime * travelSpeed) { … } … }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visibilité en mouvement. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout cela fonctionne, sauf lorsqu'un nouvel ordre est émis au moment du déplacement du détachement. </font><font style="vertical-align: inherit;">Cela conduit à la téléportation, qui devrait également s'appliquer à la visibilité. </font><font style="vertical-align: inherit;">Pour réaliser cela, nous devons suivre l'emplacement actuel de l'équipe pendant le déplacement.</font></font><br><br><pre> <code class="cs hljs"> HexCell location, currentTravelLocation;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous mettrons à jour cet emplacement chaque fois que nous touchons une nouvelle cellule pendant le déplacement, jusqu'à ce que l'équipe atteigne la cellule finale. </font><font style="vertical-align: inherit;">Ensuite, il doit être réinitialisé.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { currentTravelLocation = pathToTravel[i]; a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = (b + currentTravelLocation.Position) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; Grid.IncreaseVisibility(pathToTravel[i], visionRange); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { transform.localPosition = Bezier.GetPoint(a, b, c, t); Vector3 d = Bezier.GetDerivative(a, b, c, t); dy = <span class="hljs-number"><span class="hljs-number">0f</span></span>; transform.localRotation = Quaternion.LookRotation(d); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } Grid.DecreaseVisibility(pathToTravel[i], visionRange); t -= <span class="hljs-number"><span class="hljs-number">1f</span></span>; } currentTravelLocation = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, après avoir terminé le virage, </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous pouvons vérifier si l'ancien emplacement intermédiaire du chemin est connu. </font><font style="vertical-align: inherit;">Si oui, vous devez réduire la visibilité dans cette cellule, et non au début du chemin.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pathToTravel[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">].Position</span></span></span><span class="hljs-function">)</span></span>; Grid.DecreaseVisibility( currentTravelLocation ? currentTravelLocation : pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>], visionRange ); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons également corriger la visibilité après recompilation qui s'est produite lors du mouvement de l'équipe. </font><font style="vertical-align: inherit;">Si l'emplacement intermédiaire est toujours connu, réduisez la visibilité et augmentez la visibilité au point final, puis réinitialisez l'emplacement intermédiaire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { transform.localPosition = location.Position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentTravelLocation) { Grid.IncreaseVisibility(location, visionRange); Grid.DecreaseVisibility(currentTravelLocation, visionRange); currentTravelLocation = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visibilité des routes et de l'eau </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que les changements de couleur du relief soient basés sur la visibilité, cela n'affecte pas les routes et l'eau. </font><font style="vertical-align: inherit;">Ils ont l'air trop lumineux pour les cellules invisibles. </font><font style="vertical-align: inherit;">Pour appliquer la visibilité aux routes et à l'eau, nous devons ajouter des indices de cellules et mélanger les poids à leurs données de maillage. </font><font style="vertical-align: inherit;">Par conséquent, nous vérifierons les enfants des </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">données</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d' </font><em><font style="vertical-align: inherit;">utilisation des cellules</font></em><font style="vertical-align: inherit;"> pour les </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rivières</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , les </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">routes</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , l' </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eau</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la rive de l'eau</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et les </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estuaires du</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fragment préfabriqué.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les routes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous partirons des routes. </font><font style="vertical-align: inherit;">La méthode est </font></font><code>HexGridChunk.TriangulateRoadEdge</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilisée pour créer une petite partie de la route au centre de la cellule, elle a donc besoin d'un index de cellule. </font><font style="vertical-align: inherit;">Ajoutez-y un paramètre et générez des données de cellule pour le triangle.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadEdge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 center, Vector3 mL, Vector3 mR, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index </span></span></span><span class="hljs-function">)</span></span> { roads.AddTriangle(center, mL, mR); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); Vector3 indices; indices.x = indices.y = indices.z = index; roads.AddTriangleCellData(indices, weights1); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un autre moyen simple de créer des routes est </font></font><code>TriangulateRoadSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il est utilisé à l'intérieur et entre les cellules, il devrait donc fonctionner avec deux index différents. </font><font style="vertical-align: inherit;">Pour cela, il est pratique d'utiliser le paramètre vecteur d'index. </font><font style="vertical-align: inherit;">Étant donné que les segments de route peuvent faire partie de rebords, les poids doivent également passer par des paramètres.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, Vector3 v5, Vector3 v6, Color w1, Color w2, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { roads.AddQuad(v1, v2, v4, v5); roads.AddQuad(v2, v3, v5, v6); roads.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); roads.AddQuadUV(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); roads.AddQuadCellData(indices, w1, w2); roads.AddQuadCellData(indices, w1, w2); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Passons maintenant à </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ce qui crée des routes à l'intérieur des cellules. </font><font style="vertical-align: inherit;">Il a également besoin d'un paramètre d'index. </font><font style="vertical-align: inherit;">Il transmet ces données aux méthodes routières qu'il appelle et les ajoute aux triangles qu'il crée.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 center, Vector3 mL, Vector3 mR, EdgeVertices e, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoadThroughCellEdge, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRoadThroughCellEdge) { Vector3 indices; indices.x = indices.y = indices.z = index; Vector3 mC = Vector3.Lerp(mL, mR, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); TriangulateRoadSegment( mL, mC, mR, e.v2, e.v3, e.v4, weights1, weights1, indices ); roads.AddTriangle(center, mL, mC); roads.AddTriangle(center, mC, mR); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); roads.AddTriangleCellData(indices, weights1); roads.AddTriangleCellData(indices, weights1); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateRoadEdge(center, mL, mR, index); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il reste à ajouter les arguments de méthode nécessaires </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>TriangulateRoadEdge</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>TriangulateRoadSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">corriger toutes les erreurs du compilateur.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithoutRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { TriangulateEdgeFan(center, e, cell.Index); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoads) { Vector2 interpolators = GetRoadInterpolators(direction, cell); TriangulateRoad( center, Vector3.Lerp(center, e.v1, interpolators.x), Vector3.Lerp(center, e.v5, interpolators.y), e, cell.HasRoadThroughEdge(direction), cell.Index ); } } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … TriangulateRoad(roadCenter, mL, mR, e, hasRoadThroughEdge, cell.Index); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { TriangulateRoadEdge(roadCenter, center, mL, cell.Index); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextHasRiver) { TriangulateRoadEdge(roadCenter, mR, center, cell.Index); } } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> … </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRoad) { TriangulateRoadSegment( e1.v2, e1.v3, e1.v4, e2.v2, e2.v3, e2.v4, w1, w2, indices ); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, les données de maillage sont correctes et nous allons passer au shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Road</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Il a besoin d'un programme vertex et il doit contenir </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HexCellData</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs css"> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">surface</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">surf</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Standard</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">fullforwardshadows</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">decal</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:blend</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vertex</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:vert</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">target</span></span> 3<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#include</span></span> "<span class="hljs-selector-tag"><span class="hljs-selector-tag">HexCellData</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.cginc</span></span>"</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comme nous ne mélangeons pas plusieurs matériaux, il nous suffira de passer un indicateur de visibilité dans le programme des fragments. </font></font><br><br><pre> <code class="hljs cpp"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> {</span></span> float2 uv_MainTex; float3 worldPos; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> visibility; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il suffit qu'un nouveau programme vertex reçoive des données de deux cellules. </font><font style="vertical-align: inherit;">Nous mélangeons immédiatement leur visibilité, l'ajustons et ajoutons à la sortie.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); data.visibility = cell0.x * v.color.x + cell1.x * v.color.y; data.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dans le programme de fragments, nous avons juste besoin d'ajouter de la visibilité à la couleur. </font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); fixed4 c = _Color * ((noise.y * <span class="hljs-number"><span class="hljs-number">0.75</span></span> + <span class="hljs-number"><span class="hljs-number">0.25</span></span>) * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af8/92f/46e/af892f46e364906cc547aaecb4e50e3a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Routes avec visibilité.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eau libre </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il peut sembler que la visibilité a déjà affecté l'eau, mais ce n'est que la surface d'un terrain immergé dans l'eau. </font><font style="vertical-align: inherit;">Commençons par appliquer la visibilité en eau libre. </font><font style="vertical-align: inherit;">Pour cela, nous devons changer </font></font><code>HexGridChunk.TriangulateOpenWater</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateOpenWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { … water.AddTriangle(center, c1, c2); Vector3 indices; indices.x = indices.y = indices.z = cell.Index; water.AddTriangleCellData(indices, weights1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE &amp;&amp; neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { … water.AddQuad(c1, c2, e1, e2); indices.y = neighbor.Index; water.AddQuadCellData(indices, weights1, weights2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E) { … water.AddTriangle( c2, e2, c2 + HexMetrics.GetWaterBridge(direction.Next()) ); indices.z = nextNeighbor.Index; water.AddTriangleCellData( indices, weights1, weights2, weights3 ); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous devons également ajouter des données cellulaires aux fans des triangles près des côtes. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { … water.AddTriangle(center, e1.v1, e1.v2); water.AddTriangle(center, e1.v2, e1.v3); water.AddTriangle(center, e1.v3, e1.v4); water.AddTriangle(center, e1.v4, e1.v5); Vector3 indices; indices.x = indices.y = indices.z = cell.Index; water.AddTriangleCellData(indices, weights1); water.AddTriangleCellData(indices, weights1); water.AddTriangleCellData(indices, weights1); water.AddTriangleCellData(indices, weights1); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> doit être changé de la même manière que le shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Road</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais il doit combiner la visibilité non pas de deux, mais de trois cellules.</font></font><br><br><pre> <code class="hljs pgsql"> #pragma surface surf Standard alpha vertex:vert #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexCellData.cginc" sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float3 worldPos; <span class="hljs-type"><span class="hljs-type">float</span></span> visibility; }; … <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell2 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">2</span></span>); data.visibility = cell0.x * v.color.x + cell1.x * v.color.y + cell2.x * v.color.z; data.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility); } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> waves = Waves(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz, _MainTex); fixed4 c = saturate(_Color + waves); o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility; … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a4/c52/36c/6a4c5236c52eaae78cbde54fb2fdeeac.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eau libre avec visibilité.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Côte et estuaire </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour soutenir la côte, nous devons changer à nouveau </font></font><code>HexGridChunk.TriangulateWaterShore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous avons déjà créé un vecteur d'index, mais nous n'avons utilisé qu'un seul indice de cellule pour l'eau libre. </font><font style="vertical-align: inherit;">La côte a également besoin d'un index voisin, alors changez le code.</font></font><br><br><pre> <code class="cs hljs"> Vector3 indices; <span class="hljs-comment"><span class="hljs-comment">// indices.x = indices.y = indices.z = cell.Index; indices.x = indices.z = cell.Index; indices.y = neighbor.Index;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez les données des cellules aux quads et au triangle de la côte. </font><font style="vertical-align: inherit;">Nous transmettons également les index lors de l'appel </font></font><code>TriangulateEstuary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { TriangulateEstuary( e1, e2, cell.IncomingRiver == direction, indices ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { … waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadCellData(indices, weights1, weights2); waterShore.AddQuadCellData(indices, weights1, weights2); waterShore.AddQuadCellData(indices, weights1, weights2); waterShore.AddQuadCellData(indices, weights1, weights2); } HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { … waterShore.AddTriangleUV( … ); indices.z = nextNeighbor.Index; waterShore.AddTriangleCellData( indices, weights1, weights2, weights3 ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez le paramètre nécessaire </font></font><code>TriangulateEstuary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et prenez soin de ces cellules pour la côte et la bouche. </font><font style="vertical-align: inherit;">N'oubliez pas que la bouche est en trapèze avec deux triangles de la côte sur les côtés. </font><font style="vertical-align: inherit;">Nous nous assurons que les poids sont transférés dans le bon ordre.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEstuary</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, EdgeVertices e2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> incomingRiver, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { waterShore.AddTriangle(e2.v1, e1.v2, e1.v1); waterShore.AddTriangle(e2.v5, e1.v5, e1.v4); waterShore.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); waterShore.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); waterShore.AddTriangleCellData(indices, weights2, weights1, weights1); waterShore.AddTriangleCellData(indices, weights2, weights1, weights1); estuaries.AddQuad(e2.v1, e1.v2, e2.v2, e1.v3); estuaries.AddTriangle(e1.v3, e2.v2, e2.v4); estuaries.AddQuad(e1.v3, e1.v4, e2.v4, e2.v5); estuaries.AddQuadUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); estuaries.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); estuaries.AddQuadUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); estuaries.AddQuadCellData( indices, weights2, weights1, weights2, weights1 ); estuaries.AddTriangleCellData(indices, weights1, weights2, weights2); estuaries.AddQuadCellData(indices, weights1, weights2); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WaterShore</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><em><font style="vertical-align: inherit;">vous</font></em><font style="vertical-align: inherit;"> devez effectuer les mêmes modifications que dans le shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , en mélangeant la visibilité des trois cellules.</font></font><br><br><pre> <code class="hljs pgsql"> #pragma surface surf Standard alpha vertex:vert #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexCellData.cginc" sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float3 worldPos; <span class="hljs-type"><span class="hljs-type">float</span></span> visibility; }; … <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell2 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">2</span></span>); data.visibility = cell0.x * v.color.x + cell1.x * v.color.y + cell2.x * v.color.z; data.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility); } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { … fixed4 c = saturate(_Color + max(foam, waves)); o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le </font><font style="vertical-align: inherit;">shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estuary</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mélange la visibilité de deux cellules, tout comme le shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Road</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Il a déjà un programme de sommets, car nous avons besoin de lui pour transmettre les coordonnées UV des rivières.</font></font><br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexCellData.cginc" sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float2 riverUV; float3 worldPos; <span class="hljs-type"><span class="hljs-type">float</span></span> visibility; }; half _Glossiness; half _Metallic; fixed4 _Color; <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> o) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, o); o.riverUV = v.texcoord1.xy; <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); o.visibility = cell0.x * v.color.x + cell1.x * v.color.y; o.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, o.visibility); } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { … fixed4 c = saturate(_Color + water); o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility; … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/88f/829/254/88f829254235a293040ac755d8318bc3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Côte et estuaire avec visibilité.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rivières </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les dernières régions aquatiques avec lesquelles travailler sont les rivières. </font><font style="vertical-align: inherit;">Ajoutez un </font></font><code>HexGridChunk.TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vecteur d'index </font><font style="vertical-align: inherit;">au </font><font style="vertical-align: inherit;">paramètre et ajoutez-le au maillage afin qu'il puisse conserver la visibilité de deux cellules.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { TriangulateRiverQuad(v1, v2, v3, v4, y, y, v, reversed, indices); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { … rivers.AddQuadCellData(indices, weights1, weights2); }</code> </pre> <br> <code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">crée des points d'extrémité de rivière avec un quad et un triangle au centre de la cellule. </font><font style="vertical-align: inherit;">Ajoutez les données de cellule nécessaires pour cela.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiverBeginOrEnd</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reversed = cell.HasIncomingRiver; Vector3 indices; indices.x = indices.y = indices.z = cell.Index; TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>, reversed, indices ); center.y = m.v2.y = m.v4.y = cell.RiverSurfaceY; rivers.AddTriangle(center, m.v2, m.v4); … rivers.AddTriangleCellData(indices, weights1); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons déjà ces indices de cellule </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous les transmettons donc simplement à l'appel </font></font><code>TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reversed = cell.IncomingRiver == direction; TriangulateRiverQuad( centerL, centerR, m.v2, m.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>, reversed, indices ); TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>, reversed, indices ); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous ajoutons également un support d'index aux chutes d'eau qui se déversent en eau profonde. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterfallInWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> waterY, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { … rivers.AddQuadCellData(indices, weights1, weights2); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et enfin, changez-le </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour qu'il passe les index nécessaires aux méthodes des rivières et cascades.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRiver) { e2.v3.y = neighbor.StreamBedY; Vector3 indices; indices.x = indices.z = cell.Index; indices.y = neighbor.Index; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor.IsUnderwater) { TriangulateRiverQuad( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction, indices ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt; neighbor.WaterLevel) { TriangulateWaterfallInWater( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, neighbor.WaterSurfaceY, indices ); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !neighbor.IsUnderwater &amp;&amp; neighbor.Elevation &gt; cell.WaterLevel ) { TriangulateWaterfallInWater( e2.v4, e2.v2, e1.v4, e1.v2, neighbor.RiverSurfaceY, cell.RiverSurfaceY, cell.WaterSurfaceY, indices ); } } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">River</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> doit apporter les mêmes modifications que le shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Road</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs pgsql"> #pragma surface surf Standard alpha vertex:vert #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexCellData.cginc" sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; <span class="hljs-type"><span class="hljs-type">float</span></span> visibility; }; … <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); data.visibility = cell0.x * v.color.x + cell1.x * v.color.y; data.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility); } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> river = River(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex, _MainTex); fixed4 c = saturate(_Color + river); o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility; … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ef/db6/76a/1efdb676afe28b61b73f317d25158505.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivières avec visibilité. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objets et visibilité </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La visibilité fonctionne désormais pour l'ensemble du terrain généré par la procédure, mais jusqu'à présent, elle n'affecte pas les caractéristiques du terrain. Les bâtiments, les fermes et les arbres sont créés à partir de préfabriqués et non à partir de la géométrie procédurale, nous ne pouvons donc pas ajouter d'indices de cellules et mélanger les poids avec leurs sommets. Étant donné que chacun de ces objets appartient à une seule cellule, nous devons déterminer dans quelle cellule ils se trouvent. Si nous pouvons le faire, nous aurons alors accès aux données des cellules correspondantes et appliquerons la visibilité.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons déjà transformer les positions XZ du monde en indices cellulaires. Cette transformation a été utilisée pour modifier le terrain et gérer les escouades. Cependant, le code correspondant n'est pas trivial. Il utilise des opérations entières et nécessite une logique pour fonctionner avec les bords. Ceci n'est pas pratique pour un shader, nous pouvons donc cuire la majeure partie de la logique dans une texture et l'utiliser. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous utilisons déjà une texture avec un motif hexagonal pour projeter la grille sur la topographie. Cette texture définit une zone de cellule de 2 × 2. Par conséquent, nous pouvons facilement calculer dans quelle zone nous nous trouvons. Après cela, vous pouvez appliquer une texture contenant des décalages X et Z pour les cellules de cette zone et utiliser ces données pour calculer la cellule dans laquelle nous nous trouvons.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici une texture similaire. Le décalage X est stocké dans son canal rouge et le décalage Z est stocké dans le canal vert. Puisqu'il couvre la zone de 2 × 2 cellules, nous avons besoin de décalages de 0 et 2. Ces données ne peuvent pas être stockées dans le canal de couleur, donc les décalages sont réduits de moitié. Nous n'avons pas besoin de bords clairs des cellules, donc une petite texture suffit.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/795/63c/d3c/79563cd3c22e7aa2ca66e40b5ffe3f7e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La texture des coordonnées de la grille. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez de la texture au projet. </font><font style="vertical-align: inherit;">Réglez son </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mode</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d' </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habillage</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur </font><em><font style="vertical-align: inherit;">Répéter</font></em><font style="vertical-align: inherit;"> , tout comme les autres textures de maillage. </font><font style="vertical-align: inherit;">Nous n'avons pas besoin de mélange, donc pour le </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mode Blend,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous choisirons </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Point</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Désactivez également la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compression</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> afin que les données ne soient pas déformées. </font><font style="vertical-align: inherit;">Désactivez le mode </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sRGB</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour que lors du rendu en mode linéaire, aucune conversion d'espace colorimétrique ne soit effectuée. </font><font style="vertical-align: inherit;">Et enfin, nous n'avons pas besoin de textures mip.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/866/aa9/de3/866aa9de36f6953f54d4fb8197fb75ff.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Options d'importation de texture.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ombrage d'objets avec visibilité </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Créez un nouvel ombrage de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fonction</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour ajouter un support de visibilité aux objets. </font><font style="vertical-align: inherit;">Il s'agit d'un simple shader de surface avec un programme de vertex. </font><font style="vertical-align: inherit;">Ajoutez-y </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HexCellData</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et passez l'indicateur de visibilité au programme de fragment, et comme d'habitude, considérez-le en couleur. </font><font style="vertical-align: inherit;">La différence ici est que nous ne pouvons pas l'utiliser </font></font><code>GetCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">car les données de maillage requises n'existent pas. </font><font style="vertical-align: inherit;">Au lieu de cela, nous avons une position dans le monde. </font><font style="vertical-align: inherit;">Mais pour l'instant, laissez la visibilité égale à 1.</font></font><br><br><pre> <code class="hljs pgsql">Shader "Custom/Feature" { Properties { _Color ("Color", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex ("Albedo (RGB)", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Glossiness ("Smoothness", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.5</span></span> _Metallic ("Metallic", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.0</span></span> [NoTilingOffset] _GridCoordinates ("Grid Coordinates", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} } SubShader { Tags { "RenderType"="Opaque" } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> CGPROGRAM #pragma surface surf Standard fullforwardshadows vertex:vert #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "../HexCellData.cginc" sampler2D _MainTex, _GridCoordinates; half _Glossiness; half _Metallic; fixed4 _Color; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; <span class="hljs-type"><span class="hljs-type">float</span></span> visibility; }; <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); float3 pos = mul(unity_ObjectToWorld, v.vertex); data.visibility = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = tex2D (_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex) * _Color; o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; } ENDCG } FallBack "Diffuse" }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modifiez tous les matériaux des objets pour qu'ils utilisent le nouveau shader et affectez-leur la texture des coordonnées de la grille. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e35/fad/546/e35fad5469e6c9e5c6a31626ba182ec8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Urbain avec texture en maille.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Accéder aux données des cellules </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour échantillonner la texture des coordonnées de la grille dans le programme des sommets, nous avons à nouveau besoin d' </font></font><code>tex2Dlod</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un vecteur de coordonnées de texture à quatre composants. </font><font style="vertical-align: inherit;">Les deux premières coordonnées sont la position du monde XZ. </font><font style="vertical-align: inherit;">Les deux autres sont égaux à zéro comme précédemment.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); float3 pos = mul(unity_ObjectToWorld, v.vertex); <span class="hljs-type"><span class="hljs-type">float4</span></span> gridUV = <span class="hljs-type"><span class="hljs-type">float4</span></span>(pos.xz, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); data.visibility = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme dans le shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nous étirons les coordonnées UV afin que la texture ait le rapport d'aspect correct correspondant à la grille d'hexagones.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float4</span></span> gridUV = <span class="hljs-type"><span class="hljs-type">float4</span></span>(pos.xz, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); gridUV.x *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-number"><span class="hljs-number">8.66025404</span></span>); gridUV.y *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">15.0</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons découvrir dans quelle partie des cellules 2 × 2 nous nous trouvons en prenant la valeur des coordonnées UV arrondies vers le bas. </font><font style="vertical-align: inherit;">Cela constitue la base des coordonnées des cellules.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float4</span></span> gridUV = <span class="hljs-type"><span class="hljs-type">float4</span></span>(pos.xz, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); gridUV.x *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-number"><span class="hljs-number">8.66025404</span></span>); gridUV.y *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">15.0</span></span>); float2 cellDataCoordinates = floor(gridUV.xy);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour trouver les coordonnées de la cellule dans laquelle nous nous trouvons, nous ajoutons les déplacements stockés dans la texture. </font></font><br><br><pre> <code class="hljs pgsql"> float2 cellDataCoordinates = floor(gridUV.xy) + tex2Dlod(_GridCoordinates, gridUV).rg;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Puisqu'une partie de la grille est de 2 × 2 et que les décalages sont divisés par deux, nous devons doubler le résultat pour obtenir les coordonnées finales. </font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">float2</span></span> cellDataCoordinates = floor(gridUV.xy) + tex2Dlod(_GridCoordinates, gridUV).rg; <span class="hljs-attribute"><span class="hljs-attribute">cellDataCoordinates</span></span> *= <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous avons les coordonnées XZ de la grille de cellules que nous devons convertir en coordonnées UV de ces cellules. </font><font style="vertical-align: inherit;">Cela peut être fait en se déplaçant simplement vers le centre des pixels, puis en les divisant en tailles de texture. </font><font style="vertical-align: inherit;">Ajoutons donc une </font><font style="vertical-align: inherit;">fonction pour cela au </font><font style="vertical-align: inherit;">fichier d'inclusion </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HexCellData</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> qui gérera également l'échantillonnage.</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (float2 cellDataCoordinates) { float2 uv = cellDataCoordinates + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; uv.x *= _HexCellData_TexelSize.x; uv.y *= _HexCellData_TexelSize.y; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tex2Dlod(_HexCellData, <span class="hljs-type"><span class="hljs-type">float4</span></span>(uv, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant , </font><font style="vertical-align: inherit;">nous pouvons utiliser dans le programme de vertex shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la fonction</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs haskell"> cellDataCoordinates *= <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.visibility = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCellData</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cellDataCoordinates</span></span></span><span class="hljs-class">).x; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.visibility = lerp(0.25, 1, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">visibility</span></span></span><span class="hljs-class">);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ed/9c9/7ed/1ed9c97ed37aa88aaee6c0efd9d075d7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objets avec visibilité.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enfin, la visibilité affecte l'ensemble de la carte, à l'exception des unités qui sont toujours visibles. Puisque nous déterminons la visibilité des objets pour chaque sommet, puis pour l'objet traversant la limite des cellules, la visibilité des cellules qu'il ferme sera mélangée. Mais les objets sont si petits qu'ils restent constamment à l'intérieur de leur cellule, même en tenant compte de la distorsion des positions. Cependant, certains peuvent faire partie des sommets d'une autre cellule. Par conséquent, notre approche est bon marché, mais imparfaite. Ceci est plus visible dans le cas des murs, dont la visibilité varie entre les visibilités des cellules voisines.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/421/1c7/f7d/4211c7f7dea80bbbd13664586074c43a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Murs à visibilité variable. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étant donné que les segments de mur sont générés de manière procédurale, nous pouvons ajouter des données de cellule à leur maillage et utiliser l'approche que nous avons utilisée pour le relief. </font><font style="vertical-align: inherit;">Malheureusement, les tours sont préfabriquées, nous aurons donc encore des incohérences. </font><font style="vertical-align: inherit;">De manière générale, l'approche existante semble assez bonne pour la géométrie simple que nous utilisons. </font><font style="vertical-align: inherit;">À l'avenir, nous envisagerons des modèles et des murs plus détaillés, par conséquent, nous améliorerons la méthode de mélange de leur visibilité. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partie 21: recherche cartographique </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous affichons tout lors de l'édition. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous suivons les cellules enquêtées. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous cachons ce qui est encore inconnu. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous forçons les unités à éviter les zones inexplorées. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dans la partie précédente, nous avons ajouté le brouillard de guerre, que nous allons maintenant affiner pour mettre en œuvre la recherche cartographique. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/81d/40e/bff/81d40ebff615fc7c4e39a15d88da016d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous sommes prêts à explorer le monde.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Afficher la carte entière en mode édition </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le sens de l'étude est que jusqu'à ce que les cellules ne soient pas vues, elles sont considérées comme inconnues et donc invisibles. </font><font style="vertical-align: inherit;">Ils ne doivent pas être masqués, mais pas affichés du tout. </font><font style="vertical-align: inherit;">Par conséquent, avant d'ajouter un support de recherche, nous activerons la visibilité en mode édition.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Commutation de visibilité </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons contrôler si les shaders utilisent la visibilité en utilisant le mot-clé, comme cela a été fait avec la superposition sur la grille. </font><font style="vertical-align: inherit;">Utilisons le mot clé </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HEX_MAP_EDIT_MODE</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour </font><font style="vertical-align: inherit;">indiquer l'état du mode d'édition. </font><font style="vertical-align: inherit;">Puisque plusieurs shaders doivent connaître ce mot-clé, nous le définirons globalement en utilisant des méthodes statiques </font></font><code>Shader.EnableKeyWord</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>Shader.DisableKeyword</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous appellerons la méthode appropriée </font></font><code>HexGameUI.SetEditMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lors du changement de mode d'édition.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { enabled = !toggle; grid.ShowUI(!toggle); grid.ClearPath(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (toggle) { Shader.EnableKeyword(<span class="hljs-string"><span class="hljs-string">"HEX_MAP_EDIT_MODE"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Shader.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"HEX_MAP_EDIT_MODE"</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shaders du mode édition </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HEX_MAP_EDIT_MODE est</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> défini, les shaders ignorent la visibilité. </font><font style="vertical-align: inherit;">Cela se résume au fait que la visibilité des cellules sera toujours considérée comme égale à 1. Ajoutons une </font><font style="vertical-align: inherit;">fonction pour filtrer les données des cellules en fonction du mot-clé </font><font style="vertical-align: inherit;">au début du </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fichier</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inclus </font><em><font style="vertical-align: inherit;">HexCellData</font></em><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs kotlin">sampler2D _HexCellData; float4 _HexCellData_TexelSize; float4 FilterCellData (float4 <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(HEX_MAP_EDIT_MODE) <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.x = <span class="hljs-number"><span class="hljs-number">1</span></span>; #endif <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous passons par cette fonction le résultat des deux fonctions </font></font><code>GetCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avant de la retourner.</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { … <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FilterCellData(data); } <span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (float2 cellDataCoordinates) { … <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FilterCellData(tex2Dlod(_HexCellData, <span class="hljs-type"><span class="hljs-type">float4</span></span>(uv, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>))); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour que tout fonctionne, tous les shaders pertinents doivent recevoir la directive multi_compile pour créer des options au cas où le mot clé </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HEX_MAP_EDIT_MODE</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est </font><font style="vertical-align: inherit;">défini. </font><font style="vertical-align: inherit;">Ajoutez la ligne appropriée aux shaders </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estuaire</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entité</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivière</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Route</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eau</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rive d'eau</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , entre la directive cible et la première directive d'inclusion.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> multi_compile _ HEX_MAP_EDIT_MODE</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, lorsque vous passez en mode d'édition de carte, le brouillard de guerre disparaîtra. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Recherche cellulaire </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par défaut, les cellules doivent être considérées comme inexplorées. </font><font style="vertical-align: inherit;">Ils sont explorés lorsqu'une équipe les voit. </font><font style="vertical-align: inherit;">Après cela, ils continuent de faire l'objet d'une enquête si un détachement peut les voir.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suivi de l'état de l'étude </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour ajouter un support pour le suivi du statut des études, nous ajoutons à la </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propriété générale </font></font><code>IsExplored</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsExplored { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'état de l'étude est déterminé par la cellule elle-même. </font><font style="vertical-align: inherit;">Par conséquent, cette propriété doit être définie uniquement </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pour ajouter cette restriction, nous allons mettre le setter privé.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsExplored { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La première fois que la visibilité de la cellule devient supérieure à zéro, la cellule commence à être considérée comme étudiée et </font></font><code>IsExplored</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">une valeur doit donc être attribuée </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En fait, il nous suffira de simplement marquer la cellule comme examinée lorsque la visibilité augmente à 1. Cela doit être fait avant l'appel </font></font><code>RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { visibility += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (visibility == <span class="hljs-number"><span class="hljs-number">1</span></span>) { IsExplored = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transfert de l'état de la recherche aux shaders </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme dans le cas de la visibilité des cellules, nous transférons leur état de recherche aux shaders via les données du shader. </font><font style="vertical-align: inherit;">Au final, ce n'est qu'un autre type de visibilité. </font></font><code>HexCellShaderData.RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stocke l'état de visibilité dans le canal de données R. </font><font style="vertical-align: inherit;">Gardons l'état de l'étude dans les données du canal G.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = cell.Index; cellTextureData[index].r = cell.IsVisible ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; cellTextureData[index].g = cell.IsExplored ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Relief noir inexploré </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant utiliser des shaders pour visualiser l'état de la recherche cellulaire. </font><font style="vertical-align: inherit;">Pour nous assurer que tout fonctionne comme il se doit, nous rendons simplement le terrain inexploré noir. </font><font style="vertical-align: inherit;">Mais d'abord, pour que le mode d'édition fonctionne, modifiez-le </font></font><code>FilterCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">afin qu'il filtre les données de recherche.</font></font><br><br><pre> <code class="hljs kotlin">float4 FilterCellData (float4 <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(HEX_MAP_EDIT_MODE) <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.xy = <span class="hljs-number"><span class="hljs-number">1</span></span>; #endif <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> transmet les données de visibilité des trois cellules possibles au programme de fragments. </font><font style="vertical-align: inherit;">Dans le cas de l'état de recherche, nous les combinons dans le programme vertex et transférons la seule valeur au programme fragment. </font><font style="vertical-align: inherit;">Ajoutez le </font></font><code>visibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quatrième composant à l' </font><font style="vertical-align: inherit;">entrée </font><font style="vertical-align: inherit;">afin d'avoir une place pour cela.</font></font><br><br><pre> <code class="hljs pgsql"> struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { <span class="hljs-type"><span class="hljs-type">float4</span></span> color : COLOR; float3 worldPos; float3 terrain; <span class="hljs-type"><span class="hljs-type">float4</span></span> visibility; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, dans le programme vertex, lorsque nous changeons l'indice de visibilité, nous devons explicitement y accéder </font></font><code>data.visibility.xyz</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { … data.visibility.xyz = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility.xyz); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après cela, nous combinons les états de l'étude et écrivons le résultat </font></font><code>data.visibility.w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cela revient à combiner la visibilité dans d'autres shaders, mais en utilisant le composant Y de ces cellules.</font></font><br><br><pre> <code class="hljs haskell"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.visibility.xyz = lerp(0.25, 1, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">visibility</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xyz</span></span></span><span class="hljs-class">); </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.visibility.w = cell0.y * v.color.x + cell1.y * v.color.y + cell2.y * v.color.z;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le statut de la recherche est désormais disponible dans le programme Fragment via </font></font><code>IN.visibility.w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Considérez-le dans le calcul de l'albédo.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { … <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.w; o.Albedo = c.rgb * grid * _Color * explored; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2d/de4/c18/b2dde4c1831a9ecc637550b2b8e2e134.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La topographie inexplorée est maintenant noire. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le relief des cellules inexplorées a désormais une couleur noire. </font><font style="vertical-align: inherit;">Mais cela n'a pas encore affecté les objets, les routes et l'eau. </font><font style="vertical-align: inherit;">Cependant, cela suffit pour s'assurer que l'étude fonctionne.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enregistrement et chargement de l'état de la recherche </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que nous avons ajouté un support de recherche, nous devons nous assurer que l'état de la recherche est pris en compte lors de l'enregistrement et du chargement des cartes. </font><font style="vertical-align: inherit;">Par conséquent, nous devons augmenter la version des fichiers de carte à 3. Pour rendre ces modifications plus pratiques, ajoutons une </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constante </font><font style="vertical-align: inherit;">pour cela </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapFileVersion = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous utiliserons cette constante lors de l'écriture de la version du fichier </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et lors de la vérification de la prise en charge des fichiers </font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(mapFileVersion); hexGrid.Save(writer); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!File.Exists(path)) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"File does not exist "</span></span> + path); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &lt;= mapFileVersion) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme étape finale, </font></font><code>HexCell.Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous enregistrons le statut de l'étude.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { … writer.Write(IsExplored); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et nous le lirons à la fin </font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Après cela, nous appellerons </font></font><code>RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">au cas où l'état de l'étude </font><font style="vertical-align: inherit;">serait </font><font style="vertical-align: inherit;">différent du précédent.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { … IsExplored = reader.ReadBoolean(); ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour conserver la compatibilité descendante avec les anciens fichiers de sauvegarde, nous devons ignorer la lecture de l'état de sauvegarde si la version du fichier est inférieure à 3. Dans ce cas, par défaut, les cellules auront l'état «inexploré». </font><font style="vertical-align: inherit;">Pour ce faire, nous devons ajouter des </font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">données d'en-tête en </font><font style="vertical-align: inherit;">tant que paramètre </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { … IsExplored = header &gt;= <span class="hljs-number"><span class="hljs-number">3</span></span> ? reader.ReadBoolean() : <span class="hljs-literal"><span class="hljs-literal">false</span></span>; ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">va maintenant devoir passer les </font></font><code>HexCell.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">données d' </font><font style="vertical-align: inherit;">en- </font><font style="vertical-align: inherit;">tête.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader, header); } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Désormais, lors de l'enregistrement et du chargement des cartes, l'état d'exploration des cellules sera pris en compte. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Masquer les cellules inconnues </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au stade actuel, les cellules inexplorées sont visuellement indiquées par un relief noir. </font><font style="vertical-align: inherit;">Mais en réalité, nous voulons que ces cellules soient invisibles car elles sont inconnues. </font><font style="vertical-align: inherit;">Nous pouvons rendre la géométrie opaque transparente afin qu'elle ne soit pas visible. </font><font style="vertical-align: inherit;">Cependant, le framework d'ombrage de surface Unity a été développé sans cette possibilité à l'esprit. </font><font style="vertical-align: inherit;">Au lieu d'utiliser une véritable transparence, nous changerons les shaders pour qu'ils correspondent à l'arrière-plan, ce qui les rendra également invisibles.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rendre le relief vraiment noir </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que le relief étudié soit noir, on peut encore le reconnaître car il a toujours un éclairage spéculaire. Pour se débarrasser de l'éclairage, nous devons le rendre parfaitement noir mat. Afin de ne pas affecter les autres propriétés de surface, il est plus facile de changer la couleur spéculaire en noir. Cela est possible si vous utilisez un shader de surface qui fonctionne avec du spéculaire, mais maintenant nous utilisons le métal standard. Commençons donc par basculer le shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur spéculaire. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remplacez la propriété de couleur </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_Metallic</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur la </font><font style="vertical-align: inherit;">propriété </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_Specular</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Par défaut, sa valeur de couleur doit être égale à (0,2, 0,2, 0,2). Nous garantissons donc qu'elle correspondra à l'apparence de la version métallique.</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Terrain Texture Array"</span></span>, 2DArray) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_GridTex</span></span> (<span class="hljs-string"><span class="hljs-string">"Grid Texture"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> // _Metallic (<span class="hljs-string"><span class="hljs-string">"Metallic"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> _Specular (<span class="hljs-string"><span class="hljs-string">"Specular"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifiez également les variables de shader correspondantes. </font><font style="vertical-align: inherit;">La couleur des shaders de surface spéculaires est définie comme </font></font><code>fixed3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, utilisons-la donc.</font></font><br><br><pre> <code class="hljs objectivec"> half _Glossiness; <span class="hljs-comment"><span class="hljs-comment">// half _Metallic; fixed3 _Specular; fixed4 _Color;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifiez le surf surfacique pragma de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standard</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> à </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StandardSpecular</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Cela forcera Unity à générer des shaders en utilisant spéculaire.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf StandardSpecular fullforwardshadows vertex:vert</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, la fonction a </font></font><code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">besoin que le deuxième paramètre soit de type </font></font><code>SurfaceOutputStandardSpecular</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">De plus, vous devez maintenant attribuer la valeur non </font></font><code>o.Metallic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais </font></font><code>o.Specular</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { … <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.w; o.Albedo = c.rgb * grid * _Color * explored; // o.Metallic = _Metallic; o.Specular = _Specular; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons masquer les reflets en considérant la </font></font><code>explored</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">couleur spéculaire.</font></font><br><br><pre> <code class="hljs"> o.Specular = _Specular * explored;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/289/d05/128/289d0512816a7d6f692b0e7639e882eb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain inexploré sans éclairage réfléchi. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme vous pouvez le voir sur la photo, le relief inexploré est maintenant d'un noir terne. </font><font style="vertical-align: inherit;">Cependant, lorsqu'elles sont vues sous un angle tangent, les surfaces se transforment en miroir, à cause de quoi le relief commence à refléter l'environnement, c'est-à-dire la skybox.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi les surfaces deviennent-elles des miroirs?</font></font></b> <div class="spoiler_text">    .  .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rendering</a> . </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/255/d63/627/255d636278eb947c27117d6c596a9489.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les zones inexplorées reflètent toujours l'environnement. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour se débarrasser de ces reflets, on considérera le relief inexploré complètement ombré. </font><font style="vertical-align: inherit;">Ceci est accompli en attribuant une valeur au </font></font><code>explored</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paramètre d'occlusion, que nous utilisons comme masque de réflexion.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.w; o.Albedo = c.rgb * grid * _Color * explored; o.Specular = _Specular * explored; o.Smoothness = _Glossiness; o.Occlusion = explored; o.Alpha = ca;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/118/ab6/a5a/118ab6a5a91711eda2165433a7b99513.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inexploré sans reflets.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fond assorti </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que le terrain inexploré ignore tout l'éclairage, vous devez le faire correspondre à l'arrière-plan. </font><font style="vertical-align: inherit;">Comme notre caméra regarde toujours d'en haut, l'arrière-plan est toujours gris. </font><font style="vertical-align: inherit;">Pour indiquer au shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> quelle couleur utiliser, ajoutez la propriété </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_BackgroundColor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui est par défaut le noir.</font></font><br><br><pre> <code class="hljs dos"> Properties { … _BackgroundColor ("Background <span class="hljs-built_in"><span class="hljs-built_in">Color</span></span>", <span class="hljs-built_in"><span class="hljs-built_in">Color</span></span>) = (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) } … half _Glossiness; fixed3 _Specular; fixed4 _Color; half3 _BackgroundColor;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour utiliser cette couleur, nous l'ajouterons comme lumière émissive. </font><font style="vertical-align: inherit;">Ceci est </font></font><code>o.Emission</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">accompli en attribuant une valeur de couleur d'arrière-plan multipliée par un moins exploré.</font></font><br><br><pre> <code class="hljs"> o.Occlusion = explored; o.Emission = _BackgroundColor * (1 - explored);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisque nous utilisons la skybox par défaut, la couleur d'arrière-plan visible n'est en fait pas la même. </font><font style="vertical-align: inherit;">En général, un gris légèrement rougeâtre serait la meilleure couleur. </font><font style="vertical-align: inherit;">Lors de la configuration du matériau en relief, vous pouvez utiliser le </font><font style="vertical-align: inherit;">code 68615BFF </font><font style="vertical-align: inherit;">pour </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Color</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eeb/307/7dd/eeb3077dd097a7649575a371cbb361f6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matériau en relief avec fond gris. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En général, cela fonctionne, bien que si vous savez où chercher, vous remarquerez des silhouettes très faibles. </font><font style="vertical-align: inherit;">Pour que le joueur ne puisse pas les voir, vous pouvez attribuer une couleur d'arrière-plan uniforme de 68615BFF à la caméra au lieu de skybox.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b9/8cc/ec9/7b98ccec9228ac333cc23ec19cc6f28b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Appareil photo avec une couleur de fond uniforme.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi ne pas retirer la skybox?</font></font></b> <div class="spoiler_text">   ,   ,     environmental lighting .     ,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous ne pouvons pas trouver la différence entre le fond et les cellules inexplorées. </font><font style="vertical-align: inherit;">Une topographie inexplorée élevée peut toujours masquer une topographie explorée basse à de faibles angles de caméra. </font><font style="vertical-align: inherit;">De plus, des parties inexplorées projettent toujours des ombres sur l'exploré. </font><font style="vertical-align: inherit;">Mais ces indices minimaux peuvent être négligés.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f88/764/d67/f88764d67aec0bf90267d273e1a248d5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les cellules inexplorées ne sont plus visibles.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que faire si vous n'utilisez pas une couleur d'arrière-plan uniforme?</font></font></b> <div class="spoiler_text">    ,        ,      .        .      ,          .       ,     ,  ,  UV-           . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Masquer les objets en relief </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous n'avons plus que le maillage du relief caché. </font><font style="vertical-align: inherit;">Le reste de l'état de l'étude n'a pas encore été affecté.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/282/c0c/a0f/282c0ca0fb55bf26ee0bb1d43cadd42f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'à présent, seul le relief est caché. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifions le shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feature</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui est un shader opaque comme </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Transformez-le en un shader spéculaire et ajoutez-lui la couleur d'arrière-plan. </font><font style="vertical-align: inherit;">Commençons par les propriétés.</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Albedo (RGB)"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> // _Metallic (<span class="hljs-string"><span class="hljs-string">"Metallic"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> _Specular (<span class="hljs-string"><span class="hljs-string">"Specular"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>) _BackgroundColor (<span class="hljs-string"><span class="hljs-string">"Background Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) [NoScaleOffset] _GridCoordinates (<span class="hljs-string"><span class="hljs-string">"Grid Coordinates"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Surface et variables du pragma supplémentaires, comme précédemment. </font></font><br><br><pre> <code class="hljs cpp"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf StandardSpecular fullforwardshadows vertex:vert … half _Glossiness; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// half _Metallic; fixed3 _Specular; fixed4 _Color; half3 _BackgroundColor;</span></span></span></span></code> </pre> <br> <code>visibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un autre composant est également requis. </font><font style="vertical-align: inherit;">Puisque </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feature</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> combine la visibilité pour chaque sommet, il ne lui fallait qu'une seule valeur flottante. </font><font style="vertical-align: inherit;">Il nous en faut maintenant deux.</font></font><br><br><pre> <code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span></span>{ float2 uv_MainTex; float2 visibility; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifiez-le </font></font><code>vert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">afin qu'il utilise explicitement pour les données de visibilité </font></font><code>data.visibility.x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, puis affectez la </font></font><code>data.visibility.y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valeur des données d'étude.</font></font><br><br><pre> <code class="hljs kotlin"> void vert (inout appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Input <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { … float4 cellData = GetCellData(cellDataCoordinates); <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = cellData.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x); <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.y = cellData.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifiez-le </font></font><code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour qu'il utilise les nouvelles données, comme </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { fixed4 c = tex2D (_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex) * _Color; <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.y; o.Albedo = c.rgb * (<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.x * explored); // o.Metallic = _Metallic; o.Specular = _Specular * explored; o.Smoothness = _Glossiness; o.Occlusion = explored; o.Emission = _BackgroundColor * (<span class="hljs-number"><span class="hljs-number">1</span></span> - explored); o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d13/863/dc6/d13863dc60bbb92750cd5c8f8b69d82b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objets de secours cachés.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Masquer l'eau </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, les shaders </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water Shore</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Commençons par les convertir en shaders spéculaires. </font><font style="vertical-align: inherit;">Cependant, ils n'ont pas besoin d'une couleur d'arrière-plan car ce sont des shaders transparents. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après la conversion, ajoutez </font></font><code>visibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un autre composant et modifiez-le en conséquence </font></font><code>vert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Les deux shaders combinent les données de trois cellules.</font></font><br><br><pre> <code class="hljs dos"> struct Input { … float2 visibility; }; … void vert (inout appdata_full v, out Input data) { … data.visibility.x = cell0.x * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.x + cell1.x * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.y + cell2.x * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.z; data.visibility.x = lerp(<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility.x); data.visibility.y = cell0.y * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.x + cell1.y * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.y + cell2.y * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.z; }</code> </pre> <br> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water Shore</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> effectuent </font></font><code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des opérations différentes, mais définissent leurs propriétés de surface de la même manière. </font><font style="vertical-align: inherit;">Puisqu'ils sont transparents, nous prendrons en compte </font></font><code>explore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans le canal alpha, et nous ne fixerons pas d'émission.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { … <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.y; o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.x; o.Specular = _Specular * explored; o.Smoothness = _Glossiness; o.Occlusion = explored; o.Alpha = ca * explored; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15a/e39/390/15ae39390ccbe91f3d12f068992a7c14.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eau cachée.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous cachons les estuaires, les rivières et les routes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons toujours les shaders pour l' </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estuaire</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rivière</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">route</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Les trois sont transparents et combinent les données de deux cellules. </font><font style="vertical-align: inherit;">Mettez-les tous en spéculaire, puis ajoutez-les aux </font></font><code>visibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">données de recherche.</font></font><br><br><pre> <code class="hljs kotlin"> struct Input { … float2 visibility; }; … void vert (inout appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Input <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { … <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = cell0.x * v.color.x + cell1.x * v.color.y; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x); <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.y = cell0.y * v.color.x + cell1.y * v.color.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifiez la fonction des </font></font><code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shaders </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estuaire</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivière</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour qu'elle utilise les nouvelles données. </font><font style="vertical-align: inherit;">Les deux doivent apporter les mêmes modifications.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { … <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.y; fixed4 c = saturate(_Color + water); o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.x; o.Specular = _Specular * explored; o.Smoothness = _Glossiness; o.Occlusion = explored; o.Alpha = ca * explored; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le Shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Road est un</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> peu différent car il utilise une métrique de mélange supplémentaire.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); fixed4 c = _Color * ((noise.y * <span class="hljs-number"><span class="hljs-number">0.75</span></span> + <span class="hljs-number"><span class="hljs-number">0.25</span></span>) * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.x); <span class="hljs-type"><span class="hljs-type">float</span></span> blend = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.x; blend *= noise.x + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; blend = smoothstep(<span class="hljs-number"><span class="hljs-number">0.4</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, blend); <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.y; o.Albedo = c.rgb; o.Specular = _Specular * explored; o.Smoothness = _Glossiness; o.Occlusion = explored; o.Alpha = blend * explored; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c6/1d2/c65/1c61d2c652b436385b42188c39476c14.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout est caché. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Éviter les cellules inexplorées </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que tout ce qui est inconnu soit visuellement caché, l'état de l'étude n'est pas pris en compte lors de la recherche d'un chemin. </font><font style="vertical-align: inherit;">En conséquence, les unités peuvent être commandées pour se déplacer à travers et à travers des cellules inexplorées, déterminant magiquement la voie à suivre. </font><font style="vertical-align: inherit;">Nous devons forcer les unités pour éviter les cellules inexplorées.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca9/eb9/f22/ca9eb9f22cd36b917bd5f0c38028bce7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parcourez les cellules inexplorées.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les escouades déterminent le coût du déplacement </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avant de s'attaquer aux cellules inexplorées, refaisons le code pour transférer le coût du déplacement de </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cela simplifiera la prise en charge des unités avec différentes règles de mouvement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez à la </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">méthode générale </font></font><code>GetMoveCost</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour déterminer le coût du déménagement. </font><font style="vertical-align: inherit;">Il a besoin de savoir quelles cellules se déplacent entre elles, ainsi que la direction. </font><font style="vertical-align: inherit;">Nous copions le code correspondant pour les coûts de passage de </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cette méthode et modifions les noms des variables.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMoveCost</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexCell fromCell, HexCell toCell, HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { HexEdgeType edgeType = fromCell.GetEdgeType(toCell); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edgeType == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> moveCost; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fromCell.HasRoadThroughEdge(direction)) { moveCost = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fromCell.Walled != toCell.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { moveCost = edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; moveCost += toCell.UrbanLevel + toCell.FarmLevel + toCell.PlantLevel; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La méthode doit renvoyer le coût du déménagement. </font><font style="vertical-align: inherit;">J'ai utilisé l'ancien code pour ignorer les mouvements invalides </font></font><code>continue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais cette approche ne fonctionnera pas ici. </font><font style="vertical-align: inherit;">Si le mouvement n'est pas possible, nous rembourserons les coûts négatifs du déménagement.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMoveCost</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexCell fromCell, HexCell toCell, HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { HexEdgeType edgeType = fromCell.GetEdgeType(toCell); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edgeType == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> moveCost; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fromCell.HasRoadThroughEdge(direction)) { moveCost = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fromCell.Walled != toCell.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { moveCost = edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; moveCost += toCell.UrbanLevel + toCell.FarmLevel + toCell.PlantLevel; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> moveCost; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous devons savoir quand trouver le chemin, non seulement la vitesse, mais aussi l'unité sélectionnée. </font><font style="vertical-align: inherit;">Changez en conséquence </font></font><code>HexGameUI.DoPathFinding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoPathfinding</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UpdateCurrentCell()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentCell &amp;&amp; selectedUnit.IsValidDestination(currentCell)) { grid.FindPath(selectedUnit.Location, currentCell, selectedUnit); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { grid.ClearPath(); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étant donné que nous avons encore besoin d'accéder à la vitesse de l'équipe, nous allons ajouter à la </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propriété </font></font><code>Speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Alors qu'il renverra une valeur constante de 24.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Speed { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mutation, </font></font><code>FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour qu'ils puissent travailler avec notre nouvelle approche.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, HexUnit unit</span></span></span><span class="hljs-function">)</span></span> { ClearPath(); currentPathFrom = fromCell; currentPathTo = toCell; currentPathExists = Search(fromCell, toCell, unit); ShowPath(unit.Speed); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, HexUnit unit</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> speed = unit.Speed; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous allons supprimer de l' </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ancien code qui déterminait s'il est possible de passer à la cellule suivante et quels sont les coûts de déplacement. </font><font style="vertical-align: inherit;">Au lieu de cela, nous appellerons </font></font><code>HexUnit.IsValidDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>HexUnit.GetMoveCost</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous sauterons la cellule si le coût du déménagement est négatif.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.SearchPhase &gt; searchFrontierPhase ) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// if (neighbor.IsUnderwater || neighbor.Unit) { // continue; // } // HexEdgeType edgeType = current.GetEdgeType(neighbor); // if (edgeType == HexEdgeType.Cliff) { // continue; // } // int moveCost; // if (current.HasRoadThroughEdge(d)) { // moveCost = 1; // } // else if (current.Walled != neighbor.Walled) { // continue; // } // else { // moveCost = edgeType == HexEdgeType.Flat ? 5 : 10; // moveCost += neighbor.UrbanLevel + neighbor.FarmLevel + // neighbor.PlantLevel; // } if (!unit.IsValidDestination(neighbor)) { continue; } int moveCost = unit.GetMoveCost(current, neighbor, d); if (moveCost &lt; 0) { continue; } int distance = current.Distance + moveCost; int turn = (distance - 1) / speed; if (turn &gt; currentTurn) { distance = turn * speed + moveCost; } … }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Contourner les zones inexplorées </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour éviter les cellules inexplorées, il nous suffit de </font></font><code>HexUnit.IsValidDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vérifier si la cellule est examinée.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsValidDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell.IsExplored &amp;&amp; !cell.IsUnderwater &amp;&amp; !cell.Unit; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a84/831/2c6/a848312c6231a168a966e4cdafc2df38.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plus d'unités ne pourront pas accéder à des cellules inexplorées. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étant donné que les cellules inexplorées ne sont plus des points de terminaison valides, les escouades les éviteront lors du déplacement vers le point de terminaison. </font><font style="vertical-align: inherit;">Autrement dit, les zones inexplorées agissent comme des barrières qui allongent le chemin ou même le rendent impossible. </font><font style="vertical-align: inherit;">Nous devrons rapprocher les unités d'un terrain inconnu afin d'abord d'explorer la région.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que faire si un chemin plus court apparaît pendant le déménagement?</font></font></b> <div class="spoiler_text">                .           ,        .       . <br><br>   ,        ,            .            ,    . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partie 22: Visibilité améliorée </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modifiez en douceur la visibilité. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Utilisez la hauteur de la cellule pour déterminer la portée. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Masquez le bord de la carte. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En ajoutant la prise en charge de l'exploration cartographique, nous améliorerons les calculs et les transitions de l'oscilloscope. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d2/c4a/793/2d2c4a7939e75fe09298f96ff6125478.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour voir plus loin, grimpez plus haut.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transitions de visibilité </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La cellule est visible ou invisible, car elle est ou non dans le périmètre du détachement. </font><font style="vertical-align: inherit;">Même s'il semble qu'il faut un certain temps à une unité pour se déplacer entre les cellules, sa portée passe instantanément de cellule en cellule. </font><font style="vertical-align: inherit;">En conséquence, la visibilité des cellules environnantes change considérablement. </font><font style="vertical-align: inherit;">Le mouvement de l'escouade semble fluide, mais les changements de visibilité sont soudains. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idéalement, la visibilité devrait également changer en douceur. </font><font style="vertical-align: inherit;">Une fois dans le champ de visibilité, les cellules doivent être éclairées progressivement et, en la laissant, s'assombrir progressivement. </font><font style="vertical-align: inherit;">Ou peut-être préférez-vous des transitions instantanées? </font><font style="vertical-align: inherit;">Ajoutons à la </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propriété qui change les transitions instantanées. </font><font style="vertical-align: inherit;">Par défaut, les transitions seront fluides.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ImmediateMode { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suivi des cellules de transition </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Même lors de l'affichage de transitions fluides, les données de visibilité réelle restent binaires, c'est-à-dire que l'effet n'est que visuel. </font><font style="vertical-align: inherit;">Cela signifie que les transitions de visibilité doivent être traitées </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous lui donnerons une liste de cellules dans lesquelles la transition est effectuée. </font><font style="vertical-align: inherit;">Assurez-vous qu'à chaque initialisation, il est vide.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCellShaderData</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { Texture2D cellTexture; Color32[] cellTextureData; List&lt;HexCell&gt; transitioningCells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexCell&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ImmediateMode { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … transitioningCells.Clear(); enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour le moment, nous définissons </font></font><code>RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">directement les </font><font style="vertical-align: inherit;">données des cellules </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ceci est toujours correct pour le mode de transition instantanée, mais lorsqu'il est désactivé, nous devons ajouter une cellule à la liste des cellules de transition.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = cell.Index; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ImmediateMode) { cellTextureData[index].r = cell.IsVisible ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; cellTextureData[index].g = cell.IsExplored ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { transitioningCells.Add(cell); } enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La visibilité ne semble plus fonctionner, car pour l'instant, nous ne faisons rien avec les cellules de la liste. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Boucle à travers les cellules en boucle </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au lieu de régler instantanément les valeurs correspondantes sur 255 ou 0, nous augmenterons / diminuerons ces valeurs progressivement. </font><font style="vertical-align: inherit;">La fluidité de la transition dépend du taux de changement. </font><font style="vertical-align: inherit;">Cela ne devrait pas être très rapide et pas très lent. </font><font style="vertical-align: inherit;">Un bon compromis entre de belles transitions et la commodité du jeu est de changer en une seconde. </font><font style="vertical-align: inherit;">Fixons une constante pour que cela soit plus facile à changer.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> transitionSpeed = <span class="hljs-number"><span class="hljs-number">255f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, </font></font><code>LateUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous pouvons définir le delta appliqué aux valeurs. </font><font style="vertical-align: inherit;">Pour ce faire, multipliez le delta temporel par la vitesse. </font><font style="vertical-align: inherit;">Il doit s'agir d'un entier car nous ne savons pas quelle taille il peut avoir. </font><font style="vertical-align: inherit;">Une forte baisse de la fréquence d'images peut rendre le delta supérieur à 255. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, nous devons mettre à jour lorsqu'il y a des cellules de transition. </font><font style="vertical-align: inherit;">Par conséquent, le code doit être inclus tant qu'il y a quelque chose dans la liste.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LateUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(Time.deltaTime * transitionSpeed); cellTexture.SetPixels32(cellTextureData); cellTexture.Apply(); enabled = transitioningCells.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Également théoriquement possible des fréquences d'images très élevées. </font><font style="vertical-align: inherit;">En combinaison avec une faible vitesse de transition, cela peut nous donner un delta de 0. Pour que le changement ait lieu, nous forçons le delta minimum à 1.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(Time.deltaTime * transitionSpeed); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta == <span class="hljs-number"><span class="hljs-number">0</span></span>) { delta = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après avoir reçu le delta, nous pouvons boucler autour de toutes les cellules de transition et mettre à jour leurs données. </font><font style="vertical-align: inherit;">Supposons que nous ayons une méthode pour cela </font></font><code>UpdateCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dont les paramètres sont la cellule et le delta correspondants.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(Time.deltaTime * transitionSpeed); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta == <span class="hljs-number"><span class="hljs-number">0</span></span>) { delta = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; transitioningCells.Count; i++) { UpdateCellData(transitioningCells[i], delta); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À un moment donné, la transition cellulaire devrait se terminer. </font><font style="vertical-align: inherit;">Supposons que la méthode renvoie des informations indiquant si la transition est toujours en cours. </font><font style="vertical-align: inherit;">Lorsque cela cesse, nous pouvons supprimer la cellule de la liste. </font><font style="vertical-align: inherit;">Après cela, nous devons décrémenter l'itérateur afin de ne pas sauter les cellules.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; transitioningCells.Count; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!UpdateCellData(transitioningCells[i], delta)) { transitioningCells.RemoveAt(i--); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'ordre dans lequel les cellules de transition sont traitées n'est pas important. </font><font style="vertical-align: inherit;">Par conséquent, nous n'avons pas à supprimer la cellule à l'index en cours, ce qui forcerait </font></font><code>RemoveAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">toutes les cellules </font><font style="vertical-align: inherit;">à se </font><font style="vertical-align: inherit;">déplacer après lui. </font><font style="vertical-align: inherit;">Au lieu de cela, nous déplaçons la dernière cellule vers l'index en cours, puis supprimons la dernière.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!UpdateCellData(transitioningCells[i], delta)) { transitioningCells[i--] = transitioningCells[transitioningCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; transitioningCells.RemoveAt(transitioningCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons maintenant créer une méthode </font></font><code>UpdateCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pour faire son travail, il aura besoin d'un index et de données de cellule, alors commençons par les obtenir. </font><font style="vertical-align: inherit;">Il doit également déterminer s'il convient de poursuivre la mise à jour de la cellule. </font><font style="vertical-align: inherit;">Par défaut, nous supposerons que ce n'est pas nécessaire. </font><font style="vertical-align: inherit;">Une fois les travaux terminés, il est nécessaire d'appliquer les données modifiées et de renvoyer l'état "la mise à jour se poursuit".</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = cell.Index; Color32 data = cellTextureData[index]; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> stillUpdating = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; cellTextureData[index] = data; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stillUpdating; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mise à jour des données de cellule </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A ce stade, nous avons une cellule en transition ou déjà terminée. </font><font style="vertical-align: inherit;">Tout d'abord, vérifions l'état de la sonde cellulaire. </font><font style="vertical-align: inherit;">Si la cellule est examinée, mais que sa valeur G n'est pas encore égale à 255, alors elle est en cours de transition, nous allons donc surveiller cela.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> stillUpdating = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsExplored &amp;&amp; data.g &lt; <span class="hljs-number"><span class="hljs-number">255</span></span>) { stillUpdating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } cellTextureData[index] = data;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour effectuer la transition, nous ajouterons un delta à la valeur G de la cellule. </font><font style="vertical-align: inherit;">Les opérations arithmétiques ne fonctionnent pas avec les octets, elles sont d'abord converties en entier. </font><font style="vertical-align: inherit;">Par conséquent, la somme aura le format entier, qui doit être converti en octet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsExplored &amp;&amp; data.g &lt; <span class="hljs-number"><span class="hljs-number">255</span></span>) { stillUpdating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = data.g + delta; data.g = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)t; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mais avant la conversion, vous devez vous assurer que la valeur ne dépasse pas 255. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = data.g + delta; data.g = t &gt;= <span class="hljs-number"><span class="hljs-number">255</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)t;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ensuite, nous devons faire de même pour la visibilité, qui utilise la valeur de R. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsExplored &amp;&amp; data.g &lt; <span class="hljs-number"><span class="hljs-number">255</span></span>) { … } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsVisible &amp;&amp; data.r &lt; <span class="hljs-number"><span class="hljs-number">255</span></span>) { stillUpdating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = data.r + delta; data.r = t &gt;= <span class="hljs-number"><span class="hljs-number">255</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)t; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Puisque la cellule peut redevenir invisible, nous devons vérifier s'il est nécessaire de diminuer la valeur de R. Cela se produit lorsque la cellule est invisible, mais R est supérieur à zéro. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsVisible) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.r &lt; <span class="hljs-number"><span class="hljs-number">255</span></span>) { stillUpdating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = data.r + delta; data.r = t &gt;= <span class="hljs-number"><span class="hljs-number">255</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)t; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.r &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { stillUpdating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = data.r - delta; data.r = t &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)t; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, il est </font></font><code>UpdateCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prêt et les transitions de visibilité sont effectuées correctement.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transitions de visibilité.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Protection contre les éléments de transition en double </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les transitions fonctionnent, mais des éléments en double peuvent apparaître dans la liste. </font><font style="vertical-align: inherit;">Cela se produit si l'état de visibilité de la cellule change alors qu'elle est encore en transition. </font><font style="vertical-align: inherit;">Par exemple, lorsque la cellule n'est visible pendant le mouvement de l'équipe que pendant une courte période. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En raison de l'apparition d'éléments dupliqués, la transition de cellule est mise à jour plusieurs fois par image, ce qui entraîne des transitions plus rapides et un travail supplémentaire. </font><font style="vertical-align: inherit;">Nous pouvons éviter cela en vérifiant avant d'ajouter une cellule si elle est déjà dans la liste. </font><font style="vertical-align: inherit;">Cependant, une liste de recherche à chaque appel</font></font><code>RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coûteux, en particulier lorsque plusieurs transitions cellulaires sont effectuées. </font><font style="vertical-align: inherit;">À la place, utilisons un autre canal qui n'a pas encore été utilisé pour indiquer si la cellule est en cours de transition, par exemple, la valeur B. Lorsque nous ajoutons une cellule à la liste, nous lui attribuons la valeur 255 et n'ajoutons que les cellules dont la valeur n'est pas égale à 255.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = cell.Index; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ImmediateMode) { cellTextureData[index].r = cell.IsVisible ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; cellTextureData[index].g = cell.IsExplored ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellTextureData[index].b != <span class="hljs-number"><span class="hljs-number">255</span></span>) { cellTextureData[index].b = <span class="hljs-number"><span class="hljs-number">255</span></span>; transitioningCells.Add(cell); } enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour que cela fonctionne, nous devons réinitialiser la valeur de B après la fin de la transition cellulaire. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!stillUpdating) { data.b = <span class="hljs-number"><span class="hljs-number">0</span></span>; } cellTextureData[index] = data; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stillUpdating; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transitions sans doublons.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chargement instantané de la visibilité </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les changements de visibilité sont désormais toujours progressifs, même lors du chargement d'une carte. </font><font style="vertical-align: inherit;">Ceci est illogique, car la carte décrit l'état dans lequel les cellules sont déjà visibles, donc la transition est inappropriée ici. </font><font style="vertical-align: inherit;">De plus, effectuer des transitions pour les nombreuses cellules visibles d'une grande carte peut ralentir le jeu après le chargement. </font><font style="vertical-align: inherit;">Par conséquent, avant de charger des cellules et des escouades, passons </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">au mode de transition instantanée.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { … cellShaderData.ImmediateMode = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader, header); } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous redéfinissons donc le réglage initial du mode de transition instantanée, quel qu'il soit. </font><font style="vertical-align: inherit;">Peut-être qu'il est déjà désactivé ou a fait une option de configuration, nous nous souviendrons donc du mode initial et y basculerons après la fin des travaux.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> originalImmediateMode = cellShaderData.ImmediateMode; cellShaderData.ImmediateMode = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; … cellShaderData.ImmediateMode = originalImmediateMode; }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Portée dépendante de la hauteur </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'à présent, nous avons utilisé une portée constante de trois pour toutes les unités, mais en réalité, c'est plus compliqué. Dans le cas général, nous ne pouvons pas voir l'objet pour deux raisons: soit un obstacle nous empêche de le voir, soit l'objet est trop petit ou trop éloigné. Dans notre jeu, nous n'implémentons que la limitation de portée. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous ne pouvons pas voir ce qui se trouve de l'autre côté de la Terre, car la planète nous obscurcit. Nous ne pouvons que voir à l'horizon. Puisque la planète peut être considérée approximativement comme une sphère, plus le point de vue est élevé, plus nous pouvons voir de surface, c'est-à-dire que l'horizon dépend de la hauteur.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/071/788/208/0717882082a42e92b14e158876c6e28b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'horizon dépend de la hauteur du point de vue. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La visibilité limitée de nos unités imite l'effet d'horizon créé par la courbure de la Terre. </font><font style="vertical-align: inherit;">La portée de leur examen dépend de la taille de la planète et de l'échelle de la carte. </font><font style="vertical-align: inherit;">C'est du moins l'explication logique. </font><font style="vertical-align: inherit;">Mais la principale raison de la réduction de la portée est le gameplay, c'est une limitation appelée le brouillard de guerre. </font><font style="vertical-align: inherit;">Cependant, en comprenant la physique sous-jacente au champ de vision, nous pouvons conclure qu'un point de vue élevé devrait avoir une valeur stratégique, car il éloigne l'horizon et vous permet de regarder les obstacles inférieurs. </font><font style="vertical-align: inherit;">Mais jusqu'à présent, nous ne l'avons pas mis en œuvre.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hauteur pour examen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour tenir compte de la hauteur lors de la détermination de la portée, nous devons connaître la hauteur. </font><font style="vertical-align: inherit;">Ce sera la hauteur ou le niveau d'eau habituel, selon qu'il s'agit de la cellule terrestre ou de l'eau. </font><font style="vertical-align: inherit;">Ajoutons cela à la </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propriété.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ViewElevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation &gt;= waterLevel ? elevation : waterLevel; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais si la hauteur affecte la portée, alors avec un changement de la hauteur de vision de la cellule, la situation de visibilité peut également changer. </font><font style="vertical-align: inherit;">Étant donné que la cellule a bloqué ou bloque désormais la portée de plusieurs unités, il n'est pas si facile de déterminer ce qui doit être changé. </font><font style="vertical-align: inherit;">La cellule elle-même ne pourra pas résoudre ce problème, alors laissez-la signaler un changement de situation </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Supposons que vous </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ayez une méthode pour cela </font></font><code>ViewElevationChanged</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous l'appellerons lors de la cession </font></font><code>HexCell.Elevation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, si nécessaire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevation == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalViewElevation = ViewElevation; elevation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ViewElevation != originalViewElevation) { ShaderData.ViewElevationChanged(); } … } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il en va de même </font></font><code>WaterLevel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> WaterLevel { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> waterLevel; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (waterLevel == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalViewElevation = ViewElevation; waterLevel = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ViewElevation != originalViewElevation) { ShaderData.ViewElevationChanged(); } ValidateRivers(); Refresh(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Réinitialiser la visibilité </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons maintenant créer une méthode </font></font><code>HexCellShaderData.ViewElevationChanged</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Déterminer comment une situation de visibilité générale change est une tâche complexe, en particulier lorsque vous changez plusieurs cellules en même temps. </font><font style="vertical-align: inherit;">Par conséquent, nous ne proposerons aucune astuce, mais prévoyons simplement de réinitialiser la visibilité de toutes les cellules. </font><font style="vertical-align: inherit;">Ajoutez un champ booléen pour savoir si cela doit être fait. </font><font style="vertical-align: inherit;">Dans la méthode, nous allons simplement la définir sur true et inclure le composant. </font><font style="vertical-align: inherit;">Quel que soit le nombre de cellules qui ont changé simultanément, cela entraînera une seule réinitialisation.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> needsVisibilityReset; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ViewElevationChanged</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { needsVisibilityReset = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour réinitialiser les valeurs de visibilité de toutes les cellules, vous devez y avoir accès, ce que vous n'avez </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pas. </font><font style="vertical-align: inherit;">Déléguons donc cette responsabilité </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pour ce faire, vous devez ajouter à la </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propriété, ce qui vous permet de vous référer à la grille. </font><font style="vertical-align: inherit;">Ensuite, nous pouvons l'utiliser </font></font><code>LateUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour demander une réinitialisation.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid Grid { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LateUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (needsVisibilityReset) { needsVisibilityReset = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; Grid.ResetVisibility(); } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Passons à </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: définir le lien vers la grille </font></font><code>HexGrid.Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">après avoir créé les données du shader.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; cellShaderData = gameObject.AddComponent&lt;HexCellShaderData&gt;(); cellShaderData.Grid = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; CreateMap(cellCountX, cellCountZ); }</code> </pre> <br> <code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devrait également obtenir une méthode </font></font><code>ResetVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour éliminer toutes les cellules. </font><font style="vertical-align: inherit;">Faites-le contourner toutes les cellules de la boucle et déléguez-lui la réinitialisation.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].ResetVisibility(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous devons ajouter à la </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">méthode </font></font><code>ResetVisibilty</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il mettra simplement à zéro la visibilité et déclenchera la mise à jour de la visibilité. </font><font style="vertical-align: inherit;">Cela doit être fait lorsque la visibilité des cellules est supérieure à zéro.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (visibility &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { visibility = <span class="hljs-number"><span class="hljs-number">0</span></span>; ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après avoir réinitialisé toutes les données de visibilité, </font></font><code>HexGrid.ResetVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il doit à nouveau appliquer la visibilité à toutes les escouades, pour lesquelles il doit connaître la portée de chaque escouade. </font><font style="vertical-align: inherit;">Supposons qu'il puisse être obtenu à l'aide de la propriété </font></font><code>VisionRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].ResetVisibility(); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; units.Count; i++) { HexUnit unit = units[i]; IncreaseVisibility(unit.Location, unit.VisionRange); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour que cela fonctionne, nous allons refactoriser le changement </font></font><code>HexUnit.visionRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de </font><font style="vertical-align: inherit;">nom </font></font><code>HexUnit.VisionRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et le transformer en propriété. </font><font style="vertical-align: inherit;">Bien qu'il recevra une valeur constante de 3, mais à l'avenir, il changera.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> VisionRange { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour cette raison, les données de visibilité seront réinitialisées et resteront correctes après avoir modifié la hauteur de visualisation des cellules. </font><font style="vertical-align: inherit;">Mais il est probable que nous allons changer les règles pour déterminer la portée et exécuter la recompilation en mode Play. </font><font style="vertical-align: inherit;">Pour que l'étendue change indépendamment, exécutons une réinitialisation </font></font><code>HexGrid.OnEnable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lorsque la recompilation est détectée.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { … ResetVisibility(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vous pouvez maintenant modifier le code de portée et voir les résultats, tout en restant en mode Lecture. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Élargir l'horizon </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le calcul de la portée est déterminé </font></font><code>HexGrid.GetVisibleCells</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pour que la hauteur affecte la portée, nous pouvons simplement utiliser la hauteur de vision en </font></font><code>fromCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">redéfinissant temporairement la zone transmise. </font><font style="vertical-align: inherit;">Nous pouvons donc facilement vérifier si cela fonctionne.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">List&lt;HexCell&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetVisibleCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> range</span></span></span><span class="hljs-function">)</span></span> { … range = fromCell.ViewElevation; fromCell.SearchPhase = searchFrontierPhase; fromCell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(fromCell); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/727/032/6d3/7270326d379796f2b4f2f3c3ca65512c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisez la hauteur comme portée.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Obstacles à la visibilité </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'application d'une hauteur de visualisation en tant que portée ne fonctionne correctement que lorsque toutes les autres cellules sont à une hauteur nulle. </font><font style="vertical-align: inherit;">Mais si toutes les cellules ont la même hauteur que le point de vue, alors le champ de vision doit être nul. </font><font style="vertical-align: inherit;">De plus, les cellules avec des hauteurs élevées devraient bloquer la visibilité des cellules basses derrière elles. </font><font style="vertical-align: inherit;">Jusqu'à présent, rien de tout cela n'a été mis en œuvre.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de8/7be/a6f/de87bea6f4b88cd61765450a63f738f9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La portée n'interfère pas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La façon la plus correcte de déterminer la portée serait de vérifier par l'émission de rayons, mais cela deviendrait rapidement coûteux et produirait encore des résultats étranges. </font><font style="vertical-align: inherit;">Nous avons besoin d'une solution rapide qui crée des résultats suffisamment bons qui ne doivent pas nécessairement être parfaits. </font><font style="vertical-align: inherit;">De plus, il est important que les règles de détermination de la portée soient simples, intuitives et prévisibles pour les joueurs. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notre solution sera la suivante - lors de la détermination de la visibilité d'une cellule, nous ajouterons la hauteur de vision de la cellule voisine à la distance parcourue. </font><font style="vertical-align: inherit;">En fait, cela réduit la portée lorsque nous regardons ces cellules, et si elles sont ignorées, cela ne nous permettra pas d'atteindre les cellules derrière elles.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance + neighbor.ViewElevation &gt; range) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/774/44c/efe/77444cefe82d428ee32e094213e82a1a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les cellules hautes bloquent la vue.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ne devrions-nous pas voir de grandes cellules au loin?</font></font></b> <div class="spoiler_text">      ,     ,   ,   .       ,       . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ne regardez pas dans les coins </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il semble maintenant que les cellules hautes bloquent la vue à un niveau bas, mais parfois la portée pénètre à travers elles, bien qu'il semble que cela ne devrait pas être le cas. </font><font style="vertical-align: inherit;">Cela se produit car l'algorithme de recherche trouve toujours un chemin vers ces cellules, contournant les cellules bloquantes. </font><font style="vertical-align: inherit;">En conséquence, il semble que notre zone de visibilité puisse contourner les obstacles. </font><font style="vertical-align: inherit;">Pour éviter cela, nous devons nous assurer que seuls les chemins les plus courts sont pris en compte lors de la détermination de la visibilité des cellules. </font><font style="vertical-align: inherit;">Cela peut être fait en supprimant les chemins qui deviennent plus longs que nécessaire.</font></font><br><br><pre> <code class="cs hljs"> HexCoordinates fromCoordinates = fromCell.coordinates; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { … <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance + neighbor.ViewElevation &gt; range || distance &gt; fromCoordinates.DistanceTo(neighbor.coordinates) ) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } … } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30d/bfa/1c2/30dbfa1c2df2fb6119249f00cdc3d8d8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous utilisons uniquement les chemins les plus courts.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous avons donc corrigé la plupart des cas manifestement erronés. Pour les cellules voisines, cela fonctionne bien, car il n'y a que les chemins les plus courts vers elles. Les cellules plus éloignées ont plus d'options pour les trajets; par conséquent, sur de longues distances, une enveloppe de visibilité peut toujours se produire. Ce ne sera pas un problème si les zones de visibilité restent petites et que les différences de hauteur adjacentes ne sont pas trop importantes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et enfin, au lieu de remplacer le champ de vision transmis, nous y ajoutons la hauteur de la vue. Le propre champ de vision de l’escouade indique sa hauteur, son altitude de vol ou ses capacités de reconnaissance.</font></font><br><br><pre> <code class="cs hljs"> range += fromCell.ViewElevation;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ff/1ce/a2b/3ff1cea2b833bda69990576fa8323aec.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vue avec plein champ de vision à un point de vue bas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est-à-dire que les dernières règles de visibilité s'appliquent à la vision lors du déplacement sur le chemin le plus court vers le champ de vision, en tenant compte de la différence de hauteur de cellule par rapport au point de vue. </font><font style="vertical-align: inherit;">Lorsqu'une cellule est hors de portée, elle bloque tous les chemins la traversant. </font><font style="vertical-align: inherit;">En conséquence, les points d'observation élevés, d'où rien n'empêche la vue, deviennent stratégiquement précieux.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'en est-il de gêner la visibilité des objets?</font></font></b> <div class="spoiler_text">  ,        ,  . ,  ,        .          . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cellules qui ne peuvent pas être explorées </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le dernier problème de visibilité concerne les bords de la carte. </font><font style="vertical-align: inherit;">Le relief se termine brusquement et sans transitions, car les cellules en bordure n'ont pas de voisins.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/587/217/fbb/587217fbb248ae8a13759a33e22e25ff.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bord marqué de la carte.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idéalement, l'affichage visuel des zones et des bords inexplorés de la carte devrait être le même. Nous pouvons y parvenir en ajoutant des cas spéciaux lors de la triangulation des bords, lorsqu'ils n'ont pas de voisins, mais cela nécessitera une logique supplémentaire et nous devrons travailler avec des cellules manquantes. Par conséquent, une telle solution n'est pas triviale. Une autre approche consiste à forcer les cellules limites de la carte à être inexplorées, même si elles sont dans la portée de l'escouade. Cette approche est beaucoup plus simple, alors utilisons-la. Il vous permet également de marquer comme inexploré et d'autres cellules, ce qui facilite la création de bords inégaux de la carte. De plus, les cellules cachées sur les bords vous permettent de créer des routes et des rivières qui entrent et sortent de la carte de la rivière et de la route, car leurs points d'extrémité seront hors de portée.De plus, avec l'aide de cette solution, vous pouvez ajouter des unités entrant et sortant de la carte.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous marquons les cellules comme enquêtées </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour indiquer qu'une cellule peut être examinée, ajoutez à la </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propriété </font></font><code>Explorable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Explorable { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Désormais, une cellule peut être visible si elle fait l'objet d'une enquête. </font></font><code>IsVisible</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous allons donc </font><font style="vertical-align: inherit;">modifier la propriété </font><font style="vertical-align: inherit;">pour en tenir compte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsVisible { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> visibility &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; Explorable; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La même chose s'applique à </font></font><code>IsExplored</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cependant, pour cela, nous avons étudié la propriété standard. </font><font style="vertical-align: inherit;">Nous devons le convertir en une propriété explicite afin de pouvoir changer la logique de son getter.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsExplored { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> explored &amp;&amp; Explorable; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { explored = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } … <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> explored;</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Masquer le bord de la carte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez masquer le bord d'une carte rectangulaire dans la méthode </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Les cellules qui ne sont pas sur le bord sont étudiées, tout le reste est inexploré.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { … HexCell cell = cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab); cell.transform.localPosition = position; cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); cell.Index = i; cell.ShaderData = cellShaderData; cell.Explorable = x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; x &lt; cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; z &lt; cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, les cartes sont assombries sur les bords, se cachant derrière elles d'immenses espaces inexplorés. </font><font style="vertical-align: inherit;">Par conséquent, la taille de la zone étudiée des cartes diminue de deux dans chaque dimension.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/594/19f/353/59419f35345fa4eac3380c4e16461baf.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bord inexploré de la carte.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Est-il possible de rendre l'état de la recherche modifiable?</font></font></b> <div class="spoiler_text"> ,  ,     .          . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Des cellules inexplorées nuisent à la visibilité </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin, si la cellule ne peut pas être examinée, elle devrait nuire à la visibilité. </font><font style="vertical-align: inherit;">Modifiez </font></font><code>HexGrid.GetVisibleCells</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour en tenir compte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.SearchPhase &gt; searchFrontierPhase || !neighbor.Explorable ) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partie 23: générer des terres </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Remplissez de nouvelles cartes avec des paysages générés. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous élevons des terres au-dessus de l'eau, nous en inondons. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous contrôlons la quantité de terrain créé, sa hauteur et ses irrégularités. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous ajoutons la prise en charge de diverses options de configuration pour créer des cartes variables. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous faisons en sorte que la même carte puisse être générée à nouveau. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette partie du didacticiel sera le début d'une série sur la génération de cartes procédurales. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette partie a été créée dans Unity 2017.1.0.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99e/798/7bb/99e7987bbcb46f1f961b72ba76a78aa0.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'une des nombreuses cartes générées.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Génération de cartes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que nous puissions créer n'importe quelle carte, cela prend beaucoup de temps. Il serait pratique que l'application puisse aider le concepteur en générant pour lui des cartes qu'il pourra ensuite modifier à son goût. Vous pouvez prendre une autre étape et vous débarrasser complètement de la création manuelle de la conception, transférant complètement la responsabilité de générer la carte finie à l'application. Pour cette raison, le jeu peut être joué à chaque fois avec une nouvelle carte et chaque session de jeu sera différente. Pour que tout cela soit possible, nous devons créer un algorithme de génération de carte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le type d'algorithme de génération dont vous avez besoin dépend du type de carte dont vous avez besoin. Il n'y a pas de bonne approche, il faut toujours chercher un compromis entre crédibilité et jouabilité.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour qu'une carte soit crédible, elle doit sembler tout à fait possible et réelle au joueur. Cela ne signifie pas que la carte doit ressembler à une partie de notre planète. Ce peut être une planète différente ou une réalité complètement différente. Mais s'il doit indiquer le relief de la Terre, il doit lui ressembler au moins partiellement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La jouabilité est liée à la façon dont les cartes correspondent au gameplay. Parfois, cela entre en conflit avec la crédibilité. Par exemple, bien que les chaînes de montagnes puissent être belles, en même temps, elles limitent considérablement le mouvement et la vue des unités. Si cela n'est pas souhaitable, vous devez vous passer de montagnes, ce qui réduira la crédibilité et limiter l'expressivité du jeu. Ou nous pouvons sauver les montagnes, mais réduire leur impact sur le gameplay, ce qui peut également réduire la crédibilité.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, la faisabilité doit être considérée. Par exemple, vous pouvez créer une planète semblable à la terre très réaliste en simulant des plaques tectoniques, l'érosion, les pluies, les éruptions volcaniques, les effets des météorites et de la lune, etc. Mais le développement d'un tel système demandera beaucoup de temps. De plus, la génération d'une telle planète peut prendre beaucoup de temps et les joueurs ne voudront pas attendre quelques minutes avant de commencer une nouvelle partie. Autrement dit, la simulation est un outil puissant, mais elle a un prix.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les jeux utilisent souvent des compromis entre crédibilité, jouabilité et faisabilité. Parfois, ces compromis sont invisibles et semblent tout à fait normaux, et parfois ils semblent aléatoires, incohérents ou chaotiques, selon les décisions prises au cours du processus de développement. Cela s'applique non seulement à la génération de cartes, mais lors du développement d'un générateur de cartes procédural, vous devez y prêter une attention particulière. Vous pouvez passer beaucoup de temps à créer un algorithme qui génère de belles cartes qui s'avèrent inutiles pour le jeu que vous créez.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cette série de didacticiels, nous allons créer un relief semblable à la terre. </font><font style="vertical-align: inherit;">Il devrait être intéressant, avec une grande variabilité et l'absence de grandes zones homogènes. </font><font style="vertical-align: inherit;">L'échelle du relief sera grande, les cartes couvriront un ou plusieurs continents, régions des océans ou même une planète entière. </font><font style="vertical-align: inherit;">Nous devons contrôler la géographie, y compris les masses terrestres, le climat, le nombre de régions et les bosses du terrain. </font><font style="vertical-align: inherit;">Dans cette partie, nous allons jeter les bases de la création de sushi.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Démarrer en mode édition </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous allons nous concentrer sur la carte, pas sur le gameplay, il sera donc plus pratique de lancer l'application en mode édition. </font><font style="vertical-align: inherit;">Grâce à cela, nous pouvons immédiatement voir les cartes. </font><font style="vertical-align: inherit;">Par conséquent, nous allons changer en </font></font><code>HexMapEditor.Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">définissant le mode d'édition sur true et en activant le mot-clé shader de ce mode.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrainMaterial.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); Shader.EnableKeyword(<span class="hljs-string"><span class="hljs-string">"HEX_MAP_EDIT_MODE"</span></span>); SetEditMode(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Générateur de cartes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étant donné que beaucoup de code est nécessaire pour générer des cartes procédurales, nous ne les ajouterons pas directement à </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Au lieu de cela, nous allons créer un nouveau composant </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous ne le saurons pas. </font><font style="vertical-align: inherit;">Cela simplifiera la transition vers un autre algorithme si nous en avons besoin. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le générateur a besoin d'un lien vers la grille, nous allons donc lui ajouter un champ général. </font><font style="vertical-align: inherit;">De plus, nous ajoutons une méthode générale </font></font><code>GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui traitera du travail de l'algorithme. </font><font style="vertical-align: inherit;">Nous allons lui donner les dimensions de la carte en tant que paramètres, puis la forcer à être utilisée pour créer une nouvelle carte vide.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexMapGenerator</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid grid; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { grid.CreateMap(x, z); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez un objet avec un composant à la scène </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et connectez-le à la grille.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/932/b6e/fd2/932b6efd2dd1809893af27ec7a91c620.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objet générateur de carte.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Changer le menu d'une nouvelle carte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous allons le changer </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">afin qu'il puisse générer des cartes, pas seulement en créer des vides. </font><font style="vertical-align: inherit;">Nous contrôlerons sa fonctionnalité via un champ booléen </font></font><code>generateMaps</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui par défaut a une valeur </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Créons une méthode générale pour définir ce champ, comme nous l'avons fait pour changer d'options </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ajoutez le commutateur approprié au menu et connectez-le à la méthode.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> generateMaps = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleMapGeneration</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { generateMaps = toggle; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc9/9c7/0c9/fc99c70c99095b3565104ef42254859d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menu d'une nouvelle carte avec un interrupteur. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Donnez au menu un lien vers le générateur de carte. </font><font style="vertical-align: inherit;">Ensuite, nous le forcerons à appeler la méthode du </font></font><code>GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">générateur </font><font style="vertical-align: inherit;">si nécessaire </font><font style="vertical-align: inherit;">, et pas seulement à exécuter la </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grille.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMapGenerator mapGenerator; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (generateMaps) { mapGenerator.GenerateMap(x, z); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hexGrid.CreateMap(x, z); } HexMapCamera.ValidatePosition(); Close(); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d1/e98/3d9/7d1e983d927d912b75d9b245219659f1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connexion au générateur.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Accès cellulaire </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour que le générateur fonctionne, il doit avoir accès aux cellules. </font><font style="vertical-align: inherit;">Nous </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avons déjà des </font><font style="vertical-align: inherit;">méthodes communes </font></font><code>GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui nécessitent ou vecteur de position, ou les </font><font style="vertical-align: inherit;">coordonnées hexagonaux. </font><font style="vertical-align: inherit;">Le générateur n'a pas besoin de fonctionner avec l'un ou l'autre, nous ajoutons donc deux méthodes pratiques </font></font><code>HexGrid.GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui fonctionneront avec les coordonnées du décalage ou de l'index de la cellule.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xOffset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zOffset</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cells[xOffset + zOffset * cellCountX]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cellIndex</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cells[cellIndex]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, il </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut recevoir directement des cellules. </font><font style="vertical-align: inherit;">Par exemple, après avoir créé une nouvelle carte, il peut utiliser les coordonnées de l'herbe pour définir l'herbe comme relief de la colonne centrale des cellules.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { grid.CreateMap(x, z); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; z; i++) { grid.GetCell(x / <span class="hljs-number"><span class="hljs-number">2</span></span>, i).TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/860/aee/119/860aee119f0e000ef290f6c87e61ad05.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colonne d'herbe sur une petite carte. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Faire des sushis </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de la génération d'une carte, nous commençons complètement sans terrain. </font><font style="vertical-align: inherit;">On peut imaginer que le monde entier est inondé d'un immense océan. </font><font style="vertical-align: inherit;">Une terre est créée lorsqu'une partie du plancher océanique est tellement élevée qu'elle s'élève au-dessus de l'eau. </font><font style="vertical-align: inherit;">Nous devons décider combien de terres devraient être créées de cette façon, où elles apparaîtront et quelle forme elles auront.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Augmentez le soulagement </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commençons petit - élever un morceau de terre au-dessus de l'eau. </font><font style="vertical-align: inherit;">Nous créons pour cela une méthode </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec un paramètre pour contrôler la taille du tracé. </font><font style="vertical-align: inherit;">Appelez cette méthode dans </font></font><code>GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en remplaçant le code de test précédent. </font><font style="vertical-align: inherit;">Commençons par un petit terrain composé de sept cellules.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { grid.CreateMap(x, z); <span class="hljs-comment"><span class="hljs-comment">// for (int i = 0; i &lt; z; i++) { // grid.GetCell(x / 2, i).TerrainTypeIndex = 1; // } RaiseTerrain(7); } void RaiseTerrain (int chunkSize) {}</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'à présent, nous utilisons le relief de type «herbe» pour désigner la terre élevée, et le relief «sable» d'origine se réfère à l'océan. </font><font style="vertical-align: inherit;">Faites-nous </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prendre une cellule au hasard et changez le type de son relief jusqu'à ce que nous obtenions la bonne quantité de terrain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour obtenir une cellule aléatoire, nous ajoutons une méthode </font></font><code>GetRandomCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui détermine un indice de cellule aléatoire et obtient la cellule correspondante à partir de la grille.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunkSize; i++) { GetRandomCell().TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grid.GetCell(Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, grid.cellCountX * grid.cellCountZ)); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/396/fb8/ce6/396fb8ce67de74961b31562e275bd81a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sept cellules de sushi aléatoires. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme à la fin, nous pourrions avoir besoin de beaucoup de cellules aléatoires ou parcourir plusieurs fois toutes les cellules, gardons une trace du nombre de cellules dans la cellule elle-même </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cellCount; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { cellCount = x * z; … } … <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grid.GetCell(Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, cellCount)); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Création d'un site </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'à présent, nous transformons sept cellules aléatoires en terres, et elles peuvent être n'importe où. </font><font style="vertical-align: inherit;">Très probablement, ils ne forment pas une seule zone terrestre. </font><font style="vertical-align: inherit;">De plus, nous pouvons sélectionner plusieurs fois les mêmes cellules, donc nous obtenons moins de terrain. </font><font style="vertical-align: inherit;">Pour résoudre les deux problèmes, sans restrictions, nous sélectionnerons uniquement la première cellule. </font><font style="vertical-align: inherit;">Après cela, nous devons sélectionner uniquement les cellules qui sont à côté de celles sélectionnées précédemment. </font><font style="vertical-align: inherit;">Ces restrictions sont similaires aux limitations de la recherche de chemin, nous utilisons donc la même approche ici. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous ajoutons </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">notre propre propriété et le compteur de la phase de la frontière de recherche, comme c'était le cas </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> HexCellPriorityQueue searchFrontier; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> searchFrontierPhase;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vérifiez que la file d'attente prioritaire existe avant d'en avoir besoin. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { cellCount = x * z; grid.CreateMap(x, z); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } RaiseTerrain(<span class="hljs-number"><span class="hljs-number">7</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après avoir créé une nouvelle carte, la limite de recherche pour toutes les cellules est nulle. Mais si nous allons rechercher des cellules dans le processus de génération de carte, nous augmenterons leur frontière de recherche dans ce processus. Si nous effectuons de nombreuses opérations de recherche, elles peuvent être en avance sur la phase de la limite de recherche enregistrée </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Cela peut interférer avec la recherche de chemins d'unité. Pour éviter cela, à la fin du processus de génération de carte, nous remettrons à zéro la phase de recherche de toutes les cellules.</font></font><br><br><pre> <code class="cs hljs"> RaiseTerrain(<span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { grid.GetCell(i).SearchPhase = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, je </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dois chercher les cellules appropriées et ne pas les sélectionner au hasard. Ce processus est très similaire à la méthode de recherche dans </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Cependant, nous ne visiterons pas les cellules plus d'une fois, il nous suffira donc d'augmenter la phase de la bordure de recherche de 1 au lieu de 2. Ensuite, nous initialisons la bordure avec la première cellule, qui est sélectionnée au hasard. Comme d'habitude, en plus de définir sa phase de recherche, nous attribuons sa distance et son heuristique à zéro.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// for (int i = 0; i &lt; chunkSize; i++) { // GetRandomCell().TerrainTypeIndex = 1; // } searchFrontierPhase += 1; HexCell firstCell = GetRandomCell(); firstCell.SearchPhase = searchFrontierPhase; firstCell.Distance = 0; firstCell.SearchHeuristic = 0; searchFrontier.Enqueue(firstCell); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après cela, la boucle de recherche nous sera pour la plupart familière. </font><font style="vertical-align: inherit;">De plus, pour continuer la recherche jusqu'à ce que la bordure soit vide, nous devons nous arrêter lorsque le fragment atteint la taille souhaitée, nous allons donc le suivre. </font><font style="vertical-align: inherit;">À chaque itération, nous allons extraire la cellule suivante de la file d'attente, définir le type de son relief, augmenter la taille, puis contourner les voisins de cette cellule. </font><font style="vertical-align: inherit;">Tous les voisins sont simplement ajoutés à la frontière s'ils n'y ont pas encore été ajoutés. </font><font style="vertical-align: inherit;">Nous n'avons pas besoin de faire de changements ou de comparaisons. </font><font style="vertical-align: inherit;">Après avoir terminé, vous devez effacer la frontière.</font></font><br><br><pre> <code class="cs hljs"> searchFrontier.Enqueue(firstCell); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (size &lt; chunkSize &amp;&amp; searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); current.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; size += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; neighbor.SearchPhase &lt; searchFrontierPhase) { neighbor.SearchPhase = searchFrontierPhase; neighbor.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; neighbor.SearchHeuristic = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(neighbor); } } } searchFrontier.Clear();</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97a/f44/023/97af440236cb6909130d6a8bfaab3f5a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une ligne de cellules. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons obtenu une seule parcelle de la bonne taille. </font><font style="vertical-align: inherit;">Il ne sera plus petit que s'il n'y a pas un nombre suffisant de cellules. </font><font style="vertical-align: inherit;">En raison de la façon dont la frontière est remplie, le tracé se compose toujours d'une ligne allant vers le nord-ouest. </font><font style="vertical-align: inherit;">Il ne change de direction que lorsqu'il atteint le bord de la carte.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous connectons les cellules </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les zones terrestres ressemblent rarement à des lignes, et si elles le font, elles ne sont pas toujours orientées de la même manière. </font><font style="vertical-align: inherit;">Pour changer la forme du site, nous devons changer les priorités des cellules. </font><font style="vertical-align: inherit;">La première cellule aléatoire peut être utilisée comme centre du tracé. </font><font style="vertical-align: inherit;">La distance à toutes les autres cellules sera alors relative à ce point. </font><font style="vertical-align: inherit;">Nous accorderons donc une priorité plus élevée aux cellules plus proches du centre, de sorte que le site ne se développera pas en ligne, mais autour du centre.</font></font><br><br><pre> <code class="cs hljs"> searchFrontier.Enqueue(firstCell); HexCoordinates center = firstCell.coordinates; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (size &lt; chunkSize &amp;&amp; searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); current.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; size += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; neighbor.SearchPhase &lt; searchFrontierPhase) { neighbor.SearchPhase = searchFrontierPhase; neighbor.Distance = neighbor.coordinates.DistanceTo(center); neighbor.SearchHeuristic = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(neighbor); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/841/117/149/84111714960a293415b1d24edf92f56b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'accumulation de cellules. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et en fait, maintenant nos sept cellules sont joliment emballées dans une zone hexagonale compacte si la cellule centrale n'apparaît pas sur le bord de la carte. </font><font style="vertical-align: inherit;">Essayons maintenant d'utiliser une taille de tracé de 30.</font></font><br><br><pre> <code class="cs hljs"> RaiseTerrain(<span class="hljs-number"><span class="hljs-number">30</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/893/c36/13e/893c3613edfe02b457cc4ee6d191072c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masse de sushi en 30 cellules. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons de nouveau la même forme, bien qu'il n'y ait pas assez de cellules pour obtenir le bon hexagone. </font><font style="vertical-align: inherit;">Étant donné que le rayon du tracé est plus grand, il est plus susceptible d'être proche du bord de la carte, ce qui l'obligera à prendre une forme différente.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Randomisation des sushis </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous ne voulons pas que toutes les zones soient identiques, nous allons donc modifier légèrement les priorités des cellules. </font><font style="vertical-align: inherit;">Chaque fois que nous ajoutons une cellule voisine à la bordure, si le nombre suivant est </font></font><code>Random.value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inférieur à une certaine valeur de seuil, l'heuristique de cette cellule devient non pas 0, mais 1. Utilisons la valeur 0,5 comme seuil, c'est-à-dire qu'elle affectera très probablement la moitié des cellules.</font></font><br><br><pre> <code class="cs hljs"> neighbor.Distance = neighbor.coordinates.DistanceTo(center); neighbor.SearchHeuristic = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(neighbor);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43e/aec/793/43eaec79315f68e0618fe71c0f93c3f3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zone déformée.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En augmentant l'heuristique de recherche de la cellule, nous l'avons rendue visite plus tard que prévu. En même temps, d'autres cellules situées un peu plus loin du centre seront visitées plus tôt, à moins qu'elles n'augmentent également l'heuristique. Cela signifie que si nous augmentons l'heuristique de toutes les cellules d'une valeur, cela n'affectera pas la carte. Autrement dit, le seuil 1 n'aura pas d'effet, comme le seuil 0. Et le seuil 0,8 sera équivalent à 0,2. Autrement dit, la probabilité de 0,5 rend le processus de recherche le plus "tremblant". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La quantité d'oscillation appropriée dépend du type de terrain souhaité, nous allons donc la personnaliser. Ajouter un champ flottant générique </font></font><code>jitterProbability</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec l'attribut </font><font style="vertical-align: inherit;">au générateur</font></font><code>Range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">limité dans la plage de 0 à 0,5. </font><font style="vertical-align: inherit;">Donnons-lui une valeur par défaut égale à la moyenne de cet intervalle, soit 0,25. </font><font style="vertical-align: inherit;">Cela nous permettra de configurer le générateur dans la fenêtre de l'inspecteur Unity.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 0.5f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> jitterProbability = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/795/b50/381/795b50381d8c9cda219ff092cf64cee5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Probabilité de fluctuations. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pouvez-vous le rendre personnalisable dans l'interface utilisateur du jeu?</font></font></b> <div class="spoiler_text">  ,       .           UI,       .          ,      UI.  ,     .         ,       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maintenant, pour décider quand l'heuristique doit être égale à 1, nous utilisons la probabilité au lieu d'une valeur constante. </font></font><br><br><pre> <code class="cs hljs"> neighbor.SearchHeuristic = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; jitterProbability ? <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous utilisons des valeurs heuristiques de 0 et 1. Bien que des valeurs plus grandes puissent être utilisées, cela aggravera considérablement la déformation des sections, les transformant très probablement en un tas de bandes. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Élever des terres </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous ne nous limiterons pas à la génération d'un seul terrain. </font><font style="vertical-align: inherit;">Par exemple, nous plaçons un appel </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans une boucle pour obtenir cinq sections.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { RaiseTerrain(<span class="hljs-number"><span class="hljs-number">30</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d42/83f/acd/d4283facd88705107d705290c3d8e78b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cinq parcelles de terrain. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que nous générions maintenant cinq parcelles de 30 cellules chacune, mais pas nécessairement exactement 150 cellules de terrain. </font><font style="vertical-align: inherit;">Étant donné que chaque site est créé séparément, ils ne se connaissent pas, ils peuvent donc se croiser. </font><font style="vertical-align: inherit;">C'est normal car cela peut créer des paysages plus intéressants qu'un simple ensemble de sections isolées. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour augmenter la variabilité des terres, nous pouvons également changer la taille de chaque parcelle. </font><font style="vertical-align: inherit;">Ajoutez deux champs entiers pour contrôler les tailles minimale et maximale des tracés. </font><font style="vertical-align: inherit;">Attribuez-leur un intervalle suffisamment grand, par exemple 20-200. </font><font style="vertical-align: inherit;">Je ferai le minimum standard égal à 30, et le maximum standard - 100.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(20, 200)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSizeMin = <span class="hljs-number"><span class="hljs-number">30</span></span>; [Range(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSizeMax = <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ea/026/e43/9ea026e43e949f571be0358332447de5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intervalle de dimensionnement. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous utilisons ces champs pour déterminer aléatoirement la taille de la zone lors de l'appel </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> RaiseTerrain(Random.Range(chunkSizeMin, chunkSizeMax + <span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0df/124/dab/0df124dab1f706825f75304d2862aea3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cinq sections de taille aléatoire sur la carte du milieu.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Créez suffisamment de sushis </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Certes, on ne peut pas particulièrement contrôler la quantité de terrain générée. </font><font style="vertical-align: inherit;">Bien que nous puissions ajouter l'option de configuration pour le nombre de parcelles, les parcelles elles-mêmes sont de taille aléatoire et peuvent se chevaucher légèrement ou fortement. </font><font style="vertical-align: inherit;">Par conséquent, le nombre de sites ne garantit pas la réception sur la carte de la quantité de terrain requise. </font><font style="vertical-align: inherit;">Ajoutons une option pour contrôler directement le pourcentage de terrain exprimé en nombre entier. </font><font style="vertical-align: inherit;">Étant donné que 100% de la terre ou de l'eau n'est pas très intéressant, nous le limitons à l'intervalle 5–95, avec une valeur de 50 par défaut.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(5, 95)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landPercentage = <span class="hljs-number"><span class="hljs-number">50</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21e/281/912/21e281912ad5a4a5378c5e55514c639c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourcentage de sushi. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour garantir la création de la bonne quantité de terrain, il nous suffit de continuer à élever des zones du terrain jusqu'à ce que nous obtenions une quantité suffisante. </font><font style="vertical-align: inherit;">Pour ce faire, nous devons contrôler le processus, ce qui compliquera la génération de terres. </font><font style="vertical-align: inherit;">Par conséquent, remplaçons le cycle existant de création de sites en appelant une nouvelle méthode </font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La première chose que fait cette méthode est de calculer le nombre de cellules qui devraient devenir des terres. </font><font style="vertical-align: inherit;">Ce montant sera notre somme totale de cellules de sushi.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-comment"><span class="hljs-comment">// for (int i = 0; i &lt; 5; i++) { // RaiseTerrain(Random.Range(chunkSizeMin, chunkSizeMax + 1)); // } CreateLand(); for (int i = 0; i &lt; cellCount; i++) { grid.GetCell(i).SearchPhase = 0; } } void CreateLand () { int landBudget = Mathf.RoundToInt(cellCount * landPercentage * 0.01f); }</span></span></code> </pre> <br> <code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">provoquera </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jusqu'à ce que nous ayons dépensé la totalité des cellules. </font><font style="vertical-align: inherit;">Afin de ne pas dépasser le montant, nous modifions </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour qu'il reçoive le montant comme paramètre supplémentaire. </font><font style="vertical-align: inherit;">Après avoir terminé ses travaux, il doit restituer le montant restant.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// void RaiseTerrain (int chunkSize) { int RaiseTerrain (int chunkSize, int budget) { … return budget; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le montant devrait diminuer chaque fois que la cellule est retirée de la frontière et convertie en terre. </font><font style="vertical-align: inherit;">Si après cela, le montant total est dépensé, alors nous devons arrêter la recherche et terminer le site. </font><font style="vertical-align: inherit;">De plus, cela ne devrait être fait que lorsque la cellule actuelle n'est pas encore atterrie.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (size &lt; chunkSize &amp;&amp; searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.TerrainTypeIndex == <span class="hljs-number"><span class="hljs-number">0</span></span>) { current.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (--budget == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } size += <span class="hljs-number"><span class="hljs-number">1</span></span>; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, il </font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut élever des terres jusqu'à ce qu'il dépense la totalité des cellules.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { landBudget = RaiseTerrain( Random.Range(chunkSizeMin, chunkSizeMax + <span class="hljs-number"><span class="hljs-number">1</span></span>), landBudget ); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d15/34e/7f4/d1534e7f47ba4cf87f3dbeed60aa7d00.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exactement la moitié de la carte est devenue un terrain. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tenez compte de la hauteur </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La terre n'est pas seulement une plaque plate, limitée par le littoral. </font><font style="vertical-align: inherit;">Elle a une hauteur changeante, contenant des collines, des montagnes, des vallées, des lacs, etc. </font><font style="vertical-align: inherit;">De grandes différences de hauteur existent en raison de l'interaction des plaques tectoniques se déplaçant lentement. </font><font style="vertical-align: inherit;">Bien que nous ne le simulions pas, nos terres devraient en quelque sorte ressembler à de telles plaques. </font><font style="vertical-align: inherit;">Les sites ne bougent pas, mais peuvent se croiser. </font><font style="vertical-align: inherit;">Et nous pouvons en profiter.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Poussez la terre </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chaque parcelle représente une portion de terre expulsée du fond de l'océan. </font><font style="vertical-align: inherit;">Par conséquent, augmentons constamment la hauteur de la cellule actuelle </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et voyons ce qui se passe.</font></font><br><br><pre> <code class="cs hljs"> HexCell current = searchFrontier.Dequeue(); current.Elevation += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.TerrainTypeIndex == <span class="hljs-number"><span class="hljs-number">0</span></span>) { … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b3c/f6e/d3e/b3cf6ed3e71eb737ea7246c92bdd5624.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain avec des hauteurs. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons atteint les hauteurs, mais c'est difficile à voir. </font><font style="vertical-align: inherit;">Vous pouvez les rendre plus lisibles si vous utilisez votre propre type de terrain pour chaque niveau de hauteur, comme la superposition géographique. </font><font style="vertical-align: inherit;">Nous ne le ferons que pour que les hauteurs soient plus visibles, vous pouvez donc simplement utiliser le niveau de hauteur comme indice d'élévation.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que se passe-t-il si la hauteur dépasse le nombre de types de terrain?</font></font></b> <div class="spoiler_text">        .        ,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au lieu de mettre à jour le type de terrain de la cellule à chaque changement de hauteur, créons une méthode distincte </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour définir tous les types de terrain une seule fois.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); cell.TerrainTypeIndex = cell.Elevation; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous appellerons cette méthode après avoir créé des sushis. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … CreateLand(); SetTerrainType(); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, il </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne peut plus gérer le type de relief et se concentrer sur les hauteurs. </font><font style="vertical-align: inherit;">Pour ce faire, vous devez modifier sa logique. </font><font style="vertical-align: inherit;">Si la nouvelle hauteur de la cellule actuelle est 1, alors elle vient de devenir plus sèche, donc la somme des cellules a diminué, ce qui peut conduire à l'achèvement de la croissance du site.</font></font><br><br><pre> <code class="cs hljs"> HexCell current = searchFrontier.Dequeue(); current.Elevation += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.Elevation == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; --budget == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// if (current.TerrainTypeIndex == 0) { // current.TerrainTypeIndex = 1; // if (--budget == 0) { // break; // } // }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee0/eec/b9e/ee0eecb9e59f527bd27f0275e230de0a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stratification des couches.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ajouter de l'eau </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Indiquons explicitement quelles cellules sont de l'eau ou de la terre, en réglant le niveau d'eau pour toutes les cellules sur 1. Faites-le </font></font><code>GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avant de créer la terre.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { cellCount = x * z; grid.CreateMap(x, z); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { grid.GetCell(i).WaterLevel = <span class="hljs-number"><span class="hljs-number">1</span></span>; } CreateLand(); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, pour la désignation des couches terrestres, nous pouvons utiliser tous les types de terrain. </font><font style="vertical-align: inherit;">Toutes les cellules sous-marines resteront sablonneuses, tout comme les cellules terrestres les plus basses. </font><font style="vertical-align: inherit;">Cela peut être fait en soustrayant le niveau d'eau de la hauteur et en utilisant la valeur comme indice du type de relief.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { cell.TerrainTypeIndex = cell.Elevation - cell.WaterLevel; } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b5/449/bc3/1b5449bc37b1c677d908484c7bcd0286.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terre et eau.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Augmentez le niveau d'eau </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous ne sommes pas limités à un seul niveau d'eau. </font><font style="vertical-align: inherit;">Rendons-le personnalisable à l'aide d'un champ commun avec un intervalle de 1 à 5 et une valeur par défaut de 3. </font><font style="vertical-align: inherit;">Utilisez ce niveau lors de l'initialisation des cellules.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(1, 5)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> waterLevel = <span class="hljs-number"><span class="hljs-number">3</span></span>; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { grid.GetCell(i).WaterLevel = waterLevel; } … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c32/9cf/82f/c329cf82f9a847ac01f2754cc3252500.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/850/c9d/fe4/850c9dfe4694834486bf4be64ac1783a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Niveau d'eau 3.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lorsque le niveau d'eau est à 3, nous obtenons moins de terres que prévu. </font><font style="vertical-align: inherit;">C'est parce qu'il </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">croit toujours que le niveau d'eau est 1. Corrigeons-le.</font></font><br><br><pre> <code class="cs hljs"> HexCell current = searchFrontier.Dequeue(); current.Elevation += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.Elevation == waterLevel &amp;&amp; --budget == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'utilisation de niveaux d'eau plus élevés conduit à cela. </font><font style="vertical-align: inherit;">que les cellules ne deviennent pas des terres immédiatement. </font><font style="vertical-align: inherit;">Lorsque le niveau d'eau est à 2, la première section restera toujours sous l'eau. </font><font style="vertical-align: inherit;">Le fond de l'océan a augmenté, mais reste toujours sous l'eau. </font><font style="vertical-align: inherit;">Un terrain n'est formé qu'à l'intersection d'au moins deux sections. </font><font style="vertical-align: inherit;">Plus le niveau d'eau est élevé, plus les sites doivent traverser pour créer des terres. </font><font style="vertical-align: inherit;">Par conséquent, avec la montée des eaux, la terre devient plus chaotique. </font><font style="vertical-align: inherit;">En outre, lorsque davantage de parcelles sont nécessaires, il est plus probable qu'elles se recoupent sur des terres déjà existantes, en raison des montagnes qui seront plus communes et des terres plates moins probables, comme dans le cas de l'utilisation de parcelles plus petites.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c39/f02/abf/c39f02abf2bfa93f01395208da92ae9a.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/01f/4e2/5a901f4e2785456e0784f33508be4ede.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/863/816/cc1/863816cc19c0fd7cbf172905962970d9.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd0/412/190/fd041219043df072443b00d6799f3946.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les niveaux d'eau sont de 2 à 5, les sushis sont toujours à 50%. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mouvement vertical </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jusqu'à présent, nous avons élevé les parcelles d'un niveau à la fois, mais nous n'avons pas à nous limiter à cela. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sites élevés </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que chaque section augmente la hauteur de ses cellules d'un niveau, des coupures peuvent se produire. </font><font style="vertical-align: inherit;">Cela se produit lorsque les bords de deux sections se touchent. </font><font style="vertical-align: inherit;">Cela peut créer des falaises isolées, mais les longues lignes de falaise seront rares. </font><font style="vertical-align: inherit;">Nous pouvons augmenter la fréquence de leur apparition en augmentant la hauteur de l'intrigue de plus d'un pas. </font><font style="vertical-align: inherit;">Mais cela ne doit être fait que pour une certaine proportion de sites. </font><font style="vertical-align: inherit;">Si toutes les zones montent haut, il sera très difficile de se déplacer le long du terrain. </font><font style="vertical-align: inherit;">Rendons donc ce paramètre personnalisable à l'aide d'un champ de probabilité avec une valeur par défaut de 0,25.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> highRiseProbability = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/485/8d7/cb64858d7531bb31842aebdd49b68304.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La probabilité d'une forte augmentation des cellules. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que nous puissions utiliser n'importe quelle augmentation de hauteur pour les zones élevées, cela devient rapidement incontrôlable. </font><font style="vertical-align: inherit;">La différence de hauteur 2 crée déjà des falaises, donc cela suffit. </font><font style="vertical-align: inherit;">Comme vous pouvez sauter une hauteur égale au niveau de l'eau, nous devons changer la façon dont nous déterminons si une cellule est devenue une terre. </font><font style="vertical-align: inherit;">Si elle était en dessous du niveau de l'eau, et maintenant elle est au même niveau ou plus, alors nous avons créé une nouvelle cellule terrestre.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rise = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; highRiseProbability ? <span class="hljs-number"><span class="hljs-number">2</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (size &lt; chunkSize &amp;&amp; searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalElevation = current.Elevation; current.Elevation = originalElevation + rise; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( originalElevation &lt; waterLevel &amp;&amp; current.Elevation &gt;= waterLevel &amp;&amp; --budget == <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } size += <span class="hljs-number"><span class="hljs-number">1</span></span>; … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b31/8c1/ea5/b318c1ea557ced17d2cb0d9a951bcfc3.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ba/353/78b/4ba35378bc60e74b624e136b90a4a7eb.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea3/8ac/b0a/ea38acb0a5cf12835c2ba177e41d6178.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/018/0df/bd9/0180dfbd9869a0d0e0d5a1712af34fb3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les probabilités d'une forte augmentation de la hauteur sont de 0,25, 0,50, 0,75 et 1.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abaisser le terrain </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La terre ne monte pas toujours, parfois elle tombe. </font><font style="vertical-align: inherit;">Lorsque la terre tombe suffisamment bas, l'eau la remplit et elle est perdue. </font><font style="vertical-align: inherit;">Jusqu'à présent, nous ne faisons pas cela. </font><font style="vertical-align: inherit;">Comme nous ne faisons que pousser les zones vers le haut, le terrain ressemble généralement à un ensemble de zones plutôt rondes mélangées. </font><font style="vertical-align: inherit;">Si nous abaissons parfois la zone, nous obtenons des formes plus variées.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e4/95e/d81/9e495ed818dfffc39e5a238f273c8c5b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grande carte sans sushi coulé. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons contrôler la fréquence de l'affaissement des terres en utilisant un autre champ de probabilité. </font><font style="vertical-align: inherit;">Étant donné que l'abaissement peut détruire des terres, la probabilité d'abaissement doit toujours être inférieure à la probabilité d'augmenter. </font><font style="vertical-align: inherit;">Sinon, cela peut prendre beaucoup de temps pour obtenir le bon pourcentage de terres. </font><font style="vertical-align: inherit;">Par conséquent, utilisons une probabilité d'abaissement maximale de 0,4 avec une valeur par défaut de 0,2.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 0.4f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sinkProbability = <span class="hljs-number"><span class="hljs-number">0.2f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a11/997/e82/a11997e824700a045e9faaedaafeb121.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Probabilité d'abaissement. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'abaissement du site est similaire à l'augmentation, avec quelques différences. </font><font style="vertical-align: inherit;">Par conséquent, nous dupliquons la méthode </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et changeons son nom en </font></font><code>SinkTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Au lieu de déterminer l'ampleur de l'augmentation, nous avons besoin d'une valeur d'abaissement qui peut utiliser la même logique. </font><font style="vertical-align: inherit;">Dans le même temps, des comparaisons pour vérifier si nous avons traversé la surface de l'eau doivent être retournées. </font><font style="vertical-align: inherit;">De plus, lors de l'abaissement du relief, nous ne sommes pas limités à la somme des cellules. </font><font style="vertical-align: inherit;">Au lieu de cela, chaque cellule de sushi perdue renvoie le montant dépensé, nous l'augmentons donc et continuons à travailler.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SinkTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> budget</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sink = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; highRiseProbability ? <span class="hljs-number"><span class="hljs-number">2</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (size &lt; chunkSize &amp;&amp; searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalElevation = current.Elevation; current.Elevation = originalElevation - sink; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( originalElevation &gt;= waterLevel &amp;&amp; current.Elevation &lt; waterLevel <span class="hljs-comment"><span class="hljs-comment">// &amp;&amp; --budget == 0 ) { // break; budget += 1; } size += 1; … } searchFrontier.Clear(); return budget; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, à chaque itération à l'intérieur, </font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous devons soit baisser, soit élever le terrain, selon la probabilité d'abaissement.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; sinkProbability) { landBudget = SinkTerrain(chunkSize, landBudget); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { landBudget = RaiseTerrain(chunkSize, landBudget); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6b/c5e/762/d6bc5e76274e4aa9c8a692f90fde3646.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2f/8ae/3e3/c2f8ae3e3a4b814b6ae954d40225149e.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e3/f5d/461/1e3f5d461421feddbb145d4e1d56c000.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33b/39d/462/33b39d462682688fc2a8094556e4fc91.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La probabilité de chute est de 0,1, 0,2, 0,3 et 0,4.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hauteur limite </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au stade actuel, nous pouvons potentiellement chevaucher de nombreuses sections, parfois avec plusieurs augmentations de hauteur, dont certaines peuvent descendre puis remonter. </font><font style="vertical-align: inherit;">Dans le même temps, nous pouvons créer des hauteurs très élevées, et parfois très basses, en particulier lorsqu'un pourcentage élevé de terrain est nécessaire.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f3f/c2e/359/f3fc2e359db04b4411f2bcd06b81888b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Énormes hauteurs à 90% du terrain. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour limiter la hauteur, ajoutons un minimum et un maximum personnalisés. </font><font style="vertical-align: inherit;">Un minimum raisonnable se situera entre −4 et 0, et un maximum acceptable peut être compris entre 6 et 10. </font><font style="vertical-align: inherit;">Laissez les valeurs par défaut être -2 et 8. Lorsque vous modifiez manuellement la carte, elles seront en dehors de la limite acceptable, vous pouvez donc changer le curseur de l'interface utilisateur de l'éditeur ou le laisser tel quel.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(-4, 0)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationMinimum = <span class="hljs-number"><span class="hljs-number">-2</span></span>; [Range(<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationMaximum = <span class="hljs-number"><span class="hljs-number">8</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bcb/20b/efc/bcb20befc496cd2c5bffbc94b0a9d267.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hauteurs minimum et maximum. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous devons nous assurer que la hauteur ne dépasse pas le maximum autorisé. </font><font style="vertical-align: inherit;">Cela peut être fait en vérifiant si les cellules actuelles sont trop élevées. </font><font style="vertical-align: inherit;">Si c'est le cas, nous les ignorons sans modifier la hauteur et ajouter leurs voisins. </font><font style="vertical-align: inherit;">Cela conduira au fait que les zones terrestres éviteront les zones qui ont atteint une hauteur maximale et se développeront autour d'elles.</font></font><br><br><pre> <code class="cs hljs"> HexCell current = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalElevation = current.Elevation; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newElevation = originalElevation + rise; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newElevation &gt; elevationMaximum) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } current.Elevation = newElevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( originalElevation &lt; waterLevel &amp;&amp; newElevation &gt;= waterLevel &amp;&amp; --budget == <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } size += <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faites de même à l'intérieur </font></font><code>SinkTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais pour une hauteur minimale.</font></font><br><br><pre> <code class="cs hljs"> HexCell current = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalElevation = current.Elevation; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newElevation = current.Elevation - sink; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newElevation &lt; elevationMinimum) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } current.Elevation = newElevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( originalElevation &gt;= waterLevel &amp;&amp; newElevation &lt; waterLevel ) { budget += <span class="hljs-number"><span class="hljs-number">1</span></span>; } size += <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4af/cbe/339/4afcbe339d0d697779ff0649f6c2c125.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hauteur limitée avec 90% de terrain.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Préservation de l'altitude négative </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À ce stade, le code de sauvegarde et de chargement ne peut pas gérer les hauteurs négatives car nous stockons la hauteur en octets. </font><font style="vertical-align: inherit;">Un nombre négatif est converti lorsqu'il est enregistré en un grand positif. </font><font style="vertical-align: inherit;">Par conséquent, lors de l'enregistrement et du chargement de la carte générée, des cartes très hautes peuvent apparaître à la place des cellules sous-marines d'origine. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons ajouter la prise en charge des hauteurs négatives en la stockant sous forme d'entier et non d'octet. </font><font style="vertical-align: inherit;">Cependant, nous n'avons toujours pas besoin de prendre en charge plusieurs niveaux de hauteur. </font><font style="vertical-align: inherit;">De plus, nous pouvons compenser la valeur stockée en ajoutant 127. Cela nous permettra de stocker correctement les hauteurs dans la plage −127–128 dans un octet. </font><font style="vertical-align: inherit;">Changez en </font></font><code>HexCell.Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conséquence.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)terrainTypeIndex); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(elevation + <span class="hljs-number"><span class="hljs-number">127</span></span>)); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisque nous avons changé la façon dont nous enregistrons les données cartographiques, nous les augmentons </font></font><code>SaveLoadMenu.mapFileVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à 4.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapFileVersion = <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et enfin, changez-le </font></font><code>HexCell.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour qu'il soustrait 127 des hauteurs chargées à partir des fichiers de la version 4.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadByte(); ShaderData.RefreshTerrain(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); elevation = reader.ReadByte(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>) { elevation -= <span class="hljs-number"><span class="hljs-number">127</span></span>; } … }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Recréer la même carte </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant créer une grande variété de cartes. </font><font style="vertical-align: inherit;">Lors de la génération de chaque nouveau résultat sera aléatoire. </font><font style="vertical-align: inherit;">Nous pouvons contrôler à l'aide des options de configuration uniquement les caractéristiques de la carte, mais pas la forme la plus précise. </font><font style="vertical-align: inherit;">Mais parfois, nous devons recréer exactement la même carte. </font><font style="vertical-align: inherit;">Par exemple, pour partager une belle carte avec un ami ou recommencer après l'avoir modifiée manuellement. </font><font style="vertical-align: inherit;">Il est également utile dans le processus de développement du jeu, alors ajoutons cette fonctionnalité.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Utilisation de semences </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour rendre le processus de génération de carte imprévisible, nous utilisons </font></font><code>Random.Range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>Random.value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pour obtenir à nouveau la même séquence pseudo-aléatoire de nombres, vous devez utiliser la même valeur de départ. </font><font style="vertical-align: inherit;">Nous avons déjà adopté une approche similaire auparavant, en </font></font><code>HexMetrics.InitializeHashGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il enregistre d'abord l'état actuel du générateur de nombres initialisé avec une valeur de départ spécifique, puis restaure son état d'origine. </font><font style="vertical-align: inherit;">Nous pouvons utiliser la même approche pour </font></font><code>HexMapGenerator.GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous pouvons à nouveau nous souvenir de l'ancien état et le restaurer après l'achèvement, afin de ne pas interférer avec quoi que ce soit d'autre qui utilise </font></font><code>Random</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { Random.State originalRandomState = Random.state; … Random.state = originalRandomState; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, nous devons mettre à disposition la graine utilisée pour générer la dernière carte. </font><font style="vertical-align: inherit;">Cela se fait à l'aide d'un champ entier commun.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> seed;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41d/3b5/538/41d3b553898698698636b6bada081aa6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Afficher la graine. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous avons besoin de la valeur de départ pour initialiser </font></font><code>Random</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pour créer des cartes aléatoires, vous devez utiliser une graine aléatoire. </font><font style="vertical-align: inherit;">L'approche la plus simple consiste à utiliser une valeur de départ arbitraire pour générer </font></font><code>Random.Range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pour que cela n'affecte pas l'état aléatoire initial, nous devons le faire après l'avoir enregistré.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { Random.State originalRandomState = Random.state; seed = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue); Random.InitState(seed); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depuis la fin, nous restaurons un état aléatoire, si nous générons immédiatement une autre carte, nous obtenons ainsi la même valeur de départ. </font><font style="vertical-align: inherit;">De plus, nous ne savons pas comment l'état aléatoire initial a été initialisé. </font><font style="vertical-align: inherit;">Par conséquent, bien qu'il puisse servir de point de départ arbitraire, nous avons besoin de quelque chose de plus pour le randomiser à chaque appel.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il existe différentes façons d'initialiser des générateurs de nombres aléatoires. </font><font style="vertical-align: inherit;">Dans ce cas, vous pouvez simplement combiner plusieurs valeurs arbitraires qui varient sur une large plage, c'est-à-dire que la probabilité de recréer la même carte sera faible. </font><font style="vertical-align: inherit;">Par exemple, nous utilisons les 32 bits inférieurs de l'heure système, exprimés en cycles, plus le temps d'exécution actuel de l'application. </font><font style="vertical-align: inherit;">Combinez ces valeurs à l'aide de l'opération OU exclusive au niveau du bit afin que le résultat ne soit pas très grand.</font></font><br><br><pre> <code class="cs hljs"> seed = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue); seed ^= (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)System.DateTime.Now.Ticks; seed ^= (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Time.unscaledTime; Random.InitState(seed);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le nombre résultant peut être négatif, ce qui pour une graine de valeur publique n'est pas très joli. </font><font style="vertical-align: inherit;">Nous pouvons le rendre strictement positif en utilisant un masquage au niveau du bit avec une valeur entière maximale qui réinitialisera le bit de signe.</font></font><br><br><pre> <code class="cs hljs"> seed ^= (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Time.unscaledTime; seed &amp;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; Random.InitState(seed);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Graine réutilisable </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous générons toujours des cartes aléatoires, mais maintenant nous pouvons voir quelle valeur de graine a été utilisée pour chacune d'elles. </font><font style="vertical-align: inherit;">Pour recréer à nouveau la même carte, nous devons ordonner au générateur d'utiliser à nouveau la même valeur de départ, plutôt que d'en créer une nouvelle. </font><font style="vertical-align: inherit;">Nous allons le faire en ajoutant un commutateur à l'aide d'un champ booléen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useFixedSeed;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/200/4c6/eed/2004c6eed8c2244bdfe660bf477d2fa3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Possibilité d'utiliser une graine constante. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si une graine constante est sélectionnée, nous sautons simplement la génération de la nouvelle graine </font></font><code>GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si nous ne modifions pas manuellement le champ de départ, le résultat sera à nouveau la même carte.</font></font><br><br><pre> <code class="cs hljs"> Random.State originalRandomState = Random.state; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!useFixedSeed) { seed = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue); seed ^= (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)System.DateTime.Now.Ticks; seed ^= (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Time.time; seed &amp;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } Random.InitState(seed);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons copier la valeur de départ de la carte que nous aimons et la sauvegarder quelque part, afin de la générer à nouveau à l'avenir. </font><font style="vertical-align: inherit;">N'oubliez pas que nous n'obtiendrons la même carte que si nous utilisons exactement les mêmes paramètres de générateur, c'est-à-dire la même taille de carte, ainsi que toutes les autres options de configuration. </font><font style="vertical-align: inherit;">Même un petit changement dans ces probabilités peut créer une carte complètement différente. </font><font style="vertical-align: inherit;">Par conséquent, en plus de la graine, nous devons nous souvenir de tous les paramètres.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ff/cd2/279/7ffcd2279b4dd882db924d8e1fc61d0e.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/486/6db/156/4866db15628d75936b7e19fa4841f2f5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grandes cartes avec des valeurs de départ 0 et 929396788, paramètres standard. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr427003/">https://habr.com/ru/post/fr427003/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr426991/index.html">Startup Digest: 10 événements IT à venir à Moscou</a></li>
<li><a href="../fr426993/index.html">Dois-je apprendre le C pour comprendre le fonctionnement d'un ordinateur?</a></li>
<li><a href="../fr426995/index.html">Le recyclage nuit aux produits et aux employés</a></li>
<li><a href="../fr426997/index.html">Comment créer des formes personnalisées à l'aide de MaterialShapeDrawable</a></li>
<li><a href="../fr426999/index.html">Suivre les tendances ou évoluer vers RxJava et LiveData</a></li>
<li><a href="../fr427005/index.html">Développeurs d'IA - le métier de millionnaire?</a></li>
<li><a href="../fr427009/index.html">"Marche" d'un électron: manipulations avec une charge à l'intérieur de la structure des liaisons insaturées</a></li>
<li><a href="../fr427011/index.html">Mon "Bonjour tout le monde!" sur FPGA ou la prochaine version de UART</a></li>
<li><a href="../fr427013/index.html">Face à face NeoQUEST-2018: rappelez-vous comment c'était</a></li>
<li><a href="../fr427015/index.html">Pourquoi les centres de données intelligents commerciaux ont-ils besoin de PDU intelligentes?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>