<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ΩüèΩ üçî üßôüèº Cartes hexagonales dans Unity: brouillard de guerre, recherche cartographique, g√©n√©ration proc√©durale üë©üèæ‚Äçü§ù‚Äçüë®üèº ü•ñ üôÖ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parties 1-3: maillage, couleurs et hauteurs de cellule 

 Parties 4-7: bosses, rivi√®res et routes 

 Parties 8-11: eau, reliefs et remparts 

 Parties...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cartes hexagonales dans Unity: brouillard de guerre, recherche cartographique, g√©n√©ration proc√©durale</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427003/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 1-3: maillage, couleurs et hauteurs de cellule</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 4-7: bosses, rivi√®res et routes</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 8-11: eau, reliefs et remparts</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 12-15: sauvegarde et chargement, textures, distances</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 16-19: trouver le chemin, √©quipes de joueurs, animations</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 20-23: Brouillard de guerre, recherche cartographique, g√©n√©ration proc√©durale</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 24-27: cycle de l'eau, √©rosion, biomes, carte cylindrique</a> <br><br><h1>  Partie 20: le brouillard de la guerre </h1><br><ul><li>  Enregistrez les donn√©es de cellule dans la texture. </li><li>  Modifiez les types de relief sans triangulation. </li><li>  Nous suivons la visibilit√©. </li><li>  Obscurcissez tout ce qui est invisible. </li></ul><br>  Dans cette partie, nous ajouterons l'effet de brouillard de guerre √† la carte. <br><br>  Maintenant, la s√©rie sera cr√©√©e sur Unity 2017.1.0. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/716/b6b/8a9/716b6b8a9d024dc87b2d645b5d4bdbb6.jpg"></div><br>  <i>Maintenant, nous voyons que nous pouvons et ne pouvons pas voir.</i> <br><a name="habracut"></a><br><h2>  Donn√©es de cellule dans le shader </h2><br>  De nombreux jeux de strat√©gie utilisent le concept du brouillard de guerre.  Cela signifie que la vision du joueur est limit√©e.  Il ne peut voir que ce qui est proche de ses unit√©s ou de sa zone contr√¥l√©e.  Bien que nous puissions voir le soulagement, nous ne savons pas ce qui se passe l√†-bas.  Habituellement, le terrain invisible est rendu plus sombre.  Pour r√©aliser cela, nous devons suivre la visibilit√© de la cellule et la rendre en cons√©quence. <br><br>  Le moyen le plus simple de modifier l'apparence des cellules masqu√©es consiste √† ajouter une m√©trique de visibilit√© aux donn√©es de maillage.  Cependant, en m√™me temps, nous devrons commencer une nouvelle triangulation en relief avec un changement de visibilit√©.  C'est une mauvaise d√©cision car la visibilit√© change constamment pendant le match. <br><br>  La technique de rendu sur la topographie d'une surface translucide est souvent utilis√©e, qui masque partiellement les cellules invisibles au joueur.  Cette m√©thode convient aux terrains relativement plats en combinaison avec un angle de vision limit√©.  Mais comme notre terrain peut contenir des hauteurs et des objets tr√®s variables qui peuvent √™tre vus sous diff√©rents angles, nous avons besoin pour cela d'un maillage tr√®s d√©taill√© qui correspond √† la forme du terrain.  Cette m√©thode sera plus co√ªteuse que l'approche la plus simple mentionn√©e ci-dessus. <br><br>  Une autre approche consiste √† transf√©rer les donn√©es des cellules vers le shader lors du rendu s√©par√©ment du maillage en relief.  Cela nous permettra d'effectuer une triangulation une seule fois.  Les donn√©es des cellules peuvent √™tre transf√©r√©es en utilisant la texture.  Changer la texture est un processus beaucoup plus simple que de trianguler le terrain.  De plus, l'ex√©cution de plusieurs √©chantillons de texture suppl√©mentaires est plus rapide que le rendu d'une seule couche translucide. <br><br><div class="spoiler">  <b class="spoiler_title">Qu'en est-il de l'utilisation de tableaux de shaders?</b> <div class="spoiler_text">  Vous pouvez √©galement transf√©rer des donn√©es de cellule vers le shader √† l'aide d'un tableau de vecteurs.  Cependant, les tableaux de shaders ont une limite de taille, mesur√©e en milliers d'octets, et les textures peuvent contenir des millions de pixels.  Pour prendre en charge de grandes cartes, nous utiliserons des textures. </div></div><br><h3>  Gestion des donn√©es cellulaires </h3><br>  Nous avons besoin d'un moyen de contr√¥ler la texture contenant les donn√©es des cellules.  Cr√©ons un nouveau composant <code>HexCellShaderData</code> qui fera cela. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCellShaderData</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { Texture2D cellTexture; }</code> </pre> <br>  Lors de la cr√©ation ou du chargement d'une nouvelle carte, nous devons cr√©er une nouvelle texture avec la bonne taille.  Par cons√©quent, nous y ajoutons une m√©thode d'initialisation qui cr√©e une texture.  Nous utilisons une texture RGBA sans textures de mip et espace colorim√©trique lin√©aire.  Nous n'avons pas besoin de m√©langer les donn√©es des cellules, nous utilisons donc le filtrage ponctuel.  De plus, les donn√©es ne doivent pas √™tre r√©duites.  Chaque pixel de la texture contiendra les donn√©es d'une cellule. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { cellTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D( x, z, TextureFormat.RGBA32, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); cellTexture.filterMode = FilterMode.Point; cellTexture.wrapMode = TextureWrapMode.Clamp; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">La taille de la texture doit-elle correspondre √† la taille de la carte?</b> <div class="spoiler_text">  Non, il suffit d'avoir suffisamment de pixels pour contenir toutes les cellules.  Avec une correspondance exacte avec la taille de la carte, une texture avec des tailles qui ne sont pas des puissances de deux (non-puissance de deux, NPOT) sera tr√®s probablement cr√©√©e, et ce format de texture n'est pas le plus efficace.  Bien que nous puissions configurer le code pour qu'il fonctionne avec des textures de la taille d'une puissance de deux, il s'agit d'une optimisation mineure, qui complique l'acc√®s aux donn√©es des cellules. </div></div><br>  En fait, nous n'avons pas √† cr√©er une nouvelle texture chaque fois que nous cr√©ons une nouvelle carte.  Il suffit de redimensionner la texture si elle existe d√©j√†.  Nous n'avons m√™me pas besoin de v√©rifier si nous avons d√©j√† la bonne taille, car <code>Texture2D.Resize</code> est assez intelligent pour le faire pour nous. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellTexture) { cellTexture.Resize(x, z); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cellTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D( cellCountX, cellCountZ, TextureFormat.RGBA32, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); cellTexture.filterMode = FilterMode.Point; cellTexture.wrapMode = TextureWrapMode.Clamp; } }</code> </pre> <br>  Au lieu d'appliquer des donn√©es de cellule un pixel √† la fois, nous utilisons un tampon de couleur et appliquons les donn√©es de toutes les cellules √† la fois.  Pour ce faire, nous utiliserons le tableau <code>Color32</code> .  Si n√©cessaire, nous cr√©erons une nouvelle instance de tableau √† la fin de <code>Initialize</code> .  Si nous avons d√©j√† un tableau de la bonne taille.  puis nous effa√ßons son contenu. <br><br><pre> <code class="cs hljs"> Texture2D cellTexture; Color32[] cellTextureData; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellTextureData == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || cellTextureData.Length != x * z) { cellTextureData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color32[x * z]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellTextureData.Length; i++) { cellTextureData[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color32(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); } } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Qu'est-ce que color32?</b> <div class="spoiler_text">  Les textures RGBA non compress√©es standard contiennent des pixels de quatre octets.  Chacun des quatre canaux de couleur re√ßoit un octet, c'est-√†-dire qu'il a 256 valeurs possibles.  Lorsque vous utilisez la structure Unity <code>Color</code> , ses composants √† virgule flottante dans l'intervalle 0‚Äì1 sont convertis en octets dans l'intervalle 0‚Äì255.  Lors de l'√©chantillonnage, le GPU effectue la transformation inverse. <br><br>  La structure <code>Color32</code> fonctionne directement avec les octets, donc ils prennent moins d'espace et ne n√©cessitent pas de conversion, ce qui augmente l'efficacit√© de leur utilisation.  √âtant donn√© que nous stockons des donn√©es de cellule au lieu de couleurs, il sera plus logique de travailler directement avec des donn√©es de texture brutes et non avec <code>Color</code> . </div></div><br>  <code>HexGrid</code> doit g√©rer la cr√©ation et l'initialisation de ces cellules dans le shader.  Par cons√©quent, nous y ajouterons un champ <code>cellShaderData</code> et cr√©erons un composant dans <code>Awake</code> . <br><br><pre> <code class="cs hljs"> HexCellShaderData cellShaderData; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; cellShaderData = gameObject.AddComponent&lt;HexCellShaderData&gt;(); CreateMap(cellCountX, cellCountZ); }</code> </pre> <br>  Lors de la cr√©ation d'une nouvelle carte, <code>cellShaderData</code> doit √©galement √™tre <code>cellShaderData</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ cellCountX = x; cellCountZ = z; chunkCountX = cellCountX / HexMetrics.chunkSizeX; chunkCountZ = cellCountZ / HexMetrics.chunkSizeZ; cellShaderData.Initialize(cellCountX, cellCountZ); CreateChunks(); CreateCells(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3>  Modification des donn√©es de cellule </h3><br>  Jusqu'√† pr√©sent, lors de la modification des propri√©t√©s d'une cellule, il √©tait n√©cessaire de mettre √† jour un ou plusieurs fragments, mais maintenant il peut √™tre n√©cessaire de mettre √† jour les donn√©es des cellules.  Cela signifie que les cellules doivent avoir un lien vers les donn√©es de cellule dans le shader.  Pour ce faire, ajoutez une propri√©t√© √† <code>HexCell</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCellShaderData ShaderData { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br>  Dans <code>HexGrid.CreateCell</code> nous assignerons un composant de donn√©es shader √† cette propri√©t√©. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ HexCell cell = cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab); cell.transform.localPosition = position; cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); cell.ShaderData = cellShaderData; ‚Ä¶ }</code> </pre> <br>  Nous pouvons maintenant demander aux cellules de mettre √† jour leurs donn√©es de shader.  Bien que nous ne surveillions pas la visibilit√©, nous pouvons utiliser des donn√©es de shader pour autre chose.  Le type de relief de la cellule d√©termine la texture utilis√©e pour la rendre.  Cela n'affecte pas la g√©om√©trie de la cellule, nous pouvons donc stocker l'indice de type d'√©l√©vation dans les donn√©es de la cellule, et non dans les donn√©es du maillage.  Cela nous permettra de nous d√©barrasser du besoin de triangulation lors du changement du type de relief de la cellule. <br><br>  Ajoutez une m√©thode <code>HexCellShaderData</code> √† <code>RefreshTerrain</code> pour simplifier cette t√¢che pour une cellule sp√©cifique.  Laissons cette m√©thode vide pour l'instant. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br>  Modifiez <code>HexCell.TerrainTypeIndex</code> afin qu'il <code>HexCell.TerrainTypeIndex</code> cette m√©thode et n'ordonne pas de mettre √† jour les fragments. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TerrainTypeIndex { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> terrainTypeIndex; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (terrainTypeIndex != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { terrainTypeIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Refresh(); ShaderData.RefreshTerrain(this); } } }</span></span></code> </pre> <br>  Nous l'appellerons √©galement dans <code>HexCell.Load</code> apr√®s avoir re√ßu le type de topographie de cellule. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadByte(); ShaderData.RefreshTerrain(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); elevation = reader.ReadByte(); RefreshPosition(); ‚Ä¶ }</code> </pre> <br><h3>  Index des cellules </h3><br>  Pour changer ces cellules, nous devons conna√Ætre l'indice de la cellule.  La fa√ßon la plus simple de proc√©der consiste √† ajouter la propri√©t√© <code>Index</code> √† <code>HexCell</code> .  Il indiquera l'index de la cellule dans la liste des cellules de la carte, ce qui correspond √† son index dans les cellules donn√©es du shader. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Index { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br>  Cet index est d√©j√† dans <code>HexGrid.CreateCell</code> , il suffit donc de l'affecter √† la cellule cr√©√©e. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); cell.Index = i; cell.ShaderData = cellShaderData; ‚Ä¶ }</code> </pre> <br>  D√©sormais, <code>HexCellShaderData.RefreshTerrain</code> peut utiliser cet index pour sp√©cifier des donn√©es de cellule.  Enregistrons l'index du type d'√©l√©vation dans la composante alpha de son pixel en convertissant simplement le type en octet.  Cela supportera jusqu'√† 256 types de terrains, ce qui nous suffira. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cellTextureData[cell.Index].a = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)cell.TerrainTypeIndex; }</code> </pre> <br>  Pour appliquer des donn√©es √† une texture et les transmettre au GPU, nous devons appeler <code>Texture2D.SetPixels32</code> , puis <code>Texture2D.Apply</code> .  Comme pour les fragments, nous reporterons ces op√©rations sur <code>LateUpdate</code> afin qu'elles ne puissent √™tre effectu√©es plus d'une fois par trame, quel que soit le nombre de cellules modifi√©es. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cellTextureData[cell.Index].a = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)cell.TerrainTypeIndex; enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LateUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { cellTexture.SetPixels32(cellTextureData); cellTexture.Apply(); enabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Pour vous assurer que les donn√©es seront mises √† jour apr√®s la cr√©ation d'une nouvelle carte, activez le composant apr√®s l'initialisation. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3>  Triangulation des indices cellulaires </h3><br>  Puisque nous stockons maintenant l'indice de type d'√©l√©vation dans ces cellules, nous n'avons plus besoin de les inclure dans le processus de triangulation.  Mais pour utiliser les donn√©es de cellule, le shader doit savoir quels index utiliser.  Par cons√©quent, vous devez stocker les indices de cellule dans les donn√©es de maillage, en rempla√ßant les indices de type d'√©l√©vation.  De plus, nous avons toujours besoin du canal de couleur du maillage pour m√©langer les cellules lors de l'utilisation de ces cellules. <br><br>  Nous <code>useColors</code> champs communs obsol√®tes <code>useColors</code> et <code>useTerrainTypes</code> .  Remplacez-les par un champ <code>useCellData</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public bool useCollider, useColors, useUVCoordinates, useUV2Coordinates; // public bool useTerrainTypes; public bool useCollider, useCellData, useUVCoordinates, useUV2Coordinates;</span></span></code> </pre><br>  Nous refactorisons le changement de nom de la liste <code>cellIndices</code> en <code>cellIndices</code> .  Refactorisons √©galement les <code>colors</code> en <code>cellWeights</code> - ce nom fera mieux. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// [NonSerialized] List&lt;Vector3&gt; vertices, terrainTypes; // [NonSerialized] List&lt;Color&gt; colors; [NonSerialized] List&lt;Vector3&gt; vertices, cellIndices; [NonSerialized] List&lt;Color&gt; cellWeights; [NonSerialized] List&lt;Vector2&gt; uvs, uv2s; [NonSerialized] List&lt;int&gt; triangles;</span></span></code> </pre><br>  Modifiez <code>Clear</code> sorte que lorsque vous utilisez ces cellules, il obtienne deux listes ensemble, et non s√©par√©ment. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Clear(); vertices = ListPool&lt;Vector3&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useCellData) { cellWeights = ListPool&lt;Color&gt;.Get(); cellIndices = ListPool&lt;Vector3&gt;.Get(); } <span class="hljs-comment"><span class="hljs-comment">// if (useColors) { // colors = ListPool&lt;Color&gt;.Get(); // } if (useUVCoordinates) { uvs = ListPool&lt;Vector2&gt;.Get(); } if (useUV2Coordinates) { uv2s = ListPool&lt;Vector2&gt;.Get(); } // if (useTerrainTypes) { // terrainTypes = ListPool&lt;Vector3&gt;.Get(); // } triangles = ListPool&lt;int&gt;.Get(); }</span></span></code> </pre> <br>  Effectuez le m√™me regroupement dans <code>Apply</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.SetVertices(vertices); ListPool&lt;Vector3&gt;.Add(vertices); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useCellData) { hexMesh.SetColors(cellWeights); ListPool&lt;Color&gt;.Add(cellWeights); hexMesh.SetUVs(<span class="hljs-number"><span class="hljs-number">2</span></span>, cellIndices); ListPool&lt;Vector3&gt;.Add(cellIndices); } <span class="hljs-comment"><span class="hljs-comment">// if (useColors) { // hexMesh.SetColors(colors); // ListPool&lt;Color&gt;.Add(colors); // } if (useUVCoordinates) { hexMesh.SetUVs(0, uvs); ListPool&lt;Vector2&gt;.Add(uvs); } if (useUV2Coordinates) { hexMesh.SetUVs(1, uv2s); ListPool&lt;Vector2&gt;.Add(uv2s); } // if (useTerrainTypes) { // hexMesh.SetUVs(2, terrainTypes); // ListPool&lt;Vector3&gt;.Add(terrainTypes); // } hexMesh.SetTriangles(triangles, 0); ListPool&lt;int&gt;.Add(triangles); hexMesh.RecalculateNormals(); if (useCollider) { meshCollider.sharedMesh = hexMesh; } }</span></span></code> </pre> <br>  <code>AddTriangleColor</code> toutes les <code>AddTriangleTerrainTypes</code> <code>AddTriangleColor</code> et <code>AddTriangleTerrainTypes</code> .  Remplacez-les par les m√©thodes <code>AddTriangleCellData</code> appropri√©es, qui ajoutent des index et des pond√©rations √† la fois. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 indices, Color weights1, Color weights2, Color weights3 </span></span></span><span class="hljs-function">)</span></span> { cellIndices.Add(indices); cellIndices.Add(indices); cellIndices.Add(indices); cellWeights.Add(weights1); cellWeights.Add(weights2); cellWeights.Add(weights3); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 indices, Color weights</span></span></span><span class="hljs-function">)</span></span> { AddTriangleCellData(indices, weights, weights, weights); }</code> </pre> <br>  Faites de m√™me dans la m√©thode <code>AddQuad</code> appropri√©e. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 indices, Color weights1, Color weights2, Color weights3, Color weights4 </span></span></span><span class="hljs-function">)</span></span> { cellIndices.Add(indices); cellIndices.Add(indices); cellIndices.Add(indices); cellIndices.Add(indices); cellWeights.Add(weights1); cellWeights.Add(weights2); cellWeights.Add(weights3); cellWeights.Add(weights4); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 indices, Color weights1, Color weights2 </span></span></span><span class="hljs-function">)</span></span> { AddQuadCellData(indices, weights1, weights1, weights2, weights2); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 indices, Color weights</span></span></span><span class="hljs-function">)</span></span> { AddQuadCellData(indices, weights, weights, weights, weights); }</code> </pre> <br><h3>  Refactorisation HexGridChunk </h3><br>  √Ä ce stade, nous obtenons de nombreuses erreurs de compilation dans <code>HexGridChunk</code> qui doivent √™tre <code>HexGridChunk</code> .  Mais d'abord, par souci de coh√©rence, nous refactorisons-renommons les couleurs statiques en poids. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color weights1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color weights2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color weights3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br>  Commen√ßons par fixer <code>TriangulateEdgeFan</code> .  Il avait besoin d'un type, mais maintenant il a besoin d'un index de cellule.  <code>AddTriangleColor</code> code <code>AddTriangleColor</code> et <code>AddTriangleTerrainTypes</code> par le code <code>AddTriangleCellData</code> correspondant. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { terrain.AddTriangle(center, edge.v1, edge.v2); terrain.AddTriangle(center, edge.v2, edge.v3); terrain.AddTriangle(center, edge.v3, edge.v4); terrain.AddTriangle(center, edge.v4, edge.v5); Vector3 indices; indices.x = indices.y = indices.z = index; terrain.AddTriangleCellData(indices, weights1); terrain.AddTriangleCellData(indices, weights1); terrain.AddTriangleCellData(indices, weights1); terrain.AddTriangleCellData(indices, weights1); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights1); // terrain.AddTriangleColor(weights1); // terrain.AddTriangleColor(weights1); // terrain.AddTriangleColor(weights1); // Vector3 types; // types.x = types.y = types.z = type; // terrain.AddTriangleTerrainTypes(types); // terrain.AddTriangleTerrainTypes(types); // terrain.AddTriangleTerrainTypes(types); // terrain.AddTriangleTerrainTypes(types); }</span></span></code> </pre> <br>  Cette m√©thode est appel√©e √† plusieurs endroits.  Examinons-les et assurons-nous que l'index de la cellule y est transf√©r√©, et non le type de terrain. <br><br><pre> <code class="cs hljs"> TriangulateEdgeFan(center, e, cell.Index);</code> </pre> <br>  Vient ensuite <code>TriangulateEdgeStrip</code> .  Tout est un peu plus compliqu√© ici, mais nous utilisons la m√™me approche.  Renommez √©galement les noms des param√®tres <code>c1</code> et <code>c2</code> en <code>w1</code> et <code>w2</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color w1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index1, EdgeVertices e2, Color w2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { terrain.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); terrain.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); terrain.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); terrain.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); Vector3 indices; indices.x = indices.z = index1; indices.y = index2; terrain.AddQuadCellData(indices, w1, w2); terrain.AddQuadCellData(indices, w1, w2); terrain.AddQuadCellData(indices, w1, w2); terrain.AddQuadCellData(indices, w1, w2); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddQuadColor(c1, c2); // terrain.AddQuadColor(c1, c2); // terrain.AddQuadColor(c1, c2); // terrain.AddQuadColor(c1, c2); // Vector3 types; // types.x = types.z = type1; // types.y = type2; // terrain.AddQuadTerrainTypes(types); // terrain.AddQuadTerrainTypes(types); // terrain.AddQuadTerrainTypes(types); // terrain.AddQuadTerrainTypes(types); if (hasRoad) { TriangulateRoadSegment(e1.v2, e1.v3, e1.v4, e2.v2, e2.v3, e2.v4); } }</span></span></code> </pre> <br>  Modifiez les appels √† cette m√©thode afin que l'index de cellule leur soit transmis.  Nous gardons √©galement les noms de variables coh√©rents. <br><br><pre> <code class="cs hljs"> TriangulateEdgeStrip( m, weights1, cell.Index, e, weights1, cell.Index ); ‚Ä¶ TriangulateEdgeStrip( e1, weights1, cell.Index, e2, weights2, neighbor.Index, hasRoad ); ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color w2 = HexMetrics.TerraceLerp(weights1, weights2, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> i1 = beginCell.Index; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> i2 = endCell.Index; TriangulateEdgeStrip(begin, weights1, i1, e2, w2, i2, hasRoad); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color w1 = w2; e2 = EdgeVertices.TerraceLerp(begin, end, i); w2 = HexMetrics.TerraceLerp(weights1, weights2, i); TriangulateEdgeStrip(e1, w1, i1, e2, w2, i2, hasRoad); } TriangulateEdgeStrip(e2, w2, i1, end, weights2, i2, hasRoad); }</code> </pre> <br>  Passons maintenant aux m√©thodes d'angle.  Ces modifications sont simples, mais elles doivent √™tre effectu√©es dans une grande quantit√© de code.  Tout d'abord chez <code>TriangulateCorner</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangle(bottom, left, right); Vector3 indices; indices.x = bottomCell.Index; indices.y = leftCell.Index; indices.z = rightCell.Index; terrain.AddTriangleCellData(indices, weights1, weights2, weights3); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights1, weights2, weights3); // Vector3 types; // types.x = bottomCell.TerrainTypeIndex; // types.y = leftCell.TerrainTypeIndex; // types.z = rightCell.TerrainTypeIndex; // terrain.AddTriangleTerrainTypes(types); } features.AddWall(bottom, bottomCell, left, leftCell, right, rightCell); }</span></span></code> </pre> <br>  Venir √† <code>TriangulateCornerTerraces</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { Vector3 v3 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 v4 = HexMetrics.TerraceLerp(begin, right, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color w3 = HexMetrics.TerraceLerp(weights1, weights2, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color w4 = HexMetrics.TerraceLerp(weights1, weights3, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 indices; indices.x = beginCell.Index; indices.y = leftCell.Index; indices.z = rightCell.Index; terrain.AddTriangle(begin, v3, v4); terrain.AddTriangleCellData(indices, weights1, w3, w4); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights1, w3, w4); // terrain.AddTriangleTerrainTypes(indices); for (int i = 2; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v3; Vector3 v2 = v4; Color w1 = w3; Color w2 = w4; v3 = HexMetrics.TerraceLerp(begin, left, i); v4 = HexMetrics.TerraceLerp(begin, right, i); w3 = HexMetrics.TerraceLerp(weights1, weights2, i); w4 = HexMetrics.TerraceLerp(weights1, weights3, i); terrain.AddQuad(v1, v2, v3, v4); terrain.AddQuadCellData(indices, w1, w2, w3, w4); // terrain.AddQuadColor(w1, w2, w3, w4); // terrain.AddQuadTerrainTypes(indices); } terrain.AddQuad(v3, v4, left, right); terrain.AddQuadCellData(indices, w3, w4, weights2, weights3); // terrain.AddQuadColor(w3, w4, weights2, weights3); // terrain.AddQuadTerrainTypes(indices); }</span></span></code> </pre> <br>  Puis dans <code>TriangulateCornerTerracesCliff</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } Vector3 boundary = Vector3.Lerp( HexMetrics.Perturb(begin), HexMetrics.Perturb(right), b ); Color boundaryWeights = Color.Lerp(weights1, weights3, b); Vector3 indices; indices.x = beginCell.Index; indices.y = leftCell.Index; indices.z = rightCell.Index; TriangulateBoundaryTriangle( begin, weights1, left, weights2, boundary, boundaryWeights, indices ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, weights2, right, weights3, boundary, boundaryWeights, indices ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleCellData( indices, weights2, weights3, boundaryWeights ); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights2, weights3, boundaryColor); // terrain.AddTriangleTerrainTypes(indices); } }</span></span></code> </pre> <br>  Et un peu diff√©remment dans <code>TriangulateCornerCliffTerraces</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerCliffTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (leftCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } Vector3 boundary = Vector3.Lerp( HexMetrics.Perturb(begin), HexMetrics.Perturb(left), b ); Color boundaryWeights = Color.Lerp(weights1, weights2, b); Vector3 indices; indices.x = beginCell.Index; indices.y = leftCell.Index; indices.z = rightCell.Index; TriangulateBoundaryTriangle( right, weights3, begin, weights1, boundary, boundaryWeights, indices ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, weights2, right, weights3, boundary, boundaryWeights, indices ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleCellData( indices, weights2, weights3, boundaryWeights ); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights2, weights3, boundaryWeights); // terrain.AddTriangleTerrainTypes(indices); } }</span></span></code> </pre> <br>  Les deux m√©thodes pr√©c√©dentes utilisent le <code>TriangulateBoundaryTriangle</code> , qui n√©cessite √©galement une mise √† jour. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, Color beginWeights, Vector3 left, Color leftWeights, Vector3 boundary, Color boundaryWeights, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>)); Color w2 = HexMetrics.TerraceLerp(beginWeights, leftWeights, <span class="hljs-number"><span class="hljs-number">1</span></span>); terrain.AddTriangleUnperturbed(HexMetrics.Perturb(begin), v2, boundary); terrain.AddTriangleCellData(indices, beginWeights, w2, boundaryWeights); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(beginColor, c2, boundaryColor); // terrain.AddTriangleTerrainTypes(types); for (int i = 2; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color w1 = w2; v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, i)); w2 = HexMetrics.TerraceLerp(beginWeights, leftWeights, i); terrain.AddTriangleUnperturbed(v1, v2, boundary); terrain.AddTriangleCellData(indices, w1, w2, boundaryWeights); // terrain.AddTriangleColor(c1, c2, boundaryColor); // terrain.AddTriangleTerrainTypes(types); } terrain.AddTriangleUnperturbed(v2, HexMetrics.Perturb(left), boundary); terrain.AddTriangleCellData(indices, w2, leftWeights, boundaryWeights); // terrain.AddTriangleColor(c2, leftColor, boundaryColor); // terrain.AddTriangleTerrainTypes(types); }</span></span></code> </pre> <br>  La derni√®re m√©thode qui doit √™tre modifi√©e est <code>TriangulateWithRiver</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ terrain.AddTriangle(centerL, m.v1, m.v2); terrain.AddQuad(centerL, center, m.v2, m.v3); terrain.AddQuad(center, centerR, m.v3, m.v4); terrain.AddTriangle(centerR, m.v4, m.v5); Vector3 indices; indices.x = indices.y = indices.z = cell.Index; terrain.AddTriangleCellData(indices, weights1); terrain.AddQuadCellData(indices, weights1); terrain.AddQuadCellData(indices, weights1); terrain.AddTriangleCellData(indices, weights1); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights1); // terrain.AddQuadColor(weights1); // terrain.AddQuadColor(weights1); // terrain.AddTriangleColor(weights1); // Vector3 types; // types.x = types.y = types.z = cell.TerrainTypeIndex; // terrain.AddTriangleTerrainTypes(types); // terrain.AddQuadTerrainTypes(types); // terrain.AddQuadTerrainTypes(types); // terrain.AddTriangleTerrainTypes(types); ‚Ä¶ }</span></span></code> </pre> <br>  Pour que tout fonctionne, nous devons indiquer que nous utiliserons les donn√©es de cellule pour l'√©l√©ment enfant du relief du fragment pr√©fabriqu√©. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/919/b8c/731/919b8c7317b2aa3c06f1077eef27fe96.png"></div><br>  <i>Le relief utilise des donn√©es cellulaires.</i> <br><br>  √Ä ce stade, le maillage contient des index de cellules au lieu d'indices de type d'√©l√©vation.  Comme le shader d'√©l√©vation les interpr√®te toujours comme des indices d'√©l√©vation, nous verrons que la premi√®re cellule est rendue avec la premi√®re texture et ainsi de suite jusqu'√† ce que la derni√®re texture en relief soit atteinte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a5/a23/ce8/8a5a23ce850af789e759dde6879f93eb.png"></div><br>  <i>Utilisation d'indices de cellule comme indices de texture d'√©l√©vation.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Je ne peux pas faire fonctionner le code refactoris√©.</b>  <b class="spoiler_title">Qu'est-ce que je fais mal?</b> <div class="spoiler_text">  √Ä un moment donn√©, nous avons modifi√© une grande quantit√© de code de triangulation, il y a donc une forte probabilit√© d'erreurs ou d'oubli.  Si vous ne trouvez pas l'erreur, essayez de t√©l√©charger le package √† partir de cette section et extrayez les fichiers appropri√©s.  Vous pouvez les importer dans un projet distinct et les comparer avec votre propre code. </div></div><br><h3>  Transf√©rer des donn√©es de cellule vers un shader </h3><br>  Pour utiliser ces cellules, le shader de terrain doit y avoir acc√®s.  Cela peut √™tre impl√©ment√© via la propri√©t√© shader.  Cela n√©cessitera <code>HexCellShaderData</code> d√©finir la propri√©t√© mat√©rielle du relief.  Ou nous pouvons rendre la texture de ces cellules globalement visible √† tous les shaders.  C'est pratique car nous en avons besoin dans plusieurs shaders, nous allons donc utiliser cette approche. <br><br>  Apr√®s avoir cr√©√© la texture de cellule, appelez la m√©thode statique <code>Shader.SetGlobalTexture</code> pour la rendre globalement visible en tant que <em>_HexCellData</em> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cellTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D( x, z, TextureFormat.RGBA32, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); cellTexture.filterMode = FilterMode.Point; cellTexture.wrapMode = TextureWrapMode.Clamp; Shader.SetGlobalTexture(<span class="hljs-string"><span class="hljs-string">"_HexCellData"</span></span>, cellTexture); } ‚Ä¶ }</code> </pre> <br>  Lorsque vous utilisez la propri√©t√© shader, Unity met la taille de texture √† la disposition du shader via la variable <em>textureName_TexelSize</em> .  Il s'agit d'un vectoriseur √† quatre composants contenant des valeurs qui sont inverses √† la largeur et √† la hauteur, ainsi qu'√† la largeur et √† la hauteur elles-m√™mes.  Mais lors de la d√©finition de la texture globale, cela n'est pas effectu√©.  Par cons√©quent, nous le ferons nous-m√™mes en utilisant le <code>Shader.SetGlobalVector</code> apr√®s avoir cr√©√© ou redimensionn√© la texture. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cellTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D( x, z, TextureFormat.RGBA32, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); cellTexture.filterMode = FilterMode.Point; cellTexture.wrapMode = TextureWrapMode.Clamp; Shader.SetGlobalTexture(<span class="hljs-string"><span class="hljs-string">"_HexCellData"</span></span>, cellTexture); } Shader.SetGlobalVector( <span class="hljs-string"><span class="hljs-string">"_HexCellData_TexelSize"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector4(<span class="hljs-number"><span class="hljs-number">1f</span></span> / x, <span class="hljs-number"><span class="hljs-number">1f</span></span> / z, x, z) );</code> </pre> <br><h3>  Acc√®s aux donn√©es du shader </h3><br>  Cr√©ez un nouveau fichier d'inclusion de shader dans le dossier des mat√©riaux appel√© <em>HexCellData</em> .  √Ä l'int√©rieur, nous d√©finissons des variables pour obtenir des informations sur la texture et la taille de ces cellules.  Nous cr√©ons √©galement une fonction pour obtenir les donn√©es de cellule pour les donn√©es de maillage de sommet donn√©es. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">sampler2D</span></span> _HexCellData; <span class="hljs-attribute"><span class="hljs-attribute">float4</span></span> _HexCellData_TexelSize; <span class="hljs-attribute"><span class="hljs-attribute">float4</span></span> GetCellData (appdata_full v) { }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a64/604/dbc/a64604dbc7d3ad5ff1e1578bd0c84eec.png"></div><br>  <i>Nouveau fichier d'inclusion.</i> <br><br>  Les indices de cellule sont stock√©s dans <code>v.texcoord2</code> , comme c'√©tait le cas avec les types de terrain.  Commen√ßons par le premier index - <code>v.texcoord2.x</code> .  Malheureusement, nous ne pouvons pas utiliser directement l'index pour √©chantillonner la texture de ces cellules.  Nous devrons le convertir en coordonn√©es UV. <br><br>  La premi√®re √©tape de la cr√©ation de la coordonn√©e U consiste √† diviser l'indice de cellule par la largeur de la texture.  Nous pouvons le faire en le multipliant par <code>_HexCellData_TexelSize.x</code> . <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">appdata_full v</span></span></span><span class="hljs-function">)</span></span> { float2 uv; uv.x = v.texcoord2.x * _HexCellData_TexelSize.x; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le r√©sultat sera un nombre sous la forme ZU, o√π Z est l'index de ligne et U est la coordonn√©e de la cellule U. </font><font style="vertical-align: inherit;">Nous pouvons extraire la cha√Æne en arrondissant le nombre vers le bas puis en le soustrayant du nombre pour obtenir la coordonn√©e U.</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v) { float2 uv; uv.x = v.texcoord2.x * _HexCellData_TexelSize.x; <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> = floor(uv.x); uv.x -= <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La coordonn√©e V divise la ligne par la hauteur de la texture. </font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v) { float2 uv; uv.x = v.texcoord2.x * _HexCellData_TexelSize.x; <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> = floor(uv.x); uv.x -= <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>; uv.y = <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> * _HexCellData_TexelSize.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisque nous √©chantillonnons la texture, nous devons utiliser les coordonn√©es au centre des pixels, pas √† leurs bords. </font><font style="vertical-align: inherit;">De cette fa√ßon, nous garantissons que les bons pixels sont √©chantillonn√©s. </font><font style="vertical-align: inherit;">Par cons√©quent, apr√®s avoir divis√© par la taille de la texture, ajoutez ¬Ω.</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v) { float2 uv; uv.x = (v.texcoord2.x + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.x; <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> = floor(uv.x); uv.x -= <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>; uv.y = (<span class="hljs-keyword"><span class="hljs-keyword">row</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela nous donne les coordonn√©es UV correctes pour l'indice de la premi√®re cellule stock√©e dans les donn√©es de sommet. </font><font style="vertical-align: inherit;">Mais en plus, nous pouvons avoir jusqu'√† trois indices diff√©rents. </font><font style="vertical-align: inherit;">Par cons√©quent, nous allons le faire </font></font><code>GetCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fonctionner pour n'importe quel index. </font><font style="vertical-align: inherit;">Ajoutez-y un param√®tre entier </font></font><code>index</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que nous utiliserons pour acc√©der √† la composante vectorielle avec l'index de cellule.</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float2 uv; uv.x = (v.texcoord2[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>] + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.x; <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> = floor(uv.x); uv.x -= <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>; uv.y = (<span class="hljs-keyword"><span class="hljs-keyword">row</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que nous avons toutes les coordonn√©es n√©cessaires pour ces cellules, nous pouvons √©chantillonner </font></font><code>_HexCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Puisque nous √©chantillonnons la texture dans le programme vertex, nous devons dire explicitement au shader quelle texture de mip utiliser. </font><font style="vertical-align: inherit;">Cela peut √™tre fait en utilisant une fonction </font></font><code>tex2Dlod</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui n√©cessite les coordonn√©es de quatre textures. </font><font style="vertical-align: inherit;">Puisque ces cellules n'ont pas de textures mip, nous attribuons des valeurs nulles aux coordonn√©es suppl√©mentaires.</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float2 uv; uv.x = (v.texcoord2[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>] + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.x; <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> = floor(uv.x); uv.x -= <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>; uv.y = (<span class="hljs-keyword"><span class="hljs-keyword">row</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> data = tex2Dlod(_HexCellData, <span class="hljs-type"><span class="hljs-type">float4</span></span>(uv, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le quatri√®me composant de donn√©es contient un index de type d'√©l√©vation, que nous stockons directement sous forme d'octets. </font><font style="vertical-align: inherit;">Cependant, le GPU l'a automatiquement converti en une valeur √† virgule flottante comprise entre 0 et 1. </font><font style="vertical-align: inherit;">Pour le reconvertir √† la valeur correcte, multipliez-le par 255. Apr√®s cela, vous pouvez renvoyer les donn√©es.</font></font><br><br><pre> <code class="hljs kotlin"> float4 <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = tex2Dlod(_HexCellData, float4(uv, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.w *= <span class="hljs-number"><span class="hljs-number">255</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour utiliser cette fonctionnalit√©, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">activez HexCellData</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans le shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Depuis que j'ai plac√© ce shader dans </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mat√©riaux / Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , j'ai besoin d'utiliser le chemin relatif </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">../HexCellData.cginc</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs lisp"> #include <span class="hljs-string"><span class="hljs-string">"../HexCellData.cginc"</span></span> UNITY_DECLARE_TEX2DARRAY(<span class="hljs-name"><span class="hljs-name">_MainTex</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le programme vertex, nous obtenons des donn√©es de cellule pour les trois indices cellulaires stock√©s dans les donn√©es de vertex. </font><font style="vertical-align: inherit;">Attribuez ensuite </font></font><code>data.terrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">leurs indices d'√©l√©vation.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); // data.terrain = v.texcoord2.xyz; <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell2 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">2</span></span>); data.terrain.x = cell0.w; data.terrain.y = cell1.w; data.terrain.z = cell2.w; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä ce stade, la carte a de nouveau commenc√© √† afficher le terrain correct. </font><font style="vertical-align: inherit;">La grande diff√©rence est que la modification des types de terrain ne conduit plus √† de nouvelles triangulations. </font><font style="vertical-align: inherit;">Si, lors de la modification, toute autre donn√©e de cellule est modifi√©e, la triangulation sera effectu√©e comme d'habitude. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visibilit√© </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir cr√©√© la base de ces cellules, nous pouvons continuer √† soutenir la visibilit√©. </font><font style="vertical-align: inherit;">Pour ce faire, nous utilisons le shader, les cellules elles-m√™mes et les objets qui d√©terminent la visibilit√©. </font><font style="vertical-align: inherit;">Notez que le processus de triangulation n'en sait absolument rien.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commen√ßons par expliquer au shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain la</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> visibilit√©. </font><font style="vertical-align: inherit;">Il recevra les donn√©es de visibilit√© du programme vertex et les transmettra au programme de fragments √† l'aide de la structure </font></font><code>Input</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Puisque nous passons trois indices d'√©l√©vation distincts, nous passerons √©galement trois valeurs de visibilit√©.</font></font><br><br><pre> <code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span></span>{ float4 color : <span class="hljs-type"><span class="hljs-type">COLOR</span></span>; float3 worldPos; float3 terrain; float3 visibility; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour stocker la visibilit√©, nous utilisons le premier composant de ces cellules. </font></font><br><br><pre> <code class="hljs kotlin"> void vert (inout appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Input <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { UNITY_INITIALIZE_OUTPUT(Input, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); float4 cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); float4 cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); float4 cell2 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.terrain.x = cell0.w; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.terrain.y = cell1.w; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.terrain.z = cell2.w; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = cell0.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.y = cell1.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.z = cell2.x; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une visibilit√© de 0 signifie que la cellule est actuellement invisible. </font><font style="vertical-align: inherit;">S'il √©tait visible, il aurait la valeur de visibilit√© 1. On peut donc assombrir le terrain en multipliant le r√©sultat </font></font><code>GetTerrainColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par le vecteur de visibilit√© correspondant. </font><font style="vertical-align: inherit;">Ainsi, nous modulons individuellement la couleur du relief de chaque cellule mixte.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float4</span></span> GetTerrainColor (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float3 uvw = float3(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.terrain[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]); <span class="hljs-type"><span class="hljs-type">float4</span></span> c = UNITY_SAMPLE_TEX2DARRAY(_MainTex, uvw); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c * (<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.color[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>] * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bf/183/e69/1bf183e695a42f4691f63cec72255993.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les cellules sont devenues noires.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ne pouvons-nous pas plut√¥t combiner la visibilit√© dans un programme de vertex?</font></font></b> <div class="spoiler_text">   ,           .              .           .        ,      .   ,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'obscurit√© totale est un buste pour les cellules temporairement invisibles. </font><font style="vertical-align: inherit;">Pour que nous puissions toujours voir le relief, nous devons augmenter l'indicateur utilis√© pour les cellules cach√©es. </font><font style="vertical-align: inherit;">Passons de 0‚Äì1 √† ¬º - 1, ce qui peut √™tre fait en utilisant la fonction </font></font><code>lerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† la fin du programme vertex.</font></font><br><br><pre> <code class="hljs kotlin"> void vert (inout appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Input <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = cell0.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.y = cell1.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.z = cell2.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a20/090/3e2/a200903e2f31f3bdcd0c996d42f91a02.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cellules ombr√©es.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suivi de la visibilit√© des cellules </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour que la visibilit√© fonctionne, les cellules doivent suivre leur visibilit√©. Mais comment une cellule d√©termine-t-elle si elle est visible? Nous pouvons le faire en suivant le nombre d'entit√©s qui le voient. Lorsque quelqu'un commence √† voir une cellule, il doit signaler cette cellule. Et lorsque quelqu'un arr√™te de voir la cellule, il doit √©galement l'en informer. La cellule garde simplement une trace du nombre d'observateurs, quelles que soient ces entit√©s. Si une cellule a une valeur de visibilit√© d'au moins 1, elle est visible, sinon elle est invisible. Pour impl√©menter ce comportement, nous ajoutons </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deux m√©thodes et une propri√©t√© </font><font style="vertical-align: inherit;">√† la </font><font style="vertical-align: inherit;">variable.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsVisible { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> visibility &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } } ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> visibility; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { visibility += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { visibility -= <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, ajoutez √† la </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©thode </font></font><code>RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui fait la m√™me chose que </font></font><code>RefreshTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, juste pour des raisons de visibilit√©. </font><font style="vertical-align: inherit;">Enregistrez les donn√©es dans le composant R des cellules de donn√©es. </font><font style="vertical-align: inherit;">Comme nous travaillons avec des octets convertis en valeurs 0‚Äì1, nous utilisons pour indiquer la visibilit√© </font></font><code>(byte)255</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cellTextureData[cell.Index].r = cell.IsVisible ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous appellerons cette m√©thode avec une visibilit√© croissante et d√©croissante, en changeant la valeur entre 0 et 1. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { visibility += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (visibility == <span class="hljs-number"><span class="hljs-number">1</span></span>) { ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { visibility -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (visibility == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cr√©er la visibilit√© de l'escouade </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faisons en sorte que les unit√©s puissent voir la cellule qu'elles occupent. </font><font style="vertical-align: inherit;">Ceci est accompli en utilisant un appel </font></font><code>IncreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">au nouvel emplacement de l'unit√© pendant la t√¢che </font></font><code>HexUnit.Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous demandons √©galement l'ancien emplacement (s'il existe) </font></font><code>DecreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> location; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { location.DecreaseVisibility(); location.Unit = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } location = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Unit = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.IncreaseVisibility(); transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Position; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bc/f95/a07/7bcf95a07fdf4c10ed1d53055dddf6a4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les unit√©s peuvent voir o√π elles se trouvent. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin nous avons utilis√© la visibilit√©! </font><font style="vertical-align: inherit;">Lorsqu'elles sont ajout√©es √† une carte, les unit√©s rendent leur cellule visible. </font><font style="vertical-align: inherit;">De plus, leur port√©e est t√©l√©port√©e lors du d√©placement vers leur nouvel emplacement. </font><font style="vertical-align: inherit;">Mais leur port√©e reste active lors de la suppression d'unit√©s de la carte. </font><font style="vertical-align: inherit;">Pour r√©soudre ce probl√®me, nous r√©duirons la visibilit√© de leur emplacement lors de la destruction d'unit√©s.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Die</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { location.DecreaseVisibility(); } location.Unit = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; Destroy(gameObject); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plage de visibilit√© </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'√† pr√©sent, nous ne voyons que la cellule dans laquelle se trouve le d√©tachement, ce qui limite les possibilit√©s. Au moins, nous devons voir les cellules voisines. Dans le cas g√©n√©ral, les unit√©s peuvent voir toutes les cellules √† une certaine distance, qui d√©pend de l'unit√©. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutons √† la </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©thode pour trouver toutes les cellules visibles d'une cellule en tenant compte de la plage. Nous pouvons cr√©er cette m√©thode en dupliquant et en changeant </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Modifiez ses param√®tres et faites-lui retourner une liste de cellules pour lesquelles vous pouvez utiliser le pool de listes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä chaque it√©ration, la cellule actuelle est ajout√©e √† la liste. Il n'y a plus de cellule finale, la recherche ne se terminera donc jamais lorsqu'elle atteindra ce point. Nous nous d√©barrassons √©galement de la logique des d√©placements et du co√ªt du d√©placement. Faire les propri√©t√©s</font></font><code>PathFrom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on ne les a plus pos√©es car nous n'en avons pas besoin et nous ne voulons pas interf√©rer avec le chemin le long de la grille. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä chaque √©tape, la distance augmente simplement de 1. Si elle d√©passe la plage, cette cellule est ignor√©e. </font><font style="vertical-align: inherit;">Et nous n'avons pas besoin d'une heuristique de recherche, nous l'initialisons donc avec une valeur de 0. Autrement dit, nous sommes revenus √† l'algorithme de Dijkstra.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">List&lt;HexCell&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetVisibleCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> range</span></span></span><span class="hljs-function">)</span></span> { List&lt;HexCell&gt; visibleCells = ListPool&lt;HexCell&gt;.Get(); searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchFrontier.Clear(); } fromCell.SearchPhase = searchFrontierPhase; fromCell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(fromCell); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); current.SearchPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; visibleCells.Add(current); <span class="hljs-comment"><span class="hljs-comment">// if (current == toCell) { // return true; // } // int currentTurn = (current.Distance - 1) / speed; for (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); if ( neighbor == null || neighbor.SearchPhase &gt; searchFrontierPhase ) { continue; } // ‚Ä¶ // int moveCost; // ‚Ä¶ int distance = current.Distance + 1; if (distance &gt; range) { continue; } // int turn = (distance - 1) / speed; // if (turn &gt; currentTurn) { // distance = turn * speed + moveCost; // } if (neighbor.SearchPhase &lt; searchFrontierPhase) { neighbor.SearchPhase = searchFrontierPhase; neighbor.Distance = distance; // neighbor.PathFrom = current; neighbor.SearchHeuristic = 0; searchFrontier.Enqueue(neighbor); } else if (distance &lt; neighbor.Distance) { int oldPriority = neighbor.SearchPriority; neighbor.Distance = distance; // neighbor.PathFrom = current; searchFrontier.Change(neighbor, oldPriority); } } } return visibleCells; }</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ne pouvons-nous pas utiliser un algorithme plus simple pour trouver toutes les cellules √† port√©e?</font></font></b> <div class="spoiler_text"> ,          ,      . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez √©galement des </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©thodes </font></font><code>IncreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>DecreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ils obtiennent la cellule et la plage, prennent une liste des cellules correspondantes et augmentent / diminuent leur visibilit√©. </font><font style="vertical-align: inherit;">Une fois termin√©, ils devraient retourner la liste dans son pool.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> range</span></span></span><span class="hljs-function">)</span></span> { List&lt;HexCell&gt; cells = GetVisibleCells(fromCell, range); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Count; i++) { cells[i].IncreaseVisibility(); } ListPool&lt;HexCell&gt;.Add(cells); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> range</span></span></span><span class="hljs-function">)</span></span> { List&lt;HexCell&gt; cells = GetVisibleCells(fromCell, range); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Count; i++) { cells[i].DecreaseVisibility(); } ListPool&lt;HexCell&gt;.Add(cells); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour utiliser ces m√©thodes </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√©cessite un acc√®s √† la grille, ajoutez-y donc une propri√©t√© </font></font><code>Grid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid Grid { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque vous ajoutez une escouade √† une grille, elle attribue une grille √† cette propri√©t√© </font></font><code>HexGrid.AddUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexUnit unit, HexCell location, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> orientation</span></span></span><span class="hljs-function">)</span></span> { units.Add(unit); unit.Grid = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; unit.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); unit.Location = location; unit.Orientation = orientation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour commencer, une plage de visibilit√© de trois cellules sera suffisante. </font><font style="vertical-align: inherit;">Pour ce faire, nous ajoutons √† la </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constante, qui √† l'avenir peut toujours se transformer en variable. </font><font style="vertical-align: inherit;">Ensuite, nous ferons en sorte que l'√©quipe invoque des m√©thodes pour la grille </font></font><code>IncreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>DecreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en transmettant √©galement sa plage de visibilit√©, et non pas simplement aller √† cet endroit.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> visionRange = <span class="hljs-number"><span class="hljs-number">3</span></span>; ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> location; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { <span class="hljs-comment"><span class="hljs-comment">// location.DecreaseVisibility(); Grid.DecreaseVisibility(location, visionRange); location.Unit = null; } location = value; value.Unit = this; // value.IncreaseVisibility(); Grid.IncreaseVisibility(value, visionRange); transform.localPosition = value.Position; } } ‚Ä¶ public void Die () { if (location) { // location.DecreaseVisibility(); Grid.DecreaseVisibility(location, visionRange); } location.Unit = null; Destroy(gameObject); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cd/c45/ccb/8cdc45ccb01449b3c7d50a7bef9b249c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unit√©s avec une plage de visibilit√© pouvant se chevaucher.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visibilit√© lors du d√©placement </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä l'heure actuelle, la zone de visibilit√© de l'escouade apr√®s la commande de d√©placement est imm√©diatement t√©l√©port√©e au point final. </font><font style="vertical-align: inherit;">Il aurait √©t√© pr√©f√©rable que l'unit√© et son champ de visibilit√© se rapprochent. </font><font style="vertical-align: inherit;">La premi√®re √©tape consiste √† ne plus d√©finir la propri√©t√© </font></font><code>Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c </font></font><code>HexUnit.Travel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Au lieu de cela, nous changerons directement le champ </font></font><code>location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en √©vitant le code de propri√©t√©. </font><font style="vertical-align: inherit;">Par cons√©quent, nous effacerons manuellement l'ancien emplacement et configurerons un nouvel emplacement. </font><font style="vertical-align: inherit;">La visibilit√© restera inchang√©e.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Travel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;HexCell&gt; path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Location = path[path.Count - 1]; location.Unit = null; location = path[path.Count - 1]; location.Unit = this; pathToTravel = path; StopAllCoroutines(); StartCoroutine(TravelPath()); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä l'int√©rieur des coroutines, </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous ne r√©duirons la visibilit√© de la premi√®re cellule qu'apr√®s l'ach√®vement </font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Apr√®s cela, avant de passer √† une nouvelle cellule, nous augmenterons la visibilit√© de cette cellule. </font><font style="vertical-align: inherit;">Cela fait, nous en r√©duisons encore la visibilit√©. </font><font style="vertical-align: inherit;">Enfin, augmentez la visibilit√© depuis la derni√®re cellule.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-comment"><span class="hljs-comment">// transform.localPosition = c; yield return LookAt(pathToTravel[1].Position); Grid.DecreaseVisibility(pathToTravel[0], visionRange); float t = Time.deltaTime * travelSpeed; for (int i = 1; i &lt; pathToTravel.Count; i++) { a = c; b = pathToTravel[i - 1].Position; c = (b + pathToTravel[i].Position) * 0.5f; Grid.IncreaseVisibility(pathToTravel[i], visionRange); for (; t &lt; 1f; t += Time.deltaTime * travelSpeed) { ‚Ä¶ } Grid.DecreaseVisibility(pathToTravel[i], visionRange); t -= 1f; } a = c; b = location.Position; // We can simply use the destination here. c = b; Grid.IncreaseVisibility(location, visionRange); for (; t &lt; 1f; t += Time.deltaTime * travelSpeed) { ‚Ä¶ } ‚Ä¶ }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visibilit√© en mouvement. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout cela fonctionne, sauf lorsqu'un nouvel ordre est √©mis au moment du d√©placement du d√©tachement. </font><font style="vertical-align: inherit;">Cela conduit √† la t√©l√©portation, qui devrait √©galement s'appliquer √† la visibilit√©. </font><font style="vertical-align: inherit;">Pour r√©aliser cela, nous devons suivre l'emplacement actuel de l'√©quipe pendant le d√©placement.</font></font><br><br><pre> <code class="cs hljs"> HexCell location, currentTravelLocation;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous mettrons √† jour cet emplacement chaque fois que nous touchons une nouvelle cellule pendant le d√©placement, jusqu'√† ce que l'√©quipe atteigne la cellule finale. </font><font style="vertical-align: inherit;">Ensuite, il doit √™tre r√©initialis√©.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { currentTravelLocation = pathToTravel[i]; a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = (b + currentTravelLocation.Position) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; Grid.IncreaseVisibility(pathToTravel[i], visionRange); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { transform.localPosition = Bezier.GetPoint(a, b, c, t); Vector3 d = Bezier.GetDerivative(a, b, c, t); dy = <span class="hljs-number"><span class="hljs-number">0f</span></span>; transform.localRotation = Quaternion.LookRotation(d); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } Grid.DecreaseVisibility(pathToTravel[i], visionRange); t -= <span class="hljs-number"><span class="hljs-number">1f</span></span>; } currentTravelLocation = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, apr√®s avoir termin√© le virage, </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous pouvons v√©rifier si l'ancien emplacement interm√©diaire du chemin est connu. </font><font style="vertical-align: inherit;">Si oui, vous devez r√©duire la visibilit√© dans cette cellule, et non au d√©but du chemin.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pathToTravel[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">].Position</span></span></span><span class="hljs-function">)</span></span>; Grid.DecreaseVisibility( currentTravelLocation ? currentTravelLocation : pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>], visionRange ); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons √©galement corriger la visibilit√© apr√®s recompilation qui s'est produite lors du mouvement de l'√©quipe. </font><font style="vertical-align: inherit;">Si l'emplacement interm√©diaire est toujours connu, r√©duisez la visibilit√© et augmentez la visibilit√© au point final, puis r√©initialisez l'emplacement interm√©diaire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { transform.localPosition = location.Position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentTravelLocation) { Grid.IncreaseVisibility(location, visionRange); Grid.DecreaseVisibility(currentTravelLocation, visionRange); currentTravelLocation = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visibilit√© des routes et de l'eau </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que les changements de couleur du relief soient bas√©s sur la visibilit√©, cela n'affecte pas les routes et l'eau. </font><font style="vertical-align: inherit;">Ils ont l'air trop lumineux pour les cellules invisibles. </font><font style="vertical-align: inherit;">Pour appliquer la visibilit√© aux routes et √† l'eau, nous devons ajouter des indices de cellules et m√©langer les poids √† leurs donn√©es de maillage. </font><font style="vertical-align: inherit;">Par cons√©quent, nous v√©rifierons les enfants des </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">donn√©es</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d' </font><em><font style="vertical-align: inherit;">utilisation des cellules</font></em><font style="vertical-align: inherit;"> pour les </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rivi√®res</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , les </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">routes</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , l' </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eau</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la rive de l'eau</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et les </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estuaires du</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fragment pr√©fabriqu√©.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les routes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous partirons des routes. </font><font style="vertical-align: inherit;">La m√©thode est </font></font><code>HexGridChunk.TriangulateRoadEdge</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilis√©e pour cr√©er une petite partie de la route au centre de la cellule, elle a donc besoin d'un index de cellule. </font><font style="vertical-align: inherit;">Ajoutez-y un param√®tre et g√©n√©rez des donn√©es de cellule pour le triangle.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadEdge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 center, Vector3 mL, Vector3 mR, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index </span></span></span><span class="hljs-function">)</span></span> { roads.AddTriangle(center, mL, mR); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); Vector3 indices; indices.x = indices.y = indices.z = index; roads.AddTriangleCellData(indices, weights1); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un autre moyen simple de cr√©er des routes est </font></font><code>TriangulateRoadSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il est utilis√© √† l'int√©rieur et entre les cellules, il devrait donc fonctionner avec deux index diff√©rents. </font><font style="vertical-align: inherit;">Pour cela, il est pratique d'utiliser le param√®tre vecteur d'index. </font><font style="vertical-align: inherit;">√âtant donn√© que les segments de route peuvent faire partie de rebords, les poids doivent √©galement passer par des param√®tres.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, Vector3 v5, Vector3 v6, Color w1, Color w2, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { roads.AddQuad(v1, v2, v4, v5); roads.AddQuad(v2, v3, v5, v6); roads.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); roads.AddQuadUV(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); roads.AddQuadCellData(indices, w1, w2); roads.AddQuadCellData(indices, w1, w2); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Passons maintenant √† </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ce qui cr√©e des routes √† l'int√©rieur des cellules. </font><font style="vertical-align: inherit;">Il a √©galement besoin d'un param√®tre d'index. </font><font style="vertical-align: inherit;">Il transmet ces donn√©es aux m√©thodes routi√®res qu'il appelle et les ajoute aux triangles qu'il cr√©e.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 center, Vector3 mL, Vector3 mR, EdgeVertices e, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoadThroughCellEdge, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRoadThroughCellEdge) { Vector3 indices; indices.x = indices.y = indices.z = index; Vector3 mC = Vector3.Lerp(mL, mR, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); TriangulateRoadSegment( mL, mC, mR, e.v2, e.v3, e.v4, weights1, weights1, indices ); roads.AddTriangle(center, mL, mC); roads.AddTriangle(center, mC, mR); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); roads.AddTriangleCellData(indices, weights1); roads.AddTriangleCellData(indices, weights1); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateRoadEdge(center, mL, mR, index); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il reste √† ajouter les arguments de m√©thode n√©cessaires </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>TriangulateRoadEdge</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>TriangulateRoadSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">corriger toutes les erreurs du compilateur.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithoutRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { TriangulateEdgeFan(center, e, cell.Index); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoads) { Vector2 interpolators = GetRoadInterpolators(direction, cell); TriangulateRoad( center, Vector3.Lerp(center, e.v1, interpolators.x), Vector3.Lerp(center, e.v5, interpolators.y), e, cell.HasRoadThroughEdge(direction), cell.Index ); } } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ TriangulateRoad(roadCenter, mL, mR, e, hasRoadThroughEdge, cell.Index); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { TriangulateRoadEdge(roadCenter, center, mL, cell.Index); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextHasRiver) { TriangulateRoadEdge(roadCenter, mR, center, cell.Index); } } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> ‚Ä¶ </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRoad) { TriangulateRoadSegment( e1.v2, e1.v3, e1.v4, e2.v2, e2.v3, e2.v4, w1, w2, indices ); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, les donn√©es de maillage sont correctes et nous allons passer au shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Road</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Il a besoin d'un programme vertex et il doit contenir </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HexCellData</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs css"> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">surface</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">surf</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Standard</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">fullforwardshadows</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">decal</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:blend</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vertex</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:vert</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">target</span></span> 3<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#include</span></span> "<span class="hljs-selector-tag"><span class="hljs-selector-tag">HexCellData</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.cginc</span></span>"</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comme nous ne m√©langeons pas plusieurs mat√©riaux, il nous suffira de passer un indicateur de visibilit√© dans le programme des fragments. </font></font><br><br><pre> <code class="hljs cpp"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> {</span></span> float2 uv_MainTex; float3 worldPos; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> visibility; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il suffit qu'un nouveau programme vertex re√ßoive des donn√©es de deux cellules. </font><font style="vertical-align: inherit;">Nous m√©langeons imm√©diatement leur visibilit√©, l'ajustons et ajoutons √† la sortie.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); data.visibility = cell0.x * v.color.x + cell1.x * v.color.y; data.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dans le programme de fragments, nous avons juste besoin d'ajouter de la visibilit√© √† la couleur. </font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); fixed4 c = _Color * ((noise.y * <span class="hljs-number"><span class="hljs-number">0.75</span></span> + <span class="hljs-number"><span class="hljs-number">0.25</span></span>) * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af8/92f/46e/af892f46e364906cc547aaecb4e50e3a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Routes avec visibilit√©.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eau libre </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il peut sembler que la visibilit√© a d√©j√† affect√© l'eau, mais ce n'est que la surface d'un terrain immerg√© dans l'eau. </font><font style="vertical-align: inherit;">Commen√ßons par appliquer la visibilit√© en eau libre. </font><font style="vertical-align: inherit;">Pour cela, nous devons changer </font></font><code>HexGridChunk.TriangulateOpenWater</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateOpenWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ water.AddTriangle(center, c1, c2); Vector3 indices; indices.x = indices.y = indices.z = cell.Index; water.AddTriangleCellData(indices, weights1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE &amp;&amp; neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { ‚Ä¶ water.AddQuad(c1, c2, e1, e2); indices.y = neighbor.Index; water.AddQuadCellData(indices, weights1, weights2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E) { ‚Ä¶ water.AddTriangle( c2, e2, c2 + HexMetrics.GetWaterBridge(direction.Next()) ); indices.z = nextNeighbor.Index; water.AddTriangleCellData( indices, weights1, weights2, weights3 ); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous devons √©galement ajouter des donn√©es cellulaires aux fans des triangles pr√®s des c√¥tes. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ water.AddTriangle(center, e1.v1, e1.v2); water.AddTriangle(center, e1.v2, e1.v3); water.AddTriangle(center, e1.v3, e1.v4); water.AddTriangle(center, e1.v4, e1.v5); Vector3 indices; indices.x = indices.y = indices.z = cell.Index; water.AddTriangleCellData(indices, weights1); water.AddTriangleCellData(indices, weights1); water.AddTriangleCellData(indices, weights1); water.AddTriangleCellData(indices, weights1); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> doit √™tre chang√© de la m√™me mani√®re que le shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Road</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais il doit combiner la visibilit√© non pas de deux, mais de trois cellules.</font></font><br><br><pre> <code class="hljs pgsql"> #pragma surface surf Standard alpha vertex:vert #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexCellData.cginc" sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float3 worldPos; <span class="hljs-type"><span class="hljs-type">float</span></span> visibility; }; ‚Ä¶ <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell2 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">2</span></span>); data.visibility = cell0.x * v.color.x + cell1.x * v.color.y + cell2.x * v.color.z; data.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility); } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> waves = Waves(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz, _MainTex); fixed4 c = saturate(_Color + waves); o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility; ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a4/c52/36c/6a4c5236c52eaae78cbde54fb2fdeeac.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eau libre avec visibilit√©.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C√¥te et estuaire </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour soutenir la c√¥te, nous devons changer √† nouveau </font></font><code>HexGridChunk.TriangulateWaterShore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous avons d√©j√† cr√©√© un vecteur d'index, mais nous n'avons utilis√© qu'un seul indice de cellule pour l'eau libre. </font><font style="vertical-align: inherit;">La c√¥te a √©galement besoin d'un index voisin, alors changez le code.</font></font><br><br><pre> <code class="cs hljs"> Vector3 indices; <span class="hljs-comment"><span class="hljs-comment">// indices.x = indices.y = indices.z = cell.Index; indices.x = indices.z = cell.Index; indices.y = neighbor.Index;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez les donn√©es des cellules aux quads et au triangle de la c√¥te. </font><font style="vertical-align: inherit;">Nous transmettons √©galement les index lors de l'appel </font></font><code>TriangulateEstuary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { TriangulateEstuary( e1, e2, cell.IncomingRiver == direction, indices ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ‚Ä¶ waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadCellData(indices, weights1, weights2); waterShore.AddQuadCellData(indices, weights1, weights2); waterShore.AddQuadCellData(indices, weights1, weights2); waterShore.AddQuadCellData(indices, weights1, weights2); } HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { ‚Ä¶ waterShore.AddTriangleUV( ‚Ä¶ ); indices.z = nextNeighbor.Index; waterShore.AddTriangleCellData( indices, weights1, weights2, weights3 ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez le param√®tre n√©cessaire </font></font><code>TriangulateEstuary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et prenez soin de ces cellules pour la c√¥te et la bouche. </font><font style="vertical-align: inherit;">N'oubliez pas que la bouche est en trap√®ze avec deux triangles de la c√¥te sur les c√¥t√©s. </font><font style="vertical-align: inherit;">Nous nous assurons que les poids sont transf√©r√©s dans le bon ordre.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEstuary</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, EdgeVertices e2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> incomingRiver, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { waterShore.AddTriangle(e2.v1, e1.v2, e1.v1); waterShore.AddTriangle(e2.v5, e1.v5, e1.v4); waterShore.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); waterShore.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); waterShore.AddTriangleCellData(indices, weights2, weights1, weights1); waterShore.AddTriangleCellData(indices, weights2, weights1, weights1); estuaries.AddQuad(e2.v1, e1.v2, e2.v2, e1.v3); estuaries.AddTriangle(e1.v3, e2.v2, e2.v4); estuaries.AddQuad(e1.v3, e1.v4, e2.v4, e2.v5); estuaries.AddQuadUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); estuaries.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); estuaries.AddQuadUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); estuaries.AddQuadCellData( indices, weights2, weights1, weights2, weights1 ); estuaries.AddTriangleCellData(indices, weights1, weights2, weights2); estuaries.AddQuadCellData(indices, weights1, weights2); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WaterShore</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><em><font style="vertical-align: inherit;">vous</font></em><font style="vertical-align: inherit;"> devez effectuer les m√™mes modifications que dans le shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , en m√©langeant la visibilit√© des trois cellules.</font></font><br><br><pre> <code class="hljs pgsql"> #pragma surface surf Standard alpha vertex:vert #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexCellData.cginc" sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float3 worldPos; <span class="hljs-type"><span class="hljs-type">float</span></span> visibility; }; ‚Ä¶ <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell2 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">2</span></span>); data.visibility = cell0.x * v.color.x + cell1.x * v.color.y + cell2.x * v.color.z; data.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility); } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { ‚Ä¶ fixed4 c = saturate(_Color + max(foam, waves)); o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le </font><font style="vertical-align: inherit;">shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estuary</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> m√©lange la visibilit√© de deux cellules, tout comme le shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Road</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Il a d√©j√† un programme de sommets, car nous avons besoin de lui pour transmettre les coordonn√©es UV des rivi√®res.</font></font><br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexCellData.cginc" sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float2 riverUV; float3 worldPos; <span class="hljs-type"><span class="hljs-type">float</span></span> visibility; }; half _Glossiness; half _Metallic; fixed4 _Color; <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> o) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, o); o.riverUV = v.texcoord1.xy; <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); o.visibility = cell0.x * v.color.x + cell1.x * v.color.y; o.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, o.visibility); } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { ‚Ä¶ fixed4 c = saturate(_Color + water); o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility; ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/88f/829/254/88f829254235a293040ac755d8318bc3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√¥te et estuaire avec visibilit√©.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rivi√®res </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les derni√®res r√©gions aquatiques avec lesquelles travailler sont les rivi√®res. </font><font style="vertical-align: inherit;">Ajoutez un </font></font><code>HexGridChunk.TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vecteur d'index </font><font style="vertical-align: inherit;">au </font><font style="vertical-align: inherit;">param√®tre et ajoutez-le au maillage afin qu'il puisse conserver la visibilit√© de deux cellules.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { TriangulateRiverQuad(v1, v2, v3, v4, y, y, v, reversed, indices); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ rivers.AddQuadCellData(indices, weights1, weights2); }</code> </pre> <br> <code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cr√©e des points d'extr√©mit√© de rivi√®re avec un quad et un triangle au centre de la cellule. </font><font style="vertical-align: inherit;">Ajoutez les donn√©es de cellule n√©cessaires pour cela.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiverBeginOrEnd</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reversed = cell.HasIncomingRiver; Vector3 indices; indices.x = indices.y = indices.z = cell.Index; TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>, reversed, indices ); center.y = m.v2.y = m.v4.y = cell.RiverSurfaceY; rivers.AddTriangle(center, m.v2, m.v4); ‚Ä¶ rivers.AddTriangleCellData(indices, weights1); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons d√©j√† ces indices de cellule </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous les transmettons donc simplement √† l'appel </font></font><code>TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reversed = cell.IncomingRiver == direction; TriangulateRiverQuad( centerL, centerR, m.v2, m.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>, reversed, indices ); TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>, reversed, indices ); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous ajoutons √©galement un support d'index aux chutes d'eau qui se d√©versent en eau profonde. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterfallInWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> waterY, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ rivers.AddQuadCellData(indices, weights1, weights2); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et enfin, changez-le </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour qu'il passe les index n√©cessaires aux m√©thodes des rivi√®res et cascades.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRiver) { e2.v3.y = neighbor.StreamBedY; Vector3 indices; indices.x = indices.z = cell.Index; indices.y = neighbor.Index; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor.IsUnderwater) { TriangulateRiverQuad( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction, indices ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt; neighbor.WaterLevel) { TriangulateWaterfallInWater( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, neighbor.WaterSurfaceY, indices ); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !neighbor.IsUnderwater &amp;&amp; neighbor.Elevation &gt; cell.WaterLevel ) { TriangulateWaterfallInWater( e2.v4, e2.v2, e1.v4, e1.v2, neighbor.RiverSurfaceY, cell.RiverSurfaceY, cell.WaterSurfaceY, indices ); } } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">River</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> doit apporter les m√™mes modifications que le shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Road</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs pgsql"> #pragma surface surf Standard alpha vertex:vert #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexCellData.cginc" sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; <span class="hljs-type"><span class="hljs-type">float</span></span> visibility; }; ‚Ä¶ <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); data.visibility = cell0.x * v.color.x + cell1.x * v.color.y; data.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility); } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> river = River(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex, _MainTex); fixed4 c = saturate(_Color + river); o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility; ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ef/db6/76a/1efdb676afe28b61b73f317d25158505.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivi√®res avec visibilit√©. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objets et visibilit√© </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La visibilit√© fonctionne d√©sormais pour l'ensemble du terrain g√©n√©r√© par la proc√©dure, mais jusqu'√† pr√©sent, elle n'affecte pas les caract√©ristiques du terrain. Les b√¢timents, les fermes et les arbres sont cr√©√©s √† partir de pr√©fabriqu√©s et non √† partir de la g√©om√©trie proc√©durale, nous ne pouvons donc pas ajouter d'indices de cellules et m√©langer les poids avec leurs sommets. √âtant donn√© que chacun de ces objets appartient √† une seule cellule, nous devons d√©terminer dans quelle cellule ils se trouvent. Si nous pouvons le faire, nous aurons alors acc√®s aux donn√©es des cellules correspondantes et appliquerons la visibilit√©.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons d√©j√† transformer les positions XZ du monde en indices cellulaires. Cette transformation a √©t√© utilis√©e pour modifier le terrain et g√©rer les escouades. Cependant, le code correspondant n'est pas trivial. Il utilise des op√©rations enti√®res et n√©cessite une logique pour fonctionner avec les bords. Ceci n'est pas pratique pour un shader, nous pouvons donc cuire la majeure partie de la logique dans une texture et l'utiliser. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous utilisons d√©j√† une texture avec un motif hexagonal pour projeter la grille sur la topographie. Cette texture d√©finit une zone de cellule de 2 √ó 2. Par cons√©quent, nous pouvons facilement calculer dans quelle zone nous nous trouvons. Apr√®s cela, vous pouvez appliquer une texture contenant des d√©calages X et Z pour les cellules de cette zone et utiliser ces donn√©es pour calculer la cellule dans laquelle nous nous trouvons.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici une texture similaire. Le d√©calage X est stock√© dans son canal rouge et le d√©calage Z est stock√© dans le canal vert. Puisqu'il couvre la zone de 2 √ó 2 cellules, nous avons besoin de d√©calages de 0 et 2. Ces donn√©es ne peuvent pas √™tre stock√©es dans le canal de couleur, donc les d√©calages sont r√©duits de moiti√©. Nous n'avons pas besoin de bords clairs des cellules, donc une petite texture suffit.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/795/63c/d3c/79563cd3c22e7aa2ca66e40b5ffe3f7e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La texture des coordonn√©es de la grille. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez de la texture au projet. </font><font style="vertical-align: inherit;">R√©glez son </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mode</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d' </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habillage</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur </font><em><font style="vertical-align: inherit;">R√©p√©ter</font></em><font style="vertical-align: inherit;"> , tout comme les autres textures de maillage. </font><font style="vertical-align: inherit;">Nous n'avons pas besoin de m√©lange, donc pour le </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mode Blend,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous choisirons </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Point</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">D√©sactivez √©galement la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compression</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> afin que les donn√©es ne soient pas d√©form√©es. </font><font style="vertical-align: inherit;">D√©sactivez le mode </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sRGB</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour que lors du rendu en mode lin√©aire, aucune conversion d'espace colorim√©trique ne soit effectu√©e. </font><font style="vertical-align: inherit;">Et enfin, nous n'avons pas besoin de textures mip.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/866/aa9/de3/866aa9de36f6953f54d4fb8197fb75ff.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Options d'importation de texture.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ombrage d'objets avec visibilit√© </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cr√©ez un nouvel ombrage de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fonction</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour ajouter un support de visibilit√© aux objets. </font><font style="vertical-align: inherit;">Il s'agit d'un simple shader de surface avec un programme de vertex. </font><font style="vertical-align: inherit;">Ajoutez-y </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HexCellData</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et passez l'indicateur de visibilit√© au programme de fragment, et comme d'habitude, consid√©rez-le en couleur. </font><font style="vertical-align: inherit;">La diff√©rence ici est que nous ne pouvons pas l'utiliser </font></font><code>GetCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">car les donn√©es de maillage requises n'existent pas. </font><font style="vertical-align: inherit;">Au lieu de cela, nous avons une position dans le monde. </font><font style="vertical-align: inherit;">Mais pour l'instant, laissez la visibilit√© √©gale √† 1.</font></font><br><br><pre> <code class="hljs pgsql">Shader "Custom/Feature" { Properties { _Color ("Color", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex ("Albedo (RGB)", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Glossiness ("Smoothness", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.5</span></span> _Metallic ("Metallic", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.0</span></span> [NoTilingOffset] _GridCoordinates ("Grid Coordinates", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} } SubShader { Tags { "RenderType"="Opaque" } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> CGPROGRAM #pragma surface surf Standard fullforwardshadows vertex:vert #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "../HexCellData.cginc" sampler2D _MainTex, _GridCoordinates; half _Glossiness; half _Metallic; fixed4 _Color; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; <span class="hljs-type"><span class="hljs-type">float</span></span> visibility; }; <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); float3 pos = mul(unity_ObjectToWorld, v.vertex); data.visibility = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = tex2D (_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex) * _Color; o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; } ENDCG } FallBack "Diffuse" }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modifiez tous les mat√©riaux des objets pour qu'ils utilisent le nouveau shader et affectez-leur la texture des coordonn√©es de la grille. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e35/fad/546/e35fad5469e6c9e5c6a31626ba182ec8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Urbain avec texture en maille.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Acc√©der aux donn√©es des cellules </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour √©chantillonner la texture des coordonn√©es de la grille dans le programme des sommets, nous avons √† nouveau besoin d' </font></font><code>tex2Dlod</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un vecteur de coordonn√©es de texture √† quatre composants. </font><font style="vertical-align: inherit;">Les deux premi√®res coordonn√©es sont la position du monde XZ. </font><font style="vertical-align: inherit;">Les deux autres sont √©gaux √† z√©ro comme pr√©c√©demment.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); float3 pos = mul(unity_ObjectToWorld, v.vertex); <span class="hljs-type"><span class="hljs-type">float4</span></span> gridUV = <span class="hljs-type"><span class="hljs-type">float4</span></span>(pos.xz, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); data.visibility = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme dans le shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nous √©tirons les coordonn√©es UV afin que la texture ait le rapport d'aspect correct correspondant √† la grille d'hexagones.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float4</span></span> gridUV = <span class="hljs-type"><span class="hljs-type">float4</span></span>(pos.xz, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); gridUV.x *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-number"><span class="hljs-number">8.66025404</span></span>); gridUV.y *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">15.0</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons d√©couvrir dans quelle partie des cellules 2 √ó 2 nous nous trouvons en prenant la valeur des coordonn√©es UV arrondies vers le bas. </font><font style="vertical-align: inherit;">Cela constitue la base des coordonn√©es des cellules.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float4</span></span> gridUV = <span class="hljs-type"><span class="hljs-type">float4</span></span>(pos.xz, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); gridUV.x *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-number"><span class="hljs-number">8.66025404</span></span>); gridUV.y *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">15.0</span></span>); float2 cellDataCoordinates = floor(gridUV.xy);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour trouver les coordonn√©es de la cellule dans laquelle nous nous trouvons, nous ajoutons les d√©placements stock√©s dans la texture. </font></font><br><br><pre> <code class="hljs pgsql"> float2 cellDataCoordinates = floor(gridUV.xy) + tex2Dlod(_GridCoordinates, gridUV).rg;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Puisqu'une partie de la grille est de 2 √ó 2 et que les d√©calages sont divis√©s par deux, nous devons doubler le r√©sultat pour obtenir les coordonn√©es finales. </font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">float2</span></span> cellDataCoordinates = floor(gridUV.xy) + tex2Dlod(_GridCoordinates, gridUV).rg; <span class="hljs-attribute"><span class="hljs-attribute">cellDataCoordinates</span></span> *= <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous avons les coordonn√©es XZ de la grille de cellules que nous devons convertir en coordonn√©es UV de ces cellules. </font><font style="vertical-align: inherit;">Cela peut √™tre fait en se d√©pla√ßant simplement vers le centre des pixels, puis en les divisant en tailles de texture. </font><font style="vertical-align: inherit;">Ajoutons donc une </font><font style="vertical-align: inherit;">fonction pour cela au </font><font style="vertical-align: inherit;">fichier d'inclusion </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HexCellData</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> qui g√©rera √©galement l'√©chantillonnage.</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (float2 cellDataCoordinates) { float2 uv = cellDataCoordinates + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; uv.x *= _HexCellData_TexelSize.x; uv.y *= _HexCellData_TexelSize.y; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tex2Dlod(_HexCellData, <span class="hljs-type"><span class="hljs-type">float4</span></span>(uv, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant , </font><font style="vertical-align: inherit;">nous pouvons utiliser dans le programme de vertex shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la fonction</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs haskell"> cellDataCoordinates *= <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.visibility = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCellData</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cellDataCoordinates</span></span></span><span class="hljs-class">).x; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.visibility = lerp(0.25, 1, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">visibility</span></span></span><span class="hljs-class">);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ed/9c9/7ed/1ed9c97ed37aa88aaee6c0efd9d075d7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objets avec visibilit√©.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enfin, la visibilit√© affecte l'ensemble de la carte, √† l'exception des unit√©s qui sont toujours visibles. Puisque nous d√©terminons la visibilit√© des objets pour chaque sommet, puis pour l'objet traversant la limite des cellules, la visibilit√© des cellules qu'il ferme sera m√©lang√©e. Mais les objets sont si petits qu'ils restent constamment √† l'int√©rieur de leur cellule, m√™me en tenant compte de la distorsion des positions. Cependant, certains peuvent faire partie des sommets d'une autre cellule. Par cons√©quent, notre approche est bon march√©, mais imparfaite. Ceci est plus visible dans le cas des murs, dont la visibilit√© varie entre les visibilit√©s des cellules voisines.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/421/1c7/f7d/4211c7f7dea80bbbd13664586074c43a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Murs √† visibilit√© variable. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtant donn√© que les segments de mur sont g√©n√©r√©s de mani√®re proc√©durale, nous pouvons ajouter des donn√©es de cellule √† leur maillage et utiliser l'approche que nous avons utilis√©e pour le relief. </font><font style="vertical-align: inherit;">Malheureusement, les tours sont pr√©fabriqu√©es, nous aurons donc encore des incoh√©rences. </font><font style="vertical-align: inherit;">De mani√®re g√©n√©rale, l'approche existante semble assez bonne pour la g√©om√©trie simple que nous utilisons. </font><font style="vertical-align: inherit;">√Ä l'avenir, nous envisagerons des mod√®les et des murs plus d√©taill√©s, par cons√©quent, nous am√©liorerons la m√©thode de m√©lange de leur visibilit√©. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partie 21: recherche cartographique </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous affichons tout lors de l'√©dition. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous suivons les cellules enqu√™t√©es. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous cachons ce qui est encore inconnu. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous for√ßons les unit√©s √† √©viter les zones inexplor√©es. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dans la partie pr√©c√©dente, nous avons ajout√© le brouillard de guerre, que nous allons maintenant affiner pour mettre en ≈ìuvre la recherche cartographique. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/81d/40e/bff/81d40ebff615fc7c4e39a15d88da016d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous sommes pr√™ts √† explorer le monde.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Afficher la carte enti√®re en mode √©dition </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le sens de l'√©tude est que jusqu'√† ce que les cellules ne soient pas vues, elles sont consid√©r√©es comme inconnues et donc invisibles. </font><font style="vertical-align: inherit;">Ils ne doivent pas √™tre masqu√©s, mais pas affich√©s du tout. </font><font style="vertical-align: inherit;">Par cons√©quent, avant d'ajouter un support de recherche, nous activerons la visibilit√© en mode √©dition.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Commutation de visibilit√© </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons contr√¥ler si les shaders utilisent la visibilit√© en utilisant le mot-cl√©, comme cela a √©t√© fait avec la superposition sur la grille. </font><font style="vertical-align: inherit;">Utilisons le mot cl√© </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HEX_MAP_EDIT_MODE</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour </font><font style="vertical-align: inherit;">indiquer l'√©tat du mode d'√©dition. </font><font style="vertical-align: inherit;">Puisque plusieurs shaders doivent conna√Ætre ce mot-cl√©, nous le d√©finirons globalement en utilisant des m√©thodes statiques </font></font><code>Shader.EnableKeyWord</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>Shader.DisableKeyword</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous appellerons la m√©thode appropri√©e </font></font><code>HexGameUI.SetEditMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lors du changement de mode d'√©dition.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { enabled = !toggle; grid.ShowUI(!toggle); grid.ClearPath(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (toggle) { Shader.EnableKeyword(<span class="hljs-string"><span class="hljs-string">"HEX_MAP_EDIT_MODE"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Shader.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"HEX_MAP_EDIT_MODE"</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shaders du mode √©dition </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HEX_MAP_EDIT_MODE est</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d√©fini, les shaders ignorent la visibilit√©. </font><font style="vertical-align: inherit;">Cela se r√©sume au fait que la visibilit√© des cellules sera toujours consid√©r√©e comme √©gale √† 1. Ajoutons une </font><font style="vertical-align: inherit;">fonction pour filtrer les donn√©es des cellules en fonction du mot-cl√© </font><font style="vertical-align: inherit;">au d√©but du </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fichier</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inclus </font><em><font style="vertical-align: inherit;">HexCellData</font></em><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs kotlin">sampler2D _HexCellData; float4 _HexCellData_TexelSize; float4 FilterCellData (float4 <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(HEX_MAP_EDIT_MODE) <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.x = <span class="hljs-number"><span class="hljs-number">1</span></span>; #endif <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous passons par cette fonction le r√©sultat des deux fonctions </font></font><code>GetCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avant de la retourner.</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FilterCellData(data); } <span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (float2 cellDataCoordinates) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FilterCellData(tex2Dlod(_HexCellData, <span class="hljs-type"><span class="hljs-type">float4</span></span>(uv, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>))); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour que tout fonctionne, tous les shaders pertinents doivent recevoir la directive multi_compile pour cr√©er des options au cas o√π le mot cl√© </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HEX_MAP_EDIT_MODE</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est </font><font style="vertical-align: inherit;">d√©fini. </font><font style="vertical-align: inherit;">Ajoutez la ligne appropri√©e aux shaders </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estuaire</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entit√©</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivi√®re</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Route</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eau</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rive d'eau</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , entre la directive cible et la premi√®re directive d'inclusion.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> multi_compile _ HEX_MAP_EDIT_MODE</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, lorsque vous passez en mode d'√©dition de carte, le brouillard de guerre dispara√Ætra. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Recherche cellulaire </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par d√©faut, les cellules doivent √™tre consid√©r√©es comme inexplor√©es. </font><font style="vertical-align: inherit;">Ils sont explor√©s lorsqu'une √©quipe les voit. </font><font style="vertical-align: inherit;">Apr√®s cela, ils continuent de faire l'objet d'une enqu√™te si un d√©tachement peut les voir.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suivi de l'√©tat de l'√©tude </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour ajouter un support pour le suivi du statut des √©tudes, nous ajoutons √† la </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propri√©t√© g√©n√©rale </font></font><code>IsExplored</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsExplored { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'√©tat de l'√©tude est d√©termin√© par la cellule elle-m√™me. </font><font style="vertical-align: inherit;">Par cons√©quent, cette propri√©t√© doit √™tre d√©finie uniquement </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pour ajouter cette restriction, nous allons mettre le setter priv√©.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsExplored { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La premi√®re fois que la visibilit√© de la cellule devient sup√©rieure √† z√©ro, la cellule commence √† √™tre consid√©r√©e comme √©tudi√©e et </font></font><code>IsExplored</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">une valeur doit donc √™tre attribu√©e </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En fait, il nous suffira de simplement marquer la cellule comme examin√©e lorsque la visibilit√© augmente √† 1. Cela doit √™tre fait avant l'appel </font></font><code>RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { visibility += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (visibility == <span class="hljs-number"><span class="hljs-number">1</span></span>) { IsExplored = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transfert de l'√©tat de la recherche aux shaders </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme dans le cas de la visibilit√© des cellules, nous transf√©rons leur √©tat de recherche aux shaders via les donn√©es du shader. </font><font style="vertical-align: inherit;">Au final, ce n'est qu'un autre type de visibilit√©. </font></font><code>HexCellShaderData.RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stocke l'√©tat de visibilit√© dans le canal de donn√©es R. </font><font style="vertical-align: inherit;">Gardons l'√©tat de l'√©tude dans les donn√©es du canal G.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = cell.Index; cellTextureData[index].r = cell.IsVisible ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; cellTextureData[index].g = cell.IsExplored ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Relief noir inexplor√© </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant utiliser des shaders pour visualiser l'√©tat de la recherche cellulaire. </font><font style="vertical-align: inherit;">Pour nous assurer que tout fonctionne comme il se doit, nous rendons simplement le terrain inexplor√© noir. </font><font style="vertical-align: inherit;">Mais d'abord, pour que le mode d'√©dition fonctionne, modifiez-le </font></font><code>FilterCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">afin qu'il filtre les donn√©es de recherche.</font></font><br><br><pre> <code class="hljs kotlin">float4 FilterCellData (float4 <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(HEX_MAP_EDIT_MODE) <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.xy = <span class="hljs-number"><span class="hljs-number">1</span></span>; #endif <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> transmet les donn√©es de visibilit√© des trois cellules possibles au programme de fragments. </font><font style="vertical-align: inherit;">Dans le cas de l'√©tat de recherche, nous les combinons dans le programme vertex et transf√©rons la seule valeur au programme fragment. </font><font style="vertical-align: inherit;">Ajoutez le </font></font><code>visibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quatri√®me composant √† l' </font><font style="vertical-align: inherit;">entr√©e </font><font style="vertical-align: inherit;">afin d'avoir une place pour cela.</font></font><br><br><pre> <code class="hljs pgsql"> struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { <span class="hljs-type"><span class="hljs-type">float4</span></span> color : COLOR; float3 worldPos; float3 terrain; <span class="hljs-type"><span class="hljs-type">float4</span></span> visibility; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, dans le programme vertex, lorsque nous changeons l'indice de visibilit√©, nous devons explicitement y acc√©der </font></font><code>data.visibility.xyz</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { ‚Ä¶ data.visibility.xyz = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility.xyz); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s cela, nous combinons les √©tats de l'√©tude et √©crivons le r√©sultat </font></font><code>data.visibility.w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cela revient √† combiner la visibilit√© dans d'autres shaders, mais en utilisant le composant Y de ces cellules.</font></font><br><br><pre> <code class="hljs haskell"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.visibility.xyz = lerp(0.25, 1, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">visibility</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xyz</span></span></span><span class="hljs-class">); </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.visibility.w = cell0.y * v.color.x + cell1.y * v.color.y + cell2.y * v.color.z;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le statut de la recherche est d√©sormais disponible dans le programme Fragment via </font></font><code>IN.visibility.w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Consid√©rez-le dans le calcul de l'alb√©do.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { ‚Ä¶ <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.w; o.Albedo = c.rgb * grid * _Color * explored; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2d/de4/c18/b2dde4c1831a9ecc637550b2b8e2e134.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La topographie inexplor√©e est maintenant noire. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le relief des cellules inexplor√©es a d√©sormais une couleur noire. </font><font style="vertical-align: inherit;">Mais cela n'a pas encore affect√© les objets, les routes et l'eau. </font><font style="vertical-align: inherit;">Cependant, cela suffit pour s'assurer que l'√©tude fonctionne.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enregistrement et chargement de l'√©tat de la recherche </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que nous avons ajout√© un support de recherche, nous devons nous assurer que l'√©tat de la recherche est pris en compte lors de l'enregistrement et du chargement des cartes. </font><font style="vertical-align: inherit;">Par cons√©quent, nous devons augmenter la version des fichiers de carte √† 3. Pour rendre ces modifications plus pratiques, ajoutons une </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constante </font><font style="vertical-align: inherit;">pour cela </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapFileVersion = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous utiliserons cette constante lors de l'√©criture de la version du fichier </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et lors de la v√©rification de la prise en charge des fichiers </font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(mapFileVersion); hexGrid.Save(writer); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!File.Exists(path)) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"File does not exist "</span></span> + path); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &lt;= mapFileVersion) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme √©tape finale, </font></font><code>HexCell.Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous enregistrons le statut de l'√©tude.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ writer.Write(IsExplored); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et nous le lirons √† la fin </font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Apr√®s cela, nous appellerons </font></font><code>RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">au cas o√π l'√©tat de l'√©tude </font><font style="vertical-align: inherit;">serait </font><font style="vertical-align: inherit;">diff√©rent du pr√©c√©dent.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ IsExplored = reader.ReadBoolean(); ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour conserver la compatibilit√© descendante avec les anciens fichiers de sauvegarde, nous devons ignorer la lecture de l'√©tat de sauvegarde si la version du fichier est inf√©rieure √† 3. Dans ce cas, par d√©faut, les cellules auront l'√©tat ¬´inexplor√©¬ª. </font><font style="vertical-align: inherit;">Pour ce faire, nous devons ajouter des </font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">donn√©es d'en-t√™te en </font><font style="vertical-align: inherit;">tant que param√®tre </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ IsExplored = header &gt;= <span class="hljs-number"><span class="hljs-number">3</span></span> ? reader.ReadBoolean() : <span class="hljs-literal"><span class="hljs-literal">false</span></span>; ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">va maintenant devoir passer les </font></font><code>HexCell.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">donn√©es d' </font><font style="vertical-align: inherit;">en- </font><font style="vertical-align: inherit;">t√™te.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader, header); } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©sormais, lors de l'enregistrement et du chargement des cartes, l'√©tat d'exploration des cellules sera pris en compte. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Masquer les cellules inconnues </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au stade actuel, les cellules inexplor√©es sont visuellement indiqu√©es par un relief noir. </font><font style="vertical-align: inherit;">Mais en r√©alit√©, nous voulons que ces cellules soient invisibles car elles sont inconnues. </font><font style="vertical-align: inherit;">Nous pouvons rendre la g√©om√©trie opaque transparente afin qu'elle ne soit pas visible. </font><font style="vertical-align: inherit;">Cependant, le framework d'ombrage de surface Unity a √©t√© d√©velopp√© sans cette possibilit√© √† l'esprit. </font><font style="vertical-align: inherit;">Au lieu d'utiliser une v√©ritable transparence, nous changerons les shaders pour qu'ils correspondent √† l'arri√®re-plan, ce qui les rendra √©galement invisibles.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rendre le relief vraiment noir </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que le relief √©tudi√© soit noir, on peut encore le reconna√Ætre car il a toujours un √©clairage sp√©culaire. Pour se d√©barrasser de l'√©clairage, nous devons le rendre parfaitement noir mat. Afin de ne pas affecter les autres propri√©t√©s de surface, il est plus facile de changer la couleur sp√©culaire en noir. Cela est possible si vous utilisez un shader de surface qui fonctionne avec du sp√©culaire, mais maintenant nous utilisons le m√©tal standard. Commen√ßons donc par basculer le shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur sp√©culaire. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remplacez la propri√©t√© de couleur </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_Metallic</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur la </font><font style="vertical-align: inherit;">propri√©t√© </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_Specular</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Par d√©faut, sa valeur de couleur doit √™tre √©gale √† (0,2, 0,2, 0,2). Nous garantissons donc qu'elle correspondra √† l'apparence de la version m√©tallique.</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Terrain Texture Array"</span></span>, 2DArray) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_GridTex</span></span> (<span class="hljs-string"><span class="hljs-string">"Grid Texture"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> // _Metallic (<span class="hljs-string"><span class="hljs-string">"Metallic"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> _Specular (<span class="hljs-string"><span class="hljs-string">"Specular"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifiez √©galement les variables de shader correspondantes. </font><font style="vertical-align: inherit;">La couleur des shaders de surface sp√©culaires est d√©finie comme </font></font><code>fixed3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, utilisons-la donc.</font></font><br><br><pre> <code class="hljs objectivec"> half _Glossiness; <span class="hljs-comment"><span class="hljs-comment">// half _Metallic; fixed3 _Specular; fixed4 _Color;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifiez le surf surfacique pragma de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standard</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √† </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StandardSpecular</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Cela forcera Unity √† g√©n√©rer des shaders en utilisant sp√©culaire.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf StandardSpecular fullforwardshadows vertex:vert</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, la fonction a </font></font><code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">besoin que le deuxi√®me param√®tre soit de type </font></font><code>SurfaceOutputStandardSpecular</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">De plus, vous devez maintenant attribuer la valeur non </font></font><code>o.Metallic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais </font></font><code>o.Specular</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { ‚Ä¶ <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.w; o.Albedo = c.rgb * grid * _Color * explored; // o.Metallic = _Metallic; o.Specular = _Specular; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons masquer les reflets en consid√©rant la </font></font><code>explored</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">couleur sp√©culaire.</font></font><br><br><pre> <code class="hljs"> o.Specular = _Specular * explored;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/289/d05/128/289d0512816a7d6f692b0e7639e882eb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain inexplor√© sans √©clairage r√©fl√©chi. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme vous pouvez le voir sur la photo, le relief inexplor√© est maintenant d'un noir terne. </font><font style="vertical-align: inherit;">Cependant, lorsqu'elles sont vues sous un angle tangent, les surfaces se transforment en miroir, √† cause de quoi le relief commence √† refl√©ter l'environnement, c'est-√†-dire la skybox.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi les surfaces deviennent-elles des miroirs?</font></font></b> <div class="spoiler_text">    .  .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rendering</a> . </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/255/d63/627/255d636278eb947c27117d6c596a9489.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les zones inexplor√©es refl√®tent toujours l'environnement. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour se d√©barrasser de ces reflets, on consid√©rera le relief inexplor√© compl√®tement ombr√©. </font><font style="vertical-align: inherit;">Ceci est accompli en attribuant une valeur au </font></font><code>explored</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">param√®tre d'occlusion, que nous utilisons comme masque de r√©flexion.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.w; o.Albedo = c.rgb * grid * _Color * explored; o.Specular = _Specular * explored; o.Smoothness = _Glossiness; o.Occlusion = explored; o.Alpha = ca;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/118/ab6/a5a/118ab6a5a91711eda2165433a7b99513.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inexplor√© sans reflets.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fond assorti </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que le terrain inexplor√© ignore tout l'√©clairage, vous devez le faire correspondre √† l'arri√®re-plan. </font><font style="vertical-align: inherit;">Comme notre cam√©ra regarde toujours d'en haut, l'arri√®re-plan est toujours gris. </font><font style="vertical-align: inherit;">Pour indiquer au shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> quelle couleur utiliser, ajoutez la propri√©t√© </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_BackgroundColor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui est par d√©faut le noir.</font></font><br><br><pre> <code class="hljs dos"> Properties { ‚Ä¶ _BackgroundColor ("Background <span class="hljs-built_in"><span class="hljs-built_in">Color</span></span>", <span class="hljs-built_in"><span class="hljs-built_in">Color</span></span>) = (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) } ‚Ä¶ half _Glossiness; fixed3 _Specular; fixed4 _Color; half3 _BackgroundColor;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour utiliser cette couleur, nous l'ajouterons comme lumi√®re √©missive. </font><font style="vertical-align: inherit;">Ceci est </font></font><code>o.Emission</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">accompli en attribuant une valeur de couleur d'arri√®re-plan multipli√©e par un moins explor√©.</font></font><br><br><pre> <code class="hljs"> o.Occlusion = explored; o.Emission = _BackgroundColor * (1 - explored);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisque nous utilisons la skybox par d√©faut, la couleur d'arri√®re-plan visible n'est en fait pas la m√™me. </font><font style="vertical-align: inherit;">En g√©n√©ral, un gris l√©g√®rement rouge√¢tre serait la meilleure couleur. </font><font style="vertical-align: inherit;">Lors de la configuration du mat√©riau en relief, vous pouvez utiliser le </font><font style="vertical-align: inherit;">code 68615BFF </font><font style="vertical-align: inherit;">pour </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Color</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eeb/307/7dd/eeb3077dd097a7649575a371cbb361f6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mat√©riau en relief avec fond gris. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En g√©n√©ral, cela fonctionne, bien que si vous savez o√π chercher, vous remarquerez des silhouettes tr√®s faibles. </font><font style="vertical-align: inherit;">Pour que le joueur ne puisse pas les voir, vous pouvez attribuer une couleur d'arri√®re-plan uniforme de 68615BFF √† la cam√©ra au lieu de skybox.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b9/8cc/ec9/7b98ccec9228ac333cc23ec19cc6f28b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Appareil photo avec une couleur de fond uniforme.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi ne pas retirer la skybox?</font></font></b> <div class="spoiler_text">   ,   ,     environmental lighting .     ,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous ne pouvons pas trouver la diff√©rence entre le fond et les cellules inexplor√©es. </font><font style="vertical-align: inherit;">Une topographie inexplor√©e √©lev√©e peut toujours masquer une topographie explor√©e basse √† de faibles angles de cam√©ra. </font><font style="vertical-align: inherit;">De plus, des parties inexplor√©es projettent toujours des ombres sur l'explor√©. </font><font style="vertical-align: inherit;">Mais ces indices minimaux peuvent √™tre n√©glig√©s.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f88/764/d67/f88764d67aec0bf90267d273e1a248d5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les cellules inexplor√©es ne sont plus visibles.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que faire si vous n'utilisez pas une couleur d'arri√®re-plan uniforme?</font></font></b> <div class="spoiler_text">    ,        ,      .        .      ,          .       ,     ,  ,  UV-           . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Masquer les objets en relief </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous n'avons plus que le maillage du relief cach√©. </font><font style="vertical-align: inherit;">Le reste de l'√©tat de l'√©tude n'a pas encore √©t√© affect√©.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/282/c0c/a0f/282c0ca0fb55bf26ee0bb1d43cadd42f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'√† pr√©sent, seul le relief est cach√©. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifions le shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feature</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui est un shader opaque comme </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Transformez-le en un shader sp√©culaire et ajoutez-lui la couleur d'arri√®re-plan. </font><font style="vertical-align: inherit;">Commen√ßons par les propri√©t√©s.</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Albedo (RGB)"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> // _Metallic (<span class="hljs-string"><span class="hljs-string">"Metallic"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> _Specular (<span class="hljs-string"><span class="hljs-string">"Specular"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>) _BackgroundColor (<span class="hljs-string"><span class="hljs-string">"Background Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) [NoScaleOffset] _GridCoordinates (<span class="hljs-string"><span class="hljs-string">"Grid Coordinates"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Surface et variables du pragma suppl√©mentaires, comme pr√©c√©demment. </font></font><br><br><pre> <code class="hljs cpp"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf StandardSpecular fullforwardshadows vertex:vert ‚Ä¶ half _Glossiness; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// half _Metallic; fixed3 _Specular; fixed4 _Color; half3 _BackgroundColor;</span></span></span></span></code> </pre> <br> <code>visibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un autre composant est √©galement requis. </font><font style="vertical-align: inherit;">Puisque </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feature</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> combine la visibilit√© pour chaque sommet, il ne lui fallait qu'une seule valeur flottante. </font><font style="vertical-align: inherit;">Il nous en faut maintenant deux.</font></font><br><br><pre> <code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span></span>{ float2 uv_MainTex; float2 visibility; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifiez-le </font></font><code>vert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">afin qu'il utilise explicitement pour les donn√©es de visibilit√© </font></font><code>data.visibility.x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, puis affectez la </font></font><code>data.visibility.y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valeur des donn√©es d'√©tude.</font></font><br><br><pre> <code class="hljs kotlin"> void vert (inout appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Input <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { ‚Ä¶ float4 cellData = GetCellData(cellDataCoordinates); <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = cellData.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x); <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.y = cellData.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifiez-le </font></font><code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour qu'il utilise les nouvelles donn√©es, comme </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { fixed4 c = tex2D (_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex) * _Color; <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.y; o.Albedo = c.rgb * (<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.x * explored); // o.Metallic = _Metallic; o.Specular = _Specular * explored; o.Smoothness = _Glossiness; o.Occlusion = explored; o.Emission = _BackgroundColor * (<span class="hljs-number"><span class="hljs-number">1</span></span> - explored); o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d13/863/dc6/d13863dc60bbb92750cd5c8f8b69d82b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objets de secours cach√©s.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Masquer l'eau </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, les shaders </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water Shore</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Commen√ßons par les convertir en shaders sp√©culaires. </font><font style="vertical-align: inherit;">Cependant, ils n'ont pas besoin d'une couleur d'arri√®re-plan car ce sont des shaders transparents. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s la conversion, ajoutez </font></font><code>visibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un autre composant et modifiez-le en cons√©quence </font></font><code>vert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Les deux shaders combinent les donn√©es de trois cellules.</font></font><br><br><pre> <code class="hljs dos"> struct Input { ‚Ä¶ float2 visibility; }; ‚Ä¶ void vert (inout appdata_full v, out Input data) { ‚Ä¶ data.visibility.x = cell0.x * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.x + cell1.x * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.y + cell2.x * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.z; data.visibility.x = lerp(<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility.x); data.visibility.y = cell0.y * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.x + cell1.y * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.y + cell2.y * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.z; }</code> </pre> <br> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water Shore</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> effectuent </font></font><code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des op√©rations diff√©rentes, mais d√©finissent leurs propri√©t√©s de surface de la m√™me mani√®re. </font><font style="vertical-align: inherit;">Puisqu'ils sont transparents, nous prendrons en compte </font></font><code>explore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans le canal alpha, et nous ne fixerons pas d'√©mission.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { ‚Ä¶ <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.y; o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.x; o.Specular = _Specular * explored; o.Smoothness = _Glossiness; o.Occlusion = explored; o.Alpha = ca * explored; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15a/e39/390/15ae39390ccbe91f3d12f068992a7c14.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eau cach√©e.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous cachons les estuaires, les rivi√®res et les routes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons toujours les shaders pour l' </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estuaire</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rivi√®re</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">route</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Les trois sont transparents et combinent les donn√©es de deux cellules. </font><font style="vertical-align: inherit;">Mettez-les tous en sp√©culaire, puis ajoutez-les aux </font></font><code>visibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">donn√©es de recherche.</font></font><br><br><pre> <code class="hljs kotlin"> struct Input { ‚Ä¶ float2 visibility; }; ‚Ä¶ void vert (inout appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Input <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = cell0.x * v.color.x + cell1.x * v.color.y; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x); <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.y = cell0.y * v.color.x + cell1.y * v.color.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifiez la fonction des </font></font><code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shaders </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estuaire</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivi√®re</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour qu'elle utilise les nouvelles donn√©es. </font><font style="vertical-align: inherit;">Les deux doivent apporter les m√™mes modifications.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { ‚Ä¶ <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.y; fixed4 c = saturate(_Color + water); o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.x; o.Specular = _Specular * explored; o.Smoothness = _Glossiness; o.Occlusion = explored; o.Alpha = ca * explored; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le Shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Road est un</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> peu diff√©rent car il utilise une m√©trique de m√©lange suppl√©mentaire.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); fixed4 c = _Color * ((noise.y * <span class="hljs-number"><span class="hljs-number">0.75</span></span> + <span class="hljs-number"><span class="hljs-number">0.25</span></span>) * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.x); <span class="hljs-type"><span class="hljs-type">float</span></span> blend = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.x; blend *= noise.x + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; blend = smoothstep(<span class="hljs-number"><span class="hljs-number">0.4</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, blend); <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.y; o.Albedo = c.rgb; o.Specular = _Specular * explored; o.Smoothness = _Glossiness; o.Occlusion = explored; o.Alpha = blend * explored; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c6/1d2/c65/1c61d2c652b436385b42188c39476c14.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout est cach√©. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √âviter les cellules inexplor√©es </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que tout ce qui est inconnu soit visuellement cach√©, l'√©tat de l'√©tude n'est pas pris en compte lors de la recherche d'un chemin. </font><font style="vertical-align: inherit;">En cons√©quence, les unit√©s peuvent √™tre command√©es pour se d√©placer √† travers et √† travers des cellules inexplor√©es, d√©terminant magiquement la voie √† suivre. </font><font style="vertical-align: inherit;">Nous devons forcer les unit√©s pour √©viter les cellules inexplor√©es.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca9/eb9/f22/ca9eb9f22cd36b917bd5f0c38028bce7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parcourez les cellules inexplor√©es.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les escouades d√©terminent le co√ªt du d√©placement </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avant de s'attaquer aux cellules inexplor√©es, refaisons le code pour transf√©rer le co√ªt du d√©placement de </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cela simplifiera la prise en charge des unit√©s avec diff√©rentes r√®gles de mouvement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez √† la </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©thode g√©n√©rale </font></font><code>GetMoveCost</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour d√©terminer le co√ªt du d√©m√©nagement. </font><font style="vertical-align: inherit;">Il a besoin de savoir quelles cellules se d√©placent entre elles, ainsi que la direction. </font><font style="vertical-align: inherit;">Nous copions le code correspondant pour les co√ªts de passage de </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cette m√©thode et modifions les noms des variables.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMoveCost</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexCell fromCell, HexCell toCell, HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { HexEdgeType edgeType = fromCell.GetEdgeType(toCell); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edgeType == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> moveCost; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fromCell.HasRoadThroughEdge(direction)) { moveCost = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fromCell.Walled != toCell.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { moveCost = edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; moveCost += toCell.UrbanLevel + toCell.FarmLevel + toCell.PlantLevel; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La m√©thode doit renvoyer le co√ªt du d√©m√©nagement. </font><font style="vertical-align: inherit;">J'ai utilis√© l'ancien code pour ignorer les mouvements invalides </font></font><code>continue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais cette approche ne fonctionnera pas ici. </font><font style="vertical-align: inherit;">Si le mouvement n'est pas possible, nous rembourserons les co√ªts n√©gatifs du d√©m√©nagement.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMoveCost</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexCell fromCell, HexCell toCell, HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { HexEdgeType edgeType = fromCell.GetEdgeType(toCell); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edgeType == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> moveCost; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fromCell.HasRoadThroughEdge(direction)) { moveCost = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fromCell.Walled != toCell.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { moveCost = edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; moveCost += toCell.UrbanLevel + toCell.FarmLevel + toCell.PlantLevel; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> moveCost; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous devons savoir quand trouver le chemin, non seulement la vitesse, mais aussi l'unit√© s√©lectionn√©e. </font><font style="vertical-align: inherit;">Changez en cons√©quence </font></font><code>HexGameUI.DoPathFinding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoPathfinding</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UpdateCurrentCell()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentCell &amp;&amp; selectedUnit.IsValidDestination(currentCell)) { grid.FindPath(selectedUnit.Location, currentCell, selectedUnit); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { grid.ClearPath(); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtant donn√© que nous avons encore besoin d'acc√©der √† la vitesse de l'√©quipe, nous allons ajouter √† la </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propri√©t√© </font></font><code>Speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Alors qu'il renverra une valeur constante de 24.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Speed { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mutation, </font></font><code>FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour qu'ils puissent travailler avec notre nouvelle approche.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, HexUnit unit</span></span></span><span class="hljs-function">)</span></span> { ClearPath(); currentPathFrom = fromCell; currentPathTo = toCell; currentPathExists = Search(fromCell, toCell, unit); ShowPath(unit.Speed); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, HexUnit unit</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> speed = unit.Speed; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous allons supprimer de l' </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ancien code qui d√©terminait s'il est possible de passer √† la cellule suivante et quels sont les co√ªts de d√©placement. </font><font style="vertical-align: inherit;">Au lieu de cela, nous appellerons </font></font><code>HexUnit.IsValidDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>HexUnit.GetMoveCost</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous sauterons la cellule si le co√ªt du d√©m√©nagement est n√©gatif.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.SearchPhase &gt; searchFrontierPhase ) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// if (neighbor.IsUnderwater || neighbor.Unit) { // continue; // } // HexEdgeType edgeType = current.GetEdgeType(neighbor); // if (edgeType == HexEdgeType.Cliff) { // continue; // } // int moveCost; // if (current.HasRoadThroughEdge(d)) { // moveCost = 1; // } // else if (current.Walled != neighbor.Walled) { // continue; // } // else { // moveCost = edgeType == HexEdgeType.Flat ? 5 : 10; // moveCost += neighbor.UrbanLevel + neighbor.FarmLevel + // neighbor.PlantLevel; // } if (!unit.IsValidDestination(neighbor)) { continue; } int moveCost = unit.GetMoveCost(current, neighbor, d); if (moveCost &lt; 0) { continue; } int distance = current.Distance + moveCost; int turn = (distance - 1) / speed; if (turn &gt; currentTurn) { distance = turn * speed + moveCost; } ‚Ä¶ }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Contourner les zones inexplor√©es </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour √©viter les cellules inexplor√©es, il nous suffit de </font></font><code>HexUnit.IsValidDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v√©rifier si la cellule est examin√©e.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsValidDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell.IsExplored &amp;&amp; !cell.IsUnderwater &amp;&amp; !cell.Unit; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a84/831/2c6/a848312c6231a168a966e4cdafc2df38.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plus d'unit√©s ne pourront pas acc√©der √† des cellules inexplor√©es. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtant donn√© que les cellules inexplor√©es ne sont plus des points de terminaison valides, les escouades les √©viteront lors du d√©placement vers le point de terminaison. </font><font style="vertical-align: inherit;">Autrement dit, les zones inexplor√©es agissent comme des barri√®res qui allongent le chemin ou m√™me le rendent impossible. </font><font style="vertical-align: inherit;">Nous devrons rapprocher les unit√©s d'un terrain inconnu afin d'abord d'explorer la r√©gion.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que faire si un chemin plus court appara√Æt pendant le d√©m√©nagement?</font></font></b> <div class="spoiler_text">                .           ,        .       . <br><br>   ,        ,            .            ,    . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partie 22: Visibilit√© am√©lior√©e </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modifiez en douceur la visibilit√©. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Utilisez la hauteur de la cellule pour d√©terminer la port√©e. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Masquez le bord de la carte. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En ajoutant la prise en charge de l'exploration cartographique, nous am√©liorerons les calculs et les transitions de l'oscilloscope. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d2/c4a/793/2d2c4a7939e75fe09298f96ff6125478.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour voir plus loin, grimpez plus haut.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transitions de visibilit√© </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La cellule est visible ou invisible, car elle est ou non dans le p√©rim√®tre du d√©tachement. </font><font style="vertical-align: inherit;">M√™me s'il semble qu'il faut un certain temps √† une unit√© pour se d√©placer entre les cellules, sa port√©e passe instantan√©ment de cellule en cellule. </font><font style="vertical-align: inherit;">En cons√©quence, la visibilit√© des cellules environnantes change consid√©rablement. </font><font style="vertical-align: inherit;">Le mouvement de l'escouade semble fluide, mais les changements de visibilit√© sont soudains. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Id√©alement, la visibilit√© devrait √©galement changer en douceur. </font><font style="vertical-align: inherit;">Une fois dans le champ de visibilit√©, les cellules doivent √™tre √©clair√©es progressivement et, en la laissant, s'assombrir progressivement. </font><font style="vertical-align: inherit;">Ou peut-√™tre pr√©f√©rez-vous des transitions instantan√©es? </font><font style="vertical-align: inherit;">Ajoutons √† la </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propri√©t√© qui change les transitions instantan√©es. </font><font style="vertical-align: inherit;">Par d√©faut, les transitions seront fluides.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ImmediateMode { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suivi des cellules de transition </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√™me lors de l'affichage de transitions fluides, les donn√©es de visibilit√© r√©elle restent binaires, c'est-√†-dire que l'effet n'est que visuel. </font><font style="vertical-align: inherit;">Cela signifie que les transitions de visibilit√© doivent √™tre trait√©es </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous lui donnerons une liste de cellules dans lesquelles la transition est effectu√©e. </font><font style="vertical-align: inherit;">Assurez-vous qu'√† chaque initialisation, il est vide.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCellShaderData</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { Texture2D cellTexture; Color32[] cellTextureData; List&lt;HexCell&gt; transitioningCells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexCell&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ImmediateMode { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ transitioningCells.Clear(); enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour le moment, nous d√©finissons </font></font><code>RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">directement les </font><font style="vertical-align: inherit;">donn√©es des cellules </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ceci est toujours correct pour le mode de transition instantan√©e, mais lorsqu'il est d√©sactiv√©, nous devons ajouter une cellule √† la liste des cellules de transition.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = cell.Index; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ImmediateMode) { cellTextureData[index].r = cell.IsVisible ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; cellTextureData[index].g = cell.IsExplored ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { transitioningCells.Add(cell); } enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La visibilit√© ne semble plus fonctionner, car pour l'instant, nous ne faisons rien avec les cellules de la liste. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Boucle √† travers les cellules en boucle </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au lieu de r√©gler instantan√©ment les valeurs correspondantes sur 255 ou 0, nous augmenterons / diminuerons ces valeurs progressivement. </font><font style="vertical-align: inherit;">La fluidit√© de la transition d√©pend du taux de changement. </font><font style="vertical-align: inherit;">Cela ne devrait pas √™tre tr√®s rapide et pas tr√®s lent. </font><font style="vertical-align: inherit;">Un bon compromis entre de belles transitions et la commodit√© du jeu est de changer en une seconde. </font><font style="vertical-align: inherit;">Fixons une constante pour que cela soit plus facile √† changer.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> transitionSpeed = <span class="hljs-number"><span class="hljs-number">255f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, </font></font><code>LateUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous pouvons d√©finir le delta appliqu√© aux valeurs. </font><font style="vertical-align: inherit;">Pour ce faire, multipliez le delta temporel par la vitesse. </font><font style="vertical-align: inherit;">Il doit s'agir d'un entier car nous ne savons pas quelle taille il peut avoir. </font><font style="vertical-align: inherit;">Une forte baisse de la fr√©quence d'images peut rendre le delta sup√©rieur √† 255. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, nous devons mettre √† jour lorsqu'il y a des cellules de transition. </font><font style="vertical-align: inherit;">Par cons√©quent, le code doit √™tre inclus tant qu'il y a quelque chose dans la liste.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LateUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(Time.deltaTime * transitionSpeed); cellTexture.SetPixels32(cellTextureData); cellTexture.Apply(); enabled = transitioningCells.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âgalement th√©oriquement possible des fr√©quences d'images tr√®s √©lev√©es. </font><font style="vertical-align: inherit;">En combinaison avec une faible vitesse de transition, cela peut nous donner un delta de 0. Pour que le changement ait lieu, nous for√ßons le delta minimum √† 1.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(Time.deltaTime * transitionSpeed); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta == <span class="hljs-number"><span class="hljs-number">0</span></span>) { delta = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir re√ßu le delta, nous pouvons boucler autour de toutes les cellules de transition et mettre √† jour leurs donn√©es. </font><font style="vertical-align: inherit;">Supposons que nous ayons une m√©thode pour cela </font></font><code>UpdateCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dont les param√®tres sont la cellule et le delta correspondants.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(Time.deltaTime * transitionSpeed); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta == <span class="hljs-number"><span class="hljs-number">0</span></span>) { delta = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; transitioningCells.Count; i++) { UpdateCellData(transitioningCells[i], delta); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä un moment donn√©, la transition cellulaire devrait se terminer. </font><font style="vertical-align: inherit;">Supposons que la m√©thode renvoie des informations indiquant si la transition est toujours en cours. </font><font style="vertical-align: inherit;">Lorsque cela cesse, nous pouvons supprimer la cellule de la liste. </font><font style="vertical-align: inherit;">Apr√®s cela, nous devons d√©cr√©menter l'it√©rateur afin de ne pas sauter les cellules.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; transitioningCells.Count; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!UpdateCellData(transitioningCells[i], delta)) { transitioningCells.RemoveAt(i--); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'ordre dans lequel les cellules de transition sont trait√©es n'est pas important. </font><font style="vertical-align: inherit;">Par cons√©quent, nous n'avons pas √† supprimer la cellule √† l'index en cours, ce qui forcerait </font></font><code>RemoveAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">toutes les cellules </font><font style="vertical-align: inherit;">√† se </font><font style="vertical-align: inherit;">d√©placer apr√®s lui. </font><font style="vertical-align: inherit;">Au lieu de cela, nous d√©pla√ßons la derni√®re cellule vers l'index en cours, puis supprimons la derni√®re.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!UpdateCellData(transitioningCells[i], delta)) { transitioningCells[i--] = transitioningCells[transitioningCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; transitioningCells.RemoveAt(transitioningCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons maintenant cr√©er une m√©thode </font></font><code>UpdateCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pour faire son travail, il aura besoin d'un index et de donn√©es de cellule, alors commen√ßons par les obtenir. </font><font style="vertical-align: inherit;">Il doit √©galement d√©terminer s'il convient de poursuivre la mise √† jour de la cellule. </font><font style="vertical-align: inherit;">Par d√©faut, nous supposerons que ce n'est pas n√©cessaire. </font><font style="vertical-align: inherit;">Une fois les travaux termin√©s, il est n√©cessaire d'appliquer les donn√©es modifi√©es et de renvoyer l'√©tat "la mise √† jour se poursuit".</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = cell.Index; Color32 data = cellTextureData[index]; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> stillUpdating = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; cellTextureData[index] = data; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stillUpdating; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mise √† jour des donn√©es de cellule </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A ce stade, nous avons une cellule en transition ou d√©j√† termin√©e. </font><font style="vertical-align: inherit;">Tout d'abord, v√©rifions l'√©tat de la sonde cellulaire. </font><font style="vertical-align: inherit;">Si la cellule est examin√©e, mais que sa valeur G n'est pas encore √©gale √† 255, alors elle est en cours de transition, nous allons donc surveiller cela.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> stillUpdating = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsExplored &amp;&amp; data.g &lt; <span class="hljs-number"><span class="hljs-number">255</span></span>) { stillUpdating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } cellTextureData[index] = data;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour effectuer la transition, nous ajouterons un delta √† la valeur G de la cellule. </font><font style="vertical-align: inherit;">Les op√©rations arithm√©tiques ne fonctionnent pas avec les octets, elles sont d'abord converties en entier. </font><font style="vertical-align: inherit;">Par cons√©quent, la somme aura le format entier, qui doit √™tre converti en octet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsExplored &amp;&amp; data.g &lt; <span class="hljs-number"><span class="hljs-number">255</span></span>) { stillUpdating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = data.g + delta; data.g = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)t; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mais avant la conversion, vous devez vous assurer que la valeur ne d√©passe pas 255. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = data.g + delta; data.g = t &gt;= <span class="hljs-number"><span class="hljs-number">255</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)t;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ensuite, nous devons faire de m√™me pour la visibilit√©, qui utilise la valeur de R. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsExplored &amp;&amp; data.g &lt; <span class="hljs-number"><span class="hljs-number">255</span></span>) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsVisible &amp;&amp; data.r &lt; <span class="hljs-number"><span class="hljs-number">255</span></span>) { stillUpdating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = data.r + delta; data.r = t &gt;= <span class="hljs-number"><span class="hljs-number">255</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)t; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Puisque la cellule peut redevenir invisible, nous devons v√©rifier s'il est n√©cessaire de diminuer la valeur de R. Cela se produit lorsque la cellule est invisible, mais R est sup√©rieur √† z√©ro. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsVisible) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.r &lt; <span class="hljs-number"><span class="hljs-number">255</span></span>) { stillUpdating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = data.r + delta; data.r = t &gt;= <span class="hljs-number"><span class="hljs-number">255</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)t; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.r &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { stillUpdating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = data.r - delta; data.r = t &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)t; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, il est </font></font><code>UpdateCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pr√™t et les transitions de visibilit√© sont effectu√©es correctement.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transitions de visibilit√©.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Protection contre les √©l√©ments de transition en double </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les transitions fonctionnent, mais des √©l√©ments en double peuvent appara√Ætre dans la liste. </font><font style="vertical-align: inherit;">Cela se produit si l'√©tat de visibilit√© de la cellule change alors qu'elle est encore en transition. </font><font style="vertical-align: inherit;">Par exemple, lorsque la cellule n'est visible pendant le mouvement de l'√©quipe que pendant une courte p√©riode. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En raison de l'apparition d'√©l√©ments dupliqu√©s, la transition de cellule est mise √† jour plusieurs fois par image, ce qui entra√Æne des transitions plus rapides et un travail suppl√©mentaire. </font><font style="vertical-align: inherit;">Nous pouvons √©viter cela en v√©rifiant avant d'ajouter une cellule si elle est d√©j√† dans la liste. </font><font style="vertical-align: inherit;">Cependant, une liste de recherche √† chaque appel</font></font><code>RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">co√ªteux, en particulier lorsque plusieurs transitions cellulaires sont effectu√©es. </font><font style="vertical-align: inherit;">√Ä la place, utilisons un autre canal qui n'a pas encore √©t√© utilis√© pour indiquer si la cellule est en cours de transition, par exemple, la valeur B. Lorsque nous ajoutons une cellule √† la liste, nous lui attribuons la valeur 255 et n'ajoutons que les cellules dont la valeur n'est pas √©gale √† 255.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = cell.Index; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ImmediateMode) { cellTextureData[index].r = cell.IsVisible ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; cellTextureData[index].g = cell.IsExplored ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellTextureData[index].b != <span class="hljs-number"><span class="hljs-number">255</span></span>) { cellTextureData[index].b = <span class="hljs-number"><span class="hljs-number">255</span></span>; transitioningCells.Add(cell); } enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour que cela fonctionne, nous devons r√©initialiser la valeur de B apr√®s la fin de la transition cellulaire. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!stillUpdating) { data.b = <span class="hljs-number"><span class="hljs-number">0</span></span>; } cellTextureData[index] = data; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stillUpdating; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transitions sans doublons.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chargement instantan√© de la visibilit√© </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les changements de visibilit√© sont d√©sormais toujours progressifs, m√™me lors du chargement d'une carte. </font><font style="vertical-align: inherit;">Ceci est illogique, car la carte d√©crit l'√©tat dans lequel les cellules sont d√©j√† visibles, donc la transition est inappropri√©e ici. </font><font style="vertical-align: inherit;">De plus, effectuer des transitions pour les nombreuses cellules visibles d'une grande carte peut ralentir le jeu apr√®s le chargement. </font><font style="vertical-align: inherit;">Par cons√©quent, avant de charger des cellules et des escouades, passons </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">au mode de transition instantan√©e.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ cellShaderData.ImmediateMode = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader, header); } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous red√©finissons donc le r√©glage initial du mode de transition instantan√©e, quel qu'il soit. </font><font style="vertical-align: inherit;">Peut-√™tre qu'il est d√©j√† d√©sactiv√© ou a fait une option de configuration, nous nous souviendrons donc du mode initial et y basculerons apr√®s la fin des travaux.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> originalImmediateMode = cellShaderData.ImmediateMode; cellShaderData.ImmediateMode = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; ‚Ä¶ cellShaderData.ImmediateMode = originalImmediateMode; }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Port√©e d√©pendante de la hauteur </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'√† pr√©sent, nous avons utilis√© une port√©e constante de trois pour toutes les unit√©s, mais en r√©alit√©, c'est plus compliqu√©. Dans le cas g√©n√©ral, nous ne pouvons pas voir l'objet pour deux raisons: soit un obstacle nous emp√™che de le voir, soit l'objet est trop petit ou trop √©loign√©. Dans notre jeu, nous n'impl√©mentons que la limitation de port√©e. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous ne pouvons pas voir ce qui se trouve de l'autre c√¥t√© de la Terre, car la plan√®te nous obscurcit. Nous ne pouvons que voir √† l'horizon. Puisque la plan√®te peut √™tre consid√©r√©e approximativement comme une sph√®re, plus le point de vue est √©lev√©, plus nous pouvons voir de surface, c'est-√†-dire que l'horizon d√©pend de la hauteur.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/071/788/208/0717882082a42e92b14e158876c6e28b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'horizon d√©pend de la hauteur du point de vue. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La visibilit√© limit√©e de nos unit√©s imite l'effet d'horizon cr√©√© par la courbure de la Terre. </font><font style="vertical-align: inherit;">La port√©e de leur examen d√©pend de la taille de la plan√®te et de l'√©chelle de la carte. </font><font style="vertical-align: inherit;">C'est du moins l'explication logique. </font><font style="vertical-align: inherit;">Mais la principale raison de la r√©duction de la port√©e est le gameplay, c'est une limitation appel√©e le brouillard de guerre. </font><font style="vertical-align: inherit;">Cependant, en comprenant la physique sous-jacente au champ de vision, nous pouvons conclure qu'un point de vue √©lev√© devrait avoir une valeur strat√©gique, car il √©loigne l'horizon et vous permet de regarder les obstacles inf√©rieurs. </font><font style="vertical-align: inherit;">Mais jusqu'√† pr√©sent, nous ne l'avons pas mis en ≈ìuvre.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hauteur pour examen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour tenir compte de la hauteur lors de la d√©termination de la port√©e, nous devons conna√Ætre la hauteur. </font><font style="vertical-align: inherit;">Ce sera la hauteur ou le niveau d'eau habituel, selon qu'il s'agit de la cellule terrestre ou de l'eau. </font><font style="vertical-align: inherit;">Ajoutons cela √† la </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propri√©t√©.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ViewElevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation &gt;= waterLevel ? elevation : waterLevel; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais si la hauteur affecte la port√©e, alors avec un changement de la hauteur de vision de la cellule, la situation de visibilit√© peut √©galement changer. </font><font style="vertical-align: inherit;">√âtant donn√© que la cellule a bloqu√© ou bloque d√©sormais la port√©e de plusieurs unit√©s, il n'est pas si facile de d√©terminer ce qui doit √™tre chang√©. </font><font style="vertical-align: inherit;">La cellule elle-m√™me ne pourra pas r√©soudre ce probl√®me, alors laissez-la signaler un changement de situation </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Supposons que vous </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ayez une m√©thode pour cela </font></font><code>ViewElevationChanged</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous l'appellerons lors de la cession </font></font><code>HexCell.Elevation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, si n√©cessaire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevation == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalViewElevation = ViewElevation; elevation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ViewElevation != originalViewElevation) { ShaderData.ViewElevationChanged(); } ‚Ä¶ } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il en va de m√™me </font></font><code>WaterLevel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> WaterLevel { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> waterLevel; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (waterLevel == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalViewElevation = ViewElevation; waterLevel = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ViewElevation != originalViewElevation) { ShaderData.ViewElevationChanged(); } ValidateRivers(); Refresh(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R√©initialiser la visibilit√© </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons maintenant cr√©er une m√©thode </font></font><code>HexCellShaderData.ViewElevationChanged</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">D√©terminer comment une situation de visibilit√© g√©n√©rale change est une t√¢che complexe, en particulier lorsque vous changez plusieurs cellules en m√™me temps. </font><font style="vertical-align: inherit;">Par cons√©quent, nous ne proposerons aucune astuce, mais pr√©voyons simplement de r√©initialiser la visibilit√© de toutes les cellules. </font><font style="vertical-align: inherit;">Ajoutez un champ bool√©en pour savoir si cela doit √™tre fait. </font><font style="vertical-align: inherit;">Dans la m√©thode, nous allons simplement la d√©finir sur true et inclure le composant. </font><font style="vertical-align: inherit;">Quel que soit le nombre de cellules qui ont chang√© simultan√©ment, cela entra√Ænera une seule r√©initialisation.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> needsVisibilityReset; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ViewElevationChanged</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { needsVisibilityReset = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour r√©initialiser les valeurs de visibilit√© de toutes les cellules, vous devez y avoir acc√®s, ce que vous n'avez </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pas. </font><font style="vertical-align: inherit;">D√©l√©guons donc cette responsabilit√© </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pour ce faire, vous devez ajouter √† la </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propri√©t√©, ce qui vous permet de vous r√©f√©rer √† la grille. </font><font style="vertical-align: inherit;">Ensuite, nous pouvons l'utiliser </font></font><code>LateUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour demander une r√©initialisation.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid Grid { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LateUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (needsVisibilityReset) { needsVisibilityReset = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; Grid.ResetVisibility(); } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Passons √† </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: d√©finir le lien vers la grille </font></font><code>HexGrid.Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apr√®s avoir cr√©√© les donn√©es du shader.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; cellShaderData = gameObject.AddComponent&lt;HexCellShaderData&gt;(); cellShaderData.Grid = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; CreateMap(cellCountX, cellCountZ); }</code> </pre> <br> <code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devrait √©galement obtenir une m√©thode </font></font><code>ResetVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour √©liminer toutes les cellules. </font><font style="vertical-align: inherit;">Faites-le contourner toutes les cellules de la boucle et d√©l√©guez-lui la r√©initialisation.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].ResetVisibility(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous devons ajouter √† la </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©thode </font></font><code>ResetVisibilty</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il mettra simplement √† z√©ro la visibilit√© et d√©clenchera la mise √† jour de la visibilit√©. </font><font style="vertical-align: inherit;">Cela doit √™tre fait lorsque la visibilit√© des cellules est sup√©rieure √† z√©ro.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (visibility &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { visibility = <span class="hljs-number"><span class="hljs-number">0</span></span>; ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir r√©initialis√© toutes les donn√©es de visibilit√©, </font></font><code>HexGrid.ResetVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il doit √† nouveau appliquer la visibilit√© √† toutes les escouades, pour lesquelles il doit conna√Ætre la port√©e de chaque escouade. </font><font style="vertical-align: inherit;">Supposons qu'il puisse √™tre obtenu √† l'aide de la propri√©t√© </font></font><code>VisionRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].ResetVisibility(); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; units.Count; i++) { HexUnit unit = units[i]; IncreaseVisibility(unit.Location, unit.VisionRange); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour que cela fonctionne, nous allons refactoriser le changement </font></font><code>HexUnit.visionRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de </font><font style="vertical-align: inherit;">nom </font></font><code>HexUnit.VisionRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et le transformer en propri√©t√©. </font><font style="vertical-align: inherit;">Bien qu'il recevra une valeur constante de 3, mais √† l'avenir, il changera.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> VisionRange { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour cette raison, les donn√©es de visibilit√© seront r√©initialis√©es et resteront correctes apr√®s avoir modifi√© la hauteur de visualisation des cellules. </font><font style="vertical-align: inherit;">Mais il est probable que nous allons changer les r√®gles pour d√©terminer la port√©e et ex√©cuter la recompilation en mode Play. </font><font style="vertical-align: inherit;">Pour que l'√©tendue change ind√©pendamment, ex√©cutons une r√©initialisation </font></font><code>HexGrid.OnEnable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lorsque la recompilation est d√©tect√©e.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { ‚Ä¶ ResetVisibility(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vous pouvez maintenant modifier le code de port√©e et voir les r√©sultats, tout en restant en mode Lecture. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √âlargir l'horizon </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le calcul de la port√©e est d√©termin√© </font></font><code>HexGrid.GetVisibleCells</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pour que la hauteur affecte la port√©e, nous pouvons simplement utiliser la hauteur de vision en </font></font><code>fromCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">red√©finissant temporairement la zone transmise. </font><font style="vertical-align: inherit;">Nous pouvons donc facilement v√©rifier si cela fonctionne.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">List&lt;HexCell&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetVisibleCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> range</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ range = fromCell.ViewElevation; fromCell.SearchPhase = searchFrontierPhase; fromCell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(fromCell); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/727/032/6d3/7270326d379796f2b4f2f3c3ca65512c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisez la hauteur comme port√©e.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Obstacles √† la visibilit√© </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'application d'une hauteur de visualisation en tant que port√©e ne fonctionne correctement que lorsque toutes les autres cellules sont √† une hauteur nulle. </font><font style="vertical-align: inherit;">Mais si toutes les cellules ont la m√™me hauteur que le point de vue, alors le champ de vision doit √™tre nul. </font><font style="vertical-align: inherit;">De plus, les cellules avec des hauteurs √©lev√©es devraient bloquer la visibilit√© des cellules basses derri√®re elles. </font><font style="vertical-align: inherit;">Jusqu'√† pr√©sent, rien de tout cela n'a √©t√© mis en ≈ìuvre.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de8/7be/a6f/de87bea6f4b88cd61765450a63f738f9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La port√©e n'interf√®re pas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La fa√ßon la plus correcte de d√©terminer la port√©e serait de v√©rifier par l'√©mission de rayons, mais cela deviendrait rapidement co√ªteux et produirait encore des r√©sultats √©tranges. </font><font style="vertical-align: inherit;">Nous avons besoin d'une solution rapide qui cr√©e des r√©sultats suffisamment bons qui ne doivent pas n√©cessairement √™tre parfaits. </font><font style="vertical-align: inherit;">De plus, il est important que les r√®gles de d√©termination de la port√©e soient simples, intuitives et pr√©visibles pour les joueurs. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notre solution sera la suivante - lors de la d√©termination de la visibilit√© d'une cellule, nous ajouterons la hauteur de vision de la cellule voisine √† la distance parcourue. </font><font style="vertical-align: inherit;">En fait, cela r√©duit la port√©e lorsque nous regardons ces cellules, et si elles sont ignor√©es, cela ne nous permettra pas d'atteindre les cellules derri√®re elles.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance + neighbor.ViewElevation &gt; range) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/774/44c/efe/77444cefe82d428ee32e094213e82a1a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les cellules hautes bloquent la vue.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ne devrions-nous pas voir de grandes cellules au loin?</font></font></b> <div class="spoiler_text">      ,     ,   ,   .       ,       . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ne regardez pas dans les coins </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il semble maintenant que les cellules hautes bloquent la vue √† un niveau bas, mais parfois la port√©e p√©n√®tre √† travers elles, bien qu'il semble que cela ne devrait pas √™tre le cas. </font><font style="vertical-align: inherit;">Cela se produit car l'algorithme de recherche trouve toujours un chemin vers ces cellules, contournant les cellules bloquantes. </font><font style="vertical-align: inherit;">En cons√©quence, il semble que notre zone de visibilit√© puisse contourner les obstacles. </font><font style="vertical-align: inherit;">Pour √©viter cela, nous devons nous assurer que seuls les chemins les plus courts sont pris en compte lors de la d√©termination de la visibilit√© des cellules. </font><font style="vertical-align: inherit;">Cela peut √™tre fait en supprimant les chemins qui deviennent plus longs que n√©cessaire.</font></font><br><br><pre> <code class="cs hljs"> HexCoordinates fromCoordinates = fromCell.coordinates; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance + neighbor.ViewElevation &gt; range || distance &gt; fromCoordinates.DistanceTo(neighbor.coordinates) ) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ‚Ä¶ } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30d/bfa/1c2/30dbfa1c2df2fb6119249f00cdc3d8d8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous utilisons uniquement les chemins les plus courts.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous avons donc corrig√© la plupart des cas manifestement erron√©s. Pour les cellules voisines, cela fonctionne bien, car il n'y a que les chemins les plus courts vers elles. Les cellules plus √©loign√©es ont plus d'options pour les trajets; par cons√©quent, sur de longues distances, une enveloppe de visibilit√© peut toujours se produire. Ce ne sera pas un probl√®me si les zones de visibilit√© restent petites et que les diff√©rences de hauteur adjacentes ne sont pas trop importantes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et enfin, au lieu de remplacer le champ de vision transmis, nous y ajoutons la hauteur de la vue. Le propre champ de vision de l‚Äôescouade indique sa hauteur, son altitude de vol ou ses capacit√©s de reconnaissance.</font></font><br><br><pre> <code class="cs hljs"> range += fromCell.ViewElevation;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ff/1ce/a2b/3ff1cea2b833bda69990576fa8323aec.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vue avec plein champ de vision √† un point de vue bas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est-√†-dire que les derni√®res r√®gles de visibilit√© s'appliquent √† la vision lors du d√©placement sur le chemin le plus court vers le champ de vision, en tenant compte de la diff√©rence de hauteur de cellule par rapport au point de vue. </font><font style="vertical-align: inherit;">Lorsqu'une cellule est hors de port√©e, elle bloque tous les chemins la traversant. </font><font style="vertical-align: inherit;">En cons√©quence, les points d'observation √©lev√©s, d'o√π rien n'emp√™che la vue, deviennent strat√©giquement pr√©cieux.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'en est-il de g√™ner la visibilit√© des objets?</font></font></b> <div class="spoiler_text">  ,        ,  . ,  ,        .          . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cellules qui ne peuvent pas √™tre explor√©es </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le dernier probl√®me de visibilit√© concerne les bords de la carte. </font><font style="vertical-align: inherit;">Le relief se termine brusquement et sans transitions, car les cellules en bordure n'ont pas de voisins.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/587/217/fbb/587217fbb248ae8a13759a33e22e25ff.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bord marqu√© de la carte.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Id√©alement, l'affichage visuel des zones et des bords inexplor√©s de la carte devrait √™tre le m√™me. Nous pouvons y parvenir en ajoutant des cas sp√©ciaux lors de la triangulation des bords, lorsqu'ils n'ont pas de voisins, mais cela n√©cessitera une logique suppl√©mentaire et nous devrons travailler avec des cellules manquantes. Par cons√©quent, une telle solution n'est pas triviale. Une autre approche consiste √† forcer les cellules limites de la carte √† √™tre inexplor√©es, m√™me si elles sont dans la port√©e de l'escouade. Cette approche est beaucoup plus simple, alors utilisons-la. Il vous permet √©galement de marquer comme inexplor√© et d'autres cellules, ce qui facilite la cr√©ation de bords in√©gaux de la carte. De plus, les cellules cach√©es sur les bords vous permettent de cr√©er des routes et des rivi√®res qui entrent et sortent de la carte de la rivi√®re et de la route, car leurs points d'extr√©mit√© seront hors de port√©e.De plus, avec l'aide de cette solution, vous pouvez ajouter des unit√©s entrant et sortant de la carte.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous marquons les cellules comme enqu√™t√©es </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour indiquer qu'une cellule peut √™tre examin√©e, ajoutez √† la </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propri√©t√© </font></font><code>Explorable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Explorable { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©sormais, une cellule peut √™tre visible si elle fait l'objet d'une enqu√™te. </font></font><code>IsVisible</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous allons donc </font><font style="vertical-align: inherit;">modifier la propri√©t√© </font><font style="vertical-align: inherit;">pour en tenir compte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsVisible { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> visibility &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; Explorable; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La m√™me chose s'applique √† </font></font><code>IsExplored</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cependant, pour cela, nous avons √©tudi√© la propri√©t√© standard. </font><font style="vertical-align: inherit;">Nous devons le convertir en une propri√©t√© explicite afin de pouvoir changer la logique de son getter.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsExplored { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> explored &amp;&amp; Explorable; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { explored = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> explored;</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Masquer le bord de la carte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez masquer le bord d'une carte rectangulaire dans la m√©thode </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Les cellules qui ne sont pas sur le bord sont √©tudi√©es, tout le reste est inexplor√©.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ HexCell cell = cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab); cell.transform.localPosition = position; cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); cell.Index = i; cell.ShaderData = cellShaderData; cell.Explorable = x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; x &lt; cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; z &lt; cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, les cartes sont assombries sur les bords, se cachant derri√®re elles d'immenses espaces inexplor√©s. </font><font style="vertical-align: inherit;">Par cons√©quent, la taille de la zone √©tudi√©e des cartes diminue de deux dans chaque dimension.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/594/19f/353/59419f35345fa4eac3380c4e16461baf.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bord inexplor√© de la carte.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Est-il possible de rendre l'√©tat de la recherche modifiable?</font></font></b> <div class="spoiler_text"> ,  ,     .          . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Des cellules inexplor√©es nuisent √† la visibilit√© </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin, si la cellule ne peut pas √™tre examin√©e, elle devrait nuire √† la visibilit√©. </font><font style="vertical-align: inherit;">Modifiez </font></font><code>HexGrid.GetVisibleCells</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour en tenir compte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.SearchPhase &gt; searchFrontierPhase || !neighbor.Explorable ) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partie 23: g√©n√©rer des terres </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Remplissez de nouvelles cartes avec des paysages g√©n√©r√©s. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous √©levons des terres au-dessus de l'eau, nous en inondons. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous contr√¥lons la quantit√© de terrain cr√©√©, sa hauteur et ses irr√©gularit√©s. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous ajoutons la prise en charge de diverses options de configuration pour cr√©er des cartes variables. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous faisons en sorte que la m√™me carte puisse √™tre g√©n√©r√©e √† nouveau. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette partie du didacticiel sera le d√©but d'une s√©rie sur la g√©n√©ration de cartes proc√©durales. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette partie a √©t√© cr√©√©e dans Unity 2017.1.0.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99e/798/7bb/99e7987bbcb46f1f961b72ba76a78aa0.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'une des nombreuses cartes g√©n√©r√©es.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> G√©n√©ration de cartes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que nous puissions cr√©er n'importe quelle carte, cela prend beaucoup de temps. Il serait pratique que l'application puisse aider le concepteur en g√©n√©rant pour lui des cartes qu'il pourra ensuite modifier √† son go√ªt. Vous pouvez prendre une autre √©tape et vous d√©barrasser compl√®tement de la cr√©ation manuelle de la conception, transf√©rant compl√®tement la responsabilit√© de g√©n√©rer la carte finie √† l'application. Pour cette raison, le jeu peut √™tre jou√© √† chaque fois avec une nouvelle carte et chaque session de jeu sera diff√©rente. Pour que tout cela soit possible, nous devons cr√©er un algorithme de g√©n√©ration de carte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le type d'algorithme de g√©n√©ration dont vous avez besoin d√©pend du type de carte dont vous avez besoin. Il n'y a pas de bonne approche, il faut toujours chercher un compromis entre cr√©dibilit√© et jouabilit√©.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour qu'une carte soit cr√©dible, elle doit sembler tout √† fait possible et r√©elle au joueur. Cela ne signifie pas que la carte doit ressembler √† une partie de notre plan√®te. Ce peut √™tre une plan√®te diff√©rente ou une r√©alit√© compl√®tement diff√©rente. Mais s'il doit indiquer le relief de la Terre, il doit lui ressembler au moins partiellement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La jouabilit√© est li√©e √† la fa√ßon dont les cartes correspondent au gameplay. Parfois, cela entre en conflit avec la cr√©dibilit√©. Par exemple, bien que les cha√Ænes de montagnes puissent √™tre belles, en m√™me temps, elles limitent consid√©rablement le mouvement et la vue des unit√©s. Si cela n'est pas souhaitable, vous devez vous passer de montagnes, ce qui r√©duira la cr√©dibilit√© et limiter l'expressivit√© du jeu. Ou nous pouvons sauver les montagnes, mais r√©duire leur impact sur le gameplay, ce qui peut √©galement r√©duire la cr√©dibilit√©.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, la faisabilit√© doit √™tre consid√©r√©e. Par exemple, vous pouvez cr√©er une plan√®te semblable √† la terre tr√®s r√©aliste en simulant des plaques tectoniques, l'√©rosion, les pluies, les √©ruptions volcaniques, les effets des m√©t√©orites et de la lune, etc. Mais le d√©veloppement d'un tel syst√®me demandera beaucoup de temps. De plus, la g√©n√©ration d'une telle plan√®te peut prendre beaucoup de temps et les joueurs ne voudront pas attendre quelques minutes avant de commencer une nouvelle partie. Autrement dit, la simulation est un outil puissant, mais elle a un prix.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les jeux utilisent souvent des compromis entre cr√©dibilit√©, jouabilit√© et faisabilit√©. Parfois, ces compromis sont invisibles et semblent tout √† fait normaux, et parfois ils semblent al√©atoires, incoh√©rents ou chaotiques, selon les d√©cisions prises au cours du processus de d√©veloppement. Cela s'applique non seulement √† la g√©n√©ration de cartes, mais lors du d√©veloppement d'un g√©n√©rateur de cartes proc√©dural, vous devez y pr√™ter une attention particuli√®re. Vous pouvez passer beaucoup de temps √† cr√©er un algorithme qui g√©n√®re de belles cartes qui s'av√®rent inutiles pour le jeu que vous cr√©ez.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cette s√©rie de didacticiels, nous allons cr√©er un relief semblable √† la terre. </font><font style="vertical-align: inherit;">Il devrait √™tre int√©ressant, avec une grande variabilit√© et l'absence de grandes zones homog√®nes. </font><font style="vertical-align: inherit;">L'√©chelle du relief sera grande, les cartes couvriront un ou plusieurs continents, r√©gions des oc√©ans ou m√™me une plan√®te enti√®re. </font><font style="vertical-align: inherit;">Nous devons contr√¥ler la g√©ographie, y compris les masses terrestres, le climat, le nombre de r√©gions et les bosses du terrain. </font><font style="vertical-align: inherit;">Dans cette partie, nous allons jeter les bases de la cr√©ation de sushi.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D√©marrer en mode √©dition </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous allons nous concentrer sur la carte, pas sur le gameplay, il sera donc plus pratique de lancer l'application en mode √©dition. </font><font style="vertical-align: inherit;">Gr√¢ce √† cela, nous pouvons imm√©diatement voir les cartes. </font><font style="vertical-align: inherit;">Par cons√©quent, nous allons changer en </font></font><code>HexMapEditor.Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©finissant le mode d'√©dition sur true et en activant le mot-cl√© shader de ce mode.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrainMaterial.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); Shader.EnableKeyword(<span class="hljs-string"><span class="hljs-string">"HEX_MAP_EDIT_MODE"</span></span>); SetEditMode(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> G√©n√©rateur de cartes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtant donn√© que beaucoup de code est n√©cessaire pour g√©n√©rer des cartes proc√©durales, nous ne les ajouterons pas directement √† </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Au lieu de cela, nous allons cr√©er un nouveau composant </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous ne le saurons pas. </font><font style="vertical-align: inherit;">Cela simplifiera la transition vers un autre algorithme si nous en avons besoin. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le g√©n√©rateur a besoin d'un lien vers la grille, nous allons donc lui ajouter un champ g√©n√©ral. </font><font style="vertical-align: inherit;">De plus, nous ajoutons une m√©thode g√©n√©rale </font></font><code>GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui traitera du travail de l'algorithme. </font><font style="vertical-align: inherit;">Nous allons lui donner les dimensions de la carte en tant que param√®tres, puis la forcer √† √™tre utilis√©e pour cr√©er une nouvelle carte vide.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexMapGenerator</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid grid; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { grid.CreateMap(x, z); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez un objet avec un composant √† la sc√®ne </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et connectez-le √† la grille.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/932/b6e/fd2/932b6efd2dd1809893af27ec7a91c620.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objet g√©n√©rateur de carte.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Changer le menu d'une nouvelle carte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous allons le changer </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">afin qu'il puisse g√©n√©rer des cartes, pas seulement en cr√©er des vides. </font><font style="vertical-align: inherit;">Nous contr√¥lerons sa fonctionnalit√© via un champ bool√©en </font></font><code>generateMaps</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui par d√©faut a une valeur </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cr√©ons une m√©thode g√©n√©rale pour d√©finir ce champ, comme nous l'avons fait pour changer d'options </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ajoutez le commutateur appropri√© au menu et connectez-le √† la m√©thode.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> generateMaps = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleMapGeneration</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { generateMaps = toggle; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc9/9c7/0c9/fc99c70c99095b3565104ef42254859d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menu d'une nouvelle carte avec un interrupteur. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Donnez au menu un lien vers le g√©n√©rateur de carte. </font><font style="vertical-align: inherit;">Ensuite, nous le forcerons √† appeler la m√©thode du </font></font><code>GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g√©n√©rateur </font><font style="vertical-align: inherit;">si n√©cessaire </font><font style="vertical-align: inherit;">, et pas seulement √† ex√©cuter la </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grille.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMapGenerator mapGenerator; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (generateMaps) { mapGenerator.GenerateMap(x, z); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hexGrid.CreateMap(x, z); } HexMapCamera.ValidatePosition(); Close(); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d1/e98/3d9/7d1e983d927d912b75d9b245219659f1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connexion au g√©n√©rateur.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Acc√®s cellulaire </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour que le g√©n√©rateur fonctionne, il doit avoir acc√®s aux cellules. </font><font style="vertical-align: inherit;">Nous </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avons d√©j√† des </font><font style="vertical-align: inherit;">m√©thodes communes </font></font><code>GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui n√©cessitent ou vecteur de position, ou les </font><font style="vertical-align: inherit;">coordonn√©es hexagonaux. </font><font style="vertical-align: inherit;">Le g√©n√©rateur n'a pas besoin de fonctionner avec l'un ou l'autre, nous ajoutons donc deux m√©thodes pratiques </font></font><code>HexGrid.GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui fonctionneront avec les coordonn√©es du d√©calage ou de l'index de la cellule.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xOffset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zOffset</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cells[xOffset + zOffset * cellCountX]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cellIndex</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cells[cellIndex]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, il </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut recevoir directement des cellules. </font><font style="vertical-align: inherit;">Par exemple, apr√®s avoir cr√©√© une nouvelle carte, il peut utiliser les coordonn√©es de l'herbe pour d√©finir l'herbe comme relief de la colonne centrale des cellules.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { grid.CreateMap(x, z); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; z; i++) { grid.GetCell(x / <span class="hljs-number"><span class="hljs-number">2</span></span>, i).TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/860/aee/119/860aee119f0e000ef290f6c87e61ad05.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colonne d'herbe sur une petite carte. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Faire des sushis </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de la g√©n√©ration d'une carte, nous commen√ßons compl√®tement sans terrain. </font><font style="vertical-align: inherit;">On peut imaginer que le monde entier est inond√© d'un immense oc√©an. </font><font style="vertical-align: inherit;">Une terre est cr√©√©e lorsqu'une partie du plancher oc√©anique est tellement √©lev√©e qu'elle s'√©l√®ve au-dessus de l'eau. </font><font style="vertical-align: inherit;">Nous devons d√©cider combien de terres devraient √™tre cr√©√©es de cette fa√ßon, o√π elles appara√Ætront et quelle forme elles auront.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Augmentez le soulagement </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commen√ßons petit - √©lever un morceau de terre au-dessus de l'eau. </font><font style="vertical-align: inherit;">Nous cr√©ons pour cela une m√©thode </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec un param√®tre pour contr√¥ler la taille du trac√©. </font><font style="vertical-align: inherit;">Appelez cette m√©thode dans </font></font><code>GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en rempla√ßant le code de test pr√©c√©dent. </font><font style="vertical-align: inherit;">Commen√ßons par un petit terrain compos√© de sept cellules.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { grid.CreateMap(x, z); <span class="hljs-comment"><span class="hljs-comment">// for (int i = 0; i &lt; z; i++) { // grid.GetCell(x / 2, i).TerrainTypeIndex = 1; // } RaiseTerrain(7); } void RaiseTerrain (int chunkSize) {}</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'√† pr√©sent, nous utilisons le relief de type ¬´herbe¬ª pour d√©signer la terre √©lev√©e, et le relief ¬´sable¬ª d'origine se r√©f√®re √† l'oc√©an. </font><font style="vertical-align: inherit;">Faites-nous </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prendre une cellule au hasard et changez le type de son relief jusqu'√† ce que nous obtenions la bonne quantit√© de terrain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour obtenir une cellule al√©atoire, nous ajoutons une m√©thode </font></font><code>GetRandomCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui d√©termine un indice de cellule al√©atoire et obtient la cellule correspondante √† partir de la grille.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunkSize; i++) { GetRandomCell().TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grid.GetCell(Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, grid.cellCountX * grid.cellCountZ)); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/396/fb8/ce6/396fb8ce67de74961b31562e275bd81a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sept cellules de sushi al√©atoires. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme √† la fin, nous pourrions avoir besoin de beaucoup de cellules al√©atoires ou parcourir plusieurs fois toutes les cellules, gardons une trace du nombre de cellules dans la cellule elle-m√™me </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cellCount; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { cellCount = x * z; ‚Ä¶ } ‚Ä¶ <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grid.GetCell(Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, cellCount)); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cr√©ation d'un site </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'√† pr√©sent, nous transformons sept cellules al√©atoires en terres, et elles peuvent √™tre n'importe o√π. </font><font style="vertical-align: inherit;">Tr√®s probablement, ils ne forment pas une seule zone terrestre. </font><font style="vertical-align: inherit;">De plus, nous pouvons s√©lectionner plusieurs fois les m√™mes cellules, donc nous obtenons moins de terrain. </font><font style="vertical-align: inherit;">Pour r√©soudre les deux probl√®mes, sans restrictions, nous s√©lectionnerons uniquement la premi√®re cellule. </font><font style="vertical-align: inherit;">Apr√®s cela, nous devons s√©lectionner uniquement les cellules qui sont √† c√¥t√© de celles s√©lectionn√©es pr√©c√©demment. </font><font style="vertical-align: inherit;">Ces restrictions sont similaires aux limitations de la recherche de chemin, nous utilisons donc la m√™me approche ici. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous ajoutons </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">notre propre propri√©t√© et le compteur de la phase de la fronti√®re de recherche, comme c'√©tait le cas </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> HexCellPriorityQueue searchFrontier; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> searchFrontierPhase;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V√©rifiez que la file d'attente prioritaire existe avant d'en avoir besoin. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { cellCount = x * z; grid.CreateMap(x, z); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } RaiseTerrain(<span class="hljs-number"><span class="hljs-number">7</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir cr√©√© une nouvelle carte, la limite de recherche pour toutes les cellules est nulle. Mais si nous allons rechercher des cellules dans le processus de g√©n√©ration de carte, nous augmenterons leur fronti√®re de recherche dans ce processus. Si nous effectuons de nombreuses op√©rations de recherche, elles peuvent √™tre en avance sur la phase de la limite de recherche enregistr√©e </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Cela peut interf√©rer avec la recherche de chemins d'unit√©. Pour √©viter cela, √† la fin du processus de g√©n√©ration de carte, nous remettrons √† z√©ro la phase de recherche de toutes les cellules.</font></font><br><br><pre> <code class="cs hljs"> RaiseTerrain(<span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { grid.GetCell(i).SearchPhase = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, je </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dois chercher les cellules appropri√©es et ne pas les s√©lectionner au hasard. Ce processus est tr√®s similaire √† la m√©thode de recherche dans </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Cependant, nous ne visiterons pas les cellules plus d'une fois, il nous suffira donc d'augmenter la phase de la bordure de recherche de 1 au lieu de 2. Ensuite, nous initialisons la bordure avec la premi√®re cellule, qui est s√©lectionn√©e au hasard. Comme d'habitude, en plus de d√©finir sa phase de recherche, nous attribuons sa distance et son heuristique √† z√©ro.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// for (int i = 0; i &lt; chunkSize; i++) { // GetRandomCell().TerrainTypeIndex = 1; // } searchFrontierPhase += 1; HexCell firstCell = GetRandomCell(); firstCell.SearchPhase = searchFrontierPhase; firstCell.Distance = 0; firstCell.SearchHeuristic = 0; searchFrontier.Enqueue(firstCell); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s cela, la boucle de recherche nous sera pour la plupart famili√®re. </font><font style="vertical-align: inherit;">De plus, pour continuer la recherche jusqu'√† ce que la bordure soit vide, nous devons nous arr√™ter lorsque le fragment atteint la taille souhait√©e, nous allons donc le suivre. </font><font style="vertical-align: inherit;">√Ä chaque it√©ration, nous allons extraire la cellule suivante de la file d'attente, d√©finir le type de son relief, augmenter la taille, puis contourner les voisins de cette cellule. </font><font style="vertical-align: inherit;">Tous les voisins sont simplement ajout√©s √† la fronti√®re s'ils n'y ont pas encore √©t√© ajout√©s. </font><font style="vertical-align: inherit;">Nous n'avons pas besoin de faire de changements ou de comparaisons. </font><font style="vertical-align: inherit;">Apr√®s avoir termin√©, vous devez effacer la fronti√®re.</font></font><br><br><pre> <code class="cs hljs"> searchFrontier.Enqueue(firstCell); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (size &lt; chunkSize &amp;&amp; searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); current.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; size += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; neighbor.SearchPhase &lt; searchFrontierPhase) { neighbor.SearchPhase = searchFrontierPhase; neighbor.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; neighbor.SearchHeuristic = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(neighbor); } } } searchFrontier.Clear();</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97a/f44/023/97af440236cb6909130d6a8bfaab3f5a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une ligne de cellules. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons obtenu une seule parcelle de la bonne taille. </font><font style="vertical-align: inherit;">Il ne sera plus petit que s'il n'y a pas un nombre suffisant de cellules. </font><font style="vertical-align: inherit;">En raison de la fa√ßon dont la fronti√®re est remplie, le trac√© se compose toujours d'une ligne allant vers le nord-ouest. </font><font style="vertical-align: inherit;">Il ne change de direction que lorsqu'il atteint le bord de la carte.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous connectons les cellules </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les zones terrestres ressemblent rarement √† des lignes, et si elles le font, elles ne sont pas toujours orient√©es de la m√™me mani√®re. </font><font style="vertical-align: inherit;">Pour changer la forme du site, nous devons changer les priorit√©s des cellules. </font><font style="vertical-align: inherit;">La premi√®re cellule al√©atoire peut √™tre utilis√©e comme centre du trac√©. </font><font style="vertical-align: inherit;">La distance √† toutes les autres cellules sera alors relative √† ce point. </font><font style="vertical-align: inherit;">Nous accorderons donc une priorit√© plus √©lev√©e aux cellules plus proches du centre, de sorte que le site ne se d√©veloppera pas en ligne, mais autour du centre.</font></font><br><br><pre> <code class="cs hljs"> searchFrontier.Enqueue(firstCell); HexCoordinates center = firstCell.coordinates; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (size &lt; chunkSize &amp;&amp; searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); current.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; size += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; neighbor.SearchPhase &lt; searchFrontierPhase) { neighbor.SearchPhase = searchFrontierPhase; neighbor.Distance = neighbor.coordinates.DistanceTo(center); neighbor.SearchHeuristic = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(neighbor); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/841/117/149/84111714960a293415b1d24edf92f56b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'accumulation de cellules. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et en fait, maintenant nos sept cellules sont joliment emball√©es dans une zone hexagonale compacte si la cellule centrale n'appara√Æt pas sur le bord de la carte. </font><font style="vertical-align: inherit;">Essayons maintenant d'utiliser une taille de trac√© de 30.</font></font><br><br><pre> <code class="cs hljs"> RaiseTerrain(<span class="hljs-number"><span class="hljs-number">30</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/893/c36/13e/893c3613edfe02b457cc4ee6d191072c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masse de sushi en 30 cellules. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons de nouveau la m√™me forme, bien qu'il n'y ait pas assez de cellules pour obtenir le bon hexagone. </font><font style="vertical-align: inherit;">√âtant donn√© que le rayon du trac√© est plus grand, il est plus susceptible d'√™tre proche du bord de la carte, ce qui l'obligera √† prendre une forme diff√©rente.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Randomisation des sushis </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous ne voulons pas que toutes les zones soient identiques, nous allons donc modifier l√©g√®rement les priorit√©s des cellules. </font><font style="vertical-align: inherit;">Chaque fois que nous ajoutons une cellule voisine √† la bordure, si le nombre suivant est </font></font><code>Random.value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inf√©rieur √† une certaine valeur de seuil, l'heuristique de cette cellule devient non pas 0, mais 1. Utilisons la valeur 0,5 comme seuil, c'est-√†-dire qu'elle affectera tr√®s probablement la moiti√© des cellules.</font></font><br><br><pre> <code class="cs hljs"> neighbor.Distance = neighbor.coordinates.DistanceTo(center); neighbor.SearchHeuristic = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(neighbor);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43e/aec/793/43eaec79315f68e0618fe71c0f93c3f3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zone d√©form√©e.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En augmentant l'heuristique de recherche de la cellule, nous l'avons rendue visite plus tard que pr√©vu. En m√™me temps, d'autres cellules situ√©es un peu plus loin du centre seront visit√©es plus t√¥t, √† moins qu'elles n'augmentent √©galement l'heuristique. Cela signifie que si nous augmentons l'heuristique de toutes les cellules d'une valeur, cela n'affectera pas la carte. Autrement dit, le seuil 1 n'aura pas d'effet, comme le seuil 0. Et le seuil 0,8 sera √©quivalent √† 0,2. Autrement dit, la probabilit√© de 0,5 rend le processus de recherche le plus "tremblant". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La quantit√© d'oscillation appropri√©e d√©pend du type de terrain souhait√©, nous allons donc la personnaliser. Ajouter un champ flottant g√©n√©rique </font></font><code>jitterProbability</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec l'attribut </font><font style="vertical-align: inherit;">au g√©n√©rateur</font></font><code>Range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">limit√© dans la plage de 0 √† 0,5. </font><font style="vertical-align: inherit;">Donnons-lui une valeur par d√©faut √©gale √† la moyenne de cet intervalle, soit 0,25. </font><font style="vertical-align: inherit;">Cela nous permettra de configurer le g√©n√©rateur dans la fen√™tre de l'inspecteur Unity.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 0.5f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> jitterProbability = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/795/b50/381/795b50381d8c9cda219ff092cf64cee5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Probabilit√© de fluctuations. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pouvez-vous le rendre personnalisable dans l'interface utilisateur du jeu?</font></font></b> <div class="spoiler_text">  ,       .           UI,       .          ,      UI.  ,     .         ,       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maintenant, pour d√©cider quand l'heuristique doit √™tre √©gale √† 1, nous utilisons la probabilit√© au lieu d'une valeur constante. </font></font><br><br><pre> <code class="cs hljs"> neighbor.SearchHeuristic = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; jitterProbability ? <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous utilisons des valeurs heuristiques de 0 et 1. Bien que des valeurs plus grandes puissent √™tre utilis√©es, cela aggravera consid√©rablement la d√©formation des sections, les transformant tr√®s probablement en un tas de bandes. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √âlever des terres </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous ne nous limiterons pas √† la g√©n√©ration d'un seul terrain. </font><font style="vertical-align: inherit;">Par exemple, nous pla√ßons un appel </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans une boucle pour obtenir cinq sections.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { RaiseTerrain(<span class="hljs-number"><span class="hljs-number">30</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d42/83f/acd/d4283facd88705107d705290c3d8e78b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cinq parcelles de terrain. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que nous g√©n√©rions maintenant cinq parcelles de 30 cellules chacune, mais pas n√©cessairement exactement 150 cellules de terrain. </font><font style="vertical-align: inherit;">√âtant donn√© que chaque site est cr√©√© s√©par√©ment, ils ne se connaissent pas, ils peuvent donc se croiser. </font><font style="vertical-align: inherit;">C'est normal car cela peut cr√©er des paysages plus int√©ressants qu'un simple ensemble de sections isol√©es. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour augmenter la variabilit√© des terres, nous pouvons √©galement changer la taille de chaque parcelle. </font><font style="vertical-align: inherit;">Ajoutez deux champs entiers pour contr√¥ler les tailles minimale et maximale des trac√©s. </font><font style="vertical-align: inherit;">Attribuez-leur un intervalle suffisamment grand, par exemple 20-200. </font><font style="vertical-align: inherit;">Je ferai le minimum standard √©gal √† 30, et le maximum standard - 100.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(20, 200)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSizeMin = <span class="hljs-number"><span class="hljs-number">30</span></span>; [Range(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSizeMax = <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ea/026/e43/9ea026e43e949f571be0358332447de5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intervalle de dimensionnement. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous utilisons ces champs pour d√©terminer al√©atoirement la taille de la zone lors de l'appel </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> RaiseTerrain(Random.Range(chunkSizeMin, chunkSizeMax + <span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0df/124/dab/0df124dab1f706825f75304d2862aea3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cinq sections de taille al√©atoire sur la carte du milieu.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cr√©ez suffisamment de sushis </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Certes, on ne peut pas particuli√®rement contr√¥ler la quantit√© de terrain g√©n√©r√©e. </font><font style="vertical-align: inherit;">Bien que nous puissions ajouter l'option de configuration pour le nombre de parcelles, les parcelles elles-m√™mes sont de taille al√©atoire et peuvent se chevaucher l√©g√®rement ou fortement. </font><font style="vertical-align: inherit;">Par cons√©quent, le nombre de sites ne garantit pas la r√©ception sur la carte de la quantit√© de terrain requise. </font><font style="vertical-align: inherit;">Ajoutons une option pour contr√¥ler directement le pourcentage de terrain exprim√© en nombre entier. </font><font style="vertical-align: inherit;">√âtant donn√© que 100% de la terre ou de l'eau n'est pas tr√®s int√©ressant, nous le limitons √† l'intervalle 5‚Äì95, avec une valeur de 50 par d√©faut.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(5, 95)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landPercentage = <span class="hljs-number"><span class="hljs-number">50</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21e/281/912/21e281912ad5a4a5378c5e55514c639c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourcentage de sushi. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour garantir la cr√©ation de la bonne quantit√© de terrain, il nous suffit de continuer √† √©lever des zones du terrain jusqu'√† ce que nous obtenions une quantit√© suffisante. </font><font style="vertical-align: inherit;">Pour ce faire, nous devons contr√¥ler le processus, ce qui compliquera la g√©n√©ration de terres. </font><font style="vertical-align: inherit;">Par cons√©quent, rempla√ßons le cycle existant de cr√©ation de sites en appelant une nouvelle m√©thode </font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La premi√®re chose que fait cette m√©thode est de calculer le nombre de cellules qui devraient devenir des terres. </font><font style="vertical-align: inherit;">Ce montant sera notre somme totale de cellules de sushi.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">// for (int i = 0; i &lt; 5; i++) { // RaiseTerrain(Random.Range(chunkSizeMin, chunkSizeMax + 1)); // } CreateLand(); for (int i = 0; i &lt; cellCount; i++) { grid.GetCell(i).SearchPhase = 0; } } void CreateLand () { int landBudget = Mathf.RoundToInt(cellCount * landPercentage * 0.01f); }</span></span></code> </pre> <br> <code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">provoquera </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jusqu'√† ce que nous ayons d√©pens√© la totalit√© des cellules. </font><font style="vertical-align: inherit;">Afin de ne pas d√©passer le montant, nous modifions </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour qu'il re√ßoive le montant comme param√®tre suppl√©mentaire. </font><font style="vertical-align: inherit;">Apr√®s avoir termin√© ses travaux, il doit restituer le montant restant.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// void RaiseTerrain (int chunkSize) { int RaiseTerrain (int chunkSize, int budget) { ‚Ä¶ return budget; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le montant devrait diminuer chaque fois que la cellule est retir√©e de la fronti√®re et convertie en terre. </font><font style="vertical-align: inherit;">Si apr√®s cela, le montant total est d√©pens√©, alors nous devons arr√™ter la recherche et terminer le site. </font><font style="vertical-align: inherit;">De plus, cela ne devrait √™tre fait que lorsque la cellule actuelle n'est pas encore atterrie.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (size &lt; chunkSize &amp;&amp; searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.TerrainTypeIndex == <span class="hljs-number"><span class="hljs-number">0</span></span>) { current.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (--budget == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } size += <span class="hljs-number"><span class="hljs-number">1</span></span>; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, il </font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut √©lever des terres jusqu'√† ce qu'il d√©pense la totalit√© des cellules.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { landBudget = RaiseTerrain( Random.Range(chunkSizeMin, chunkSizeMax + <span class="hljs-number"><span class="hljs-number">1</span></span>), landBudget ); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d15/34e/7f4/d1534e7f47ba4cf87f3dbeed60aa7d00.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exactement la moiti√© de la carte est devenue un terrain. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tenez compte de la hauteur </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La terre n'est pas seulement une plaque plate, limit√©e par le littoral. </font><font style="vertical-align: inherit;">Elle a une hauteur changeante, contenant des collines, des montagnes, des vall√©es, des lacs, etc. </font><font style="vertical-align: inherit;">De grandes diff√©rences de hauteur existent en raison de l'interaction des plaques tectoniques se d√©pla√ßant lentement. </font><font style="vertical-align: inherit;">Bien que nous ne le simulions pas, nos terres devraient en quelque sorte ressembler √† de telles plaques. </font><font style="vertical-align: inherit;">Les sites ne bougent pas, mais peuvent se croiser. </font><font style="vertical-align: inherit;">Et nous pouvons en profiter.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Poussez la terre </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chaque parcelle repr√©sente une portion de terre expuls√©e du fond de l'oc√©an. </font><font style="vertical-align: inherit;">Par cons√©quent, augmentons constamment la hauteur de la cellule actuelle </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et voyons ce qui se passe.</font></font><br><br><pre> <code class="cs hljs"> HexCell current = searchFrontier.Dequeue(); current.Elevation += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.TerrainTypeIndex == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b3c/f6e/d3e/b3cf6ed3e71eb737ea7246c92bdd5624.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain avec des hauteurs. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons atteint les hauteurs, mais c'est difficile √† voir. </font><font style="vertical-align: inherit;">Vous pouvez les rendre plus lisibles si vous utilisez votre propre type de terrain pour chaque niveau de hauteur, comme la superposition g√©ographique. </font><font style="vertical-align: inherit;">Nous ne le ferons que pour que les hauteurs soient plus visibles, vous pouvez donc simplement utiliser le niveau de hauteur comme indice d'√©l√©vation.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que se passe-t-il si la hauteur d√©passe le nombre de types de terrain?</font></font></b> <div class="spoiler_text">        .        ,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au lieu de mettre √† jour le type de terrain de la cellule √† chaque changement de hauteur, cr√©ons une m√©thode distincte </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour d√©finir tous les types de terrain une seule fois.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); cell.TerrainTypeIndex = cell.Elevation; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous appellerons cette m√©thode apr√®s avoir cr√©√© des sushis. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ CreateLand(); SetTerrainType(); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, il </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne peut plus g√©rer le type de relief et se concentrer sur les hauteurs. </font><font style="vertical-align: inherit;">Pour ce faire, vous devez modifier sa logique. </font><font style="vertical-align: inherit;">Si la nouvelle hauteur de la cellule actuelle est 1, alors elle vient de devenir plus s√®che, donc la somme des cellules a diminu√©, ce qui peut conduire √† l'ach√®vement de la croissance du site.</font></font><br><br><pre> <code class="cs hljs"> HexCell current = searchFrontier.Dequeue(); current.Elevation += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.Elevation == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; --budget == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// if (current.TerrainTypeIndex == 0) { // current.TerrainTypeIndex = 1; // if (--budget == 0) { // break; // } // }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee0/eec/b9e/ee0eecb9e59f527bd27f0275e230de0a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stratification des couches.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ajouter de l'eau </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Indiquons explicitement quelles cellules sont de l'eau ou de la terre, en r√©glant le niveau d'eau pour toutes les cellules sur 1. Faites-le </font></font><code>GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avant de cr√©er la terre.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { cellCount = x * z; grid.CreateMap(x, z); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { grid.GetCell(i).WaterLevel = <span class="hljs-number"><span class="hljs-number">1</span></span>; } CreateLand(); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, pour la d√©signation des couches terrestres, nous pouvons utiliser tous les types de terrain. </font><font style="vertical-align: inherit;">Toutes les cellules sous-marines resteront sablonneuses, tout comme les cellules terrestres les plus basses. </font><font style="vertical-align: inherit;">Cela peut √™tre fait en soustrayant le niveau d'eau de la hauteur et en utilisant la valeur comme indice du type de relief.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { cell.TerrainTypeIndex = cell.Elevation - cell.WaterLevel; } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b5/449/bc3/1b5449bc37b1c677d908484c7bcd0286.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terre et eau.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Augmentez le niveau d'eau </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous ne sommes pas limit√©s √† un seul niveau d'eau. </font><font style="vertical-align: inherit;">Rendons-le personnalisable √† l'aide d'un champ commun avec un intervalle de 1 √† 5 et une valeur par d√©faut de 3. </font><font style="vertical-align: inherit;">Utilisez ce niveau lors de l'initialisation des cellules.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(1, 5)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> waterLevel = <span class="hljs-number"><span class="hljs-number">3</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { grid.GetCell(i).WaterLevel = waterLevel; } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c32/9cf/82f/c329cf82f9a847ac01f2754cc3252500.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/850/c9d/fe4/850c9dfe4694834486bf4be64ac1783a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Niveau d'eau 3.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lorsque le niveau d'eau est √† 3, nous obtenons moins de terres que pr√©vu. </font><font style="vertical-align: inherit;">C'est parce qu'il </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">croit toujours que le niveau d'eau est 1. Corrigeons-le.</font></font><br><br><pre> <code class="cs hljs"> HexCell current = searchFrontier.Dequeue(); current.Elevation += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.Elevation == waterLevel &amp;&amp; --budget == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'utilisation de niveaux d'eau plus √©lev√©s conduit √† cela. </font><font style="vertical-align: inherit;">que les cellules ne deviennent pas des terres imm√©diatement. </font><font style="vertical-align: inherit;">Lorsque le niveau d'eau est √† 2, la premi√®re section restera toujours sous l'eau. </font><font style="vertical-align: inherit;">Le fond de l'oc√©an a augment√©, mais reste toujours sous l'eau. </font><font style="vertical-align: inherit;">Un terrain n'est form√© qu'√† l'intersection d'au moins deux sections. </font><font style="vertical-align: inherit;">Plus le niveau d'eau est √©lev√©, plus les sites doivent traverser pour cr√©er des terres. </font><font style="vertical-align: inherit;">Par cons√©quent, avec la mont√©e des eaux, la terre devient plus chaotique. </font><font style="vertical-align: inherit;">En outre, lorsque davantage de parcelles sont n√©cessaires, il est plus probable qu'elles se recoupent sur des terres d√©j√† existantes, en raison des montagnes qui seront plus communes et des terres plates moins probables, comme dans le cas de l'utilisation de parcelles plus petites.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c39/f02/abf/c39f02abf2bfa93f01395208da92ae9a.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/01f/4e2/5a901f4e2785456e0784f33508be4ede.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/863/816/cc1/863816cc19c0fd7cbf172905962970d9.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd0/412/190/fd041219043df072443b00d6799f3946.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les niveaux d'eau sont de 2 √† 5, les sushis sont toujours √† 50%. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mouvement vertical </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jusqu'√† pr√©sent, nous avons √©lev√© les parcelles d'un niveau √† la fois, mais nous n'avons pas √† nous limiter √† cela. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sites √©lev√©s </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que chaque section augmente la hauteur de ses cellules d'un niveau, des coupures peuvent se produire. </font><font style="vertical-align: inherit;">Cela se produit lorsque les bords de deux sections se touchent. </font><font style="vertical-align: inherit;">Cela peut cr√©er des falaises isol√©es, mais les longues lignes de falaise seront rares. </font><font style="vertical-align: inherit;">Nous pouvons augmenter la fr√©quence de leur apparition en augmentant la hauteur de l'intrigue de plus d'un pas. </font><font style="vertical-align: inherit;">Mais cela ne doit √™tre fait que pour une certaine proportion de sites. </font><font style="vertical-align: inherit;">Si toutes les zones montent haut, il sera tr√®s difficile de se d√©placer le long du terrain. </font><font style="vertical-align: inherit;">Rendons donc ce param√®tre personnalisable √† l'aide d'un champ de probabilit√© avec une valeur par d√©faut de 0,25.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> highRiseProbability = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/485/8d7/cb64858d7531bb31842aebdd49b68304.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La probabilit√© d'une forte augmentation des cellules. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que nous puissions utiliser n'importe quelle augmentation de hauteur pour les zones √©lev√©es, cela devient rapidement incontr√¥lable. </font><font style="vertical-align: inherit;">La diff√©rence de hauteur 2 cr√©e d√©j√† des falaises, donc cela suffit. </font><font style="vertical-align: inherit;">Comme vous pouvez sauter une hauteur √©gale au niveau de l'eau, nous devons changer la fa√ßon dont nous d√©terminons si une cellule est devenue une terre. </font><font style="vertical-align: inherit;">Si elle √©tait en dessous du niveau de l'eau, et maintenant elle est au m√™me niveau ou plus, alors nous avons cr√©√© une nouvelle cellule terrestre.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rise = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; highRiseProbability ? <span class="hljs-number"><span class="hljs-number">2</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (size &lt; chunkSize &amp;&amp; searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalElevation = current.Elevation; current.Elevation = originalElevation + rise; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( originalElevation &lt; waterLevel &amp;&amp; current.Elevation &gt;= waterLevel &amp;&amp; --budget == <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } size += <span class="hljs-number"><span class="hljs-number">1</span></span>; ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b31/8c1/ea5/b318c1ea557ced17d2cb0d9a951bcfc3.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ba/353/78b/4ba35378bc60e74b624e136b90a4a7eb.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea3/8ac/b0a/ea38acb0a5cf12835c2ba177e41d6178.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/018/0df/bd9/0180dfbd9869a0d0e0d5a1712af34fb3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les probabilit√©s d'une forte augmentation de la hauteur sont de 0,25, 0,50, 0,75 et 1.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abaisser le terrain </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La terre ne monte pas toujours, parfois elle tombe. </font><font style="vertical-align: inherit;">Lorsque la terre tombe suffisamment bas, l'eau la remplit et elle est perdue. </font><font style="vertical-align: inherit;">Jusqu'√† pr√©sent, nous ne faisons pas cela. </font><font style="vertical-align: inherit;">Comme nous ne faisons que pousser les zones vers le haut, le terrain ressemble g√©n√©ralement √† un ensemble de zones plut√¥t rondes m√©lang√©es. </font><font style="vertical-align: inherit;">Si nous abaissons parfois la zone, nous obtenons des formes plus vari√©es.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e4/95e/d81/9e495ed818dfffc39e5a238f273c8c5b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grande carte sans sushi coul√©. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons contr√¥ler la fr√©quence de l'affaissement des terres en utilisant un autre champ de probabilit√©. </font><font style="vertical-align: inherit;">√âtant donn√© que l'abaissement peut d√©truire des terres, la probabilit√© d'abaissement doit toujours √™tre inf√©rieure √† la probabilit√© d'augmenter. </font><font style="vertical-align: inherit;">Sinon, cela peut prendre beaucoup de temps pour obtenir le bon pourcentage de terres. </font><font style="vertical-align: inherit;">Par cons√©quent, utilisons une probabilit√© d'abaissement maximale de 0,4 avec une valeur par d√©faut de 0,2.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 0.4f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sinkProbability = <span class="hljs-number"><span class="hljs-number">0.2f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a11/997/e82/a11997e824700a045e9faaedaafeb121.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Probabilit√© d'abaissement. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'abaissement du site est similaire √† l'augmentation, avec quelques diff√©rences. </font><font style="vertical-align: inherit;">Par cons√©quent, nous dupliquons la m√©thode </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et changeons son nom en </font></font><code>SinkTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Au lieu de d√©terminer l'ampleur de l'augmentation, nous avons besoin d'une valeur d'abaissement qui peut utiliser la m√™me logique. </font><font style="vertical-align: inherit;">Dans le m√™me temps, des comparaisons pour v√©rifier si nous avons travers√© la surface de l'eau doivent √™tre retourn√©es. </font><font style="vertical-align: inherit;">De plus, lors de l'abaissement du relief, nous ne sommes pas limit√©s √† la somme des cellules. </font><font style="vertical-align: inherit;">Au lieu de cela, chaque cellule de sushi perdue renvoie le montant d√©pens√©, nous l'augmentons donc et continuons √† travailler.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SinkTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> budget</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sink = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; highRiseProbability ? <span class="hljs-number"><span class="hljs-number">2</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (size &lt; chunkSize &amp;&amp; searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalElevation = current.Elevation; current.Elevation = originalElevation - sink; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( originalElevation &gt;= waterLevel &amp;&amp; current.Elevation &lt; waterLevel <span class="hljs-comment"><span class="hljs-comment">// &amp;&amp; --budget == 0 ) { // break; budget += 1; } size += 1; ‚Ä¶ } searchFrontier.Clear(); return budget; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, √† chaque it√©ration √† l'int√©rieur, </font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous devons soit baisser, soit √©lever le terrain, selon la probabilit√© d'abaissement.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; sinkProbability) { landBudget = SinkTerrain(chunkSize, landBudget); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { landBudget = RaiseTerrain(chunkSize, landBudget); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6b/c5e/762/d6bc5e76274e4aa9c8a692f90fde3646.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2f/8ae/3e3/c2f8ae3e3a4b814b6ae954d40225149e.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e3/f5d/461/1e3f5d461421feddbb145d4e1d56c000.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33b/39d/462/33b39d462682688fc2a8094556e4fc91.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La probabilit√© de chute est de 0,1, 0,2, 0,3 et 0,4.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hauteur limite </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au stade actuel, nous pouvons potentiellement chevaucher de nombreuses sections, parfois avec plusieurs augmentations de hauteur, dont certaines peuvent descendre puis remonter. </font><font style="vertical-align: inherit;">Dans le m√™me temps, nous pouvons cr√©er des hauteurs tr√®s √©lev√©es, et parfois tr√®s basses, en particulier lorsqu'un pourcentage √©lev√© de terrain est n√©cessaire.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f3f/c2e/359/f3fc2e359db04b4411f2bcd06b81888b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ânormes hauteurs √† 90% du terrain. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour limiter la hauteur, ajoutons un minimum et un maximum personnalis√©s. </font><font style="vertical-align: inherit;">Un minimum raisonnable se situera entre ‚àí4 et 0, et un maximum acceptable peut √™tre compris entre 6 et 10. </font><font style="vertical-align: inherit;">Laissez les valeurs par d√©faut √™tre -2 et 8. Lorsque vous modifiez manuellement la carte, elles seront en dehors de la limite acceptable, vous pouvez donc changer le curseur de l'interface utilisateur de l'√©diteur ou le laisser tel quel.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(-4, 0)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationMinimum = <span class="hljs-number"><span class="hljs-number">-2</span></span>; [Range(<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationMaximum = <span class="hljs-number"><span class="hljs-number">8</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bcb/20b/efc/bcb20befc496cd2c5bffbc94b0a9d267.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hauteurs minimum et maximum. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous devons nous assurer que la hauteur ne d√©passe pas le maximum autoris√©. </font><font style="vertical-align: inherit;">Cela peut √™tre fait en v√©rifiant si les cellules actuelles sont trop √©lev√©es. </font><font style="vertical-align: inherit;">Si c'est le cas, nous les ignorons sans modifier la hauteur et ajouter leurs voisins. </font><font style="vertical-align: inherit;">Cela conduira au fait que les zones terrestres √©viteront les zones qui ont atteint une hauteur maximale et se d√©velopperont autour d'elles.</font></font><br><br><pre> <code class="cs hljs"> HexCell current = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalElevation = current.Elevation; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newElevation = originalElevation + rise; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newElevation &gt; elevationMaximum) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } current.Elevation = newElevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( originalElevation &lt; waterLevel &amp;&amp; newElevation &gt;= waterLevel &amp;&amp; --budget == <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } size += <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faites de m√™me √† l'int√©rieur </font></font><code>SinkTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais pour une hauteur minimale.</font></font><br><br><pre> <code class="cs hljs"> HexCell current = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalElevation = current.Elevation; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newElevation = current.Elevation - sink; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newElevation &lt; elevationMinimum) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } current.Elevation = newElevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( originalElevation &gt;= waterLevel &amp;&amp; newElevation &lt; waterLevel ) { budget += <span class="hljs-number"><span class="hljs-number">1</span></span>; } size += <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4af/cbe/339/4afcbe339d0d697779ff0649f6c2c125.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hauteur limit√©e avec 90% de terrain.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pr√©servation de l'altitude n√©gative </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä ce stade, le code de sauvegarde et de chargement ne peut pas g√©rer les hauteurs n√©gatives car nous stockons la hauteur en octets. </font><font style="vertical-align: inherit;">Un nombre n√©gatif est converti lorsqu'il est enregistr√© en un grand positif. </font><font style="vertical-align: inherit;">Par cons√©quent, lors de l'enregistrement et du chargement de la carte g√©n√©r√©e, des cartes tr√®s hautes peuvent appara√Ætre √† la place des cellules sous-marines d'origine. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons ajouter la prise en charge des hauteurs n√©gatives en la stockant sous forme d'entier et non d'octet. </font><font style="vertical-align: inherit;">Cependant, nous n'avons toujours pas besoin de prendre en charge plusieurs niveaux de hauteur. </font><font style="vertical-align: inherit;">De plus, nous pouvons compenser la valeur stock√©e en ajoutant 127. Cela nous permettra de stocker correctement les hauteurs dans la plage ‚àí127‚Äì128 dans un octet. </font><font style="vertical-align: inherit;">Changez en </font></font><code>HexCell.Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cons√©quence.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)terrainTypeIndex); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(elevation + <span class="hljs-number"><span class="hljs-number">127</span></span>)); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisque nous avons chang√© la fa√ßon dont nous enregistrons les donn√©es cartographiques, nous les augmentons </font></font><code>SaveLoadMenu.mapFileVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† 4.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapFileVersion = <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et enfin, changez-le </font></font><code>HexCell.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour qu'il soustrait 127 des hauteurs charg√©es √† partir des fichiers de la version 4.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadByte(); ShaderData.RefreshTerrain(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); elevation = reader.ReadByte(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>) { elevation -= <span class="hljs-number"><span class="hljs-number">127</span></span>; } ‚Ä¶ }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Recr√©er la m√™me carte </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant cr√©er une grande vari√©t√© de cartes. </font><font style="vertical-align: inherit;">Lors de la g√©n√©ration de chaque nouveau r√©sultat sera al√©atoire. </font><font style="vertical-align: inherit;">Nous pouvons contr√¥ler √† l'aide des options de configuration uniquement les caract√©ristiques de la carte, mais pas la forme la plus pr√©cise. </font><font style="vertical-align: inherit;">Mais parfois, nous devons recr√©er exactement la m√™me carte. </font><font style="vertical-align: inherit;">Par exemple, pour partager une belle carte avec un ami ou recommencer apr√®s l'avoir modifi√©e manuellement. </font><font style="vertical-align: inherit;">Il est √©galement utile dans le processus de d√©veloppement du jeu, alors ajoutons cette fonctionnalit√©.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Utilisation de semences </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour rendre le processus de g√©n√©ration de carte impr√©visible, nous utilisons </font></font><code>Random.Range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>Random.value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pour obtenir √† nouveau la m√™me s√©quence pseudo-al√©atoire de nombres, vous devez utiliser la m√™me valeur de d√©part. </font><font style="vertical-align: inherit;">Nous avons d√©j√† adopt√© une approche similaire auparavant, en </font></font><code>HexMetrics.InitializeHashGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il enregistre d'abord l'√©tat actuel du g√©n√©rateur de nombres initialis√© avec une valeur de d√©part sp√©cifique, puis restaure son √©tat d'origine. </font><font style="vertical-align: inherit;">Nous pouvons utiliser la m√™me approche pour </font></font><code>HexMapGenerator.GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous pouvons √† nouveau nous souvenir de l'ancien √©tat et le restaurer apr√®s l'ach√®vement, afin de ne pas interf√©rer avec quoi que ce soit d'autre qui utilise </font></font><code>Random</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { Random.State originalRandomState = Random.state; ‚Ä¶ Random.state = originalRandomState; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, nous devons mettre √† disposition la graine utilis√©e pour g√©n√©rer la derni√®re carte. </font><font style="vertical-align: inherit;">Cela se fait √† l'aide d'un champ entier commun.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> seed;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41d/3b5/538/41d3b553898698698636b6bada081aa6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Afficher la graine. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous avons besoin de la valeur de d√©part pour initialiser </font></font><code>Random</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pour cr√©er des cartes al√©atoires, vous devez utiliser une graine al√©atoire. </font><font style="vertical-align: inherit;">L'approche la plus simple consiste √† utiliser une valeur de d√©part arbitraire pour g√©n√©rer </font></font><code>Random.Range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pour que cela n'affecte pas l'√©tat al√©atoire initial, nous devons le faire apr√®s l'avoir enregistr√©.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { Random.State originalRandomState = Random.state; seed = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue); Random.InitState(seed); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depuis la fin, nous restaurons un √©tat al√©atoire, si nous g√©n√©rons imm√©diatement une autre carte, nous obtenons ainsi la m√™me valeur de d√©part. </font><font style="vertical-align: inherit;">De plus, nous ne savons pas comment l'√©tat al√©atoire initial a √©t√© initialis√©. </font><font style="vertical-align: inherit;">Par cons√©quent, bien qu'il puisse servir de point de d√©part arbitraire, nous avons besoin de quelque chose de plus pour le randomiser √† chaque appel.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il existe diff√©rentes fa√ßons d'initialiser des g√©n√©rateurs de nombres al√©atoires. </font><font style="vertical-align: inherit;">Dans ce cas, vous pouvez simplement combiner plusieurs valeurs arbitraires qui varient sur une large plage, c'est-√†-dire que la probabilit√© de recr√©er la m√™me carte sera faible. </font><font style="vertical-align: inherit;">Par exemple, nous utilisons les 32 bits inf√©rieurs de l'heure syst√®me, exprim√©s en cycles, plus le temps d'ex√©cution actuel de l'application. </font><font style="vertical-align: inherit;">Combinez ces valeurs √† l'aide de l'op√©ration OU exclusive au niveau du bit afin que le r√©sultat ne soit pas tr√®s grand.</font></font><br><br><pre> <code class="cs hljs"> seed = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue); seed ^= (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)System.DateTime.Now.Ticks; seed ^= (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Time.unscaledTime; Random.InitState(seed);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le nombre r√©sultant peut √™tre n√©gatif, ce qui pour une graine de valeur publique n'est pas tr√®s joli. </font><font style="vertical-align: inherit;">Nous pouvons le rendre strictement positif en utilisant un masquage au niveau du bit avec une valeur enti√®re maximale qui r√©initialisera le bit de signe.</font></font><br><br><pre> <code class="cs hljs"> seed ^= (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Time.unscaledTime; seed &amp;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; Random.InitState(seed);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Graine r√©utilisable </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous g√©n√©rons toujours des cartes al√©atoires, mais maintenant nous pouvons voir quelle valeur de graine a √©t√© utilis√©e pour chacune d'elles. </font><font style="vertical-align: inherit;">Pour recr√©er √† nouveau la m√™me carte, nous devons ordonner au g√©n√©rateur d'utiliser √† nouveau la m√™me valeur de d√©part, plut√¥t que d'en cr√©er une nouvelle. </font><font style="vertical-align: inherit;">Nous allons le faire en ajoutant un commutateur √† l'aide d'un champ bool√©en.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useFixedSeed;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/200/4c6/eed/2004c6eed8c2244bdfe660bf477d2fa3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Possibilit√© d'utiliser une graine constante. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si une graine constante est s√©lectionn√©e, nous sautons simplement la g√©n√©ration de la nouvelle graine </font></font><code>GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si nous ne modifions pas manuellement le champ de d√©part, le r√©sultat sera √† nouveau la m√™me carte.</font></font><br><br><pre> <code class="cs hljs"> Random.State originalRandomState = Random.state; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!useFixedSeed) { seed = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue); seed ^= (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)System.DateTime.Now.Ticks; seed ^= (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Time.time; seed &amp;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } Random.InitState(seed);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons copier la valeur de d√©part de la carte que nous aimons et la sauvegarder quelque part, afin de la g√©n√©rer √† nouveau √† l'avenir. </font><font style="vertical-align: inherit;">N'oubliez pas que nous n'obtiendrons la m√™me carte que si nous utilisons exactement les m√™mes param√®tres de g√©n√©rateur, c'est-√†-dire la m√™me taille de carte, ainsi que toutes les autres options de configuration. </font><font style="vertical-align: inherit;">M√™me un petit changement dans ces probabilit√©s peut cr√©er une carte compl√®tement diff√©rente. </font><font style="vertical-align: inherit;">Par cons√©quent, en plus de la graine, nous devons nous souvenir de tous les param√®tres.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ff/cd2/279/7ffcd2279b4dd882db924d8e1fc61d0e.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/486/6db/156/4866db15628d75936b7e19fa4841f2f5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grandes cartes avec des valeurs de d√©part 0 et 929396788, param√®tres standard. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr427003/">https://habr.com/ru/post/fr427003/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr426991/index.html">Startup Digest: 10 √©v√©nements IT √† venir √† Moscou</a></li>
<li><a href="../fr426993/index.html">Dois-je apprendre le C pour comprendre le fonctionnement d'un ordinateur?</a></li>
<li><a href="../fr426995/index.html">Le recyclage nuit aux produits et aux employ√©s</a></li>
<li><a href="../fr426997/index.html">Comment cr√©er des formes personnalis√©es √† l'aide de MaterialShapeDrawable</a></li>
<li><a href="../fr426999/index.html">Suivre les tendances ou √©voluer vers RxJava et LiveData</a></li>
<li><a href="../fr427005/index.html">D√©veloppeurs d'IA - le m√©tier de millionnaire?</a></li>
<li><a href="../fr427009/index.html">"Marche" d'un √©lectron: manipulations avec une charge √† l'int√©rieur de la structure des liaisons insatur√©es</a></li>
<li><a href="../fr427011/index.html">Mon "Bonjour tout le monde!" sur FPGA ou la prochaine version de UART</a></li>
<li><a href="../fr427013/index.html">Face √† face NeoQUEST-2018: rappelez-vous comment c'√©tait</a></li>
<li><a href="../fr427015/index.html">Pourquoi les centres de donn√©es intelligents commerciaux ont-ils besoin de PDU intelligentes?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>