<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👬 🤮 ♏️ CRDT: tipos de dados replicados sem conflitos 💞 👉🏿 🧖🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Como contar os hits da página google.com? E como armazenar o contador de gostos de usuários muito populares? Este artigo propõe considerar a solução d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>CRDT: tipos de dados replicados sem conflitos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418897/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/r1/we/lm/r1welma_rgaxinwrbp7ekni1tdo.png"></div><br>  Como contar os hits da página google.com?  E como armazenar o contador de gostos de usuários muito populares?  Este artigo propõe considerar a solução desses problemas usando o CRDT (tipos de dados replicados sem conflitos, que em russo se traduz aproximadamente como tipos de dados replicados sem conflitos) e, no caso mais geral, tarefas de sincronização de réplicas em um sistema distribuído com vários nós principais. <br><a name="habracut"></a><br><h1>  1. Introdução </h1><br>  Há muito que estamos acostumados a usar aplicativos como um calendário ou um serviço de anotações como o Evernote.  Eles estão unidos pelo fato de permitir que você trabalhe offline, de vários dispositivos e para várias pessoas ao mesmo tempo (nos mesmos dados).  O desafio enfrentado pelos desenvolvedores de cada aplicativo é como garantir a sincronização mais "suave" dos dados alterados simultaneamente em vários dispositivos.  Idealmente, o envolvimento do usuário não deve ser necessário para resolver conflitos de mesclagem. <br><br>  Em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo anterior,</a> já consideramos uma abordagem para resolver esses problemas - Transformação Operacional, também descreverá um método muito semelhante que possui vantagens e desvantagens (por exemplo, o CRDT para JSON ainda não foi inventado. Upd: Graças ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">msvn</a> pelo link, aqui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aqui está um</a> projeto dos autores de um artigo de pesquisa sobre a implementação do JSON no CRDT) <br><br><h1>  2. Forte consistência eventual </h1><br>  Recentemente, muito trabalho foi escrito e muita pesquisa foi feita no campo da eventual consistência.  Na minha opinião, agora há uma forte tendência para uma mudança de consistência forte para várias opções de consistência, para pesquisar qual consistência em que situações / sistemas é mais rentável aplicar, para repensar as definições existentes.  Isso leva a alguma confusão, por exemplo, quando os autores de algumas obras, falando sobre consistência, significam consistência eventual com alguma propriedade adicional, e outros autores usam certa terminologia para isso. <br><br>  A pergunta levantada pelos autores de um dos artigos critica a definição atual de consistência eventual: de acordo com ela, se o seu sistema sempre responde “42” a todas as solicitações, tudo está bem, e eventualmente é consistente. <br><br>  Sem violar a correção deste artigo, eu, seguindo os autores dos artigos originais, usarei a seguinte terminologia (observe que essas não são definições estritas, são diferenças): <br><br><ul><li>  Consistência forte (SC): todas as operações de gravação são estritamente ordenadas, uma solicitação de leitura em qualquer réplica retorna o mesmo resultado, último registro.  É necessário um consenso em <b>tempo real</b> para resolver conflitos (com as conseqüências resultantes), pode suportar uma queda para n / 2 - 1 nós. </li><li>  Eventual consistência (EC): atualize os dados localmente, envie a atualização ainda mais.  A leitura em réplicas diferentes pode retornar dados obsoletos.  Em caso de conflito, revertemos ou de alguma forma decidimos o que fazer.  T.O.  ainda é necessário um consenso, mas não <b>mais em tempo real</b> . </li><li>  Forte consistência eventual (SEC): EC + para resolver conflitos, as réplicas têm um algoritmo predefinido.  T.O.  <b>não é necessário um consenso</b> , pois pode suportar uma queda para n - 1 nós. </li></ul><br>  Observe que a SEC (por assim dizer) resolve o problema do teorema da CAP: todas as três propriedades são satisfeitas. <br><br>  Portanto, estamos prontos para doar o SC e queremos ter um certo conjunto de tipos de dados básicos para o nosso sistema distribuído potencialmente instável que resolverá automaticamente os conflitos de gravação para nós (nenhuma interação do usuário ou solicitação a algum árbitro é necessária) <br><br><h1>  3. Tarefas sobre curtidas e hits </h1><br>  Sem dúvida, existem vários algoritmos para resolver esses problemas.  O CRDT oferece uma maneira bastante elegante e fácil. <br><br><h3>  Contagem de hits do Google.com.br: </h3><br>  O google.com processa aproximadamente 150.000 solicitações por segundo de todo o mundo.  Obviamente, o contador precisa ser atualizado de forma assíncrona.  As filas resolvem parcialmente o problema - por exemplo, se fornecermos uma API externa para obter esse valor, teremos que fazer a replicação para não colocar o repositório com solicitações de leitura.  E se já houver replicação, talvez sem filas globais? <br><br><div style="text-align:center;"><img width="500" src="https://habrastorage.org/webt/wv/4y/tn/wv4ytnmej1xm2tbhen3ddztgv6w.png" alt="imagem"></div><br><br><h3>  Contando gostos do usuário: </h3><br>  A tarefa é muito semelhante à anterior, só que agora você precisa contar hits únicos. <br><br><h1>  4. Terminologia </h1><br>  Para uma compreensão mais completa do artigo, você precisa conhecer os seguintes termos: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Idempotência</a> <br>  Diz que a aplicação da operação várias vezes não altera o resultado. <br>  Exemplos - operação GET ou adição com zero: <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2">f</span><span class="MJXp-mo" id="MJXp-Span-3" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4">x</span><span class="MJXp-mo" id="MJXp-Span-5" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-6" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-7">x</span><span class="MJXp-mo" id="MJXp-Span-8" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-9">0</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-1"> f (x) = x + 0 </script><br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Comutatividade</a> <br><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-10"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-11">f</span><span class="MJXp-mo" id="MJXp-Span-12" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-13">x</span><span class="MJXp-mo" id="MJXp-Span-14" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-15">y</span><span class="MJXp-mo" id="MJXp-Span-16" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-17" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-18">f</span><span class="MJXp-mo" id="MJXp-Span-19" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-20">y</span><span class="MJXp-mo" id="MJXp-Span-21" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-22">x</span><span class="MJXp-mo" id="MJXp-Span-23" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-2"> f (x, y) = f (y, x) </script><br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ordem parcial</a> <br>  Reflexividade + transitividade + antissimetria <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Meia estrutura</a> <br>  Conjunto parcialmente pedido com a face superior (inferior) exata <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Vetor de versão</a> <br>  Um vetor de dimensão é igual ao número de nós e cada nó, quando ocorre um determinado evento, incrementa seu valor no vetor.  Durante a sincronização, os dados são transmitidos com esse vetor e isso introduz uma relação de ordem, que permite determinar qual réplica possui dados antigos / novos. </li></ol><br><h1>  5. Modelos de sincronização </h1><br><h3>  Baseado no estado: </h3><br>  Também chamada de sincronização passiva, forma o Tipo de dados replicado convergente - CvRDT. <br>  É usado em sistemas de arquivos como NFS, AFS, Coda e nos armazenamentos KV Riak, Dynamo <br>  Nesse caso, as réplicas trocam os estados diretamente, a réplica de recebimento mescla o estado recebido com seu estado atual. <br><br><div style="text-align:center;"><img width="600" src="https://habrastorage.org/webt/ac/r_/7b/acr_7blhm_vkl7rwgfenmjpvdus.png" alt="imagem"></div><br>  Para executar a convergência de réplicas usando essa sincronização, é necessário que: <br><br><ul><li>  Os dados formaram um semilático </li><li>  A função de mesclagem produziu um limite superior exato </li><li>  As réplicas formaram um gráfico conectado. </li></ul><br>  Um exemplo: <br><br><ul><li>  Conjunto de dados: números naturais <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-24"><span class="MJXp-mtext" id="MJXp-Span-25">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-26">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-27">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-28">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-29">h</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-30">b</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-31">b</span><span class="MJXp-mrow" id="MJXp-Span-32"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-33">N</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-3"> \ mathbb {N} </script></li><li>  Item mínimo: <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-34"><span class="MJXp-mo" id="MJXp-Span-35" style="margin-left: 0em; margin-right: 0.111em;">−</span><span class="MJXp-mtext" id="MJXp-Span-36">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-37">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-38">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-39">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-40">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-41">y</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-4"> - \ infty </script></li><li><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-42"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-43">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-44">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-45">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-46">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-47">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-48">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-49">g</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-50">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-51">m</span><span class="MJXp-mo" id="MJXp-Span-52" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-53">x</span><span class="MJXp-mo" id="MJXp-Span-54" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-55">y</span><span class="MJXp-mo" id="MJXp-Span-56" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-57" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-58">m</span><span class="MJXp-mrow" id="MJXp-Span-59"><span class="MJXp-mo" id="MJXp-Span-60" style="margin-left: 0em; margin-right: 0em;">á</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-61">x</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-62">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-63">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-64">o</span><span class="MJXp-mo" id="MJXp-Span-65" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-66">x</span><span class="MJXp-mo" id="MJXp-Span-67" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-68">y</span><span class="MJXp-mo" id="MJXp-Span-69" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-5"> mesclagem (x, y) = máximo (x, y) </script></li></ul><br>  Esses requisitos nos fornecem uma função de mesclagem <b>comutativa</b> e <b>idempotente</b> que <b>cresce monotonicamente</b> em um determinado conjunto de dados: <br><br><div style="text-align:center;"><img width="300" src="https://habrastorage.org/webt/jn/nw/vl/jnnwvlfp_tjkank2zknwdcbj-oc.png" alt="imagem"></div><br>  Isso garante que as réplicas converjam mais cedo ou mais tarde e permita que você não se preocupe com o protocolo de transferência de dados - <b>podemos perder mensagens com um novo estado, enviá-las várias vezes e até mesmo em qualquer ordem</b> . <br><br><h3>  Baseado em operação: </h3><br>  Também chamado de Sincronização Ativa, ele forma o Tipo de Dados Replicado Comutativo - CmRDT. <br>  Utilizado em sistemas cooperativos como Bayou, Rover, IceCube, Telex. <br><br>  Nesse caso, as réplicas trocam operações de atualização de estado.  Ao atualizar dados, a réplica original: <br><br><ul><li>  Chama o método generate (), que retorna o método effector () para executar nas réplicas restantes.  Em outras palavras, effector () é o fechamento para alterar o estado das réplicas restantes. </li><li>  Aplicando um efetor a um estado local </li><li>  Envia efetor para todas as outras réplicas </li></ul><br><div style="text-align:center;"><img width="600" src="https://habrastorage.org/webt/bd/i3/ps/bdi3pshr57wi0udnldnurhcdpfs.png" alt="imagem"></div><br>  Para executar a convergência de réplicas, as seguintes condições devem ser atendidas: <br><br><ul><li>  Protocolo de Entrega Confiável </li><li>  Se o efetor for entregue a todas as réplicas de acordo com a ordem inserida (para um determinado tipo), os efetores simultâneos serão comutativos <b>ou</b> </li><li>  Se o efetor for entregue a todas as réplicas sem levar em conta o pedido, todos os efetores serão comutativos. </li><li>  Caso o efetor possa ser entregue várias vezes, ele deve ser idempotente </li><li>  Algumas implementações usam filas (Kafka) como parte do protocolo de entrega. </li></ul><br><h3>  Baseado em Delta: </h3><br>  Considerando o estado / operação, é fácil perceber que, se uma atualização altera apenas parte do estado, não faz sentido enviar o estado inteiro e, se um grande número de alterações afeta um estado (por exemplo, um contador), você pode enviar uma alteração agregada e nem todas as operações mudanças. <br><br>  A sincronização delta combina as duas abordagens e envia mutadores delta que atualizam o estado de acordo com a data da sincronização mais recente.  Na sincronização inicial, é necessário enviar o estado completamente, e algumas implementações nesses casos já levam em consideração o estado das réplicas restantes ao construir delta-mutadores. <br><br>  O próximo método de otimização é compactar o log baseado em op, se atrasos forem permitidos. <br><br><div style="text-align:center;"><img width="600" src="https://habrastorage.org/webt/rd/vi/a5/rdvia5kv708z55ndt_t5j_leaum.png" alt="imagem"></div><br><h3>  Baseado em operação pura: </h3><br>  Há um atraso na criação do opector na sincronização baseada em op.  Em alguns sistemas, isso pode não ser aceitável, então você deve enviar a alteração original com o custo de complicar o protocolo e a quantidade adicional de metadados. <br><br><div style="text-align:center;"><img width="500" src="https://habrastorage.org/webt/3l/p2/r2/3lp2r2ruizjddxllrwgbgwh5ykw.png" alt="imagem"></div><br><h3>  Abordagens de uso padrão: </h3><br><ul><li>  Se as atualizações forem <b>enviadas imediatamente</b> no sistema, a escolha com base no estado seria uma má escolha, pois o envio de todo o estado é mais caro do que apenas uma operação de atualização.  Baseado em Delta funciona melhor, mas nesse caso em particular, a diferença com base em estado será pequena. </li><li>  Se você precisar <b>sincronizar a réplica após uma falha</b> , será baseada em estado e em delta a escolha perfeita.  Se você precisar usar operações, então as opções são: <br><br>  1) Role todas as operações perdidas desde o momento da falha <br>  2) Uma cópia completa de uma das réplicas e reversão de operações perdidas </li><li>  Como observado acima, o sistema operacional exige que as atualizações sejam entregues exatamente uma vez para cada réplica.  O requisito de entrega apenas uma vez pode ser omitido se o efetor for idempotente.  Na prática, é muito mais fácil implementar o primeiro que o segundo. </li></ul><br><h3>  A relação entre Op-based e State: </h3><br>  Duas abordagens podem ser emuladas uma pela outra, portanto, no futuro, consideraremos o CRDT sem referência a qualquer modelo de sincronização específico. <br><br><h1>  6. CRDT </h1><br><h2>  6.1 Contador </h2><br>  Um número inteiro que suporta duas operações: inc e dec.  Como exemplo, considere possíveis implementações para sincronizações baseadas em op e baseadas em estado: <br><br><h3>  Contador baseado em Op: </h3><br>  Obviamente, basta enviar atualizações.  Exemplo para inc: <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> function (counter) { counter += <span class="hljs-number"><span class="hljs-number">1</span></span> } }</code> </pre> <br><h3>  Contador baseado em estado: </h3><br>  A implementação não é mais tão óbvia, pois não está claro como deve ser a função de mesclagem. <br><br>  Considere as seguintes opções: <br><br>  <u>Contador de aumento monotônico (contador de incremento apenas, contador G):</u> <br><br>  Os dados serão armazenados como um vetor de dimensão igual ao número de nós (vetor de versão) e cada réplica aumentará o valor na posição com seu ID. <br><br>  A função de mesclagem assumirá o máximo nas posições correspondentes, e o valor final é a soma de todos os elementos do vetor <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-70"><span class="noError" id="MJXp-Span-71" style="display: inline-block;">\&nbsp;begin&nbsp;{align}&nbsp;inc&nbsp;()&nbsp;&amp;:&nbsp;V&nbsp;[id&nbsp;()]&nbsp;=&nbsp;V&nbsp;[id&nbsp;()]&nbsp;+&nbsp;1&nbsp;\\&nbsp;valor&nbsp;()&nbsp;&amp;:&nbsp;\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;0}&nbsp;^&nbsp;{n}&nbsp;V&nbsp;[i]&nbsp;\\&nbsp;mesclar&nbsp;(C_1,&nbsp;C_2)&nbsp;&amp;:&nbsp;i&nbsp;\&nbsp;em&nbsp;[1..n]&nbsp;\&nbsp;Resultado&nbsp;[i]&nbsp;=&nbsp;máximo&nbsp;(C_1.V&nbsp;[i],&nbsp;C_2.V&nbsp;[i])&nbsp;\&nbsp;end&nbsp;{align</span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-6"> \ begin {align} inc () &: V [id ()] = V [id ()] + 1 \\ valor () &: \ sum_ {i = 0} ^ {n} V [i] \\ mesclar (C_1, C_2) &: i \ em [1..n] \ Resultado [i] = máximo (C_1.V [i], C_2.V [i]) \ end {align</script></p><br>  Você também pode usar o G-Set (veja abaixo) <br><br>  Aplicação: <br><br><ul><li>  Contando cliques / hits (sic!) </li></ul><br>  <u>Contador com suporte de decremento (contador PN)</u> <br><br>  Começamos dois contador G - um para operações de incremento, o segundo - para decremento <br><br>  Aplicação: <br><br><ul><li>  O número de usuários conectados em uma rede p2p, como o Skype </li></ul><br>  <u>Contador não negativo</u> <br><br>  Uma implementação simples ainda não existe.  Sugira suas idéias nos comentários, discuta. <br><br><h2>  6.2 Registrar </h2><br>  Uma célula de memória com duas operações - atribuir (escrever) e valor (ler). <br>  O problema é que a atribuição não é comutativa.  Existem duas abordagens para resolver esse problema: <br><br><h3>  Último registro de vitórias de gravação (LWW-Register): </h3><br>  Entramos no pedido completo por meio da geração de ID exclusivo para cada operação (registro de data e hora, por exemplo). <br><br>  Um exemplo de sincronização é a troca de pares (valor, id): <br><br><div style="text-align:center;"><img width="600" src="https://habrastorage.org/webt/rw/8m/1k/rw8m1k8wgby7v0gczcthhdmdvns.png"></div><br>  Aplicação: <br><br><ul><li>  Colunas em cassandra </li><li>  NFS - arquivo no todo ou em parte </li></ul><br><h3>  Registre-se com vários valores (Multi-Value Register, MV-Register): </h3><br>  A abordagem é semelhante a um contador G - armazenamos o conjunto (valor, vetor de versão).  Registre o valor - todos os valores, ao mesclar - o LWW separadamente para cada valor no vetor. <br><br><div style="text-align:center;"><img width="600" src="https://habrastorage.org/webt/o3/kr/vc/o3krvcuowzsa-vi_avn27jcscxk.png"></div><br>  Aplicação: <br><br><ul><li>  Cesta na Amazônia.  Um bug conhecido é associado a isso, quando, após remover um item da cesta, ele aparece lá novamente.  O motivo é que, apesar do registro armazenar um conjunto de valores, ele não é um conjunto (veja a figura abaixo).  A propósito, a Amazon nem considera isso um bug - na verdade, aumenta as vendas. </li><li>  Riak.  Em um caso mais geral, mudamos o problema de escolher o valor real (observação - não há conflito!) Para o aplicativo. </li></ul><br>  Explicação do bug na Amazon: <br><br><div style="text-align:center;"><img width="600" src="https://habrastorage.org/webt/k0/au/le/k0auleq-jjcrfdtkdswe8tfdxnq.png"></div><br><br><h2>  6.3 Lotes </h2><br>  O conjunto é o tipo básico para a construção de contêineres, mapas e gráficos e suporta operações - add e rmv, que não são comutativas. <br><br>  Considere a implementação ingênua do conjunto baseado em op, no qual add e rmv são executados à medida que chegam (add chega a 1 e 2 réplicas ao mesmo tempo e, em seguida, rmv vai para 1) <br><br><div style="text-align:center;"><img width="600" src="https://habrastorage.org/webt/yk/uu/3b/ykuu3b4-brgkjj2p4y32gmytafs.png"></div><br>  Como você pode ver, as réplicas eventualmente se dispersaram.  Considere as várias opções para construir conjuntos sem conflito: <br><br><h3>  Conjunto crescente (G-Set): </h3><br>  A solução mais fácil é impedir que itens sejam excluídos.  Tudo o que resta é a operação de adição, que é comutativa.  A função de mesclagem é a união de conjuntos. <br><br><h3>  Conjunto bifásico (conjunto 2P): </h3><br>  Permitimos que você exclua, mas não será possível adicioná-lo novamente após a remoção.  Para implementar, configuramos um conjunto separado de elementos remotos do conjunto G (esse conjunto é chamado de conjunto de marca de exclusão) <br>  Exemplo para baseado em estado: <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-72"><span class="noError" id="MJXp-Span-73" style="display: inline-block;">\&nbsp;begin&nbsp;{align}&nbsp;pesquisa&nbsp;(e)&nbsp;&amp;:&nbsp;e&nbsp;\&nbsp;em&nbsp;A&nbsp;\&nbsp;land&nbsp;e&nbsp;\&nbsp;não&nbsp;em&nbsp;R&nbsp;\\&nbsp;add&nbsp;(e)&nbsp;&amp;:&nbsp;A&nbsp;=&nbsp;A&nbsp;\&nbsp;cup&nbsp;\&nbsp;{e&nbsp;\}&nbsp;\\&nbsp;rmv&nbsp;(e)&nbsp;&amp;:&nbsp;R&nbsp;=&nbsp;R&nbsp;\&nbsp;cup&nbsp;\&nbsp;{e&nbsp;\}&nbsp;\\&nbsp;mesclar&nbsp;(S_1,&nbsp;S_2)&nbsp;&amp;:&nbsp;\\&nbsp;Res&nbsp;&amp;&nbsp;ult.A&nbsp;=&nbsp;S_1.A&nbsp;\&nbsp;cup&nbsp;S_2.A&nbsp;\\&nbsp;Res&nbsp;&amp;&nbsp;ult.R&nbsp;=&nbsp;S_1.R&nbsp;\&nbsp;cup&nbsp;S_2.R&nbsp;\&nbsp;end&nbsp;{align}</span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-7"> \ begin {align} pesquisa (e) &: e \ em A \ land e \ não em R \\ add (e) &: A = A \ cup \ {e \} \\ rmv (e) &: R = R \ cup \ {e \} \\ mesclar (S_1, S_2) &: \\ Res & ult.A = S_1.A \ cup S_2.A \\ Res & ult.R = S_1.R \ cup S_2.R \ end {align} </script></p><br><h3>  Conjunto de elementos LWW: </h3><br>  A próxima maneira de implementar um conjunto sem conflito é introduzir um pedido completo, uma das opções é gerar registros de data e hora exclusivos para cada elemento. <br><br>  Temos dois conjuntos - add-set e remove-set, quando add () é chamado, add (elemento, unique_id ()), ao verificar se há um elemento no conjunto - veja onde o timestamp é maior - em remove-set ou em add-set <br><br><div style="text-align:center;"><img width="600" src="https://habrastorage.org/webt/iw/gt/95/iwgt95jsuu9xps80j0w-sjgweq4.png"></div><br><h3>  Conjunto PN: </h3><br>  Variação com a ordenação do conjunto - iniciamos um contador para cada elemento, quando o adicionamos, aumentamos, quando o excluímos, diminuímos.  Um elemento está no conjunto se seu contador for positivo. <br><div style="text-align:center;"><img width="600" src="https://habrastorage.org/webt/nf/qz/dw/nfqzdwf7risphmn8qyuq0tsjc3s.png"></div><br>  Observe o efeito interessante - na terceira réplica, adicionar um elemento não leva à sua aparência. <br><br><h3>  Conjunto Observar-Remover, Conjunto OR ou Conjunto Add-Win: </h3><br>  Nesse tipo, adicionar tem precedência sobre remover.  Exemplo de implementação: a cada elemento adicionado recentemente é atribuída uma tag exclusiva (relativa ao elemento e não ao conjunto inteiro).  Rmv remove um elemento do conjunto e envia todos os pares vistos (elemento, tag) para as réplicas para remoção. <br><br><div style="text-align:center;"><img width="600" src="https://habrastorage.org/webt/5n/ac/1l/5nac1lanif5y_kh_w9rvaz-jqoe.png"></div><br><br><h3>  Conjunto Remover-Ganhar: </h3><br>  Semelhante ao anterior, mas ao mesmo tempo, add / rmv rmv vence. <br><br><h2>  6.4 Gráfico </h2><br>  Este tipo é construído com base em muitos.  O problema é o seguinte: se houver operações simultâneas addEdge (u, v) e removeVertex (u) - o que devo fazer?  As seguintes opções são possíveis: <br><br><ul><li>  Prioridade RemoveVertex, todas as arestas incidentes nesse vértice são excluídas </li><li>  Prioridade AddEdge, vértices excluídos restaurados </li><li>  Adiamos a execução do removeVertex até que todos os addEdge simultâneos sejam executados. </li></ul><br>  A opção mais fácil é a primeira, para sua implementação (gráfico 2P2P) basta obter dois conjuntos 2P, um para os vértices e o segundo para as arestas <br><br><h2>  6.5 Mapa </h2><br><h3>  Mapa de literais: </h3><br>  Dois problemas a resolver: <br><br><ul><li>  O que fazer com operações de venda simultânea?  Por analogia com os contadores, você pode escolher semântica LWW ou MV </li><li>  O que fazer com o put / rmv simultâneo?  Por analogia com os conjuntos, é possível semântica put-wins ou rmv-wins ou last-put-wins. </li></ul><br><h3>  Mapeamento CRDT (Mapa de CRDTs): </h3><br>  Um caso mais interessante, porque  permite criar mapeamentos aninhados.  Não consideramos casos de alteração de tipos aninhados - isso deve ser decidido pelo próprio CRDT aninhado. <br><br>  <u>Mapa Remover-como-redefinição recursiva</u> <br><br>  A operação de remoção "redefine" o valor do tipo para um determinado estado inicial.  Por exemplo, para um contador, esse é um valor zero. <br><br>  Considere um exemplo - uma lista de compras geral.  Um dos usuários adiciona farinha e o segundo faz uma finalização da compra (isso leva a uma chamada para a operação de exclusão em todos os elementos).  Como resultado, uma unidade de farinha permanece na lista, o que parece lógico. <br><br><div style="text-align:center;"><img width="700" src="https://habrastorage.org/webt/9g/sn/4j/9gsn4jdmbdg_ba1hdrmftl5mcgy.png"></div><br>  <u>Mapa Remove-wins</u> <br><br>  A operação rmv tem precedência. <br><br>  Exemplo: em um jogo online, um jogador de Alice tem 10 moedas e um martelo.  Em seguida, dois eventos ocorrem simultaneamente: na réplica A, ela produziu uma unha, e na réplica B, seu personagem é excluído com a remoção de todos os objetos: <br><br><div style="text-align:center;"><img width="700" src="https://habrastorage.org/webt/tb/xd/6s/tbxd6s7eun3rpn57mnwt9d4hbxa.png"></div><br><br>  Observe que, ao usar remover como recursivo, uma unha acabaria por permanecer, o que não é o estado correto quando o personagem é removido. <br><br>  <u>Atualizar mapa de vitórias</u> <br><br>  As atualizações têm precedência, ou melhor, cancelam operações anteriores para excluir rmv simultâneas. <br><br>  Exemplo: em um jogo online, o personagem Alice na réplica B é excluído devido à inatividade, mas a atividade ocorre na réplica A ao mesmo tempo.  Obviamente, a operação de exclusão deve ser cancelada. <br><br><div style="text-align:center;"><img width="700" src="https://habrastorage.org/webt/63/oz/5y/63oz5yzch4ioguyram3erawkzl0.png"></div><br>  Há um efeito interessante ao trabalhar com essa implementação - suponha que tenhamos duas réplicas, A e B, e elas armazenem o conjunto por alguma chave k.  Então, se A excluir o valor da chave k e B excluir todos os elementos do conjunto, no final, as réplicas deixarão um conjunto vazio com a chave k. <br><br>  Observe que uma implementação ingênua não funcionará corretamente - você não pode simplesmente desfazer todas as operações de exclusão anteriores.  No exemplo a seguir, com essa abordagem, o estado final seria o estado inicial, incorreto: <br><br><div style="text-align:center;"><img width="700" src="https://habrastorage.org/webt/mp/un/hm/mpunhmkzj125hqob4net7iq7kc4.png"></div><br><h2>  Lista </h2><br>  O problema com esse tipo é que os índices de itens em réplicas diferentes serão diferentes após as operações locais de inserção / exclusão.  Para resolver esse problema, a abordagem Transformação operacional é aplicada - ao aplicar a alteração obtida, o índice do elemento na réplica original deve ser levado em consideração. <br><br><h1>  7. Riak </h1><br>  Como exemplo, considere o CRDT em Riak: <br><br><ul><li>  Contador: Contador PN </li><li>  Conjunto: Conjunto OR </li><li>  Mapa: atualização ganha mapa de CRDTs </li><li>  Sinalizador (booleano): OR-Defina onde no máximo 1 elemento </li><li>  Registro: pares (valor, registro de data e hora) </li></ul><br><h1>  8. Quem usa CRDT </h1><br>  A seção <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">wiki</a> contém bons exemplos. <br><br><h1>  9. Referências </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Lojas Key-CRDT</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Um tipo de dados JSON replicado sem conflitos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Um estudo abrangente dos tipos de dados replicados convergentes e comutativos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tipo de dados replicado convergente e comutativo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tipo de dados replicado sem conflitos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Um guia de bluffers para CRDTs em Riak</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CRDTs: uma atualização (ou apenas um PUT)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tipos de dados replicados sem conflitos: uma visão geral</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Consistência Eventual Forte e Tipos de Dados Replicados sem Conflitos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Estruturas de dados eventualmente consistentes</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt418897/">https://habr.com/ru/post/pt418897/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt418885/index.html">Crispr pode acelerar processos naturais e mudar a forma como os alimentos são cultivados</a></li>
<li><a href="../pt418887/index.html">Quão rápido o universo está se expandindo?</a></li>
<li><a href="../pt418889/index.html">Guia de Teste de Aplicação Manual: Benefícios, Etapas e Metodologias</a></li>
<li><a href="../pt418891/index.html">Verificamos os códigos-fonte do Android usando o PVS-Studio, ou ninguém é perfeito</a></li>
<li><a href="../pt418895/index.html">Aprenda Inteligência Artificial para jogar um jogo</a></li>
<li><a href="../pt418899/index.html">Primeiras impressões e ações após a atualização do MySQL da versão 5.7 para 8.0.11</a></li>
<li><a href="../pt418901/index.html">Os russos conquistaram a maioria das medalhas de ouro na Olimpíada Europeia de Ciência da Computação eJOI 2018</a></li>
<li><a href="../pt418903/index.html">Cientistas: não há CO₂ suficiente em Marte para aquecer a atmosfera. Explosão de pólo não vai ajudar</a></li>
<li><a href="../pt418905/index.html">InlineKeyboard em telegram bots</a></li>
<li><a href="../pt418907/index.html">Como ensinar o Zabbix a enviar notificações de problemas diretamente para a área de trabalho</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>