<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💜 ⏮️ 🧜🏾 哦，牛顿的方法 🤮 🦏 🍌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="关于数值优化方法的文章很多。 这是可以理解的，尤其是在深度神经网络最近展示的成功背景下。 令人欣慰的是，至少一些发烧友不仅对如何在已经流行于这些Internet的框架上轰炸他们的神经网络感兴趣，而且对它们如何工作以及为什么起作用感兴趣。 但是，我最近不得不指出，在提出与神经网络训练有关的问题时（不仅...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>哦，牛顿的方法</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469877/"> 关于数值优化方法的文章很多。 这是可以理解的，尤其是在深度神经网络最近展示的成功背景下。 令人欣慰的是，至少一些发烧友不仅对如何在已经流行于这些Internet的框架上轰炸他们的神经网络感兴趣，而且对它们如何工作以及为什么起作用感兴趣。 但是，我最近不得不指出，在提出与神经网络训练有关的问题时（不仅与训练有关，而且不仅与网络有关），包括在哈布雷（Habré）上，越来越多地使用许多“知名”语句进行转发，其有效性简单地说，令人怀疑。 在这些可疑的陈述中： <br><br><ol><li> 在训练神经网络的任务中，二阶或更多阶的方法效果不佳。 因为那样 </li><li> 牛顿法需要正弦确​​定性的Hessian矩阵（二阶导数），因此效果不佳。 <br></li><li>  Levenberg-Marquardt方法是梯度下降和Newton方法之间的折衷，通常是启发式的。 <br></li></ol><br> 等 与继续这份名单相比，开始做生意最好。 在这篇文章中，我们将考虑第二个陈述，因为我在哈布雷至少只见过他两次。 我将仅在涉及牛顿法的部分中提及第一个问题，因为它的范围要广得多。 第三和其余的将留给更好的时间。 <br><a name="habracut"></a><br> 我们关注的焦点将是无条件优化的任务 <img src="https://habrastorage.org/getpro/habr/post_images/823/e50/c93/823e50c935e4cc19a175f53c17ca79af.gif" title="“ f（x）\ rightarrow \ min”"> 在哪里 <img src="https://habrastorage.org/getpro/habr/post_images/bc7/838/e10/bc7838e10e143195c0381efbf0671cce.gif" title="“ x =（x_ {1}，x_ {2}，\点）”">  -向量空间的一个点，或者干脆-向量。 当然，我们了解的越多，这项任务就越容易解决 <img src="https://habrastorage.org/getpro/habr/post_images/188/ee6/44e/188ee644e8202aad30eac11166858841.gif" title="“ f”">  。 通常认为每个参数都有区别 <img src="https://habrastorage.org/getpro/habr/post_images/6d8/d4e/07d/6d8d4e07d259325d5dd652e4b3b97af6.gif" title="“ x_ {k}”">  ，以及我们肮脏的事所需的次数。 众所周知，这一点的必要条件 <img src="https://habrastorage.org/getpro/habr/post_images/8ae/e32/d7e/8aee32d7e93fb189b268894bf91622b0.gif" title="“ x ^ {*}”"> 达到最小值，是函数的梯度相等 <img src="https://habrastorage.org/getpro/habr/post_images/735/1d5/454/7351d54544ca7acc4b7a9bff7a2c2f6a.gif" title="“ \ bigtriangledown f（x ^ {*}）”"> 此时为零。 从这里，我们立即获得以下最小化方法： <br><br> 解方程 <img src="https://habrastorage.org/getpro/habr/post_images/d59/223/ac1/d59223ac159bfe660ea26a1d60f8f33f.gif" title="“ \ bigtriangledown f（x）= 0”">  。 <br><br> 温和地说，这项任务并不容易。 绝对不比原来容易。 但是，在这一点上，我们可以立即注意到最小化问题和求解非线性方程组问题之间的联系。 在考虑使用Levenberg-Marquardt方法时（当我们使用它时），这种联系会重新出现。 同时，请记住（或发现）牛顿法是求解非线性方程组的最常用方法之一。 它在于以下事实： <img src="https://habrastorage.org/getpro/habr/post_images/0a0/ec7/804/0a0ec780406efe57ca6444290ccfde09.gif" title="“ F（x）= 0”"> 我们从一些初始近似开始 <img src="https://habrastorage.org/getpro/habr/post_images/460/82f/7d6/46082f7d6471c3fabb832d8f94075758.gif" title="“ x_ {0}”"> 建立一个序列 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3a0/23d/4a2/3a023d4a27cdff86f8cf3bc78d5b3a21.gif" title="“ x_ {i + 1} = x_ {i} -H ^ {-1}（x_ {i}）F（x_ {i}）”">  -牛顿的显式方法 <br><br> 或 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/116/6fa/27b/1166fa27b4038fed75d435daaaab53fe.gif" title="“ \开始{cases} H（x_ {i}）p_ {i} =-F（x_ {i}）\\ x_ {i + 1} = x_ {i} + p_ {i} \ end {cases””">  -牛顿的隐式方法 <br><br> 在哪里 <img src="https://habrastorage.org/getpro/habr/post_images/bc8/190/17b/bc819017bab0b9f9d995f262f3f76a42.gif" title="“ H”">  -由函数的偏导数组成的矩阵 <img src="https://habrastorage.org/getpro/habr/post_images/01a/a15/8fc/01aa158fc8bc3d7f7f3b2807df8b4a5e.gif" title="“ F”">  。 自然，在一般情况下，当简单地将非线性方程组简单地带给我们时，就需要从矩阵中得到一些东西。 <img src="https://habrastorage.org/getpro/habr/post_images/bc8/190/17b/bc819017bab0b9f9d995f262f3f76a42.gif" title="“ H”"> 我们没有资格。 在方程是某个函数的最小条件的情况下，我们可以说矩阵 <img src="https://habrastorage.org/getpro/habr/post_images/bc8/190/17b/bc819017bab0b9f9d995f262f3f76a42.gif" title="“ H”"> 对称的。 但没有更多。 <br><br> 牛顿法求解非线性方程组的方法已得到很好的研究。 这就是问题-对于其收敛，不需要矩阵的正定性 <img src="https://habrastorage.org/getpro/habr/post_images/bc8/190/17b/bc819017bab0b9f9d995f262f3f76a42.gif" title="“ H”">  。 是的，并且不需要，否则他将一文不值。 取而代之的是，还有其他条件可以确保这种方法的局部收敛，在此我们将不予考虑，从而将感兴趣的人员吸引到专业文献中（或在评论中）。 我们得到陈述2为假。 <br><br> 那呢 <br><br> 是的，没有。 这个词的伏击是该词之前的局部收敛。 这意味着初始近似 <img src="https://habrastorage.org/getpro/habr/post_images/460/82f/7d6/46082f7d6471c3fabb832d8f94075758.gif" title="“ x_ {0}”"> 必须与解决方案“足够近”，否则在每个步骤中，我们都将越来越远。 怎么办 我不会详细介绍如何解决一般形式的非线性方程组的问题。 相反，回到我们的优化任务。 陈述2的第一个错误实际上是通常说到优化问题中的牛顿法，这意味着它的修改-阻尼牛顿法，其中根据规则构造了近似序列。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/23d/ca8/404/23dca84042b77a1560b8cd2db607e8ae.gif" title="“ x_ {i + 1} = x_ {i}-\ alpha_ {i} H ^ {-1}（x_ {i}）F（x_ {i}）”">  -牛顿的显式阻尼方法 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9d4/67c/c96/9d467cc96266cf1179d3e553718f5bee.gif" title="“ \开始{cases} H（x_ {i}）p_ {i} =-F（x_ {i}）\\ x_ {i + 1} = x_ {i} + \ alpha_ {i} p_ {i} \结束{cases}“">  -牛顿的隐式阻尼方法 <br><br> 这是顺序 <img src="https://habrastorage.org/getpro/habr/post_images/c70/738/fd1/c70738fd1eb4d9bfff34f20904f41bbf.gif" title="“ \ {\ alpha_ {i} \}”"> 是该方法的参数，其构造是单独的任务。 在最小化问题中，选择时自然 <img src="https://habrastorage.org/getpro/habr/post_images/eb2/94d/fe4/eb294dfe4cfca7355f8b030f3d7dade8.gif" title="“ \ alpha_ {i}”"> 要求在每次迭代中函数f的值减小，即 <img src="https://habrastorage.org/getpro/habr/post_images/3ae/e45/ba0/3aee45ba0097ca8bdc8a23ef6a465f21.gif" title="“ f（x_ {i + 1}）＆lt; f（x_ {i}）”">  。 逻辑上出现了一个问题：是否存在这样的（正面） <img src="https://habrastorage.org/getpro/habr/post_images/eb2/94d/fe4/eb294dfe4cfca7355f8b030f3d7dade8.gif" title="“ \ alpha_ {i}”">  ？ 如果这个问题的答案是肯定的，那么 <img src="https://habrastorage.org/getpro/habr/post_images/cf2/deb/64e/cf2deb64e8b0e4d34902a32a5fd93b7b.gif" title="“ p_ {i}”"> 称为下降方向。 然后可以通过以下方式提出问题： <br>  <i>牛顿法生成的方向何时是下降方向？</i> <br> 要回答这个问题，您将不得不从另一侧看待最小化问题。 <br><br><h2> 下降方法 </h2><br> 对于最小化问题，此方法似乎很自然：从任意点开始，我们以某种方式选择方向p并朝该方向迈出一步 <img src="https://habrastorage.org/getpro/habr/post_images/fbf/01e/b21/fbf01eb21703831c5dd0e196a2efccc2.gif" title="“ \ alpha p”">  。 如果 <img src="https://habrastorage.org/getpro/habr/post_images/bd9/6f9/580/bd96f95806b05f65a5766db233a85653.gif" title="“ f（x + \ alpha p）＆lt; f（x）”"> 然后拿 <img src="https://habrastorage.org/getpro/habr/post_images/b87/e59/538/b87e59538ed10c96ec3db2e7bad8dc85.gif" title="“ x + \ alpha p”"> 作为新的起点，然后重复该过程。 如果方向是任意选择的，那么这种方法有时称为随机游走法。 可以将单位基向量作为方向-即，仅在一个坐标中迈出一步，该方法称为坐标下降法。 不用说，它们无效吗？ 为了使此方法正常工作，我们需要一些额外的保证。 为此，我们引入了辅助功能 <img src="https://habrastorage.org/getpro/habr/post_images/8bf/1d5/4e1/8bf1d54e1f36dd4c9dfd5720437af51c.gif" title="“ g（p）= f（x + p）”">  。 我认为最小化很明显 <img src="https://habrastorage.org/getpro/habr/post_images/188/ee6/44e/188ee644e8202aad30eac11166858841.gif" title="“ f”"> 完全等同于最小化 <img src="https://habrastorage.org/getpro/habr/post_images/da7/7c5/b48/da77c5b4891cf3d059f1b04a28b230ef.gif" title="“G”">  。 如果 <img src="https://habrastorage.org/getpro/habr/post_images/188/ee6/44e/188ee644e8202aad30eac11166858841.gif" title="“ f”"> 然后可区分 <img src="https://habrastorage.org/getpro/habr/post_images/da7/7c5/b48/da77c5b4891cf3d059f1b04a28b230ef.gif" title="“G”"> 可以表示为 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e47/615/d31/e47615d310276ab67a9163889a2335a5.gif" title="“ g（p）= f（x）+ \ bigtriangledown f ^ {T}（x）p + o（\ parallel p \ parallel ^ {2}）”"><br><br> 如果 <img src="https://habrastorage.org/getpro/habr/post_images/2a7/342/acb/2a7342acbe0772f75af6eee281c247d0.gif" title="“ \平行p \平行”"> 那么小 <img src="https://habrastorage.org/getpro/habr/post_images/2ef/8a9/23f/2ef8a923f49cf84264effb5f3f703c31.gif" title="“ g（p）\大约\ bar {g}（p）= f（x）+ \ bigtriangledown f ^ {T}（x）p”">  。 我们现在可以尝试替换最小化问题 <img src="https://habrastorage.org/getpro/habr/post_images/076/563/484/076563484d4e576c5c48098bfa94d45c.gif" title="“克（p）”"> 使其近似值（或<i>模型</i> ）最小化的任务 <img src="https://habrastorage.org/getpro/habr/post_images/174/774/888/1747748884846362babfd8fe73857f1e.gif" title="“ \ bar {g}（p）”">  。 顺便说一下，所有基于使用方法的模型 <img src="https://habrastorage.org/getpro/habr/post_images/174/774/888/1747748884846362babfd8fe73857f1e.gif" title="“ \ bar {g}（p）”"> 称为渐变。 但是麻烦是 <img src="https://habrastorage.org/getpro/habr/post_images/462/957/dda/462957dda265f4fb8be04327f1c12b0f.gif" title="“ \ bar {g}”"> 是线性函数，因此没有最小值。 为了解决此问题，我们对要执行的步骤的长度添加了限制。 在这种情况下，这是完全自然的要求-因为我们的模型或多或少正确地仅在足够小的邻域中描述了目标函数。 结果，我们获得了条件优化的另一个问题： <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/8a2/c43/279/8a2c4327974067619cfad20b7ea1e821.gif" title="\\\ bar {g}（p）= f（x）+ \ bigtriangledown f ^ {T}（x）p \ rightarrow \ min \\ \ parallel p \ parallel_ {2} = \ Delta"></a> <br><br> 此任务有一个明显的解决方案： <img src="https://habrastorage.org/getpro/habr/post_images/3ff/1f6/a21/3ff1f6a2117e5d9a99603bcc8fde4f69.gif" title="“ p =-\ beta \ bigtriangledown f（x）”"> 在哪里 <img src="https://habrastorage.org/getpro/habr/post_images/76d/0eb/69b/76d0eb69ba026a58bbe3edd275fee712.gif" title="“ \ beta”">  -保证满足约束条件的因素。 然后，下降法的迭代形式为 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/966/987/c25/966987c257a50df1855a50ea363350dd.gif" title="“ x_ {i + 1} = x_ {i}-\ beta \ bigtriangledown f（x_ {i}）”">  ， <br><br> 在其中我们学习了著名的<b>梯度下降法</b> 。 参量 <img src="https://habrastorage.org/getpro/habr/post_images/76d/0eb/69b/76d0eb69ba026a58bbe3edd275fee712.gif" title="“ \ beta”">  ，通常称为下降速度，现在已经具有可以理解的含义，其值是根据新点位于给定半径的球体上（围绕旧点外接）的条件确定的。 <br><br> 根据目标函数构造模型的性质，我们可以认为 <img src="https://habrastorage.org/getpro/habr/post_images/a2b/068/6ad/a2b0686adbc103ad9f96be85cca5d418.gif" title="“ \三角洲”">  ，即使很小，如果 <img src="https://habrastorage.org/getpro/habr/post_images/84b/5fd/00f/84b5fd00fe1f4ca32b7cd7bd095a1490.gif" title="“ \ bar {g}（p）＆lt; \ bar {g}（0）”"> 然后 <img src="https://habrastorage.org/getpro/habr/post_images/553/80b/dc5/55380bdc5a434366df6d181078d6a8b7.gif" title="“ g（p）＆lt; g（0）”">  。 值得注意的是，在这种情况下，我们的移动方向并不取决于该球体半径的大小。 然后，我们可以选择以下方式之一： <br><br><ol><li> 根据某种方法选择值 <img src="https://habrastorage.org/getpro/habr/post_images/a2b/068/6ad/a2b0686adbc103ad9f96be85cca5d418.gif" title="“ \三角洲”">  。 </li><li> 设置选择适当值的任务 <img src="https://habrastorage.org/getpro/habr/post_images/76d/0eb/69b/76d0eb69ba026a58bbe3edd275fee712.gif" title="“ \ beta”">  ，从而降低了目标函数的值。 </li></ol><br> 第一种方法是<i>信任区域方法的</i>典型<i>方法</i> ，第二种方法导致了所谓的辅助问题的形成。  <i>线性搜索（LineSearch）</i> 。 在这种特殊情况下，这些方法之间的差异很小，我们将不予考虑。 相反，请注意以下几点： <br><br>  <b><i>为什么我们实际上在寻找补偿</i></b> <b><i><img src="https://habrastorage.org/getpro/habr/post_images/4b2/8c1/3d5/4b28c13d5f5d658adb7478fbc9efc923.gif" title="“ p”"></i></b>  <b><i>恰好躺在球上？</i></b> <br><br> 实际上，我们可以用这样的要求很好地替换此限制，例如，p属于立方体的表面，即， <img src="https://habrastorage.org/getpro/habr/post_images/cf1/a35/92e/cf1a3592ebe97c9e262a083ea44c594c.gif" title="“ \平行p \平行_ {\ infty} = \ Delta”">  （在这种情况下，它不太合理，但是为什么不这样）或某些椭圆形的表面呢？ 如果我们回想起最小化沟壑功能时出现的问题，这似乎已经很合逻辑了。 问题的实质是，沿着某些坐标线，函数的变化比沿着其他坐标线的变化快得多。 因此，我们得到如果增量应属于球体，则数量 <img src="https://habrastorage.org/getpro/habr/post_images/a2b/068/6ad/a2b0686adbc103ad9f96be85cca5d418.gif" title="“ \三角洲”"> 提供“下降”的位置应该很小。 这导致一个事实，即达到最低要求将需要大量步骤。 但是，如果相反，我们采用合适的椭圆作为邻域，那么这个问题将神奇地化为泡影。 <br><br> 在椭圆面的点属于的条件下，可以写成 <img src="https://habrastorage.org/getpro/habr/post_images/6ff/1b4/930/6ff1b49309ec84aa656d848764359b4e.gif" title="“ \ parallel p \ parallel_ {B} = \ sqrt {p ^ {T} Bp} = \ Delta”"> 在哪里 <img src="https://habrastorage.org/getpro/habr/post_images/dab/ea9/01c/dabea901c4b1a4079aa96d47bcee4e75.gif" title="“ B”"> 是一些正定矩阵，也称为度量。 规范 <img src="https://habrastorage.org/getpro/habr/post_images/ab8/b42/711/ab8b42711a932f9129bdb193b6a74360.gif" title="“ \ parallel \ cdot \ parallel_ {B}”"> 称为由矩阵引起的椭圆范数 <img src="https://habrastorage.org/getpro/habr/post_images/dab/ea9/01c/dabea901c4b1a4079aa96d47bcee4e75.gif" title="“ B”">  。 这是什么样的矩阵，以及从哪里获得的矩阵-我们将在以后考虑，现在我们开始一项新任务。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/f4c/cc0/757/f4ccc0757e09fb304ff10a9a8c4751b6.gif" title="\\\ bar {g}（p）= f（x）+ \ bigtriangledown f ^ {T}（x）p \ rightarrow \ min \\ \ dfrac {1} {2} \ parallel p \ parallel_ {B} ^ {2} = \ Delta"></a> <br><br> 规范的平方和1/2系数在这里仅仅是为了方便起见，以免混淆根源。 应用拉格朗日乘数法，我们得到了无条件优化的有界问题 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/605/36d/d5e/60536dd5e2297580940a5b926760a3ce.gif" title="f（x）+ \ bigtriangledown f ^ {T}（x）p + \ dfrac {\ lambda} {2} p ^ {T} Bp- \ lambda \ Delta \ rightarrow \ min"></a> <br><br> 最低要求的必要条件是 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/4c5/f7e/921/4c5f7e921637c73fcb992c5d9b9efcd6.gif" title="\ bigtriangledown f（x）+ \ lambda Bp = 0"></a> 或 <img src="https://habrastorage.org/getpro/habr/post_images/a80/6c9/ff7/a806c9ff7ce22ea27c87b6a61a4c8fed.gif" title="“ B \左（\ lambda p \右）=-\ bigtriangledown f（x）”"> 从哪里来 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/b50/032/3a9/b500323a970c7ae821295450627bdad2.gif" title="p =-\ dfrac {1} {\ lambda} B ^ {-1} \ bigtriangledown f（x）= \ dfrac {1} {\ lambda} \ bar {p}"></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/697/906/5d7/6979065d729033e0093ffad8475e80a6.gif" title="\\\ dfrac {1} {\ lambda ^ {2}} \左（B ^ {-1} \ bigtriangledown f（x）\右）^ {T} B \左（B ^ {-1} \ bigtriangledown f （x）\ right）= \ dfrac {1} {\ lambda ^ {2}} \ bigtriangledown f（x）^ {T} B ^ {-1} BB ^ {--1} \ bigtriangledown f（x）= \ \ = \ dfrac {1} {\ lambda ^ {2}} \ bigtriangledown f（x）^ {T} B ^ {-1} \ bigtriangledown f（x）= \ Delta"></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/41f/689/d89/41f689d890b92c84f05fdd0ede8a8114.gif" title="\ lambda = \ sqrt {\ dfrac {1} {\ Delta} \ bigtriangledown f（x）^ {T} B ^ {-1} \ bigtriangledown f（x）}> 0"></a> <br><br> 再次，我们看到了方向 <img src="https://habrastorage.org/getpro/habr/post_images/45b/686/bb0/45b686bb0219a74b212cfdeaf1998653.gif" title="“ \ bar {p} =-B ^ {-1} \ bigtriangledown f（x）”">  ，我们将在其中移动，而不取决于值 <img src="https://habrastorage.org/getpro/habr/post_images/a2b/068/6ad/a2b0686adbc103ad9f96be85cca5d418.gif" title="“ \三角洲”">  -仅从矩阵 <img src="https://habrastorage.org/getpro/habr/post_images/dab/ea9/01c/dabea901c4b1a4079aa96d47bcee4e75.gif" title="“ B”">  。 再说一次，我们可以接载 <img src="https://habrastorage.org/getpro/habr/post_images/a2b/068/6ad/a2b0686adbc103ad9f96be85cca5d418.gif" title="“ \三角洲”"> 充满了计算的需要 <img src="https://habrastorage.org/getpro/habr/post_images/99d/394/e7d/99d394e7d0b74248114405067e0ffd51.gif" title="“ \ lambda”"> 和显式矩阵求逆 <img src="https://habrastorage.org/getpro/habr/post_images/dab/ea9/01c/dabea901c4b1a4079aa96d47bcee4e75.gif" title="“ B”">  ，或解决寻找合适偏差的辅助问题 <img src="https://habrastorage.org/getpro/habr/post_images/b7b/6a7/371/b7b6a73716dc8f4e40a52c1c5ef0e6b4.gif" title="“ x_ {i + 1} = x_ {i} + \ beta \ bar {p} _ {i}”">  。 由于 <img src="https://habrastorage.org/getpro/habr/post_images/0b8/52f/d1b/0b852fd1bbc20f2966bf757a56186312.gif" title="“ \ lambda＆gt; 0”">  ，可以保证存在对此辅助问题的解决方案。 <br><br> 那么矩阵B应该是什么呢？ 我们将自己局限于投机性思想。 如果目标函数 <img src="https://habrastorage.org/getpro/habr/post_images/188/ee6/44e/188ee644e8202aad30eac11166858841.gif" title="“ f”">  -二次方，即具有形式 <img src="https://habrastorage.org/getpro/habr/post_images/974/f7f/cf6/974f7fcf6345b91ef8466f2cabba6efe.gif" title="“ f（x）= a + b ^ {T} x + x ^ {T} Hx”"> 在哪里 <img src="https://habrastorage.org/getpro/habr/post_images/bc8/190/17b/bc819017bab0b9f9d995f262f3f76a42.gif" title="“ H”"> 正定，很明显，矩阵作用的最佳人选 <img src="https://habrastorage.org/getpro/habr/post_images/dab/ea9/01c/dabea901c4b1a4079aa96d47bcee4e75.gif" title="“ B”"> 是粗麻布的 <img src="https://habrastorage.org/getpro/habr/post_images/bc8/190/17b/bc819017bab0b9f9d995f262f3f76a42.gif" title="“ H”">  ，因为在这种情况下，我们需要构造下降法的一个迭代。 如果H不是正定的，则​​它不能是度量，并且以此构造的迭代是阻尼牛顿法的迭代，但不是下降法的迭代。 最后，我们可以给出严格的答案 <br><br>  <b>问题：</b> <i>牛顿法中的黑森矩阵是否必须是正定的？</i> <br>  <b>答：</b> <i>不，在标准牛顿法或阻尼牛顿法中都不需要。</i>  <i>但是，如果满足此条件，则阻尼牛顿法是一种下降法，具有<i>全局性质</i> ，而不仅仅是局部收敛。</i> <br><br> 作为说明，让我们看一下使用梯度下降和牛顿方法将众所周知的Rosenbrock函数最小化时的置信度区域，以及区域的形状如何影响过程的收敛。 <br><br><img src="https://habrastorage.org/webt/_x/30/nx/_x30nxs-eyrixuan0-diyvwixww.gif" width="600"><br><br> 这就是下降方法在球形置信区域内的行为，它也是梯度下降。 一切都像一本教科书-我们陷入了峡谷。 <br><br><img src="https://habrastorage.org/webt/9x/ik/td/9xiktd4lapdka-uk010evfvlcdm.gif" width="600"><br><br> 如果置信区域具有由Hessian矩阵定义的椭圆形状，则可以得到此结果。 这无非是阻尼牛顿法的迭代。 <br><br> 仅解决了如果Hessian矩阵不是正定的怎么办的问题。 有很多选择。 首先是得分。 也许您很幸运，如果没有此属性，牛顿的迭代将收敛。 这是很真实的，尤其是在最小化过程的最后阶段，当您已经足够接近解决方案时。 在这种情况下，可以使用标准牛顿法的迭代，而不必为寻找允许下降的邻域而烦恼。 或者在以下情况下使用阻尼牛顿法的迭代 <img src="https://habrastorage.org/getpro/habr/post_images/6da/2c0/bc5/6da2c0bc54434a64d7630c142d0c7bf9.gif" title="“ \ beta = 0”"> 即，在获得的方向不是下降方向的情况下，例如将其改变为反梯度。  <i>只是不必根据Sylvester准则明确检查Hessian是否为正定</i> ，就象<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>所做的一样<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">！！！</a>  。 这是浪费和毫无意义的。 <br> 更细微的方法涉及在某种程度上接近于Hessian矩阵构造一个矩阵，但是具有正定性的特性，尤其是通过校正特征值。 另一个主题是拟牛顿法或可变度量方法，它们可以保证矩阵B的正定性，并且不需要计算二阶导数。 通常，对这些问题的详细讨论已经超出了本文的范围。 <br><br> 是的，顺便说一句，根据所说的， <i>具有Hessian正定性的牛顿阻尼法是一种梯度法</i> 。 以及拟牛顿法。 还有许多其他选择，是基于方向和步长的单独选择。 因此，将牛顿法与梯度术语进行对比是不正确的。 <br><br><h2> 总结一下 </h2><br> 在讨论最小化方法时通常会记住的牛顿法通常不是经典意义上的牛顿法，而是具有由目标函数的黑森（Hessian）指定的度量的下降法。 是的，如果Hessian到处都是肯定的，它将在全球范围内收敛。 这仅对于凸函数是可行的，凸函数实际上在实践中要比我们想要的少得多，因此在一般情况下，如果没有适当的修改，牛顿方法的应用（我们不会脱离集合并继续称其为）不能保证正确的结果。 训练神经网络，甚至是浅层神经网络，通常会导致许多局部极小值出现非凸优化问题。 这是一次新的伏击。 牛顿法通常会快速收敛（如果收敛）。 我的意思是非常快。 奇怪的是，这很不好，因为我们在几次迭代中都达到了局部最小值。 对于具有复杂地形的功能，它可能比全局功能差很多。 线性搜索的梯度下降收敛速度要慢得多，但更有可能“跳过”目标函数的波峰，这在最小化的早期阶段非常重要。 如果您已经充分降低了目标函数的值，并且梯度下降的收敛速度显着降低，则此处度量的更改可能会加速该过程，但这是最后阶段。 <br><br> 当然，这种说法不是普遍的，也不是毫无争议的，在某些情况下甚至是不正确的。 以及关于梯度方法在学习问题中效果最好的说法。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN469877/">https://habr.com/ru/post/zh-CN469877/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN469865/index.html">700名员工和多个大洲：Alconost如何建立无办公室业务模式</a></li>
<li><a href="../zh-CN469867/index.html">它如何变成小学生（以及棋盘游戏与它有什么关系）</a></li>
<li><a href="../zh-CN469869/index.html">为什么要超频RAM（这很简单！）</a></li>
<li><a href="../zh-CN469871/index.html">当键盘是桌子时</a></li>
<li><a href="../zh-CN469875/index.html">如何在2019年保护密码</a></li>
<li><a href="../zh-CN469879/index.html">一键双击VPN。 如何轻松拆分入口和出口点的IP地址</a></li>
<li><a href="../zh-CN469881/index.html">哈布雷（Habré）上一则帖子的前三天</a></li>
<li><a href="../zh-CN469883/index.html">可以编程随机性吗？</a></li>
<li><a href="../zh-CN469885/index.html">使用x11vnc时禁用本地控制台</a></li>
<li><a href="../zh-CN469889/index.html">SamsPcbGuide，第12部分：技术-BGA型外壳，塑料和空间II</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>