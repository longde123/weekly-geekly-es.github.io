<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖕🏿 🏄 🦗 Kein einziger ORM 🌛 🏓 🦎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kein einziger ORM 


 Hallo allerseits! Ich bin verantwortlich für die Partnerentwicklungsabteilung des Hotelreservierungsdienstes Ostrovok.ru . In di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kein einziger ORM</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ostrovok/blog/447706/"><h1 id="ne-ormom-edinym">  Kein einziger ORM </h1><br><p>  Hallo allerseits!  Ich bin verantwortlich für die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Partnerentwicklungsabteilung des</a> Hotelreservierungsdienstes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ostrovok.ru</a> .  In diesem Artikel möchte ich darüber sprechen, wie wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Django ORM</a> für ein Projekt verwendet haben. </p><br><p>  Tatsächlich habe ich getäuscht, der Name hätte " <del>  Nicht </del>  ORM single ". Wenn Sie sich fragen, warum ich das geschrieben habe und ob: </p><br><ul><li> Sie haben Django auf dem Stapel und möchten das Maximum aus ORM <code>Model.objects.all()</code> , nicht nur <code>Model.objects.all()</code> , </li><li>  Sie möchten einen Teil der Geschäftslogik auf die Datenbankebene übertragen. </li><li>  Oder möchten Sie herausfinden, warum die häufigste Entschuldigung für Entwickler bei B2B.Ostrovok.ru <em>"so historisch"</em> ist? </li></ul><br><p>  ... willkommen bei cat. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/66b/308/b1c/66b308b1cd5afefead46ef7bffdbbddf.jpg" alt="cdpv"></p><a name="habracut"></a><br><p>  2014 haben wir B2B.Ostrovok.ru gestartet - einen Online-Buchungsservice für Hotels, Transfers, Autos und andere Reisedienstleistungen für Fachleute auf dem Tourismusmarkt (Reisebüros, Betreiber und Firmenkunden). </p><br><p>  Im B2B-Bereich haben wir ein abstraktes Bestellmodell basierend auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>GenericForeignKey</code></a> - Meta Order - <code>MetaOrder</code> entworfen und recht erfolgreich verwendet. </p><br><p>  Eine Meta-Bestellung ist eine abstrakte Entität, die unabhängig von der Art der Bestellung verwendet werden kann: ein Hotel ( <code>Hotel</code> ), ein zusätzlicher Service ( <code>Upsell</code> ) oder ein Auto ( <code>Car</code> ).  In Zukunft werden möglicherweise andere Typen angezeigt. </p><br><p>  Das war nicht immer so.  Als der B2B-Service eingeführt wurde, konnten nur Hotels über ihn gebucht werden, und die gesamte Geschäftslogik war auf sie ausgerichtet.  Es wurden viele Felder erstellt, um beispielsweise die Wechselkurse des Verkaufsbetrags und des Reservierungsrückerstattungsbetrags anzuzeigen.  Im Laufe der Zeit haben wir erkannt, wie diese Daten angesichts der Meta-Bestellungen am besten gespeichert und wiederverwendet werden können.  Der gesamte Code konnte jedoch nicht umgeschrieben werden, und ein Teil dieses Erbes floss in die neue Architektur ein.  Tatsächlich führte dies zu Schwierigkeiten bei den Berechnungen, bei denen verschiedene Arten von Aufträgen verwendet werden.  Was zu tun ist - also <em>historisch</em> ... </p><br><p>  Mein Ziel ist es, die Kraft von Django ORM in unserem Beispiel zu zeigen. </p><br><h2 id="predystoriya">  Hintergrund </h2><br><p>  Um ihre Ausgaben zu planen, fehlten unseren B2B-Kunden wirklich Informationen darüber, wie viel sie jetzt / morgen / später bezahlen müssen, ob sie Schulden für Bestellungen haben und wie groß diese sind und wie viel mehr sie innerhalb ihrer Grenzen ausgeben können.  Wir haben uns entschlossen, diese Informationen in Form eines Dashboards anzuzeigen - einer so einfachen Steckdose mit einem übersichtlichen Diagramm. </p><br><p><img src="https://habrastorage.org/webt/2a/rj/yo/2arjyoaa9_xfe8ddcaz5qn4w5mu.gif" alt="dash1"><br>  <em>(Alle Werte sind Testwerte und gelten nicht für einen bestimmten Partner.)</em> </p><br><p>  Auf den ersten Blick ist alles ganz einfach - wir filtern alle Bestellungen des Partners, fassen zusammen und zeigen. </p><br><h2 id="varianty-resheniya">  Lösungsoptionen </h2><br><p>  Eine kleine Erklärung, wie wir Berechnungen durchführen.  Wir sind ein internationales Unternehmen, unsere Partner aus verschiedenen Ländern führen Operationen - Kauf und Wiederverkauf von Reservierungen - in verschiedenen Währungen durch.  Darüber hinaus müssen sie Abschlüsse in der von ihnen gewählten Währung (in der Regel lokal) erhalten.  Es wäre töricht und unpraktisch, alle möglichen Daten zu den Kursen aller Währungen zu speichern. Sie müssen also eine Referenzwährung auswählen, beispielsweise den Rubel.  Somit können Sie die Kurse aller Währungen nur im Rubel speichern.  Wenn ein Partner eine Zusammenfassung erhalten möchte, rechnen wir die Beträge dem zum Zeitpunkt des Verkaufs festgelegten Satz um. </p><br><h3 id="v-lob">  "In der Stirn" </h3><br><p>  Tatsächlich ist dies <code>Model.objects.all()</code> und die Bedingungsschleife: </p><br><div class="spoiler">  <b class="spoiler_title">Model.objects.all () mit Bedingungen</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">output</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(partner_id)</span></span></span><span class="hljs-function">:</span></span> today = dt.date.today() <span class="hljs-comment"><span class="hljs-comment"># query_get_one -    partner = query_get_one(Partner.objects.filter(id=partner_id)) #    -  query = MetaOrder.objects.filter(partner=partner) result = defaultdict(Decimal) for morder in query: #  ,     #     payment_pending = morder.get_payment_pending() payment_due = morder.get_payment_due() #        # (     ) payable = morder.get_payable_in_cur() #       if payment_pending &gt; today: result['payment_pending'] += payable # ,     if payment_pending &lt; today and payment_due &gt; today: result['payment_due'] += payable return result</span></span></code> </pre> </div></div><br><p>  Diese Abfrage gibt einen Generator zurück, der möglicherweise mehrere hundert Buchungen enthält.  Für jede dieser Buchungen wird eine Anfrage an die Datenbank gestellt, und daher wird der Zyklus sehr lange dauern. </p><br><p>  Sie können die Dinge etwas beschleunigen, indem Sie die Methode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>prefetch_related</code></a> hinzufügen: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># object -      GenericForeignKey. query = query.prefetch_related('object')</span></span></code> </pre> <br><p>  Dann gibt es etwas weniger Abfragen an die Datenbank ( <code>GenericForeignKey</code> auf den <code>GenericForeignKey</code> ), aber am Ende werden wir bei ihrer Nummer anhalten, da die Abfrage an die Datenbank immer noch bei jeder Iteration der Schleife durchgeführt wird. </p><br><p>  Die <code>output</code> kann (und sollte) zwischengespeichert werden, aber der erste Aufruf erfüllt immer noch die Größenordnung einer Minute, was völlig inakzeptabel ist. </p><br><p>  Hier sind die Ergebnisse dieses Ansatzes: </p><br><p><img src="https://habrastorage.org/webt/yz/ur/wq/yzurwquhxoeqczgncqi66je8570.png" alt="Timing_vorher"></p><br><p>  Die durchschnittliche Antwortzeit beträgt 4 Sekunden und es gibt Spitzen, die 21 Sekunden erreichen.  Ziemlich lange Zeit. </p><br><p>  Wir haben das Dashboard nicht für alle Partner eingeführt und hatten daher nicht viele Anfragen, aber es reicht immer noch aus, um zu verstehen, dass dieser Ansatz nicht effektiv ist. </p><br><p><img src="https://habrastorage.org/webt/f0/rz/yn/f0rzynfsqypr3z0mh1cnwoi6ee0.png" alt="count_before"><br>  <em>Die Zahlen unten rechts geben die Anzahl der Abfragen an: Minimum, Maximum, Durchschnitt, Gesamt.</em> </p><br><h3 id="s-umom">  Mit Bedacht </h3><br><p>  Der Stirnprototyp war gut für das Verständnis der Komplexität der Aufgabe, aber nicht optimal für den Einsatz.  Wir haben beschlossen, dass es viel schneller und weniger ressourcenintensiv ist, mehrere komplexe Abfragen in die Datenbank zu stellen als viele einfache. </p><br><h4 id="plan-zaprosa">  Plan anfordern </h4><br><p>  Breite Striche des Abfrageplans können folgendermaßen beschrieben werden: </p><br><ul><li>  Bestellungen gemäß den Anfangsbedingungen abholen, </li><li>  Felder für die Berechnung durch <code>annotate</code> vorbereiten, </li><li>  Feldwerte berechnen </li><li>  <code>aggregate</code> nach Menge und Menge </li></ul><br><h4 id="nachalnye-usloviya">  Ausgangsbedingungen </h4><br><p>  Partner, die die Website besuchen, können nur Informationen zu ihrem Vertrag sehen. </p><br><pre> <code class="python hljs">partner = query_get_one(Partner.objects.filter(id=partner_id))</code> </pre> <br><p>  Falls wir keine neuen Arten von Bestellungen / Buchungen anzeigen möchten, müssen wir nur die unterstützten filtern: </p><br><pre> <code class="python hljs">query = MetaOrder.objects.filter( partner=partner, content_type__in=[ Hotel.get_content_type(), Car.get_content_type(), Upsell.get_content_type(), ] )</code> </pre> <br><p>  Der Bestellstatus ist wichtig (mehr zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Q</code></a> ): </p><br><pre> <code class="python hljs">query = query.filter( Q(hotel__status__in=[<span class="hljs-string"><span class="hljs-string">'completed'</span></span>, <span class="hljs-string"><span class="hljs-string">'cancelled'</span></span>]) <span class="hljs-comment"><span class="hljs-comment">#     ,    # | Q(car__status__in=[...]) )</span></span></code> </pre> <br><p>  Wir verwenden häufig auch vorbereitete Anfragen, um beispielsweise alle Bestellungen auszuschließen, die nicht bezahlt werden können.  Es gibt eine Menge Geschäftslogik, die für uns im Rahmen dieses Artikels nicht sehr interessant ist, aber im Wesentlichen handelt es sich nur um zusätzliche Filter.  Eine Methode, die eine vorbereitete Abfrage zurückgibt, sieht möglicherweise folgendermaßen aus: </p><br><pre> <code class="python hljs">query = MetaOrder.exclude_non_payable_metaorders(query)</code> </pre> <br><p>  Wie Sie sehen können, ist dies eine Klassenmethode, die auch ein <code>QuerySet</code> . </p><br><p>  Wir bereiten auch einige Variablen für bedingte Konstruktionen und zum Speichern von Berechnungsergebnissen vor: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> dt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typing.decimal <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Decimal today = dt.date.today() result = defaultdict(Decimal)</code> </pre> <br><h4 id="podgotovka-poley-annotatehttpsdocsdjangoprojectcomen21refmodelsquerysetsannotate">  Feldvorbereitung ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>annotate</code></a> ) </h4><br><p>  Aufgrund der Tatsache, dass wir uns je nach Art der Bestellung auf die Felder beziehen müssen, verwenden wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Coalesce</code></a> .  Auf diese Weise können wir eine beliebige Anzahl neuer Auftragstypen in einem einzigen Feld zusammenfassen. </p><br><p>  Hier ist der erste Teil des <code>annotate</code> Blocks: </p><br><div class="spoiler">  <b class="spoiler_title">Zuerst kommentieren</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#     , #      from app.helpers.numbers import ZERO, ONE query_annoted = query.annotate( _payment_pending=Coalesce( 'hotel__payment_pending', 'car__payment_pending', 'upsell__payment_pending', ), _payment_due=Coalesce( 'hotel__payment_due', 'car__payment_due', 'upsell__payment_due', ), _refund=Coalesce( 'hotel__refund', Value(ZERO) ), _refund_currency_rate=Coalesce( 'hotel__refund_currency_rate', Value(ONE) ), _sell=Coalesce( 'hotel__sell', Value(ZERO) ), _sell_currency_rate=Coalesce( 'hotel__sell_currency_rate', Value(ONE) ), )</span></span></code> </pre> </div></div><br><p>  <code>Coalesce</code> arbeitet hier mit einem Knall, da Hotelbestellungen mehrere besondere Eigenschaften haben und in allen anderen Fällen (zusätzliche Dienstleistungen und Autos) diese Eigenschaften für uns nicht wichtig sind.  So erscheinen <code>Value(ZERO)</code> für Beträge und <code>Value(ONE)</code> für Wechselkurse.  <code>ZERO</code> und <code>ONE</code> sind <code>Decimal('0')</code> und <code>Decimal(1)</code> , nur in Form von Konstanten.  Ein Amateur-Ansatz, aber in unserem Projekt wird er so akzeptiert. </p><br><p>  Sie haben vielleicht eine Frage, warum nicht einige Felder in einer Meta-Reihenfolge eine Ebene höher legen?  Zum Beispiel <code>payment_pending</code> , was überall ist.  Zwar übertragen wir solche Felder im Laufe der Zeit in eine Meta-Reihenfolge, aber jetzt funktioniert der Code gut, sodass solche Aufgaben nicht unsere Priorität sind. </p><br><h4 id="esche-odna-podgotovka-i-raschety">  Eine weitere Vorbereitung und Berechnungen </h4><br><p>  Jetzt müssen wir einige Berechnungen mit den Beträgen durchführen, die wir im letzten <code>annotate</code> .  Beachten Sie, dass Sie hier nicht mehr an die Art der Bestellung gebunden sein müssen (mit Ausnahme einer Ausnahme). </p><br><div class="spoiler">  <b class="spoiler_title">Zweite Anmerkung</b> <div class="spoiler_text"><pre> <code class="python hljs">.annotate( <span class="hljs-comment"><span class="hljs-comment">#  _base     _sell_base=( F('_sell') * F('_sell_currency_rate') ), _refund_base=( F('_refund') * F('_refund_currency_rate') ), _payable_base=( F('_sell_base') - F('_refund_base') ), _reporting_currency_rate=Case( When( content_type=Hotel.get_content_type(), then=RawSQL( '(hotel.currency_data-&gt;&gt;%s)::numeric', (partner.reporting_currency,), ), ), output_field=DecimalField(), default=Decimal('1'), ), )</span></span></code> </pre> </div></div><br><p>  Der interessanteste Teil dieses Blocks ist das Feld <code>_reporting_currency_rate</code> oder der Wechselkurs zur Referenzwährung zum Zeitpunkt des Verkaufs.  Die Daten zu den Wechselkursen aller Währungen zur Referenzwährung für eine Hotelbestellung werden inrency_data gespeichert.  Dies ist nur JSON.  Warum behalten wir das?  <em>Dies ist historisch gesehen der Fall</em> . </p><br><p>  Und hier scheint es, warum nicht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>F</code></a> und den Wert der Vertragswährung ersetzen?  Das heißt, es wäre cool, wenn Sie dies tun könnten: </p><br><pre> <code class="python hljs">F(<span class="hljs-string"><span class="hljs-string">f'currency_data__</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{partner.reporting_currency}</span></span></span><span class="hljs-string">'</span></span>)</code> </pre> <br><p>  <code>f-strings</code> in <code>F</code> <code>f-strings</code> nicht unterstützt <code>F</code>  Obwohl die Tatsache, dass Django ORM bereits auf verschachtelte JSON-Felder zugreifen kann, sehr erfreulich ist - <code>F('currency_data__USD')</code> . </p><br><p>  Und der letzte <code>annotate</code> ist die <code>_payable_in_cur</code> Berechnung, die für alle Bestellungen summiert wird.  Dieser Wert muss in der Vertragswährung angegeben werden. </p><br><p><img src="https://habrastorage.org/webt/3g/hi/rd/3ghirdq4rnexrp2vnhwucju7rkw.png" alt="dash2"></p><br><pre> <code class="python hljs">.annotate( _payable_in_cur=( F(<span class="hljs-string"><span class="hljs-string">'_payable_base'</span></span>) / F(<span class="hljs-string"><span class="hljs-string">'_reporting_currency_rate'</span></span>) ) )</code> </pre> <br><p>  Die Besonderheit der <code>annotate</code> Methode besteht darin, dass sie viele <code>SELECT something AS something_else</code> Konstrukte generiert, die nicht direkt an der Anforderung beteiligt sind.  Dies kann durch Entladen der SQL-Abfrage - <code>query.__str__()</code> . </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">So</a> <code>base_query_annotated</code> der von Django ORM für <code>base_query_annotated</code> generierte SQL-Code <code>base_query_annotated</code> .  Sie müssen es ziemlich oft lesen, um zu verstehen, wo Sie Ihre Abfrage optimieren können. </p><br><h4 id="zaklyuchitelnye-podschety">  Endgültige Berechnungen </h4><br><p>  Es wird einen kleinen Wrapper für das <code>aggregate</code> , damit der Partner in Zukunft, wenn er eine andere Metrik benötigt, diese problemlos hinzufügen kann. </p><br><p><img src="https://habrastorage.org/webt/ky/qm/pi/kyqmpiht-jwpwuripuf6wlfiqv0.png" alt="dash3"></p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_get_data_from_query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(query: QuerySet)</span></span></span><span class="hljs-function"> -&gt; Decimal:</span></span> result = query.aggregate( _sum_payable=Sum(F(<span class="hljs-string"><span class="hljs-string">'_payable_in_cur'</span></span>)), ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result[<span class="hljs-string"><span class="hljs-string">'_sum_payable'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> ZERO</code> </pre> <br><p>  Und noch etwas - dies ist die letzte Filterung nach Geschäftsbedingungen. Zum Beispiel benötigen wir alle Bestellungen, die bald bezahlt werden müssen. </p><br><p><img src="https://habrastorage.org/webt/xz/rj/ss/xzrjssl1barwnpvtegjkg1tkvs0.png" alt="dash4"></p><br><pre> <code class="python hljs">before_payment_pending_query = _get_data_from_query( base_query_annotated.filter(_payment_pending__gt=today) )</code> </pre> <br><h4 id="otladka-i-proverka">  Debugging und Überprüfung </h4><br><p>  Eine sehr bequeme Möglichkeit, die Richtigkeit der erstellten Anforderung zu überprüfen, besteht darin, sie mit einer besser lesbaren Version der Berechnungen zu vergleichen. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> morder <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> query: payable = morder.get_payable_in_cur() payment_pending = morder.get_payment_pending() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> payment_pending &gt; today: result[<span class="hljs-string"><span class="hljs-string">'payment_pending'</span></span>] += payable</code> </pre> <br><p>  Kennen Sie die "Stirn" -Methode? </p><br><h3 id="finalnyy-kod">  Endgültiger Code </h3><br><p>  Als Ergebnis haben wir ungefähr Folgendes erhalten: </p><br><div class="spoiler">  <b class="spoiler_title">Endgültiger Code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_get_data_from_query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(query: QuerySet)</span></span></span><span class="hljs-function"> -&gt; tuple:</span></span> result = query.aggregate( _sum_payable=Sum(F(<span class="hljs-string"><span class="hljs-string">'_payable_in_cur'</span></span>)), ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result[<span class="hljs-string"><span class="hljs-string">'_sum_payable'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> ZERO <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">output</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(partner_id: int)</span></span></span><span class="hljs-function">:</span></span> today = dt.date.today() partner = query_get_one(Partner.objects.filter(id=partner_id)) query = MetaOrder.objects.filter(partner=partner, content_type__in=[ Hotel.get_content_type(), Car.get_content_type(), Upsell.get_content_type(), ]) result = defaultdict(Decimal) query_annoted = query.annotate( _payment_pending=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__payment_pending'</span></span>, <span class="hljs-string"><span class="hljs-string">'car__payment_pending'</span></span>, <span class="hljs-string"><span class="hljs-string">'upsell__payment_pending'</span></span>, ), _payment_due=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__payment_due'</span></span>, <span class="hljs-string"><span class="hljs-string">'car__payment_due'</span></span>, <span class="hljs-string"><span class="hljs-string">'upsell__payment_due'</span></span>, ), _refund=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__refund'</span></span>, Value(ZERO) ), _refund_currency_rate=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__refund_currency_rate'</span></span>, Value(Decimal(<span class="hljs-string"><span class="hljs-string">'1'</span></span>)) ), _sell=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__sell'</span></span>, Value(ZERO) ), _sell_currency_rate=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__sell_currency_rate'</span></span>, Value(Decimal(<span class="hljs-string"><span class="hljs-string">'1'</span></span>)) ), ).annotate( <span class="hljs-comment"><span class="hljs-comment"># Calculated fields _sell_base=( F('_sell') * F('_sell_currency_rate') ), _refund_base=( F('_refund') * F('_refund_currency_rate') ), _payable_base=( F('_sell_base') - F('_refund_base') ), _reporting_currency_rate=Case( # Only hotels have currency_data, therefore we need a # check and default value When( content_type=Hotel.get_content_type(), then=RawSQL( '(hotel.currency_data-&gt;&gt;%s)::numeric', (partner.reporting_currency,), ), ), output_field=DecimalField(), default=Decimal('1'), ), ) .annotate( _payable_in_cur=( F('_payable_base') / F('_reporting_currency_rate') ) ) before_payment_pending_query = _get_data_from_query( base_query_annotated.filter(_payment_pending__gt=today) ) after_payment_pending_before_payment_due_query = _get_data_from_query( base_query_annotated.filter( Q(_payment_pending__lte=today) &amp; Q(_payment_due__gt=today) ) )</span></span></code> </pre></div></div><br><p>  So funktioniert es jetzt: </p><br><p><img src="https://habrastorage.org/webt/xg/1i/rf/xg1irfnazuk-rqk14wdlxn32nhi.png" alt="Timing_nachher"></p><br><p><img src="https://habrastorage.org/webt/mt/k7/cq/mtk7cqefuzlx96roihjpgvpeaz8.png" alt="count_after"></p><br><h2 id="vyvody">  Schlussfolgerungen </h2><br><p>  Nach dem Umschreiben und Optimieren der Logik ist es uns gelungen, Affiliate-Metriken relativ schnell zu verarbeiten und die Anzahl der Abfragen an die Datenbank erheblich zu reduzieren.  Die Lösung hat sich als gut erwiesen, und wir werden diese Logik in anderen Teilen des Projekts wiederverwenden.  ORM ist unser Alles. </p><br><p>  Schreiben Sie Kommentare, stellen Sie Fragen - wir werden versuchen zu antworten!  Vielen Dank! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de447706/">https://habr.com/ru/post/de447706/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de447696/index.html">Warum Städte gegen Amazon Go sind, die ersten bargeldlosen Geschäfte</a></li>
<li><a href="../de447698/index.html">Red Hogwarts: Akademiker ohne Diplom</a></li>
<li><a href="../de447700/index.html">Emotionale Flexibilität ist der Schlüssel zum persönlichen Wachstum.</a></li>
<li><a href="../de447702/index.html">Der ideale mathematische Kreis existiert nicht</a></li>
<li><a href="../de447704/index.html">Elbrus besteigen - Aufklärung im Kampf. Technischer Teil 1. Register, Stapel und andere technische Details</a></li>
<li><a href="../de447708/index.html">Yandex überreichte jungen Wissenschaftlern und Wissenschaftlern die ersten Ilya Segalovich-Preise</a></li>
<li><a href="../de447712/index.html">Hallo, SaaS | Russische SaaS 2018 - Ergebnisse</a></li>
<li><a href="../de447714/index.html">Zur Anwendung der Theorie der ARMA-Prozesse in der Ingenieurpraxis</a></li>
<li><a href="../de447716/index.html">Einheit: Zeichnen Sie viele Gesundheitsbalken in einem Zug</a></li>
<li><a href="../de447718/index.html">Alles wird nach Plan verlaufen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>