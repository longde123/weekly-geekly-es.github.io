<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñïüèø üèÑ ü¶ó Kein einziger ORM üåõ üèì ü¶é</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kein einziger ORM 


 Hallo allerseits! Ich bin verantwortlich f√ºr die Partnerentwicklungsabteilung des Hotelreservierungsdienstes Ostrovok.ru . In di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kein einziger ORM</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ostrovok/blog/447706/"><h1 id="ne-ormom-edinym">  Kein einziger ORM </h1><br><p>  Hallo allerseits!  Ich bin verantwortlich f√ºr die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Partnerentwicklungsabteilung des</a> Hotelreservierungsdienstes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ostrovok.ru</a> .  In diesem Artikel m√∂chte ich dar√ºber sprechen, wie wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Django ORM</a> f√ºr ein Projekt verwendet haben. </p><br><p>  Tats√§chlich habe ich get√§uscht, der Name h√§tte " <del>  Nicht </del>  ORM single ". Wenn Sie sich fragen, warum ich das geschrieben habe und ob: </p><br><ul><li> Sie haben Django auf dem Stapel und m√∂chten das Maximum aus ORM <code>Model.objects.all()</code> , nicht nur <code>Model.objects.all()</code> , </li><li>  Sie m√∂chten einen Teil der Gesch√§ftslogik auf die Datenbankebene √ºbertragen. </li><li>  Oder m√∂chten Sie herausfinden, warum die h√§ufigste Entschuldigung f√ºr Entwickler bei B2B.Ostrovok.ru <em>"so historisch"</em> ist? </li></ul><br><p>  ... willkommen bei cat. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/66b/308/b1c/66b308b1cd5afefead46ef7bffdbbddf.jpg" alt="cdpv"></p><a name="habracut"></a><br><p>  2014 haben wir B2B.Ostrovok.ru gestartet - einen Online-Buchungsservice f√ºr Hotels, Transfers, Autos und andere Reisedienstleistungen f√ºr Fachleute auf dem Tourismusmarkt (Reiseb√ºros, Betreiber und Firmenkunden). </p><br><p>  Im B2B-Bereich haben wir ein abstraktes Bestellmodell basierend auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>GenericForeignKey</code></a> - Meta Order - <code>MetaOrder</code> entworfen und recht erfolgreich verwendet. </p><br><p>  Eine Meta-Bestellung ist eine abstrakte Entit√§t, die unabh√§ngig von der Art der Bestellung verwendet werden kann: ein Hotel ( <code>Hotel</code> ), ein zus√§tzlicher Service ( <code>Upsell</code> ) oder ein Auto ( <code>Car</code> ).  In Zukunft werden m√∂glicherweise andere Typen angezeigt. </p><br><p>  Das war nicht immer so.  Als der B2B-Service eingef√ºhrt wurde, konnten nur Hotels √ºber ihn gebucht werden, und die gesamte Gesch√§ftslogik war auf sie ausgerichtet.  Es wurden viele Felder erstellt, um beispielsweise die Wechselkurse des Verkaufsbetrags und des Reservierungsr√ºckerstattungsbetrags anzuzeigen.  Im Laufe der Zeit haben wir erkannt, wie diese Daten angesichts der Meta-Bestellungen am besten gespeichert und wiederverwendet werden k√∂nnen.  Der gesamte Code konnte jedoch nicht umgeschrieben werden, und ein Teil dieses Erbes floss in die neue Architektur ein.  Tats√§chlich f√ºhrte dies zu Schwierigkeiten bei den Berechnungen, bei denen verschiedene Arten von Auftr√§gen verwendet werden.  Was zu tun ist - also <em>historisch</em> ... </p><br><p>  Mein Ziel ist es, die Kraft von Django ORM in unserem Beispiel zu zeigen. </p><br><h2 id="predystoriya">  Hintergrund </h2><br><p>  Um ihre Ausgaben zu planen, fehlten unseren B2B-Kunden wirklich Informationen dar√ºber, wie viel sie jetzt / morgen / sp√§ter bezahlen m√ºssen, ob sie Schulden f√ºr Bestellungen haben und wie gro√ü diese sind und wie viel mehr sie innerhalb ihrer Grenzen ausgeben k√∂nnen.  Wir haben uns entschlossen, diese Informationen in Form eines Dashboards anzuzeigen - einer so einfachen Steckdose mit einem √ºbersichtlichen Diagramm. </p><br><p><img src="https://habrastorage.org/webt/2a/rj/yo/2arjyoaa9_xfe8ddcaz5qn4w5mu.gif" alt="dash1"><br>  <em>(Alle Werte sind Testwerte und gelten nicht f√ºr einen bestimmten Partner.)</em> </p><br><p>  Auf den ersten Blick ist alles ganz einfach - wir filtern alle Bestellungen des Partners, fassen zusammen und zeigen. </p><br><h2 id="varianty-resheniya">  L√∂sungsoptionen </h2><br><p>  Eine kleine Erkl√§rung, wie wir Berechnungen durchf√ºhren.  Wir sind ein internationales Unternehmen, unsere Partner aus verschiedenen L√§ndern f√ºhren Operationen - Kauf und Wiederverkauf von Reservierungen - in verschiedenen W√§hrungen durch.  Dar√ºber hinaus m√ºssen sie Abschl√ºsse in der von ihnen gew√§hlten W√§hrung (in der Regel lokal) erhalten.  Es w√§re t√∂richt und unpraktisch, alle m√∂glichen Daten zu den Kursen aller W√§hrungen zu speichern. Sie m√ºssen also eine Referenzw√§hrung ausw√§hlen, beispielsweise den Rubel.  Somit k√∂nnen Sie die Kurse aller W√§hrungen nur im Rubel speichern.  Wenn ein Partner eine Zusammenfassung erhalten m√∂chte, rechnen wir die Betr√§ge dem zum Zeitpunkt des Verkaufs festgelegten Satz um. </p><br><h3 id="v-lob">  "In der Stirn" </h3><br><p>  Tats√§chlich ist dies <code>Model.objects.all()</code> und die Bedingungsschleife: </p><br><div class="spoiler">  <b class="spoiler_title">Model.objects.all () mit Bedingungen</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">output</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(partner_id)</span></span></span><span class="hljs-function">:</span></span> today = dt.date.today() <span class="hljs-comment"><span class="hljs-comment"># query_get_one -    partner = query_get_one(Partner.objects.filter(id=partner_id)) #    -  query = MetaOrder.objects.filter(partner=partner) result = defaultdict(Decimal) for morder in query: #  ,     #     payment_pending = morder.get_payment_pending() payment_due = morder.get_payment_due() #        # (     ) payable = morder.get_payable_in_cur() #       if payment_pending &gt; today: result['payment_pending'] += payable # ,     if payment_pending &lt; today and payment_due &gt; today: result['payment_due'] += payable return result</span></span></code> </pre> </div></div><br><p>  Diese Abfrage gibt einen Generator zur√ºck, der m√∂glicherweise mehrere hundert Buchungen enth√§lt.  F√ºr jede dieser Buchungen wird eine Anfrage an die Datenbank gestellt, und daher wird der Zyklus sehr lange dauern. </p><br><p>  Sie k√∂nnen die Dinge etwas beschleunigen, indem Sie die Methode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>prefetch_related</code></a> hinzuf√ºgen: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># object -      GenericForeignKey. query = query.prefetch_related('object')</span></span></code> </pre> <br><p>  Dann gibt es etwas weniger Abfragen an die Datenbank ( <code>GenericForeignKey</code> auf den <code>GenericForeignKey</code> ), aber am Ende werden wir bei ihrer Nummer anhalten, da die Abfrage an die Datenbank immer noch bei jeder Iteration der Schleife durchgef√ºhrt wird. </p><br><p>  Die <code>output</code> kann (und sollte) zwischengespeichert werden, aber der erste Aufruf erf√ºllt immer noch die Gr√∂√üenordnung einer Minute, was v√∂llig inakzeptabel ist. </p><br><p>  Hier sind die Ergebnisse dieses Ansatzes: </p><br><p><img src="https://habrastorage.org/webt/yz/ur/wq/yzurwquhxoeqczgncqi66je8570.png" alt="Timing_vorher"></p><br><p>  Die durchschnittliche Antwortzeit betr√§gt 4 Sekunden und es gibt Spitzen, die 21 Sekunden erreichen.  Ziemlich lange Zeit. </p><br><p>  Wir haben das Dashboard nicht f√ºr alle Partner eingef√ºhrt und hatten daher nicht viele Anfragen, aber es reicht immer noch aus, um zu verstehen, dass dieser Ansatz nicht effektiv ist. </p><br><p><img src="https://habrastorage.org/webt/f0/rz/yn/f0rzynfsqypr3z0mh1cnwoi6ee0.png" alt="count_before"><br>  <em>Die Zahlen unten rechts geben die Anzahl der Abfragen an: Minimum, Maximum, Durchschnitt, Gesamt.</em> </p><br><h3 id="s-umom">  Mit Bedacht </h3><br><p>  Der Stirnprototyp war gut f√ºr das Verst√§ndnis der Komplexit√§t der Aufgabe, aber nicht optimal f√ºr den Einsatz.  Wir haben beschlossen, dass es viel schneller und weniger ressourcenintensiv ist, mehrere komplexe Abfragen in die Datenbank zu stellen als viele einfache. </p><br><h4 id="plan-zaprosa">  Plan anfordern </h4><br><p>  Breite Striche des Abfrageplans k√∂nnen folgenderma√üen beschrieben werden: </p><br><ul><li>  Bestellungen gem√§√ü den Anfangsbedingungen abholen, </li><li>  Felder f√ºr die Berechnung durch <code>annotate</code> vorbereiten, </li><li>  Feldwerte berechnen </li><li>  <code>aggregate</code> nach Menge und Menge </li></ul><br><h4 id="nachalnye-usloviya">  Ausgangsbedingungen </h4><br><p>  Partner, die die Website besuchen, k√∂nnen nur Informationen zu ihrem Vertrag sehen. </p><br><pre> <code class="python hljs">partner = query_get_one(Partner.objects.filter(id=partner_id))</code> </pre> <br><p>  Falls wir keine neuen Arten von Bestellungen / Buchungen anzeigen m√∂chten, m√ºssen wir nur die unterst√ºtzten filtern: </p><br><pre> <code class="python hljs">query = MetaOrder.objects.filter( partner=partner, content_type__in=[ Hotel.get_content_type(), Car.get_content_type(), Upsell.get_content_type(), ] )</code> </pre> <br><p>  Der Bestellstatus ist wichtig (mehr zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Q</code></a> ): </p><br><pre> <code class="python hljs">query = query.filter( Q(hotel__status__in=[<span class="hljs-string"><span class="hljs-string">'completed'</span></span>, <span class="hljs-string"><span class="hljs-string">'cancelled'</span></span>]) <span class="hljs-comment"><span class="hljs-comment">#     ,    # | Q(car__status__in=[...]) )</span></span></code> </pre> <br><p>  Wir verwenden h√§ufig auch vorbereitete Anfragen, um beispielsweise alle Bestellungen auszuschlie√üen, die nicht bezahlt werden k√∂nnen.  Es gibt eine Menge Gesch√§ftslogik, die f√ºr uns im Rahmen dieses Artikels nicht sehr interessant ist, aber im Wesentlichen handelt es sich nur um zus√§tzliche Filter.  Eine Methode, die eine vorbereitete Abfrage zur√ºckgibt, sieht m√∂glicherweise folgenderma√üen aus: </p><br><pre> <code class="python hljs">query = MetaOrder.exclude_non_payable_metaorders(query)</code> </pre> <br><p>  Wie Sie sehen k√∂nnen, ist dies eine Klassenmethode, die auch ein <code>QuerySet</code> . </p><br><p>  Wir bereiten auch einige Variablen f√ºr bedingte Konstruktionen und zum Speichern von Berechnungsergebnissen vor: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> dt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typing.decimal <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Decimal today = dt.date.today() result = defaultdict(Decimal)</code> </pre> <br><h4 id="podgotovka-poley-annotatehttpsdocsdjangoprojectcomen21refmodelsquerysetsannotate">  Feldvorbereitung ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>annotate</code></a> ) </h4><br><p>  Aufgrund der Tatsache, dass wir uns je nach Art der Bestellung auf die Felder beziehen m√ºssen, verwenden wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Coalesce</code></a> .  Auf diese Weise k√∂nnen wir eine beliebige Anzahl neuer Auftragstypen in einem einzigen Feld zusammenfassen. </p><br><p>  Hier ist der erste Teil des <code>annotate</code> Blocks: </p><br><div class="spoiler">  <b class="spoiler_title">Zuerst kommentieren</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#     , #      from app.helpers.numbers import ZERO, ONE query_annoted = query.annotate( _payment_pending=Coalesce( 'hotel__payment_pending', 'car__payment_pending', 'upsell__payment_pending', ), _payment_due=Coalesce( 'hotel__payment_due', 'car__payment_due', 'upsell__payment_due', ), _refund=Coalesce( 'hotel__refund', Value(ZERO) ), _refund_currency_rate=Coalesce( 'hotel__refund_currency_rate', Value(ONE) ), _sell=Coalesce( 'hotel__sell', Value(ZERO) ), _sell_currency_rate=Coalesce( 'hotel__sell_currency_rate', Value(ONE) ), )</span></span></code> </pre> </div></div><br><p>  <code>Coalesce</code> arbeitet hier mit einem Knall, da Hotelbestellungen mehrere besondere Eigenschaften haben und in allen anderen F√§llen (zus√§tzliche Dienstleistungen und Autos) diese Eigenschaften f√ºr uns nicht wichtig sind.  So erscheinen <code>Value(ZERO)</code> f√ºr Betr√§ge und <code>Value(ONE)</code> f√ºr Wechselkurse.  <code>ZERO</code> und <code>ONE</code> sind <code>Decimal('0')</code> und <code>Decimal(1)</code> , nur in Form von Konstanten.  Ein Amateur-Ansatz, aber in unserem Projekt wird er so akzeptiert. </p><br><p>  Sie haben vielleicht eine Frage, warum nicht einige Felder in einer Meta-Reihenfolge eine Ebene h√∂her legen?  Zum Beispiel <code>payment_pending</code> , was √ºberall ist.  Zwar √ºbertragen wir solche Felder im Laufe der Zeit in eine Meta-Reihenfolge, aber jetzt funktioniert der Code gut, sodass solche Aufgaben nicht unsere Priorit√§t sind. </p><br><h4 id="esche-odna-podgotovka-i-raschety">  Eine weitere Vorbereitung und Berechnungen </h4><br><p>  Jetzt m√ºssen wir einige Berechnungen mit den Betr√§gen durchf√ºhren, die wir im letzten <code>annotate</code> .  Beachten Sie, dass Sie hier nicht mehr an die Art der Bestellung gebunden sein m√ºssen (mit Ausnahme einer Ausnahme). </p><br><div class="spoiler">  <b class="spoiler_title">Zweite Anmerkung</b> <div class="spoiler_text"><pre> <code class="python hljs">.annotate( <span class="hljs-comment"><span class="hljs-comment">#  _base     _sell_base=( F('_sell') * F('_sell_currency_rate') ), _refund_base=( F('_refund') * F('_refund_currency_rate') ), _payable_base=( F('_sell_base') - F('_refund_base') ), _reporting_currency_rate=Case( When( content_type=Hotel.get_content_type(), then=RawSQL( '(hotel.currency_data-&gt;&gt;%s)::numeric', (partner.reporting_currency,), ), ), output_field=DecimalField(), default=Decimal('1'), ), )</span></span></code> </pre> </div></div><br><p>  Der interessanteste Teil dieses Blocks ist das Feld <code>_reporting_currency_rate</code> oder der Wechselkurs zur Referenzw√§hrung zum Zeitpunkt des Verkaufs.  Die Daten zu den Wechselkursen aller W√§hrungen zur Referenzw√§hrung f√ºr eine Hotelbestellung werden inrency_data gespeichert.  Dies ist nur JSON.  Warum behalten wir das?  <em>Dies ist historisch gesehen der Fall</em> . </p><br><p>  Und hier scheint es, warum nicht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>F</code></a> und den Wert der Vertragsw√§hrung ersetzen?  Das hei√üt, es w√§re cool, wenn Sie dies tun k√∂nnten: </p><br><pre> <code class="python hljs">F(<span class="hljs-string"><span class="hljs-string">f'currency_data__</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{partner.reporting_currency}</span></span></span><span class="hljs-string">'</span></span>)</code> </pre> <br><p>  <code>f-strings</code> in <code>F</code> <code>f-strings</code> nicht unterst√ºtzt <code>F</code>  Obwohl die Tatsache, dass Django ORM bereits auf verschachtelte JSON-Felder zugreifen kann, sehr erfreulich ist - <code>F('currency_data__USD')</code> . </p><br><p>  Und der letzte <code>annotate</code> ist die <code>_payable_in_cur</code> Berechnung, die f√ºr alle Bestellungen summiert wird.  Dieser Wert muss in der Vertragsw√§hrung angegeben werden. </p><br><p><img src="https://habrastorage.org/webt/3g/hi/rd/3ghirdq4rnexrp2vnhwucju7rkw.png" alt="dash2"></p><br><pre> <code class="python hljs">.annotate( _payable_in_cur=( F(<span class="hljs-string"><span class="hljs-string">'_payable_base'</span></span>) / F(<span class="hljs-string"><span class="hljs-string">'_reporting_currency_rate'</span></span>) ) )</code> </pre> <br><p>  Die Besonderheit der <code>annotate</code> Methode besteht darin, dass sie viele <code>SELECT something AS something_else</code> Konstrukte generiert, die nicht direkt an der Anforderung beteiligt sind.  Dies kann durch Entladen der SQL-Abfrage - <code>query.__str__()</code> . </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">So</a> <code>base_query_annotated</code> der von Django ORM f√ºr <code>base_query_annotated</code> generierte SQL-Code <code>base_query_annotated</code> .  Sie m√ºssen es ziemlich oft lesen, um zu verstehen, wo Sie Ihre Abfrage optimieren k√∂nnen. </p><br><h4 id="zaklyuchitelnye-podschety">  Endg√ºltige Berechnungen </h4><br><p>  Es wird einen kleinen Wrapper f√ºr das <code>aggregate</code> , damit der Partner in Zukunft, wenn er eine andere Metrik ben√∂tigt, diese problemlos hinzuf√ºgen kann. </p><br><p><img src="https://habrastorage.org/webt/ky/qm/pi/kyqmpiht-jwpwuripuf6wlfiqv0.png" alt="dash3"></p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_get_data_from_query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(query: QuerySet)</span></span></span><span class="hljs-function"> -&gt; Decimal:</span></span> result = query.aggregate( _sum_payable=Sum(F(<span class="hljs-string"><span class="hljs-string">'_payable_in_cur'</span></span>)), ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result[<span class="hljs-string"><span class="hljs-string">'_sum_payable'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> ZERO</code> </pre> <br><p>  Und noch etwas - dies ist die letzte Filterung nach Gesch√§ftsbedingungen. Zum Beispiel ben√∂tigen wir alle Bestellungen, die bald bezahlt werden m√ºssen. </p><br><p><img src="https://habrastorage.org/webt/xz/rj/ss/xzrjssl1barwnpvtegjkg1tkvs0.png" alt="dash4"></p><br><pre> <code class="python hljs">before_payment_pending_query = _get_data_from_query( base_query_annotated.filter(_payment_pending__gt=today) )</code> </pre> <br><h4 id="otladka-i-proverka">  Debugging und √úberpr√ºfung </h4><br><p>  Eine sehr bequeme M√∂glichkeit, die Richtigkeit der erstellten Anforderung zu √ºberpr√ºfen, besteht darin, sie mit einer besser lesbaren Version der Berechnungen zu vergleichen. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> morder <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> query: payable = morder.get_payable_in_cur() payment_pending = morder.get_payment_pending() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> payment_pending &gt; today: result[<span class="hljs-string"><span class="hljs-string">'payment_pending'</span></span>] += payable</code> </pre> <br><p>  Kennen Sie die "Stirn" -Methode? </p><br><h3 id="finalnyy-kod">  Endg√ºltiger Code </h3><br><p>  Als Ergebnis haben wir ungef√§hr Folgendes erhalten: </p><br><div class="spoiler">  <b class="spoiler_title">Endg√ºltiger Code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_get_data_from_query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(query: QuerySet)</span></span></span><span class="hljs-function"> -&gt; tuple:</span></span> result = query.aggregate( _sum_payable=Sum(F(<span class="hljs-string"><span class="hljs-string">'_payable_in_cur'</span></span>)), ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result[<span class="hljs-string"><span class="hljs-string">'_sum_payable'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> ZERO <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">output</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(partner_id: int)</span></span></span><span class="hljs-function">:</span></span> today = dt.date.today() partner = query_get_one(Partner.objects.filter(id=partner_id)) query = MetaOrder.objects.filter(partner=partner, content_type__in=[ Hotel.get_content_type(), Car.get_content_type(), Upsell.get_content_type(), ]) result = defaultdict(Decimal) query_annoted = query.annotate( _payment_pending=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__payment_pending'</span></span>, <span class="hljs-string"><span class="hljs-string">'car__payment_pending'</span></span>, <span class="hljs-string"><span class="hljs-string">'upsell__payment_pending'</span></span>, ), _payment_due=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__payment_due'</span></span>, <span class="hljs-string"><span class="hljs-string">'car__payment_due'</span></span>, <span class="hljs-string"><span class="hljs-string">'upsell__payment_due'</span></span>, ), _refund=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__refund'</span></span>, Value(ZERO) ), _refund_currency_rate=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__refund_currency_rate'</span></span>, Value(Decimal(<span class="hljs-string"><span class="hljs-string">'1'</span></span>)) ), _sell=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__sell'</span></span>, Value(ZERO) ), _sell_currency_rate=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__sell_currency_rate'</span></span>, Value(Decimal(<span class="hljs-string"><span class="hljs-string">'1'</span></span>)) ), ).annotate( <span class="hljs-comment"><span class="hljs-comment"># Calculated fields _sell_base=( F('_sell') * F('_sell_currency_rate') ), _refund_base=( F('_refund') * F('_refund_currency_rate') ), _payable_base=( F('_sell_base') - F('_refund_base') ), _reporting_currency_rate=Case( # Only hotels have currency_data, therefore we need a # check and default value When( content_type=Hotel.get_content_type(), then=RawSQL( '(hotel.currency_data-&gt;&gt;%s)::numeric', (partner.reporting_currency,), ), ), output_field=DecimalField(), default=Decimal('1'), ), ) .annotate( _payable_in_cur=( F('_payable_base') / F('_reporting_currency_rate') ) ) before_payment_pending_query = _get_data_from_query( base_query_annotated.filter(_payment_pending__gt=today) ) after_payment_pending_before_payment_due_query = _get_data_from_query( base_query_annotated.filter( Q(_payment_pending__lte=today) &amp; Q(_payment_due__gt=today) ) )</span></span></code> </pre></div></div><br><p>  So funktioniert es jetzt: </p><br><p><img src="https://habrastorage.org/webt/xg/1i/rf/xg1irfnazuk-rqk14wdlxn32nhi.png" alt="Timing_nachher"></p><br><p><img src="https://habrastorage.org/webt/mt/k7/cq/mtk7cqefuzlx96roihjpgvpeaz8.png" alt="count_after"></p><br><h2 id="vyvody">  Schlussfolgerungen </h2><br><p>  Nach dem Umschreiben und Optimieren der Logik ist es uns gelungen, Affiliate-Metriken relativ schnell zu verarbeiten und die Anzahl der Abfragen an die Datenbank erheblich zu reduzieren.  Die L√∂sung hat sich als gut erwiesen, und wir werden diese Logik in anderen Teilen des Projekts wiederverwenden.  ORM ist unser Alles. </p><br><p>  Schreiben Sie Kommentare, stellen Sie Fragen - wir werden versuchen zu antworten!  Vielen Dank! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de447706/">https://habr.com/ru/post/de447706/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de447696/index.html">Warum St√§dte gegen Amazon Go sind, die ersten bargeldlosen Gesch√§fte</a></li>
<li><a href="../de447698/index.html">Red Hogwarts: Akademiker ohne Diplom</a></li>
<li><a href="../de447700/index.html">Emotionale Flexibilit√§t ist der Schl√ºssel zum pers√∂nlichen Wachstum.</a></li>
<li><a href="../de447702/index.html">Der ideale mathematische Kreis existiert nicht</a></li>
<li><a href="../de447704/index.html">Elbrus besteigen - Aufkl√§rung im Kampf. Technischer Teil 1. Register, Stapel und andere technische Details</a></li>
<li><a href="../de447708/index.html">Yandex √ºberreichte jungen Wissenschaftlern und Wissenschaftlern die ersten Ilya Segalovich-Preise</a></li>
<li><a href="../de447712/index.html">Hallo, SaaS | Russische SaaS 2018 - Ergebnisse</a></li>
<li><a href="../de447714/index.html">Zur Anwendung der Theorie der ARMA-Prozesse in der Ingenieurpraxis</a></li>
<li><a href="../de447716/index.html">Einheit: Zeichnen Sie viele Gesundheitsbalken in einem Zug</a></li>
<li><a href="../de447718/index.html">Alles wird nach Plan verlaufen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>