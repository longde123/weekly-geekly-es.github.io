<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👩‍👦 🌭 👨‍🔧 AERODISK vAIR arsitektur atau fitur bangunan cluster nasional 🐊 👋🏼 🌅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Khabrovchans! Kami terus memperkenalkan Anda dengan sistem hyperconverged Rusia AERODISK vAIR. Artikel ini akan fokus pada arsitektur sistem ini...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>AERODISK vAIR arsitektur atau fitur bangunan cluster nasional</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/aerodisk/blog/475254/"><p><img src="https://habrastorage.org/webt/4c/_3/or/4c_3or6x9ro2_f_g8-waac1oen0.jpeg"></p><br><p>  Halo, Khabrovchans!  Kami terus memperkenalkan Anda dengan sistem hyperconverged Rusia AERODISK vAIR.  Artikel ini akan fokus pada arsitektur sistem ini.  Pada artikel terakhir, kami mem-parsing sistem file ARDFS kami, dan dalam artikel ini kami akan membahas semua komponen perangkat lunak utama yang membentuk vAIR dan tugas-tugas mereka. </p><a name="habracut"></a><br><p>  Kami mulai deskripsi arsitektur dari bawah ke atas - dari penyimpanan ke manajemen. </p><br><h2 id="faylovaya-sistema-ardfs--raft-cluster-driver">  Sistem File Driver ARDFS + Raft Cluster </h2><br><p>  Dasar dari vAIR adalah sistem file terdistribusi ARDFS, yang menggabungkan disk lokal dari semua node cluster menjadi satu kumpulan logis, berdasarkan disk virtual dengan satu atau satu skema toleransi kesalahan (faktor Replikasi atau Penghapusan pengkodean) dibentuk dari blok virtual 4MB.  Penjelasan lebih rinci tentang pekerjaan ARDFS diberikan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><br></a> <br>  Raft Cluster Driver adalah layanan ARDFS internal yang memecahkan masalah penyimpanan metadata sistem file yang terdistribusi dan andal. </p><br><p>  Metadata ARDFS secara konvensional dibagi menjadi dua kelas. </p><br><ul><li>  pemberitahuan - informasi tentang operasi dengan objek penyimpanan dan informasi tentang objek itu sendiri; </li><li>  informasi layanan - mengatur kunci dan informasi konfigurasi untuk node penyimpanan. </li></ul><br><p>  Layanan RCD digunakan untuk mendistribusikan data ini.  Secara otomatis menetapkan sebuah node dengan peran seorang pemimpin yang tugasnya adalah untuk mendapatkan dan menyebarkan metadata di seluruh node.  Seorang pemimpin adalah satu-satunya sumber sejati informasi ini.  Selain itu, pemimpin mengatur detak jantung, mis.  memeriksa ketersediaan semua node penyimpanan (ini tidak ada hubungannya dengan ketersediaan mesin virtual, RCD hanyalah layanan untuk penyimpanan). </p><br><p>  Jika karena alasan apa pun pemimpin telah menjadi tidak tersedia untuk salah satu node biasa selama lebih dari satu detik, simpul biasa ini menyelenggarakan pemilihan ulang pemimpin, meminta ketersediaan pemimpin dari node biasa lainnya.  Jika ada kuorum, pemimpin dipilih kembali.  Setelah mantan pemimpin "bangun", ia secara otomatis menjadi simpul biasa, karena  pemimpin baru mengirimnya tim yang tepat. </p><br><p> Logika RCD itu sendiri bukanlah hal baru.  Banyak solusi pihak ketiga dan komersial dan gratis juga dipandu oleh logika ini, tetapi solusi ini tidak cocok untuk kami (seperti FS open-source yang ada), karena mereka cukup berat, dan sangat sulit untuk mengoptimalkannya untuk tugas-tugas sederhana kami, jadi kami hanya menulis sendiri Layanan RCD. <br>  Mungkin terlihat bahwa pemimpin adalah "leher sempit" yang dapat memperlambat kerja dalam kelompok besar dengan ratusan node, tetapi ini tidak demikian.  Proses yang dijelaskan terjadi hampir secara instan dan “berbobot” sangat sedikit sejak kami menulisnya sendiri dan hanya menyertakan fungsi yang paling diperlukan.  Selain itu, ini terjadi sepenuhnya secara otomatis, hanya menyisakan pesan dalam log. </p><br><h2 id="masterio--sluzhba-upravleniya-mnogopotochnym-vvodom-vyvodom">  MasterIO - Layanan Manajemen I / O Multithreaded </h2><br><p>  Setelah kumpulan ARDFS dengan disk virtual diatur, itu dapat digunakan untuk I / O.  Pada titik ini, muncul pertanyaan khusus untuk sistem hyperconverged, yaitu: berapa banyak sumber daya sistem (CPU / RAM) yang dapat kita sumbangkan untuk IO? </p><br><p>  Dalam sistem penyimpanan klasik, pertanyaan ini tidak terlalu akut, karena tugas penyimpanan hanya untuk menyimpan data (dan sebagian besar sumber daya penyimpanan sistem dapat dengan aman diberikan di bawah IO), dan tugas hyperconvergence, selain penyimpanan, juga mencakup pelaksanaan mesin virtual.  Oleh karena itu, GCS membutuhkan penggunaan sumber daya CPU dan RAM terutama untuk mesin virtual.  Nah, bagaimana dengan I / O? </p><br><p>  Untuk mengatasi masalah ini, vAIR menggunakan layanan manajemen I / O: MasterIO.  Tugas layanan ini sederhana - <del>  “Ambil semuanya dan bagikan” </del>  dijamin untuk mengambil jumlah sumber daya sistem n untuk input dan output dan, mulai dari mereka, mulai jumlah n input / output stream. </p><br><p>  Awalnya, kami ingin menyediakan mekanisme "sangat cerdas" untuk mengalokasikan sumber daya untuk IO.  Misalnya, jika tidak ada beban pada penyimpanan, maka sumber daya sistem dapat digunakan untuk mesin virtual, dan jika beban muncul, sumber daya ini “dengan lembut” dihilangkan dari mesin virtual dalam batas yang telah ditentukan sebelumnya.  Namun upaya ini berakhir dengan kegagalan parsial.  Pengujian menunjukkan bahwa jika beban ditingkatkan secara bertahap, maka semuanya OK, sumber daya (ditandai untuk kemungkinan penghapusan) secara bertahap ditarik dari VM demi I / O.  Tetapi ledakan tajam dari penyimpanan menyebabkan tidak terlalu lunaknya penarikan sumber daya dari mesin virtual, dan sebagai hasilnya, antrian menumpuk pada prosesor dan, sebagai akibatnya, <del>  dan serigala lapar dan domba mati </del>  dan virtualka hang, dan tidak ada IOPS. </p><br><p>  Mungkin di masa depan kami akan kembali ke masalah ini, tetapi untuk saat ini kami telah menerapkan penerbitan sumber daya untuk IO dengan cara kakek tua yang baik. </p><br><p>  Berdasarkan data ukuran, administrator melakukan pra-alokasi nomor inti CPU dan RAM untuk layanan MasterIO.  Sumber daya ini dialokasikan secara monopoli, yaitu  mereka tidak dapat digunakan dengan cara apa pun untuk kebutuhan VM sampai admin mengizinkannya.  Sumber daya dialokasikan secara merata, mis.  jumlah sumber daya sistem yang sama diambil dari setiap node cluster.  Pertama-tama, sumber daya prosesor menarik bagi MasterIO (RAM kurang penting), terutama jika kita menggunakan Erasure coding. </p><br><p>  Jika kesalahan terjadi dengan ukuran, dan kami memberikan terlalu banyak sumber daya untuk MasterIO, maka situasinya mudah diselesaikan dengan menghapus sumber daya ini kembali ke kumpulan sumber daya VM.  Jika sumber daya diam, maka mereka akan segera kembali ke sumber daya VM, tetapi jika sumber daya ini dibuang, Anda harus menunggu beberapa saat agar MasterIO melepaskannya dengan lembut. </p><br><p>  Situasi sebaliknya lebih rumit.  Jika kita perlu meningkatkan jumlah core untuk MasterIO, dan mereka sibuk dengan virtual, maka kita harus "bernegosiasi" dengan virtual, yaitu, memilihnya dengan pegangan, karena dalam mode otomatis dalam situasi semburan muatan yang tajam, operasi ini penuh dengan pembekuan VM dan perilaku berubah-ubah lainnya. </p><br><p>  Oleh karena itu, banyak perhatian perlu diberikan untuk mengukur kinerja sistem hyperconverged IO (tidak hanya milik kita).  Beberapa saat kemudian di salah satu artikel kami berjanji untuk mempertimbangkan masalah ini secara lebih rinci. </p><br><h2 id="gipervizor">  Hypervisor </h2><br><p>  Hypervisor Aist bertanggung jawab untuk menjalankan mesin virtual di vAIR.  Hypervisor ini didasarkan pada hypervisor KVM yang telah teruji waktu.  Pada prinsipnya, cukup banyak yang telah ditulis tentang karya KVM, jadi tidak ada kebutuhan khusus untuk melukisnya, cukup tunjukkan bahwa semua fungsi standar KVM disimpan di Bangau dan berfungsi dengan baik. </p><br><p>  Oleh karena itu, di sini kami akan menjelaskan perbedaan utama dari KVM standar, yang kami implementasikan di Bangau.  Bangau adalah bagian dari sistem (pra-instal hypervisor) dan dikendalikan dari konsol umum vAIR melalui Web-GUI (versi Rusia dan Inggris) dan SSH (jelas, hanya bahasa Inggris). </p><br><p><img src="https://habrastorage.org/webt/vi/ju/9e/viju9ee4sxkeq-ezvoobttyjvck.png"></p><br><p>  Selain itu, konfigurasi hypervisor disimpan dalam database ConfigDB yang didistribusikan (kira-kira nanti), yang juga merupakan satu titik kontrol.  Yaitu, Anda dapat terhubung ke sembarang simpul di kluster dan mengelola semua tanpa perlu server manajemen yang terpisah. </p><br><p>  Tambahan penting untuk fungsionalitas KVM standar adalah modul HA yang kami kembangkan.  Ini adalah implementasi paling sederhana dari sekelompok mesin virtual ketersediaan tinggi, yang memungkinkan Anda untuk secara otomatis me-restart mesin virtual pada node cluster lain jika terjadi kegagalan simpul. </p><br><p>  Fitur lain yang bermanfaat adalah penyebaran massal mesin virtual (relevan untuk lingkungan VDI), yang akan mengotomatiskan penyebaran mesin virtual dengan distribusi otomatis antar node tergantung pada bebannya. </p><br><p>  Distribusi VM antar node adalah dasar untuk penyeimbangan beban otomatis (ala DRS).  Fungsi ini belum tersedia dalam rilis saat ini, tetapi kami sedang aktif mengatasinya dan pasti akan muncul di salah satu pembaruan berikutnya. </p><br><p>  VMware ESXi hypervisor secara opsional didukung, saat ini diimplementasikan menggunakan protokol iSCSI, dan dukungan NFS juga direncanakan di masa depan. </p><br><h2 id="virtualnye-kommutatory">  Sakelar virtual </h2><br><p>  Untuk implementasi perangkat lunak switch, komponen terpisah disediakan - Fraktal.  Seperti pada komponen kami yang lain, kami beralih dari yang sederhana ke yang rumit, sehingga dalam versi pertama peralihan sederhana diterapkan, sementara perutean dan firewall diberikan ke perangkat pihak ketiga.  Prinsip operasi adalah standar.  Antarmuka fisik server terhubung oleh jembatan ke objek Fraktal - sekelompok port.  Sekelompok port, pada gilirannya, dengan mesin virtual yang diinginkan dalam klaster.  Organisasi VLAN didukung, dan di salah satu rilis selanjutnya, dukungan VxLAN akan ditambahkan.  Semua sakelar yang dibuat didistribusikan secara default, mis.  didistribusikan di semua node cluster, sehingga mesin virtual mana yang beralih untuk terhubung ke VM tidak bergantung pada node lokasi, ini adalah masalah keputusan administrator saja. </p><br><h2 id="monitoring-i-statistika">  Pemantauan dan statistik </h2><br><p>  Komponen yang bertanggung jawab untuk pemantauan dan statistik (judul pekerjaan Monica), pada kenyataannya, adalah klon yang dirancang ulang dari sistem penyimpanan ENGINE.  Pada suatu waktu, ia merekomendasikan dirinya dengan baik dan kami memutuskan untuk menggunakannya dengan vAIR dengan penyetelan yang mudah.  Seperti semua komponen lainnya, Monica dieksekusi dan disimpan di semua node cluster secara bersamaan. </p><br><p>  Tanggung jawab Monica yang sulit dapat diuraikan sebagai berikut: </p><br><p>  Pengumpulan data: </p><br><ul><li>  dari sensor perangkat keras (apa yang dapat memberi zat besi pada IPMI); </li><li>  dari objek logis vAIR (ARDFS, Bangau, Fraktal, MasterIO, dan objek lainnya). </li></ul><br><p><img src="https://habrastorage.org/webt/1c/4k/u8/1c4ku82o_bkanp-348z-jbeioma.png"></p><br><p>  Mengumpulkan data dalam database terdistribusi; </p><br><p>  Interpretasi data dalam bentuk: </p><br><ul><li>  log; </li><li>  Lansiran </li><li>  jadwal. </li></ul><br><p>  Interaksi eksternal dengan sistem pihak ketiga melalui protokol SMTP (mengirim peringatan email) dan SNMP (interaksi dengan sistem pemantauan pihak ketiga). </p><br><p><img src="https://habrastorage.org/webt/2k/-p/9o/2k-p9oah-yrta3n5ti0m5yfm22e.png"></p><br><h2 id="raspredelennaya-baza-konfiguraciy">  Basis Konfigurasi Terdistribusi </h2><br><p>  Dalam paragraf sebelumnya, disebutkan bahwa banyak data disimpan di semua node cluster pada saat yang sama.  Untuk mengatur metode penyimpanan ini, disediakan database ConfigDB terdistribusi khusus.  Seperti namanya, database menyimpan konfigurasi semua objek cluster: hypervisor, mesin virtual, modul HA, switch, sistem file (jangan bingung dengan database metadata FS, ini adalah database lain), serta statistik.  Data ini disimpan secara sinkron pada semua node dan konsistensi data ini merupakan prasyarat untuk operasi stabil vAIR. </p><br><p>  Poin penting: meskipun fungsi ConfigDB sangat penting untuk operasi vAIR, kegagalannya, meskipun akan menghentikan cluster, tidak mempengaruhi konsistensi data yang disimpan di ARDFS, yang menurut kami merupakan nilai tambah untuk keandalan solusi secara keseluruhan. </p><br><p>  ConfigDB juga merupakan satu titik manajemen, sehingga Anda dapat pergi ke sembarang cluster dari alamat IP dan sepenuhnya mengelola semua node dari cluster, yang cukup nyaman. </p><br><p>  Selain itu, untuk mengakses sistem eksternal, ConfigDB menyediakan Restful API di mana Anda dapat mengkonfigurasi integrasi dengan sistem pihak ketiga.  Sebagai contoh, kami baru-baru ini membuat integrasi pilot dengan beberapa solusi Rusia di bidang VDI dan keamanan informasi.  Ketika proyek selesai, kami akan dengan senang hati menulis rincian teknis di sini. </p><br><h2 id="kartina-v-celom">  Seluruh gambar </h2><br><p>  Akibatnya, kami memiliki dua versi arsitektur sistem. </p><br><p>  Dalam kasus pertama - utama - perangkat lunak Avisor hypervisor dan Fractal switch KVM kami digunakan. </p><br><p>  <strong>Skenario 1. Benar</strong> </p><br><p><img src="https://habrastorage.org/webt/0-/pb/7j/0-pb7j1-zdrpqone3dlvw5un4py.png"></p><br><p>  Pada opsi kedua - opsional - ketika Anda ingin menggunakan hypervisor ESXi, skema ini agak rumit.  Untuk menggunakan ESXi, itu harus diinstal dengan cara standar pada drive lokal cluster.  Selanjutnya, pada setiap node ESXi, mesin virtual vAIR MasterVM diinstal, yang berisi distribusi vAIR khusus untuk dijalankan sebagai mesin virtual VMware. </p><br><p>  ESXi memberikan semua disk lokal gratis dengan meneruskan ke MasterVM.  Di dalam MasterVM, disk ini sudah diformat secara standar di ARDFS dan dikirim ke luar (atau lebih tepatnya, kembali ke ESXi) menggunakan protokol iSCSI (dan di masa depan juga akan ada NFS) melalui antarmuka khusus di ESXi.  Dengan demikian, mesin virtual dan jaringan perangkat lunak dalam hal ini disediakan oleh ESXi. </p><br><p>  <strong>Skenario 2. ESXi</strong> </p><br><p><img src="https://habrastorage.org/webt/no/jf/cv/nojfcvippesbznyxdmzpvnmq2se.png"></p><br><p>  Jadi, kami telah membongkar semua komponen utama arsitektur vAIR dan tugas-tugas mereka.  Pada artikel selanjutnya kita akan berbicara tentang fungsionalitas dan rencana yang sudah diterapkan untuk waktu dekat. </p><br><p>  Kami menunggu komentar dan saran. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id475254/">https://habr.com/ru/post/id475254/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id475244/index.html">Fitur JavaScript Baru yang Diharapkan Harus Anda Ketahui</a></li>
<li><a href="../id475246/index.html">Pemrograman Asinkron Python: Tinjauan Singkat</a></li>
<li><a href="../id475248/index.html">Penggunaan polyfill saat menulis aplikasi lintas-browser</a></li>
<li><a href="../id475250/index.html">Sebagai Redash memperhatikan dan memperbaiki masalah yang menyebabkan penurunan kinerja kode Python</a></li>
<li><a href="../id475252/index.html">Cara mengkritik Microsoft</a></li>
<li><a href="../id475258/index.html">Representasi visual dari pemilihan di St. Petersburg - keajaiban pembungkus suara</a></li>
<li><a href="../id475260/index.html">Perbedaan antara fungsi asinkron dan fungsi yang mengembalikan janji</a></li>
<li><a href="../id475262/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 388 (4 - 10 November, 2019)</a></li>
<li><a href="../id475264/index.html">Sniffer yang bisa: bagaimana keluarga FakeSecurity menginfeksi toko online</a></li>
<li><a href="../id475268/index.html">Parameterisasi tidak pasti sebagai metode universal untuk membangun arsitektur aplikasi di C ++ dan Java untuk minimum. harga</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>