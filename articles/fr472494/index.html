<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëáüèø üë©‚Äçüíª üëÜüèæ Analyse de code ROOT - cadre d'analyse des donn√©es de recherche üà≥ üßöüèø üë©üèº‚Äçüè≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alors que la 118e semaine Nobel se d√©roulait √† Stockholm, un examen du code du projet ROOT utilis√© dans la recherche scientifique pour le traitement d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analyse de code ROOT - cadre d'analyse des donn√©es de recherche</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/472494/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df2/7f4/bcd/df27f4bcd139790b322570ee2f48e1ab.png" alt="Image 3"></div>  Alors que la 118e semaine Nobel se d√©roulait √† Stockholm, un examen du code du projet ROOT utilis√© dans la recherche scientifique pour le traitement des m√©gadonn√©es √©tait en cours de pr√©paration au bureau de d√©veloppement de l'analyseur de code statique PVS-Studio.  Bien s√ªr, vous ne donnerez pas de bonus pour un tel code, mais les d√©veloppeurs recevront un examen d√©taill√© des d√©fauts de code int√©ressants et une licence pour une v√©rification compl√®te du projet. <br><br><h2>  Pr√©sentation </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a89/187/f04/a89187f045bbcb2b5b8d5ab7c9dc7da1.png" alt="Image 1"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ROOT</a> - un ensemble d'utilitaires pour travailler avec des donn√©es de recherche scientifique.  Il fournit toutes les fonctionnalit√©s n√©cessaires au traitement des m√©gadonn√©es, √† l'analyse statistique, √† la visualisation et au stockage.  Il est principalement √©crit en C ++.  Le d√©veloppement a commenc√© au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CERN</a> (Organisation europ√©enne pour la recherche nucl√©aire) pour la recherche en physique des hautes √©nergies.  Chaque jour, des milliers de physiciens utilisent des applications ROOT pour analyser leurs donn√©es ou simuler. <br><a name="habracut"></a><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PVS-Studio</a> est un outil pour d√©tecter les erreurs et les vuln√©rabilit√©s potentielles dans le code source des programmes √©crits en C, C ++, C # et Java.  Il fonctionne sur les syst√®mes 64 bits sous Windows, Linux et macOS et peut analyser le code con√ßu pour les plates-formes ARM 32 bits, 64 bits et int√©gr√©es. <br><br><h2>  D√©but des nouveaux diagnostics </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V1046</a> Utilisation non <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">s√ªre</a> des types bool 'et' int 'ensemble dans l'op√©ration' &amp; = '.  GSLMultiRootFinder.h 175 <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ROOT::Math::IMultiGenFunction &amp; func)</span></span></span><span class="hljs-function"> </span></span>{ ROOT::Math::IMultiGenFunction * f = func.Clone(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!f) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; fFunctions.push_back(f); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fFunctions.size(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FuncIterator</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SetFunctionList</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FuncIterator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">begin</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FuncIterator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ret = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (FuncIterator itr = begin; itr != end; ++itr) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ROOT::Math::IMultiGenFunction * f = *itr; ret &amp;= AddFunction(*f); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre> <br>  La version b√™ta de l'analyseur qui a √©t√© utilis√©e lors de la v√©rification a trouv√© une erreur si terrible. <br><br>  <b>J'attends.</b>  La fonction <i>SetFunctionList</i> contourne la liste des it√©rateurs.  Si au moins l'un d'entre eux n'est pas valide, la valeur de retour sera <i>fausse</i> , sinon <i>vraie</i> . <br><br>  <b>La r√©alit√©</b>  La fonction <i>SetFunctionList</i> peut retourner <i>false</i> m√™me pour les it√©rateurs valides.  Nous allons <i>examiner</i> la situation: <i>AddFunction</i> renvoie le nombre d'it√©rateurs valides dans la liste <i>fFunctions</i> .  C'est-√†-dire  lors de l'ajout d'it√©rateurs non nuls, la taille de cette liste augmentera s√©quentiellement: 1, 2, 3, 4, etc.  C'est l√† que l'erreur dans le code commence √† se manifester: <br><br><pre> <code class="cpp hljs">ret &amp;= AddFunction(*f);</code> </pre> <br>  Parce que  Puisque la fonction retourne un r√©sultat de type <i>int</i> , pas <i>bool</i> , l'op√©ration '&amp; =' avec des nombres pairs donnera la valeur <i>false</i> .  Apr√®s tout, le bit de nombre pair le moins significatif sera toujours nul.  Par cons√©quent, une telle erreur non √©vidente g√¢chera le r√©sultat de la fonction <i>SetFunctionsList</i> m√™me pour des arguments valides. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa4/c23/64f/aa4c2364f5205b526db1625aeebd32ff.png" alt="Image 2"></div><br><h2>  Erreurs dans les expressions conditionnelles </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V501</a> Il existe des sous-expressions identiques √† gauche et √† droite de l'op√©rateur '&amp;&amp;': module &amp;&amp; module rootcling_impl.cxx 3650 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleDiagnostic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> override </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isROOTSystemModuleDiag = <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> &amp;&amp; ....; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isSystemModuleDiag = <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>-&gt;IsSystem; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isROOTSystemModuleDiag &amp;&amp; !isSystemModuleDiag) fChild-&gt;HandleDiagnostic(DiagLevel, Info); .... }</code> </pre> <br>  Commen√ßons par l'exemple le plus inoffensif.  Le pointeur du module est v√©rifi√© deux fois.  Tr√®s probablement, une v√©rification n'est pas n√©cessaire.  Mais il vaut mieux corriger le code afin qu‚Äôil n‚Äôy ait pas de questions inutiles. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V501</a> Il existe des sous-expressions identiques 'strchr (fHostAuth-&gt; GetHost (),' * ')' √† gauche et √† droite de '||'  op√©rateur.  TAuthenticate.cxx 300 <br><br><pre> <code class="cpp hljs">TAuthenticate::TAuthenticate(TSocket *sock, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *remote, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *proto, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *user) { .... <span class="hljs-comment"><span class="hljs-comment">// If generic THostAuth (ie with wild card or user == any) // make a personalized memory copy of this THostAuth if (strchr(fHostAuth-&gt;GetHost(),'*') || strchr(fHostAuth-&gt;GetHost(),'*') || fHostAuth-&gt;GetServer() == -1 ) { fHostAuth = new THostAuth(*fHostAuth); fHostAuth-&gt;SetHost(fqdn); fHostAuth-&gt;SetUser(checkUser); fHostAuth-&gt;SetServer(servtype); } .... }</span></span></code> </pre> <br>  Ici, dans la ligne <i>fHostAuth-&gt; GetHost (),</i> le m√™me caract√®re est recherch√© - '*'.  Peut-√™tre que l'un d'eux devrait √™tre le symbole ¬´?¬ª.  Ils sont g√©n√©ralement utilis√©s pour d√©finir diff√©rents masques. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V517</a> L'utilisation du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mod√®le</a> 'if (A) {...} else if (A) {...}' a √©t√© d√©tect√©e.  Il y a une probabilit√© de pr√©sence d'erreur logique.  V√©rifiez les lignes: 163, 165. TProofMonSenderML.cxx 163 <br><br><pre> <code class="cpp hljs">Int_t TProofMonSenderML::SendSummary(TList *recs, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *id) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fSummaryVrs == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((dsn = recs-&gt;FindObject(<span class="hljs-string"><span class="hljs-string">"dataset"</span></span>))) recs-&gt;Remove(dsn); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fSummaryVrs == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Only the first records xrecs = new TList; xrecs-&gt;SetOwner(kFALSE); TIter nxr(recs); TObject *o = 0; while ((o = nxr())) { if (!strcmp(o-&gt;GetName(), "vmemmxw")) break; xrecs-&gt;Add(o); } } .... }</span></span></code> </pre> <br>  La variable <i>fSummaryVrs est</i> compar√©e deux fois √† z√©ro.  Cela provoque l'ex√©cution du code dans la branche else-if.  Beaucoup de code y est √©crit ... <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V523</a> L' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">instruction</a> 'then' est √©quivalente √† l'instruction 'else'.  TKDTree.cxx 805 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Index, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Value&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TKDTree&lt;Index, Value&gt;::UpdateRange(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (point[fAxis[inode]]&lt;=fValue[inode]){ <span class="hljs-comment"><span class="hljs-comment">//first examine the node that contains the point UpdateRange(GetLeft(inode),point, range, res); UpdateRange(GetRight(inode),point, range, res); } else { UpdateRange(GetLeft(inode),point, range, res); UpdateRange(GetRight(inode),point, range, res); } .... }</span></span></code> </pre> <br>  Le m√™me code copier-coller est ex√©cut√© dans n'importe quelle condition.  Il y a peut-√™tre une faute de frappe dans les mots <i>gauche</i> et <i>droite</i> . <br><br>  Il y a beaucoup de code suspect similaire dans le projet: <br><br><ul><li>  V523 L'instruction 'then' est √©quivalente √† l'instruction 'else'.  TContainerConverters.cxx 51 </li><li>  V523 L'instruction 'then' est √©quivalente √† l'instruction 'else'.  TWebFile.cxx 1310 </li><li>  V523 L'instruction 'then' est √©quivalente √† l'instruction 'else'.  MethodMLP.cxx 423 </li><li>  V523 L'instruction 'then' est √©quivalente √† l'instruction 'else'.  RooAbsCategory.cxx 394 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V547 L'</a> expression '! File_name_value.empty ()' est toujours fausse.  SelectionRules.cxx 1423 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> SelectionRules::AreAllSelectionRulesUsed() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; rule : fClassSelectionRules){ .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file_name_value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!rule.GetAttributeValue(<span class="hljs-string"><span class="hljs-string">"file_name"</span></span>, file_name_value)) file_name_value.clear(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!file_name_value.empty()) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= // don't complain about defined_in rules continue; } const char* attrName = nullptr; const char* attrVal = nullptr; if (!file_name_value.empty()) { // &lt;= attrName = "file name"; attrVal = file_name_value.c_str(); } else { attrName = "class"; if (!name.empty()) attrVal = name.c_str(); } ROOT::TMetaUtils::Warning(0,"Unused %s rule: %s\n", attrName, attrVal); } .... }</span></span></code> </pre> <br>  Tr√®s probablement, il n'y a pas d'erreur.  L'analyseur a d√©tect√© un code pouvant √™tre raccourci.  Parce que  <i>√âtant donn√© que la</i> valeur de <i>file_name_value.empty () est</i> v√©rifi√©e au d√©but de la boucle, puis plus bas dans le code, cette v√©rification peut √™tre supprim√©e, r√©duisant consid√©rablement la quantit√© de code inutile. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V590</a> Envisagez d'inspecter le '! File1 ||  c &lt;= 0 ||  c == '*' ||  c! = '(' 'expression. L'expression est excessive ou contient une erreur d'impression. TTabCom.cxx 840 <br><br><pre> <code class="cpp hljs">TString TTabCom::DetermineClass(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> varName[]) { .... c = file1.get(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!file1 || c &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || c == <span class="hljs-string"><span class="hljs-string">'*'</span></span> || c != <span class="hljs-string"><span class="hljs-string">'('</span></span>) { Error(<span class="hljs-string"><span class="hljs-string">"TTabCom::DetermineClass"</span></span>, <span class="hljs-string"><span class="hljs-string">"variable \"%s\" not defined?"</span></span>, varName); <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> cleanup; } .... }</code> </pre> <br>  Consid√©rez la partie abr√©g√©e de l'expression conditionnelle point√©e par l'analyseur: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (.... || c == <span class="hljs-string"><span class="hljs-string">'*'</span></span> || c != <span class="hljs-string"><span class="hljs-string">'('</span></span>) { .... }</code> </pre> <br>  La condition ne d√©pend pas de l‚Äô√©galit√© ou non du symbole ¬´ast√©risque¬ª.  Cette partie de l'expression conditionnelle sera toujours vraie pour tout caract√®re autre que '('. Ceci est facile √† voir si vous construisez une table de v√©rit√©. <br><br>  Deux autres endroits avec une logique √©trange dans les expressions conditionnelles: <br><br><ul><li>  V590 Envisagez d'inspecter cette expression.  L'expression est excessive ou contient une erreur d'impression.  TFile.cxx 3963 </li><li>  V590 Envisagez d'inspecter cette expression.  L'expression est excessive ou contient une erreur d'impression.  TStreamerInfoActions.cxx 3084 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V593</a> Envisagez de revoir l'expression du type ¬´A = B &lt;C¬ª.  L'expression est calcul√©e comme suit: ¬´A = (B &lt;C)¬ª.  TProofServ.cxx 1903 <br><br><pre> <code class="cpp hljs">Int_t TProofServ::HandleSocketInput(TMessage *mess, Bool_t all) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Int_t ret = fProof-&gt;AddWorkers(workerList) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Error(<span class="hljs-string"><span class="hljs-string">"HandleSocketInput:kPROOF_GETSLAVEINFO"</span></span>, <span class="hljs-string"><span class="hljs-string">"adding a list of worker nodes returned: %d"</span></span>, ret); } .... }</code> </pre> <br>  L'erreur d√©tect√©e par l'analyseur ne se manifeste que lorsque le programme ne fonctionne pas correctement.  La variable <i>ret</i> doit stocker le code retour de la fonction <i>AddWorkers</i> et, en cas d'urgence, afficher cette valeur dans le journal.  Mais le code ne fonctionne pas comme √ßa.  La condition manque de crochets suppl√©mentaires qui sp√©cifient la priorit√© des op√©rations.  Pas le code retour, mais le r√©sultat d'une comparaison logique est stock√© dans la variable <i>ret</i> , c'est-√†-dire  seulement 0 ou 1. <br><br>  Il y a un autre endroit avec un d√©faut similaire: <br><br><ul><li>  V593 Envisagez de revoir l'expression du type ¬´A = B &lt;C¬ª.  L'expression est calcul√©e comme suit: ¬´A = (B &lt;C)¬ª.  TProofServ.cxx 3897 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V768</a> La constante d'√©num√©ration 'kCostComplexityPruning' est utilis√©e comme variable de type bool√©en.  MethodDT.cxx 283 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> EPruneMethod {kExpectedErrorPruning=<span class="hljs-number"><span class="hljs-number">0</span></span>, kCostComplexityPruning, kNoPruning}; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TMVA::MethodDT::ProcessOptions() { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fPruneStrength &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) fAutomatic = kTRUE; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> fAutomatic = kFALSE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fAutomatic &amp;&amp; fPruneMethod==!DecisionTree::kCostComplexityPruning){ Log() &lt;&lt; kFATAL &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Sorry automatic pruning strength determination is ...."</span></span> &lt;&lt; Endl; } .... }</code> </pre> <br>  Hmm ... Pourquoi la n√©gation de la valeur constante de <i>kCostComplexityPruning</i> ?  Tr√®s probablement, le symbole de n√©gation a √©t√© accidentellement ajout√© et conduit maintenant √† une logique incorrecte d'ex√©cution de code. <br><br><h2>  Code non valide avec des pointeurs </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V522 Le</a> d√©r√©f√©rencement du pointeur nul ¬´pre¬ª peut avoir lieu.  TSynapse.cxx 61 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TSynapse::SetPre(TNeuron * pre) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pre) { Error(<span class="hljs-string"><span class="hljs-string">"SetPre"</span></span>,<span class="hljs-string"><span class="hljs-string">"this synapse is already assigned to a pre-neuron."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } fpre = pre; pre-&gt;AddPost(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  J'ai essay√© de comprendre ce code bizarre.  Il semble que l'id√©e ne consiste pas √† d√©finir une nouvelle valeur pour le champ <i>fpre</i> .  Ensuite, ils ont fait une erreur en confondant le pointeur, qui devrait √™tre v√©rifi√© dans l'√©tat.  Dans l'impl√©mentation actuelle, si vous transmettez la valeur <i>nullptr</i> √† la fonction <i>SetPre</i> , le pointeur null est d√©r√©f√©renc√©. <br><br>  Tr√®s probablement, c'est correct: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TSynapse::SetPre(TNeuron * pre) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fpre) { Error(<span class="hljs-string"><span class="hljs-string">"SetPre"</span></span>,<span class="hljs-string"><span class="hljs-string">"this synapse is already assigned to a pre-neuron."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } fpre = pre; pre-&gt;AddPost(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  Certes, cela ne sauvera toujours pas la fonction de passer un pointeur nul.  Mais au moins, ce code semble plus logique que la version originale. <br><br>  Voici un autre endroit qui a √©t√© copi√© √† partir d'ici avec de l√©g√®res modifications: <br><br><ul><li>  V522 Le d√©r√©f√©rencement du pointeur nul ¬´post¬ª peut avoir lieu.  TSynapse.cxx 74 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V595</a> Le pointeur 'N' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† nullptr.  V√©rifiez les lignes: 484, 488. Scanner.cxx 484 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> RScanner::shouldVisitDecl(clang::NamedDecl *D) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> M = D-&gt;getOwningModule()) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= 2 return fInterpreter.getSema().isModuleVisible(M); } return true; } bool RScanner::VisitNamespaceDecl(clang::NamespaceDecl* N) { if (fScanType == EScanType::kOnePCM) return true; if (!shouldVisitDecl(N)) // &lt;= 1 return true; if((N &amp;&amp; N-&gt;isImplicit()) || !N){ // &lt;= 3 return true; } .... }</span></span></code> </pre> <br>  L'analyseur a d√©tect√© un code tr√®s dangereux!  Dans le premier cas, le pointeur <i>N</i> est d√©r√©f√©renc√© sans v√©rifier une valeur nulle.  Et vous ne pouvez m√™me pas voir l'appel au pointeur non v√©rifi√©.  Cela se produit √† l'int√©rieur de la fonction <i>shouldVisitDecl</i> . <br><br>  Traditionnellement, cette r√®gle de diagnostic g√©n√®re de nombreux avertissements utiles.  En voici quelques uns: <br><br><ul><li>  V595 Le pointeur ¬´fichier¬ª a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† nullptr.  V√©rifiez les lignes: 141, 153. TFileCacheRead.cxx 141 </li><li>  V595 Le pointeur 'fFree' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† nullptr.  V√©rifiez les lignes: 2029, 2038. TFile.cxx 2029 </li><li>  V595 Le pointeur 'tbuf' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† nullptr.  V√©rifier les lignes: 586, 591. TGText.cxx 586 </li><li>  V595 Le pointeur 'fPlayer' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† nullptr.  V√©rifiez les lignes: 3425, 3430. TProof.cxx 3425 </li><li>  V595 Le pointeur 'gProofServ' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† nullptr.  V√©rifiez les lignes: 1192, 1194. TProofPlayer.cxx 1192 </li><li>  V595 Le pointeur 'projDataTmp' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† nullptr.  V√©rifiez les lignes: 791, 804. RooSimultaneous.cxx 791 </li></ul><br>  L'exemple suivant n'est pas une erreur, mais d√©montre une fois de plus que les macros <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">encouragent l'</a> √©criture de code incorrect ou redondant. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V571 Contr√¥le</a> r√©current.  La condition ¬´if (fCanvasImp)¬ª a d√©j√† √©t√© v√©rifi√©e √† la ligne 799. TCanvas.cxx 800 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SafeDelete(p) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (p) { delete p; p = 0; } } void TCanvas::Close(Option_t *option) { .... </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (fCanvasImp) SafeDelete(fCanvasImp); .... }</span></span></code> </pre> <br>  Le pointeur <i>fCanvasImp est</i> v√©rifi√© deux fois.  L'une des v√©rifications est d√©j√† impl√©ment√©e dans la macro <i>SafeDelete</i> .  Un des probl√®mes avec les macros est qu'elles sont souvent difficiles √† naviguer √† partir du code, donc beaucoup n'√©tudient pas leur contenu avant utilisation. <br><br><h2>  Erreurs lors de l'utilisation de tableaux </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V519</a> La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">variable</a> 'Line [Cursor]' re√ßoit des valeurs successives deux fois.  C'est peut-√™tre une erreur.  V√©rifiez les lignes: 352, 353. Editor.cpp 353 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> find_last_non_alnum(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;str, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::size_type index = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos) { .... <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> tmp = Line.GetText()[Cursor]; Line[Cursor] = Line[Cursor - <span class="hljs-number"><span class="hljs-number">1</span></span>]; Line[Cursor] = tmp; .... }</code> </pre> <br>  La nouvelle valeur de l'√©l√©ment <i>Line [Cursor]</i> est imm√©diatement remplac√©e.  Quelque chose ne va pas ici ... <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V557 Le</a> d√©passement de matrice est possible.  L'index ¬´ivar¬ª pointe au-del√† de la limite du tableau.  BasicMinimizer.cxx 130 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> BasicMinimizer::SetVariableValue(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ivar, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> val) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ivar &gt; fValues.size() ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; fValues[ivar] = val; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Faire des erreurs dans la v√©rification de l'index d'un tableau n'est donc qu'un √©norme probl√®me ces derniers temps.  Presque tous les trois projets sont trouv√©s.  Si tout est simple lors de l'indexation d'un tableau dans une boucle - l'op√©rateur '&lt;' est presque toujours utilis√© pour comparer l'index √† la taille du tableau, alors avec une telle v√©rification, comme ici, vous devez utiliser l'op√©rateur '&gt; =', et non '&gt;'.  Sinon, il est possible de d√©passer la limite du tableau par un √©l√©ment. <br><br>  Cette erreur s'est propag√©e plusieurs fois sur le fichier: <br><br><ul><li>  V557 Le d√©passement de matrice est possible.  L'index ¬´ivar¬ª pointe au-del√† de la limite du tableau.  BasicMinimizer.cxx 186 </li><li>  V557 Le d√©passement de matrice est possible.  L'index ¬´ivar¬ª pointe au-del√† de la limite du tableau.  BasicMinimizer.cxx 194 </li><li>  V557 Le d√©passement de matrice est possible.  L'index ¬´ivar¬ª pointe au-del√† de la limite du tableau.  BasicMinimizer.cxx 209 </li><li>  V557 Le d√©passement de matrice est possible.  L'index ¬´ivar¬ª pointe au-del√† de la limite du tableau.  BasicMinimizer.cxx 215 </li><li>  V557 Le d√©passement de matrice est possible.  L'index ¬´ivar¬ª pointe au-del√† de la limite du tableau.  BasicMinimizer.cxx 230 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V621</a> Envisagez d'inspecter l'op√©rateur ¬´pour¬ª.  Il est possible que la boucle soit mal ex√©cut√©e ou ne soit pas ex√©cut√©e du tout.  TDataMember.cxx 554 <br><br><pre> <code class="cpp hljs">Int_t TDataMember::GetArrayDim() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fArrayDim&lt;<span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; fInfo) { R__LOCKGUARD(gInterpreterMutex); TDataMember *dm = <span class="hljs-keyword"><span class="hljs-keyword">const_cast</span></span>&lt;TDataMember*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); dm-&gt;fArrayDim = gCling-&gt;DataMemberInfo_ArrayDim(fInfo); <span class="hljs-comment"><span class="hljs-comment">// fArrayMaxIndex should be zero if (dm-&gt;fArrayDim) { dm-&gt;fArrayMaxIndex = new Int_t[fArrayDim]; for(Int_t dim = 0; dim &lt; fArrayDim; ++dim) { dm-&gt;fArrayMaxIndex[dim] = gCling-&gt;DataMemberInfo_MaxIndex(fInfo,dim); } } } return fArrayDim; }</span></span></code> </pre> <br>  Tr√®s probablement, dans la boucle for, ils voulaient comparer la variable <i>dim</i> avec <i>dm-&gt; fArrayDim</i> , et non <i>fArrayDim</i> .  La valeur de la variable utilis√©e est n√©gative, en raison de la condition au d√©but de la fonction.  Un tel cycle n'est jamais ex√©cut√©. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V767</a> Acc√®s suspect √† l'√©l√©ment du tableau 'courant' par un index constant √† l'int√©rieur d'une boucle.  TClingUtils.cxx 3082 <br><br><pre> <code class="cpp hljs">llvm::StringRef ROOT::TMetaUtils::DataMemberInfo__ValidArrayIndex(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current!=<span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Check the token if (isdigit(current[0])) { for(i=0;i&lt;strlen(current);i++) { if (!isdigit(current[0])) { if (errstr) *errstr = current; if (errnum) *errnum = NOT_INT; return llvm::StringRef(); } } } else { // current token is not a digit .... } .... } .... }</span></span></code> </pre> <br>  Ce fragment de code analyse une certaine ligne et v√©rifie son exactitude.  Une fois que le caract√®re nul de la cha√Æne <i>actuelle</i> est d√©fini comme un nombre, tous les autres caract√®res sont parcourus pour vous assurer que tous les caract√®res sont des nombres √† la fin de la cha√Æne.  Eh bien, comment √ßa se passe ... le compteur de boucle <i>i n'est</i> pas utilis√© dans la boucle.  Il √©tait n√©cessaire d'√©crire le <i>courant [i]</i> et non le <i>courant [0]</i> dans la condition. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16e/c09/97a/16ec0997a4c29ce4a257d4124cf63ce2.png" alt="Image 4"></div><br><h2>  Fuite de m√©moire </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V773</a> La fonction a √©t√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ferm√©e</a> sans rel√¢cher le pointeur ¬´liste d'options¬ª.  Une fuite de m√©moire est possible.  TDataMember.cxx 355 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TDataMember::Init(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> afterReading) { .... TList *optionlist = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TList(); <span class="hljs-comment"><span class="hljs-comment">//storage for options strings for (i=0;i&lt;token_cnt;i++) { if (strstr(tokens[i],"Items")) { ptr1 = R__STRTOK_R(tokens[i], "()", &amp;rest); if (ptr1 == 0) { Fatal("TDataMember","Internal error, found \"Items....",GetTitle()); return; } ptr1 = R__STRTOK_R(nullptr, "()", &amp;rest); if (ptr1 == 0) { Fatal("TDataMember","Internal error, found \"Items....",GetTitle()); return; } .... } .... } .... // dispose of temporary option list... delete optionlist; .... }</span></span></code> </pre> <br>  Lorsque vous quittez une fonction, la m√©moire n'est pas fournie par le pointeur <i>optionList</i> .  Il est difficile pour moi de dire si cela est n√©cessaire dans ce cas particulier.  Mais g√©n√©ralement, ces erreurs sont corrig√©es dans les projets sur les rapports PVS-Studio.  Tout d√©pend si le programme doit essayer de continuer √† fonctionner en cas d'urgence ou non.  Il existe de nombreux avertissements de ce type dans le projet, il est pr√©f√©rable que les d√©veloppeurs rev√©rifient le projet par eux-m√™mes et voient le rapport complet de l'analyseur. <br><br><h2>  Encore une fois sur la fonction memset </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V597</a> Le compilateur pourrait supprimer l'appel de fonction 'memset', qui est utilis√© pour vider le tampon 'x'.  La fonction memset_s () doit √™tre utilis√©e pour effacer les donn√©es priv√©es.  TMD5.cxx 366 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TMD5::Transform(UInt_t buf[<span class="hljs-number"><span class="hljs-number">4</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UChar_t in[<span class="hljs-number"><span class="hljs-number">64</span></span>]) { UInt_t a, b, c, d, x[<span class="hljs-number"><span class="hljs-number">16</span></span>]; .... <span class="hljs-comment"><span class="hljs-comment">// Zero out sensitive information memset(x, 0, sizeof(x)); }</span></span></code> </pre> <br>  Beaucoup penseront que lorsque le code sera compil√©, ce commentaire n'entrera pas dans le fichier binaire, et ils auront raison: D.  Mais la fonction <i>memset</i> sera √©galement supprim√©e par le compilateur, tout le monde ne le devine pas.  Et cela arrivera.  Si le tampon vid√© ne sera plus utilis√© dans le code, le compilateur optimisera le code et supprimera l'appel de fonction.  Techniquement, il a raison, mais s'il y avait des donn√©es secr√®tes dans le tampon, elles y resteraient.  Il s'agit d'une faille de s√©curit√© classique <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CWE-14</a> . <br><br><h2>  Avertissements divers </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V591</a> La fonction non vide doit renvoyer une valeur.  LogLikelihoodFCN.h 108 <br><br><pre> <code class="cpp hljs">LogLikelihoodFCN &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> LogLikelihoodFCN &amp; rhs) { SetData(rhs.DataPtr() ); SetModelFunction(rhs.ModelFunctionPtr() ); fNEffPoints = rhs.fNEffPoints; fGrad = rhs.fGrad; fIsExtended = rhs.fIsExtended; fWeight = rhs.fWeight; fExecutionPolicy = rhs.fExecutionPolicy; }</code> </pre> <br>  L'instruction surcharg√©e n'a pas de valeur de retour.  √âgalement un probl√®me tr√®s courant ces derniers temps. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V596</a> L'objet a √©t√© cr√©√© mais il n'est pas utilis√©.  Le mot cl√© ¬´throw¬ª peut √™tre manquant: throw runtime_error (FOO);  RTensor.hxx 363 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Value_t, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Container_t&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> RTensor&lt;Value_t, Container_t&gt; RTensor&lt;Value_t, Container_t&gt;::Transpose() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fLayout == MemoryLayout::RowMajor) { fLayout = MemoryLayout::ColumnMajor; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fLayout == MemoryLayout::ColumnMajor) { fLayout = MemoryLayout::RowMajor; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-string"><span class="hljs-string">"Memory layout is not known."</span></span>); } .... }</code> </pre> <br>  L'erreur est que le mot cl√© <i>throw</i> est accidentellement oubli√©.  Par cons√©quent, ce code ne l√®ve pas d'exception en cas d'erreur. <br><br>  Au total, il y avait deux de ces endroits.  La seconde: <br><br><ul><li>  V596 L'objet a √©t√© cr√©√© mais il n'est pas utilis√©.  Le mot cl√© ¬´throw¬ª peut √™tre manquant: throw runtime_error (FOO);  Forest.hxx 137 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V609</a> Divisez par z√©ro.  Plage du d√©nominateur [0..100].  TGHtmlImage.cxx 340 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *TGHtml::GetPctWidth(TGHtmlElement *p, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *opt, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ret) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, m, val; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || n &gt; <span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> z; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (opt[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'h'</span></span>) { val = fCanvas-&gt;GetHeight() * <span class="hljs-number"><span class="hljs-number">100</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { val = fCanvas-&gt;GetWidth() * <span class="hljs-number"><span class="hljs-number">100</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!fInTd) { <span class="hljs-built_in"><span class="hljs-built_in">snprintf</span></span>(ret, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-string"><span class="hljs-string">"%d"</span></span>, val / n); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } else { .... } .... }</span></span></code> </pre> <br>  Un cas similaire √† ceux d√©crits pr√©c√©demment sur les tableaux.  Ici, la variable <i>n est</i> limit√©e √† une plage de valeurs de 0 √† 100. Dans ce cas, il existe une branche de code dans laquelle la division par la variable n avec une valeur de 0 se produit. Tr√®s probablement, la restriction de la valeur de n doit √™tre r√©√©crite de cette fa√ßon: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || n &gt; <span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> z;</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V646</a> Envisagez d'inspecter la logique de l'application.  Il est possible que le mot cl√© "else" soit manquant.  TProofServ.cxx 729 <br><br><pre> <code class="cpp hljs">TProofServ::TProofServ(Int_t *argc, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **argv, FILE *flog) : TApplication(<span class="hljs-string"><span class="hljs-string">"proofserv"</span></span>, argc, argv, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!logmx.IsDigit()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (logmx.EndsWith(<span class="hljs-string"><span class="hljs-string">"K"</span></span>)) { xf = <span class="hljs-number"><span class="hljs-number">1024</span></span>; logmx.Remove(TString::kTrailing, <span class="hljs-string"><span class="hljs-string">'K'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (logmx.EndsWith(<span class="hljs-string"><span class="hljs-string">"M"</span></span>)) { xf = <span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>; logmx.Remove(TString::kTrailing, <span class="hljs-string"><span class="hljs-string">'M'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (logmx.EndsWith(<span class="hljs-string"><span class="hljs-string">"G"</span></span>)) { xf = <span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>; logmx.Remove(TString::kTrailing, <span class="hljs-string"><span class="hljs-string">'G'</span></span>); } } .... }</code> </pre> <br>  L'analyseur a d√©tect√© un formatage √©trange.  √Ä un endroit, le mot-cl√© <i>else</i> est manquant.  D'apr√®s le code, nous pouvons supposer que le code vaut vraiment la peine d'√™tre corrig√©. <br><br>  Et quelques endroits √† r√©parer en m√™me temps: <br><br><ul><li>  V646 Envisagez d'inspecter la logique de l'application.  Il est possible que le mot cl√© "else" soit manquant.  TFormula_v5.cxx 3702 </li><li>  V646 Envisagez d'inspecter la logique de l'application.  Il est possible que le mot cl√© "else" soit manquant.  RooAbsCategory.cxx 604 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La</a> boucle infinie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V663</a> est possible.  La condition ¬´cin.eof ()¬ª est insuffisante pour rompre la boucle.  Pensez √† ajouter l'appel de fonction 'cin.fail ()' √† l'expression conditionnelle.  MethodKNN.cxx 602 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TMVA::MethodKNN::ReadWeightsFromStream(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream&amp; is) { .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!is.eof()) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> line; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::getline(is, line); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (line.empty() || line.find(<span class="hljs-string"><span class="hljs-string">"#"</span></span>) != <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } .... } .... }</code> </pre> <br>  Lorsque vous travaillez avec la classe <i>std :: istream</i> , appeler la fonction <i>eof ()</i> ne suffit pas pour terminer la boucle.  En cas d'√©chec lors de la lecture des donn√©es, l'appel de la fonction <i>eof ()</i> retournera toujours <i>false</i> , et il n'y a aucun autre point de sortie de la boucle dans ce code.  Pour terminer la boucle dans ce cas, une v√©rification suppl√©mentaire de la valeur retourn√©e par la fonction <i>fail ()</i> est requise: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!is.eof() &amp;&amp; !is.fail()) { .... }</code> </pre> <br>  Ou √©crivez simplement: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (is) { .... }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V678</a> Un objet est utilis√© comme argument de sa propre m√©thode.  Pensez √† v√©rifier le premier argument r√©el de la fonction ¬´Copier¬ª.  TFormLeafInfo.cxx 2414 <br><br><pre> <code class="cpp hljs">TFormLeafInfoMultiVarDim::TFormLeafInfoMultiVarDim( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TFormLeafInfoMultiVarDim&amp; orig) : TFormLeafInfo(orig) { fNsize = orig.fNsize; fSizes.Copy(fSizes); <span class="hljs-comment"><span class="hljs-comment">// &lt;= fCounter2 = orig.fCounter2?orig.fCounter2-&gt;DeepCopy():0; fSumOfSizes = orig.fSumOfSizes; fDim = orig.fDim; fVirtDim = orig.fVirtDim; fPrimaryIndex = orig.fPrimaryIndex; fSecondaryIndex = orig.fSecondaryIndex; }</span></span></code> </pre> <br>  Enfin, voici une telle erreur.  Au lieu de <i>fSizes,</i> vous avez d√ª passer <i>orig.fSizes</i> √† la fonction <i>Copy</i> . <br><br><h2>  Conclusion </h2><br>  Il y a environ un an, un aper√ßu du code de projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NCBI Genome Workbench</a> a √©t√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fourni</a> .  Ce projet est √©galement utilis√© dans la recherche scientifique, mais dans le g√©nome.  Pour ce que je veux dire, les logiciels dans ce domaine sont tr√®s importants, mais leur qualit√© n'est pas d√ªment prise en compte. <br><br>  Soit dit en passant, l'autre jour, macOS 10.15 Catalina est sorti, dans lequel ils ont refus√© de prendre en charge les applications 32 bits.  Et dans PVS-Studio, il existe un large ensemble de r√®gles pour identifier les probl√®mes lors du portage de programmes vers des syst√®mes 64 bits.  Plus d'informations √† ce sujet dans le blog de l'analyseur. <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br>  Si vous souhaitez partager cet article avec un public anglophone, veuillez utiliser le lien vers la traduction: Svyatoslav Razmyslov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Analyse du code de ROOT, cadre d'analyse des donn√©es scientifiques</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr472494/">https://habr.com/ru/post/fr472494/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr472484/index.html">Fermeture de trous dans un cluster Kubernetes. Rapport et transcription avec DevOpsConf</a></li>
<li><a href="../fr472486/index.html">Stockage de donn√©es √† long terme. (Article - discussion)</a></li>
<li><a href="../fr472488/index.html">Trente reportages de DevOops 2019: Tim Lister, Hadi Hariri, Roman Shaposhnik et autres stars du DevOps international</a></li>
<li><a href="../fr472490/index.html">Comment j'ai recherch√© une norme de beaut√© √† l'aide du traitement du langage naturel (et je ne l'ai pas trouv√©e)</a></li>
<li><a href="../fr472492/index.html">Analyse du code de ROOT, cadre d'analyse des donn√©es scientifiques</a></li>
<li><a href="../fr472496/index.html">Cr√©ation d'une mise en page Scrapbook sur une grille CSS</a></li>
<li><a href="../fr472502/index.html">SOC is people: la dure vie quotidienne du responsable de service du centre de surveillance et de r√©ponse aux cyberattaques</a></li>
<li><a href="../fr472504/index.html">PHP Microservice Framework Swoft: Use Database Part 1</a></li>
<li><a href="../fr472508/index.html">Fiabilit√© du flash: attendue et inattendue. Partie 3. XIV conf√©rence de l'association USENIX. Technologies de stockage de fichiers</a></li>
<li><a href="../fr472514/index.html">De la recherche d'une id√©e √† une application termin√©e</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>