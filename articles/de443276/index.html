<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôªÔ∏è üßùüèΩ üßôüèæ Surprise Query Scheduler in der PostgreSQL-Datenbank üë©üèº‚Äçü§ù‚Äçüë®üèª üôÑ üõ¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Diagramme, Berichte und Analysen - all dies ist im Backoffice eines jeden, auch sehr kleinen Unternehmens, irgendwie vorhanden. Wenn es in regul√§ren T...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Surprise Query Scheduler in der PostgreSQL-Datenbank</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/okko/blog/443276/">  Diagramme, Berichte und Analysen - all dies ist im Backoffice eines jeden, auch sehr kleinen Unternehmens, irgendwie vorhanden.  Wenn es in regul√§ren Tabellen in Excel / Numbers / Libre √ºberf√ºllt ist, die Daten jedoch noch nicht sehr gro√ü sind, werden herk√∂mmliche L√∂sungen f√ºr unternehmensinterne Anforderungen h√§ufig mithilfe relationaler Datenbanken wie PostgreSQL, MySQL oder MariaDB erstellt. <br><br>  Diese Datenbanken sind kostenlos, dank SQL k√∂nnen sie bequem in andere Komponenten des Systems integriert werden, sie sind beliebt und die meisten Entwickler und Analysten k√∂nnen mit ihnen arbeiten.  Die Last (Verkehr und Volumen), die sie verdauen k√∂nnen, ist gro√ü genug, um problemlos durchzuhalten, bis sich das Unternehmen komplexere (und teurere) L√∂sungen f√ºr Analysen und Berichte leisten kann. <br><a name="habracut"></a><br><h4>  Ausgangsposition </h4><br>  Aber selbst in einer Technologie, die wiederholt untersucht wurde, gibt es immer verschiedene Nuancen, die die Sorgen der Ingenieure pl√∂tzlich verst√§rken k√∂nnen.  Neben der Zuverl√§ssigkeit ist das am h√§ufigsten genannte Problem bei Datenbanken deren Leistung.  Offensichtlich nimmt mit zunehmender Datenmenge die DB-Antwortrate ab, aber wenn dies vorhersehbar geschieht und mit der Zunahme der Last √ºbereinstimmt, ist dies nicht so schlimm.  Sie k√∂nnen immer im Voraus sehen, wann die Datenbank Aufmerksamkeit erfordert, und ein Upgrade oder einen √úbergang zu einer grundlegend anderen Datenbank planen.  Viel schlimmer, wenn sich die Datenbankleistung unvorhersehbar verschlechtert. <br><br>  Das Thema der Verbesserung der Datenbankleistung ist so alt wie die Welt und sehr umfangreich. In diesem Artikel m√∂chte ich mich nur auf eine Richtung konzentrieren.  Bei der Bewertung der Effektivit√§t von Abfragepl√§nen in einer PostgreSQL-Datenbank sowie bei der √Ñnderung dieser Effizienz im Laufe der Zeit, um das Verhalten des Datenbankplaners vorhersehbarer zu machen. <br><br>  Trotz der Tatsache, dass viele der Dinge, die diskutiert werden, auf alle neueren Versionen dieser Datenbank anwendbar sind, bedeuten die folgenden Beispiele Version 11.2, letztere im Moment. <br>  Bevor wir uns mit den Details befassen, ist es sinnvoll, abzuschweifen und ein paar Worte dar√ºber zu sagen, woher Leistungsprobleme in relationalen Datenbanken kommen k√∂nnen.  Womit ist die Datenbank genau besch√§ftigt, wenn sie "langsamer" wird?  Mangel an Speicher (eine gro√üe Anzahl von Festplatten- oder Netzwerkzugriffen), ein schwacher Prozessor, all dies sind offensichtliche Probleme mit klaren L√∂sungen, aber was kann die Ausf√ºhrungsgeschwindigkeit der Abfrage noch beeinflussen? <br><br><h4>  Erfrischen Sie Erinnerungen </h4><br>  Damit die Datenbank auf die SQL-Abfrage antworten kann, muss ein Abfrageplan erstellt werden (in den Tabellen und Spalten, um zu sehen, welche Indizes ben√∂tigt werden, was von dort ausgew√§hlt werden muss, mit was verglichen werden soll, wie viel Speicher ben√∂tigt wird usw.).  Dieser Plan wird in Form eines Baums gebildet, dessen Knoten nur einige typische Operationen mit unterschiedlicher Rechenkomplexit√§t sind.  Hier sind einige davon zum Beispiel (N ist die Anzahl der Zeilen, mit denen die Operation ausgef√ºhrt werden soll): <br><br><table><thead><tr><th>  <nobr>Bedienung</nobr> </th><th>  Was wird gemacht? </th><th>  Kosten </th></tr></thead><tbody><tr><td colspan="3">  <i><font color="#999">SELECT ... WHERE ... Datenabrufvorg√§nge</font></i> </td></tr><tr><td>  <nobr>Seq Scan</nobr> </td><td>  Wir laden jede Zeile aus der Tabelle und √ºberpr√ºfen den Zustand. </td><td>  O (N) </td></tr><tr><td>  <nobr>Index-Scan</nobr> <br>  (B-Baum-Index) </td><td>  Die Daten befinden sich direkt im Index, daher suchen wir nach Bedingungen nach den erforderlichen Elementen des Index und nehmen die Daten von dort. </td><td>  O (log (N)), suche nach einem Element in einem sortierten Baum. </td></tr><tr><td>  <nobr>Index-Scan</nobr> <br>  (Hash-Index) </td><td>  Die Daten befinden sich direkt im Index, daher suchen wir nach Bedingungen nach den erforderlichen Elementen des Index und nehmen die Daten von dort. </td><td>  O (1), Suche nach einem Element in einer Hash-Tabelle, ohne die Kosten f√ºr die Erstellung von Hashes </td></tr><tr><td>  Bitmap-Heap-Scan </td><td>  Wir w√§hlen die Nummern der erforderlichen Zeilen nach Index aus, laden dann nur die erforderlichen Zeilen und f√ºhren mit ihnen zus√§tzliche Pr√ºfungen durch. </td><td>  Index-Scan + Seq-Scan (M), <br>  Dabei ist M die Anzahl der Zeilen, die nach dem Index-Scan gefunden wurden.  Es wird angenommen, dass M &lt;&lt; N, d.h.  Index ist n√ºtzlicher als Seq Scan. </td></tr><tr><td colspan="3">  <i><font color="#999">Verkn√ºpfungsoperationen (JOIN, SELECT aus mehreren Tabellen)</font></i> </td></tr><tr><td>  Verschachtelte Schleife </td><td>  Suchen Sie f√ºr jede Zeile aus der linken Tabelle nach einer geeigneten Zeile in der rechten Tabelle. </td><td>  O (N <sup>2</sup> ). <br>  Wenn jedoch eine der Tabellen viel kleiner als die andere ist (W√∂rterbuch) und praktisch nicht mit der Zeit w√§chst, k√∂nnen die tats√§chlichen Kosten auf O (N) sinken. </td></tr><tr><td>  Hash beitreten </td><td>  F√ºr jede Zeile aus der linken und rechten Tabelle ber√ºcksichtigen wir den Hash, wodurch die Anzahl der Suchvorg√§nge nach m√∂glichen Verbindungsoptionen verringert wird. </td><td>  O (N), aber im Fall einer sehr ineffizienten Hash-Funktion oder einer gro√üen Anzahl identischer Felder f√ºr die Verbindung kann O (N <sup>2</sup> ) vorhanden sein. </td></tr><tr><td>  Join zusammenf√ºhren </td><td>  Nach Bedingungen sortieren wir die linke und rechte Tabelle, danach kombinieren wir die beiden sortierten Listen </td><td>  O (N * log (N)) <br>  Kosten sortieren + Liste durchgehen. </td></tr><tr><td colspan="3">  <i><font color="#999">Aggregationsoperationen (GROUP BY, DISTINCT)</font></i> </td></tr><tr><td>  Gruppenaggregat </td><td>  Wir sortieren die Tabelle nach der Aggregationsbedingung und gruppieren dann in der sortierten Liste die benachbarten Zeilen. </td><td>  O (N * log (N)) </td></tr><tr><td>  Hash-Aggregat </td><td>  Wir betrachten den Hash f√ºr die Aggregationsbedingung f√ºr jede Zeile.  F√ºr Zeilen mit demselben Hash f√ºhren wir eine Aggregation durch. </td><td>  O (N) </td></tr></tbody></table><br>  Wie Sie sehen k√∂nnen, h√§ngen die Kosten einer Abfrage stark davon ab, wie sich die Daten in den Tabellen befinden und wie diese Reihenfolge den verwendeten Hash-Operationen entspricht.  Verschachtelte Schleifen k√∂nnen trotz ihrer Kosten in O (N <sup>2</sup> ) rentabler sein als Hash Join oder Merge Join, wenn eine der verkn√ºpften Tabellen zu einer oder mehreren Zeilen degeneriert. <br><br>  Zu den Kosten geh√∂rt neben den CPU-Ressourcen auch die Speichernutzung.  Da beide Ressourcen begrenzt sind, muss der Abfrageplaner einen Kompromiss finden.  Wenn die Verbindung von zwei Tabellen √ºber Hash Join mathematisch rentabler ist, aber im Speicher einfach kein Platz f√ºr eine so gro√üe Hash-Tabelle vorhanden ist, kann die Datenbank beispielsweise gezwungen sein, Merge Join zu verwenden.  Eine "langsame" verschachtelte Schleife ben√∂tigt im Allgemeinen keinen zus√§tzlichen Speicher und ist bereit, direkt nach dem Start Ergebnisse zu erzielen. <br><br>  Die relativen Kosten dieser Vorg√§nge sind in der Grafik deutlicher dargestellt.  Dies sind keine absoluten Zahlen, sondern nur ein ungef√§hres Verh√§ltnis verschiedener Operationen. <br><br><img src="https://habrastorage.org/webt/9f/p_/mx/9fp_mx7mhhd5kgokxbqeu-kxpfa.png"><br><br>  Das Nested Loop-Diagramm "beginnt" unten, weil  Es erfordert keine zus√§tzlichen Berechnungen oder Speicherzuweisungen oder das Kopieren von Zwischendaten, hat jedoch O (N <sup>2</sup> ) -Kosten.  Merge Join und Hash Join haben h√∂here Anfangskosten, aber nach einigen N Werten beginnen sie, die verschachtelte Schleife rechtzeitig zu schlagen.  Der Planer versucht, den Plan mit den niedrigsten Kosten auszuw√§hlen, und h√§lt sich in der obigen Tabelle an verschiedene Vorg√§nge mit unterschiedlichen N (gr√ºner gestrichelter Pfeil).  Mit der Anzahl der Zeilen bis zu N1 ist es rentabler, Nested Loop zu verwenden. Von N1 bis N2 ist es rentabler, Join zusammenzuf√ºhren. Nach N2 wird es f√ºr Hash Join rentabler. F√ºr Hash Join ist jedoch Speicher erforderlich, um Hash-Tabellen zu erstellen.  Und wenn N3 erreicht wird, wird dieser Speicher nicht mehr ausreichend, was zur erzwungenen Verwendung von Merge Join f√ºhrt. <br><br>  Bei der Auswahl eines Plans sch√§tzt der Planer die Kosten f√ºr jede Operation im Plan anhand einer Reihe relativer Kosten einiger ‚Äûatomarer‚Äú Operationen in der Datenbank.  B. Berechnungen, Vergleiche, Laden einer Seite in den Speicher usw.  Hier ist eine Liste einiger dieser Parameter aus der Standardkonfiguration, von denen es nicht viele gibt: <br><br><table><thead><tr><th>  Relative Kostenkonstante </th><th>  Standardwert </th></tr></thead><tbody><tr><td>  seq_page_cost </td><td>  1.0 </td></tr><tr><td>  random_page_cost </td><td>  4.0 </td></tr><tr><td>  cpu_tuple_cost </td><td>  0,01 </td></tr><tr><td>  cpu_index_tuple_cost </td><td>  0,005 </td></tr><tr><td>  cpu_operator_cost </td><td>  0,0025 </td></tr><tr><td>  parallel_tuple_cost </td><td>  0,1 </td></tr><tr><td>  parallel_setup_cost </td><td>  1000.0 </td></tr></tbody></table><br>  Zwar gibt es nur wenige Konstanten, aber Sie m√ºssen immer noch genau das ‚ÄûN‚Äú kennen, dh genau, wie viele Zeilen aus den vorherigen Ergebnissen in jeder solchen Operation verarbeitet werden m√ºssen.  Die Obergrenze ist hier offensichtlich - die Datenbank ‚Äûwei√ü‚Äú, wie viele Daten sich in einer Tabelle befinden, und kann immer ‚Äûmaximal‚Äú berechnen.  Wenn Sie beispielsweise zwei Tabellen mit jeweils 100 Zeilen haben, kann das Verkn√ºpfen dieser Tabellen 0 bis 10.000 Zeilen in der Ausgabe erzeugen.  Dementsprechend kann die n√§chste Eingabeoperation bis zu 10.000 Zeilen haben. <br><br>  Wenn Sie jedoch zumindest ein wenig √ºber die Art der Daten in den Tabellen wissen, kann diese Anzahl von Zeilen genauer vorhergesagt werden.  Wenn Sie beispielsweise f√ºr zwei Tabellen mit 100 Zeilen aus dem obigen Beispiel im Voraus wissen, dass der Join nicht 10.000 Zeilen, sondern dieselben 100 Zeilen erzeugt, werden die gesch√§tzten Kosten f√ºr die n√§chste Operation erheblich reduziert.  In diesem Fall k√∂nnte dieser Plan effektiver sein als andere. <br><br><h4>  Out-of-the-Box-Optimierung </h4><br>  Damit der Scheduler die Gr√∂√üe der Zwischenergebnisse genauer vorhersagen kann, verwendet PostgreSQL die Statistiksammlung f√ºr Tabellen, die in pg_statistic oder in seiner besser lesbaren Version - in pg_stats - akkumuliert ist.  Sie wird automatisch beim Start des Vakuums oder explizit mit dem Befehl ANALYZE aktualisiert.  In dieser Tabelle werden verschiedene Informationen dar√ºber gespeichert, welche Daten und welche Art von Natur in den Tabellen enthalten sind.  Insbesondere Histogramme von Werten, Prozentsatz leerer Felder und andere Informationen.  Der Planer verwendet all dies, um die Datenmenge f√ºr jede Operation im Planbaum genauer vorherzusagen und somit die Betriebskosten und den Plan als Ganzes genauer zu berechnen. <br><br>  Nehmen Sie zum Beispiel die Abfrage: <br><pre><code class="plaintext hljs">SELECT t1.important_value FROM t1 WHERE t1.a &gt; 100</code> </pre> <br><br>  Angenommen, das Histogramm der Werte in der Spalte ‚Äût1.a‚Äú ergab, dass Werte √ºber 100 in ungef√§hr 1% der Zeilen der Tabelle gefunden werden.  Dann k√∂nnen wir vorhersagen, dass eine solche Stichprobe etwa ein Hundertstel aller Zeilen aus der Tabelle ‚Äût1‚Äú zur√ºckgibt. <br>  Die Datenbank bietet Ihnen die M√∂glichkeit, die prognostizierten Kosten des Plans mithilfe des Befehls EXPLAIN und die tats√§chliche Betriebszeit mithilfe von EXPLAIN ANALYZE anzuzeigen. <br><br>  Es scheint, dass mit automatischen Statistiken jetzt alles in Ordnung sein sollte, aber es kann Schwierigkeiten geben.  Es gibt einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">guten Artikel von Citus Data</a> , der ein Beispiel f√ºr die Ineffizienz automatischer Statistiken und die Erfassung zus√§tzlicher Statistiken mithilfe von CREATE STATISTICS (verf√ºgbar mit PG 10.0) enth√§lt. <br><br>  F√ºr den Planer gibt es also zwei Fehlerquellen bei der Kostenberechnung: <br><br><ol><li>  Die relativen Kosten f√ºr primitive Operationen (seq_page_cost, cpu_operator_cost usw.) k√∂nnen standardm√§√üig stark von der Realit√§t abweichen (CPU-Kosten 0,01, Kosten f√ºr das Laden von srq-Seiten - 1 oder 4 f√ºr zuf√§lliges Laden von Seiten).  Weit davon entfernt, dass 100 Vergleiche 1 Seitenladung entsprechen. </li><li>  Fehler beim Vorhersagen der Anzahl der Zeilen in Zwischenoperationen.  Die tats√§chlichen Betriebskosten k√∂nnen in diesem Fall stark von der Prognose abweichen. </li></ol><br>  Bei komplexen Abfragen kann das Erstellen und Prognostizieren aller m√∂glichen Pl√§ne viel Zeit in Anspruch nehmen.  Was n√ºtzt es, Daten in 1 Sekunde zur√ºckzugeben, wenn die Datenbank nur eine Minutenanforderung geplant hat?  PostgreSQL verf√ºgt √ºber einen Geqo-Optimierer f√ºr diese Situation. Es handelt sich um einen Scheduler, der nicht alle m√∂glichen Pl√§ne erstellt, sondern mit einigen zuf√§lligen Pl√§nen beginnt und die besten vervollst√§ndigt und M√∂glichkeiten zur Kostensenkung vorhersagt.  All dies verbessert auch nicht die Genauigkeit der Prognose, obwohl es die Suche nach mindestens einem mehr oder weniger optimalen Plan beschleunigt. <br><br><h4>  Pl√∂tzliche Pl√§ne - Konkurrenten </h4><br>  Wenn alles gut geht, wird Ihre Anfrage so schnell wie m√∂glich erf√ºllt.  Wenn die Datenmenge zunimmt, nimmt die Geschwindigkeit der Abfrageausf√ºhrung in der Datenbank allm√§hlich zu, und nach einiger Zeit k√∂nnen Sie bei Beobachtung grob vorhersagen, wann der Speicher oder die Anzahl der CPU-Kerne erh√∂ht oder der Cluster usw. erweitert werden muss. <br><br>  Wir m√ºssen jedoch ber√ºcksichtigen, dass der optimale Plan Konkurrenten mit engen Ausf√ºhrungskosten hat, die wir nicht sehen.  Und wenn die Datenbank pl√∂tzlich den Abfrageplan in einen anderen √§ndert, ist dies eine √úberraschung.  Es ist gut, wenn die Datenbank zu einem effizienteren Plan springt.  Und wenn nicht?  Schauen wir uns zum Beispiel das Bild an.  Dies sind die prognostizierten Kosten und die Echtzeit f√ºr die Umsetzung von zwei Pl√§nen (rot und gr√ºn): <br><br><img src="https://habrastorage.org/webt/an/0e/t1/an0et1smgdhh60caqa4yltzgiu4.png"><br><br>  Hier wird ein Plan in Gr√ºn und der n√§chste ‚ÄûKonkurrent‚Äú in Rot angezeigt.  Die gepunktete Linie zeigt eine grafische Darstellung der projizierten Kosten, die durchgezogene Linie ist die Echtzeit.  Der grau gestrichelte Pfeil zeigt die Planerauswahl. <br><br>  Angenommen, an einem sch√∂nen Freitagabend erreicht die vorhergesagte Anzahl von Zeilen in einer Zwischenoperation N1 und die ‚Äûrote‚Äú Prognose beginnt, die ‚Äûgr√ºne‚Äú zu √ºbertreffen.  Der Scheduler beginnt damit.  Die tats√§chliche Ausf√ºhrungszeit der Abfrage springt sofort (Umschalten von einer gr√ºnen durchgezogenen auf eine rote Linie), dh der Zeitplan f√ºr die Datenbankverschlechterung hat die Form eines Schritts (oder m√∂glicherweise einer ‚ÄûWand‚Äú).  In der Praxis kann eine solche "Wand" die Ausf√ºhrungszeit der Abfrage um eine Gr√∂√üenordnung oder mehr erh√∂hen. <br><br>  Es ist anzumerken, dass diese Situation wahrscheinlich eher f√ºr das Backoffice und die Analyse als f√ºr das Frontend typisch ist, da letzteres normalerweise f√ºr mehr gleichzeitige Abfragen angepasst ist und daher einfachere Abfragen in der Datenbank verwendet, bei denen der Fehler bei Planvorhersagen geringer ist.  Wenn es sich um eine Datenbank f√ºr Berichte oder Analysen handelt, k√∂nnen Abfragen beliebig komplex sein. <br><br><h4>  Wie kann man damit leben? </h4><br>  Es stellt sich die Frage: War es irgendwie m√∂glich, solche unsichtbaren Pl√§ne unter Wasser vorauszusehen?  Das Problem ist schlie√ülich nicht, dass sie nicht optimal sind, sondern dass der Wechsel zu einem anderen Plan unvorhersehbar und nach dem Gesetz der Gemeinheit im ungl√ºcklichsten Moment daf√ºr erfolgen kann. <br><br>  Leider k√∂nnen Sie sie nicht direkt sehen, aber Sie k√∂nnen nach alternativen Pl√§nen suchen, indem Sie die tats√§chlichen Gewichte √§ndern, mit denen sie ausgew√§hlt werden.  Die Bedeutung dieses Ansatzes besteht darin, den aktuellen Plan, den der Planer f√ºr optimal h√§lt, aus dem Blickfeld zu entfernen, damit einer seiner engsten Konkurrenten optimal wird und er somit durch das EXPLAIN-Team gesehen werden kann.  Durch regelm√§√üige √úberpr√ºfung der Kosten√§nderungen bei solchen ‚ÄûWettbewerbern‚Äú und im Hauptplan k√∂nnen Sie die Wahrscheinlichkeit absch√§tzen, mit der die Datenbank bald zu einem anderen Plan ‚Äûspringt‚Äú. <br><br>  Sie k√∂nnen nicht nur Daten zu Prognosen alternativer Pl√§ne sammeln, sondern diese auch ausf√ºhren und deren Leistung messen. Dies gibt auch einen √úberblick √ºber das interne ‚ÄûWohlbefinden‚Äú der Datenbank. <br>  Mal sehen, welche Werkzeuge wir f√ºr solche Experimente haben. <br><br>  Erstens k√∂nnen Sie bestimmte Vorg√§nge mithilfe von Sitzungsvariablen explizit "verbieten".  Praktischerweise m√ºssen sie nicht in der Konfiguration ge√§ndert werden und die Datenbank wird neu geladen. Ihr Wert √§ndert sich nur in der aktuell ge√∂ffneten Sitzung und wirkt sich nicht auf andere Sitzungen aus, sodass Sie direkt mit realen Daten experimentieren k√∂nnen.  Hier ist eine Liste von ihnen mit Standardwerten.  Fast alle Operationen sind enthalten: <br><table><thead><tr><th>  Verwendete Operationen </th><th>  Standardwert </th></tr></thead><tbody><tr><td>  enable_bitmapscan <br>  enable_hashagg <br>  enable_hashjoin <br>  enable_indexscan <br>  enable_indexonlyscan <br>  enable_material <br>  enable_mergejoin <br>  enable_nestloop <br>  enable_parallel_append <br>  enable_seqscan <br>  enable_sort <br>  enable_tidscan <br>  enable_parallel_hash <br>  enable_partition_pruning </td><td>  auf </td></tr><tr><td>  enable_partitionwise_join <br>  enable_partitionwise_aggregate </td><td>  aus </td></tr></tbody></table><br>  Indem wir bestimmte Vorg√§nge verbieten oder zulassen, zwingen wir den Scheduler, andere Pl√§ne auszuw√§hlen, die wir mit demselben EXPLAIN-Befehl sehen k√∂nnen.  Tats√§chlich verbietet das ‚ÄûVerbot‚Äú von Operationen nicht deren Verwendung, sondern erh√∂ht lediglich ihre Kosten erheblich.  In PostgreSQL verursacht jede ‚Äûverbotene‚Äú Operation automatisch Kosten in H√∂he von 10 Milliarden konventionellen Einheiten.  Dar√ºber hinaus kann sich in EXPLAIN das Gesamtgewicht des Plans als unerschwinglich hoch herausstellen, aber vor dem Hintergrund dieser zehn Milliarden ist das Gewicht der verbleibenden Operationen deutlich sichtbar, da es normalerweise in kleinere Auftr√§ge passt. <br><br>  Von besonderem Interesse sind zwei der folgenden Operationen: <br><br><ul><li>  <strong>Hash Join.</strong>  Seine Komplexit√§t ist O (N), aber bei einem Fehler mit einer Prognose in der H√∂he des Ergebnisses k√∂nnen Sie nicht in den Speicher passen und m√ºssen Merge Join mit einem Preis von O (N * log (N)) durchf√ºhren. </li><li>  <strong>Verschachtelte Schleife.</strong>  Seine Komplexit√§t ist O (N <sup>2</sup> ), daher beeinflusst der Fehler in der Gr√∂√üenprognose quadratisch die Geschwindigkeit einer solchen Verbindung. </li></ul><br>  Nehmen wir zum Beispiel einige reelle Zahlen aus Abfragen, deren Optimierung wir in unserem Unternehmen durchgef√ºhrt haben. <br><br>  <strong><u>Plan 1.</u></strong> Bei allen zul√§ssigen Operationen betrugen die Gesamtkosten des optimalsten Plans 274962,09 Einheiten. <br><br>  <strong><u>Plan 2.</u></strong> Mit der "verbotenen" verschachtelten Schleife stiegen die Kosten auf 40000534153,85.  Diese 40 Milliarden, die den gr√∂√üten Teil der Kosten ausmachen, sind trotz des Verbots das Vierfache der verwendeten verschachtelten Schleife.  Und die verbleibenden 534153,85 - dies ist genau die Prognose der Kosten aller anderen Operationen im Plan.  Wie wir sehen, ist es ungef√§hr doppelt so hoch wie die Kosten des optimalen Plans, das hei√üt, es liegt nahe genug daran. <br><br>  <strong><u>Plan 3.</u></strong> Mit dem ‚Äûverbotenen‚Äú Hash-Join betrugen die Kosten 383253,77.  Der Plan wurde wirklich ohne Verwendung der Hash-Join-Operation erstellt, da wir keine Milliarden sehen.  Seine Kosten sind jedoch 30% h√∂her als die des Optimums, was ebenfalls sehr nahe liegt. <br><br>  In Wirklichkeit waren die Ausf√ºhrungszeiten der Abfrage wie folgt: <br><br>  <strong><u>Plan 1</u></strong> (alle Operationen erlaubt) wurde in ~ 9 Minuten abgeschlossen. <br>  <strong><u>Plan 2</u></strong> (mit der "verbotenen" verschachtelten Schleife) wurde in 1,5 Sekunden abgeschlossen. <br>  <strong><u>Plan 3</u></strong> (mit einem "verbotenen" Hash-Join) wurde in ~ 5 Minuten abgeschlossen. <br><br>  Der Grund ist, wie Sie sehen k√∂nnen, die fehlerhafte Vorhersage der Kosten der verschachtelten Schleife.  In der Tat wird beim Vergleich von EXPLAIN mit EXPLAIN ANALYZE ein Fehler mit der Definition dieses ungl√ºcklichen N in einer Zwischenoperation festgestellt.  Anstelle einer vorhergesagten einzelnen Zeile stie√ü die verschachtelte Schleife auf mehrere tausend Zeilen, wodurch sich die Ausf√ºhrungszeit der Abfrage um einige Gr√∂√üenordnungen erh√∂hte. <br><br>  Einsparungen mit dem "verbotenen" Hash-Join sind mit dem Ersetzen von Hashing durch Sortieren und Zusammenf√ºhren verbunden, was in diesem Fall schneller funktionierte als Hash-Join.  Beachten Sie, dass dieser Plan 2 in Wirklichkeit fast zweimal schneller ist als der "optimale" Plan 1. Obwohl vorhergesagt wurde, dass er langsamer sein wird. <br><br>  Wenn Ihre Anforderung pl√∂tzlich (nach einem DB-Upgrade oder nur von selbst) viel l√§nger als zuvor ausgef√ºhrt wird, versuchen Sie in der Praxis zun√§chst, entweder Hash Join oder Nested Loop zu verweigern, und pr√ºfen Sie, wie sich dies auf die Geschwindigkeit der Abfrage auswirkt.  In einem erfolgreichen Fall k√∂nnen Sie zumindest einen neuen nicht optimalen Plan verbieten und zum vorherigen schnellen zur√ºckkehren. <br><br>  Dazu m√ºssen Sie die PostgreSQL-Konfigurationsdateien bei einem Datenbankneustart nicht √§ndern. In jeder Konsole ist es ganz einfach, den Wert der gew√ºnschten Variablen f√ºr eine ge√∂ffnete Sitzung aus der Datenbank zu √§ndern.  Die verbleibenden Sitzungen sind nicht betroffen. Die Konfiguration wird nur f√ºr Ihre aktuelle Sitzung ge√§ndert.  Zum Beispiel so: <br><br><pre> <code class="plaintext hljs">SET enable_hashjoin='on'; SET enable_nestloop='off'; SELECT ‚Ä¶ FROM ‚Ä¶ (    )</code> </pre><br>  Die zweite M√∂glichkeit, die Wahl des Plans zu beeinflussen, besteht darin, die Gewichte von Operationen auf niedriger Ebene zu √§ndern.  Hier gibt es kein universelles Rezept, aber wenn Sie beispielsweise eine Datenbank mit einem "aufgew√§rmten" Cache haben und die gesamten Daten im Speicher gespeichert sind, unterscheiden sich die Kosten f√ºr das sequentielle Laden von Seiten wahrscheinlich nicht von den Kosten f√ºr das Laden einer zuf√§lligen Seite.  W√§hrend in der Standardkonfiguration zuf√§llig 4-mal teurer ist als sequentiell. <br><br>  In einem anderen Beispiel betragen die bedingten Kosten f√ºr die parallele Verarbeitung standardm√§√üig 1000, w√§hrend die Kosten f√ºr das Laden einer Seite 1,0 betragen.  Es ist sinnvoll, zun√§chst jeweils nur einen der Parameter zu √§ndern, um festzustellen, ob sich dies auf die Wahl des Plans auswirkt.  Am einfachsten ist es, den Parameter auf 0 oder einen hohen Wert (1 Million) zu setzen. <br><br>  Beachten Sie jedoch, dass Sie durch eine Verbesserung der Leistung in einer Anforderung die Leistung in einer anderen beeintr√§chtigen k√∂nnen.  Im Allgemeinen gibt es ein weites Feld f√ºr Experimente.  Es ist besser, sie einzeln zu √§ndern. <br><br><h4>  Alternative Behandlungsm√∂glichkeiten </h4><br>  Eine Geschichte √ºber einen Scheduler w√§re unvollst√§ndig, ohne mindestens zwei PostgreSQL-Erweiterungen zu erw√§hnen. <br><br>  Das erste ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SR_PLAN</a> , um den berechneten Plan zu speichern und seine weitere Verwendung zu erzwingen.  Dies tr√§gt dazu bei, das Datenbankverhalten in Bezug auf die Planauswahl vorhersehbarer zu machen. <br><br>  Das zweite ist das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Adaptive Query Optimizer</a> , das Feedback an den Scheduler von der Echtzeitausf√ºhrung der Abfrage implementiert, dh der Scheduler misst die tats√§chlichen Ergebnisse der ausgef√ºhrten Abfrage und passt seine Pl√§ne in Zukunft in diesem Sinne an.  Die Datenbank ist daher f√ºr bestimmte Daten und Abfragen "selbstoptimierend". <br><br><h4>  Was macht die Datenbank sonst noch, wenn sie langsamer wird? </h4><br>  Nachdem wir die Abfrageplanung mehr oder weniger geregelt haben, werden wir sehen, was sowohl in der Datenbank selbst als auch in den Anwendungen, die sie verwenden, um die maximale Leistung zu erzielen, noch verbessert werden kann. <br><br>  Angenommen, der Abfrageplan ist bereits optimal.  Wenn wir die offensichtlichsten Probleme ausschlie√üen (wenig Speicher oder eine langsame Festplatte / ein langsames Netzwerk), fallen immer noch Kosten f√ºr die Berechnung der Hashes an.  Es gibt wahrscheinlich gro√üe M√∂glichkeiten f√ºr zuk√ºnftige Verbesserungen von PostgreSQL (unter Verwendung der GPU oder sogar der SSE2 / SSE3 / AVX-Anweisungen der CPU), aber dies wurde bisher nicht durchgef√ºhrt und Hash-Berechnungen nutzen fast nie die Hardwarefunktionen der Hardware.  Sie k√∂nnen ein wenig in dieser Datenbank helfen. <br><br>  Wenn Sie bemerken, werden Indizes in PostgreSQL standardm√§√üig als B-Tree erstellt.  Ihr Nutzen ist, dass sie sehr vielseitig sind.  Ein solcher Index kann sowohl mit Gleichheitsbedingungen als auch mit Vergleichsbedingungen (mehr oder weniger) verwendet werden.  Das Finden eines Elements in einem solchen Index ist ein logarithmischer Aufwand.  Wenn Ihre Abfrage jedoch nur eine Gleichheitsbedingung enth√§lt, k√∂nnen Indizes auch als Hash-Index erstellt werden, dessen Kosten konstant sind. <br><br>  Au√üerdem k√∂nnen Sie weiterhin versuchen, die Anforderung so zu √§ndern, dass ihre parallele Ausf√ºhrung verwendet wird.  Um genau zu verstehen, wie man es umschreibt, ist es am besten, sich mit der Liste der F√§lle vertraut zu machen, in denen Parallelit√§t vom Planer automatisch verboten wird, und solche Situationen zu vermeiden.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Handbuch</a> zu diesem Thema beschreibt kurz alle Situationen, daher ist es nicht sinnvoll, sie hier zu wiederholen. <br><br>  Was tun, wenn die Anfrage immer noch nicht gut parallel ist?  Es ist sehr traurig zu sehen, wie in Ihrer leistungsstarken Multi-Core-Datenbank, in der Sie der einzige Client sind, ein Kern zu 100% belegt ist und alle anderen Kernel ihn nur betrachten.  In diesem Fall m√ºssen Sie der Datenbank von der Seite der Anwendung aus helfen.  Da jede Sitzung ihren eigenen Kern hat, k√∂nnen Sie mehrere davon √∂ffnen und die allgemeine Abfrage in Teile aufteilen, k√ºrzere und schnellere Auswahlen treffen und sie zu einem gemeinsamen Ergebnis kombinieren, das bereits in der Anwendung vorhanden ist.  Dadurch werden die maximal verf√ºgbaren CPU-Ressourcen in der PostgreSQL-Datenbank belegt. <br><br>  Abschlie√üend m√∂chte ich darauf hinweisen, dass die oben genannten Diagnose- und Optimierungsoptionen nur die Spitze des Eisbergs sind. Sie sind jedoch recht einfach zu verwenden und k√∂nnen dazu beitragen, das Problem schnell direkt anhand der Betriebsdaten zu identifizieren, ohne die Konfiguration zu beeintr√§chtigen oder den Betrieb anderer Anwendungen zu st√∂ren. <br><br>  Erfolgreiche Anfragen mit genauen und kurzen Pl√§nen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443276/">https://habr.com/ru/post/de443276/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443266/index.html">Wie wir dazu beigetragen haben, die Arbeit des Rechnungswesens in einem gro√üen Energieunternehmen zu ver√§ndern</a></li>
<li><a href="../de443268/index.html">Post mortem: Folgen Sie der Middleware oder wie wir Kommentare gebrochen haben</a></li>
<li><a href="../de443270/index.html">Die Ank√ºndigung des Sony Xperia 1: ein neues Flaggschiff-Konzept</a></li>
<li><a href="../de443272/index.html">Der Mythos der Nichrom-Sch√§dlinge</a></li>
<li><a href="../de443274/index.html">Zusammenstellung der Nachrichten aus der Spielebranche vom 8. M√§rz bis Sonntag</a></li>
<li><a href="../de443278/index.html">Coinbase Crypto-Exchange verliert Benutzer aufgrund des Kaufs eines Startups f√ºr die Entwickler von Spyware vom Hacking-Team</a></li>
<li><a href="../de443280/index.html">Die Geschichte, wie ich ein 120-Zoll-Heimkino aus Rohren, Seilen, einem Paravent und schwarzem Samt zusammengebaut habe</a></li>
<li><a href="../de443282/index.html">Was sollen wir eine Blockchain bauen?</a></li>
<li><a href="../de443284/index.html">Indizes in PostgreSQL - 4 (Btree)</a></li>
<li><a href="../de443286/index.html">TDMS Fairway. Autofill-Mechanismus f√ºr die Hauptbeschriftungen auf den Zeichnungen und Details der Dokumente</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>