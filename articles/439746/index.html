<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì° üåá üëáüèª Comprender las promesas de JavaScript ‚õ±Ô∏è üëÉ üë©üèΩ‚Äçü§ù‚Äçüë®üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Buen dia, Habr! Les presento la traducci√≥n del art√≠culo "Comprender las promesas en JavaScript" de Sukhjinder Arora. 



 Del autor de la traducci√≥n: ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comprender las promesas de JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439746/">  Buen dia, Habr!  Les presento la traducci√≥n del art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Comprender las promesas en JavaScript"</a> de Sukhjinder Arora. <br><br><img src="https://habrastorage.org/webt/ox/6m/oa/ox6moan9gwhmc2oouqbhyfzumtm.png"><br><a name="habracut"></a><br>  <i>Del autor de la traducci√≥n: Adem√°s del propio autor, espero que el art√≠culo te haya sido √∫til.</i>  <i>Por favor, si ella realmente te ayud√≥ a aprender algo nuevo por ti mismo, ¬°no seas demasiado vago para ir al art√≠culo original y agradecer al autor!</i>  <i>Estar√© encantado de tus comentarios!</i> <i><br><br></i>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Enlace a la traducci√≥n del art√≠culo sobre JavaScript asincr√≥nico del mismo autor</a> .</i> <br><br>  JavaScript es un lenguaje de programaci√≥n de un solo subproceso, lo que significa que se puede hacer una cosa a la vez.  Antes de ES6, utilizamos devoluciones de llamada para administrar tareas asincr√≥nicas, como la solicitud de red. <br><br>  Usando promesas, podemos evitar el "infierno de devoluci√≥n de llamada" y hacer que nuestro c√≥digo sea m√°s limpio, m√°s legible y m√°s f√°cil de entender. <br><br>  Supongamos que queremos obtener algunos datos del servidor de forma asincr√≥nica, utilizando devoluciones de llamada har√≠amos algo como esto: <br><br><pre><code class="javascript hljs">getData(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x); getMoreData(x, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">y</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(y); getSomeMoreData(y, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">z</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(z); }); }); });</code> </pre> <br>  Aqu√≠, solicito algunos datos del servidor utilizando la funci√≥n <i>getData ()</i> , que recibe datos dentro de la funci√≥n de devoluci√≥n de llamada.  Dentro de la funci√≥n de devoluci√≥n de llamada, solicito datos adicionales llamando a la funci√≥n <i>getMoreData ()</i> , pasando los datos anteriores como argumento, y as√≠ sucesivamente. <br><br>  Esto es lo que llamamos "infierno de devoluci√≥n de llamada", donde cada devoluci√≥n de llamada est√° anidada dentro de la otra, y cada devoluci√≥n de llamada interna depende de su padre. <br><br>  Podemos reescribir el fragmento anterior usando promesas: <br><br><pre> <code class="javascript hljs">getData() .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getMoreData(x); }) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">y</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getSomeMoreData(y); }) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">z</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(z); });</code> </pre> <br>  Puede ver lo que se ha vuelto m√°s legible que con el primer ejemplo de devoluci√≥n de llamada. <br><br><h2>  ¬øQu√© son las promesas? </h2><br>  Una Promesa (Promesa) es un objeto que contiene el valor futuro de una operaci√≥n asincr√≥nica.  Por ejemplo, si solicita algunos datos del servidor, Promis nos promete recibir estos datos, que podemos usar en el futuro. <br><br>  Antes de sumergirnos en todas estas cosas t√©cnicas, veamos la terminolog√≠a de las promesas. <br><br><h3>  Estados de promesa </h3><br>  Una promesa en JavaScript, como una promesa en la vida real, tiene 3 estados.  Esto puede ser 1) no resuelto (pendiente), 2) resuelto / resuelto (completado) o 3) rechazado / rechazado. <br><br><img src="https://habrastorage.org/webt/pk/hr/zz/pkhrzzgtdsgqvtptwn26gmtbjhk.png"><br><br>  <b>Sin resolver o pendiente</b> : Promis espera si el resultado no est√° listo.  Es decir, espera la finalizaci√≥n de algo (por ejemplo, la finalizaci√≥n de una operaci√≥n asincr√≥nica). <br>  <b>Resuelto o completado</b> : Promis resuelto si el resultado est√° disponible.  Es decir, algo complet√≥ su ejecuci√≥n (por ejemplo, una operaci√≥n asincr√≥nica) y todo sali√≥ bien. <br>  <b>Rechazado</b> : Promis rechazado si se produjo un error durante la ejecuci√≥n. <br><br>  Ahora que sabemos qu√© es Promis y su terminolog√≠a, volvamos a la parte pr√°ctica de las promesas. <br><br><h3>  Crear promis </h3><br>  En la mayor√≠a de los casos, simplemente usar√° promesas, no las crear√°, pero a√∫n es importante saber c√≥mo se crean. <br><br>  Sintaxis: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { ... });</code> </pre> <br>  Creamos una nueva promesa usando el constructor Promises, se necesita un argumento, una devoluci√≥n de llamada, tambi√©n conocida como una funci√≥n ejecutiva, que toma 2 devoluciones de llamada, <i>resolver</i> y <i>rechazar</i> . <br><br>  La funci√≥n ejecutiva se realiza inmediatamente despu√©s de la creaci√≥n de la promesa.  Se hace una promesa al llamar a <i>resolve ()</i> , y se rechaza por <i>rechazar ()</i> .  Por ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(allWentWell) { resolve(<span class="hljs-string"><span class="hljs-string">'  !'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'-   '</span></span>); } });</code> </pre> <br>  <i>resolver ()</i> y <i>rechazar ()</i> toman un argumento, que puede ser una cadena, un n√∫mero, una expresi√≥n l√≥gica, una matriz o un objeto. <br><br>  Echemos un vistazo a otro ejemplo para comprender completamente c√≥mo se crean las promesas. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> randomNumber = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random(); setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(randomNumber &lt; <span class="hljs-number"><span class="hljs-number">.6</span></span>) { resolve(<span class="hljs-string"><span class="hljs-string">'  !'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'-   '</span></span>); } }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); });</code> </pre> <br>  Aqu√≠ cre√© una nueva Promesa usando el constructor Promis.  Una promesa se ejecuta o rechaza 2 segundos despu√©s de su creaci√≥n.  Se ejecuta una promesa si <i>randomNumber es</i> menor que .6 y se rechaza en otros casos. <br><br>  Cuando se ha creado una promesa, estar√° pendiente y su valor ser√° <i>indefinido</i> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cs/wr/c2/cswrc2jdrixhaguff2w9oijiyf4.png"></div><br>  Despu√©s de 2 segundos, el temporizador finaliza, la promesa se ejecuta aleatoriamente o se rechaza, y su valor ser√° el que se pasa a la funci√≥n de <i>resoluci√≥n</i> o <i>rechazo</i> .  A continuaci√≥n se muestra un ejemplo de dos casos: <br><br>  Terminaci√≥n exitosa: <br><br><img src="https://habrastorage.org/webt/eq/3y/ss/eq3ysskatvuvjnvpoaz9k7zdmvi.png"><br><br>  Rechazo de promesa: <br><br><img src="https://habrastorage.org/webt/qn/7v/ee/qn7vee1ebi19qgo4zzv72tgpfjg.png"><br><br>  <b>Nota:</b> Promise se puede ejecutar o rechazar solo una vez.  Las llamadas adicionales a <i>resolver ()</i> o <i>rechazar ()</i> no afectar√°n el estado de la promesa de ninguna manera.  Un ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise resolved'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   reject('Promise rejected'); //       });</span></span></code> </pre> <br>  Como se llam√≥ primero a <i>resolve ()</i> , la promesa ahora tiene el estado "completado".  La llamada posterior a <i>rechazar ()</i> no afectar√° el estado de la promesa de ninguna manera. <br><br><h3>  Usando Promis </h3><br>  Ahora sabemos c√≥mo crear promesas, ahora veamos c√≥mo aplicar la promesa ya creada.  Usamos promesas usando los m√©todos <i>then ()</i> y <i>catch ()</i> . <br><br>  Por ejemplo, consultar datos de una API usando <i>fetch</i> , que devuelve una promesa. <br><br>  <i>.then ()</i> <b>sintaxis:</b> <i>promise.then (successCallback, failureCallback)</i> <br><br>  <i>successCallback</i> se llama si la promesa se ha ejecutado con √©xito.  Se necesita un argumento, que es el valor pasado para <i>resolver ()</i> . <br><br>  <i>failCallback</i> se llama si la promesa ha sido rechazada.  Se necesita un argumento, que es el valor dado a <i>rechazar ()</i> . <br><br>  Un ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> randomNumber = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(randomNumber &lt; <span class="hljs-number"><span class="hljs-number">.7</span></span>) { resolve(<span class="hljs-string"><span class="hljs-string">'  !'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'-   '</span></span>)); } }); promise.then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); <span class="hljs-comment"><span class="hljs-comment">//  '  !' }, (error) =&gt; { console.log(error); //   } );</span></span></code> </pre> <br>  Si se ejecut√≥ la promesa, se <i>llama</i> a <i>successCallback</i> con el valor pasado para <i>resolver ()</i> .  Y si la promesa fue rechazada, se <i>llama</i> a <i>failureCallback</i> con el valor pasado a rechazar (). <br><br>  <i>Sintaxis .catch ()</i> <b>:</b> <i>promise.catch (failureCallback)</i> <br><br>  Usamos <i>catch ()</i> para manejar errores.  Esto es m√°s legible que el manejo de errores dentro de <i>failureCallback</i> dentro de la devoluci√≥n de llamada del m√©todo <i>then ()</i> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'-   '</span></span>)); }); promise .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); }) .catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error); <span class="hljs-comment"><span class="hljs-comment">//   });</span></span></code> </pre> <br><h3>  Cadena de la promesa </h3><br>  Los m√©todos <i>then ()</i> y <i>catch ()</i> tambi√©n pueden devolver una nueva promesa, que puede ser procesada por una cadena de otro then () al final del m√©todo anterior then (). <br><br>  Usamos una cadena de promesas cuando queremos completar una secuencia de promesas. <br><br>  Por ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 '</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise2 '</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Promise3 '</span></span>); }); promise1 .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); <span class="hljs-comment"><span class="hljs-comment">// Promise1  return promise2; }) .then((data) =&gt; { console.log(data); // Promise2  return promise3; }) .then((data) =&gt; { console.log(data); }) .catch((error) =&gt; { console.log(error); // Promise3  });</span></span></code> </pre> <br><h4>  Entonces, ¬øqu√© est√° pasando aqu√≠? </h4><br>  Cuando <i>se</i> cumple la <i>promesa1</i> , se llama al m√©todo <i>then (),</i> que devuelve la promesa2. <br>  Luego, cuando se <i>cumple la</i> <i>promesa2, se</i> vuelve a <i>llamar a</i> <i>()</i> y se devuelve la <i>promesa3</i> . <br><br>  Como se rechaza la promesa3, en lugar de la siguiente <i>()</i> , se llama a <i>catch ()</i> , que maneja el rechazo de la <i>promesa3</i> . <br><br>  <b>Nota:</b> Como regla, un m√©todo <i>catch ()</i> es suficiente para manejar el rechazo de cualquiera de las promesas en la cadena, si este m√©todo est√° al final. <br><br><h4>  Error com√∫n </h4><br>  Muchos reci√©n llegados cometen un error al invertir algunas promesas dentro de otras.  Por ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 '</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise2 '</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Promise3 '</span></span>); }); promise1.then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); <span class="hljs-comment"><span class="hljs-comment">// Promise1  promise2.then((data) =&gt; { console.log(data); // Promise2  promise3.then((data) =&gt; { console.log(data); }).catch((error) =&gt; { console.log(error); // Promise3  }); }).catch((error) =&gt; { console.log(error); }) }).catch((error) =&gt; { console.log(error); });</span></span></code> </pre> <br>  Aunque esto funcionar√° bien, se considera un mal estilo y hace que el c√≥digo sea menos legible.  Si tiene una secuencia de promesas que ejecutar, ser√° mejor ponerlas una tras otra que poner una dentro de la otra. <br><br><h3>  Promise.all () </h3><br>  Este m√©todo toma una serie de promesas y devuelve una nueva promesa que se ejecutar√° cuando todas las promesas dentro de la matriz se ejecuten o rechacen tan pronto como se encuentre una promesa rechazada.  Por ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise2 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">1500</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([promise1, promise2]) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data[<span class="hljs-number"><span class="hljs-number">0</span></span>], data[<span class="hljs-number"><span class="hljs-number">1</span></span>])) .catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error));</code> </pre> <br>  Aqu√≠, el argumento dentro de <i>then ()</i> es una matriz que contiene los valores de las promesas en el mismo orden en que se pasaron a <i>Promise.all ()</i> . (Solo si se ejecutan todas las promesas) <br><br>  La promesa se rechaza con la causa del rechazo de la primera promesa en la matriz transferida.  Por ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Promise2 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">1500</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([promise1, promise2]) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data[<span class="hljs-number"><span class="hljs-number">0</span></span>], data[<span class="hljs-number"><span class="hljs-number">1</span></span>])) .catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error)); <span class="hljs-comment"><span class="hljs-comment">// Promise2 </span></span></code> </pre> <br>  Aqu√≠ tenemos dos promesas, donde una se ejecuta despu√©s de 2 segundos y la otra se desv√≠a despu√©s de 1.5 segundos.  Tan pronto como se rechaza la segunda promesa, la <i>promesa</i> devuelta desde <i>Promise.all ()</i> se rechaza sin esperar la primera. <br><br>  Este m√©todo puede ser √∫til cuando tiene m√°s de una promesa y desea saber cu√°ndo se han completado todas las promesas.  Por ejemplo, si solicita datos de una API de terceros y desea hacer algo con estos datos solo cuando todas las solicitudes sean exitosas. <br><br>  Como resultado, tenemos <i>Promise.all ()</i> , que espera la ejecuci√≥n exitosa de todas las promesas, o completa su ejecuci√≥n cuando detecta la primera falla en el conjunto de promesas. <br><br><h3>  Promise.race () </h3><br>  Este m√©todo acepta una serie de promesas y devuelve una nueva promesa que se ejecutar√° tan pronto como se cumpla o rechace la promesa cumplida en la matriz si la promesa rechazada ocurre antes.  Por ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Promise2 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">1500</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.race([promise1, promise2]) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data)) <span class="hljs-comment"><span class="hljs-comment">// Promise1  .catch((error) =&gt; console.log(error));</span></span></code> </pre> <br>  Aqu√≠ tenemos dos promesas, donde una se ejecuta despu√©s de 1 segundo y la otra se desv√≠a despu√©s de 1.5 segundos.  Tan pronto como se cumpla la primera promesa, la promesa devuelta de Promise.race () tendr√° el estado cumplido sin esperar el estado de la segunda promesa. <br><br>  Aqu√≠, los <i>datos</i> que se pasan a <i>then ()</i> son el valor de la primera promesa ejecutada. <br><br>  Como resultado, <i>Promise.race ()</i> espera la primera promesa y toma su estado como el estado de la promesa devuelta. <br><br>  <i>Comentario del autor de la traducci√≥n: De ah√≠ el nombre mismo.</i>  <i>Raza - Raza</i> <br><br><h2>  Conclusi√≥n </h2><br>  Aprendimos qu√© son las promesas y qu√© comen en JavaScript.  Las promesas consisten en dos partes 1) Crear una promesa y 2) Usar una promesa.  La mayor√≠a de las veces usar√° promesas en lugar de crearlas, pero es importante saber c√≥mo se crean. <br><br>  Eso es todo, ¬°espero que este art√≠culo te haya sido √∫til! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/439746/">https://habr.com/ru/post/439746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../439734/index.html">Implementar Kubernetes en el escritorio en minutos con MicroK8s</a></li>
<li><a href="../439736/index.html">Conexi√≥n IPSec VPN entre MikroTik y Kerio Control</a></li>
<li><a href="../439738/index.html">En busca del bot√≥n "Hacer bien". Zyxel en la red de peque√±as y medianas empresas</a></li>
<li><a href="../439742/index.html">Admisi√≥n al programa Master JetBrains en la Universidad ITMO</a></li>
<li><a href="../439744/index.html">Investigadores del MIT dise√±aron "rectenna" que convierte las se√±ales de Wi-Fi en electricidad</a></li>
<li><a href="../439748/index.html">El resumen de materiales interesantes para el desarrollador m√≥vil # 285 (del 4 al 10 de febrero)</a></li>
<li><a href="../439750/index.html">Aprenda la gesti√≥n de productos, ¬ød√≥nde?</a></li>
<li><a href="../439752/index.html">IRM multin√∫cleo</a></li>
<li><a href="../439754/index.html">Google comenzar√° a desarrollar relojes inteligentes</a></li>
<li><a href="../439756/index.html">¬øPor qu√© necesito un generador termoac√∫stico?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>