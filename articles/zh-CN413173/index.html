<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧜🏽 👶🏽 📇 使用window.onerror监视JavaScript错误 👩🏿‍🤝‍👩🏽 👦 🛌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我们今天发布的翻译材料专用于使用window.onerror处理JS错误。 这是一个特殊的浏览器事件，当发生未捕获的错误时将触发该事件。 在这里，我们将讨论如何使用onerror事件onerror捕获错误，以及如何将有关错误的信息发送到网站开发者的服务器。 此处理程序可用作您自己的系统的基础，该系统...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用window.onerror监视JavaScript错误</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/413173/">我们今天发布的翻译材料专用于使用<code>window.onerror</code>处理JS错误。 这是一个特殊的浏览器事件，当发生未捕获的错误时将触发该事件。 在这里，我们将讨论如何使用<code>onerror</code>事件<code>onerror</code>捕获错误，以及如何将有关错误的信息发送到网站开发者的服务器。 此处理程序可用作您自己的系统的基础，该系统用于收集和分析错误信息。 此外，它是面向错误的库（例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">raven-js）中</a>使用的最重要的机制之一。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/11f/1b9/ddc/11f1b9ddcfdd735951758c0f56d57a03.jpg" alt="图片"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">监听window.onerror事件</font> </h2><br> 您可以通过为<code>window.onerror</code>分配<code>window.onerror</code>充当错误处理程序<code>window.onerror</code>函数来监听<code>onerror</code>事件： <br><br><pre> <code class="hljs lua">window.onerror = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(msg, url, lineNo, columnNo, error)</span></span></span></span> { // ...   ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br> 发生错误时将调用此函数；以下参数将传递给该函数： <br><br><ul><li>  <code>msg</code>错误消息。 例如， <code>Uncaught ReferenceError: foo is not defined</code> 。 </li><li>  <code>url</code>发生错误的脚本或文档的地址。 例如<code>/dist/app.js</code> 。 </li><li>  <code>lineNo</code>发生错误的行号（如果支持）。 </li><li>  <code>columnNo</code>行的列号（如果支持）。 </li><li>  <code>error</code>对象（如果支持）。 </li></ul><br> 前四个参数告诉开发人员哪个脚本，哪个行以及该行的哪一列发生了错误。 最后一个参数（类型为<code>Error</code>的对象）可能是所有参数中最重要的。 让我们来谈谈。 <br><br><h2>  <font color="#3AC1EF">错误对象和Error.prototype.stack属性</font> </h2><br> 乍一看， <code>Error</code>对象没什么特别的。 它包含三个非常标准的属性<code>lineNumber</code> ， <code>fileName</code>和<code>lineNumber</code> 。 给定传递给<code>window.onerror</code>事件处理程序的信息，此数据可以被认为是冗余的。 <br><br> 在这种情况下，实际值是非标准属性<code>Error.prototype.stack</code> 。 此属性提供对调用堆栈（错误堆栈）的访问权限，使您可以找出错误发生时程序中正在发生的情况，该函数调用是在错误出现之前发生的。 调用堆栈跟踪可能是调试过程的关键部分。 而且，尽管<code>stack</code>属性不是标准属性，但在所有现代浏览器中都可用。 <br><br> 这就是错误对象的<code>stack</code>属性在Chrome 46中的样子。 <br><br><pre> <code class="hljs css">"<span class="hljs-selector-tag"><span class="hljs-selector-tag">Error</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">foobar</span></span>\<span class="hljs-selector-tag"><span class="hljs-selector-tag">n</span></span>    <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">new</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">bar</span></span> (&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">anonymous</span></span>&gt;<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:241</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:11)</span></span>\<span class="hljs-selector-tag"><span class="hljs-selector-tag">n</span></span>    <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">foo</span></span> (&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">anonymous</span></span>&gt;<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:245</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:5)</span></span>\<span class="hljs-selector-tag"><span class="hljs-selector-tag">n</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">anonymous</span></span>&gt;<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:250</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:5</span></span>\<span class="hljs-selector-tag"><span class="hljs-selector-tag">n</span></span>    <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">anonymous</span></span>&gt;<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:251</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:3</span></span>\<span class="hljs-selector-tag"><span class="hljs-selector-tag">n</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">anonymous</span></span>&gt;<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:267</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:4</span></span>\<span class="hljs-selector-tag"><span class="hljs-selector-tag">n</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">callFunction</span></span> (&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">anonymous</span></span>&gt;<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:229</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:33)</span></span>\<span class="hljs-selector-tag"><span class="hljs-selector-tag">n</span></span>    <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">anonymous</span></span>&gt;<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:239</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:23</span></span>\<span class="hljs-selector-tag"><span class="hljs-selector-tag">n</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">anonymous</span></span>&gt;<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:240</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:3</span></span>\<span class="hljs-selector-tag"><span class="hljs-selector-tag">n</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Object</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.InjectedScript</span></span>.\_<span class="hljs-selector-tag"><span class="hljs-selector-tag">evaluateOn</span></span> (&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">anonymous</span></span>&gt;<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:875</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:140)</span></span>\<span class="hljs-selector-tag"><span class="hljs-selector-tag">n</span></span>    <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Object</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.InjectedScript</span></span>.\_<span class="hljs-selector-tag"><span class="hljs-selector-tag">evaluateAndWrap</span></span> (&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">anonymous</span></span>&gt;<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:808</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:34)"</span></span></code> </pre> <br> 在我们面前的是未格式化的字符串。 当此属性的内容以这种形式显示时，使用它很不方便。 这是格式化后的外观。 <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Error</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">foobar</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">new</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">bar</span></span> (&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">anonymous</span></span>&gt;<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:241</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:11)</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">foo</span></span> (&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">anonymous</span></span>&gt;<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:245</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:5)</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">callFunction</span></span> (&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">anonymous</span></span>&gt;<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:229</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:33)</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Object</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.InjectedScript</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">._evaluateOn</span></span> (&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">anonymous</span></span>&gt;<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:875</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:140)</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Object</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.InjectedScript</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">._evaluateAndWrap</span></span> (&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">anonymous</span></span>&gt;<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:808</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:34)</span></span></code> </pre> <br> 现在，在格式化之后，错误堆栈看起来更加清晰，可以立即清楚为什么调试错误时<code>stack</code>属性非常重要。 <br><br> 但是，这里的一切进展都不顺利。  <code>stack</code>属性未标准化；在不同的浏览器中实现不同。 例如，这里是错误堆栈在Internet Explorer 11中的样子。 <br><br><pre> <code class="hljs powershell">Error: foobar at bar (Unknown script code:<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">5</span></span>) at foo (Unknown script code:<span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">5</span></span>) at Anonymous <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Unknown script code:11:5)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">at</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Anonymous</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Unknown script code:10:2)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">at</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Anonymous</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Unknown script code:1:73)</span></span></span></span></code> </pre> <br> 与前面的示例相比，您可以注意到，这里不仅使用了不同的格式来表示堆栈帧，而且每个帧的数据更少。 例如，Chrome可以识别使用<code>new</code>关键字的实例，并提供有关其他事件（尤其是有关函数调用<code>_evaluateOn</code>和<code>_evaluateAndWrap</code> ）的详细信息。 同时，在这里，我们仅比较了IE和Chrome提供的功能。 其他浏览器使用自己的方法来显示有关堆栈的数据并选择此数据中包含的信息。 <br><br> 为了使所有这些看起来统一，可以使用第三方工具。 例如，raven-js为此使用了TraceKit。  Stacktrace.js和其他一些项目实现了相同的目的。 <br><br><h2>  <font color="#3AC1EF">各种浏览器支持window.onerror的功能</font> </h2><br>  <code>windows.onerror</code>事件在浏览器中已经存在了一段时间。 特别是，它可以在IE6和Firefox 2中找到。这里的问题是所有浏览器都以不同的方式实现<code>windows.onerror</code> 。 例如，这涉及传递给此事件的处理程序的参数的数量和结构。 <br><br> 下表<code>onerror</code>主要浏览器中传递给<code>onerror</code>处理程序<code>onerror</code>参数。 <br><table><tbody><tr><td> 浏览器 <br></td><td> 讯息 <br></td><td> 网址 <br></td><td> 行号 <br></td><td> 颜色 <br></td><td>  errorObj <br></td></tr><tr><td> 火狐浏览器 <br></td><td> 有 <br></td><td> 有 <br></td><td> 有 <br></td><td> 有 <br></td><td> 有 <br></td></tr><tr><td> 镀铬 <br></td><td> 有 <br></td><td> 有 <br></td><td> 有 <br></td><td> 有 <br></td><td> 有 <br></td></tr><tr><td> 边缘 <br></td><td> 有 <br></td><td> 有 <br></td><td> 有 <br></td><td> 有 <br></td><td> 有 <br></td></tr><tr><td>  IE 11 <br></td><td> 有 <br></td><td> 有 <br></td><td> 有 <br></td><td> 有 <br></td><td> 有 <br></td></tr><tr><td>  IE10 <br></td><td> 有 <br></td><td> 有 <br></td><td> 有 <br></td><td> 有 <br></td><td> 没有啦 <br></td></tr><tr><td>  IE 9.8 <br></td><td> 有 <br></td><td> 有 <br></td><td> 有 <br></td><td> 没有啦 <br></td><td> 没有啦 <br></td></tr><tr><td>  Safari 10及更高版本 <br></td><td> 有 <br></td><td> 有 <br></td><td> 有 <br></td><td> 有 <br></td><td> 有 <br></td></tr><tr><td>  Safari 9 <br></td><td> 有 <br></td><td> 有 <br></td><td> 有 <br></td><td> 有 <br></td><td> 没有啦 <br></td></tr><tr><td>  Android浏览器4.4 <br></td><td> 有 <br></td><td> 有 <br></td><td> 有 <br></td><td> 有 <br></td><td> 没有啦 <br></td></tr></tbody></table><br> 也许不足为奇，Internet Explorer 8、9和10对<code>onerror</code>支持有限。 但是，在Safari浏览器中对错误对象的支持仅出现在2016年发布的第10版中似乎并不寻常。 此外，还有一些使用标准Android浏览器的旧式移动设备，该浏览器也不支持错误对象。 在现代版本的Android中，此浏览器已由Chrome Mobile取代。 <br><br> 如果没有错误对象可供使用，那么就没有关于堆栈跟踪的数据。 这意味着不支持错误对象的浏览器不会在使用<code>onerror</code>处理程序的标准脚本中提供堆栈信息。 正如我们所说的，这一点非常重要。 <br><br><h2>  <font color="#3AC1EF">使用try / catch构造针对window.onerror的Polyfill开发</font> </h2><br> 为了在不支持将<code>onerror</code>对象传递给<code>onerror</code>处理程序的浏览器中获取有关堆栈的信息，可以使用以下技巧。 您可以将代码包装在<code>try/catch</code>构造中，然后自己捕获错误。 在所有现代浏览器中，产生的错误对象将包含我们需要的<code>stack</code>属性。 <br> 看一下<code>invoke()</code>辅助方法代码，该代码调用对象的给定方法，并向其传递参数数组。 <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(obj, method, args)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj[<span class="hljs-type"><span class="hljs-type">method</span></span>].apply(this,args); }</code> </pre> <br> 这是使用方法。 <br><br><pre> <code class="hljs lisp">invoke(<span class="hljs-name"><span class="hljs-name">Math</span></span>, 'max', [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>])<span class="hljs-comment"><span class="hljs-comment">; //  2</span></span></code> </pre> <br> 这是相同的<code>invoke()</code> ，但是现在方法调用包装在<code>try/catch</code> ，它使您可以捕获可能的错误。 <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(obj, method, args)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj[<span class="hljs-type"><span class="hljs-type">method</span></span>].apply(this,args); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(e) {   captureError(e);//      <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> e;//      } } invoke(Math,<span class="hljs-string"><span class="hljs-string">'highest'</span></span>,[<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>]); //  ,     Math.highest</code> </pre> <br> 当然，将此类结构手动添加到可能需要它们的所有位置非常昂贵。 通过创建通用帮助函数可以简化此任务。 <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrapErrors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn)</span></span></span></span> { //      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!fn.__wrapped__) {   fn.__wrapped__ = function() {     <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>{       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn.apply(this,arguments);     }<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(e){       captureError(e);//          <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> e;//          }   }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn.__wrapped__; } var invoke = wrapErrors(function(obj, method, args) { returnobj[<span class="hljs-type"><span class="hljs-type">method</span></span>].apply(this,args); }); invoke(Math,<span class="hljs-string"><span class="hljs-string">'highest'</span></span>,[<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>]);//,   Math.highest</code> </pre> <br> 由于JavaScript使用单线程代码执行模型，因此该包装器仅应与新堆栈开始时的那些函数调用一起使用。 无需将所有函数调用包装在其中。 <br><br> 结果，该功能需要在以下位置使用： <br><br><ul><li> 应用程序的启动位置（例如，使用jQuery时，在<code>$(document).ready</code>函数中） </li><li> 在事件处理程序中（例如，在<code>addEventListener</code>或<code>$.fn.click</code>格式的<code>$.fn.click</code> ） </li><li> 在计时器事件调用的回调中（例如，它是<code>setTimeout</code>或<code>requestAnimationFrame</code> ） </li></ul><br> 这是使用<code>wrapErrors</code>函数的示例。 <br><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span>(wrapErrors(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {//    doSynchronousStuff1();//     setTimeout(wrapErrors(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   doSynchronousStuff2();//      })); <span class="hljs-variable"><span class="hljs-variable">$</span></span>(<span class="hljs-string"><span class="hljs-string">'.foo'</span></span>).click(wrapErrors(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   doSynchronousStuff3();//     })); }));</code> </pre> <br> 可以自己将此类构造添加到代码中，但这是一项非常耗时的任务。 在这种情况下，作为一种方便的替代方法，可以考虑使用用于处理错误的库，例如，该库具有<code>addEventListener</code>和<code>setTimeout</code> <code>addEventListener</code>错误的工具的机制。 <br><br><h2>  <font color="#3AC1EF">错误转移到服务器</font> </h2><br> 因此，现在我们可以使用<code>windows.onerror</code>或基于<code>try/catch</code>辅助功能来拦截错误信息。 这些错误发生在客户端，在被拦截后，我们希望对其进行处理并采取措施消除它们。 为此，需要将它们转移到我们的服务器。 为此，您需要准备一个Web服务，该服务将通过HTTP接收有关错误的信息，然后以某种方式保存它们以进行进一步处理，例如-将其写入日志文件或数据库。 <br><br> 如果此Web服务与Web应用程序位于同一域中，则<code>XMLHttpRequest</code>就足够了。 下面的示例演示如何使用函数从jQuery执行AJAX查询，以将数据传输到服务器。 <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> captureError(ex){ var errorData = {   <span class="hljs-type"><span class="hljs-type">name</span></span>:ex.name,// : ReferenceError   message:ex.line,// : x <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> undefined   url:document.<span class="hljs-keyword"><span class="hljs-keyword">location</span></span>.href,   stack:ex.stack//   ; ,     ! }; $.post(<span class="hljs-string"><span class="hljs-string">'/logger/js/'</span></span>,{   data:errorData }); }</code> </pre> <br> 请记住，如果您需要发送跨域请求以将有关错误的信息发送到服务器，则必须注意支持此类请求。 <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br> 您已经了解了创建服务以捕获错误并将错误信息发送到服务器的基础知识。 特别是在这里，我们研究了以下问题： <br><br><ul><li>  <code>onerror</code>事件的功能及其在各种浏览器中的支持。 </li><li> 在<code>onerror</code>不支持使用错误对象的情况下，使用<code>try/catch</code>机制获取有关调用堆栈的信息。 </li><li> 将错误数据传输到开发人员的服务器。 </li></ul><br> 在了解了上述机制的工作原理之后，您已经获得了基础知识，可以使您开始创建自己的用于处理错误的系统，并在工作中阐明其他细节。 也许这种情况对于涉及某些应用程序的情况尤其重要，例如出于安全原因，不打算使用第三方库。 如果您的应用程序允许使用第三方代码，则可以很好地找到监视JS错误的正确工具。 这些工具包括<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Sentry</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Rollbar</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TrackJS</a>和其他类似项目。 <br><br>  <b>亲爱的读者们！</b> 您使用哪些监视JS错误的工具？ <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN413173/">https://habr.com/ru/post/zh-CN413173/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN413163/index.html">HTTPS的弱点。 第二部分</a></li>
<li><a href="../zh-CN413165/index.html">SRTP说明</a></li>
<li><a href="../zh-CN413167/index.html">如何将Zimbra与DLP系统集成？</a></li>
<li><a href="../zh-CN413169/index.html">JavaScript中有用的数组和对象方法</a></li>
<li><a href="../zh-CN413171/index.html">托卡马克JET启动新的氘Tri运动</a></li>
<li><a href="../zh-CN413175/index.html">Go中的静态分析：如何在检查代码时节省时间</a></li>
<li><a href="../zh-CN413177/index.html">6月4日至10日在莫斯科举行的数字活动</a></li>
<li><a href="../zh-CN413181/index.html">当外部函数调用比本地C调用快时</a></li>
<li><a href="../zh-CN413183/index.html">Optane DC永久性内存-DIMM格式的Optane</a></li>
<li><a href="../zh-CN413185/index.html">犯规行为或抽奖的组织者如何欺骗我们</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>