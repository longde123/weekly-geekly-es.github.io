<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💃🏽 🥕 👰 Menerapkan model seq2seq di Tensorflow 🍳 🔒 🖋️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pembuatan data menggunakan jaringan saraf berulang menjadi metode yang semakin populer dan digunakan di banyak bidang ilmu komputer. Sejak awal kelahi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menerapkan model seq2seq di Tensorflow</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440472/"><p>  Pembuatan data menggunakan jaringan saraf berulang menjadi metode yang semakin populer dan digunakan di banyak bidang ilmu komputer.  Sejak awal kelahiran konsep seq2seq pada tahun 2014, hanya lima tahun telah berlalu, tetapi dunia telah melihat banyak aplikasi, mulai dengan model klasik terjemahan dan pengenalan suara, dan berakhir dengan generasi deskripsi objek dalam foto. </p><br><p> Di sisi lain, seiring waktu, perpustakaan Tensorflow, dirilis oleh Google khusus untuk pengembangan jaringan saraf, mendapatkan popularitas.  Secara alami, pengembang Google tidak dapat mengabaikan paradigma populer seperti seq2seq, sehingga perpustakaan Tensorflow menyediakan kelas untuk pengembangan dalam paradigma ini.  Artikel ini menjelaskan sistem kelas ini. </p><a name="habracut"></a><br><h2 id="rekurentnye-seti">  Jaringan Berulang </h2><br><p>  Saat ini, jaringan berulang adalah salah satu formalisme paling terkenal dan praktis untuk membangun jaringan saraf yang dalam.  Jaringan rekursif dirancang untuk memproses data serial, oleh karena itu, tidak seperti sel normal (neuron), yang menerima data sebagai input dan output hasil perhitungan, sel rekursif berisi dua input dan dua output. </p><br><p>  Salah satu input mewakili data elemen saat ini dari urutan, dan input kedua disebut <i>keadaan</i> dan ditransmisikan sebagai hasil perhitungan sel pada elemen sebelumnya dari urutan. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/684/601/aa6/684601aa63886d86a1b4dafcf8ab079c.png" width="100" alt="gambar"><br><p>  Gambar menunjukkan sel A, yang datanya elemen urutan adalah input <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>x</mi><mi>t</mi></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.156ex" height="1.817ex" viewBox="0 -520.7 928.1 782.1" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/440472/&amp;usg=ALkJrhird0uuJViNxaau5ZhEWi5EcgI7bg#MJMATHI-78" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/440472/&amp;usg=ALkJrhird0uuJViNxaau5ZhEWi5EcgI7bg#MJMATHI-74" x="809" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>x</mi><mi>t</mi></msub></math></span></span><script type="math/tex" id="MathJax-Element-1"> x_t </script>  serta kondisi yang tidak ditunjukkan di sini <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>s</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>t</mi><mo>&amp;#x2212;</mo><mn>1</mn></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.017ex" height="1.937ex" viewBox="0 -520.7 1729.5 834" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/440472/&amp;usg=ALkJrhird0uuJViNxaau5ZhEWi5EcgI7bg#MJMATHI-73" x="0" y="0"></use><g transform="translate(469,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/440472/&amp;usg=ALkJrhird0uuJViNxaau5ZhEWi5EcgI7bg#MJMATHI-74" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/440472/&amp;usg=ALkJrhird0uuJViNxaau5ZhEWi5EcgI7bg#MJMAIN-2212" x="361" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/440472/&amp;usg=ALkJrhird0uuJViNxaau5ZhEWi5EcgI7bg#MJMAIN-31" x="1140" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>s</mi><mrow class="MJX-TeXAtom-ORD"><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-2"> s_ {t-1} </script>  .  Pada output, sel A memberikan status <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>s</mi><mi>t</mi></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.916ex" height="1.817ex" viewBox="0 -520.7 825.1 782.1" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/440472/&amp;usg=ALkJrhird0uuJViNxaau5ZhEWi5EcgI7bg#MJMATHI-73" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/440472/&amp;usg=ALkJrhird0uuJViNxaau5ZhEWi5EcgI7bg#MJMATHI-74" x="663" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>s</mi><mi>t</mi></msub></math></span></span><script type="math/tex" id="MathJax-Element-3"> s_t </script>  dan hasil perhitungannya <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>h</mi><mi>t</mi></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.165ex" height="2.419ex" viewBox="0 -780.1 932.1 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/440472/&amp;usg=ALkJrhird0uuJViNxaau5ZhEWi5EcgI7bg#MJMATHI-68" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/440472/&amp;usg=ALkJrhird0uuJViNxaau5ZhEWi5EcgI7bg#MJMATHI-74" x="815" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>h</mi><mi>t</mi></msub></math></span></span><script type="math/tex" id="MathJax-Element-4"> h_t </script>  . </p><br><p>  Dalam praktiknya, urutan data biasanya dibagi menjadi beberapa bagian dengan panjang tetap tertentu dan diteruskan ke perhitungan dengan seluruh himpunan bagian (kumpulan).  Dengan kata lain, contoh adalah contoh untuk belajar.  Input, output, dan keadaan sel dari jaringan rekursif adalah urutan bilangan real.  Untuk perhitungan input <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>x</mi><mn>1</mn></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.384ex" height="1.696ex" viewBox="0 -520.7 1026.4 730.2" role="img" focusable="false" style="vertical-align: -0.487ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/440472/&amp;usg=ALkJrhird0uuJViNxaau5ZhEWi5EcgI7bg#MJMATHI-78" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/440472/&amp;usg=ALkJrhird0uuJViNxaau5ZhEWi5EcgI7bg#MJMAIN-31" x="809" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>x</mi><mn>1</mn></msub></math></span></span><script type="math/tex" id="MathJax-Element-5"> x_1 </script>  perlu untuk menggunakan negara yang bukan hasil perhitungan pada urutan data yang diberikan.  Keadaan demikian disebut keadaan awal.  Jika urutannya cukup panjang, maka masuk akal untuk mempertahankan konteks perhitungan pada setiap urutan.  Dalam hal ini, dimungkinkan untuk mentransmisikan keadaan yang dihitung terakhir dalam urutan sebelumnya sebagai keadaan awal.  Jika urutannya tidak terlalu panjang atau urutannya adalah segmen pertama, maka Anda dapat menginisialisasi keadaan awal dengan nol. </p><br><p>  Saat ini, untuk pelatihan jaringan saraf hampir di mana-mana algoritma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">back propagation of error digunakan</a> .  Hasil perhitungan pada set contoh yang dikirimkan (dalam kasus kami, set berikutnya) diperiksa terhadap hasil yang diharapkan (mark up data).  Perbedaan antara nilai aktual dan yang diharapkan disebut kesalahan dan kesalahan ini disebarkan ke bobot jaringan di arah yang berlawanan.  Dengan demikian, jaringan beradaptasi dengan data yang diberi label dan, sebagai suatu peraturan, hasil dari adaptasi ini bekerja dengan baik untuk data yang tidak dipenuhi oleh jaringan dalam contoh pelatihan awal (hipotesis generalisasi). </p><br><p>  Dalam kasus jaringan rekursif, kami memiliki beberapa opsi yang keluarannya dianggap sebagai kesalahan.  Kami akan jelaskan di sini dua yang utama: </p><br><ol><li>  Anda dapat mempertimbangkan kesalahan dengan membandingkan output sel terakhir dari hasil dengan output yang diharapkan.  Ini berfungsi dengan baik untuk tugas klasifikasi.  Sebagai contoh, kita perlu menentukan pewarnaan emosional tweet.  Untuk melakukan ini, kami memilih tweet dan menandainya menjadi tiga kategori: negatif, positif dan netral.  Output sel akan menjadi tiga angka - berat kategori.  Tweet juga akan ditandai dengan tiga angka - probabilitas tweet yang termasuk dalam kategori yang sesuai.  Setelah menghitung kesalahan pada subset data, Anda dapat menyebarkannya melalui output atau menyatakan sesuka Anda. </li><li>  Anda dapat membaca kesalahan segera di output perhitungan sel untuk setiap elemen selanjutnya.  Ini sangat cocok untuk tugas memprediksi elemen urutan berikutnya dari yang sebelumnya.  Pendekatan ini dapat digunakan, misalnya, dalam masalah menentukan anomali dalam serangkaian waktu data atau dalam tugas memprediksi karakter berikutnya dalam teks, untuk kemudian menghasilkannya.  Propagasi kesalahan juga dimungkinkan melalui status atau keluaran. </li></ol><br><p>  Tidak seperti jaringan saraf yang terhubung penuh secara teratur, jaringan rekursif dalam arti bahwa kesalahan menyebar tidak hanya turun dari output jaringan ke bobotnya, tetapi juga ke kiri, melalui koneksi antar negara.  Kedalaman jaringan ditentukan oleh panjang urutan.  Untuk menyebarkan kesalahan melalui keadaan jaringan rekursif, ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma</a> khusus.  Fiturnya adalah bahwa gradien dari bobot saling berlipat ganda, ketika kesalahan menyebar dari kanan ke kiri.  Jika kesalahan awal lebih besar dari satu, maka akibatnya, kesalahan bisa menjadi sangat besar.  Sebaliknya, jika kesalahan awal kurang dari satu, maka di suatu tempat di awal urutan kesalahan mungkin memudar.  Situasi ini dalam teori jaringan saraf disebut korsel kesalahan standar.  Untuk menghindari situasi seperti itu selama pelatihan, sel-sel khusus diciptakan yang tidak memiliki kelemahan seperti itu.  Sel seperti pertama adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LSTM</a> , sekarang ada berbagai alternatif, yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GRU</a> paling populer. </p><br><p>  Pengantar yang baik untuk jaringan pengulangan dapat ditemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di artikel ini</a> .  Sumber terkenal lainnya adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> dari blog Andrey Karpaty. </p><br><p>  Perpustakaan Tensorflow memiliki banyak kelas dan fungsi untuk mengimplementasikan jaringan rekursif.  Berikut ini adalah contoh membuat jaringan rekursif dinamis berdasarkan sel dari tipe GRU: </p><br><pre><code class="python hljs">cell = tf.contrib.rnn.GRUCell(dimension) outputs, state = tf.nn.dynamic_rnn(cell, input, sequence_length=input_length, dtype=tf.float32)</code> </pre> <br><p>  Dalam contoh ini, sel GRU dibuat, yang kemudian digunakan untuk membuat jaringan rekursif dinamis.  Tensor data input dan panjang aktual dari baris-baris selanjutnya dikirimkan ke jaringan.  Input data selalu ditentukan oleh vektor bilangan real.  Untuk nilai tunggal, misalnya, kode simbol atau kata, yang disebut  embedding - memetakan kode ini ke beberapa urutan angka.  Fungsi membuat jaringan rekursif dinamis mengembalikan sepasang nilai: daftar output jaringan untuk semua nilai urutan dan keadaan yang dihitung terakhir.  Sebagai input, fungsi mengambil sel, menginput data, dan tensor panjang berikutnya. </p><br><p>  Jaringan rekursif dinamis berbeda dari yang statis di mana ia tidak membuat jaringan sel jaringan untuk selanjutnya di muka (pada tahap menentukan grafik perhitungan), tetapi meluncurkan sel pada input secara dinamis selama perhitungan grafik pada data input.  Oleh karena itu, fungsi ini perlu mengetahui panjang urutan input data agar berhenti pada waktu yang tepat. </p><br><h2 id="porozhdayuschie-modeli-na-osnove-rekurentnyh-setey">  Menghasilkan model berdasarkan jaringan perulangan </h2><br><h3 id="porozhdayuschie-rekurentnye-seti">  Menghasilkan jaringan perulangan </h3><br><p>  Sebelumnya, kami mempertimbangkan dua metode untuk menghitung kesalahan jaringan rekursif: pada output terakhir atau pada semua output untuk urutan tertentu.  Di sini kami mempertimbangkan masalah menghasilkan urutan.  Pelatihan jaringan generator didasarkan pada metode kedua di atas. </p><br><p>  Secara lebih rinci, kami mencoba untuk melatih jaringan rekursif untuk memprediksi elemen berurutan berikutnya.  Seperti disebutkan di atas, output sel dalam jaringan rekursif hanyalah urutan angka.  Vektor ini sangat tidak nyaman untuk dipelajari, oleh karena itu, mereka memperkenalkan level lain, yang menerima vektor ini pada input, dan pada output memberikan bobot prediksi.  Level ini disebut <em>level proyeksi</em> dan memungkinkan Anda untuk membandingkan output sel pada elemen tertentu dari urutan dengan output yang diharapkan dalam data berlabel. </p><br><p>  Untuk menggambarkan, pertimbangkan tugas menghasilkan teks yang direpresentasikan sebagai urutan karakter.  Panjang vektor output dari level proyeksi sama dengan ukuran alfabet teks sumber.  Ukuran alfabet biasanya tidak melebihi 150 karakter, jika Anda menghitung karakter bahasa Rusia dan Inggris, serta tanda baca.  Output dari level proyeksi adalah vektor dengan panjang alfabet, di mana setiap simbol sesuai dengan posisi tertentu dalam vektor ini - indeks simbol ini.  Data berlabel juga merupakan vektor yang terdiri dari nol, di mana seseorang berdiri pada posisi karakter mengikuti urutan. </p><br><p>  Untuk pelatihan, kami menggunakan dua urutan data: </p><br><ol><li>  Urutan karakter dalam teks sumber, di awal yang ditambahkan karakter khusus yang bukan bagian dari teks sumber.  Biasanya disebut sebagai <em>go</em> . </li><li>  Urutan karakter teks sumber apa adanya, tanpa tambahan. </li></ol><br><p>  Contoh untuk teks "ibu mencuci bingkai": </p><br><pre> <code class="python hljs">[<span class="hljs-string"><span class="hljs-string">'&lt;go&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span> <span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span> <span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">'] ['</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>]</code> </pre> <br><p>  Untuk pelatihan, minibatch biasanya dibentuk, yang terdiri dari sejumlah kecil contoh.  Dalam kasus kami, ini adalah string yang panjangnya bisa berbeda.  Kode yang dijelaskan di bawah ini menggunakan metode berikut untuk menyelesaikan masalah dengan panjang yang berbeda.  Dari banyak garis dalam paket mini ini, panjang maksimum dihitung.  Semua baris lainnya diisi dengan karakter khusus (padding) sehingga semua contoh dalam minipacket memiliki panjang yang sama.  Dalam contoh kode di bawah ini, string <em>pad</em> digunakan sebagai karakter seperti itu.  Juga, untuk generasi yang lebih baik, di akhir contoh, tambahkan simbol akhir kalimat - <em>eos</em> .  Dengan demikian, pada kenyataannya, data dari contoh akan terlihat sedikit berbeda: </p><br><pre> <code class="python hljs">[<span class="hljs-string"><span class="hljs-string">'&lt;go&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span> <span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span> <span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span>&lt;eos&gt;<span class="hljs-string"><span class="hljs-string">', '</span></span>&lt;pad&gt;<span class="hljs-string"><span class="hljs-string">', '</span></span>&lt;pad&gt;<span class="hljs-string"><span class="hljs-string">', '</span></span>&lt;pad&gt;<span class="hljs-string"><span class="hljs-string">'] ['</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;eos&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;pad&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;pad&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;pad&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;pad&gt;'</span></span>]</code> </pre> <br><p>  Urutan pertama diumpankan ke input jaringan, dan urutan kedua digunakan sebagai data yang ditandai.  Pelatihan prediksi didasarkan pada pengalihan urutan asli satu karakter ke kiri. </p><br><h3 id="obuchenie-i-porozhdenie">  Pelatihan dan pemijahan </h3><br><h4 id="obuchenie">  Pelatihan </h4><br><p>  Algoritma pembelajarannya cukup sederhana.  Untuk setiap elemen dari urutan input, kami menghitung vektor output dari level proyeksi dan membandingkannya dengan yang ditandai.  Satu-satunya pertanyaan adalah bagaimana cara menghitung kesalahan.  Anda bisa menggunakan root mean square error, tetapi untuk menghitung kesalahan dalam situasi ini, lebih baik menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cross entropy</a> .  Pustaka Tensorflow menyediakan beberapa fungsi untuk perhitungannya, meskipun tidak ada yang menghentikan implementasi rumus perhitungan langsung dalam kode. </p><br><p>  Untuk kejelasan, kami memperkenalkan beberapa notasi.  Dengan symbol_id kita akan menunjukkan pengenal simbol (nomor seri dalam alfabet).  Simbol istilah di sini agak sewenang-wenang dan hanya berarti elemen alfabet.  Alfabet mungkin tidak mengandung simbol, tetapi kata-kata atau bahkan beberapa set atribut yang lebih kompleks.  Istilah symbol_embedding akan digunakan untuk menunjukkan vektor angka yang sesuai dengan elemen alfabet tertentu.  Biasanya, set angka tersebut disimpan dalam tabel ukuran yang cocok dengan ukuran alfabet. </p><br><p>  Tensorflow menyediakan fitur yang memungkinkan Anda untuk mengakses tabel penyematan dan mengganti indeks karakter dengan vektor penyematan mereka.  Pertama, kita mendefinisikan variabel untuk menyimpan tabel: </p><br><pre> <code class="python hljs">embedding_table = tf.Variable(tf.random_uniform([alphabet_size, embedding_size]))</code> </pre> <br><p>  Setelah itu, Anda bisa mengonversi tensor input menjadi embedded tensor: </p><br><pre> <code class="python hljs">input_embeddings = tf.nn.embedding_lookup(embedding_table, input_ids)</code> </pre> <br><p>  Hasil pemanggilan fungsi adalah tensor dari dimensi yang sama yang ditransfer ke input, tetapi sebagai hasilnya, semua indeks karakter diganti dengan urutan embedding yang sesuai. </p><br><h4 id="porozhdenie">  Muncul </h4><br><p>  Untuk menghitung, sel jaringan rekursif membutuhkan status dan karakter saat ini.  Hasil perhitungannya adalah jalan keluar dan status baru.  Jika kita menerapkan tingkat proyeksi ke output, kita bisa mendapatkan vektor bobot di mana bobot pada posisi yang sesuai dapat dipertimbangkan (sangat kondisional) karena probabilitas simbol ini muncul di posisi berikutnya dalam urutan. </p><br><p>  Berbagai strategi dapat digunakan untuk memilih simbol berikutnya berdasarkan vektor bobot yang dihasilkan oleh tingkat proyeksi: </p><br><ul><li>  Strategi pencarian serakah.  Setiap kali kita memilih simbol dengan bobot tertinggi, mis.  kemungkinan besar dalam situasi ini, tetapi belum tentu yang paling tepat dalam konteks seluruh urutan. </li><li>  Strategi untuk memilih urutan terbaik (pencarian balok).  Kami tidak memilih simbol sekaligus, tetapi ingat beberapa varian simbol yang paling mungkin.  Setelah semua opsi tersebut dihitung untuk semua elemen dari urutan yang dihasilkan, kami memilih urutan karakter yang paling mungkin, dengan mempertimbangkan konteks seluruh urutan.  Biasanya, ini diwujudkan dengan menggunakan matriks yang lebarnya sama dengan panjang urutan, dan tinggi dengan jumlah varian menghasilkan karakter (lebar pencarian balok).  Setelah generasi varian urutan selesai, salah satu varian dari algoritma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Viterbi digunakan</a> untuk memilih urutan yang paling mungkin. </li></ul><br><h2 id="sistema-tipov-seq2seq-v-biblioteke-tensorflow">  Tensorflow perpustakaan sistem tipe seq2seq </h2><br><p>  Mengingat hal di atas, jelas bahwa implementasi model generatif berdasarkan jaringan pengulangan adalah tugas yang agak sulit untuk pengkodean.  Oleh karena itu, tentu saja, sistem kelas diusulkan untuk memfasilitasi solusi dari masalah ini.  Salah satu sistem ini disebut seq2seq, lalu kami menggambarkan fungsionalitas dari jenis utamanya. </p><br><p>  Tapi, pertama-tama, beberapa kata tentang nama perpustakaan.  Nama seq2seq adalah singkatan untuk urutan ke urutan (dari urutan ke urutan).  Gagasan asli untuk menghasilkan urutan diusulkan untuk menerapkan sistem terjemahan.  Urutan input kata diumpankan ke input jaringan rekursif, yang disebut encoder dalam sistem ini.  Output dari jaringan rekursif ini adalah keadaan perhitungan sel pada karakter terakhir dari urutan.  Keadaan ini disajikan sebagai keadaan awal dari jaringan rekursif kedua, decoder, yang dilatih untuk menghasilkan kata berikutnya.  Kata-kata itu digunakan sebagai simbol di kedua jaringan.  Kesalahan pada dekorator disebarkan ke encoder melalui kondisi yang ditransmisikan.  Vektor keadaan itu sendiri dalam terminologi ini disebut vektor pemikiran.  Presentasi antara digunakan dalam model terjemahan tradisional dan, sebagai aturan, adalah grafik yang mewakili struktur teks input untuk terjemahan.  Sistem terjemahan menghasilkan teks keluaran berdasarkan pada struktur perantara ini. </p><br><p>  Sebenarnya, implementasi seq2seq di Tensorflow adalah bagian dari decoder, tanpa mempengaruhi encoder.  Oleh karena itu, akan tepat untuk memanggil perpustakaan 2seq, tetapi kekuatan tradisi dan kelambanan berpikir di sini jelas menang atas akal sehat. </p><br><p>  Dua metatypes utama di perpustakaan seq2seq adalah: </p><br><ol><li>  Kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pembantu</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dekoder</a> Kelas. </li></ol><br><p>  Pengembang perpustakaan mengidentifikasi tipe-tipe ini berdasarkan pertimbangan berikut.  Mari kita perhatikan proses pembelajaran dan proses generasi, yang kami jelaskan di atas, dari sudut yang sedikit berbeda. </p><br><p>  Untuk pelatihan Anda membutuhkan: </p><br><ol><li>  Untuk setiap karakter, berikan perhitungan kondisi saat ini dan penyematan karakter saat ini. </li><li>  Ingat status output dan proyeksi yang dihitung untuk output. </li><li>  Dapatkan karakter berikutnya dalam urutan dan lanjutkan ke langkah 1. </li></ol><br><p>  Setelah itu, Anda dapat mulai menghitung kesalahan dengan membandingkan hasil perhitungan dengan karakter urutan berikut. </p><br><p>  Untuk menghasilkan itu perlu: </p><br><ol><li>  Untuk setiap karakter, berikan perhitungan kondisi saat ini dan penyematan karakter saat ini. </li><li>  Ingat status output dan proyeksi yang dihitung untuk output. </li><li>  Hitung karakter berikutnya sebagai maksimum dari indeks level proyeksi dan lanjutkan ke langkah 1. </li></ol><br><p>  Seperti yang dapat dilihat dari deskripsi, algoritma sangat mirip.  Oleh karena itu, pengembang perpustakaan memutuskan untuk merangkum prosedur untuk mendapatkan karakter berikutnya di kelas Helper.  Untuk pelatihan, ini hanya membaca karakter berikutnya dari urutan, dan untuk menghasilkannya, memilih karakter dengan bobot maksimum (tentu saja, untuk pencarian serakah). </p><br><p>  Dengan demikian, kelas dasar Helper mengimplementasikan metode next_inputs untuk mendapatkan karakter berikutnya dari kondisi saat ini dan negara, serta metode sampel untuk mendapatkan indeks karakter dari level proyeksi.  Untuk implementasi pelatihan, kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TrainingHelper</a> disediakan, dan untuk implementasi generasi dengan metode pencarian serakah, kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GreedyEmbeddingHelper disediakan</a> .  Sayangnya, model pencarian balok tidak cocok dengan sistem jenis ini, oleh karena itu, kelas khusus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BeamSearchDecoder</a> diimplementasikan di perpustakaan untuk ini.  tidak menggunakan Helper. </p><br><p>  Kelas Decoder menyediakan antarmuka untuk mengimplementasikan decoder.  Bahkan, kelas menyediakan dua metode: </p><br><ol><li>  inisialisasi untuk menginisialisasi pada awal pekerjaan. </li><li>  langkah untuk menerapkan langkah atau generasi pembelajaran.  Isi langkah ini ditentukan oleh Helper yang sesuai. </li></ol><br><p>  Perpustakaan mengimplementasikan kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BasicDecoder</a> , yang dapat digunakan baik untuk pelatihan dan untuk berkembang biak dengan asisten TrainingHelper dan GreedyEmbeddingHelper.  Ketiga kelas ini biasanya cukup untuk menerapkan model pembangkitan berdasarkan jaringan perulangan. </p><br><p>  Akhirnya, fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dynamic_decode</a> digunakan untuk mengatur bagian melalui input atau urutan yang dihasilkan. </p><br><p>  Selanjutnya, kita akan mempertimbangkan contoh ilustratif, yang menunjukkan metode untuk membangun model pembangkit untuk berbagai jenis pustaka seq2seq. </p><br><h2 id="illyustrativnyy-primer">  Contoh ilustratif </h2><br><p>  Pertama-tama, harus dikatakan bahwa semua contoh diimplementasikan dalam Python 2.7.  Daftar pustaka tambahan dapat ditemukan di file requirement.txt. </p><br><p>  Sebagai contoh ilustratif, pertimbangkan bagian dari data untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tantangan Normalisasi Teks -</a> kontes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bahasa Rusia</a> yang diselenggarakan oleh Kaggle oleh Google pada tahun 2017.  Tujuan dari kompetisi ini adalah untuk mengubah teks Rusia menjadi bentuk yang cocok untuk dibaca.  Teks untuk kontes dipecah menjadi ekspresi yang diketik.  Data pelatihan ditentukan dalam file CSV dari formulir berikut: </p><br><pre> <code class="plaintext hljs">"sentence_id","token_id","class","before","after" 0,0,"PLAIN","","" 0,1,"PLAIN","","" 0,2,"PLAIN","","" 0,3,"DATE","1862 ","    " 0,4,"PUNCT",".","." 1,0,"PLAIN","","" 1,1,"PLAIN","","" 1,2,"PLAIN","","" 1,3,"PLAIN","","" 1,4,"PLAIN","","" 1,5,"PLAIN","","" 1,6,"PLAIN","","" 1,7,"PLAIN","","" 1,8,"PLAIN","","" 1,9,"PUNCT",".","." ...</code> </pre> <br><p>  Dalam contoh di atas, ekspresi tipe DATE menarik, di dalamnya, "1862" diterjemahkan menjadi "seribu delapan ratus enam puluh dua tahun."  Untuk menggambarkan, kami menganggap data tipe DATE hanya sebagai pasangan bentuk (ekspresi sebelum, ekspresi setelah).  Mulai file data: </p><br><pre> <code class="plaintext hljs">before,after 1862 ,     1811 ,    12  2013,      15  2013,      1905 ,    17  2014,      7  2010 ,      1 ,  1843 ,     30  2007 ,      1846 ,     1996 ,     9 ,  ...</code> </pre> <br><p>  Kami akan membangun model pembangkit menggunakan perpustakaan seq2seq, di mana encoder akan diimplementasikan pada level simbol (mis., Elemen alfabet adalah simbol), dan decoder akan menggunakan kata-kata sebagai alfabet.  Kode contoh, seperti data, tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori di Github</a> . </p><br><p>  Data pelatihan dibagi menjadi tiga himpunan bagian: train.csv, test.csv dan dev.csv, masing-masing untuk pelatihan, pengujian dan pelatihan ulang verifikasi.  Data ada di direktori data.  Tiga model diimplementasikan dalam repositori: seq2seq_greedy.py, seq2seq_attention.py dan seq2seq_beamsearch.py.  Di sini kita melihat kode untuk model pencarian serakah dasar. </p><br><p>  Semua model menggunakan kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Estimator</a> untuk mengimplementasikan.  Menggunakan kelas ini memungkinkan Anda untuk menyederhanakan pengkodean tanpa terganggu oleh bagian-bagian non-model.  Misalnya, tidak perlu menerapkan siklus transfer data untuk pelatihan, membuat sesi untuk bekerja dengan Tensorflow, berpikir tentang mentransfer data ke Tensorboard, dll.  Estimator hanya membutuhkan dua fungsi untuk implementasinya: untuk transfer data dan untuk membangun model.  Contoh-contoh juga menggunakan kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dataset</a> untuk melewatkan data untuk diproses.  Implementasi modern ini jauh lebih cepat daripada kamus tradisional untuk mentransfer data dari form feed_dict. </p><br><h3 id="formirovanie-dannyh">  Pembuatan data </h3><br><p>  Pertimbangkan kode pembuatan data untuk pelatihan dan pembangkitan. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_fn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(line_before, line_after)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Encode in Bytes for TF source = [c.encode('utf8') for c in line_before.decode('utf8').rstrip('\n')] t = [w.encode('utf8') for w in nltk.word_tokenize(line_after.decode('utf8').strip())] learn_target = t + ['&lt;eos&gt;'] + ['&lt;pad&gt;'] target = ['&lt;go&gt;'] + t + ['&lt;eos&gt;'] return (source, len(source)), (target, learn_target, len(target)) def generator_fn(data_file): with open(data_file, 'rb') as f: reader = csv.DictReader(f, delimiter=',', quotechar='"') for row in reader: yield parse_fn(row['before'], row['after']) def input_fn(data_file, params=None): params = params if params is not None else {} shapes = (([None], ()), ([None], [None], ())) types = ((tf.string, tf.int32), (tf.string, tf.string, tf.int32)) defaults = (('&lt;pad&gt;', 0), ('&lt;pad&gt;', '&lt;pad&gt;', 0)) dataset = tf.data.Dataset.from_generator(functools.partial(generator_fn, data_file), output_shapes=shapes, output_types=types) dataset = dataset.repeat(params['epochs']) return (dataset.padded_batch(params.get('batch_size', 50), shapes, defaults).prefetch(1))</span></span></code> </pre> <br><p>  Fungsi input_fn digunakan untuk membuat kumpulan data yang kemudian Estimator lewati untuk pelatihan dan pembangkitan.  Tipe data diatur terlebih dahulu.  Ini adalah sepasang bentuk ((urutan encoder, panjang), (urutan decoder, urutan decoder dengan awalan, panjang)).  String "" digunakan sebagai awalan, setiap urutan enkoder diakhiri dengan kata "" khusus.  Juga, karena fakta bahwa sekuens (baik input dan output) memiliki panjang yang tidak sama, simbol padding dengan nilai "" digunakan. <br></p><p>  Kode persiapan data membaca file data, membagi string encoder menjadi karakter, dan string decoder menjadi kata-kata, menggunakan perpustakaan nltk untuk ini.  Baris yang diproses dengan cara ini adalah contoh data pelatihan.  Koleksi yang dihasilkan dibagi menjadi paket-mini, dan jumlah data dikloning sesuai dengan jumlah era pelatihan (setiap zaman adalah satu data pass). </p><br><h3 id="rabota-so-slovaryami">  Bekerja dengan kamus </h3><br><p>  Kamus disimpan sebagai daftar dalam file, satu baris untuk satu kata atau karakter.  Untuk membuat kamus, gunakan skrip build_vocabs.py.  Kamus yang dihasilkan terletak di direktori data sebagai file dari bentuk vocab. *. Txt. </p><br><p>  Kode untuk membaca kamus: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Read vocabs and inputs dropout = params['dropout'] source, source_length = features training = (mode == tf.estimator.ModeKeys.TRAIN) vocab_source = tf.contrib.lookup.index_table_from_file(vocabulary_file=params['source_vocab_file'], num_oov_buckets=params['num_oov_buckets']) with open(params['source_vocab_file']) as f: num_sources = sum(1 for _ in f) + params['num_oov_buckets'] vocab_target = tf.contrib.lookup.index_table_from_file(vocabulary_file=params['target_vocab_file'], num_oov_buckets=params['num_oov_buckets']) with open(params['target_vocab_file']) as f: num_targets = sum(1 for _ in f) + params['num_oov_buckets']</span></span></code> </pre> <br><p>  Di sini, mungkin, fungsi index_table_from_file menarik, yang membaca elemen kamus dari file, dan parameternya num_oov_buckets adalah jumlah keranjang kata yang tidak lengkap.  Secara default, angka ini sama dengan satu, yakni  semua kata yang tidak ada dalam kamus memiliki indeks yang sama dengan ukuran kamus + 1. Kami memiliki tiga kata yang tidak dikenal: "", "" dan "", yang kami ingin memiliki indeks yang berbeda.  Karena itu, atur parameter ini ke nomor tiga.  Sayangnya, Anda harus membaca file input lagi untuk mendapatkan jumlah kata dalam kamus sebagai konstanta waktu untuk mengatur grafik model. <br></p><p>  Kita masih perlu membuat tabel untuk mengimplementasikan embedding - _source_embedding, serta menerjemahkan string kata ke string pengidentifikasi: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># source embeddings matrix _source_embedding = tf.Variable(tf.random_uniform([num_sources, params['embedding_size']])) source_ids = vocab_source.lookup(source) source_embedding = tf.nn.embedding_lookup(_source_embedding, source_ids)</span></span></code> </pre> <br><h3 id="realizaciya-kodirovschika">  Implementasi Encoder </h3><br><p>  Untuk pembuat enkode, kami akan menggunakan jaringan rekursif dua arah dengan beberapa level.     ,     ,      . </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># add multilayer bidirectional RNN cell_fw = tf.contrib.rnn.MultiRNNCell([tf.contrib.rnn.GRUCell(params['dim']) for _ in range(params['layers'])]) cell_bw = tf.contrib.rnn.MultiRNNCell([tf.contrib.rnn.GRUCell(params['dim']) for _ in range(params['layers'])]) outputs, states = tf.nn.bidirectional_dynamic_rnn(cell_fw, cell_bw, source_embedding, sequence_length=source_length, dtype=tf.float32) # prepare output output = tf.concat(outputs, axis=-1) encoder_output = tf.layers.dense(output, params['dim']) # prepare state state_fw, state_bw = states cells = [] for fw, bw in zip(state_fw, state_bw): state = tf.concat([fw, bw], axis=-1) cells += [tf.layers.dense(state, params['dim'])] encoder_state = tuple(cells)</span></span></code> </pre> <br><p>       GRU,    MultiRNNCell,   ,   rnn.Cell.    , <br> sequence_length —     ,     ,    . </p><br><p> ,       ,       ,           .      ,      128,        256.     ,        ,      128.        . </p><br><p>     .  Karena    , ,    bidirectional_dynamic_rnn,   ,     .           ,      .     , ..       . , ,  .            ,   ,       . </p><br><h3 id="realizaciya-dekodirovschika">   </h3><br><p>     ,    .           . </p><br><pre> <code class="python hljs"> <span class="hljs-comment"><span class="hljs-comment"># decoder RNN cell decoder_cell = tf.contrib.rnn.MultiRNNCell([tf.contrib.rnn.GRUCell(params['dim']) for _ in range(params['layers'])]) decoder_initial_state = encoder_state # projection layer projection_layer = tf.layers.Dense(num_targets, use_bias=False) # embedding table for targets target_embedding = tf.Variable(tf.random_uniform([num_targets, params['embedding_size']]))</span></span></code> </pre> <br><h4 id="obuchenie-1">  </h4><br><p>    TrainingHelper + BasicDecoder. </p><br><pre> <code class="python hljs"> <span class="hljs-comment"><span class="hljs-comment"># target embeddings matrix target, learn_target, target_length = labels target_ids = vocab_target.lookup(target) target_learn_ids = vocab_target.lookup(learn_target) # train encoder _target_embedding = tf.nn.embedding_lookup(target_embedding, target_ids) train_helper = tf.contrib.seq2seq.TrainingHelper(_target_embedding, target_length) train_decoder = tf.contrib.seq2seq.BasicDecoder(decoder_cell, train_helper, decoder_initial_state, output_layer=projection_layer) train_outputs, _, _ = tf.contrib.seq2seq.dynamic_decode(train_decoder) train_output = train_outputs.rnn_output train_sample_id = train_outputs.sample_id</span></span></code> </pre> <br><h4 id="porozhdenie-1">  </h4><br><p>        . </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># prediction decoder prediction_helper = tf.contrib.seq2seq.GreedyEmbeddingHelper( embedding=target_embedding, start_tokens=tf.fill([batch_size], tf.to_int32(vocab_target.lookup(tf.fill([], '&lt;go&gt;')))), end_token=tf.to_int32(vocab_target.lookup(tf.fill([], '&lt;eos&gt;')))) prediction_decoder = tf.contrib.seq2seq.BasicDecoder(decoder_cell, prediction_helper, decoder_initial_state, output_layer=projection_layer) prediction_output, _, _ = tf.contrib.seq2seq.dynamic_decode(prediction_decoder, maximum_iterations=params['max_iters']) # prepare prediction reverse_vocab_target = tf.contrib.lookup.index_to_string_table_from_file(params['target_vocab_file']) pred_strings = reverse_vocab_target.lookup(tf.to_int64(prediction_output.sample_id)) predictions = { 'ids': prediction_output.sample_id, 'text': pred_strings }</span></span></code> </pre> <br><p>     GreedyEmbeddingHelper       "",     "".        . , ,    dynamic_decode      .    ,    ,   . ,     ,        . <br><br></p><h4 id="funkciya-poter-i-optimizaciya">     </h4><br><p>     ,        seq2seq. </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># loss masks = tf.sequence_mask(lengths=target_length, dtype=tf.float32) loss = tf.contrib.seq2seq.sequence_loss(logits=train_output, targets=target_learn_ids, weights=masks)</span></span></code> </pre> <br><p>    ,     ,      sequence_mask. </p><br><p>     Adam   ,   . </p><br><pre> <code class="python hljs">optimizer = tf.train.AdamOptimizer(learning_rate=params.get(<span class="hljs-string"><span class="hljs-string">'lr'</span></span>, <span class="hljs-number"><span class="hljs-number">.001</span></span>)) grads, vs = zip(*optimizer.compute_gradients(loss)) grads, gnorm = tf.clip_by_global_norm(grads, params.get(<span class="hljs-string"><span class="hljs-string">'clip'</span></span>, <span class="hljs-number"><span class="hljs-number">.5</span></span>)) train_op = optimizer.apply_gradients(zip(grads, vs), global_step=tf.train.get_or_create_global_step())</code> </pre> <br><h4 id="rezultaty-obucheniya">   </h4><br><p>         .     0.9   . , ,     ,    .   ,    . </p><br><pre> <code class="plaintext hljs">24  1944                 1  2003              1992 .           11  1927               1969            1  2016             1047          1863            17      22  2014              </code> </pre> <br><p>        .   —   ,   —  ,   —  . </p><br><p>  ,    —   .             .    ,    ( ),       .       .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>        ,     . </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>            seq2seq.      ,          ,     .    ,  . </p><br><p>           .  Tensorflow   ,   ,     .   ,         ,   .        ,        . ,      ,   padding  ,   embedding     ?       , ,       .         —     . ,    ,    . ,    ,    ,    . ,       . ,          , , ,        . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id440472/">https://habr.com/ru/post/id440472/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id440462/index.html">7 Strategi Pemasaran Konten Teratas Jangan sampai Terlewatkan pada 2019</a></li>
<li><a href="../id440464/index.html">Bekerja dengan layanan Digital Ocean Managed Databases di .NET Core</a></li>
<li><a href="../id440466/index.html">Web remote control UART</a></li>
<li><a href="../id440468/index.html">2 kali lebih banyak, 10 kali lebih cepat, sepanjang waktu - semua demi orang</a></li>
<li><a href="../id440470/index.html">Sematkan juru bahasa Python dalam aplikasi java menggunakan proyek Panama</a></li>
<li><a href="../id440474/index.html">Efek penyaringan SVG. Bagian 4. Gambar dua warna dengan feComponentTransfer</a></li>
<li><a href="../id440476/index.html">“Mulailah dengan mitaps,” atau Apakah Anda memerlukan kursus pemrograman sama sekali</a></li>
<li><a href="../id440478/index.html">3CX v16 Beta 1 dengan Dukungan Raspberry Pi Dirilis</a></li>
<li><a href="../id440486/index.html">Harga kualitas: 7 prinsip untuk mengoptimalkan biaya pengujian</a></li>
<li><a href="../id440488/index.html">Peta Bayangan Reflektif: Bagian 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>