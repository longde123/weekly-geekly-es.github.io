<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôéüèº üë¥üèº üëπ Estera con un caballo y un elefante. Base de decisiones ‚õ∑Ô∏è üë®üèΩ‚Äçüç≥ üë•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬øQuieres acertar a un jugador de ajedrez principiante? 
 P√≠dale que haga jaque mate con un caballo y un elefante. 
 
 ¬øQuieres desconcertar a un progr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Estera con un caballo y un elefante. Base de decisiones</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/396453/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQuieres acertar a un jugador de ajedrez principiante? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
P√≠dale que haga jaque mate con un caballo y un elefante. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øQuieres desconcertar a un programador novato? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
P√≠dale que calcule la alfombra con un caballo y un elefante. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/552/4b2/6d8/5524b26d81625b9ae809054ed010ee1d.jpg" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los problemas de ajedrez excitan la imaginaci√≥n del programador, por lo </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
que para la demostraci√≥n pr√°ctica de combinatoria </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
eleg√≠ el problema de ajedrez m√°s dif√≠cil del ciclo "jaque mate al rey solitario".</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Establecimiento de objetivos</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El objetivo del proyecto es crear una base de soluci√≥n, es decir, una lista de los movimientos correctos para todas las ubicaciones posibles del rey blanco, el elefante, el caballo y el rey negro en el tablero de ajedrez. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En esta publicaci√≥n, le dir√© c√≥mo resolv√≠ este problema, qu√© dificultades tuve que enfrentar y tambi√©n demostrar√© lo que sucedi√≥ al final. Tecnolog√≠as utilizadas: C #, JavaScript, PHP, HTML, CSS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Siendo un jugador de ajedrez muy mediocre, nunca aprend√≠ a hacer jaque mate r√°pidamente con un caballo y un elefante. Por lo tanto, decid√≠ compensar esta deficiencia con mis habilidades de programaci√≥n, ordenar todas las posiciones posibles y encontrar el movimiento correcto para cada una.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de escribir al menos una l√≠nea de c√≥digo, elabor√© un plan "napole√≥nico" sobre c√≥mo lo har√≠a durante varias semanas. </font><font style="vertical-align: inherit;">Realmente quer√≠a comenzar a resolver este problema desde el final, clasificando todas las combinaciones mate. </font><font style="vertical-align: inherit;">Y luego retroceda un paso hasta que se agoten todas las opciones posibles.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuantas opciones hay?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay 64 celdas en un tablero de ajedrez. </font><font style="vertical-align: inherit;">Tenemos cuatro figuras. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El n√∫mero de combinaciones posibles es 64 * 64 * 64 * 64 = 16,777,216. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solo puedes dejar un elefante de pecho blanco. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El n√∫mero de opciones se reducir√° a la mitad: 64 * 32 * 64 * 64 = 8,388,608. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tantos puestos estar√°n en nuestra base de datos de soluciones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De hecho, hay incluso menos combinaciones: dos piezas no pueden pararse en una casilla, los reyes no pueden pararse en las casillas vecinas, el rey negro no puede estar bajo el control, y as√≠ sucesivamente. </font><font style="vertical-align: inherit;">Mirando hacia el futuro, dir√© que la base de datos de soluciones result√≥ ser 5,609,790 combinaciones, la matriz se completar√° en un 67%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, para simplificar el algoritmo y acelerar el acceso a los datos de la base de datos, decid√≠ no "perder el tiempo" y crear una matriz de cuatro dimensiones para todas las combinaciones.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La siguiente estructura se define para almacenar cada combinaci√≥n:</font></font><br>
<br>
<pre><code class="cs hljs">    <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Combo<font></font>
    {<font></font>
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Coord whiteKing;
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Coord whiteBishop;
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Coord whiteKnight;
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Coord blackKing;<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el interior, se usa otra estructura Coord para registrar las coordenadas de la figura, con la capacidad de calcular el √≠ndice de 0 a 63, as√≠ como con un operador de comparaci√≥n sobrecargado.</font></font><br>
<br>
<pre><code class="cs hljs">    <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Coord<font></font>
    {<font></font>
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> x; <span class="hljs-comment"><span class="hljs-comment">//    0  7 ( a  h)</span></span>
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> y; <span class="hljs-comment"><span class="hljs-comment">//    0  7</span></span><font></font>
        <font></font>
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index<font></font>
        {<font></font>
            <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y * <span class="hljs-number"><span class="hljs-number">8</span></span>; }
            <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { x = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> % <span class="hljs-number"><span class="hljs-number">8</span></span>); <font></font>
                  y = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span>); }<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> == (Coord a, Coord b)<font></font>
        {<font></font>
            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.x == b.x &amp;&amp; a.y == b.y;<font></font>
        }<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta estructura result√≥ ser muy conveniente para pasar como argumento a varias funciones auxiliares, por ejemplo:</font></font><br>
<br>
<pre><code class="cs hljs">    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isCheck</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Combo combo</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    </span></span>
    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isCheckmate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Combo combo</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  </span></span>
    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isCheckByBishop</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Combo combo</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     </span></span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, para registrar el resultado de la base de decisiones de esta estructura no es suficiente, todav√≠a necesitamos ... </font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caja blanca</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El objetivo de nuestro programa ser√° crear un "recuadro blanco", en el que se sumar√°n todas las posiciones en las que el "movimiento es blanco", y para el que se sabe qu√© movimiento tomar, y a trav√©s de cu√°ntos movimientos se garantizar√° el jaque mate. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una parte integral de la "caja blanca" es la siguiente estructura:</font></font><br>
<br>
<pre><code class="cs hljs">    <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> WhitesMove<font></font>
    {<font></font>
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Combo combo;
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> moves;     <span class="hljs-comment"><span class="hljs-comment">//    </span></span>
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Coord moveFrom; <span class="hljs-comment"><span class="hljs-comment">//   - </span></span>
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Coord moveTo;   <span class="hljs-comment"><span class="hljs-comment">// </span></span><font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La forma m√°s f√°cil de organizar un "cuadro blanco" es abrir una matriz de cuatro dimensiones. </font><font style="vertical-align: inherit;">Cada dimensi√≥n de esta matriz corresponde a la posible posici√≥n de cada figura:</font></font><br>
<br>
<pre><code class="cs hljs">    WhitesMove [ , , , ] box = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WhitesMove [<span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>];
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La primera dimensi√≥n es la coordenada del rey blanco. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
la segunda dimensi√≥n es la coordenada del elefante blanco / 2. la </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
tercera dimensi√≥n es la coordenada del caballo blanco. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La cuarta dimensi√≥n es la coordenada del rey negro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo principal es no confundir su orden :) La matriz se descargar√° en un 33%, pero es muy conveniente para el procesamiento. </font><font style="vertical-align: inherit;">Es en esta matriz que se almacenar√°n 8.388.608 entradas para resolver combinaciones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por cierto, antes de comenzar a escribir todos los algoritmos de b√∫squeda, cre√© un proyecto vac√≠o e inicialic√© esta matriz de cuatro dimensiones, para asegurarme de que hay suficiente memoria y no ser√° necesario inventar algo adicional. </font><font style="vertical-align: inherit;">Aparentemente, la experiencia de participar en olimpiadas inform√°ticas del milenio pasado, donde el tama√±o de la estructura no pod√≠a exceder los 64 kilobytes, afect√≥ a Turbo Pascal 7.0.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idea del algoritmo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Describa brevemente la idea principal de resolver este problema. </font><font style="vertical-align: inherit;">Se basa en un algoritmo de b√∫squeda de amplitud, que tuvo que modificarse un poco, ya que dos personas juegan al ajedrez y los movimientos se hacen a su vez. </font><font style="vertical-align: inherit;">Por lo tanto, en lugar de una l√≠nea, necesitamos dos: "negro" y "blanco".</font></font><br>
<br>
<pre><code class="cs hljs">    Queue&lt;BlacksMove&gt; blackQueue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Queue&lt;BlacksMove&gt;();<font></font>
    Queue&lt;WhitesMove&gt; whiteQueue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Queue&lt;WhitesMove&gt;();
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con la estructura de WhitesMove ya nos hemos encontrado. </font><font style="vertical-align: inherit;">La estructura de BlacksMove es un poco m√°s simple, ya que no es necesario almacenar el √∫ltimo movimiento de Black en ella.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> BlacksMove<font></font>
    {<font></font>
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Combo combo;
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> moves; <font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, en la "l√≠nea negra" colocaremos todas las posiciones mate en las que el movimiento es negro. </font><font style="vertical-align: inherit;">Luego, desde cada posici√≥n, haremos un movimiento inverso para las blancas y formaremos una "l√≠nea blanca", una lista de posiciones en las que las blancas se mueven. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estos pasos deber√°n repetirse hasta que se agoten todas las combinaciones posibles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El algoritmo principal en forma de pseudoc√≥digo:</font></font><br>
<br>
<pre><code class="cs hljs">       <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-string"><span class="hljs-string">" "</span></span><font></font>
         <font></font>
         <span class="hljs-string"><span class="hljs-string">" "</span></span><font></font>
<font></font>
      <font></font>
      {<font></font>
           <span class="hljs-string"><span class="hljs-string">" "</span></span>  <font></font>
                 <span class="hljs-string"><span class="hljs-string">" "</span></span><font></font>
                    <font></font>
                      <font></font>
                           <span class="hljs-string"><span class="hljs-string">" "</span></span>
                             <span class="hljs-string"><span class="hljs-string">" "</span></span>
                             <span class="hljs-string"><span class="hljs-string">" "</span></span><font></font>
<font></font>
           <span class="hljs-string"><span class="hljs-string">" "</span></span>  <font></font>
                 <span class="hljs-string"><span class="hljs-string">" "</span></span><font></font>
                      <font></font>
                        <font></font>
                      <span class="hljs-string"><span class="hljs-string">" "</span></span>
                         <span class="hljs-string"><span class="hljs-string">" "</span></span><font></font>
<font></font>
      }  <span class="hljs-string"><span class="hljs-string">" "</span></span>  <font></font>
<font></font>
       <span class="hljs-string"><span class="hljs-string">" "</span></span>   
</code></pre><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Posici√≥n mate</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La creaci√≥n de la base de los movimientos correctos comienza con una b√∫squeda de todas las combinaciones mate. </font><font style="vertical-align: inherit;">El uso de enumeradores permiti√≥ describir con bastante eficacia este proceso.</font></font><br>
<br>
<pre><code class="cs hljs">    <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-function"><span class="hljs-function">Combo combo </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllCheckmates</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>))</span></span><font></font>
    {<font></font>
        BlacksMove checkmate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BlacksMove { combo = combo, moves = <span class="hljs-number"><span class="hljs-number">0</span></span> };<font></font>
        blackQueue.Enqueue(checkmate);<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Total encontrado 232 posiciones mate. </font><font style="vertical-align: inherit;">D√©jame recordarte que nos limitamos solo a un elefante de campo blanco. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algunos de ellos son bastante ex√≥ticos, inexistentes y "cooperativos", esto es cuando el propio rey negro se meti√≥ debajo de la estera. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/cb8/72f/c4e/cb872fc4e552449343b0bb9ad2e80303.png" alt="Mat.  ¬øCu√°l fue el movimiento de White?"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los jugadores de ajedrez son conscientes de que una estera con un caballo y un elefante de campo blanco debe colocarse en una esquina blanca. </font><font style="vertical-align: inherit;">En la esquina negra, el jaque mate solo es posible si las negras juegan a lo largo. </font><font style="vertical-align: inherit;">Especialmente publiqu√© una foto con un pseudo-aut√≥mata al comienzo del art√≠culo para provocar la atenci√≥n de jugadores de ajedrez reales :)</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mat en un movimiento</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El siguiente paso es revertir el blanco. </font><font style="vertical-align: inherit;">Es decir, para cada posici√≥n mate encontrada, haga que </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">todos los movimientos blancos posibles retrocedan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øC√≥mo hacer un movimiento inverso? </font><font style="vertical-align: inherit;">Dado que no se proporciona ninguna captura en nuestras posiciones, el algoritmo es bastante simple: haga cualquier movimiento por parte de White, despu√©s de lo cual no habr√° control para el rey negro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todas las posiciones encontradas de esta manera ya se pueden poner en el "cuadro blanco", lo que indica que hay un movimiento antes del tapete, y qu√© tipo de movimiento hacer esto. </font><font style="vertical-align: inherit;">En el camino, colocamos las combinaciones que se encuentran en la "l√≠nea negra". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As√≠ es como se ve esta parte del algoritmo:</font></font><br>
<br>
<pre><code class="cs hljs">    <span class="hljs-comment"><span class="hljs-comment">//  " "  </span></span>
    <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (blackQueue.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)<font></font>
    {<font></font>
        <span class="hljs-comment"><span class="hljs-comment">//    " "</span></span><font></font>
        BlacksMove black = blackQueue.Dequeue();<font></font>
        <span class="hljs-comment"><span class="hljs-comment">//       </span></span>
        <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-function"><span class="hljs-function">WhitesMove white </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllWhiteBackMoves</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">black</span></span></span><span class="hljs-function">))
            </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//     </span></span></span><span class="hljs-function">
            </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">!isCheck(white.combo</span></span></span><span class="hljs-function">))
                </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//      " "</span></span></span><span class="hljs-function">
                </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">!whiteBox.Exists(white.combo</span></span></span><span class="hljs-function">))</span></span><font></font>
                {<font></font>
                    <span class="hljs-comment"><span class="hljs-comment">//    " "</span></span><font></font>
                    whiteBox.Put (white);<font></font>
                    <span class="hljs-comment"><span class="hljs-comment">//    " "</span></span><font></font>
                    whiteQueue.Enqueue(white);<font></font>
                }<font></font>
    }<font></font>
</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por cierto, sobre el rendimiento</font></font></b><div class="spoiler_text">   yield-      , ,         :<br>
<br>
<pre><code class="cs hljs">        <span class="hljs-function"><span class="hljs-function">IEnumerable&lt;WhitesMove&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllWhiteBackMoves</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BlacksMove black</span></span></span><span class="hljs-function">)</span></span><font></font>
        {<font></font>
            <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-function"><span class="hljs-function">WhitesMove white </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllWhiteKingMoves</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">black</span></span></span><span class="hljs-function">))
                </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return white</span></span>;
            <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-function"><span class="hljs-function">WhitesMove white </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllWhiteBishopMoves</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">black</span></span></span><span class="hljs-function">))
                </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return white</span></span>;
            <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-function"><span class="hljs-function">WhitesMove white </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllWhiteKnightMoves</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">black</span></span></span><span class="hljs-function">))
                </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return white</span></span>;<font></font>
        }<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se encontraron un total de 920 posiciones de este tipo, aqu√≠ est√°n las m√°s interesantes: </font><font style="vertical-align: inherit;">
movimiento de </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
caballo </font></font><br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/a3c/5e9/e2a/a3c5e9e2a6de27f57d40720cf3caa044.png" alt="Caballero 1"> <img src="https://habrastorage.org/getpro/geektimes/post_images/b30/477/955/b3047795519e369386b6d4c98582310f.png" alt="movimiento de caballero 2"> <img src="https://habrastorage.org/getpro/geektimes/post_images/8aa/d2b/728/8aad2b72884640ec4fe9469efa89088d.png" alt="Caballero 3"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/af8/447/b26/af8447b26f2c45bd93595887f84f4a65.png" alt="movimiento de elefante 1"> <img src="https://habrastorage.org/getpro/geektimes/post_images/cdf/b7b/735/cdfb7b7359a3e69f93aa8b8b67651206.png" alt="movimiento de elefante 2"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
movimiento de </font><font style="vertical-align: inherit;">elefante </font><font style="vertical-align: inherit;">: movimiento de rey:</font></font><br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/689/946/f2e/689946f2eb8e8d5eac9d0cc8d2a3834b.png" alt="movimiento rey"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mat en un movimiento y medio</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El siguiente paso es revertir el negro. Con este algoritmo pas√© el mayor tiempo, se cometieron muchos errores antes de que todo funcionara correctamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A primera vista, todo es similar a la versi√≥n anterior: para cada posici√≥n de la "l√≠nea blanca" es necesario ordenar todos los movimientos posibles del rey negro. Y agregue todas las combinaciones encontradas a la "l√≠nea negra": despu√©s de todo, este es un jaque mate en un movimiento y medio, desde el cual puede hacer un movimiento inverso para las blancas nuevamente, habr√° un jaque mate en dos movimientos, y contin√∫e hasta que se revisen todas las opciones.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ese fue el error. Con cualquier movimiento posible, las negras obtienen un jaque mate "cooperativo" en un movimiento y medio, pero en realidad el rey no necesariamente pasar√° por debajo del jaque mate. Dmitry Grin me se√±al√≥ este error, que asist√≠ a todos mis seminarios web sobre la creaci√≥n de este programa, por lo que le agradezco por separado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El algoritmo correcto es el siguiente: para cada posici√≥n N despu√©s del movimiento inverso del rey negro, debe realizar todos los movimientos directos posibles para asegurarse de que todos conduzcan a posiciones familiares desde el "cuadro blanco", es decir, conduzcan a la colchoneta. Y solo despu√©s de esa posici√≥n N se puede agregar a la "l√≠nea negra". Y si el rey negro puede "escapar" de la posici√≥n N, entonces omitimos esta opci√≥n. Se reunir√° en iteraciones posteriores, cuando habr√° posiciones m√°s familiares. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As√≠ es como se ve esta parte del algoritmo:</font></font><br>
<br>
<pre><code class="cs hljs">    <span class="hljs-comment"><span class="hljs-comment">//  " "  </span></span>
    <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (whiteQueue.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)<font></font>
    {<font></font>
        <span class="hljs-comment"><span class="hljs-comment">//   N  " "</span></span><font></font>
        WhitesMove white = whiteQueue.Dequeue();<font></font>
        Combo whiteFigures = white.combo;<font></font>
        <span class="hljs-comment"><span class="hljs-comment">//   N      </span></span>
        <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-function"><span class="hljs-function">BlacksMove black </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllBlackBackMoves</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">white</span></span></span><span class="hljs-function">))</span></span><font></font>
        {<font></font>
            <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> solved = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;
            <span class="hljs-comment"><span class="hljs-comment">//      </span></span>
            <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-function"><span class="hljs-function">Coord blackKing </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllKingMoves</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">black.combo.blackKing</span></span></span><span class="hljs-function">))</span></span><font></font>
            {<font></font>
                whiteFigures.blackKing = blackKing; <span class="hljs-comment"><span class="hljs-comment">//   </span></span>
                <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isCheck(whiteFigures)) <span class="hljs-comment"><span class="hljs-comment">//    </span></span>
                    <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>;
                <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (box.Exists(whiteFigures)) <span class="hljs-comment"><span class="hljs-comment">//   </span></span>
                    <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>;<font></font>
                solved = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    ""</span></span>
                <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;<font></font>
            }<font></font>
            <span class="hljs-comment"><span class="hljs-comment">//       </span></span>
            <span class="hljs-comment"><span class="hljs-comment">//     " "</span></span>
            <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (solved)
                <span class="hljs-comment"><span class="hljs-comment">//    " "</span></span><font></font>
                blackQueue.Enqueue(black);<font></font>
        }<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En total, se encontraron 156 combinaciones de "Mat y medio movimientos".</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterativo a mitad de camino</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los algoritmos descritos para crear medio paso deben estar en bucle. </font><font style="vertical-align: inherit;">A partir de la "l√≠nea negra" formamos la "l√≠nea blanca", y luego viceversa: a partir de la l√≠nea "blanca" formamos la "l√≠nea negra". </font><font style="vertical-align: inherit;">Y as√≠ sucesivamente hasta que se agoten todas las nuevas posiciones. </font><font style="vertical-align: inherit;">El "cuadro blanco" se rellena en la etapa de formaci√≥n de la "l√≠nea blanca", ya que coloca las posiciones en las que se mueve el blanco. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El algoritmo listo para enumerar todas las opciones funcion√≥ en alg√∫n lugar en 12 minutos y se detuvo en el movimiento 33. </font><font style="vertical-align: inherit;">Esa es la cantidad m√°xima de movimientos necesarios para emparejar al rey negro con un caballo y un elefante desde cualquier posici√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por cierto, no hab√≠a tantas posiciones "m√°s dif√≠ciles", solo 156, aqu√≠ est√° una de ellas:</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/af4/481/e7c/af4481e7cfe9f5d9e5787d4f287238f6.png" alt="Mat en 33 movimientos"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mata no lo ser√°!</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay muchas posiciones en las que, incluso despu√©s del movimiento de las blancas, el rey negro puede comer un caballero u obispo y obtener un empate. </font><font style="vertical-align: inherit;">Tambi√©n hay opciones de estancamiento. </font><font style="vertical-align: inherit;">Estos son algunos de los art√≠culos m√°s interesantes.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/b87/90d/11f/b8790d11ff993e53cb6620167448e7fb.png" alt="No amigo"> <img src="https://habrastorage.org/getpro/geektimes/post_images/885/786/cad/885786cad2d99e49c3d176a83217bda4.png" alt="No amigo"><br>
<br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/09c/f2c/cf2/09cf2ccf2d1855e834a1e2e38e0205e2.png" alt="No amigo"> <img src="https://habrastorage.org/getpro/geektimes/post_images/6ef/659/f74/6ef659f744134d6e4c993c56dd71a213.png" alt="No amigo"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√≥mo almacenar una base de datos de soluciones</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øC√≥mo almacenar la base de soluci√≥n encontrada? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La forma m√°s f√°cil e incorrecta es usar la serializaci√≥n. El conjunto de cuatro dimensiones serializado de la estructura tom√≥ 1.7 gigabytes (!) De espacio en disco. El proceso de serializaci√≥n dur√≥ aproximadamente seis minutos, la deserializaci√≥n tom√≥ casi lo mismo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta opci√≥n, por supuesto, no es adecuada. Adem√°s, en la pr√°ctica no es necesario utilizar toda la matriz de cuatro dimensiones. Solo se necesita una entrada para una l√≠nea de pedido espec√≠fica. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eureka! Para ahorrar espacio, a√∫n puede deshacerse del almacenamiento de las coordenadas de las figuras para cada combinaci√≥n. Cuando tenemos una matriz de cuatro dimensiones, la posici√≥n de cada figura en el tablero est√° determinada √∫nicamente por su √≠ndice en la matriz.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se decidi√≥ almacenar toda la base de datos de soluciones en un archivo, como un escaneo lineal de una matriz de cuatro dimensiones. Para cualquier posici√≥n posible, se calcula la direcci√≥n en la que se registra la respuesta correcta. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øC√≥mo registrar la respuesta que necesitamos de la forma m√°s compacta posible? No es necesario almacenar la posici√≥n de las figuras, por lo que solo quedan tres n√∫meros: cu√°ntos movimientos al tapete, qu√© ir y d√≥nde ir. As√≠ es como se determina de manera √∫nica el movimiento correcto para las blancas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6 bit Cu√°ntos movimientos al tapete es un n√∫mero entero de 0 a 33.2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bits. Qu√© figura camina: tres opciones posibles, un rey, un elefante o un caballo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6 bit A d√≥nde va la pieza: el √≠ndice de campo en el tablero es de 0 a 63. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, para cada registro de decisi√≥n, dos bytes son suficientes: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1 byte: cu√°ntos movimientos al tapete, o 0 si la posici√≥n no es familiar. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2 bytes - FFNNNNNN</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FF - n√∫mero de la figura a caminar (1 - rey, 2 - elefante, 3 - caballo) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NNNNNN - coordenada de celda - a d√≥nde ir (de 0 a 63). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, el archivo de base de datos de la soluci√≥n toma 64 * 32 * 64 * 64 palabras = exactamente 16 megabytes. </font><font style="vertical-align: inherit;">La posici√≥n de las figuras se establece mediante las coordenadas de cada palabra, en el primer byte: el n√∫mero de movimientos al tapete (o 0 si no hay soluci√≥n), el segundo movimiento almacena el movimiento correcto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ser√≠a posible reducir el tama√±o del archivo a la mitad si no almacenaras el n√∫mero de movimientos al tapete, pero no ser√≠a interesante jugar as√≠.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coordenadas del elefante blanco cuadrado negro</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es hora de pagar por la optimizaci√≥n. </font><font style="vertical-align: inherit;">Es necesario implementar un algoritmo de rec√°lculo de coordenadas para combinaciones con un elefante "blanco y negro". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto se hizo de la siguiente manera. </font><font style="vertical-align: inherit;">Si la coordenada del elefante cae en un campo negro, entonces las coordenadas de todas las figuras en el tablero deben "voltearse". </font><font style="vertical-align: inherit;">En este caso, la coordenada Y permanece sin cambios y X cambia a 7-X. </font><font style="vertical-align: inherit;">Una demostraci√≥n visual de un cambio de coordenadas, vea la figura. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/1cb/019/1f7/1cb0191f7642a5b963437278ed9ca783.png" alt="Flip coordinado"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si el elefante est√° de pie sobre una jaula blanca, primero debe "voltear" las coordenadas de todas las figuras. </font><font style="vertical-align: inherit;">Luego busque una posici√≥n en la base de datos de soluciones. </font><font style="vertical-align: inherit;">Y una vez m√°s "voltee" la coordenada del movimiento correcto le√≠do desde all√≠.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visualizaci√≥n de la base de la soluci√≥n.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, ¬°el problema est√° resuelto! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La base de datos de soluciones ha sido creada. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øPero c√≥mo demostrarlo? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La forma m√°s obvia es utilizar tecnolog√≠as web para que pueda dar un enlace a un ejemplo de trabajo. En mi "f√≥rmula de programador", ya se cre√≥ el curso de fotograf√≠a " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nano-Chess</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ", donde utilizando las tecnolog√≠as de HTML, CSS, JavaScript y PHP se cre√≥ un tablero de ajedrez interactivo para jugar sin reglas para dos. Este gui√≥n fue tomado como base. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dej√© solo cuatro piezas, elimin√© la posibilidad de capturar, agregu√© funciones PHP para leer los movimientos correctos de la base de la soluci√≥n y "respir√© la vida" a trav√©s de JavaScript. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la p√°gina </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.videosharp.info/chess</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> puede experimentar con la base de datos de soluciones.</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/getpro/geektimes/post_images/9fb/3ce/7bc/9fb3ce7bc6645d2c96536c2a19c663a2.png" alt="Colchoneta interactiva con caballo y elefante"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para cada posici√≥n, los movimientos se calculan tanto para blanco como para negro. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para las blancas: el mejor movimiento que lleva al jaque mate. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para el negro: cu√°ntos movimientos al tapete para cualquier movimiento posible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede hacer cualquier movimiento de las figuras con el mouse, no necesariamente seg√∫n las reglas. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El script calcular√° la opci√≥n para cualquier posici√≥n o escribir√° que no hay opciones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es interesante jugar, realizar los movimientos propuestos o mover las piezas a su discreci√≥n.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusi√≥n</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se realiz√≥ un gran trabajo interesante para resolver el problema del ajedrez. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si desea repetir de esta manera, puede </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ver videos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sobre </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">c√≥mo</font></a><font style="vertical-align: inherit;"> crear este programa desde cero hasta el resultado con explicaciones detalladas y tareas independientes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Buena suerte</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es396453/">https://habr.com/ru/post/es396453/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es396441/index.html">Italia puede perder sus olivos debido a la desconfianza de los cient√≠ficos</a></li>
<li><a href="../es396443/index.html">"Sion sabios" se convirti√≥ en otra raz√≥n para bloquear Wikipedia</a></li>
<li><a href="../es396445/index.html">–ö–ª–æ–Ω—ã –æ–≤–µ—á–∫–∏ –î–æ–ª–ª–∏ –ø–æ–º–æ–≥–∞—é—Ç –¥–æ–∫–∞–∑—ã–≤–∞—Ç—å –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å SCNT-–∫–ª–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è</a></li>
<li><a href="../es396447/index.html">Precios de la electr√≥nica popular del pasado en el dinero de hoy: 1970</a></li>
<li><a href="../es396451/index.html">Delitos y castigos del mes pasado</a></li>
<li><a href="../es396455/index.html">–í—ã—á–∏—Å–ª–∏—Ç–µ–ª—å–Ω–∞—è —Ç–µ—Ö–Ω–∏–∫–∞ —Å—Ç—Ä–∞–Ω –°–≠–í. –ß–∞—Å—Ç—å –≤—Ç–æ—Ä–∞—è: –ß–µ—Ö–æ—Å–ª–æ–≤–∞–∫–∏—è</a></li>
<li><a href="../es396457/index.html">APEIGAMING en n√∫meros. Un mes despu√©s del inicio (video)</a></li>
<li><a href="../es396459/index.html">Revisi√≥n de la unidad del sistema de juego ASUS ROG GT51CA</a></li>
<li><a href="../es396463/index.html">Construcci√≥n de la l√≠nea de comunicaci√≥n Kamchatka - Sakhalin - Magadan. Cable Innovator Tour - Telef√©rico</a></li>
<li><a href="../es396467/index.html">¬øLa materia oscura tiene un uso pr√°ctico?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>