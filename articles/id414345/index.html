<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💑 👾 👨🏻‍💼 Membalikkan pengembangan saklar waktu VL-76-S 👩🏽‍🤝‍👩🏻 🙏🏽 👩🏽‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sekali waktu saya menemukan saklar waktu digital elektronik VL-76-S, baru, dalam kemasan, tetapi dalam keadaan tidak berfungsi. Tidak ditemukan cacat ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membalikkan pengembangan saklar waktu VL-76-S</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414345/">  Sekali waktu saya menemukan saklar waktu digital elektronik VL-76-S, baru, dalam kemasan, tetapi dalam keadaan tidak berfungsi.  Tidak ditemukan cacat pada papan sirkuit tercetak di dalamnya.  Oleh karena itu, perkawinan pabrik, firmware rusak. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cn/vj/2v/cnvj2vs2aonwmvjljydwos0ewqi.jpeg"></div><br>  <i>Tampilan umum relai.</i> <br><a name="habracut"></a><br>  Yang mengejutkan kami adalah penggunaan mikrokontroler ATTiny2313 yang populer dan sederhana.  Secara eksternal, desain ini terdiri dari master dalam bentuk tiga dekade sakelar dan terminal yang terhubung dengan daya 220V dan kontak relai EM.  Rentang tugas adalah 0,1 ... 99,9 menit.  dalam peningkatan 0,1 menit  (6 detik).  Tidak ada sirkuit dan firmware pada desain ini di Internet, yang tidak mengejutkan.  Tanpa berpikir dua kali, saya memutuskan untuk menggambar sirkuit dari papan sirkuit cetak dan di masa depan menulis program pada MK sendiri. <br><br>  Desainnya terdiri dari tiga papan sirkuit tercetak yang saling terhubung.  Di papan pertama, catu daya dan relai eksekusi TRA3 dibuat.  Catu daya dibuat sesuai dengan rangkaian transformerless: kapasitor quenching digunakan untuk mengurangi tegangan.  Di papan kedua adalah ATTiny2313 MK dan elemen tambahan lainnya.  Di papan ketiga adalah sakelar (setpoint) dan LED kontrol. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/be/ew/4h/beew4hzen1salm0a6x7mlwhak2g.jpeg"></div><br>  <i>Foto papan ketiga dari belakang.</i> <br><br>  Saya akan memulai deskripsinya dengan papan ketiga.  Sakelar adalah sakelar 10 posisi.  Tidak ada tanda pada mereka, masing-masing dari mereka memiliki 5 kontak.  Oleh karena itu, tergantung pada posisinya, kontak tertentu ditutup dalam berbagai kombinasi.  Memanggil kontak, saya segera menangkap polanya: satu output tetap (umum) ditutup dengan empat output lainnya (informasi) sesuai dengan representasi biner dari angka yang sesuai dengan jumlah posisi yang dipilih.  Misalnya, jika posisi "3" dipilih, maka output umum (kelima berturut-turut) ditutup dengan output ketiga dan keempat, karena angka "3" dalam representasi biner adalah "0011".  Ini adalah saklar yang rumit.  Dan mereka bertiga.  Mereka terhubung melalui konektor XP1 dan XP2 ke papan kedua dengan MK.  Konektor XP3 menghubungkan LED dan beberapa omong kosong yang tidak perlu lainnya, yang ada tempatnya di papan tulis.  Kemungkinan besar ini adalah saklar DPDT enam pin yang umum (misalnya kotak, PB22E06 misalnya).  Mungkin papan itu universal, tetapi tidak digunakan dalam model khusus ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lo/tv/rq/lotvrq9ovoeetew2zmaa6sauury.jpeg"></div><br>  <i>Foto papan kedua (utama).</i> <br><br>  Memanggil kontak switch, saya tidak segera mengerti prinsip koneksi mereka ke port MK.  Di papan utama, 8 transistor SMD segera terbukti.  Dia kemudian menemukan bahwa transistor ini digunakan sebagai pasangan dioda dengan anoda umum.  Basis mereka menuju ke port MK, dan kolektor dan emitor pergi untuk berpindah kontak.  Kemudian mereka menjelaskan kepada saya bahwa dalam kasus seperti itu ada pasangan dioda, mereka berdering seperti transistor, tetapi mereka bukan transistor.  Secara total, kami memiliki 16 konduktor yang meninggalkan pasangan dioda di papan ketiga.  Tiga perempat dari mereka (12 buah) datang ke kontak informasi switch (tiga hingga empat), dan 4 tetap gratis.  Mudah untuk menebak bahwa secara teoritis mereka disediakan untuk saklar keempat, yang entah bagaimana tidak ada, karena tidak ada ruang untuk itu di papan tulis sama sekali.  Namun demikian, agar tidak melanggar logika penalaran, saya akan menyebutkan peralihan keempat imajiner ini.  Ujung umum dari sakelar kedua dan ketiga, serta sakelar pertama dan keempat (tetapi sakelar keempat tidak tersedia untuk papan) dihubungkan secara berpasangan oleh trek di papan utama pada konektor kawin XS1 dan XS2.  Kedua pasangan ini terhubung ke output kelompok transistor.  Kedua kelompok identik ini dibuat pada transistor BC857 dan BC847 (struktur yang berbeda).  Input mereka terhubung ke MK.  Saat menerapkan "0" logis ke input grup ini, output juga akan menjadi logis "0".  Juga, di papan ada konektor XP2 untuk firmware MK, terhubung ke terminal SPI dari antarmuka MK, konektor XS3 untuk LED dan konektor XP1 yang dihubungkan dengan kabel ke papan pertama.  Harus diingat bahwa beberapa port MK dapat digunakan baik untuk SPI (untuk firmware) dan untuk input-output biasa (berfungsi di sirkuit). <br><br>  Semua hal di atas tercermin dalam diagram yang saya buat pertama kali dalam konsep, kemudian di SPlan.  Peringkat elemen radio yang tidak ditandai (misalnya, kapasitor SMD) tidak ada dalam diagram, mereka tidak begitu penting.  Pertama, saya akan memberikan diagram papan utama dan papan dengan setter (tanda tangan dari gambar di bawah). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4c/r8/gr/4cr8gr6u5edycy869h9wuyprgs0.gif"></div><br>  <i>Skema papan utama.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pg/sx/uy/pgsxuy7cgafwqwabsx39prgwkgw.gif"></div><br><br>  <i>Skema papan ketiga dengan setter</i> <br><br>  Coba perhatikan bagaimana interogasi dari masing-masing setter.  Sinyal dari port PB4 dan PB5 MK logic "0" membuka transistor VT2 dan VT1, diikuti oleh VT4 dan VT3, yang menghubungkan masing-masing ke kontak umum bus nol dari sakelar No. 1 dan No. 2-No..  Ini terjadi pada gilirannya.  Pertama, logis "0" berasal dari PB4 (PB5 sejauh ini telah diatur ke logis "1"), menghubungkan switch kedua dan ketiga.  Dalam keadaan ini, nilai-nilai sinyal direkam pada gilirannya oleh pengontrol dari port input PB3, PB2, PB1, PB0 melalui kelompok dioda 2VD1 ... 2VD4 dari switch keempat yang hilang dan kedua.  Segera, nilai-nilai sinyal dari pin PD6, PD5, PD4, PD3 MK adalah tetap, di mana sinyal dari sakelar pertama dan ketiga datang melalui kelompok dioda 2VD5 ... 2VD8.  Namun, karena hanya sakelar kedua dan ketiga yang dihubungkan oleh kontak biasa, sinyal dari sakelar kedua akan sampai ke porta pertama yang ditentukan dari MK, dan yang keempat akan diabaikan.  Demikian pula, sinyal dari saklar ketiga akan sampai pada paruh kedua dari MK, dan yang pertama akan diabaikan.  Pada tahap ini, controller tahu di mana posisi switch kedua dan ketiga dipasang.  Setelah itu, PB4 diatur ke "unit", mematikan sakelar kedua dan ketiga, dan PB5 diatur ke "nol".  Dalam hal ini, sakelar keempat yang pertama dan yang hilang dihubungkan oleh ujung yang sama ke "kasing".  Interogasi mereka terjadi persis sama seperti dalam kasus sebelumnya, tetapi sekarang sinyal dari switch yang diabaikan terakhir kali akan direkam.  Dengan demikian, pengontrol mengetahui informasi posisi semua sakelar.  Proses ini mirip dengan polling keyboard matriks, tetapi dalam hal ini matriks 4-layer dengan dimensi 2 oleh 2 dengan satu elemen yang hilang. <br><br>  Resistor R8 ... R15 - pull-up.  Meskipun, itu mungkin untuk "menarik" di MK itu sendiri.  Frekuensi jam akurat MK menyediakan kuarsa pada 10 MHz.  R1 dan C4 - MK reset circuit.  Tidak ada yang lebih menarik di forum ini. <br><br><img src="https://habrastorage.org/webt/5u/u-/8s/5uu-8sh8ffhwe3qcxqs6gzppcqa.jpeg"><br>  <i>Foto papan (daya) pertama dari sisi elemen.</i> <br><br><img src="https://habrastorage.org/webt/oe/ln/3-/oeln3-vbwunn8pr0ku2gcwloywm.jpeg"><br>  <i>Foto papan (daya) pertama dari belakang.</i> <br><br>  Mari kita beralih ke skema papan pertama (Gbr. Di Atas).  Skema itu tampak sangat menarik dan di beberapa tempat tidak dapat dipahami. <br><br><img src="https://habrastorage.org/webt/ku/br/ys/kubrysrquhsy3n1xfwmeuvnh8qw.gif"><br>  <i>Skema papan (kekuasaan) pertama.</i> <br><br>  C1C2 - untuk mengurangi tegangan.  R1 - untuk melepaskan yang di atas.  Setelah jembatan dioda, DB1 adalah dua elektrolit.  Untuk menyulitkan sirkuit (atau untuk keandalan) - skema stabilisasi kaskade VT3R6VD3 - VT7R12VD5.  VD5 mirip dengan transistor SMD emitor yang tidak digunakan.  Ini memberikan tegangan DC yang stabil dari 12V.  Selanjutnya adalah regulator linier VR1 pada 5V.  Pada saat yang sama, tegangan dilepas dari jembatan dioda DB1 melalui dioda VD2 ke penstabil 24V VT1R3VD1 lainnya.  Tegangan ini disuplai ke koil relai rel1 EM dan ke R17.  Yang terakhir tidak jelas mengapa.  Di ujung lain R17 datang sinyal dari grup transistor VT9VT10.  Rangkaian grup ini mirip dengan sirkuit di papan utama.  Sinyal dari port PB6 MK terpisah datang ke input dari grup transistor ini melalui konektor.  Mengapa itu dibutuhkan?  Mengapa menghubungkan resistor R17 ke 24V?  Kemungkinan besar, ada gagasan bahwa alih-alih sebuah resistor, Anda dapat meletakkan sesuatu yang lain, misalnya, LED kontrol internal, dengan memprogram port PB6 MK dengan cara tertentu.  Atau node switching tambahan.  Tapi, sama saja, ini omong kosong, seperti yang dikatakan oleh teknisi radio kenalan saya, setelah melihat papan desain.  Ujung kedua rel1 relai EM terhubung ke grup transistor serupa VT2VT5, dan terhubung ke port MK PD0.  Sinyal "0" dari port ini mengaktifkan relai EM yang sedang dijalankan.  Hal yang paling menarik adalah bahwa LED eksternal terhubung tidak sejajar dengan relay EM, tetapi ke celah emitor dari transistor VT2, apalagi, melalui dua konektor (melewati papan utama).  Di terminal, pin nomor 1 dan 2, dilihat dari stiker pada relai, tetap kosong.  Tetapi dalam rangkaian, kontak No. 2 terhubung ke kabel biasa, dan kontak No. 1 diumpankan ke input dari kelompok transistor VT6VT8.  Output dari grup ini dikirim ke port PD2 MK.  Kemudian, saya membaca dalam spesifikasi untuk model relai ini bahwa kontak ini digunakan untuk mengontrol model relai lainnya, yang dirangkai dalam kasus yang sama.  Model yang saya pertimbangkan tidak melibatkan kontrol, tetapi dapat diimplementasikan ketika menulis sebuah program di MK, karena skema ini memberikan peluang ini.  Di bawah kendali dapat berarti permulaan, reset (baik dalam "pemicu" dan dalam mode normal), dan segala sesuatu yang terlintas dalam pikiran.  Spesifikasi untuk relay lainnya menunjukkan diagram waktu yang menunjukkan perilaku relay tergantung pada sinyal kontrol yang diberikan.  Ia juga mengatakan di bawah ini: atas permintaan pelanggan, kami dapat mengimplementasikan diagram yang memungkinkan.  Dan saat terakhir dalam skema.  Sinyal kontrol dari terminal No. 1 ini juga datang ke transistor VT4 yang tidak berguna, ditenagai oleh tegangan 12V.  Sekali lagi, ini adalah komplikasi dari skema tersebut.  Atau mungkin masih ada ide yang diajukan?  Saya tidak menggali lebih dalam.  Saya akan senang dengan komentar apa pun. <br><br>  Tanda-tanda terminal konektor ditandatangani melalui titik setelah nama konektor itu sendiri.  Angka Romawi setelah simbol "~" menunjukkan kesimpulan yang tidak berguna dan hilang.  Yang terakhir tidak sedikit dalam skema, tetapi saya tidak akan memikirkannya.  Di bawah ini saya memberikan sketsa dari setiap papan dengan penunjukan konektor, kesimpulan dan elemen dasar. <br><br><img src="https://habrastorage.org/webt/9g/nt/94/9gnt940dbha1c-50htijfyd3erq.gif"><br>  <i>Sketsa papan.</i> <br><br>  Pertimbangkan uraian kode sumber untuk program MK.  Program itu sendiri sederhana dan ditulis oleh saya di CVAVR selama 20 menit.  Saya akan membahas algoritma di mana program akan dieksekusi.  Informasi ini mungkin tampak cukup dangkal bagi sebagian orang, tetapi itu tidak akan berlebihan untuk pemula.  Dalam versi algoritma saya, penghitung waktu pada relay waktu akan diinterogasi tidak hanya sekali, tetapi terus menerus.  Selain itu, pemungutan suara akan berlanjut bahkan setelah estafet telah tersandung.  Ini memungkinkan Anda melakukan penyesuaian saat bepergian.  Mungkin algoritme ini tidak sesuai dengan algoritme asli untuk pengoperasian relai ini, tetapi saya tidak terbiasa dengan algoritme asli.  Pada contoh algoritma yang disebutkan di atas deskripsi program akan dipertimbangkan. <br><br><div class="spoiler">  <b class="spoiler_title">Kode sumber untuk program C dengan deskripsi.</b> <div class="spoiler_text">  Kami menghubungkan pustaka untuk bekerja dengan ATTiny2313 MK, serta pustaka fungsi penundaan. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;tiny2313.h&gt; #include &lt;delay.h&gt;</span></span></span></span></code> </pre> <br>  Selanjutnya, kami melakukan substitusi makro yang diperlukan, sesuai dengan tugas rangkaian port MK.  Pergantian ini nyaman karena dalam teks program alih-alih, misalnya, PORTB.5, Anda dapat menulis getAD, yang lebih nyaman.  Kompilasi getAD akan diartikan sebagai PORTB.  Jadi, substitusi pertama adalah output untuk menghubungkan switch setpoint pertama (A) dan keempat (D).  Yang kedua adalah untuk yang kedua (B) dan ketiga (C).  Berikutnya adalah substitusi untuk mengaktifkan relai.  Dan, akhirnya, substitusi “Ctrl” yang tidak digunakan dalam program dan dalam model yang dipertimbangkan.  Anda tidak bisa menulisnya. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> getAD PORTB.5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> getBC PORTB.4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RL PORTD.0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Ctrl PIND.2</span></span></code> </pre><br>  Variabel A, B, C digunakan untuk menyimpan nomor posisi dari tiga sakelar yang sesuai dan mengambil nilai dari 0 hingga 9. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> A,B,C;</code> </pre><br>  Variabel i - nilai saat ini dari jumlah persepuluh menit (6 detik), yaitu jumlah "centang" minimum relai.  Variabel t adalah jumlah persepuluh menit (kutu) yang diterima dari master. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>,t;</code> </pre><br>  Fungsi utama dari program ini disajikan di bawah ini.  Dalam 6 baris pertama saya tidak mengerti.  Mereka dibentuk menggunakan utilitas tambahan CodeWizadAVR dan dikaitkan dengan keberadaan kuarsa eksternal pada 10 MHz. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> optsize- CLKPR=0x80; CLKPR=0x00; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _OPTIMIZE_SIZE_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> optsize+ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  Dua baris berikut mengkonfigurasi port B dari MK kami.  Menurut skema, kami menempatkan 4 bit yang lebih rendah ke input, dan yang paling signifikan ke output (PB7 tidak digunakan, dan PB6 tidak berguna, tetapi, secara teori, output).  Oleh karena itu, sesuai dengan prinsip-prinsip konfigurasi MK, yang tidak akan saya uraikan, kami menulis angka 240 ke dalam register DDRB (F0 dalam notasi heksadesimal).  Level output awal adalah "1", kecuali untuk PB7 yang tidak perlu.  Dan untuk berjaga-jaga, mari kita hubungkan "resistor pull-up" dari MK ke input, meskipun mereka sudah dipasang di sirkuit.  Untuk melakukan ini, mari atur register PORTB ke 7F dalam notasi heksadesimal. <br><br><pre> <code class="cpp hljs">PORTB=<span class="hljs-number"><span class="hljs-number">0x7F</span></span>; DDRB=<span class="hljs-number"><span class="hljs-number">0xF0</span></span>;</code> </pre><br>  Port D dikonfigurasi dengan cara yang sama. Semua pin pada input, kecuali dua yang lebih rendah.  “Resistor pull-up” pada input dan level output awal “1” pada output serupa. <br><br><pre> <code class="cpp hljs">PORTD=<span class="hljs-number"><span class="hljs-number">0x7D</span></span>; DDRD=<span class="hljs-number"><span class="hljs-number">0x03</span></span>;</code> </pre><br>  Lima baris berikut berhubungan dengan konfigurasi salah satu penghitung waktu MK.  Timer ini enam belas digit, artinya memberikan skor hingga 2 ^ 16 = 65536.  Frekuensi penghitungan ditentukan oleh frekuensi clock MK dan koefisien pembagian (satu dari lima yang telah ditentukan).  Dalam program yang dijelaskan, diputuskan untuk menyimpan akun selama 6 detik (langkah tugas minimum), kemudian meningkatkan variabel i sebesar 1 dan mengatur ulang timer ke awal hitungan.  Untuk memastikan hal di atas, Anda perlu mengambil rasio pembagian maksimum 1024 dan menghitung hingga 58594. Yang terakhir ini mudah dihitung.  Frekuensi MK - 10.000.000 Hz.  Menggunakan rasio pembagian 1024, frekuensi timer akan menjadi 10.000.000 / 1.024 = 9.765.625 Hz, dan periode akan menjadi 1.024.000 / 10.000.000 = 0.0001024 s.  Dalam 6 detik, 6 / 0,0001024 = 58593.75 dari periode tersebut akan ditumpuk.  Angka ini terletak pada timer 16-bit, tetapi ini bukan bilangan bulat, jadi Anda harus membulatkan ke 58594. Dalam kasus ini, kesalahan relai waktu kami tidak akan signifikan: 58594-58593.75 = 0,25;  0,25 * 0,0001024 = 0,0000256;  0,0000256 * 999 = 0,0255744.  Artinya, untuk periode waktu maksimum yang dimungkinkan (99,9 menit), ketidaktepatan relay waktu ini akan menjadi sekitar 25,6 milidetik, yang cukup dapat diterima dalam praktiknya.  Omong-omong, pabrikan juga menetapkan kesalahan perangkat, dan kesalahan kita tidak akan lebih buruk.  Dalam register konfigurasi timer TCCR1B, tulis nilai 5. Tanpa masuk ke detail, ini berarti timer dimulai dan koefisien pembagian adalah 1024. Dalam register TCNT1, kami menulis nilai 0. Register ini adalah 16-bit dan dibagi menjadi dua bagian 8-bit: yang termuda (L ) dan senior (H).  Nilai ditulis untuk itu, dari mana penghitung waktu akan terus menghitung.  Kita harus menghitung dari awal.  Nilai OCR1A mendaftar sebelum timer akan membaca, setelah itu akan memanggil fungsi interupsi.  Pada saat ini, fungsi utama program terganggu, dan tindakan yang ditentukan dalam fungsi interupsi ini dilakukan.  Setelah mempraktikkan interupsi, fungsi utama akan terus dijalankan.  Nilai ini, seperti yang dikatakan di atas, sama dengan 58594 (E4E2 dalam notasi heksadesimal).  Karena register OCR1A juga dibagi menjadi dua bagian, kami menulis nilai di atas dalam beberapa bagian. <br><br><pre> <code class="cpp hljs">TCCR1B=<span class="hljs-number"><span class="hljs-number">0x05</span></span>; TCNT1H=<span class="hljs-number"><span class="hljs-number">0x00</span></span>; TCNT1L=<span class="hljs-number"><span class="hljs-number">0x00</span></span>; OCR1AH=<span class="hljs-number"><span class="hljs-number">0xE4</span></span>; OCR1AL=<span class="hljs-number"><span class="hljs-number">0xE2</span></span>;</code> </pre><br>  Dua baris berikutnya mengkonfigurasi resolusi interupsi dengan benar (jangan masuk ke detail). <br><br><pre> <code class="cpp hljs">TIMSK=<span class="hljs-number"><span class="hljs-number">0x40</span></span>; <span class="hljs-meta"><span class="hljs-meta">#asm(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sei"</span></span></span><span class="hljs-meta">)</span></span></code> </pre><br>  Dalam siklus utama, sakelar setter secara konstan disurvei (sesuai dengan algoritma dalam uraian rangkaian) menggunakan penundaan 30 ms untuk operasi yang benar dan stabil.  Dengan menetapkan nilai "0" pada PORTB.5 (getAD = 0), kami menyiapkan sakelar pertama.  Kesimpulannya terhubung ke port D dari MK ke pin 6, 5, 4, 3. Arahnya dari yang termuda ke yang tertua.  Yaitu, bit orde rendah dari sakelar terhubung ke bit orde relatif rendah (bit 3) dari port MK.  Oleh karena itu, untuk menerima informasi dari port D dari MK tentang posisi sakelar pertama, perlu untuk menggeser bitwise ke kanan dengan tiga posisi (PIND &gt;&gt; 3), membalikkan bit yang diterima dengan operasi “~” (karena informasi akan datang “0”, sesuai dengan skema) dan reset empat bit tinggi yang tidak perlu dari nilai 8-bit yang diterima.  Operasi terakhir dilakukan dengan perkalian bitwise logis dari hasil dengan angka 15 (00001111 dalam representasi biner).  Setelah operasi ini, variabel A akan diberi nilai posisi sakelar pertama.  Selanjutnya, sakelar pertama dimatikan, dan sakelar kedua dan ketiga disiapkan.  Nilai dari sakelar kedua ke variabel B diambil dari port B pada MK dengan cara yang sama, tetapi tanpa operasi shift, karena terminal sakelar ini terhubung ke pin terendah dari port B dari MK dan juga secara searah arah.  Informasi dari saklar ketiga ke variabel C dihapus dengan cara yang sama seperti dari yang pertama.  Setelah itu, sakelar kedua dan ketiga (getBC = 1) “ditutup” dan nilai yang ditetapkan (jumlah persepuluh menit) dari tiga sakelar dihitung dalam variabel t. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>){ delay_ms(<span class="hljs-number"><span class="hljs-number">30</span></span>); getAD=<span class="hljs-number"><span class="hljs-number">0</span></span>; delay_ms(<span class="hljs-number"><span class="hljs-number">30</span></span>); A=(~(PIND&gt;&gt;<span class="hljs-number"><span class="hljs-number">3</span></span>)&amp;<span class="hljs-number"><span class="hljs-number">15</span></span>); delay_ms(<span class="hljs-number"><span class="hljs-number">30</span></span>); getAD=<span class="hljs-number"><span class="hljs-number">1</span></span>; getBC=<span class="hljs-number"><span class="hljs-number">0</span></span>; delay_ms(<span class="hljs-number"><span class="hljs-number">30</span></span>); B=(~PINB)&amp;<span class="hljs-number"><span class="hljs-number">15</span></span>; C=(~(PIND&gt;&gt;<span class="hljs-number"><span class="hljs-number">3</span></span>)&amp;<span class="hljs-number"><span class="hljs-number">15</span></span>); delay_ms(<span class="hljs-number"><span class="hljs-number">30</span></span>); getBC=<span class="hljs-number"><span class="hljs-number">1</span></span>; t=<span class="hljs-number"><span class="hljs-number">100</span></span>*A+<span class="hljs-number"><span class="hljs-number">10</span></span>*B+C; } }</code> </pre><br>  Perbandingan variabel ini dan variabel waktu nyata yang serupa terjadi pada fungsi interupsi. <br><br><pre> <code class="cpp hljs">interrupt [TIM1_COMPA] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timer1_compa_isr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ i+=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i&gt;=t){ RL=<span class="hljs-number"><span class="hljs-number">0</span></span>; }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ RL=<span class="hljs-number"><span class="hljs-number">1</span></span>; } TCNT1H=<span class="hljs-number"><span class="hljs-number">0x00</span></span>; TCNT1L=<span class="hljs-number"><span class="hljs-number">0x00</span></span>; }</code> </pre><br>  Jika variabel terakhir melebihi nilai yang ditetapkan, "relai pelaksana" (RL = 0) akan dihidupkan oleh "0".  Selain itu, akan dimatikan jika, pada saat yang sama, sakelar diatur ke nilai yang lebih besar dari yang dijalankan dalam variabel i.  Dalam fungsi interupsi yang sama, variabel i bertambah 1 dan timer diatur ulang ke 0. <br><br>  Bit FUSE dihapus dari MK dan dibiarkan tidak berubah.  Saya menganalisis mereka, semuanya baik-baik saja di sana. <br><br><img src="https://habrastorage.org/webt/zv/dt/ll/zvdtllilqlufxumtsv98xelmwnc.png"><br><br><br></div></div><br>  Dengan demikian, tidak hanya diagram perangkat disalin, tetapi juga program MK dikembangkan, yang tidak berbeda dalam fungsionalitas dari yang eksklusif.  Selain itu, menjadi mungkin pada tingkat perangkat lunak untuk cukup fleksibel (dan, yang paling penting, gratis) mengubah parameter waktu perangkat dan menggunakan output kontrol (No. 1 di terminal) dalam berbagai fungsi.  Program ini sangat sederhana sehingga dapat (bahkan lebih baik) ditulis dalam assembler, tapi saya belum melakukannya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414345/">https://habr.com/ru/post/id414345/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414335/index.html">Latar belakang Roskomnadzor, apa yang kamu?</a></li>
<li><a href="../id414337/index.html">Berpikir Gaya Ramda: Kekekalan dan Objek</a></li>
<li><a href="../id414339/index.html">Tur foto hebat dari situs baru Moskow coworking #tceh</a></li>
<li><a href="../id414341/index.html">Intisari materi menarik untuk pengembang ponsel # 256 (pada 3-12 Juni)</a></li>
<li><a href="../id414343/index.html">Terjemahan Mesin Neural Google</a></li>
<li><a href="../id414347/index.html">Agresi pasif: bagaimana ia menghancurkan kehidupan kerja kita dan bagaimana menghadapinya</a></li>
<li><a href="../id414349/index.html">Dapatkan Statistik Biaya MCC: Tinkoff dan Rocketbank</a></li>
<li><a href="../id414351/index.html">Alat Musik Paling Tidak Biasa: Organ Hammond, Vako Orchestron dan Synclavier</a></li>
<li><a href="../id414353/index.html">Kivy. Dari penciptaan ke produksi adalah satu langkah. Bagian 2</a></li>
<li><a href="../id414355/index.html">Kehidupan setelah ledakan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>