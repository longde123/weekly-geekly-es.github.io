<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëãüèæ üé§ üïì Einf√ºhrung in die Alpha-Version von Volume Snapshots in Kubernetes üå™Ô∏è ü¶Ö üéç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hinweis perev. : Der Originalartikel wurde k√ºrzlich im Kubernetes-Blog ver√∂ffentlicht und von Mitarbeitern von Google und Huawei (Jing Xu, Xing Yang, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einf√ºhrung in die Alpha-Version von Volume Snapshots in Kubernetes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/426133/"><img src="https://habrastorage.org/webt/ok/pe/iy/okpeiy2vp8v36hzrr-ddpboknyi.png"><br><br>  <i><b>Hinweis</b></i>  <i><b>perev.</b></i>  <i>: Der Originalartikel wurde k√ºrzlich im Kubernetes-Blog ver√∂ffentlicht und von Mitarbeitern von Google und Huawei (Jing Xu, Xing Yang, Saad Ali) verfasst, deren Aktivit√§ten Sie sicherlich im GitHub des Projekts gesehen haben, falls Sie jemals an den Funktionen und Problemen von K8 interessiert waren mit Datenspeicherung.</i>  <i>Ingenieure sprechen √ºber den Zweck von Volume-Snapshots, ihre aktuellen Funktionen und die Grundlagen der Arbeit mit ihnen.</i> <a name="habracut"></a><br><br>  In Kubernetes v1.12 wurde eine Alpha-Version der Unterst√ºtzung f√ºr Snapshots f√ºr Volumes eingef√ºhrt.  Mit dieser Funktion k√∂nnen Sie Snapshots von Volumes erstellen und l√∂schen sowie neue Volumes aus Snapshots mit den "nativen" Mitteln des Systems erstellen - √ºber die Kubernetes-API. <br><br><h2>  Was ist ein Schnappschuss? </h2><br>  Viele Speichersysteme (wie Google Cloud Persistent Disks, Amazon Elastic Block Storage und zahlreiche lokale Speichersysteme) bieten die M√∂glichkeit, einen Snapshot (‚ÄûSnapshot‚Äú) f√ºr ein permanentes Volume zu erstellen.  Ein Snapshot ist eine Kopie eines Volumes zu einem bestimmten Zeitpunkt.  Es kann verwendet werden, um ein neues Volume bereitzustellen (das bereits mit Daten aus einem Snapshot gef√ºllt ist) oder um ein vorhandenes Volume auf den vorherigen Status zur√ºckzusetzen (der in einem Snapshot dargestellt wird). <br><br><h2>  Warum sollten Sie Kubernetes Snapshots hinzuf√ºgen? </h2><br>  Im Volume-Plug-In-System von Kubernetes ist bereits eine leistungsstarke Abstraktion verf√ºgbar, die das Bereitstellen, Verbinden und Mounten von Block- und Dateispeichern automatisiert. <br><br>  Die Bereitstellung all dieser Funktionen ist Teil der Kubernetes-Workload-Toleranzziele: Kubernetes zielt darauf ab, eine Abstraktionsebene zwischen Anwendungen, die als verteilte Systeme arbeiten, und zugrunde liegenden Clustern zu erstellen, damit Anwendungen unabh√§ngig von dem spezifischen Cluster sind, auf dem sie ausgef√ºhrt werden, und die Anwendungsbereitstellung nicht erforderlich ist jegliches clusterspezifisches Wissen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes Storage SIG hat</a> Snapshot-Vorg√§nge als wichtige Funktionen f√ºr eine Vielzahl von Stateful Workloads identifiziert.  Beispielsweise m√∂chte ein Datenbankadministrator m√∂glicherweise einen Snapshot seiner Datenbank erstellen, bevor eine Operation daran ausgef√ºhrt wird. <br><br>  Nachdem Kubernetes-Benutzer die Standardmethode zum Aufrufen von Snapshot-Vorg√§ngen in der Kubernetes-API erhalten haben, k√∂nnen sie ohne Problemumgehungen (und manuellen Aufruf von speicherspezifischen Vorg√§ngen) mit ihnen arbeiten.  Stattdessen erhielten Benutzer die M√∂glichkeit, Snapshot-Vorg√§nge in ihre Tools und Richtlinien einzubetten, mit dem ruhigen Verst√§ndnis, dass alles mit allen Kubernetes-Clustern funktioniert, unabh√§ngig vom zugrunde liegenden Speicher. <br><br>  Dar√ºber hinaus fungieren diese Kubernetes-Grundelemente als Grundbausteine ‚Äã‚Äãund er√∂ffnen den Weg f√ºr die Entwicklung fortschrittlicherer Funktionen auf Unternehmensebene f√ºr das Speichermanagement - beispielsweise f√ºr Schutz, Replikation und Datenmigration. <br><br><h2>  Welche Volume-Plugins unterst√ºtzen Snapshots in Kubernetes? </h2><br>  Kubernetes unterst√ºtzt drei Arten von Volume-Plugins: In-Tree, Flex und CSI.  Weitere Informationen finden Sie in den h√§ufig gestellten <a href="">Fragen</a> zum <a href="">Kubernetes Volume Plugin</a> . <br><br>  Snapshots werden nur f√ºr CSI-Treiber unterst√ºtzt (weder f√ºr In-Tree- noch f√ºr Flex-Treiber).  Stellen Sie sicher, dass der CSI-Treiber, der die Snapshot-Unterst√ºtzung implementiert, im Kubernetes-Cluster bereitgestellt wird, um diese Funktion nutzen zu k√∂nnen. <br><br>  Zum Zeitpunkt dieses Blogposts <i>(9. Oktober 2018 - <b>ca. √úbersetzung</b> )</i> werden Snapshots von den folgenden CSI-Treibern unterst√ºtzt: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GCE Persistent Disk</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenSDS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ceph rbd</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Portworx</a> </li></ul><br>  Die Unterst√ºtzung f√ºr Snapshots f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">andere Treiber</a> befindet sich in der Entwicklung und sollte bald verf√ºgbar sein.  Weitere Informationen zu CSI und zur Bereitstellung von CSI-Treibern finden Sie in der Ver√∂ffentlichung ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CSI (Container Storage Interface) f√ºr Kubernetes Goes Beta</a> ‚Äú <i>(und</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lesen Sie</a> <i>auch unsere √úbersetzung des Hinweises ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grundlegendes zur Container Storage Interface (in Kubernetes und mehr)</a> ‚Äú). - <b>ca. Transl.</b> )</i> . <br><br><h2>  Kubernetes API f√ºr Snapshots </h2><br>  Zum Verwalten von Snapshots f√ºhrt Kubernetes Volume Snapshots drei neue API-Objekte auf dieselbe Weise wie in der Kubernetes Persistent Volumes-API ein: <br><br><ul><li> <code>VolumeSnapshot</code> <br> <ul><li>  Erstellt vom Kubernetes-Benutzer, um einen Snapshot f√ºr das angegebene Volume anzufordern.  Enth√§lt Informationen zum Snapshot-Vorgang, z. B. den Zeitstempel zum Entfernen des Snapshots und ob er einsatzbereit ist. </li><li>  Wie beim <code>PersistentVolumeClaim</code> Objekt entspricht das Erstellen und L√∂schen dieses Objekts dem Wunsch des Benutzers, eine Clusterressource (Snapshot) zu erstellen oder zu l√∂schen. </li></ul></li><li> <code>VolumeSnapshotContent</code> <br> <ul><li>  Erstellt vom CSI-Treiber, als der Snapshot erfolgreich erstellt wurde.  Enth√§lt Informationen zum Snapshot einschlie√ülich seiner ID. </li><li>  Wie ein <code>PersistentVolume</code> Objekt stellt es eine Ressource dar, die bereits vom Cluster bedient wird (Snapshot). </li><li>  Wie bei den Objekten <code>PersistentVolumeClaim</code> und <code>PersistentVolume</code> wird beim <code>VolumeSnapshotContent</code> eines Snapshots das <code>VolumeSnapshotContent</code> Objekt an den <code>VolumeSnapshot</code> angeh√§ngt, f√ºr den es erstellt wurde (es wird eine Eins-zu-Eins-Zuordnung verwendet). </li></ul></li><li> <code>VolumeSnapshotClass</code> <br> <ul><li>  Wird von Clusteradministratoren definiert, um zu beschreiben, welche Snapshots erstellt werden k√∂nnen.  Enth√§lt Treiberinformationen, Geheimnisse f√ºr den Zugriff auf Schnappsch√ºsse usw. </li></ul></li></ul><br>  Es ist wichtig zu beachten, dass diese Snap-Shot-Objekte im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gegensatz zu den Hauptobjekten</a> f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">persistente Volumes</a> in Kubernetes als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CustomResourceDefinitions (CRDs) definiert sind</a> .  Das Kubernetes-Projekt entfernt sich allm√§hlich von vordefinierten Ressourcentypen im API-Server und n√§hert sich einem Modell, bei dem der API-Server unabh√§ngig von API-Objekten ist.  Mit diesem Ansatz k√∂nnen Sie den API-Server in anderen Projekten (au√üer Kubernetes) wiederverwenden, und Verbraucher (wie Kubernetes) k√∂nnen die Arten von Ressourcen festlegen, die sie als CRD ben√∂tigen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CSI-Treiber</a> , die Snapshots unterst√ºtzen, installieren automatisch die erforderlichen CRDs.  Kubernetes-Endbenutzer m√ºssen nur √ºberpr√ºfen, ob der CSI-Treiber, der Snapshots unterst√ºtzt, im Cluster bereitgestellt wird. <br><br>  Zus√§tzlich zu diesen neuen Objekten verf√ºgt der vorhandene <code>PersistentVolumeClaim</code> ein neues <code>DataSource</code> Feld: <br><br><pre> <code class="plaintext hljs">type PersistentVolumeClaimSpec struct { AccessModes []PersistentVolumeAccessMode Selector *metav1.LabelSelector Resources ResourceRequirements VolumeName string StorageClassName *string VolumeMode *PersistentVolumeMode DataSource *TypedLocalObjectReference }</code> </pre> <br>  In diesem Feld (im Status der Alpha-Version) k√∂nnen Sie es beim Erstellen eines neuen Volumes automatisch mit Daten aus einem vorhandenen Snapshot f√ºllen. <br><br><h2>  Kubernetes Snapshot-Anforderungen </h2><br>  Bevor Sie Volume-Snapshots in Kubernetes verwenden k√∂nnen, m√ºssen Sie: <br><br><ul><li>  Stellen Sie sicher, dass der CSI-Treiber, der Snapshots implementiert, bereitgestellt wird und auf dem Cluster ausgef√ºhrt wird. </li><li>  Aktivieren Sie die Kubernetes Volume Snapshotting-Funktion √ºber das neue Feature-Gate (standardm√§√üig f√ºr die Alpha-Version deaktiviert): <br><ul><li>  Setzen Sie das folgende Flag f√ºr die <code>--feature-gates=VolumeSnapshotDataSource=true</code> API-Server- <code>--feature-gates=VolumeSnapshotDataSource=true</code> : <code>--feature-gates=VolumeSnapshotDataSource=true</code> </li></ul></li></ul><br>  Bevor Sie einen Snapshot erstellen, m√ºssen Sie auch festlegen, welcher CSI-Treiber verwendet werden soll. <code>VolumeSnapshotClass</code> erstellen Sie ein <code>VolumeSnapshotClass</code> Objekt und geben den CSI-Treiber im Feld <code>snapshotter</code> .  Im folgenden <code>VolumeSnapshotClass</code> Beispiel ist dieser Treiber <code>com.example.csi-driver</code> .  Jeder Snapshot-Anbieter ben√∂tigt mindestens ein <code>VolumeSnapshotClass</code> Objekt.  Es ist auch m√∂glich, f√ºr jeden CSI-Treiber eine Standard- <code>VolumeSnapshotClass</code> zu definieren. Dies erfolgt durch Festlegen der Annotation <code>snapshot.storage.kubernetes.io/is-default-class: "true"</code> in der Klassendefinition: <br><br><pre> <code class="plaintext hljs">apiVersion: snapshot.storage.k8s.io/v1alpha1 kind: VolumeSnapshotClass metadata: name: default-snapclass annotations: snapshot.storage.kubernetes.io/is-default-class: "true" snapshotter: com.example.csi-driver apiVersion: snapshot.storage.k8s.io/v1alpha1 kind: VolumeSnapshotClass metadata: name: csi-snapclass snapshotter: com.example.csi-driver parameters: fakeSnapshotOption: foo csiSnapshotterSecretName: csi-secret csiSnapshotterSecretNamespace: csi-namespace</code> </pre> <br>  Alle erforderlichen Parameter m√ºssen gem√§√ü der CSI-Treiberdokumentation eingestellt werden.  Im obigen Beispiel werden der Parameter <code>fakeSnapshotOption: foo</code> und alle genannten Geheimnisse beim Erstellen und Entfernen des Snapshots an den CSI-Treiber √ºbergeben.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CSI external-snapshotter</a> speichert standardm√§√üig die Parameterschl√ºssel <code>csiSnapshotterSecretName</code> und <code>csiSnapshotterSecretNamespace</code> . <br><br>  Bevor Sie einen Snapshot erstellen, m√ºssen Sie das Volume √ºber den CSI-Treiber erstellen und mit den Daten f√ºllen, die Sie dort anzeigen m√∂chten (Einzelheiten zur Verwendung von CSI-Volumes finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser Ver√∂ffentlichung</a> ). <br><br><h2>  Erstellen eines neuen Schnappschusses in Kubernetes </h2><br>  Sobald das <code>VolumeSnapshotClass</code> Objekt definiert ist und das Volume ist, von dem Sie den Snapshot entfernen m√∂chten, k√∂nnen Sie diesen Vorgang ausf√ºhren, indem Sie das <code>VolumeSnapshot</code> Objekt <code>VolumeSnapshot</code> . <br><br>  Die Quelle f√ºr den Schnappschuss wird durch zwei Parameter bestimmt: <br><br><ul><li>  <code>kind</code> - <code>PersistentVolumeClaim</code> hier angezeigt; </li><li>  <code>name</code> - der tats√§chliche Name des PVC-Objekts. </li></ul><br>  Es versteht sich, dass der Namespace des Volumes, f√ºr das der Snapshot erstellt wird, durch den Namespace des <code>VolumeSnapshot</code> Objekts bestimmt wird. <br><br><pre> <code class="plaintext hljs">apiVersion: snapshot.storage.k8s.io/v1alpha1 kind: VolumeSnapshot metadata: name: new-snapshot-demo namespace: demo-namespace spec: snapshotClassName: csi-snapclass source: name: mypvc kind: PersistentVolumeClaim</code> </pre> <br>  Die <code>VolumeSnapshot</code> Spezifikation kann eine <code>VolumeSnapshotClass</code> <code>VolumeSnapshot</code> , die Informationen dar√ºber enth√§lt, welcher CSI-Treiber zum Erstellen des Snapshots verwendet wird.  Wie bereits berichtet, werden nach dem Erstellen des <code>VolumeSnapshot</code> Objekts der Parameter <code>fakeSnapshotOption: foo</code> und alle genannten <code>VolumeSnapshotClass</code> Geheimnisse im <code>CreateSnapshot</code> Aufruf an das CSI-Plugin <code>com.example.csi-driver</code> <code>CreateSnapshot</code> . <br><br>  Als Antwort auf eine solche Anforderung erstellt der CSI-Treiber einen Snapshot des Volumes und erstellt dann automatisch ein <code>VolumeSnapshotContent</code> Objekt, das den neuen Snapshot darstellt, und bindet dieses Objekt an den <code>VolumeSnapshot</code> , um es einsatzbereit zu machen.  Wenn der CSI-Treiber keinen Snapshot erstellen kann und einen Fehler zur√ºckgibt, meldet der Snapshot-Controller diesen Fehler im Status des <code>VolumeSnapshot</code> Objekts und <b>unternimmt keine</b> neuen Versuche (dieses Verhalten unterscheidet sich von anderen Controllern in Kubernetes - es wird implementiert, um keinen Snapshot zu unvorhersehbaren Zeiten zu erstellen). . <br><br>  Wenn die Snapshot-Klasse nicht angegeben ist, versucht der externe Snapshotter, die Standardklasse zu finden und f√ºr den erstellten Snapshot zu verwenden.  In diesem Fall sollte der CSI-Treiber, auf den der <code>snapshotter</code> in der Standardklasse verweist, dem CSI-Treiber entsprechen, auf den der <code>provisioner</code> in der PVC-Speicherklasse verweist. <br><br>  Bitte beachten Sie, dass die Alpha-Version von Snapshots f√ºr Kubernetes keine Garantie f√ºr Konsistenz bietet.  Um vollst√§ndige Daten in einem Snapshot sicherzustellen, muss die Anwendung ordnungsgem√§√ü vorbereitet werden (Anwendung stoppen, Dateisystem einfrieren usw.), bevor sie entfernt wird. <br><br>  Um zu <code>VolumeSnapshot</code> ob das <code>VolumeSnapshot</code> Objekt erstellt und dem <code>VolumeSnapshotContent</code> , k√∂nnen Sie den <code>kubectl describe volumesnapshot</code> : <br><br><ul><li>  <code>Ready</code> sollte im <code>Status</code> <code>true</code> , um anzuzeigen, dass der Volume-Snapshot zur Verwendung bereit ist. </li><li>  Das Feld <code>Creation Time</code> zeigt an, wann der Schnappschuss tats√§chlich aufgenommen wurde. </li><li>  Das Feld <code>Restore Size</code> ist die minimale Volume-Gr√∂√üe zum Wiederherstellen eines Snapshots. </li><li>  Das Feld <code>Snapshot Content Name</code> des <code>Snapshot Content Name</code> in der Spezifikation verweist auf das f√ºr diesen Snapshot erstellte <code>VolumeSnapshotContent</code> Objekt. </li></ul><br><h2>  Importieren Sie einen vorhandenen Snapshot in Kubernetes </h2><br>  Ein vorhandener Snapshot kann in Kubernetes importiert werden, indem manuell ein <code>VolumeSnapshotContent</code> Objekt erstellt wird, das diesen Snapshot darstellt.  Da <code>VolumeSnapshotContent</code> ein API-Objekt ist, das nicht an einen Namespace gebunden ist, kann nur der Systemadministrator es erstellen. <br><br>  Wenn das <code>VolumeSnapshotContent</code> Objekt erstellt wird, kann der Benutzer ein anderes Objekt erstellen - <code>VolumeSnapshot</code> - das darauf <code>VolumeSnapshot</code> .  Der externe Snapshotter-Controller markiert den Snapshot als bereit, nachdem er das Vorhandensein und die korrekte Verbindung zwischen den <code>VolumeSnapshotContent</code> <code>VolumeSnapshot</code> und <code>VolumeSnapshotContent</code> .  Ein Snapshot kann in Kubernetes verwendet werden, wenn diese Verbindung hergestellt wird. <br><br>  Das <code>VolumeSnapshotContent</code> Objekt muss mit den folgenden Feldern erstellt werden, die den <i>vorab</i> <code>VolumeSnapshotContent</code> Snapshot darstellen: <br><br><ul><li>  <code>csiVolumeSnapshotSource</code> - Informationen zur Identifizierung eines Snapshots: <br><ul><li>  <code>snapshotHandle</code> - Name / Kennung f√ºr den Snapshot.  Pflichtfeld; </li><li>  <code>driver</code> - Der CSI-Treiber, mit dem mit diesem Volume gearbeitet wurde.  Pflichtfeld.  Muss mit dem Namen des <code>snapshotter</code> im Controller (Snapshot-Controller) √ºbereinstimmen. </li><li>  <code>restoreSize</code> und <code>restoreSize</code> - F√ºr vorab <code>restoreSize</code> Volumes sind diese Felder optional.  Der externe Snapshotter-Controller aktualisiert sie automatisch, nachdem ein Snapshot erstellt wurde. </li></ul></li><li>  <code>volumeSnapshotRef</code> - Zeiger auf das <code>VolumeSnapshot</code> Objekt, an das dieses Objekt (d. <code>VolumeSnapshotContent</code> ) angeh√§ngt werden soll: <br><ul><li>  <code>name</code> und <code>namespace</code> - Name und Namespace des <code>VolumeSnapshot</code> Objekts, dessen Inhalt gebunden ist. </li><li>  <code>UID</code> - optionales Feld (f√ºr vorbereitete Volumes).  Der externe Snapshotter-Controller aktualisiert dieses Feld nach dem Binden automatisch.  Wenn der Benutzer dieses Feld definiert, m√ºssen Sie sicherstellen, dass es mit der UID des Snapshots √ºbereinstimmt, f√ºr den die Bindung erfolgt.  Wenn es keine solche Entsprechung gibt, wird der Inhalt als irrelevant angesehen (verwaistes Objekt) und daher l√∂scht der Controller sowohl ihn als auch den zugeh√∂rigen Snapshot. </li></ul></li><li>  <code>snapshotClassName</code> ist ein optionales Feld.  Der externe Snapshotter-Controller aktualisiert ihn nach dem Binden automatisch. </li></ul><br><pre> <code class="plaintext hljs">apiVersion: snapshot.storage.k8s.io/v1alpha1 kind: VolumeSnapshotContent metadata: name: static-snapshot-content spec: csiVolumeSnapshotSource: driver: com.example.csi-driver snapshotHandle: snapshotcontent-example-id volumeSnapshotRef: kind: VolumeSnapshot name: static-snapshot-demo namespace: demo-namespace</code> </pre> <br>  Ein <code>VolumeSnapshot</code> Objekt muss erstellt werden, damit der Benutzer mit dem Snapshot arbeiten kann.  In ihm: <br><br><ul><li>  <code>snapshotClassName</code> - Name der Snapshot-Klasse des Volumes.  Optionales Feld.  Wenn festgelegt, sollte das <code>snapshotter</code> Feld in der Snapshot-Klasse mit dem Namen des Snapshot-Controllers √ºbereinstimmen.  Wenn nicht festgelegt, sucht der Controller nach der Standard-Snapshot-Klasse. </li><li>  <code>snapshotContentName</code> - Der Name des Inhalts des Snapshot-Volumes.  Pflichtfeld f√ºr vorbereitete B√§nde. </li></ul><br><pre> <code class="plaintext hljs">apiVersion: snapshot.storage.k8s.io/v1alpha1 kind: VolumeSnapshot metadata: name: static-snapshot-demo namespace: demo-namespace spec: snapshotClassName: csi-snapclass snapshotContentName: static-snapshot-content</code> </pre> <br>  Wenn diese Objekte erstellt werden, bindet der Snapshot-Controller sie. Setzen Sie das Feld <code>Ready</code> (in <code>Status</code> ) auf <code>True</code> , um <code>True</code> , dass der Snapshot zur Verwendung bereit ist. <br><br><h2>  Vorbereiten eines neuen Volumes aus dem Snapshot in Kubernetes </h2><br>  Verwenden Sie das neue <code>dataSource</code> Feld in <code>PersistentVolumeClaim</code> um ein neues Volume zu erstellen, das mit Daten aus dem Snapshot-Objekt <code>dataSource</code> ist.  Es hat drei Parameter: <br><br><ul><li>  <code>name</code> - Name des <code>VolumeSnapshot</code> Objekts, das die Snapshot-Quelle darstellt; </li><li>  <code>kind</code> - sollte als <code>VolumeSnapshot</code> ; </li><li>  <code>apiGroup</code> - sollte <code>snapshot.storage.k8s.io</code> . </li></ul><br>  Es wird angenommen, dass der Namespace der Quelle - der <code>VolumeSnapshot</code> - mit dem Namespace des <code>PersistentVolumeClaim</code> <code>VolumeSnapshot</code> . <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: PersistentVolumeClaim metadata: name: pvc-restore Namespace: demo-namespace spec: storageClassName: csi-storageclass dataSource: name: new-snapshot-demo kind: VolumeSnapshot apiGroup: snapshot.storage.k8s.io accessModes: - ReadWriteOnce resources: requests: storage: 1Gi</code> </pre> <br>  Wenn das <code>PersistentVolumeClaim</code> Objekt erstellt wird, wird die Bereitstellung des neuen Volumes aufgerufen, das mit Daten aus dem angegebenen Snapshot gef√ºllt ist. <br><br><h2>  Wie f√ºge ich meinem CSI-Treiber Snapshot-Unterst√ºtzung hinzu, wenn ich Speicherentwickler bin? </h2><br>  Um Snapshots zu unterst√ºtzen, sollten dem CSI-Treiber zus√§tzliche Controller-Funktionen hinzugef√ºgt werden: <code>CREATE_DELETE_SNAPSHOT</code> und <code>LIST_SNAPSHOTS</code> sowie zus√§tzliche RPC-Controller: <code>CreateSnapshot</code> , <code>DeleteSnapshot</code> , <code>ListSnapshots</code> .  Einzelheiten finden Sie in <a href="">der CSI-Spezifikation</a> . <br><br>  Obwohl Kubernetes die <a href="">grundlegendsten Richtlinien</a> zum Packen und Bereitstellen des CSI-Volume-Treibers bietet, gibt es einen <a href="">empfohlenen Mechanismus</a> zum Bereitstellen eines beliebigen containerisierten CSI-Treibers in Kubernetes, um diesen Prozess zu vereinfachen. <br><br>  Als Teil des empfohlenen Bereitstellungsprozesses schl√§gt das Kubernetes-Team vor, eine Vielzahl von Seitenwagen- (d. H. Hilfs-) Containern zu verwenden, einschlie√ülich eines Seitenwagen-Containers mit einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">externen Snapshotter</a> . <br><br>  Der erw√§hnte externe Snapshotter √ºberwacht die <code>VolumeSnapshot</code> und <code>VolumeSnapshotContent</code> Objekte auf dem API-Server und ruft die <code>DeleteSnapshot</code> <code>CreateSnapshot</code> und <code>DeleteSnapshot</code> f√ºr den CSI-Endpunkt auf.  Der Beiwagencontainer mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">externen</a> CSI <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">-Provisioner wurde</a> ebenfalls aktualisiert, um die Volumenwiederherstellung aus Snapshots mithilfe des neuen <code>dataSource</code> PVC <code>dataSource</code> zu unterst√ºtzen. <br><br>  Um Snapshot-Funktionen zu unterst√ºtzen, wird Speicherherstellern empfohlen, Sidecar-Container mit einem externen Snapshotter zus√§tzlich zu einem externen Provisioner <code>StatefulSet</code> und den CSI-Treiber in einem <code>StatefulSet</code> , wie in der folgenden Abbildung dargestellt: <br><br><img src="https://habrastorage.org/webt/9e/og/xm/9eogxmximi8i_y-6tlhber-xjts.png"><br><br>  In <a href="">diesem Bereitstellungsbeispiel gibt</a> es zwei Sidecar-Container, einen externen Provisioner und einen externen Snapshotter, und die CSI-Treiber werden mit dem CSI-Hostpfad-Plugin im StatefulSet-Pod bereitgestellt.  Der CSI-Hostpfad ist ein Beispiel-Plugin, das nicht f√ºr die Verwendung in der Produktion vorgesehen ist. <br><br><h2>  Was sind die Einschr√§nkungen der Alpha-Version? </h2><br>  Die Alpha-Version der Snapshot-Implementierung in Kubernetes weist die folgenden Einschr√§nkungen auf: <br><br><ul><li>  Das Zur√ºcksetzen eines vorhandenen Volumes auf einen vorherigen Status, der durch einen Snapshot dargestellt wird, wird nicht unterst√ºtzt (nur die Bereitstellung eines neuen Volumes aus einem Snapshot wird unterst√ºtzt). </li><li>  Die direkte Wiederherstellung wird f√ºr vorhandene <code>PersistentVolumeClaim</code> aus dem Snapshot nicht unterst√ºtzt: d. H.  Das Bereitstellen eines neuen Volumes aus dem Snapshot funktioniert, das vorhandene <code>PersistentVolumeClaim</code> wird jedoch nicht aktualisiert, sodass es auf ein neues Volume verweist und das PVC auf einen fr√ºheren Status zur√ºckgesetzt wird (es wird nur die Verwendung eines neuen Volumes unterst√ºtzt, das aus einem Snapshot √ºber ein neues PV / PVC erstellt wurde). </li><li>  Garantien f√ºr die Konsistenz von Snapshots gehen nicht √ºber die Garantien des Speichersystems hinaus (z. B. Integrit√§t beim L√∂schen). </li></ul><br><h2>  Was weiter? </h2><br>  Das Kubernetes-Team plant, die Implementierung von Snapshots f√ºr CSI in den Beta-Versionen 1.13 oder 1.14 in die Beta-Version zu bringen, abh√§ngig vom erhaltenen Feedback und der Anpassung der Technologie. <br><br><h2>  Wie erfahre ich mehr Details? </h2><br>  Weitere Snapshot-Dokumentation finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">k8s.io/docs/concepts/storage/volume-snapshots</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kubernetes-csi.github.io/docs</a> . <br><br><h2>  PS vom √úbersetzer </h2><br>  Lesen Sie auch in unserem Blog: <br><br><ul><li>  ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes 1.12: √úberblick √ºber wichtige Innovationen</a> ‚Äú; </li><li>  ‚ÄûWir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verstehen die Container Storage Interface (nicht nur in Kubernetes)</a> ‚Äú; </li><li>  ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rook ist ein Self-Service-Data-Warehouse f√ºr Kubernetes</a> ‚Äú. </li><li>  ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unsere Erfahrung mit Kubernetes in kleinen Projekten</a> ‚Äú <i>(R√ºckblick und Videobericht)</i> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Monitoring und Kubernetes</a> " <i>(R√ºckblick und Videobericht)</i> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426133/">https://habr.com/ru/post/de426133/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426119/index.html">Altert√ºmer: Cryptonomicon Iron</a></li>
<li><a href="../de426121/index.html">MC.exe (Nachrichten-Compiler), rc.exe, link.exe zum Generieren einer DLL f√ºr EventMessageFile</a></li>
<li><a href="../de426123/index.html">Lerne OpenGL. Lektion 6.1. PBR oder physikalisch korrektes Rendern. Theorie</a></li>
<li><a href="../de426125/index.html">Karriere Steroide. Aufz√ºge</a></li>
<li><a href="../de426131/index.html">Laden Sie die Konfiguration √ºber USB auf das FPGA herunter oder zerlegen Sie FTDI MPSSE</a></li>
<li><a href="../de426135/index.html">Private Cloud f√ºr das Internet der Dinge</a></li>
<li><a href="../de426137/index.html">Zeitalter der Ehrlichkeit</a></li>
<li><a href="../de426141/index.html">Red Hat ersetzt Docker durch Podman</a></li>
<li><a href="../de426143/index.html">3D-Animation - Video oder interaktiv?</a></li>
<li><a href="../de426145/index.html">Unabh√§ngiger Akzeptanzworkshop, 23. Oktober, Moskau</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>