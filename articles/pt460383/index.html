<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèéÔ∏è ‚öìÔ∏è üéß As transi√ß√µes de tela em Legend of Zelda usam os recursos n√£o documentados do NES üëó üë©üèΩ‚Äçüî¨ üë®üèΩ‚Äçü§ù‚Äçüë®üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Para o efeito de rolagem vertical na primeira parte de "The Legend of Zelda", s√£o usadas manipula√ß√µes gr√°ficas de "hardware" do NES, provavelmente n√£o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>As transi√ß√µes de tela em Legend of Zelda usam os recursos n√£o documentados do NES</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460383/">  Para o efeito de rolagem vertical na primeira parte de "The Legend of Zelda", s√£o usadas manipula√ß√µes gr√°ficas de "hardware" do NES, provavelmente n√£o fornecidas pelos desenvolvedores do console. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/631/466/3d0/6314663d04d4e3ed0d86c7e6d9b8611a.png" width="512"></div><br>  N√£o tenho acesso √† documenta√ß√£o oficial da Unidade de processamento de imagens (PPU - chip gr√°fico) do console NES; portanto, √© mais prov√°vel que minhas declara√ß√µes sobre "comportamento indefinido" sejam suposi√ß√µes.  Peguei a especifica√ß√£o do hardware gr√°fico do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">NesDev Wiki</a> .  A PPU √© controlada escrevendo nos registros com mapeamento de mem√≥ria.  Se voc√™ usar esses registros da maneira que (aparentemente) foi concebida pelos designers, seria imposs√≠vel obter esse efeito: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a5/b0e/51c/8a5b0e51c195fb1e9ba9ca282f54e61a.gif" width="512"></div><br>  Ao rolar a tela na vertical, a tela inteira deve rolar de uma s√≥ vez.  O GIF anterior mostra um exemplo de rolagem vertical parcial.  Parte da tela permanece estacion√°ria (elementos da interface) e a outra parte (√°rea de jogo) rola verticalmente.  A rolagem vertical parcial √© imposs√≠vel de implementar com o trabalho "padr√£o" com PPU. <br><br>  Por outro lado, a rolagem <em>horizontal</em> parcial √© totalmente definida e poss√≠vel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae7/c29/539/ae7c295393f6706e17e788e0a1cc39e7.gif" width="512"></div><br>  A grava√ß√£o em um registro PPU separado no momento em que o quadro √© desenhado pode levar a artefatos gr√°ficos.  A Lenda de Zelda intencionalmente causa um artefato que se manifesta como rolagem vertical parcial.  Nesta postagem, falarei um pouco sobre o hardware gr√°fico do NES e explicarei como o truque de rolagem vertical funciona. <br><a name="habracut"></a><br><h2>  Tipos de gr√°ficos </h2><br>  O console do NES possui dois tipos de gr√°ficos: <br><br><ul><li>  Sprites s√£o pe√ßas que podem ser colocadas em locais arbitr√°rios na tela e movidas independentemente uma da outra. </li><li>  Plano de fundo - uma grade de blocos que pode ser rolada suavemente como uma √∫nica imagem. </li></ul><br>  Para demonstrar a diferen√ßa entre os dois, mostrarei uma cena composta de sprites e plano de fundo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f75/f9b/138/f75f9b138db2e818cbdb9b2fb1e7b27b.gif" width="512"></div><br>  E aqui est√° a mesma cena em que apenas sprites s√£o vis√≠veis: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e8/26d/817/5e826d817b637fc450046aee1473abaf.gif" width="512"></div><br>  E aqui est√° uma cena em que apenas o fundo √© vis√≠vel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d81/b9c/bd7/d81b9cbd7bb5101f663d4decc5ebaef7.gif" width="512"></div><br><h2>  Rolagem </h2><br>  O processador de imagem (NES Picture Processor) suporta rolagem de imagens de fundo.  Na mem√≥ria gr√°fica, o gr√°fico de plano de fundo √© armazenado como uma grade bidimensional de ladrilhos que cobrem uma √°rea com o dobro da largura e altura da tela. <br><br>  Uma ‚Äújanela‚Äù √© exibida na tela nesta grade, do tamanho de uma tela, e a posi√ß√£o dessa janela pode ser controlada com precis√£o.  Movendo gradualmente a janela vis√≠vel ao longo da grade, √© criado um efeito de rolagem suave. <br><br>  O sinal de v√≠deo NES de sa√≠da tem um tamanho de 256x240 pixels.  A grade de blocos dentro da mem√≥ria √© representada como uma √°rea de 512x480 pixels e √© dividida em quatro ret√¢ngulos do tamanho de uma tela chamados "tabelas de nomes".  Os jogos podem configurar a unidade de processamento de imagens (PPU), indicando a posi√ß√£o da janela vis√≠vel, selecionando a coordenada de pixel na grade das tabelas de nomes. <br><br>  Quando voc√™ seleciona a coordenada (0, 0), toda a tabela de nomes no canto superior esquerdo ser√° exibida na tela: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d3/b5d/47f/5d3b5d47f8efdfcac271a2a7e0222e57.png"></div><br>  Passando para (125, 181), veremos um pouco de cada tabela de nomes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/912/78f/189/91278f1891416d9f15a69238e64d1422.png"></div><br>  A janela vis√≠vel √© minimizada na parte traseira da grade de blocos na mem√≥ria.  Passando para (342, 290), colocamos o canto superior esquerdo da tela vis√≠vel dentro da tabela de nomes inferior direita e, gra√ßas √† dobragem, partes de cada tabela de nomes estar√£o vis√≠veis: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e6/394/c93/6e6394c9325985807a97765ebe015bcf.png"></div><br><h3>  Mem√≥ria insuficiente! </h3><br>  Cada tabela de nomes tem um tamanho de 1 KB, mas o NES aloca apenas 2 KB de sua mem√≥ria de v√≠deo para essas tabelas, portanto, apenas duas tabelas de nomes podem caber na mem√≥ria por vez. <br><br>  Como ele pode ter quatro tabelas de nomes? <br><br><h4>  Espelhamento de tabelas de nomes </h4><br>  A mem√≥ria de v√≠deo √© conectada √† PPU de tal maneira que, quando a PPU renderiza um bloco de uma das quatro tabelas de nomes aparentes, na verdade uma das duas tabelas reais √© selecionada e a leitura vem da√≠.  Em ess√™ncia, isso significa que as quatro tabelas de nomes vis√≠veis s√£o realmente compostas por dois pares id√™nticos de tabelas. <br><br>  Esta imagem mostra uma captura instant√¢nea do conte√∫do de todas as quatro tabelas.  O canto superior esquerdo e o canto superior direito s√£o os mesmos que os dois inferiores. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/051/5b8/9b2/0515b89b2afcf122ce8df6e97e97a0a8.png" width="1024"></div><br>  Por que simplesmente n√£o manter duas tabelas de nomes? <br><br>  Felizmente, a liga√ß√£o exata entre as tabelas aparente e a real pode ser configurada em tempo de execu√ß√£o.  Se o jogo quiser executar a rolagem horizontal, ele ajusta o equipamento gr√°fico para que as tabelas superior esquerda e superior direita sejam diferentes e possam ser roladas sem duplica√ß√£o percept√≠vel.  Nessa configura√ß√£o, as tabelas superior esquerda e inferior esquerda se referem √† mesma tabela de nome real;  da mesma forma para as duas tabelas certas.  Essa configura√ß√£o √© chamada de espelhamento vertical. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e3/d85/49d/1e3d8549d5427f7f7271595dc5c6f49b.png"></div><br>  H√° tamb√©m outra configura√ß√£o poss√≠vel - ‚ÄúEspelhamento Horizontal‚Äù, que os jogos usam para rolagem vertical. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/650/6a2/528/6506a2528cba5d758301f72c80f48e8b.png"></div><br>  Normalmente, os jogos n√£o rolam na diagonal, porque cria artefatos ao redor das bordas da tela devido ao espelhamento das tabelas de nomes. <br><br><h3>  Cartuchos </h3><br>  O cartucho de cada jogo possui um hardware que permite configurar o espelhamento de tabela. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a44/8ed/3dc/a448ed3dc3849ac558d39ba0bfc5309d.jpg" width="50%"></div><br>  Alguns jogos n√£o precisam mudar o espelhamento, portanto o espelhamento horizontal ou vertical √© codificado em seus cartuchos.  Outros jogos alternam dinamicamente entre esses dois modos, portanto, o espelhamento em seus cartuchos √© configurado programaticamente.  The Legend of Zelda pertence √† segunda categoria.  Finalmente, os cartuchos de alguns jogos realmente complexos t√™m mem√≥ria de v√≠deo adicional, ou seja, eles n√£o precisam de espelhamento: eles podem rolar simultaneamente na vertical e na horizontal sem artefatos vis√≠veis de duplica√ß√£o. <br><br><h3>  Exemplo real </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0a/d58/80e/d0ad5880e16ce58d53ee2eb922c4da04.gif" width="512"></div><br>  <i>Um exemplo de rolagem vertical exibida na tela.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bb/ff0/b01/7bbff0b019dadb96e423ebc744aeb12c.gif" width="1024"></div><br>  <i>Isso mostra um registro de tabelas de nomes com espelhamento horizontal.</i>  <i>A janela atualmente vis√≠vel √© destacada.</i> <br><br>  Lembre-se de que a rolagem mais vertical n√£o √© incomum - a coisa incomum √© a rolagem vertical com <em>tela dividida</em> . <br><br><h2>  Tela dividida </h2><br>  Cada quadro do sinal de v√≠deo gerado pelo NES √© renderizado de cima para baixo, uma linha de pixels por vez.  Em cada linha, os pixels s√£o desenhados um de cada vez, da esquerda para a direita.  No meio da renderiza√ß√£o do quadro, o jogo pode reconfigurar a PPU, o que afeta a exibi√ß√£o dos pixels que ainda n√£o foram renderizados.  Uma das altera√ß√µes mais comuns no meio do quadro √© atualizar a posi√ß√£o de rolagem horizontal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/873/536/98f/87353698fa1a10a55f37d5f56ebfaefd.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c64/502/8e9/c645028e950b7e202815d7c4ad560fac.gif" width="1024"></div><br>  Ao rolar horizontalmente entre as salas, The Legend of Zelda sempre come√ßa na posi√ß√£o de rolagem (0, 0) e renderiza os elementos da interface na parte superior da tela.  Depois de desenhar a √∫ltima linha de pixels da interface na tela, a rolagem horizontal muda em um valor que aumenta a cada quadro, para que a c√¢mera se mova sem problemas. <br><br>  A anima√ß√£o da exibi√ß√£o das tabelas de nomes mostra como o jogo muda do espelhamento horizontal para o vertical antes de rolar e, em seguida, novamente para o horizontal ap√≥s a conclus√£o da transi√ß√£o.  Al√©m disso, enquanto a rolagem continua, as tabelas de nomes superior esquerdo (e inferior esquerdo) s√£o atualizadas e uma c√≥pia da sala em que o jogador entra √© gravada nelas.  Ap√≥s a rolagem, o jogo deixa de dividir a tela e novamente √© renderizado inteiramente da tabela superior esquerda. <br><br><h3>  Medi√ß√£o de renderiza√ß√£o </h3><br>  Para dividir a tela na posi√ß√£o desejada, o jogo precisa descobrir de alguma forma qual parte do quadro atual foi desenhada.  As seq√º√™ncias de pixels s√£o renderizadas em uma frequ√™ncia conhecida, portanto, o n√∫mero das seq√º√™ncias de pixels renderizadas pode ser determinado contando o n√∫mero de ciclos do processador que passaram desde o in√≠cio do quadro. <br><br>  Existe outra t√©cnica mais precisa, chamada Sprite Zero Hit. <br><br>  O NES pode renderizar at√© 64 sprites por vez.  O primeiro sprite na mem√≥ria de v√≠deo √© chamado Sprite Zero (zero sprite).  Em cada quadro, assim que um pixel opaco de um sprite zero √© sobreposto a um pixel de fundo opaco, o evento Sprite Zero Hit ocorre.  Ele define um pouco em um dos registradores PPU com mapeamento de mem√≥ria, que pode ser verificado pelo processador. <br><br>  Para usar o Sprite Zero Hit para dividir a tela, os jogos colocam o sprite zero em uma posi√ß√£o vertical perto da borda dividida e, durante a renderiza√ß√£o, eles constantemente verificam se o evento Sprite Zero Hit ocorreu.  Nesse caso, o jogo muda da rolagem horizontal para implementar a separa√ß√£o. <br><br>  A transi√ß√£o horizontal entre salas com e sem fundo √© mostrada abaixo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/71b/27a/076/71b27a0768844603020981c26b3f5124.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c4/4c1/95d/2c44c195dfac0b6c2d6b10aaf11674aa.gif" width="512"></div><br><br>  O c√≠rculo marrom que aparece no in√≠cio da transi√ß√£o e desaparece no final √© um sprite zero.  Vamos dar uma olhada na interface com e sem fundo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39b/373/83d/39b37383d425937e8e5cdb598656bac5.png" width="322"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c7d/6f9/ebe/c7d6f9ebeb7c7e066e6d349eb8c57914.png" width="322"></div><br>  Um sprite zero √© um sprite de bomba branqueada que combina perfeitamente com o sprite de bomba comum da interface do jogo.  O sprite zero est√° configurado para aparecer em segundo plano, mas como os pixels pretos da interface s√£o considerados transparentes, a bomba de sprite zero seria vis√≠vel se n√£o estivesse estrategicamente escondida atr√°s da bomba a partir da interface. <br><br>  Observe que o Sprite Zero Hit ocorre algumas linhas de pixels antes da linha inferior da interface.  Ocorre no pixel superior do fus√≠vel da bomba, que fica a 16 pixels da parte inferior da interface.  Quando o Sprite Zero Hit ocorre, o jogo come√ßa a contar os ciclos do processador e, ap√≥s completar o n√∫mero necess√°rio de ciclos, define a rolagem horizontal. <br><br><h2>  Supress√£o do feixe </h2><br>  Na maioria das vezes, o PPU do console atrai pixels para a tela.  H√° um curto tempo de inatividade entre os quadros durante os quais a renderiza√ß√£o n√£o √© executada.  Esse fen√¥meno √© chamado de apagamento (vertical em branco ou vblank).  Alguns tipos de altera√ß√µes na configura√ß√£o da PPU podem ser feitas apenas durante o vblank. <br><br><h2>  Registro de rolagem </h2><br>  Os jogos alteram a posi√ß√£o de rolagem gravando no registro PPU chamado <code>PPUSCROLL</code> , que mapeia para o endere√ßo de mem√≥ria <code>0x2005</code> .  A primeira opera√ß√£o de grava√ß√£o no <code>PPUSCROLL</code> define o componente X da posi√ß√£o de rolagem e a segunda opera√ß√£o define o componente Y. Da mesma forma, a grava√ß√£o alternativa √© realizada ainda mais. <br><br>  A seguir, s√£o mostradas todas as opera√ß√µes de grava√ß√£o diferentes de zero no <code>PPUSCROLL</code> durante esta reprodu√ß√£o (em c√¢mera lenta) de 16 quadros da tela com a plotagem do jogo.  O componente de posi√ß√£o de rolagem Y √© incrementado a cada dois quadros.  Todas as opera√ß√µes de grava√ß√£o no <code>PPUSCROLL</code> neste exemplo s√£o realizadas durante o vblank, o que faz com que todo o plano de fundo role junto com ele. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cad/0d1/003/cad0d1003d55488a17d988e6607739f2.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bc/ffb/c09/1bcffbc09db9bfe792ba85981acbe4b3.gif" width="1024"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kg/rz/fi/kgrzfigaydwrvo3qqth5bcmkecq.png"></div><br><h3>  Tela de rolagem dividida </h3><br>  As opera√ß√µes de <code>PPUSCROLL</code> no <code>PPUSCROLL</code> durante o vblank entram em vigor no in√≠cio do quadro desenhado imediatamente ap√≥s o vblank.  Se a posi√ß√£o de rolagem mudar durante a renderiza√ß√£o do quadro (ou seja, n√£o durante o vblank), essa altera√ß√£o entrar√° em vigor quando o desenho atingir a pr√≥xima linha de pixels.  A rolagem horizontal parcial √© implementada escrevendo para <code>PPUSCROLL</code> enquanto o PPU desenha a √∫ltima linha de pixels antes da rolagem. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddf/e12/b49/ddfe12b49ce180cb921243f32e77351a.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4be/38c/0bb/4be38c0bb335a414ce99a2c8d2145009.gif" width="1024"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cu/uu/1t/cuuu1twsw4wbeynzisaewszsqo8.png"></div><br>  Ao atualizar a posi√ß√£o de rolagem no meio do quadro, apenas a posi√ß√£o X da posi√ß√£o de rolagem √© aplicada.  Ou seja, o componente de posi√ß√£o de rolagem Y √© descartado.  Assim, se o jogo quiser dividir a tela e mudar a posi√ß√£o de rolar parte do quadro, ele poder√° rolar apenas horizontalmente. <br><br>  E, no entanto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a0/93e/4b7/1a093e4b76c8382f08d33b4202391094.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/760/184/2b0/7601842b02f37dc10abd97b93e0a9ec2.gif" width="1024"></div><br>  Acredite ou n√£o, o valor do registro <code>PPUSCROLL</code> n√£o mudou durante esta transi√ß√£o. <br><br>  Voc√™ pode ver um artefato gr√°fico com um pixel de altura sob a interface.  Este √© um erro do meu emulador causado pela falta de sincroniza√ß√£o dos ciclos de clock do processador com a renderiza√ß√£o pixel por pixel. <br><br><h3>  Interven√ß√£o em outros registros </h3><br>  O segundo registro, chamado <code>PPUADDR</code> , mapeado para o endere√ßo de mem√≥ria <code>0x2006</code> , √© usado para definir o endere√ßo de mem√≥ria de v√≠deo atual.  Quando um jogo, por exemplo, deseja alterar um dos blocos na tabela de nomes, primeiro grava o endere√ßo de mem√≥ria de v√≠deo do <code>PPUADDR</code> em <code>PPUADDR</code> e, em seguida, grava o novo valor do <code>PPUDATA</code> em <code>PPUDATA</code> - este √© o terceiro registro mapeado para o endere√ßo <code>0x2007</code> . <br><br>  Gravar no <code>PPUADDR</code> n√£o durante o vblank (ou seja, ao renderizar um quadro) pode causar artefatos gr√°ficos.  Isso ocorre porque a cadeia PPU, que √© afetada pela grava√ß√£o no <code>PPUADDR</code> , tamb√©m √© diretamente controlada pelo dispositivo PPU no processo de obten√ß√£o de blocos da mem√≥ria de v√≠deo para desenh√°-los.  Como o processo de renderiza√ß√£o na tela √© realizado de cima para baixo e da esquerda para a direita na linha, a PPU atribui essencialmente a <code>PPUADDR</code> valor do endere√ßo do <code>PPUADDR</code> atual que <code>PPUADDR</code> desenhado.  Quando a renderiza√ß√£o √© movida de um bloco para outro, o <code>PPUADDR</code> √© incrementado pelo valor atual. <br><br>  Assim, a grava√ß√£o em <code>PPUADDR</code> no meio do quadro pode alterar os blocos recebidos pela PPU da mem√≥ria durante o quadro atual. <br><br>  Vamos <code>PPUADDR</code> opera√ß√µes de grava√ß√£o para o <code>PPUADDR</code> durante o salto vertical.  Como a tabela de nomes tamb√©m √© atualizada durante a transi√ß√£o, a sa√≠da de <em>todas as</em> opera√ß√µes de grava√ß√£o no <code>PPUADDR</code> ser√° muito extensa.  Com uma transi√ß√£o horizontal, a rolagem √© definida durante a renderiza√ß√£o de uma linha de pixels 63, portanto, consideraremos opera√ß√µes de grava√ß√£o no <code>PPUADDR</code> somente durante essa linha. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a0/93e/4b7/1a093e4b76c8382f08d33b4202391094.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/760/184/2b0/7601842b02f37dc10abd97b93e0a9ec2.gif" width="1024"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3b/w0/iw/3bw0iwoau9zl8frbuh-mgh78-ia.png"></div><br>  O padr√£o √© claramente vis√≠vel.  A cada dois quadros, o endere√ßo registrado na linha de pixels 63 √© reduzido em 32 (0x20).  Mas como isso leva a uma atualiza√ß√£o na posi√ß√£o real de rolagem? <br><br><h3>  <i>Real</i> Scrolling Register </h3><br>  Dentro da PPU, h√° um registro de 15 bits n√£o mapeado para a CPU.  √â usado como o endere√ßo atual para acessar a mem√≥ria de v√≠deo e como uma configura√ß√£o de rolagem em segundo plano. <br><br>  Ao trabalhar com esse valor como um endere√ßo, o bit 14 √© ignorado e os bits 0-13 s√£o tratados como um endere√ßo na mem√≥ria de v√≠deo. <br><br>  Ao trabalhar com esse valor como uma configura√ß√£o de rolagem, suas diferentes partes t√™m significados diferentes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ra/ot/-q/raot-qzjvlglrxraw3kyrpskouk.png"></div><br>  <strong>Selecionar uma tabela de nomes</strong> √© um valor de 0 a 3 que determina a tabela de nomes atual a partir da qual o desenho √© feito. <br><br>  <strong>A rolagem grossa em X</strong> e a <strong>rolagem grossa em Y</strong> determinam a coordenada do bloco dentro da tabela de nomes selecionada.  Este √© o bloco atual a ser desenhado. <br><br>  <strong>A rolagem exata ao longo de Y</strong> cont√©m um valor de 0 a 7, que determina o deslocamento vertical atual da linha de pixels dentro do bloco atual.  As pe√ßas s√£o quadrados com um lado de 8 pixels. <br><br>  <strong>A rolagem exata no X</strong> est√° ausente neste registro.  H√° um registro separado contendo apenas o deslocamento horizontal do pixel atual, mas n√£o √© importante para explicar como a rolagem vertical √© realizada em The Legend of Zelda. <br><br>  O que acontece com esse registro quando um jogo grava no <code>PPUADDR</code> ?  Aqui est√£o as tr√™s primeiras opera√ß√µes de grava√ß√£o da demonstra√ß√£o mostrada acima. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nm/km/2b/nmkm2bpk5osxvd1ohc4kmne7ck4.png"></div><br>  Ao dividir as entradas no endere√ßo em componentes de rolagem, voc√™ pode entender claramente o que est√° acontecendo aqui.  A cada dois quadros, o valor da <strong>rolagem aproximada em Y</strong> diminui, o que leva √† rolagem vertical em um bloco ou 8 pixels. <br><br>  Ao longo de cada quadro, o deslocamento de rolagem inicial √© 0,0, ap√≥s o qual a grava√ß√£o na linha de pixels 63 √© realizada no endere√ßo.  Isso significa que as primeiras 63 linhas de pixels s√£o desenhadas na parte superior da tabela de nomes selecionada que cont√©m o plano de fundo da interface.  No entanto, a 64¬™ linha de pixels √© renderizada ainda mais com a rolagem vertical aplicada a partir desse endere√ßo.  Como a rolagem vertical diminui a cada dois quadros, d√° a sensa√ß√£o de rolagem vertical de uma parte da tela. <br><br><h3>  Role para baixo para rolar para cima </h3><br>  The Legend of Zelda n√£o pode esconder esse truque dos jogadores completamente.  Ele cria um artefato vis√≠vel nas transi√ß√µes verticais da tela, que s√£o percept√≠veis se voc√™ olhar atentamente.  Ao se mover entre as salas, o primeiro quadro da anima√ß√£o de rolagem rolar√° para baixo.  Aqui est√° a anima√ß√£o em c√¢mera muito lenta. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af8/a8c/79d/af8a8c79d1b4c50280c31fbf1540852a.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a52/e37/9a6/a52e379a6e5d6dd444fe115d484bb846.gif" width="1024"></div><br>  Na tabela de nomes, voc√™ pode ver o que realmente est√° acontecendo.  Embora possa parecer aos jogadores que a √°rea vis√≠vel ir√° rolar para cima sem problemas, a transi√ß√£o da rolagem come√ßa movendo a √°rea vis√≠vel da tabela superior esquerda de nomes para a tabela inferior esquerda, que cont√©m uma c√≥pia do plano de fundo da sala.  Isso √© necess√°rio porque a interface na parte superior da tela tamb√©m faz parte da tabela de nomes e, se a √°rea vis√≠vel rolou para cima a partir de sua posi√ß√£o original, ela passaria pela interface. <br><br>  A rolagem vertical √© implementada gravando no registro <code>PPUADDR</code> no meio do quadro.  O primeiro valor a ser gravado √© <code>0x2800</code> .  Dois quadros depois, <code>0x23A0</code> gravado e o valor come√ßa a diminuir em 32 a cada segundo quadro. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pk/la/gh/pklagh4idqhd3jg_mfkojhfv0lq.png"></div><br>  Gravar o valor <code>0x2800</code> no registro <code>0x2800</code> <code>PPUADDR</code> <strong>Tabela de</strong> <code>PPUADDR</code> como 2, que renderiza a tabela de nomes inferior esquerda.  Como os dois valores de rolagem s√£o 0, ele come√ßar√° no bloco superior esquerdo desta tabela de nomes.  No entanto, a <strong>rolagem exata em Y</strong> √© 2, portanto, h√° um deslocamento vertical de dois pixels na parte superior da tabela de nomes inferior esquerda.  √â por isso que, no primeiro quadro da transi√ß√£o, vemos uma barra preta com 2 pixels de altura na parte inferior da tela.  O valor de rolagem inicial da anima√ß√£o de transi√ß√£o √© deslocado 2 pixels para baixo para tornar a transi√ß√£o perfeita. <br><br>  Dois quadros depois, o <code>PPUADDR</code> gravado em <code>0x23A0</code> .  Isso nos leva de volta √† tabela de nomes no canto superior esquerdo e renderizamos a partir da 29¬™ linha de pe√ßas, ou seja, a parte inferior.  <strong>A rolagem exata em Y</strong> ainda cont√©m 2. <br><br>  Por que √© necess√°rio <strong>definir a rolagem exata em Y</strong> para 2?  Por que o jogo n√£o escreve apenas <code>0x0800</code> e <code>0x03A0</code> para n√£o sofrer um deslocamento de dois pixels? <br><br>  Quatro tabelas de nomes ocupam a √°rea de 4 KB no espa√ßo de endere√ßo PPU, de <code>0x2000</code> a <code>0x2FFF</code> .  Cada bloco na tabela ocupa um byte da mem√≥ria de v√≠deo (na verdade, s√£o apenas √≠ndices em outra tabela), e a ordem dos blocos e tabelas de nomes na mem√≥ria de v√≠deo √© tal que <strong>Selecionando uma tabela de nomes</strong> , <strong>rolagem grossa por Y</strong> e <strong>rolagem grossa por X</strong> comp√µem o deslocamento do bloco dentro √°reas de mem√≥ria com tabelas de nomes.  Ou seja, pegando os 12 bits mais baixos do registro PPU interno e adicionando-os a <code>0x2000</code> , √© poss√≠vel encontrar o endere√ßo do <code>0x2000</code> na mem√≥ria de v√≠deo.  E isso n√£o √© coincid√™ncia!  √â exatamente assim que o registro deve ser tratado: como um registro de endere√ßo e como um registro de rolagem. <br><br>  Mas h√° uma falha. <br><br>  Ao processar como um registro de endere√ßo, os bits 12 e 13 s√£o considerados parte do endere√ßo.  Durante a renderiza√ß√£o, a PPU sobrescreve constantemente o registro com o endere√ßo do bloco renderizado atual.  Como os blocos est√£o localizados nas tabelas de nomes e as tabelas est√£o na √°rea de mem√≥ria de <code>0x2000</code> a <code>0x2FFF</code> , o PPU atribui valores desse intervalo ao registro. <br><br>  Quando o jogo grava no <code>PPUADDR</code> no meio do quadro, se n√£o anotar o endere√ßo do bloco na tabela de nomes, o PPU tentar√° ler <em>de outro lugar</em> na mem√≥ria de v√≠deo.  Quaisquer bytes que ele conte ser√£o percebidos como blocos, o que provavelmente levar√° a resultados indesej√°veis.  Portanto, todos os valores registrados no meio do quadro no <code>PPUADDR</code> devem estar no intervalo de <code>0x2000</code> a <code>0x2FFF</code> .  Tomando cada n√∫mero nesse intervalo e levando em considera√ß√£o seus componentes de rolagem, o valor <strong>exato de rolagem em Y</strong> deve sempre ser igual a 2. <br><br>  Essa limita√ß√£o significa que n√£o podemos alterar a <strong>rolagem exata na</strong> dire√ß√£o <strong>Y</strong> no meio do quadro, ou seja, ao usar esse truque para implementar a rolagem vertical da separa√ß√£o da tela, estamos limitados √† rolagem de 8 pixels por vez e sempre temos um deslocamento vertical de dois pixels da borda do bloco.  The Legend of Zelda move 4 pixels por quadro ao rolar horizontalmente, mas 8 pixels por quadro ao rolar verticalmente, e agora sabemos o porqu√™. <br><br>  O artefato tamb√©m √© percept√≠vel ao rolar entre as salas para baixo, mas, neste caso, ocorre no final da anima√ß√£o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/77d/13b/89a/77d13b89abce5200d348de0379f409e5.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/468/eb2/9c2/468eb29c2eb3a97d7e4dd2a62682f1b9.gif" width="1024"></div><br><h2>  Leitura adicional </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O Wiki do NesDev</a> √© um recurso inestim√°vel para aprender sobre o hardware do NES.  Em particular, o assunto deste post s√£o p√°ginas sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">rolagem de PPU</a> <br>  e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">registros de PPU</a> . </li><li>  Meu emulador NES ainda muito inacabado est√° dispon√≠vel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </li></ul><br><h2>  Anota√ß√µes </h2><br>  At√© eu descobrir o registro interno da PPU, meu emulador mostrava o efeito de apagar durante as transi√ß√µes verticais da tela The Legend of Zelda. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/932/2a0/a5a/9322a0a5a1522a0ae0f6fbd21080286e.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d1a/078/755/d1a0787558999dd61ec2ba9dc9ba9026.gif" width="1024"></div><br>  O sprite do link desceu a tela, como deveria ser, mas o plano de fundo n√£o rolou.  A elimina√ß√£o foi causada pelo fato de o jogo atualizar gradualmente a tabela de nomes para conter os gr√°ficos da nova sala, mas n√£o atualizar a rolagem para manter as atualiza√ß√µes fora da tela. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt460383/">https://habr.com/ru/post/pt460383/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt460367/index.html">Engenharia do Caos: a arte da destrui√ß√£o intencional. Parte 1</a></li>
<li><a href="../pt460373/index.html">P√°ginas sob o cap√¥ Turbo: arquitetura da tecnologia de download r√°pido de p√°ginas da Web</a></li>
<li><a href="../pt460375/index.html">Livro "Aprendizado de m√°quina para neg√≥cios e marketing"</a></li>
<li><a href="../pt460377/index.html">Usando o Liquibase para gerenciar a estrutura do banco de dados em um aplicativo Spring Boot. Parte 1</a></li>
<li><a href="../pt460381/index.html">O que √© assertividade e por que √© necess√°rio</a></li>
<li><a href="../pt460387/index.html">Guia do Iniciante do SELinux</a></li>
<li><a href="../pt460393/index.html">Hist√≥rico: o que esperar do Fedora Silverblue</a></li>
<li><a href="../pt460395/index.html">An√°lise como um recurso: o processo de trabalhar com dados no Plesk</a></li>
<li><a href="../pt460397/index.html">In√≠cio r√°pido com WebComponents</a></li>
<li><a href="../pt460399/index.html">Indicador de carregamento SVG no Vue.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>