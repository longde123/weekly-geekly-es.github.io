<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåé üîè üë©üèª‚Äçüé§ Comment cr√©er des formes personnalis√©es √† l'aide de MaterialShapeDrawable üö¥üèº üë∏üèΩ üê•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Material Design 2.0 a introduit plusieurs nouveaux concepts. L'un d'eux porte une attention particuli√®re aux formes g√©om√©triques des √©l√©ments d'interf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment cr√©er des formes personnalis√©es √† l'aide de MaterialShapeDrawable</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mobileup/blog/426997/"><img src="https://habrastorage.org/getpro/habr/post_images/585/f26/743/585f267433530ce6e9add3c7de072e35.jpg" alt="image"><br><br><p>  Material Design 2.0 a introduit plusieurs nouveaux concepts.  L'un d'eux porte une attention particuli√®re aux formes g√©om√©triques des √©l√©ments d'interface.  Et il existe un moyen facile de cr√©er de belles formes personnalis√©es.  Il s'appelle MaterialShapeDrawable.  Voyons √† quel point il est utile et facile √† utiliser. </p><a name="habracut"></a><br><p>  Il existe plusieurs fa√ßons d'ajouter des √©l√©ments graphiques √† l'√©cran d'une application Android.  Le plus simple est d'importer des bitmaps au format webp ou png.  Une autre option consiste √† utiliser VectorDrawable, qui vous permet d'√©tirer l'image √† la taille dont vous avez besoin.  Une autre fa√ßon d'ajouter des graphiques √† l'√©cran consiste √† utiliser ShapeDrawable.  Ces derniers sont le moyen le plus simple d'ajouter un arri√®re-plan simple ou m√™me de cr√©er une ic√¥ne.  Les images cr√©√©es avec ShapeDrawable sont ind√©pendantes de la densit√© de pixels √† l'√©cran.  Ils peuvent √™tre d√©crits dans le fichier xml, faire partie d'une autre ressource graphique (par exemple, StateListDrawable) et sont pr√©sents dans le SDK Android, √† partir de l'API v.1. </p><br><p>  Pour modifier l'apparence d'une figure, nous pouvons modifier plusieurs propri√©t√©s ShapeDrawable: le nom de la figure, la couleur de remplissage (ou d√©grad√©) et la couleur de bordure de la figure.  Pour les rectangles, vous pouvez √©galement d√©finir le rayon des coins.  En utilisant ces propri√©t√©s, vous pouvez cr√©er des graphiques qui seront utilis√©s comme images individuelles sur l'√©cran, des s√©parateurs, des arri√®re-plans de boutons ou √† toute autre fin.  Si l'application utilise l'API v.21 + et ShapeDrawable comme arri√®re-plan pour les √©l√©ments avec √©l√©vation, l'ombre sous ces √©l√©ments aura √©galement la forme correcte: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/456/6b3/fd7/4566b3fd778a1edfdcce710510d1a2c4.png" alt="image"></p><br><p>  ShapeDrawable est un outil pratique qui fait presque toujours bien son travail, mais avec l'av√®nement de Material Design 2.0, les d√©veloppeurs ont besoin de quelque chose de plus flexible.  Le nouveau syst√®me de conception encourage l'utilisation de diff√©rentes formes pour souligner leur signification, leur √©tat et leur style d'application individuel.  J'ai √©crit ci-dessus qu'il existe plusieurs fa√ßons de faire ce qui est souhait√©, mais la plus simple d'entre elles n'est plus pertinente.  Est-ce √† dire que nous devons commencer √† utiliser des graphiques vectoriels et ainsi perdre la possibilit√© de ¬´lib√©rer¬ª cr√©er des ombres pour les √©l√©ments d'interface avec √©l√©vation?  Ou vaut-il la peine de revenir √† l'utilisation d'images raster et de cr√©er des ressources graphiques pour six densit√©s de pixels possibles √† l'√©cran?  Heureusement, avec l'av√®nement de Material Design 2.0, une toute nouvelle biblioth√®que de composants est apparue. </p><br><p>  Cette biblioth√®que a √©t√© cr√©√©e pour unifier l'apparence et le comportement de l'interface utilisateur Material Design sur toutes les versions d'Android et d'autres plates-formes (il existe des versions de cette biblioth√®que pour iOS, le Web et pour Flutter).  La biblioth√®que de composants impl√©mente de nombreuses fonctionnalit√©s pour le nouveau Material Design.  Par exemple, il inclut le composant BottomAppBar avec le comportement attendu.  Parmi les autres composants et utilitaires, il existe la classe MaterialShapeDrawable.  √Ä mon avis, c'est un outil n√©cessaire pour r√©soudre les t√¢ches que le nouveau syst√®me de conception pose aux d√©veloppeurs. </p><br><p> Bien que MaterialShapeDrawable soit toujours consid√©r√© comme exp√©rimental dans la version 1.0.0 de la biblioth√®que, il peut √™tre utilis√© pour cr√©er des effets sympas dans l'application.  Dans la classe MaterialShapeDrawable, vous pouvez d√©crire une forme en sp√©cifiant l'apparence de ses c√¥t√©s et chacun de ses angles.  Ces propri√©t√©s sp√©cifi√©es peuvent √™tre contr√¥l√©es par un interpolateur, ce qui leur permet de s'animer. </p><br><p>  Pour cr√©er votre propre MaterialShapeDrawable, vous pouvez utiliser le constructeur auquel vous devez passer un objet de type ShapePathModel dans les param√®tres.  Il stocke des informations sur chaque c√¥t√© et chaque coin de la figure dans les classes EdgeTreatment et CornerTreatment, respectivement (il y a toujours exactement quatre c√¥t√©s et angles, mais cela n'interf√®re pas avec la description de presque n'importe quelle figure avec leur aide).  Vous pouvez sp√©cifier des descriptions personnellement pour chaque c√¥t√© et coin, ou les d√©finir une fois pour la figure enti√®re en appelant une m√©thode. </p><br><p>  La biblioth√®que poss√®de d√©j√† plusieurs descriptions pr√™tes √† l'emploi du traitement des c√¥t√©s et des angles, qui incluent la plupart des innovations concernant la forme des composants introduites dans Material Design 2.0.  D√©j√† pr√©sent: RoundedCornerTreatment - pour les coins arrondis, CutCornerTreatment - pour les coins coup√©s, TriangleEdgeTreatment - pour couper ou ajouter un triangle sur le c√¥t√©.  Pour d√©montrer leur travail, il existe un exemple simple: </p><br><pre><code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> shapePathModel = ShapePathModel().apply { setAllCorners(CutCornerTreatment(dip(<span class="hljs-number"><span class="hljs-number">5</span></span>).toFloat())) setAllEdges(TriangleEdgeTreatment(dip(<span class="hljs-number"><span class="hljs-number">5</span></span>).toFloat(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> backgroundDrawable = MaterialShapeDrawable(shapePathModel).apply { setTint(ContextCompat.getColor(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span><span class="hljs-symbol"><span class="hljs-symbol">@MainActivity</span></span>, R.color.colorPrimary)) paintStyle = Paint.Style.FILL } textView.background = backgroundDrawable</code> </pre> <br><p>  Cela ressemblera √† ceci: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/02b/b43/168/02bb431689af8046223fd77e58fd0f2a.png" alt="image"></p><br><p>  Bien s√ªr, vous pouvez simplement cr√©er vos propres descriptions de visages et d'angles.  La forme est toujours d√©finie pour l'√©l√©ment sup√©rieur gauche et Drawable effectuera les op√©rations de rotation / r√©flexion pour obtenir la forme finale.  Il y a un petit exemple pour le d√©montrer: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CutoutCornersTreatment</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> size: <span class="hljs-built_in"><span class="hljs-built_in">Float</span></span>) : CornerTreatment() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCornerPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(angle: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-function"><span class="hljs-params">, interpolation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-function"><span class="hljs-params">, shapePath: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ShapePath</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { shapePath.reset(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, size * interpolation) shapePath.lineTo(size * interpolation, size * interpolation) shapePath.lineTo(size * interpolation, <span class="hljs-number"><span class="hljs-number">0f</span></span>) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CurvedEdgeTreatment</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> size: <span class="hljs-built_in"><span class="hljs-built_in">Float</span></span>) : EdgeTreatment() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getEdgePath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(length: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-function"><span class="hljs-params">, interpolation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-function"><span class="hljs-params">, shapePath: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ShapePath</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { shapePath.quadToPoint(length / <span class="hljs-number"><span class="hljs-number">2f</span></span>, size * interpolation, length, <span class="hljs-number"><span class="hljs-number">0f</span></span>) } }</code> </pre> <br><p>  Si ce MaterialShapeDrawable est utilis√© comme arri√®re-plan, le r√©sultat sera le suivant: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/98a/5b5/671/98a5b56711a7a3cec44ed62c459deaf2.png" alt="image"></p><br><p>  Le package bottomappbar de la nouvelle biblioth√®que de composants de mat√©riaux a un BottomAppBarTopEdgeTreatment.  Il d√©crit la d√©coupe dans le BottomAppBar pour le bouton FloatingActionButton.  Son c√¥t√© sup√©rieur peut √™tre anim√© en fonction de la position et de la taille du bouton.  Je vous conseille de lire le code de ces classes afin de voir de vos propres yeux que MaterialShapeDrawable est tr√®s flexible √† utiliser et presque tout peut √™tre fait avec. </p><br><p>  Si nous parlons du ShapeDrawable habituel, il y a un autre d√©tail qui m√©rite d'√™tre mentionn√© - la possibilit√© de projeter une ombre de la forme correspondant au contour.  Comme vous pouvez maintenant cr√©er des contours de formes tr√®s inhabituelles √† l'aide de MaterialShapeDrawable, il serait d√©cevant de ne pas apporter la forme de l'ombre √† la forme de l'image, surtout lorsque ces ombres peuvent √™tre vues partout dans Matarial Design 2.0.  MaterialShapeDrawable calcule √©galement l'apparence de l'ombre.  En utilisant la propri√©t√© shadowEnabled, vous pouvez activer l'ombre, qui suivra exactement le contour de la figure elle-m√™me, il est √©galement possible de d√©terminer le rayon, l'√©l√©vation et la couleur de l'ombre.  Cela semble trop beau pour √™tre vrai?  Malheureusement, oui.  Si vous utilisez l'ombre de MaterialShapeDrawable, vous obtenez une ombre normale (dessin√©e par la m√©thode setShadowLayer () de la classe Paint, qui a √©t√© cr√©√©e pour dessiner des ombres sur le texte), mais rogn√©e aux bordures du composant d'interface utilisateur dans lequel le r√©sultat est affich√©: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5aa/e8b/134/5aae8b1341f9adabf86daaefeccb09fa.png" alt="image"></p><br><p>  Gardez √† l'esprit que MaterialShapeDrawable est toujours consid√©r√© comme exp√©rimental, comme son API, et pourrait changer √† l'avenir.  Il convient √©galement de noter que le code de la nouvelle biblioth√®que de composants de mat√©riaux est ouvert, donc la cr√©ation de tickets dans un outil de suivi des bogues ou m√™me de demandes de tir avec correction de probl√®mes connus est la bienvenue.  En fait, lorsque vous lisez ces lignes, l'API est d√©j√† l√©g√®rement diff√©rente dans la branche principale de la biblioth√®que (par exemple, ShapeAppearanceModel sera utilis√© √† la place de ShapePathModel), ce qui indique le travail actif.  L'une des fonctionnalit√©s prometteuses de la prochaine version pourrait √™tre la possibilit√© de d√©terminer les c√¥t√©s / angles par d√©faut pour l'ensemble du th√®me de l'application.  Vous pouvez en savoir plus √† ce sujet dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation officielle</a> ou les sources de la biblioth√®que. </p><br><blockquote>  <em>Du traducteur:</em> <br>  <em>C'est cool qu'il existe des outils qui ajoutent de nouvelles fonctionnalit√©s au ShapeDrawable habituel et aident √† cr√©er des graphiques pas les plus simples.</em>  <em>Cela permet au d√©veloppeur de ne pas tirer le concepteur pour chaque petite chose, mais de r√©soudre le probl√®me lui-m√™me, et n√©cessite beaucoup moins de temps.</em>  <em>Nous attendons les prochaines versions de la biblioth√®que des composants de mat√©riaux pour essayer de nouvelles fa√ßons de r√©soudre les probl√®mes existants.</em> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr426997/">https://habr.com/ru/post/fr426997/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr426985/index.html">kubebox et autres coques de console pour Kubernetes</a></li>
<li><a href="../fr426987/index.html">Apprenez OpenGL. Le√ßon 6.3 - √âclairage bas√© sur l'image. Irradiation diffuse</a></li>
<li><a href="../fr426991/index.html">Startup Digest: 10 √©v√©nements IT √† venir √† Moscou</a></li>
<li><a href="../fr426993/index.html">Dois-je apprendre le C pour comprendre le fonctionnement d'un ordinateur?</a></li>
<li><a href="../fr426995/index.html">Le recyclage nuit aux produits et aux employ√©s</a></li>
<li><a href="../fr426999/index.html">Suivre les tendances ou √©voluer vers RxJava et LiveData</a></li>
<li><a href="../fr427003/index.html">Cartes hexagonales dans Unity: brouillard de guerre, recherche cartographique, g√©n√©ration proc√©durale</a></li>
<li><a href="../fr427005/index.html">D√©veloppeurs d'IA - le m√©tier de millionnaire?</a></li>
<li><a href="../fr427009/index.html">"Marche" d'un √©lectron: manipulations avec une charge √† l'int√©rieur de la structure des liaisons insatur√©es</a></li>
<li><a href="../fr427011/index.html">Mon "Bonjour tout le monde!" sur FPGA ou la prochaine version de UART</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>