<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöÅ üë®‚Äçüë®‚Äçüëß üßôüèø MVCC en PostgreSQL-1. Aislamiento üåΩ üå™Ô∏è ü§öüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! Con este art√≠culo comienzo un conjunto de series (¬øo una serie de conjuntos? - En una palabra, la idea es grandiosa) sobre la estructura in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC en PostgreSQL-1. Aislamiento</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/467437/">  Hola Habr!  Con este art√≠culo comienzo un conjunto de series (¬øo una serie de conjuntos? - En una palabra, la idea es grandiosa) sobre la estructura interna de PostgreSQL. <br><br>  El material se basar√° en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cursos de capacitaci√≥n</a> (en ruso) sobre administraci√≥n que Pavel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">pluzanov</a> y yo estamos creando.  No a todos les gusta ver videos (definitivamente no), y leer diapositivas, incluso con comentarios, no es nada bueno. <br><br><blockquote>  Desafortunadamente, el √∫nico curso disponible en ingl√©s en este momento es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Introducci√≥n de 2 d√≠as a PostgreSQL 11</a> . <br></blockquote><br>  Por supuesto, los art√≠culos no ser√°n exactamente iguales al contenido de los cursos.  Solo hablar√© sobre c√≥mo est√° organizado todo, omitiendo la administraci√≥n en s√≠, pero intentar√© hacerlo con m√°s detalle y m√°s a fondo.  Y creo que este conocimiento es tan √∫til para un desarrollador de aplicaciones como para un administrador. <br><br>  Apuntar√© a aquellos que ya tienen experiencia en el uso de PostgreSQL y al menos en general entienden qu√© es qu√©.  El texto ser√° demasiado dif√≠cil para los principiantes.  Por ejemplo, no dir√© una palabra sobre c√≥mo instalar PostgreSQL y ejecutar psql. <br><br>  El material en cuesti√≥n no var√≠a mucho de una versi√≥n a otra, pero utilizar√© el 11¬∫ PostgreSQL de vainilla actual. <br><br>  La primera serie trata temas relacionados con el aislamiento y la concurrencia de m√∫ltiples versiones, y el plan de la serie es el siguiente: <br><br><ol><li>  Aislamiento tal como lo entiende el est√°ndar y PostgreSQL (este art√≠culo). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bifurcaciones, archivos, p√°ginas</a> : lo que est√° sucediendo a nivel f√≠sico. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Versiones de fila</a> , transacciones virtuales y subtransacciones. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Instant√°neas de datos</a> y la visibilidad de las versiones de fila;  El horizonte de eventos. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Vac√≠o en la p√°gina y actualizaciones CALIENTES</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Vac√≠o normal</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Autovacuum</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Identificaci√≥n de la transacci√≥n envolvente y congelaci√≥n</a> . </li></ol><br>  ¬°Vamos! <br><br><blockquote>  Y antes de comenzar, me gustar√≠a agradecer a Elena Indrupskaya por traducir los art√≠culos al ingl√©s. <br></blockquote><br><a name="habracut"></a><br><h1>  ¬øQu√© es el aislamiento y por qu√© es importante? </h1><br>  Probablemente, todos al menos son conscientes de la existencia de transacciones, se han encontrado con la abreviatura ACID y han o√≠do hablar de los niveles de aislamiento.  Pero todav√≠a nos enfrentamos a la opini√≥n de que esto pertenece a la teor√≠a, que no es necesaria en la pr√°ctica.  Por lo tanto, pasar√© un tiempo tratando de explicar por qu√© esto es realmente importante. <br><br>  Es poco probable que est√© satisfecho si una aplicaci√≥n obtiene datos incorrectos de la base de datos o si la aplicaci√≥n escribe datos incorrectos en la base de datos. <br><br>  Pero, ¬øqu√© son los datos "correctos"?  Se sabe que las <em>restricciones de integridad</em> , como NOT NULL o UNIQUE, se pueden crear en el nivel de la base de datos.  Si los datos siempre cumplen con las restricciones de integridad (y esto es as√≠ porque el DBMS lo garantiza), entonces son integrales. <br><br>  ¬øSon <em>correctos</em> e <em>integrales</em> las mismas cosas?  No exactamente  No todas las restricciones se pueden especificar a nivel de base de datos.  Algunas de las restricciones son demasiado complicadas, por ejemplo, que cubren varias tablas a la vez.  E incluso si una restricci√≥n en general pudiera haberse definido en la base de datos, pero por alguna raz√≥n no lo fue, no significa que la restricci√≥n pueda ser violada. <br><br>  Entonces, la <em>correcci√≥n</em> es m√°s fuerte que la <em>integridad</em> , pero no sabemos exactamente lo que esto significa.  No tenemos m√°s que admitir que el "est√°ndar de oro" de la correcci√≥n es una aplicaci√≥n que, como nos gustar√≠a creer, est√° escrita <em>correctamente</em> y nunca funciona mal.  En cualquier caso, si una aplicaci√≥n no viola la integridad, pero viola la correcci√≥n, el DBMS no lo sabr√° y no atrapar√° la aplicaci√≥n "con las manos en la masa". <br><br>  Adem√°s, usaremos el t√©rmino <em>consistencia</em> para referirnos a la correcci√≥n. <br><br>  Sin embargo, supongamos que una aplicaci√≥n ejecuta solo secuencias correctas de operadores.  ¬øCu√°l es el papel de DBMS si la aplicaci√≥n es correcta como es? <br><br>  Primero, resulta que una secuencia correcta de operadores puede romper temporalmente la consistencia de los datos y, curiosamente, esto es normal.  Un ejemplo trillado pero claro es una transferencia de fondos de una cuenta a otra.  La regla de coherencia puede sonar as√≠: <em>una transferencia nunca cambia la cantidad total de dinero en las cuentas</em> (esta regla es bastante dif√≠cil de especificar en SQL como una restricci√≥n de integridad, por lo que existe a nivel de aplicaci√≥n y es invisible para el DBMS).  Una transferencia consta de dos operaciones: la primera reduce los fondos en una cuenta y la segunda, los aumenta en la otra.  La primera operaci√≥n rompe la consistencia de los datos, mientras que la segunda la restaura. <br><br><blockquote>  Un buen ejercicio es implementar la regla anterior a nivel de restricciones de integridad. <br></blockquote><br>  ¬øQu√© pasa si se realiza la primera operaci√≥n y la segunda no?  De hecho, sin mucho inconveniente: durante la segunda operaci√≥n puede ocurrir una falla el√©ctrica, un bloqueo del servidor, divisi√≥n por cero, lo que sea.  Est√° claro que la consistencia se romper√°, y esto no se puede permitir.  En general, es posible resolver tales problemas a nivel de aplicaci√≥n, pero a costa de enormes esfuerzos;  sin embargo, afortunadamente, no es necesario: esto lo hace el DBMS.  Pero para hacer esto, el DBMS debe saber que las dos operaciones son un todo indivisible.  Es decir, <em>una transacci√≥n</em> . <br><br>  Resulta interesante: como el DBMS sabe que las operaciones constituyen una transacci√≥n, ayuda a mantener la coherencia al garantizar que las transacciones sean at√≥micas, y lo hace sin saber nada sobre reglas de coherencia espec√≠ficas. <br><br>  Pero hay un segundo punto, m√°s sutil.  Tan pronto como aparecen varias transacciones simult√°neas en el sistema, que son absolutamente correctas por separado, es posible que no funcionen correctamente juntas.  Esto se debe a que el orden de las operaciones est√° mezclado: no se puede suponer que todas las operaciones de una transacci√≥n se realizan primero y luego todas las operaciones de la otra. <br><br>  Una nota sobre simultaneidad.  De hecho, las transacciones pueden ejecutarse simult√°neamente en un sistema con un procesador multin√∫cleo, matriz de discos, etc.  Pero el mismo razonamiento es v√°lido para un servidor que ejecuta comandos secuencialmente, en un modo de tiempo compartido: durante ciertos ciclos de reloj se ejecuta una transacci√≥n, y durante los siguientes ciclos determinados se ejecuta la otra.  A veces, el t√©rmino ejecuci√≥n <em>concurrente</em> se usa para una generalizaci√≥n. <br><br>  Las situaciones en que las transacciones correctas funcionan juntas incorrectamente se denominan <em>anomal√≠as</em> de ejecuci√≥n concurrente. <br><br>  Para un ejemplo simple: si una aplicaci√≥n quiere obtener datos correctos de la base de datos, no debe, al menos, ver los cambios de otras transacciones no confirmadas.  De lo contrario, no solo puede obtener datos inconsistentes, sino tambi√©n ver algo que nunca ha estado en la base de datos (si la transacci√≥n se cancela).  Esta anomal√≠a se llama <em>lectura sucia</em> . <br><br>  Hay otras anomal√≠as m√°s complejas, que trataremos un poco m√°s adelante. <br><br>  Ciertamente es imposible evitar la ejecuci√≥n concurrente: de lo contrario, ¬øde qu√© tipo de rendimiento podemos hablar?  Pero tampoco puedes trabajar con datos incorrectos. <br><br>  Y nuevamente el DBMS viene al rescate.  Puede realizar transacciones ejecutadas de <em>forma</em> secuencial, <em>como</em> una tras otra.  En otras palabras, <em>aislados</em> unos de otros.  En realidad, el DBMS puede realizar operaciones confusas, pero garantizar que el resultado de una ejecuci√≥n concurrente sea el mismo que el resultado de algunas de las posibles ejecuciones secuenciales.  Y esto elimina cualquier posible anomal√≠a. <br><br>  Entonces llegamos a la definici√≥n: <br><br><blockquote>  Una transacci√≥n es un conjunto de operaciones realizadas por una aplicaci√≥n que transfiere una base de datos de un estado correcto a otro estado correcto (consistencia), siempre que la transacci√≥n se complete (atomicidad) y sin interferencia de otras transacciones (aislamiento). <br></blockquote><br>  Esta definici√≥n une las tres primeras letras del acr√≥nimo ACID.  Est√°n tan estrechamente relacionados entre s√≠ que no tiene sentido considerar uno sin los dem√°s.  De hecho, tambi√©n es dif√≠cil separar la letra D (durabilidad).  De hecho, cuando un sistema falla, todav√≠a tiene cambios de transacciones no confirmadas, con lo que debe hacer algo para restaurar la consistencia de los datos. <br><br>  Todo hubiera estado bien, pero la implementaci√≥n del aislamiento completo es una tarea t√©cnicamente dif√≠cil que implica una reducci√≥n en el rendimiento del sistema.  Por lo tanto, en la pr√°ctica muy a menudo (no siempre, pero casi siempre) se utiliza el aislamiento debilitado, lo que evita algunas, pero no todas las anomal√≠as.  Esto significa que una parte del trabajo para garantizar la correcci√≥n de datos recae en la aplicaci√≥n.  Por esta misma raz√≥n, es muy importante comprender qu√© nivel de aislamiento se utiliza en el sistema, qu√© garantiza que ofrece y qu√© no, y c√≥mo escribir el c√≥digo correcto en tales condiciones. <br><br><h1>  Niveles de aislamiento y anomal√≠as en el est√°ndar SQL </h1><br>  El est√°ndar SQL ha descrito durante mucho tiempo cuatro niveles de aislamiento.  Estos niveles se definen enumerando las anomal√≠as permitidas o no permitidas cuando las transacciones se ejecutan simult√°neamente en este nivel.  Por lo tanto, para hablar sobre estos niveles, es necesario conocer las anomal√≠as. <br><br>  Enfatizo que en esta parte estamos hablando del est√°ndar, es decir, de una teor√≠a, en la cual la pr√°ctica se basa significativamente, pero de la que al mismo tiempo diverge significativamente.  Por lo tanto, todos los ejemplos aqu√≠ son especulativos.  Utilizar√°n las mismas operaciones en las cuentas de los clientes: esto es bastante demostrativo, aunque, es cierto, no tiene nada que ver con la organizaci√≥n de las operaciones bancarias en realidad. <br><br><h2>  Actualizaci√≥n de p√©rdida </h2><br>  Comencemos con la <em>actualizaci√≥n perdida</em> .  Esta anomal√≠a ocurre cuando dos transacciones leen la misma fila de la tabla, luego una transacci√≥n actualiza esa fila, y luego la segunda transacci√≥n tambi√©n actualiza la misma fila sin tener en cuenta los cambios realizados por la primera transacci√≥n. <br><br>  Por ejemplo, dos transacciones van a aumentar la cantidad en la misma cuenta en ‚ÇΩ100 (‚ÇΩ es el signo de moneda para el rublo ruso).  La primera transacci√≥n lee el valor actual (‚ÇΩ1000) y luego la segunda transacci√≥n lee el mismo valor.  La primera transacci√≥n aumenta la cantidad (esto da ‚ÇΩ1100) y escribe este valor.  La segunda transacci√≥n act√∫a de la misma manera: obtiene el mismo ‚ÇΩ1100 y escribe este valor.  Como resultado, el cliente perdi√≥ ‚ÇΩ100. <br><br>  El est√°ndar no permite actualizaciones perdidas en ning√∫n nivel de aislamiento. <br><br><h2>  Lectura sucia y lectura no comprometida </h2><br>  Una <em>lectura sucia</em> es lo que ya conocemos.  Esta anomal√≠a ocurre cuando una transacci√≥n lee cambios que a√∫n no se han confirmado por otra transacci√≥n. <br><br>  Por ejemplo, la primera transacci√≥n transfiere todo el dinero de la cuenta del cliente a otra cuenta, pero no confirma el cambio.  Otra transacci√≥n lee el saldo de la cuenta, para obtener ‚ÇΩ0, y se niega a retirar efectivo al cliente, aunque la primera transacci√≥n cancela y revierte sus cambios, por lo que el valor de 0 nunca ha existido en la base de datos. <br><br>  El est√°ndar permite lecturas sucias en el nivel de lectura no comprometida. <br><br><h2>  Lectura no repetible y lectura comprometida </h2><br>  Una anomal√≠a de <em>lectura no repetible</em> ocurre cuando una transacci√≥n lee la misma fila dos veces, y entre las lecturas, la segunda transacci√≥n modifica (o elimina) esa fila y confirma los cambios.  Entonces, la primera transacci√≥n obtendr√° resultados diferentes. <br><br>  Por ejemplo, permita que una regla de coherencia <em>proh√≠ba los importes negativos en las cuentas de los clientes</em> .  La primera transacci√≥n reducir√° el monto de la cuenta en ‚ÇΩ100.  Comprueba el valor actual, obtiene ‚ÇΩ1000 y decide que la disminuci√≥n es posible.  Al mismo tiempo, la segunda transacci√≥n reduce el monto de la cuenta a cero y confirma los cambios.  Si la primera transacci√≥n ahora vuelve a verificar la cantidad, obtendr√≠a ‚ÇΩ0 (pero ya ha decidido reducir el valor y la cuenta "entra en rojo"). <br><br>  El est√°ndar permite lecturas no repetibles en los niveles Lectura no confirmada y Lectura confirmada.  Pero Read Committed no permite lecturas sucias. <br><br><h2>  Lectura fantasma y lectura repetible </h2><br>  Una <em>lectura fantasma</em> ocurre cuando una transacci√≥n lee un conjunto de filas con la misma condici√≥n dos veces, y entre las lecturas, la segunda transacci√≥n agrega filas que cumplen esa condici√≥n (y confirma los cambios).  Luego, la primera transacci√≥n obtendr√° un conjunto diferente de filas. <br><br>  Por ejemplo, permita que una regla de coherencia <em>evite que un cliente tenga m√°s de 3 cuentas</em> .  La primera transacci√≥n va a abrir una nueva cuenta, verifica el n√∫mero actual de cuentas (digamos, 2) y decide que es posible abrir.  Al mismo tiempo, la segunda transacci√≥n tambi√©n abre una nueva cuenta para el cliente y confirma los cambios.  Ahora, si la primera transacci√≥n volvi√≥ a verificar el n√∫mero, obtendr√≠a 3 (pero ya est√° abriendo otra cuenta y el cliente parece tener 4 de ellas). <br><br>  El est√°ndar permite lecturas fantasmas en los niveles de Lectura no confirmada, Lectura comprometida y Lectura repetible.  Sin embargo, la lectura no repetible no est√° permitida en el nivel de Lectura repetible. <br><br><h2>  La ausencia de anomal√≠as y serializables </h2><br>  El est√°ndar define un nivel m√°s, Serializable, que no permite ninguna anomal√≠a.  Y esto no es lo mismo que prohibir actualizaciones perdidas y lecturas sucias, no repetibles o fantasmas. <br><br>  La cuesti√≥n es que hay muchas m√°s anomal√≠as conocidas que las enumeradas en el est√°ndar y tambi√©n un n√∫mero desconocido de otras a√∫n desconocidas. <br><br>  El nivel serializable debe evitar <em>absolutamente todas las</em> anomal√≠as.  Significa que a este nivel, un desarrollador de aplicaciones no necesita pensar en la ejecuci√≥n concurrente.  Si las transacciones realizan una secuencia correcta de operadores que trabajan por separado, los datos ser√°n coherentes tambi√©n cuando estas transacciones se ejecuten simult√°neamente. <br><br><h2>  Tabla resumen </h2><br>  Ahora podemos proporcionar una tabla conocida.  Pero aqu√≠ se agrega la √∫ltima columna, que falta en el est√°ndar, para mayor claridad. <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  Cambios perdidos </th><th>  Lectura sucia </th><th>  Lectura no repetible </th><th>  Lectura fantasma </th><th>  Otras anomal√≠as </th></tr><tr><th>  Leer no comprometido </th><th>  - </th><th>  Si </th><th>  Si </th><th>  Si </th><th>  Si </th></tr><tr><th>  Leer comprometido </th><th>  - </th><th>  - </th><th>  Si </th><th>  Si </th><th>  Si </th></tr><tr><th>  Lectura repetible </th><th>  - </th><th>  - </th><th>  - </th><th>  Si </th><th>  Si </th></tr><tr><th>  Serializable </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th></tr></tbody></table></div><br><h2>  ¬øPor qu√© exactamente estas anomal√≠as? </h2><br>  ¬øPor qu√© el est√°ndar enumera solo algunas de las muchas anomal√≠as posibles, y por qu√© son exactamente estas? <br><br>  Nadie parece saberlo con certeza.  Pero aqu√≠ la pr√°ctica est√° evidentemente por delante de la teor√≠a, por lo que es posible que en ese momento (del est√°ndar SQL: 92) no se pensara en otras anomal√≠as. <br><br>  Adem√°s, se supuso que el aislamiento debe construirse sobre cerraduras.  La idea detr√°s del ampliamente utilizado <em>Protocolo de bloqueo de dos fases</em> (2PL) es que durante la ejecuci√≥n, una transacci√≥n bloquea las filas con las que est√° trabajando y libera los bloqueos al finalizar.  Simplificando considerablemente, cuanto m√°s bloqueos adquiere una transacci√≥n, mejor se a√≠sla de otras transacciones.  Pero el rendimiento del sistema tambi√©n sufre m√°s, porque en lugar de trabajar juntos, las transacciones comienzan a ponerse en cola para las mismas filas. <br><br>  Mi sensaci√≥n es que es solo la cantidad de bloqueos necesarios, lo que explica la diferencia entre los niveles de aislamiento del est√°ndar. <br><br>  Si una transacci√≥n bloquea las filas que se modificar√°n desde la actualizaci√≥n, pero no desde la lectura, obtenemos el nivel Leer no confirmado: no se permiten cambios perdidos, pero se pueden leer los datos no confirmados. <br><br>  Si una transacci√≥n bloquea las filas para modificarlas tanto de lectura como de actualizaci√≥n, obtenemos el nivel de lectura confirmada: no puede leer datos no confirmados, pero puede obtener un valor diferente (lectura no repetible) cuando accede a la fila nuevamente. <br><br>  Si una transacci√≥n bloquea las filas para que se lean y se modifiquen, tanto de lectura como de actualizaci√≥n, obtenemos el nivel de lectura repetible: volver a leer la fila devolver√° el mismo valor. <br><br>  Pero hay un problema con Serializable: no puede bloquear una fila que a√∫n no existe.  Por lo tanto, todav√≠a es posible una lectura fantasma: otra transacci√≥n puede agregar (pero no eliminar) una fila que cumpla las condiciones de una consulta ejecutada previamente, y esa fila se incluir√° en la re-selecci√≥n. <br><br>  Por lo tanto, para implementar el nivel Serializable, los bloqueos normales no son suficientes: debe bloquear las condiciones (predicados) en lugar de las filas.  Por lo tanto, tales bloqueos se llamaron <em>predicado</em> .  Se propusieron en 1976, pero su aplicabilidad pr√°ctica est√° limitada por condiciones bastante simples para las cuales est√° claro c√≥mo unir dos predicados diferentes.  Hasta donde yo s√©, tales bloqueos nunca se han implementado en ning√∫n sistema hasta ahora. <br><br><h1>  Niveles de aislamiento en PostgreSQL </h1><br>  Con el tiempo, los protocolos de gesti√≥n de transacciones basados ‚Äã‚Äãen bloqueos fueron reemplazados por el protocolo de aislamiento de instant√°neas (SI).  Su idea es que cada transacci√≥n funcione con una instant√°nea coherente de los datos en un momento determinado, y solo esos cambios se introducen en la instant√°nea que se confirmaron antes de crearse. <br><br>  Este aislamiento evita autom√°ticamente las lecturas sucias.  Formalmente, puede especificar el nivel de lectura no confirmada en PostgreSQL, pero funcionar√° exactamente de la misma manera que lectura confirmada.  Por lo tanto, adem√°s no hablaremos sobre el nivel Leer no comprometido en absoluto. <br><br>  PostgreSQL implementa una variante <em>multiversion</em> de este protocolo.  La idea de concurrencia multiversion es que varias versiones de la misma fila pueden coexistir en un DBMS.  Esto le permite crear una instant√°nea de los datos usando versiones existentes y usar un m√≠nimo de bloqueos.  En realidad, solo los cambios posteriores en la misma fila est√°n bloqueados.  Todas las dem√°s operaciones se realizan simult√°neamente: las transacciones de escritura nunca bloquean las transacciones de solo lectura, y las transacciones de solo lectura nunca bloquean nada. <br><br>  Al usar instant√°neas de datos, el aislamiento en PostgreSQL es m√°s estricto de lo requerido por el est√°ndar: el nivel de lectura repetible no solo permite lecturas no repetibles, sino tambi√©n lecturas fantasmas (aunque no proporciona aislamiento completo).  Y esto se logra sin p√©rdida de eficiencia. <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  Cambios perdidos </th><th>  Lectura sucia </th><th>  Lectura no repetible </th><th>  Lectura fantasma </th><th>  Otras anomal√≠as </th></tr><tr><th>  Leer no comprometido </th><th>  - </th><th>  - </th><th>  Si </th><th>  Si </th><th>  Si </th></tr><tr><th>  Leer comprometido </th><th>  - </th><th>  - </th><th>  Si </th><th>  Si </th><th>  Si </th></tr><tr><th>  Lectura repetible </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th><th>  Si </th></tr><tr><th>  Serializable </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th></tr></tbody></table></div><br>  Hablaremos en los pr√≥ximos art√≠culos de c√≥mo se implementa la concurrencia multiversion "bajo el cap√≥", y ahora veremos en detalle en cada uno de los tres niveles con el ojo del usuario (como saben, lo m√°s interesante est√° oculto detr√°s de "otras anomal√≠as"). ").  Para hacer esto, creemos una tabla de cuentas.  Alice y Bob tienen ‚ÇΩ1000 cada uno, pero Bob tiene dos cuentas abiertas: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts( id <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GENERATED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IDENTITY</span></span>, number <span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNIQUE</span></span>, client <span class="hljs-type"><span class="hljs-type">text</span></span>, amount <span class="hljs-type"><span class="hljs-type">numeric</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'1001'</span></span>, <span class="hljs-string"><span class="hljs-string">'alice'</span></span>, <span class="hljs-number"><span class="hljs-number">1000.00</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2001'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2002'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">900.00</span></span>);</code> </pre> <br><h2>  Leer comprometido </h2><br><h3>  La ausencia de lectura sucia </h3><br>  Es f√°cil asegurarse de que los datos sucios no se puedan leer.  Comenzamos la transacci√≥n.  Por defecto, usar√° el nivel de aislamiento de lectura confirmada: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> transaction_isolation;</code> </pre><pre> <code class="plaintext hljs"> transaction_isolation ----------------------- read committed (1 row)</code> </pre><br>  M√°s precisamente, el nivel predeterminado lo establece el par√°metro, que se puede cambiar si es necesario: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> default_transaction_isolation;</code> </pre><pre> <code class="plaintext hljs"> default_transaction_isolation ------------------------------- read committed (1 row)</code> </pre><br>  Por lo tanto, en una transacci√≥n abierta, retiramos fondos de la cuenta, pero no comprometemos los cambios.  La transacci√≥n ve sus propios cambios: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 1 | 1001 | alice | 800.00 (1 row)</code> </pre><br>  En la segunda sesi√≥n, comenzaremos otra transacci√≥n con el mismo nivel de lectura confirmada.  Para distinguir entre las transacciones, los comandos de la segunda transacci√≥n se sangrar√°n y marcar√°n con una barra. <br><br>  Para repetir los comandos anteriores (lo cual es √∫til), debe abrir dos terminales y ejecutar psql en cada uno.  En el primer terminal, puede ingresar los comandos de una transacci√≥n, y en el segundo, los de la otra. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+--------- | 1 | 1001 | alice | 1000.00 | (1 row)</code> </pre><br>  Como se esperaba, la otra transacci√≥n no ve cambios no confirmados ya que no se permiten lecturas sucias. <br><br><h3>  Lectura no repetible </h3><br>  Ahora deje que la primera transacci√≥n confirme los cambios y la segunda vuelva a ejecutar la misma consulta. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  La consulta ya obtiene datos nuevos, y esta es la anomal√≠a de <em>lectura no repetible</em> , que se permite en el nivel de <em>lectura confirmada</em> . <br><br>  <em>Conclusi√≥n pr√°ctica</em> : en una transacci√≥n, no puede tomar decisiones basadas en datos le√≠dos por un operador anterior porque las cosas pueden cambiar entre la ejecuci√≥n de los operadores.  Aqu√≠ hay un ejemplo cuyas variaciones ocurren con tanta frecuencia en el c√≥digo de la aplicaci√≥n que se considera un antipatr√≥n cl√°sico: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>;</code> </pre><br>  Durante el tiempo que transcurre entre la verificaci√≥n y la actualizaci√≥n, otras transacciones pueden cambiar el estado de la cuenta de cualquier manera, por lo que dicho "cheque" no se protege de la nada.  Es conveniente imaginar que entre los operadores de una transacci√≥n, cualquier otro operador de otras transacciones puede "encajar", por ejemplo, de la siguiente manera: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-comment"><span class="hljs-comment">----- | UPDATE accounts SET amount = amount - 200 WHERE id = 1; | COMMIT; ----- UPDATE accounts SET amount = amount - 1000 WHERE id = 1; END IF;</span></span></code> </pre><br>  Si todo se puede estropear reorganizando los operadores, entonces el c√≥digo se escribe incorrectamente.  Y no se enga√±e a s√≠ mismo de que tal coincidencia no suceder√°, seguramente lo har√°. <br><br>  Pero, ¬øc√≥mo escribir el c√≥digo correctamente?  Las opciones tienden a ser las siguientes: <br><br><ul><li>  No para escribir c√≥digo. <br>  Esto no es una broma.  Por ejemplo, en este caso, la comprobaci√≥n se convierte f√°cilmente en una restricci√≥n de integridad: <br> <code>ALTER TABLE accounts ADD CHECK amount &gt;= 0;</code> <br>  No se necesitan verificaciones ahora: simplemente realice la operaci√≥n y, si es necesario, maneje la excepci√≥n que ocurrir√° si se intenta una violaci√≥n de integridad. <br></li><li>  Para usar una sola instrucci√≥n SQL. <br>  Surgen problemas de consistencia ya que en el intervalo de tiempo entre operadores se puede completar otra transacci√≥n, lo que cambiar√° los datos visibles.  Y si hay un operador, entonces no hay intervalos de tiempo. <br>  PostgreSQL tiene suficientes t√©cnicas para resolver problemas complejos con una declaraci√≥n SQL.  Observemos las expresiones de tabla comunes (CTE), en las que, entre el resto, puede usar las instrucciones INSERT / UPDATE / DELETE, as√≠ como la instrucci√≥n INSERT ON CONFLICT, que implementa la l√≥gica de "insertar, pero si la fila ya existe, actualizar "en una declaraci√≥n. <br></li><li>  Cerraduras personalizadas. <br>  El √∫ltimo recurso es establecer manualmente un bloqueo exclusivo en todas las filas necesarias (SELECCIONAR PARA ACTUALIZAR) o incluso en toda la tabla (TABLA DE BLOQUEO).  Esto siempre funciona, pero anula los beneficios de la concurrencia multiversion: algunas operaciones se ejecutar√°n secuencialmente en lugar de la ejecuci√≥n concurrente. <br></li></ul><br><h3>  Lectura inconsistente </h3><br>  Antes de pasar al siguiente nivel de aislamiento, debes admitir que no todo es tan simple como parece.  La implementaci√≥n de PostgreSQL es tal que permite otras anomal√≠as menos conocidas que no est√°n reguladas por el est√°ndar. <br><br>  Supongamos que la primera transacci√≥n inici√≥ la transferencia de fondos de una cuenta de Bob a la otra: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Al mismo tiempo, otra transacci√≥n cuenta el saldo de Bob, y el c√°lculo se realiza en un ciclo sobre todas las cuentas de Bob.  De hecho, la transacci√≥n comienza con la primera cuenta (y, obviamente, ve el estado anterior): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs">| amount | -------- | 100.00 | (1 row)</code> </pre><br>  En este momento, la primera transacci√≥n se completa con √©xito: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Y el otro lee el estado de la segunda cuenta (y ya ve el nuevo valor): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><pre> <code class="plaintext hljs">| amount | --------- | 1000.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Por lo tanto, la segunda transacci√≥n obtuvo ‚ÇΩ1100 en total, es decir, datos incorrectos.  Y esta es una anomal√≠a de <em>lectura inconsistente</em> . <br><br>  ¬øC√≥mo evitar tal anomal√≠a mientras se mantiene en el nivel de lectura comprometida?  Por supuesto, use un operador.  Por ejemplo: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br><br>  Hasta aqu√≠, afirm√© que la visibilidad de los datos solo pod√≠a cambiar entre operadores, pero ¬øes eso tan obvio?  Y si la consulta lleva mucho tiempo, ¬øpuede ver una parte de los datos en un estado y una parte en otro? <br><br>  Vamos a ver  Una forma conveniente de hacer esto es insertar un retraso forzado en el operador llamando a la funci√≥n pg_sleep.  Su par√°metro especifica el tiempo de retraso en segundos. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount, pg_sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br>  Mientras se ejecuta este operador, transferimos los fondos nuevamente en otra transacci√≥n: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  El resultado muestra que el operador ve los datos en el estado que ten√≠a en el momento en que comenz√≥ la ejecuci√≥n del operador.  Esto es indudablemente correcto. <br><br><pre> <code class="plaintext hljs"> amount | pg_sleep ---------+---------- 0.00 | 1000.00 | (2 rows)</code> </pre><br>  Pero tampoco es tan simple aqu√≠.  PostgreSQL le permite definir funciones, y las funciones tienen el concepto de una <em>categor√≠a de volatilidad</em> .  Si se llama a una funci√≥n VOL√ÅTIL en una consulta y se ejecuta otra consulta en esa funci√≥n, la consulta dentro de la funci√≥n ver√° datos que son inconsistentes con los datos en la consulta principal. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> get_amount(id <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">numeric</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> amount </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> accounts a </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHERE</span></span></span><span class="pgsql"> a.id = get_amount.id; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">VOLATILE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> get_amount(id), pg_sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  En este caso, obtenemos datos incorrectos: se pierden ‚ÇΩ100: <br><br><pre> <code class="plaintext hljs"> get_amount | pg_sleep ------------+---------- 100.00 | 800.00 | (2 rows)</code> </pre><br>  Destaco que este efecto solo es posible en el nivel de aislamiento de lectura comprometida y solo con las funciones VOL√ÅTILES.  El problema es que, por defecto, se utilizan exactamente este nivel de aislamiento y esta categor√≠a de volatilidad.  ¬°No caigas en la trampa! <br><br><h3>  Lectura inconsistente a cambio de cambios perdidos </h3><br>  Tambi√©n podemos obtener una lectura inconsistente dentro de un solo operador durante una actualizaci√≥n, aunque de una manera algo inesperada. <br><br>  Veamos qu√© sucede cuando dos transacciones intentan modificar la misma fila.  Ahora Bob tiene ‚ÇΩ1000 en dos cuentas: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 (2 rows)</code> </pre><br>  Comenzamos una transacci√≥n que reduce el saldo de Bob: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><br>  Al mismo tiempo, en otra transacci√≥n, el inter√©s se acumula en todas las cuentas de clientes con un saldo total igual o superior a ‚ÇΩ1,000: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount * <span class="hljs-number"><span class="hljs-number">1.01</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> ( | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts | <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> sum(amount) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> | );</code> </pre><br>  La ejecuci√≥n del operador ACTUALIZACI√ìN consta de dos partes.  Primero, se ejecuta SELECT, que selecciona las filas para actualizar que cumplan con la condici√≥n adecuada.  Debido a que el cambio en la primera transacci√≥n no se confirma, la segunda transacci√≥n no puede verlo y el cambio no afecta la selecci√≥n de filas para la acumulaci√≥n de intereses.  Bueno, entonces, las cuentas de Bob cumplen la condici√≥n y una vez que se ejecuta la actualizaci√≥n, su saldo deber√≠a aumentar en ‚ÇΩ10. <br><br>  La segunda etapa de la ejecuci√≥n es actualizar las filas seleccionadas una por una.  Aqu√≠ la segunda transacci√≥n se ve obligada a "bloquearse" porque la fila con id = 3 ya est√° bloqueada por la primera transacci√≥n. <br><br>  Mientras tanto, la primera transacci√≥n confirma los cambios: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  ¬øCu√°l ser√° el resultado? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+---------- 2 | 2001 | bob | 202.0000 3 | 2002 | bob | 707.0000 (2 rows)</code> </pre><br>  Bueno, por un lado, el comando ACTUALIZAR no deber√≠a ver los cambios de la segunda transacci√≥n.  Pero, por otro lado, no debe perder los cambios comprometidos en la segunda transacci√≥n. <br><br>  Una vez que se libera el bloqueo, ACTUALIZAR vuelve a leer la fila que est√° tratando de actualizar (pero solo esta).  Como resultado, Bob acumul√≥ ‚ÇΩ9, basado en la cantidad de ‚ÇΩ900.  Pero si Bob tuviera ‚ÇΩ900, sus cuentas no deber√≠an haber estado en la selecci√≥n en absoluto. <br><br>  Entonces, la transacci√≥n obtiene datos incorrectos: algunas de las filas son visibles en un punto en el tiempo y otras en otro.  En lugar de una actualizaci√≥n perdida, nuevamente tenemos la anomal√≠a de la <em>lectura inconsistente</em> . <br><br><blockquote>  Los lectores atentos notan que con un poco de ayuda de la aplicaci√≥n puede obtener una actualizaci√≥n perdida incluso en el nivel de lectura comprometida.  Por ejemplo: <br><br><pre> <code class="pgsql hljs"> x := (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = x + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  La base de datos no tiene la culpa: obtiene dos declaraciones SQL y no sabe nada sobre el hecho de que el valor de x + 100 est√° de alguna manera relacionado con el monto de las cuentas.  Evite escribir c√≥digo de esa manera. <br></blockquote><br><h2>  Lectura repetible </h2><br><h3>  La ausencia de lecturas no repetibles y fantasmas </h3><br>  El mismo nombre del nivel de aislamiento supone que la lectura es repetible.  Vamos a comprobarlo y, al mismo tiempo, aseg√∫rese de que no haya lecturas fantasmas.  Para hacer esto, en la primera transacci√≥n, revertimos las cuentas de Bob a su estado anterior y creamos una nueva cuenta para Charlie: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">200.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">800.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'3001'</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+---------+-------- 1 | 1001 | alice | 800.00 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 4 | 3001 | charlie | 100.00 (4 rows)</code> </pre><br>  En la segunda sesi√≥n, comenzamos la transacci√≥n con el nivel de Lectura repetible al especificarlo en el comando BEGIN (el nivel de la primera transacci√≥n no es esencial). <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 1 | 1001 | alice | 800.00 | 2 | 2001 | bob | 202.0000 | 3 | 2002 | bob | 707.0000 | (3 rows)</code> </pre><br>  Ahora la primera transacci√≥n confirma los cambios y la segunda vuelve a ejecutar la misma consulta. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 1 | 1001 | alice | 800.00 | 2 | 2001 | bob | 202.0000 | 3 | 2002 | bob | 707.0000 | (3 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  La segunda transacci√≥n todav√≠a ve exactamente los mismos datos que al principio: no hay cambios en las filas existentes o en las nuevas filas visibles. <br><br>  En este nivel, puede evitar preocuparse por algo que pueda cambiar entre dos operadores. <br><br><h3>  Error de serializaci√≥n a cambio de cambios perdidos </h3><br>  Hemos discutido anteriormente que cuando dos transacciones actualizan la misma fila en el nivel de lectura confirmada, puede ocurrir una anomal√≠a de lectura inconsistente.  Esto se debe a que la transacci√≥n en espera vuelve a leer la fila bloqueada y, por lo tanto, no la ve en el mismo momento en el tiempo que las otras filas. <br><br>  En el nivel de lectura repetible, esta anomal√≠a no est√° permitida, pero si ocurre, no se puede hacer nada, por lo que la transacci√≥n termina con un error de serializaci√≥n.  Vamos a comprobarlo repitiendo el mismo escenario con acumulaci√≥n de intereses: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 (2 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>;&lt;span/&gt; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount * <span class="hljs-number"><span class="hljs-number">1.01</span></span>&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> client&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> client&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> sum(amount) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span>&lt;span/&gt; | );&lt;span/&gt;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">| ERROR: could not serialize access due to concurrent update</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br>  Los datos permanecieron consistentes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 700.00 (2 rows)</code> </pre><br>  El mismo error ocurrir√° en el caso de cualquier otro cambio competitivo de una fila, incluso si las columnas de nuestra preocupaci√≥n no se cambiaron realmente. <br><br>  <em>Conclusi√≥n pr√°ctica</em> : si su aplicaci√≥n utiliza el nivel de aislamiento de lectura repetible para las transacciones de escritura, debe estar lista para repetir transacciones que terminaron con un error de serializaci√≥n.  Para transacciones de solo lectura, este resultado no es posible. <br><br><h3>  Escritura inconsistente </h3><br>  Por lo tanto, en PostgreSQL, en el nivel de aislamiento de lectura repetible, se evitan todas las anomal√≠as descritas en el est√°ndar.  Pero no todas las anomal√≠as en general.  Resulta que hay <em>exactamente dos</em> anomal√≠as que todav√≠a son posibles.  (Esto es cierto no solo para PostgreSQL, sino tambi√©n para otras implementaciones de Snapshot Isolation). <br><br>  La primera de estas anomal√≠as es una <em>escritura inconsistente</em> . <br><br>  Deje que se cumpla la siguiente regla de coherencia: <em>se permiten cantidades negativas en las cuentas de los clientes si la cantidad total en todas las cuentas de ese cliente sigue siendo no negativa</em> . <br><br>  La primera transacci√≥n obtiene el monto en las cuentas de Bob: ‚ÇΩ900. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> sum -------- 900.00 (1 row)</code> </pre><br>  La segunda transacci√≥n obtiene la misma cantidad. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| sum | -------- | 900.00 | (1 row)</code> </pre><br>  La primera transacci√≥n cree leg√≠timamente que el monto de una de las cuentas se puede reducir en ‚ÇΩ600. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Y la segunda transacci√≥n llega a la misma conclusi√≥n.  Pero reduce otra cuenta: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+--------- 2 | 2001 | bob | -400.00 3 | 2002 | bob | 100.00 (2 rows)</code> </pre><br>  Logramos hacer que el saldo de Bob pasara a rojo, aunque cada transacci√≥n funciona correctamente solo. <br><br><h3>  Anomal√≠a de transacci√≥n de solo lectura </h3><br>  Esta es la segunda y √∫ltima de las anomal√≠as posibles en el nivel de lectura repetible.  Para demostrarlo, necesitar√° tres transacciones, dos de las cuales cambiar√°n los datos y la tercera solo lo leer√°. <br><br>  Pero primero restauremos el estado de las cuentas de Bob: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">900.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 3 | 2002 | bob | 100.00 2 | 2001 | bob | 900.00 (2 rows)</code> </pre><br>  En la primera transacci√≥n, se acumulan intereses sobre el monto disponible en todas las cuentas de Bob.  El inter√©s se acredita a una de sus cuentas: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 1 =&gt; UPDATE accounts SET amount = amount + ( SELECT sum(amount) FROM accounts WHERE client = 'bob' ) * 0.01 WHERE id = 2;</span></span></code> </pre><br>  Luego, otra transacci√≥n retira dinero de la cuenta de otro Bob y confirma sus cambios: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 2 | =&gt; UPDATE accounts SET amount = amount - 100.00 WHERE id = 3; | =&gt; COMMIT;</span></span></code> </pre><br>  Si la primera transacci√≥n se confirma en este punto, no se producir√° ninguna anomal√≠a: podr√≠amos suponer que la primera transacci√≥n se ejecut√≥ primero y luego la segunda (pero no viceversa porque la primera transacci√≥n vio el estado de la cuenta con id = 3 antes de eso la cuenta fue cambiada por la segunda transacci√≥n). <br><br>  Pero imagine que en este punto comienza la tercera transacci√≥n (solo lectura), que lee el estado de alguna cuenta que no se ve afectada por las dos primeras transacciones: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 3 | =&gt; SELECT * FROM accounts WHERE client = 'alice';</span></span></code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><br>  Y solo despu√©s de eso se completa la primera transacci√≥n: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  ¬øQu√© estado deber√≠a ver la tercera transacci√≥n ahora? <br><br><pre> <code class="pgsql hljs">| <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br>  Una vez iniciada, la tercera transacci√≥n podr√≠a ver los cambios de la segunda transacci√≥n (que ya se hab√≠a confirmado), pero no de la primera (que a√∫n no se hab√≠a confirmado).  Por otro lado, ya hemos determinado anteriormente que la segunda transacci√≥n debe considerarse iniciada despu√©s de la primera.  Cualquiera que sea el estado que vea la tercera transacci√≥n ser√° inconsistente, esto es solo la anomal√≠a de una transacci√≥n de solo lectura.  Pero en el nivel de lectura repetible est√° permitido: <br><br><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 2 | 2001 | bob | 900.00 | 3 | 2002 | bob | 0.00 | (2 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h2>  Serializable </h2><br>  El nivel serializable evita todas las anomal√≠as posibles.  De hecho, Serializable est√° construido sobre el aislamiento de instant√°neas.  Esas anomal√≠as que no ocurren con la lectura repetible (como una lectura sucia, no repetible o fantasma) tampoco ocurren en el nivel serializable.  Y esas anomal√≠as que ocurren (una escritura inconsistente y una anomal√≠a de transacci√≥n de solo lectura) se detectan y la transacci√≥n se anula; se produce un error de serializaci√≥n familiar: <em>no se pudo serializar el acceso</em> . <br><br><h3>  Escritura inconsistente </h3><br>  Para ilustrar esto, repitamos el escenario con una anomal√≠a de escritura inconsistente: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> sum ---------- 910.0000 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| sum | ---------- | 910.0000 | (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">ERROR: could not serialize access due to read/write dependencies among transactions DETAIL: Reason code: Canceled on identification as a pivot, during commit attempt. HINT: The transaction might succeed if retried.</code> </pre><br>  Al igual que en el nivel de lectura repetible, una aplicaci√≥n que utiliza el nivel de aislamiento serializable debe repetir las transacciones que terminaron con un error de serializaci√≥n, como nos indica el mensaje de error. <br><br>  Ganamos simplicidad de programaci√≥n, pero el precio es una terminaci√≥n forzada de una fracci√≥n de las transacciones y la necesidad de repetirlas.  La pregunta, por supuesto, es qu√© tan grande es esta fracci√≥n.  Si solo se terminaran esas transacciones que se superponen incompatiblemente con otras transacciones, hubiera sido bueno.  Pero tal implementaci√≥n inevitablemente requerir√≠a muchos recursos e ineficiencia porque tendr√≠a que rastrear las operaciones en cada fila. <br><br>  En realidad, la implementaci√≥n de PostgreSQL es tal que permite falsos negativos: algunas transacciones absolutamente normales que son "desafortunadas" tambi√©n abortar√°n.  Como veremos m√°s adelante, esto depende de muchos factores, como la disponibilidad de √≠ndices apropiados o la cantidad de RAM disponible.  Adem√°s, existen otras restricciones de implementaci√≥n (bastante severas), por ejemplo, las consultas en el nivel Serializable no funcionar√°n en las r√©plicas y no utilizar√°n planes de ejecuci√≥n paralelos.  Aunque el trabajo para mejorar la implementaci√≥n contin√∫a, las limitaciones existentes hacen que este nivel de aislamiento sea menos atractivo. <br><blockquote>  Los planes paralelos aparecer√°n tan pronto como en PostgreSQL 12 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parche</a> ).  Y las consultas sobre r√©plicas pueden comenzar a funcionar en PostgreSQL 13 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">otro parche</a> ). <br></blockquote><br><h3>  Anomal√≠a de transacci√≥n de solo lectura </h3><br>  Para que una transacci√≥n de solo lectura no resulte en una anomal√≠a y no la sufra, PostgreSQL ofrece una t√©cnica interesante: dicha transacci√≥n puede bloquearse hasta que su ejecuci√≥n sea segura.  Este es el √∫nico caso cuando un operador SELECCIONAR puede ser bloqueado por actualizaciones de fila.  As√≠ es como se ve: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">900.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 900.00 3 | 2002 | bob | 100.00 (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 1 =&gt; UPDATE accounts SET amount = amount + ( SELECT sum(amount) FROM accounts WHERE client = 'bob' ) * 0.01 WHERE id = 2;</span></span></code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 2 | =&gt; UPDATE accounts SET amount = amount - 100.00 WHERE id = 3; | =&gt; COMMIT;</span></span></code> </pre><br>  La tercera transacci√≥n se declara expl√≠citamente LEER SOLAMENTE y DEFERRABLE: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ONLY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFERRABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 3 | =&gt; SELECT * FROM accounts WHERE client = 'alice';</span></span></code> </pre><br>  Al intentar ejecutar la consulta, la transacci√≥n se bloquea porque de lo contrario causar√≠a una anomal√≠a. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Y solo despu√©s de que se confirma la primera transacci√≥n, la tercera contin√∫a la ejecuci√≥n: <br><br><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 2 | 2001 | bob | 910.0000 | 3 | 2002 | bob | 0.00 | (2 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Otra nota importante: si se usa el aislamiento serializable, todas las transacciones en la aplicaci√≥n deben usar este nivel.  No puede mezclar transacciones de lectura confirmada (o lectura repetible) con serializable.  Es decir, <em>puede</em> mezclar, pero Serializable se comportar√° como Lectura repetible sin ninguna advertencia.  Discutiremos por qu√© sucede esto m√°s adelante, cuando hablemos sobre la implementaci√≥n. <br><br>  Entonces, si decide usar Serializble, es mejor establecer globalmente el nivel predeterminado (aunque esto, por supuesto, no le impedir√° especificar un nivel incorrecto expl√≠citamente): <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> default_transaction_isolation = <span class="hljs-string"><span class="hljs-string">'serializable'</span></span>;</code> </pre><br><blockquote>  Puede encontrar una presentaci√≥n m√°s rigurosa de los problemas relacionados con las transacciones, la coherencia y las anomal√≠as en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">libro</a> y el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">curso de conferencias</a> de Boris Novikov "Fundamentos de las tecnolog√≠as de bases de datos" (disponible solo en Russion). <br></blockquote><br><h1>  ¬øQu√© nivel de aislamiento usar? </h1><br>  El nivel de aislamiento de lectura confirmada se usa de manera predeterminada en PostgreSQL, y es probable que este nivel se use en la gran mayor√≠a de las aplicaciones.  Este valor predeterminado es conveniente porque a este nivel es posible cancelar la transacci√≥n solo en caso de falla, pero no como un medio para evitar inconsistencias.  En otras palabras, no se puede producir un error de serializaci√≥n. <br><br>  El otro lado de la moneda es un gran n√∫mero de posibles anomal√≠as, que se han discutido en detalle anteriormente.  El ingeniero de software siempre debe tenerlos en cuenta y escribir c√≥digo para no permitir que aparezcan.  Si no puede codificar las acciones necesarias en una sola instrucci√≥n SQL, debe recurrir al bloqueo expl√≠cito.  Lo m√°s problem√°tico es que el c√≥digo es dif√≠cil de probar en busca de errores asociados con la obtenci√≥n de datos inconsistentes, y los errores en s√≠ mismos pueden ocurrir de maneras impredecibles y no reproducibles y, por lo tanto, son dif√≠ciles de corregir. <br><br>  El nivel de aislamiento de lectura repetible elimina algunos de los problemas de inconsistencia, pero lamentablemente, no todos.  Por lo tanto, no solo debe recordar las anomal√≠as restantes, sino tambi√©n modificar la aplicaci√≥n para que maneje correctamente los errores de serializaci√≥n.  Ciertamente es inconveniente.  Pero para las transacciones de solo lectura, este nivel complementa perfectamente la lectura confirmada y es muy conveniente, por ejemplo, para crear informes que utilizan m√∫ltiples consultas SQL. <br><br>  Finalmente, el nivel serializable le permite no preocuparse por la inconsistencia, lo que facilita enormemente la codificaci√≥n.  Lo √∫nico que se requiere de la aplicaci√≥n es poder repetir cualquier transacci√≥n al obtener un error de serializaci√≥n.  Pero la fracci√≥n de transacciones anuladas, la sobrecarga adicional y la incapacidad de paralelizar consultas pueden reducir significativamente el rendimiento del sistema.  Tambi√©n tenga en cuenta que el nivel serializable no es aplicable en las r√©plicas, y que no se puede mezclar con otros niveles de aislamiento. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sigue leyendo</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/467437/">https://habr.com/ru/post/467437/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../467423/index.html">Xamarin.Forms: uso conveniente de fuentes de iconos en la aplicaci√≥n</a></li>
<li><a href="../467425/index.html">Enfoque de aprendizaje intensivo STEM</a></li>
<li><a href="../467427/index.html">BudgetTracker: otra herramienta de c√≥digo abierto para la contabilidad financiera personal</a></li>
<li><a href="../467429/index.html">Habrastatistics: explorando las secciones m√°s y menos visitadas del sitio</a></li>
<li><a href="../467435/index.html">Enviamos informes del agente Veeam Linux a correo o en Telegram</a></li>
<li><a href="../467439/index.html">¬øPor qu√© regres√≥ el vinilo y c√≥mo se relacionan los servicios de transmisi√≥n con esto?</a></li>
<li><a href="../467443/index.html">Centro Multimedia "Kodi" y Proyecto Yocto</a></li>
<li><a href="../467445/index.html">Lista evasiva de actualizaciones de Windows instaladas</a></li>
<li><a href="../467449/index.html">Detecci√≥n de vulnerabilidades y evaluaci√≥n de resistencia a ataques de piratas inform√°ticos de tarjetas inteligentes y procesadores criptogr√°ficos con protecci√≥n incorporada</a></li>
<li><a href="../467453/index.html">Resolviendo el problema del n√∫mero 42 usando una supercomputadora planetaria</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>