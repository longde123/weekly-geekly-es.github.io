<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>âœŒğŸ¾ ğŸ‘©ğŸ»â€âš•ï¸ âœŠğŸ» Pekerja Layanan dalam Klien Slack: Pada Percepatan Unduhan dan Mode Offline ğŸ§™ğŸ¾ ğŸ§”ğŸ½ ğŸ™‡ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Materi, terjemahan yang kami terbitkan hari ini, didedikasikan untuk cerita tentang mengoptimalkan versi baru dari klien desktop Slack , salah satu fi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pekerja Layanan dalam Klien Slack: Pada Percepatan Unduhan dan Mode Offline</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/468409/">  Materi, terjemahan yang kami terbitkan hari ini, didedikasikan untuk cerita tentang mengoptimalkan versi baru dari klien desktop <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Slack</a> , salah satu fitur utama di antaranya adalah percepatan pemuatan. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/yq/fs/2h/yqfs2hg85qatg9osvxq8onvkhue.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Latar belakang</font> </h2><br>  Pada awal pengerjaan pada versi baru dari klien desktop Slack, sebuah prototipe telah dibuat, yang disebut "sepatu boot cepat".  Tujuan prototipe ini, seperti yang Anda duga, adalah untuk mempercepat unduhan sebanyak mungkin.  Menggunakan file HTML dari cache CDN, data penyimpanan Redux disimpan di muka, dan pekerja layanan, kami dapat memuat versi ringan dari klien dalam waktu kurang dari satu detik (pada waktu itu, waktu pengunduhan yang biasa untuk pengguna dengan 1-2 ruang kerja adalah sekitar 5 detik )  Pekerja layanan adalah pusat percepatan ini.  Selain itu, ia membuka jalan bagi peluang yang sering kami minta para pengguna Slack untuk diimplementasikan.  Kita berbicara tentang mode offline klien.  Prototipe memungkinkan kami untuk benar-benar melihat dengan satu mata apa yang dapat dibuat ulang oleh klien.  Berdasarkan teknologi di atas, kami mulai memproses klien Slack, secara kasar membayangkan hasilnya dan berfokus pada mempercepat pemuatan dan menerapkan mode operasi program offline.  Mari kita bicara tentang bagaimana inti dari klien yang diperbarui bekerja. <br><br><h2>  <font color="#3AC1EF">Apa itu pekerja layanan?</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Service Worker</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Service Worker</a> ), pada kenyataannya, adalah objek proxy yang kuat untuk permintaan jaringan, yang memungkinkan pengembang, menggunakan sejumlah kecil kode JavaScript, untuk mengontrol bagaimana browser memproses permintaan HTTP individual.  Pekerja layanan mendukung API caching yang canggih dan fleksibel, yang dirancang sedemikian rupa sehingga objek Permintaan digunakan sebagai kunci, dan objek Respons digunakan sebagai nilai.  Pekerja layanan, seperti pekerja Web, dieksekusi dalam proses mereka sendiri, di luar utas eksekusi kode JavaScript utama dari jendela browser apa pun. <br><br>  Pekerja Layanan adalah pengikut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cache Aplikasi</a> , yang sekarang sudah tidak digunakan lagi.  Itu adalah satu set API yang diwakili oleh antarmuka <code>AppCache</code> , yang digunakan untuk membuat situs yang mengimplementasikan fitur offline.  Saat bekerja dengan <code>AppCache</code> , file manifes statis digunakan yang menjelaskan file yang ingin di-cache oleh pengembang untuk digunakan offline.  Secara umum, fitur <code>AppCache</code> terbatas pada ini.  Mekanisme ini sederhana, tetapi tidak fleksibel, yang tidak memberikan kontrol khusus pengembang atas cache.  Di W3C, ini diperhitungkan saat mengembangkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spesifikasi Pekerja Layanan</a> .  Akibatnya, pekerja layanan memungkinkan pengembang untuk mengelola banyak detail mengenai setiap sesi interaksi jaringan yang dilakukan oleh aplikasi web atau situs web. <br><br>  Ketika kami pertama kali mulai bekerja dengan teknologi ini, Chrome adalah satu-satunya browser yang mendukungnya, tetapi kami tahu bahwa tidak ada banyak waktu untuk menunggu dukungan luas bagi pekerja layanan.  Sekarang teknologi ini ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mana</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mana</a> , didukung oleh semua browser utama. <br><br><h2>  <font color="#3AC1EF">Bagaimana kami menggunakan pekerja layanan</font> </h2><br>  Ketika pengguna meluncurkan klien Slack baru untuk pertama kalinya, kami mengunduh satu set lengkap sumber daya (HTML, JavaScript, CSS, font dan suara) dan menempatkannya dalam cache pekerja layanan.  Selain itu, kami membuat salinan toko Redux yang terletak di memori dan menulis salinan ini ke basis data IndexedDB.  Saat program diluncurkan di waktu berikutnya, kami memeriksa keberadaan cache yang sesuai.  Jika ya, kami menggunakannya saat mengunduh aplikasi.  Jika pengguna terhubung ke Internet, kami mengunduh data terbaru setelah meluncurkan aplikasi.  Jika tidak, klien tetap beroperasi. <br><br>  Untuk membedakan antara dua opsi di atas untuk memuat klien - kami memberi mereka nama: unduhan panas (hangat) dan dingin (dingin).  Boot dingin klien paling sering terjadi ketika pengguna meluncurkan program untuk pertama kalinya.  Dalam situasi ini, tidak ada sumber daya yang di-cache atau data Redux yang disimpan.  Dengan boot panas, kami memiliki semua yang Anda butuhkan untuk menjalankan klien Slack di komputer pengguna.  Harap perhatikan bahwa sebagian besar sumber daya biner (gambar, PDF, video, dan sebagainya) diproses menggunakan cache browser (sumber daya ini dikendalikan oleh tajuk cache reguler).  Pekerja layanan tidak boleh memprosesnya dengan cara khusus sehingga kami dapat bekerja dengannya secara offline. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e2/86c/d90/3e286cd909ec21f50aec8152ac59baf1.png"></div><br>  <i><font color="#999999">Pilihan antara pemuatan panas dan dingin</font></i> <br><br><h2>  <font color="#3AC1EF">Siklus Hidup Pekerja Layanan</font> </h2><br>  Pekerja layanan dapat menangani tiga acara siklus hidup.  Ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">instal</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ambil</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aktifkan</a> .  Di bawah ini kita akan berbicara tentang bagaimana kita menanggapi masing-masing peristiwa ini, tetapi pertama-tama kita perlu berbicara tentang mengunduh dan mendaftarkan pekerja layanan itu sendiri.  Siklus hidupnya tergantung pada bagaimana browser menangani pembaruan file pekerja layanan.  Inilah yang dapat Anda baca tentang hal itu di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MDN</a> : â€œInstalasi dilakukan jika file yang diunduh dikenali sebagai baru.  Ini bisa berupa file yang berbeda dari yang ada (perbedaan dalam file ditentukan dengan membandingkannya dengan byte), atau file pekerja layanan yang pertama kali ditemukan oleh browser pada halaman yang sedang diproses. " <br><br>  Setiap kali kami memperbarui file JavaScript, CSS, atau HTML yang sesuai, itu berjalan melalui plugin Webpack khusus, yang membuat manifes dengan deskripsi file yang sesuai dengan hash unik ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berikut adalah</a> contoh singkatan dari file manifes).  Manifes ini tertanam dalam kode pekerja layanan, yang menyebabkan pekerja layanan diperbarui pada boot berikutnya.  Selain itu, ini dilakukan bahkan ketika implementasi pekerja layanan tidak berubah. <br><br><h3>  <font color="#3AC1EF">â–Event acara</font> </h3><br>  Setiap kali seorang pekerja layanan diperbarui, kami mendapatkan acara <code>install</code> .  Menanggapi itu, kita pergi melalui file, deskripsi yang terkandung dalam manifes dibangun ke pekerja layanan, memuat masing-masing dan menempatkannya di blok cache yang sesuai.  Penyimpanan file diatur menggunakan API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cache</a> baru, yang merupakan bagian dari spesifikasi Pekerja Layanan.  API ini menyimpan objek <code>Response</code> menggunakan objek <code>Request</code> sebagai kunci.  Sebagai hasilnya, ternyata penyimpanannya sangat sederhana.  Ini berjalan baik dengan bagaimana peristiwa pekerja layanan menerima permintaan dan mengembalikan respons. <br><br>  Kunci untuk blok cache ditugaskan berdasarkan waktu penyebaran solusi.  Cap waktu disematkan dalam kode HTML, sebagai hasilnya, dapat dikirim, sebagai bagian dari nama file, dalam permintaan untuk mengunduh setiap sumber daya.  Caching sumber daya yang terpisah dari setiap penyebaran penting untuk menghindari berbagi sumber daya yang tidak kompatibel.  Berkat ini, kami dapat memastikan bahwa file HTML yang awalnya diunduh hanya akan mengunduh sumber daya yang kompatibel, dan ini benar baik ketika mereka diunduh melalui jaringan dan ketika mereka diunduh dari cache. <br><br><h3>  <font color="#3AC1EF">â–Event mengambil</font> </h3><br>  Setelah pekerja layanan terdaftar, itu akan mulai memproses semua permintaan jaringan milik sumber yang sama.  Pengembang tidak dapat membuatnya sehingga beberapa permintaan diproses oleh pekerja layanan, sementara yang lain tidak.  Tetapi pengembang memiliki kontrol penuh atas apa yang sebenarnya perlu dilakukan dengan permintaan yang diterima oleh pekerja layanan. <br><br>  Saat memproses permintaan, pertama-tama kami memeriksanya.  Jika yang diminta ada di manifes dan ada di cache, kami mengembalikan respons ke permintaan dengan mengambil data dari cache.  Jika cache tidak memiliki apa yang Anda butuhkan, kami mengembalikan permintaan jaringan nyata yang mengakses sumber daya jaringan nyata seolah-olah pekerja layanan sama sekali tidak terlibat dalam proses ini.  Berikut ini adalah versi sederhana dari pengendali acara <code>fetch</code> kami: <br><br><pre> <code class="javascript hljs">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, (e) =&gt; {  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (assetManifest.includes(e.request.url) {    e.respondWith(      caches        .open(cacheKey)        .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cache</span></span></span><span class="hljs-function"> =&gt;</span></span> cache.match(e.request))        .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> {          <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response;          <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetch(e.request);        });    );  } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {    e.respondWith(fetch(e.request));  } });</code> </pre> <br>  Pada kenyataannya, kode seperti itu mengandung lebih banyak logika Slack-specific, tetapi inti dari handler kami sesederhana dalam contoh ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cf/86d/f94/1cf86df942a3064ac14c75cc47220fc1.png"></div><br>  <i><font color="#999999">Saat menganalisis interaksi jaringan, respons yang dikembalikan dari pekerja layanan dapat dikenali oleh tanda ServiceWorker di kolom yang menunjukkan jumlah data</font></i> <br><br><h3>  <font color="#3AC1EF">â–Event aktifkan</font> </h3><br>  Acara <code>activate</code> dinaikkan setelah instalasi yang berhasil dari pekerja layanan baru atau diperbarui.  Kami menggunakannya untuk menganalisis sumber daya yang di-cache dan membatalkan blok cache yang lebih tua dari 7 hari.  Ini adalah praktik yang baik untuk memelihara sistem secara berurutan, dan di samping itu, ini memungkinkan Anda untuk memastikan bahwa sumber daya yang terlalu lama tidak digunakan saat memuat klien. <br><br><h2>  <font color="#3AC1EF">Kode klien tertinggal di belakang rilis terbaru</font> </h2><br>  Anda mungkin telah memperhatikan bahwa implementasi kami menyiratkan bahwa siapa pun yang memulai klien Slack setelah awal klien tidak akan menerima bukan yang terbaru, tetapi sumber daya yang di-cache dimuat selama pendaftaran sebelumnya dari pekerja layanan.  Dalam implementasi klien asli, kami mencoba memperbarui pekerja layanan setelah setiap unduhan.  Namun, pengguna Slack biasa dapat, misalnya, mengunduh program hanya sekali sehari, di pagi hari.  Hal ini dapat mengarah pada fakta bahwa ia akan terus bekerja dengan klien yang kodenya sepanjang hari tertinggal dari rilis terbaru (kami merilis rilis baru beberapa kali sehari). <br><br>  Tidak seperti situs web biasa, yang setelah mengunjungi, dengan cepat pergi, klien Slack pada komputer pengguna terbuka selama berjam-jam dan dalam keadaan terbuka.  Akibatnya, kode kami memiliki masa pakai yang agak panjang, yang mengharuskan kami untuk menggunakan pendekatan khusus untuk mempertahankan relevansinya. <br><br>  Pada saat yang sama, kami berusaha untuk memastikan bahwa pengguna bekerja dengan versi terbaru dari kode, sehingga mereka menerima fitur terbaru, perbaikan bug, dan peningkatan kinerja.  Tidak lama setelah kami merilis klien baru, kami menerapkan mekanisme di dalamnya yang memungkinkan kami untuk mempersempit kesenjangan antara apa yang bekerja dengan pengguna dan apa yang telah kami lepaskan.  Jika, setelah pembaruan terakhir, versi baru dari sistem dikerahkan, kami memuat sumber daya segar yang akan digunakan saat berikutnya klien melakukan booting.  Jika tidak ada yang baru dapat ditemukan, maka tidak ada yang dimuat.  Setelah perubahan ini dibuat untuk klien, waktu hidup rata-rata sumber daya yang digunakan klien dibelah dua. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc5/6bd/544/bc56bd544f49378516f608c8e4e321f9.png"></div><br>  <i><font color="#999999">Versi baru kode diunduh secara teratur, tetapi saat mengunduh program, hanya versi terbaru yang digunakan</font></i> <br><br><h2>  <font color="#3AC1EF">Sinkronisasi Bendera Fitur Baru</font> </h2><br>  Dengan bantuan bendera fitur baru (Bendera Fitur) kami menandai basis kode yang berfungsi yang belum selesai.  Ini memungkinkan kami untuk memasukkan fitur-fitur baru dalam kode sebelum rilis publik mereka.  Pendekatan ini mengurangi risiko kesalahan dalam produksi karena fakta bahwa fitur-fitur baru dapat diuji secara bebas bersama dengan sisa aplikasi, melakukan ini jauh sebelum pekerjaan pada mereka selesai. <br><br>  Fitur-fitur baru di Slack biasanya dirilis ketika mereka membuat perubahan pada API yang sesuai.  Sebelum kami mulai menggunakan pekerja layanan, kami memiliki jaminan bahwa fitur dan perubahan baru dalam API akan selalu disinkronkan.  Tetapi setelah kami mulai menggunakan cache, yang mungkin tidak mengandung versi terbaru dari kode, ternyata klien mungkin berada dalam situasi di mana kode tidak disinkronkan dengan kemampuan backend.  Untuk mengatasi masalah ini, kami menyimpan tidak hanya sumber daya, tetapi juga beberapa respons API. <br><br>  Fakta bahwa pekerja layanan memproses sepenuhnya semua permintaan jaringan telah menyederhanakan solusi.  Dengan setiap pembaruan pekerja layanan, kami, antara lain, mengeksekusi permintaan API, caching tanggapan dalam blok cache yang sama dengan sumber daya yang sesuai.  Ini menghubungkan kemampuan dan fungsi eksperimental dengan sumber daya yang tepat - berpotensi usang, tetapi dijamin akan konsisten satu sama lain. <br><br>  Ini, pada kenyataannya, hanya puncak gunung es peluang yang tersedia untuk pengembang berkat pekerja layanan.  Masalah yang tidak dapat dipecahkan menggunakan mekanisme <code>AppCache</code> , atau yang membutuhkan mekanisme klien dan server untuk dipecahkan, dapat dengan mudah dan alami diselesaikan menggunakan pekerja layanan dan API Cache. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Pekerja layanan mempercepat pemuatan klien Slack dengan mengatur penyimpanan sumber daya lokal yang siap digunakan saat berikutnya klien melakukan booting.  Jaringan - sumber utama keterlambatan dan ambiguitas yang mungkin ditemui pengguna kami, sekarang hampir tidak berpengaruh pada situasi.  Kita, dengan kata lain, menghapusnya dari persamaan.  Dan jika Anda dapat menghapus jaringan dari persamaan, maka ternyata Anda dapat mengimplementasikan fungsionalitas offline dalam proyek tersebut.  Dukungan kami untuk mode offline sangat mudah saat ini.  Pengguna dapat mengunduh klien dan dapat membaca pesan dari percakapan yang diunduh.  Sistem pada saat yang sama mempersiapkan tanda sinkronisasi pada pesan yang sudah dibaca.  Tetapi sekarang kita memiliki dasar untuk implementasi mekanisme yang lebih maju di masa depan. <br><br>  Setelah berbulan-bulan pengembangan, eksperimen dan optimalisasi, kami belajar banyak tentang bagaimana pekerja layanan bekerja dalam praktik.  Selain itu, ternyata teknologi ini sangat cocok untuk proyek skala besar.  Dalam waktu kurang dari sebulan sejak rilis publik klien dengan pekerja layanan, kami berhasil melayani puluhan juta permintaan setiap hari dari jutaan pekerja layanan yang dipasang.  Hal ini menyebabkan pengurangan sekitar 50% dalam waktu pemuatan pelanggan baru dibandingkan dengan yang lama, dan fakta bahwa pemuatan panas sekitar 25% lebih cepat daripada dingin. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e8/d46/330/9e8d463303d4002954ada304466550fd.png"></div><br>  <i><font color="#999999">Dari kiri ke kanan: memuat klien lama, memuat dingin klien baru, memuat klien baru (semakin rendah indikator, semakin baik)</font></i> <br><br>  <b>Pembaca yang budiman!</b>  Apakah Anda menggunakan pekerja layanan dalam proyek Anda? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id468409/">https://habr.com/ru/post/id468409/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468399/index.html">C / C ++. Cara menggunakan sumber daya aplikasi tertanam saat bekerja di GCC di Linux</a></li>
<li><a href="../id468401/index.html">Cara aman untuk bertukar JWT di ASP.NET Core + SPA</a></li>
<li><a href="../id468403/index.html">Kontrol runtime aplikasi perangkat lunak internal</a></li>
<li><a href="../id468405/index.html">Dua browser masuk entah ke mana scrollbar ...</a></li>
<li><a href="../id468407/index.html">5G - teknologi yang cenderung memperlambat web</a></li>
<li><a href="../id468411/index.html">Sebuah Cerita Tentang Memecahkan Masalah Kinerja Moment.js</a></li>
<li><a href="../id468413/index.html">Akselerasi instagram.com. Bagian 2</a></li>
<li><a href="../id468417/index.html">3CX v16 Update 3 Beta dirilis - panggilan video di Android dan iOS, koneksi TLS dari batang SIP</a></li>
<li><a href="../id468419/index.html">Google Analytics dan GDPR: Apakah Saya Membutuhkan Persetujuan Pengguna?</a></li>
<li><a href="../id468423/index.html">Mengapa standar USB harus dibuat sedemikian rumit?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>