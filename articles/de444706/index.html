<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚Äçüíª üßëüèª ü§û 3D Facebook Fotos im Inneren: Parallax Shader üê≥ üíÜ üïØÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In den letzten Monaten hat Facebook 3D-Fotos √ºberflutet. Wenn Sie sie nicht sehen konnten, erkl√§re ich Folgendes: 3D-Fotos sind Bilder innerhalb des B...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>3D Facebook Fotos im Inneren: Parallax Shader</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444706/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/653/7e9/cda/6537e9cdaff76aa8cc2716b8b53ecba9.gif" alt="Bild"></div><br>  In den letzten Monaten hat Facebook <strong>3D-Fotos</strong> √ºberflutet.  Wenn Sie sie nicht sehen konnten, erkl√§re ich Folgendes: 3D-Fotos sind Bilder innerhalb des Beitrags, die den Winkel beim Scrollen der Seite oder beim Bewegen der Maus √ºber sie reibungslos √§ndern. <br><br>  Einige Monate vor Erscheinen dieser Funktion testete Facebook eine √§hnliche Funktion mit 3D-Modellen.  Obwohl Sie leicht verstehen k√∂nnen, wie Facebook 3D-Modelle rendern und entsprechend der Position der Maus drehen kann, ist die Situation bei 3D-Fotos m√∂glicherweise nicht so intuitiv. <br><br>  Die Technik, mit der Facebook zweidimensionale Bilder dreidimensional erzeugt, wird manchmal als <strong>H√∂henkartenversatz bezeichnet</strong> .  Es verwendet ein optisches Ph√§nomen namens <strong>Parallaxe</strong> . <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Beispiel eines 3D-Facebook-Fotos (GIF)</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a06/0f6/cbd/a060f6cbde767809731fea11f26034a4.gif"></div></div></div><br><h2>  Was ist Parallaxe? </h2><br>  Wenn Sie Super Mario gespielt haben, wissen Sie genau, was Parallaxe ist.  Obwohl Mario mit der gleichen Geschwindigkeit l√§uft, scheinen sich entfernte Objekte im Hintergrund langsamer zu bewegen (siehe unten). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33a/b4f/3b3/33ab4f3b3e14cc710feb881f935d5162.gif"></div><br>  Dieser Effekt erzeugt die Illusion, dass einige Elemente wie Berge und Wolken weiter entfernt sind.  Es ist effektiv, weil unser Gehirn Parallaxe (zusammen mit anderen visuellen Hinweisen) verwendet, um die Entfernung zu entfernten Objekten abzusch√§tzen. <br><br><div class="spoiler">  <b class="spoiler_title">Wie bewertet das Gehirn die Entfernung?</b> <div class="spoiler_text">  Es wird angenommen, dass das menschliche Gehirn verschiedene Mechanismen verwendet, um die Entfernung abzusch√§tzen.  Bei kurzen und mittleren Entfernungen werden Entfernungen berechnet, indem Unterschiede in der Position des sichtbaren Objekts mit dem rechten und linken Auge verglichen werden.  Dies wird als <strong>stereoskopisches Sehen bezeichnet</strong> und ist in der Natur weit verbreitet. <br><br>  F√ºr ausreichend entfernte Objekte reicht jedoch eine stereoskopische Sicht nicht aus.  Berge, Wolken und Sterne unterscheiden sich zu wenig, als dass verschiedene Augen einen signifikanten Unterschied bemerken k√∂nnten.  Daher kommt die relative Parallaxe ins Spiel.  Objekte im Hintergrund bewegen sich weniger als Objekte im Vordergrund.  Es ist ihre relative Bewegung, mit der Sie den relativen Abstand einstellen k√∂nnen. <br><br>  Bei der Wahrnehmung von Distanz werden viele andere Mechanismen verwendet.  Der bekannteste von ihnen ist der atmosph√§rische Dunst, der entfernten Objekten einen blauen Farbton verleiht.  In anderen Welten existieren die meisten dieser atmosph√§rischen Hinweise nicht, so dass es so schwierig ist, die Gr√∂√üe von Objekten auf anderen Planeten und dem Mond zu beurteilen.  Der YouTube-Nutzer Alex McCulgan erkl√§rt dies auf seinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Astrum-</a> Kanal und zeigt, wie schwierig es ist, die Gr√∂√üe der im Video gezeigten Mondobjekte zu bestimmen. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/5yx3O9cZ5NM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><br><h2>  Parallaxe als Verschiebung </h2><br>  Wenn Sie mit linearer Algebra vertraut sind, wissen Sie wahrscheinlich, wie kompliziert und nicht trivial die Mathematik von 3D-Rotationen sein kann.  Daher gibt es eine viel einfachere M√∂glichkeit, die Parallaxe zu verstehen, die nur Verschiebungen erfordert. <br><br>  Stellen wir uns vor, wir betrachten einen W√ºrfel (siehe unten).  Wenn wir genau auf die Mitte ausgerichtet sind, sehen die Vorder- und R√ºckseite f√ºr unsere Augen wie zwei Quadrate unterschiedlicher Gr√∂√üe aus.  Das ist die <strong>Aussicht</strong> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bac/1ac/714/bac1ac714202cd1fa2e3608646970dca.png"></div><br>  Was passiert jedoch, wenn wir die Kamera nach unten bewegen oder den W√ºrfel nach oben heben?  Bei Anwendung der gleichen Prinzipien k√∂nnen wir sehen, dass sich die Vorder- und R√ºckseite relativ zu ihrer vorherigen Position verschoben haben.  Noch interessanter ist, dass sie sich relativ zueinander bewegt haben.  Die R√ºckseite, die weiter von uns entfernt ist, als w√§re sie weniger bewegt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d8/25a/0e1/4d825a0e105c808d87e1b5995f2faef1.png"></div><br>  Wenn wir die wahren Positionen dieser Eckpunkte des W√ºrfels in unserem projizierten Bereich berechnen m√∂chten, m√ºssen wir die Trigonometrie ernsthaft in Angriff nehmen.  Dies ist jedoch nicht wirklich notwendig.  Wenn die Bewegung der Kamera klein genug ist, k√∂nnen wir die Verschiebung der Scheitelpunkte approximieren und sie proportional zu ihrer Entfernung bewegen. <br><br>  Das einzige, was wir bestimmen m√ºssen, ist die Skalierung.  Wenn wir X Meter nach rechts bewegen, sollte das Objekt Y Meter entfernt Z Meter verschoben haben.  Wenn X klein bleibt, wird die Parallaxe eher zur Aufgabe der <strong>linearen Interpolation</strong> als der Trigonometrie.  Im Wesentlichen bedeutet dies, dass wir kleine 3D-Rotationen simulieren k√∂nnen, indem wir Pixel in Abh√§ngigkeit von ihrem Abstand von der Kamera verschieben. <br><br><h2>  Erstellen Sie Tiefenkarten </h2><br>  Im Prinzip unterscheidet sich Facebook nicht allzu sehr von dem, was in Super Mario passiert.  F√ºr ein bestimmtes Bild werden bestimmte Pixel basierend auf dem Abstand zur Kamera in Bewegungsrichtung verschoben.  Um ein 3D-Foto von Facebook zu erstellen, ben√∂tigen Sie nur das Foto selbst und eine Karte, auf der angegeben ist, wie weit jedes Pixel von der Kamera entfernt ist.  Eine solche Karte hat den erwarteten Namen <strong>"Tiefenkarte"</strong> .  Je nach Kontext wird es auch als <strong>H√∂henkarte bezeichnet</strong> . <br><br>  Das Fotografieren ist ziemlich einfach, aber das Erstellen der richtigen Tiefenkarte ist eine viel schwierigere Aufgabe.  Moderne Ger√§te verwenden verschiedene Techniken.  Verwenden Sie meistens zwei Kameras.  Jedes macht ein Bild des gleichen Motivs, jedoch mit einer etwas anderen Perspektive.  Das gleiche Prinzip wird beim <strong>stereoskopischen Sehen</strong> angewendet, mit dem Menschen die Tiefe bei kurzen und mittleren Entfernungen bewerten.  Das folgende Bild zeigt, wie das iPhone 7 Tiefenkarten aus zwei sehr nahen Bildern erstellen kann. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/903/ab0/c03/903ab0c0376f7978c771352d82b5f648.png"></div><br>  Details zur Implementierung einer solchen Rekonstruktion sind in dem Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Instant 3D Photography beschrieben</a> , der von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Peter Hedman</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Johannes Kopf</a> auf der SIGGRAPH2018 vorgestellt wird. <br><br>  Nach dem Erstellen einer hochwertigen Tiefenkarte wird die Simulation der Dreidimensionalit√§t zu einer fast trivialen Aufgabe.  Die eigentliche Einschr√§nkung dieser Technik besteht darin, dass selbst wenn Sie ein grobes 3D-Modell neu erstellen k√∂nnen, Informationen zum Rendern von Teilen fehlen, die auf dem Originalfoto nicht sichtbar sind.  Im Moment kann dieses Problem nicht gel√∂st werden, und daher sind alle Bewegungen, die in 3D-Fotografien sichtbar sind, eher unbedeutend. <br><br>  Wir haben uns mit dem Konzept von 3D-Fotos vertraut gemacht und kurz dar√ºber gesprochen, wie moderne Smartphones sie erstellen k√∂nnen.  Im zweiten Teil lernen wir, wie dieselben Techniken verwendet werden k√∂nnen, um 3D-Fotos in Unity mithilfe von Shadern zu implementieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/653/7e9/cda/6537e9cdaff76aa8cc2716b8b53ecba9.gif"></div><br><h2>  Teil 2. Parallaxen-Shader und Tiefenkarten </h2><br><h4>  Shader-Vorlage </h4><br>  Wenn wir 3D-Fotos von Facebook mit einem Shader neu erstellen m√∂chten, m√ºssen wir zuerst entscheiden, was genau wir tun.  Da dieser Effekt am besten mit 2D-Bildern funktioniert, w√§re es logisch, eine mit Unity-Sprites kompatible L√∂sung zu implementieren.  Wir werden einen Shader erstellen, der mit <strong>Sprite Renderer verwendet werden kann</strong> . <br><br>  Obwohl ein solcher Shader von Grund auf neu erstellt werden kann, ist es oft vorzuziehen, mit einer vorgefertigten Vorlage zu beginnen.  Beginnen Sie am besten, indem Sie den vorhandenen diffusen Shader von Sprites kopieren, den Unity standardm√§√üig f√ºr alle Sprites verwendet.  Leider enth√§lt die Engine keine <em>Shader-</em> Datei, die Sie selbst bearbeiten k√∂nnen. <br><br>  Um es zu erhalten, m√ºssen Sie zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Unity-Download-Archiv gehen</a> und das integrierte <em>Shader-</em> Paket (siehe unten) f√ºr die Version der von Ihnen verwendeten Engine herunterladen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d00/1b9/da8/d001b9da891e60ef4b93f89ffb8a9fda.png"></div><br>  Nach dem Extrahieren des Pakets k√∂nnen Sie den Quellcode aller mit Unity gelieferten Shader anzeigen.  Wir interessieren uns f√ºr die Datei <em>Sprites-Diffuse.shader</em> , die standardm√§√üig f√ºr alle erstellten Sprites verwendet wird. <br><br><h2>  Bilder </h2><br>  Der zweite Aspekt, der formalisiert werden muss, sind die Daten, die wir haben.  Stellen Sie sich vor, wir haben sowohl das Bild, das wir animieren m√∂chten, als auch seine Tiefenkarte.  Letzteres ist ein Schwarzwei√übild, in dem Schwarzwei√üpixel angeben, wie weit oder nah sie von der Kamera entfernt sind. <br><br>  Die in diesem Tutorial verwendeten Bilder stammen aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Dennis Hotsons</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Pickle-Katzenprojekt</a> , und dies ist ohne Zweifel das Beste, das Sie heute sehen werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/03c/9ee/9c0/03c9ee9c0a5f15908ea183bf0b4bea98.png"></div><br>  Die diesem Bild zugeordnete H√∂henkarte gibt die Entfernung des Katzengesichts von der Kamera wieder. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/54c/f5b/d2d/54cf5bd2d93144efb7371c3076b6541c.jpg"></div><br>  Es ist leicht zu erkennen, wie gute Ergebnisse mit einer so einfachen Tiefenkarte erzielt werden k√∂nnen.  Dies bedeutet, dass es einfach ist, eigene Tiefenkarten f√ºr vorhandene Bilder zu erstellen. <br><br><h2>  Die Eigenschaften </h2><br>  Nachdem wir alle Ressourcen haben, k√∂nnen wir mit dem Schreiben des Parallax-Shader-Codes beginnen.  Wenn wir das Hauptbild als Sprite importieren, <code>_MainTex</code> Unity es automatisch √ºber die Eigenschaft <code>_MainTex</code> an den Shader.  Wir m√ºssen jedoch die Tiefenkarte dem Shader zur Verf√ºgung stellen.  Dies kann mithilfe einer neuen <strong>Shader-Eigenschaft</strong> namens <code>_HeightTex</code> .  Ich habe absichtlich beschlossen, es nicht <code>_DepthTex</code> zu nennen, um es nicht mit der <strong>Tiefenstruktur</strong> zu verwechseln (dies ist ein √§hnliches Unity-Konzept, das zum Rendern der Szenentiefenkarte verwendet wird). <br><br>  Um die St√§rke des Effekts zu √§ndern, f√ºgen wir auch die Eigenschaft <code>_Scale</code> . <br><br><pre> <code class="cpp hljs">Properties { ... _HeightTex (<span class="hljs-string"><span class="hljs-string">"Heightmap (R)"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"gray"</span></span> {} _Scale (<span class="hljs-string"><span class="hljs-string">"Scale"</span></span>, Vector) = (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) }</code> </pre> <br>  Diese beiden neuen Eigenschaften sollten auch zwei Variablen mit demselben Namen entsprechen, die dem <code>ENDCG</code> <code>CGPROGRAM</code> / <code>ENDCG</code> hinzugef√ºgt werden <code>ENDCG</code> : <br><br><pre> <code class="cpp hljs">sampler2D _HeightTex; fixed2 _Scale;</code> </pre> <br>  Jetzt ist alles fertig und wir k√∂nnen mit dem Schreiben von Code beginnen, der den Offset ausf√ºhrt. <br><br>  Der erste Schritt besteht darin, den Wert aus der Tiefenkarte <code>tex2D</code> , was mit der Funktion <code>tex2D</code> kann.  Da <code>_HeightTex</code> eine Schwarz-Wei√ü-Textur ist, k√∂nnen wir einfach den roten Kanal nehmen und den Rest verwerfen.  Der resultierende Wert misst den Abstand in einigen willk√ºrlichen Einheiten vom aktuellen Pixel zur Kamera. <br><br>  Der Tiefenwert liegt zwischen <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>0</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhgRoZq2-P2qd57qJXBZwe0btTDGWQ#MJMAIN-30" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>0</mn></math></span></span><script type="math/tex" id="MathJax-Element-1"> 0 </script>  vorher <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhgRoZq2-P2qd57qJXBZwe0btTDGWQ#MJMAIN-31" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-2"> 1 </script>  aber wir werden es auf das Intervall von strecken <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo>&amp;#x2212;</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.971ex" height="2.057ex" viewBox="0 -728.2 1279 885.9" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhgRoZq2-P2qd57qJXBZwe0btTDGWQ#MJMAIN-2212" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhgRoZq2-P2qd57qJXBZwe0btTDGWQ#MJMAIN-31" x="778" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo>‚àí</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-3"> -1 </script>  vorher <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.971ex" height="2.057ex" viewBox="0 -728.2 1279 885.9" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhgRoZq2-P2qd57qJXBZwe0btTDGWQ#MJMAIN-2B" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhgRoZq2-P2qd57qJXBZwe0btTDGWQ#MJMAIN-31" x="778" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-4"> + 1 </script>  .  Auf diese Weise k√∂nnen Sie sowohl positive (wei√üe Farbe) als auch negative (schwarze Farbe) Parallaxe bereitstellen. <br><br><h2>  Theorie </h2><br>  Um den Parallaxeneffekt in diesem Stadium zu simulieren, m√ºssen wir die Tiefeninformationen verwenden, um die Pixel des Bildes zu verschieben.  Je n√§her das Pixel ist, desto st√§rker muss es verschoben werden.  Dieser Vorgang wird in der folgenden Abbildung erl√§utert.  Das rote Pixel aus dem <em>Originalbild sollte</em> gem√§√ü den Informationen aus der Tiefenkarte zwei Pixel nach links verschieben.  Ebenso sollte das blaue Pixel zwei Pixel nach rechts verschieben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/457/008/e69/457008e692048d9b5ef8eb2964f35fe2.png"></div><br>  Obwohl dies <em>theoretisch</em> funktionieren sollte, gibt es keine einfachen M√∂glichkeiten, dies im Shader zu implementieren.  Die Sache ist, dass ein Shader nach seinem Prinzip nur die Farbe des <em>aktuellen</em> Pixels √§ndern kann.  Bei der Ausf√ºhrung des Shader-Codes muss ein bestimmtes Pixel auf dem Bildschirm gezeichnet werden.  Wir k√∂nnen dieses Pixel nicht einfach an einen anderen Ort verschieben oder die Farbe des benachbarten Pixels √§ndern.  Diese <em>Einschr√§nkung der Lokalit√§t</em> bietet einen sehr effizienten Parallelbetrieb von Shadern, erm√∂glicht es uns jedoch nicht, alle Arten von Effekten zu implementieren, die trivial w√§ren, vorausgesetzt, es gibt einen <em>zuf√§lligen Zugriff f√ºr die Aufzeichnung</em> auf jedes Pixel im Bild. <br><br>  Wenn wir genau sein wollen, m√ºssen wir die Tiefenkarte aller benachbarten Pixel abtasten, um herauszufinden, welche an die aktuelle Position verschoben werden soll (falls sollte).  Wenn sich mehrere Pixel an derselben Stelle befinden sollten, k√∂nnen wir ihren Einfluss mitteln.  Obwohl ein solches System funktioniert und das bestm√∂gliche Ergebnis liefert, ist es √§u√üerst ineffizient und m√∂glicherweise hunderte Male langsamer als der urspr√ºngliche diffuse Shader, mit dem wir begonnen haben. <br><br>  Die beste Alternative w√§re die folgende L√∂sung: Wir erhalten die Tiefe des aktuellen Pixels aus der Tiefenkarte;  Wenn wir es dann <em>nach rechts verschieben m√ºssen</em> , ersetzen Sie die aktuelle Farbe durch das Pixel <em>auf der linken Seite</em> (siehe Abbildung unten).  Hier nehmen wir an, dass, wenn Sie das Pixel nach rechts verschieben m√∂chten, die benachbarten Pixel auf der linken Seite ebenfalls auf die gleiche Weise verschoben werden sollen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/699/cc8/7c0/699cc87c06761842edfc77449c195b43.png"></div><br>  Es ist leicht zu erkennen, dass dies nur eine kosteng√ºnstige Ann√§herung an das ist, was wir wirklich erreichen wollten.  Es ist jedoch sehr effektiv, da sich Tiefenkarten normalerweise als glatt herausstellen. <br><br><h2>  Code </h2><br>  Nach dem im vorherigen Abschnitt beschriebenen Algorithmus k√∂nnen wir den Parallax-Shader mit einem einfachen <strong>Versatz der UV-Koordinaten</strong> implementieren. <br><br>  Dies f√ºhrt zu folgendem Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Displacement fixed height = tex2D(_HeightTex, IN.uv_MainTex).r; fixed2 displacement = _Scale * ((height - 0.5) * 2); fixed4 c = SampleSpriteTexture (IN.uv_MainTex - displacement) * IN.color; ... }</span></span></code> </pre> <br>  Diese Technik funktioniert gut mit fast flachen Objekten, wie in der folgenden Animation gezeigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ba/0c4/b8f/8ba0c4b8fa0fc51bf86c0874139feedb.gif"></div><br>  Aber es funktioniert wirklich sehr gut mit 3D-Modellen, da es sehr einfach ist, die Tiefenstruktur f√ºr eine 3D-Szene zu rendern.  Unten sehen Sie ein 3D-gerendertes Bild und seine Tiefenkarte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/701/179/d0f/701179d0f52d53b25f9d079d60dc8ae3.jpg"></div><br>  Die fertigen Ergebnisse werden hier angezeigt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51d/134/28c/51d13428ce1f6b84cbb6b62984f86fe4.gif"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444706/">https://habr.com/ru/post/de444706/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444692/index.html">MOSDROID # 16 Schwefel bei Redmadrobot</a></li>
<li><a href="../de444694/index.html">Wie wir den Abfluss vorhergesagt haben, n√§hern wir uns ihm als Naturkatastrophe</a></li>
<li><a href="../de444696/index.html">Erh√∂hen Sie die Containerdichte auf einem Knoten mithilfe der PFCACHE-Technologie</a></li>
<li><a href="../de444700/index.html">Zuf√§llige Datenbanken. Oracle Enterprise Data Quality - Schutzschild und Schwert f√ºr Enterprise Storage</a></li>
<li><a href="../de444704/index.html">Chancen nanoCAD SPDS Baustelle bei Bau- und Wiederaufbauprojekten unter beengten Verh√§ltnissen</a></li>
<li><a href="../de444708/index.html">PentQL-Anwendung mit GraphQL</a></li>
<li><a href="../de444710/index.html">Verst√§ndnis des Stellar Consensus Protocol</a></li>
<li><a href="../de444712/index.html">‚ÄûAtypische Einstellung zur Finanzierung‚Äú - was ist, wenn die Mitarbeiter das Einkommen selbst verwalten? Gespr√§ch mit Flant</a></li>
<li><a href="../de444714/index.html">Wie wir CAD COMPASS-3D ‚Üí Teil 1 √ºbertaktet haben</a></li>
<li><a href="../de444716/index.html">Ein Samsung-Handy mit einem faltbaren Bildschirm f√ºr 2000 US-Dollar zeigt eine Falte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>