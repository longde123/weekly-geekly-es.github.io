<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍💻 🧑🏻 🤞 3D Facebook Fotos im Inneren: Parallax Shader 🐳 💆 🕯️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In den letzten Monaten hat Facebook 3D-Fotos überflutet. Wenn Sie sie nicht sehen konnten, erkläre ich Folgendes: 3D-Fotos sind Bilder innerhalb des B...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>3D Facebook Fotos im Inneren: Parallax Shader</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444706/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/653/7e9/cda/6537e9cdaff76aa8cc2716b8b53ecba9.gif" alt="Bild"></div><br>  In den letzten Monaten hat Facebook <strong>3D-Fotos</strong> überflutet.  Wenn Sie sie nicht sehen konnten, erkläre ich Folgendes: 3D-Fotos sind Bilder innerhalb des Beitrags, die den Winkel beim Scrollen der Seite oder beim Bewegen der Maus über sie reibungslos ändern. <br><br>  Einige Monate vor Erscheinen dieser Funktion testete Facebook eine ähnliche Funktion mit 3D-Modellen.  Obwohl Sie leicht verstehen können, wie Facebook 3D-Modelle rendern und entsprechend der Position der Maus drehen kann, ist die Situation bei 3D-Fotos möglicherweise nicht so intuitiv. <br><br>  Die Technik, mit der Facebook zweidimensionale Bilder dreidimensional erzeugt, wird manchmal als <strong>Höhenkartenversatz bezeichnet</strong> .  Es verwendet ein optisches Phänomen namens <strong>Parallaxe</strong> . <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Beispiel eines 3D-Facebook-Fotos (GIF)</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a06/0f6/cbd/a060f6cbde767809731fea11f26034a4.gif"></div></div></div><br><h2>  Was ist Parallaxe? </h2><br>  Wenn Sie Super Mario gespielt haben, wissen Sie genau, was Parallaxe ist.  Obwohl Mario mit der gleichen Geschwindigkeit läuft, scheinen sich entfernte Objekte im Hintergrund langsamer zu bewegen (siehe unten). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33a/b4f/3b3/33ab4f3b3e14cc710feb881f935d5162.gif"></div><br>  Dieser Effekt erzeugt die Illusion, dass einige Elemente wie Berge und Wolken weiter entfernt sind.  Es ist effektiv, weil unser Gehirn Parallaxe (zusammen mit anderen visuellen Hinweisen) verwendet, um die Entfernung zu entfernten Objekten abzuschätzen. <br><br><div class="spoiler">  <b class="spoiler_title">Wie bewertet das Gehirn die Entfernung?</b> <div class="spoiler_text">  Es wird angenommen, dass das menschliche Gehirn verschiedene Mechanismen verwendet, um die Entfernung abzuschätzen.  Bei kurzen und mittleren Entfernungen werden Entfernungen berechnet, indem Unterschiede in der Position des sichtbaren Objekts mit dem rechten und linken Auge verglichen werden.  Dies wird als <strong>stereoskopisches Sehen bezeichnet</strong> und ist in der Natur weit verbreitet. <br><br>  Für ausreichend entfernte Objekte reicht jedoch eine stereoskopische Sicht nicht aus.  Berge, Wolken und Sterne unterscheiden sich zu wenig, als dass verschiedene Augen einen signifikanten Unterschied bemerken könnten.  Daher kommt die relative Parallaxe ins Spiel.  Objekte im Hintergrund bewegen sich weniger als Objekte im Vordergrund.  Es ist ihre relative Bewegung, mit der Sie den relativen Abstand einstellen können. <br><br>  Bei der Wahrnehmung von Distanz werden viele andere Mechanismen verwendet.  Der bekannteste von ihnen ist der atmosphärische Dunst, der entfernten Objekten einen blauen Farbton verleiht.  In anderen Welten existieren die meisten dieser atmosphärischen Hinweise nicht, so dass es so schwierig ist, die Größe von Objekten auf anderen Planeten und dem Mond zu beurteilen.  Der YouTube-Nutzer Alex McCulgan erklärt dies auf seinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Astrum-</a> Kanal und zeigt, wie schwierig es ist, die Größe der im Video gezeigten Mondobjekte zu bestimmen. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/5yx3O9cZ5NM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><br><h2>  Parallaxe als Verschiebung </h2><br>  Wenn Sie mit linearer Algebra vertraut sind, wissen Sie wahrscheinlich, wie kompliziert und nicht trivial die Mathematik von 3D-Rotationen sein kann.  Daher gibt es eine viel einfachere Möglichkeit, die Parallaxe zu verstehen, die nur Verschiebungen erfordert. <br><br>  Stellen wir uns vor, wir betrachten einen Würfel (siehe unten).  Wenn wir genau auf die Mitte ausgerichtet sind, sehen die Vorder- und Rückseite für unsere Augen wie zwei Quadrate unterschiedlicher Größe aus.  Das ist die <strong>Aussicht</strong> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bac/1ac/714/bac1ac714202cd1fa2e3608646970dca.png"></div><br>  Was passiert jedoch, wenn wir die Kamera nach unten bewegen oder den Würfel nach oben heben?  Bei Anwendung der gleichen Prinzipien können wir sehen, dass sich die Vorder- und Rückseite relativ zu ihrer vorherigen Position verschoben haben.  Noch interessanter ist, dass sie sich relativ zueinander bewegt haben.  Die Rückseite, die weiter von uns entfernt ist, als wäre sie weniger bewegt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d8/25a/0e1/4d825a0e105c808d87e1b5995f2faef1.png"></div><br>  Wenn wir die wahren Positionen dieser Eckpunkte des Würfels in unserem projizierten Bereich berechnen möchten, müssen wir die Trigonometrie ernsthaft in Angriff nehmen.  Dies ist jedoch nicht wirklich notwendig.  Wenn die Bewegung der Kamera klein genug ist, können wir die Verschiebung der Scheitelpunkte approximieren und sie proportional zu ihrer Entfernung bewegen. <br><br>  Das einzige, was wir bestimmen müssen, ist die Skalierung.  Wenn wir X Meter nach rechts bewegen, sollte das Objekt Y Meter entfernt Z Meter verschoben haben.  Wenn X klein bleibt, wird die Parallaxe eher zur Aufgabe der <strong>linearen Interpolation</strong> als der Trigonometrie.  Im Wesentlichen bedeutet dies, dass wir kleine 3D-Rotationen simulieren können, indem wir Pixel in Abhängigkeit von ihrem Abstand von der Kamera verschieben. <br><br><h2>  Erstellen Sie Tiefenkarten </h2><br>  Im Prinzip unterscheidet sich Facebook nicht allzu sehr von dem, was in Super Mario passiert.  Für ein bestimmtes Bild werden bestimmte Pixel basierend auf dem Abstand zur Kamera in Bewegungsrichtung verschoben.  Um ein 3D-Foto von Facebook zu erstellen, benötigen Sie nur das Foto selbst und eine Karte, auf der angegeben ist, wie weit jedes Pixel von der Kamera entfernt ist.  Eine solche Karte hat den erwarteten Namen <strong>"Tiefenkarte"</strong> .  Je nach Kontext wird es auch als <strong>Höhenkarte bezeichnet</strong> . <br><br>  Das Fotografieren ist ziemlich einfach, aber das Erstellen der richtigen Tiefenkarte ist eine viel schwierigere Aufgabe.  Moderne Geräte verwenden verschiedene Techniken.  Verwenden Sie meistens zwei Kameras.  Jedes macht ein Bild des gleichen Motivs, jedoch mit einer etwas anderen Perspektive.  Das gleiche Prinzip wird beim <strong>stereoskopischen Sehen</strong> angewendet, mit dem Menschen die Tiefe bei kurzen und mittleren Entfernungen bewerten.  Das folgende Bild zeigt, wie das iPhone 7 Tiefenkarten aus zwei sehr nahen Bildern erstellen kann. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/903/ab0/c03/903ab0c0376f7978c771352d82b5f648.png"></div><br>  Details zur Implementierung einer solchen Rekonstruktion sind in dem Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Instant 3D Photography beschrieben</a> , der von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Peter Hedman</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Johannes Kopf</a> auf der SIGGRAPH2018 vorgestellt wird. <br><br>  Nach dem Erstellen einer hochwertigen Tiefenkarte wird die Simulation der Dreidimensionalität zu einer fast trivialen Aufgabe.  Die eigentliche Einschränkung dieser Technik besteht darin, dass selbst wenn Sie ein grobes 3D-Modell neu erstellen können, Informationen zum Rendern von Teilen fehlen, die auf dem Originalfoto nicht sichtbar sind.  Im Moment kann dieses Problem nicht gelöst werden, und daher sind alle Bewegungen, die in 3D-Fotografien sichtbar sind, eher unbedeutend. <br><br>  Wir haben uns mit dem Konzept von 3D-Fotos vertraut gemacht und kurz darüber gesprochen, wie moderne Smartphones sie erstellen können.  Im zweiten Teil lernen wir, wie dieselben Techniken verwendet werden können, um 3D-Fotos in Unity mithilfe von Shadern zu implementieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/653/7e9/cda/6537e9cdaff76aa8cc2716b8b53ecba9.gif"></div><br><h2>  Teil 2. Parallaxen-Shader und Tiefenkarten </h2><br><h4>  Shader-Vorlage </h4><br>  Wenn wir 3D-Fotos von Facebook mit einem Shader neu erstellen möchten, müssen wir zuerst entscheiden, was genau wir tun.  Da dieser Effekt am besten mit 2D-Bildern funktioniert, wäre es logisch, eine mit Unity-Sprites kompatible Lösung zu implementieren.  Wir werden einen Shader erstellen, der mit <strong>Sprite Renderer verwendet werden kann</strong> . <br><br>  Obwohl ein solcher Shader von Grund auf neu erstellt werden kann, ist es oft vorzuziehen, mit einer vorgefertigten Vorlage zu beginnen.  Beginnen Sie am besten, indem Sie den vorhandenen diffusen Shader von Sprites kopieren, den Unity standardmäßig für alle Sprites verwendet.  Leider enthält die Engine keine <em>Shader-</em> Datei, die Sie selbst bearbeiten können. <br><br>  Um es zu erhalten, müssen Sie zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Unity-Download-Archiv gehen</a> und das integrierte <em>Shader-</em> Paket (siehe unten) für die Version der von Ihnen verwendeten Engine herunterladen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d00/1b9/da8/d001b9da891e60ef4b93f89ffb8a9fda.png"></div><br>  Nach dem Extrahieren des Pakets können Sie den Quellcode aller mit Unity gelieferten Shader anzeigen.  Wir interessieren uns für die Datei <em>Sprites-Diffuse.shader</em> , die standardmäßig für alle erstellten Sprites verwendet wird. <br><br><h2>  Bilder </h2><br>  Der zweite Aspekt, der formalisiert werden muss, sind die Daten, die wir haben.  Stellen Sie sich vor, wir haben sowohl das Bild, das wir animieren möchten, als auch seine Tiefenkarte.  Letzteres ist ein Schwarzweißbild, in dem Schwarzweißpixel angeben, wie weit oder nah sie von der Kamera entfernt sind. <br><br>  Die in diesem Tutorial verwendeten Bilder stammen aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Dennis Hotsons</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Pickle-Katzenprojekt</a> , und dies ist ohne Zweifel das Beste, das Sie heute sehen werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/03c/9ee/9c0/03c9ee9c0a5f15908ea183bf0b4bea98.png"></div><br>  Die diesem Bild zugeordnete Höhenkarte gibt die Entfernung des Katzengesichts von der Kamera wieder. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/54c/f5b/d2d/54cf5bd2d93144efb7371c3076b6541c.jpg"></div><br>  Es ist leicht zu erkennen, wie gute Ergebnisse mit einer so einfachen Tiefenkarte erzielt werden können.  Dies bedeutet, dass es einfach ist, eigene Tiefenkarten für vorhandene Bilder zu erstellen. <br><br><h2>  Die Eigenschaften </h2><br>  Nachdem wir alle Ressourcen haben, können wir mit dem Schreiben des Parallax-Shader-Codes beginnen.  Wenn wir das Hauptbild als Sprite importieren, <code>_MainTex</code> Unity es automatisch über die Eigenschaft <code>_MainTex</code> an den Shader.  Wir müssen jedoch die Tiefenkarte dem Shader zur Verfügung stellen.  Dies kann mithilfe einer neuen <strong>Shader-Eigenschaft</strong> namens <code>_HeightTex</code> .  Ich habe absichtlich beschlossen, es nicht <code>_DepthTex</code> zu nennen, um es nicht mit der <strong>Tiefenstruktur</strong> zu verwechseln (dies ist ein ähnliches Unity-Konzept, das zum Rendern der Szenentiefenkarte verwendet wird). <br><br>  Um die Stärke des Effekts zu ändern, fügen wir auch die Eigenschaft <code>_Scale</code> . <br><br><pre> <code class="cpp hljs">Properties { ... _HeightTex (<span class="hljs-string"><span class="hljs-string">"Heightmap (R)"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"gray"</span></span> {} _Scale (<span class="hljs-string"><span class="hljs-string">"Scale"</span></span>, Vector) = (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) }</code> </pre> <br>  Diese beiden neuen Eigenschaften sollten auch zwei Variablen mit demselben Namen entsprechen, die dem <code>ENDCG</code> <code>CGPROGRAM</code> / <code>ENDCG</code> hinzugefügt werden <code>ENDCG</code> : <br><br><pre> <code class="cpp hljs">sampler2D _HeightTex; fixed2 _Scale;</code> </pre> <br>  Jetzt ist alles fertig und wir können mit dem Schreiben von Code beginnen, der den Offset ausführt. <br><br>  Der erste Schritt besteht darin, den Wert aus der Tiefenkarte <code>tex2D</code> , was mit der Funktion <code>tex2D</code> kann.  Da <code>_HeightTex</code> eine Schwarz-Weiß-Textur ist, können wir einfach den roten Kanal nehmen und den Rest verwerfen.  Der resultierende Wert misst den Abstand in einigen willkürlichen Einheiten vom aktuellen Pixel zur Kamera. <br><br>  Der Tiefenwert liegt zwischen <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>0</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhgRoZq2-P2qd57qJXBZwe0btTDGWQ#MJMAIN-30" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>0</mn></math></span></span><script type="math/tex" id="MathJax-Element-1"> 0 </script>  vorher <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhgRoZq2-P2qd57qJXBZwe0btTDGWQ#MJMAIN-31" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-2"> 1 </script>  aber wir werden es auf das Intervall von strecken <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo>&amp;#x2212;</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.971ex" height="2.057ex" viewBox="0 -728.2 1279 885.9" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhgRoZq2-P2qd57qJXBZwe0btTDGWQ#MJMAIN-2212" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhgRoZq2-P2qd57qJXBZwe0btTDGWQ#MJMAIN-31" x="778" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo>−</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-3"> -1 </script>  vorher <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.971ex" height="2.057ex" viewBox="0 -728.2 1279 885.9" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhgRoZq2-P2qd57qJXBZwe0btTDGWQ#MJMAIN-2B" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhgRoZq2-P2qd57qJXBZwe0btTDGWQ#MJMAIN-31" x="778" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-4"> + 1 </script>  .  Auf diese Weise können Sie sowohl positive (weiße Farbe) als auch negative (schwarze Farbe) Parallaxe bereitstellen. <br><br><h2>  Theorie </h2><br>  Um den Parallaxeneffekt in diesem Stadium zu simulieren, müssen wir die Tiefeninformationen verwenden, um die Pixel des Bildes zu verschieben.  Je näher das Pixel ist, desto stärker muss es verschoben werden.  Dieser Vorgang wird in der folgenden Abbildung erläutert.  Das rote Pixel aus dem <em>Originalbild sollte</em> gemäß den Informationen aus der Tiefenkarte zwei Pixel nach links verschieben.  Ebenso sollte das blaue Pixel zwei Pixel nach rechts verschieben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/457/008/e69/457008e692048d9b5ef8eb2964f35fe2.png"></div><br>  Obwohl dies <em>theoretisch</em> funktionieren sollte, gibt es keine einfachen Möglichkeiten, dies im Shader zu implementieren.  Die Sache ist, dass ein Shader nach seinem Prinzip nur die Farbe des <em>aktuellen</em> Pixels ändern kann.  Bei der Ausführung des Shader-Codes muss ein bestimmtes Pixel auf dem Bildschirm gezeichnet werden.  Wir können dieses Pixel nicht einfach an einen anderen Ort verschieben oder die Farbe des benachbarten Pixels ändern.  Diese <em>Einschränkung der Lokalität</em> bietet einen sehr effizienten Parallelbetrieb von Shadern, ermöglicht es uns jedoch nicht, alle Arten von Effekten zu implementieren, die trivial wären, vorausgesetzt, es gibt einen <em>zufälligen Zugriff für die Aufzeichnung</em> auf jedes Pixel im Bild. <br><br>  Wenn wir genau sein wollen, müssen wir die Tiefenkarte aller benachbarten Pixel abtasten, um herauszufinden, welche an die aktuelle Position verschoben werden soll (falls sollte).  Wenn sich mehrere Pixel an derselben Stelle befinden sollten, können wir ihren Einfluss mitteln.  Obwohl ein solches System funktioniert und das bestmögliche Ergebnis liefert, ist es äußerst ineffizient und möglicherweise hunderte Male langsamer als der ursprüngliche diffuse Shader, mit dem wir begonnen haben. <br><br>  Die beste Alternative wäre die folgende Lösung: Wir erhalten die Tiefe des aktuellen Pixels aus der Tiefenkarte;  Wenn wir es dann <em>nach rechts verschieben müssen</em> , ersetzen Sie die aktuelle Farbe durch das Pixel <em>auf der linken Seite</em> (siehe Abbildung unten).  Hier nehmen wir an, dass, wenn Sie das Pixel nach rechts verschieben möchten, die benachbarten Pixel auf der linken Seite ebenfalls auf die gleiche Weise verschoben werden sollen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/699/cc8/7c0/699cc87c06761842edfc77449c195b43.png"></div><br>  Es ist leicht zu erkennen, dass dies nur eine kostengünstige Annäherung an das ist, was wir wirklich erreichen wollten.  Es ist jedoch sehr effektiv, da sich Tiefenkarten normalerweise als glatt herausstellen. <br><br><h2>  Code </h2><br>  Nach dem im vorherigen Abschnitt beschriebenen Algorithmus können wir den Parallax-Shader mit einem einfachen <strong>Versatz der UV-Koordinaten</strong> implementieren. <br><br>  Dies führt zu folgendem Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Displacement fixed height = tex2D(_HeightTex, IN.uv_MainTex).r; fixed2 displacement = _Scale * ((height - 0.5) * 2); fixed4 c = SampleSpriteTexture (IN.uv_MainTex - displacement) * IN.color; ... }</span></span></code> </pre> <br>  Diese Technik funktioniert gut mit fast flachen Objekten, wie in der folgenden Animation gezeigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ba/0c4/b8f/8ba0c4b8fa0fc51bf86c0874139feedb.gif"></div><br>  Aber es funktioniert wirklich sehr gut mit 3D-Modellen, da es sehr einfach ist, die Tiefenstruktur für eine 3D-Szene zu rendern.  Unten sehen Sie ein 3D-gerendertes Bild und seine Tiefenkarte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/701/179/d0f/701179d0f52d53b25f9d079d60dc8ae3.jpg"></div><br>  Die fertigen Ergebnisse werden hier angezeigt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51d/134/28c/51d13428ce1f6b84cbb6b62984f86fe4.gif"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444706/">https://habr.com/ru/post/de444706/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444692/index.html">MOSDROID # 16 Schwefel bei Redmadrobot</a></li>
<li><a href="../de444694/index.html">Wie wir den Abfluss vorhergesagt haben, nähern wir uns ihm als Naturkatastrophe</a></li>
<li><a href="../de444696/index.html">Erhöhen Sie die Containerdichte auf einem Knoten mithilfe der PFCACHE-Technologie</a></li>
<li><a href="../de444700/index.html">Zufällige Datenbanken. Oracle Enterprise Data Quality - Schutzschild und Schwert für Enterprise Storage</a></li>
<li><a href="../de444704/index.html">Chancen nanoCAD SPDS Baustelle bei Bau- und Wiederaufbauprojekten unter beengten Verhältnissen</a></li>
<li><a href="../de444708/index.html">PentQL-Anwendung mit GraphQL</a></li>
<li><a href="../de444710/index.html">Verständnis des Stellar Consensus Protocol</a></li>
<li><a href="../de444712/index.html">„Atypische Einstellung zur Finanzierung“ - was ist, wenn die Mitarbeiter das Einkommen selbst verwalten? Gespräch mit Flant</a></li>
<li><a href="../de444714/index.html">Wie wir CAD COMPASS-3D → Teil 1 übertaktet haben</a></li>
<li><a href="../de444716/index.html">Ein Samsung-Handy mit einem faltbaren Bildschirm für 2000 US-Dollar zeigt eine Falte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>