<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨â€ğŸ‘¨â€ğŸ‘¦ â­•ï¸ ğŸ˜ª Menulis miliar lagu dengan C # dan Deep Learning ğŸ‘§ ğŸ•• ğŸ¬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel ini saya akan menjelaskan bagaimana membangun situs web ASP.NET Core , yang menggunakan AI untuk menghasilkan lirik lagu yang unik dengan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menulis miliar lagu dengan C # dan Deep Learning</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453232/">  Pada artikel ini saya akan menjelaskan bagaimana membangun <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">situs web ASP.NET Core</a> , yang menggunakan AI untuk menghasilkan lirik lagu yang unik dengan mengklik tombol, dan memungkinkan pengguna memilih lagu terbaik. <br><a name="habracut"></a><br><h1>  Jaringan saraf </h1><br>  Sekitar 2,5 bulan yang lalu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">OpenAI</a> menerbitkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">posting blog</a> , di mana mereka menunjukkan hampir mustahil: model pembelajaran yang mendalam, yang dapat menulis artikel, tidak bisa dibedakan dari yang ditulis oleh manusia.  Teks yang dihasilkannya sangat mengesankan, sehingga saya harus memeriksa kalender untuk memastikan itu bukan lelucon April Mop (ingat Anda itu Februari, dan Seattle tertutup salju). <br><br><p><img src="https://habrastorage.org/webt/df/ok/nc/dfoknc5wbfxrkyvigyygtz9kctw.png" alt="Sampel teks GPT-2"></p><br><p> Mereka tidak merilis jaringan saraf terbesar dengan lebih dari 1 miliar parameter yang mereka bangun hari ini (keputusan yang sangat kontroversial), tetapi mereka membuka sumber versi parameter 117M yang lebih kecil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">pada GitHub di</a> bawah lisensi MIT.  Model ini memiliki nama yang sangat tak terlupakan: <b>GPT-2</b> . </p><br><p>  Jadi, sekitar sebulan yang lalu, ketika saya mencoba memikirkan proyek keren apa yang bisa saya buat dengan TensorFlow, jaringan itu menjadi titik awal.  Jika sudah bisa menghasilkan teks bahasa Inggris, seharusnya tidak terlalu sulit untuk <i>menyempurnakannya</i> untuk menghasilkan lirik lagu, jika ada dataset yang cukup besar. </p><br><h2>  Bagaimana cara kerja GPT-2? </h2><br><p>  Ada beberapa pencapaian penting dalam penelitian pembelajaran dalam, yang memungkinkan GPT-2 menjadi mungkin: </p><br><h3>  Belajar mandiri </h3><br><p>  Teknik ini mendapatkan namanya diselesaikan oleh Yan LeCunn hanya beberapa hari setelah saya menulis versi pertama artikel ini.  Ini adalah teknik yang sangat kuat, yang dapat diterapkan pada dasarnya semua jenis data dunia nyata.  Untuk melatih GPT-2 OpenAI mengumpulkan <i>puluhan gigabyte artikel</i> dari berbagai sumber, yang diputuskan di Reddit. </p><br><p>  Secara konvensional, seseorang harus memiliki manusia untuk melalui semua artikel ini, dan, misalnya, menandainya sebagai "positif" atau "negatif".  Kemudian mereka akan mengajarkan jaringan saraf dengan cara yang diawasi untuk mengklasifikasikan artikel ini dengan cara yang sama seperti manusia. </p><br><p><img src="https://habrastorage.org/webt/cn/sl/_2/cnsl_21o1f-vio39rn5auufl_lw.jpeg" alt="RECAPTCHA: temukan tanda-tanda bebas"></p><br><p>  Gagasan baru di sini adalah untuk membuat model pembelajaran yang mendalam, yang memiliki pemahaman tingkat tinggi tentang data Anda, Anda hanya merusak data, dan menugaskan model untuk mengembalikan yang asli.  Ini membuat model memahami koneksi antara potongan data, dan konteks sekitarnya. </p><br><p>  Mari kita ambil teks sebagai contoh.  GPT-2 mengambil sampel teks asli, mengambil 15% token untuk dikorupsi, lalu menutupi 80% darinya (misalnya mengganti dengan token topeng khusus, biasanya ___), menggantikan 10% dengan beberapa token acak lain dari kamus, dan menjaga 10% sisanya tetap utuh.  Ambil <i>aku melempar bola, dan jatuh ke rumput</i> .  Setelah korupsi mungkin terlihat seperti ini: <i>Saya melempar bola mobil, dan ___ ke rumput</i> .  Dalam istilah awam, untuk mendapatkan jaringan mengembalikan yang asli, perlu belajar, bahwa sesuatu yang dibuang kemungkinan akan jatuh, dan bola mobil adalah sesuatu yang sangat tidak biasa dalam konteksnya. </p><br><p>  Model yang dilatih seperti itu bagus dalam menghasilkan / melengkapi data parsial, tetapi fitur tingkat tinggi yang dipelajarinya (sebagai output dari lapisan dalam) dapat digunakan untuk tujuan lain dengan menambahkan satu atau dua lapisan di atasnya, dan fine-tuning <b>hanya lapisan terakhir yang baru</b> pada dataset aktual, <b>lebih kecil</b> , dan bertanda manusia dengan cara konvensional. </p><br><h3>  Sedikit perhatian pada diri sendiri </h3><br><p>  GPT-2 menggunakan sesuatu yang disebut jarang perhatian diri.  Pada intinya, ini adalah teknik, yang memungkinkan jaringan saraf memproses input besar untuk fokus pada beberapa bagian lebih dari yang lain.  Dan jaringan belajar di mana ia harus "melihat" selama pelatihan.  Mekanisme perhatian lebih dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">posting blog ini</a> . </p><br><p>  Bagian yang <i>jarang</i> dalam judul bagian ini mengacu pada batasan segmen input yang dapat dipilih mekanisme perhatian.  Perhatian awal dapat memilih dari seluruh input.  Itu menyebabkan matriks bobotnya menjadi O (input_size ^ 2), yang tumbuh sangat cepat dengan ukuran input.  Perhatian yang jarang biasanya membatasi hal itu dalam beberapa cara.  Untuk informasi lebih lanjut tentang itu, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">posting blog OpenAI</a> lain. </p><br><p>  Perhatian dalam GPT-2 adalah <i>multi-head</i> .  Bayangkan Anda bisa memiliki satu atau dua mata tambahan yang bisa Anda gunakan untuk memeriksa apa yang ada di paragraf terakhir tanpa berhenti membaca yang ada saat ini. </p><br><h3>  Lebih banyak </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Koneksi residual</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">penyandian pasangan Byte</a> , prediksi kalimat berikutnya, dan banyak lagi. </p><br><h2>  Porting GPT-2 (dan mengonversi Python secara umum) </h2><br><p>  Kode model asli dalam Python, tapi saya seorang pria C #.  Untungnya, kode sumbernya cukup mudah dibaca, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">intinya</a> hanya dalam 5 file, mungkin total 500 baris.  Jadi saya membuat proyek .NET Standard baru, menginstal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Gradient</a> (pengikatan TensorFlow untuk .NET), dan mengonversi file-file tersebut baris demi baris ke C #.  Butuh waktu sekitar 2 jam.  Satu-satunya hal pythonic yang tersisa dalam kode adalah penggunaan modul regex Python dari pip (manajer paket yang paling umum digunakan untuk Python), karena saya tidak ingin membuang waktu mempelajari seluk-beluk ekspresi reguler Python ( <i>seolah-olah itu tidak cukup. untuk menangani. NET yang sudah</i> ). </p><br><p>  Sebagian besar konversi terdiri dari mendefinisikan kelas yang serupa, menambahkan tipe, dan menulis ulang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">pemahaman daftar</a> Python ke dalam konstruksi LINQ yang sesuai.  Selain LINQ dari perpustakaan standar, saya menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">MoreLinq</a> , yang sedikit memperluas apa yang bisa dilakukan LINQ Sebagai contoh: </p><br><p></p><pre><code class="python hljs">bs = list(range(ord(<span class="hljs-string"><span class="hljs-string">"!"</span></span>), ord(<span class="hljs-string"><span class="hljs-string">"~"</span></span>)+<span class="hljs-number"><span class="hljs-number">1</span></span>)) + list(range(ord(<span class="hljs-string"><span class="hljs-string">"Â¡"</span></span>), ord(<span class="hljs-string"><span class="hljs-string">"Â¬"</span></span>)+<span class="hljs-number"><span class="hljs-number">1</span></span>)) + list(range(ord(<span class="hljs-string"><span class="hljs-string">""</span></span>), ord(<span class="hljs-string"><span class="hljs-string">"Ã¿"</span></span>)+<span class="hljs-number"><span class="hljs-number">1</span></span>))</code> </pre> <br><p>  berubah menjadi: </p><br><p></p><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bs = Range(<span class="hljs-string"><span class="hljs-string">'!'</span></span>, <span class="hljs-string"><span class="hljs-string">'~'</span></span> - <span class="hljs-string"><span class="hljs-string">'!'</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) .Concat(Range(<span class="hljs-string"><span class="hljs-string">'Â¡'</span></span>, <span class="hljs-string"><span class="hljs-string">'Â¬'</span></span> -<span class="hljs-string"><span class="hljs-string">'Â¡'</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>)) .Concat(Range(<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'Ã¿'</span></span> - <span class="hljs-string"><span class="hljs-string">''</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>)) .ToList();</code> </pre> <br><p>  Hal lain yang harus saya lawan adalah perbedaan antara cara Python menangani rentang, dan fitur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Rentang dan indeks baru</a> di C # 8 mendatang, yang saya temukan saat men-debug proses awal saya: di C # 8 akhir rentang <b>inklusif</b> , sementara di Python itu <b>eksklusif</b> (untuk memasukkan elemen terakhir dalam Python Anda harus menghilangkan sisi kanan <i>..</i> ekspresi). </p><br><blockquote>  Ada dua hal yang sulit dalam ilmu komputer: pembatalan cache, penamaan, dan kesalahan satu-per-satu. </blockquote><br><p>  Sayangnya, sumber drop asli tidak mengandung pelatihan atau bahkan kode fine-tuning, tetapi <b>Neil Shepperd</b> memberikan fine-tuner sederhana pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">GitHub-</a> nya, yang harus saya porting juga.  Bagaimanapun, hasil dari usaha itu adalah <b>kode C #</b> , yang dapat digunakan <b>untuk bermain dengan GPT-2</b> , sekarang menjadi bagian dari repositori Gradient <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Samples</a> . </p><br><p>  Inti dari latihan porting adalah dua kali lipat: setelah porting seseorang dapat <b>bermain dengan kode model dalam C # IDE favoritnya</b> , dan untuk menunjukkan, bahwa <b>sekarang mungkin untuk mendapatkan model pembelajaran mendalam yang canggih yang bekerja dalam kebiasaan .NET memproyeksikan</b> tak lama setelah rilis (antara penurunan kode GPT-2 dan rilis pertama Lagu Billion - hanya sedikit lebih dari sebulan). </p><br><h2>  Menyempurnakan lirik lagu </h2><br><p>  Ada beberapa cara seseorang bisa mendapatkan kumpulan lirik lagu yang besar.  Anda dapat mengikis salah satu situs web Internet yang menghostingnya dengan parser HTML, menariknya dari koleksi karaoke Anda, atau file mp3.  Untungnya, seseorang melakukannya untuk kita.  Saya menemukan beberapa dataset lirik yang disiapkan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Kaggle</a> .  â€œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Setiap lagu yang telah Anda dengar</a> â€ tampaknya menjadi yang terbesar.  Mencoba untuk menyempurnakan GPT-2 untuk itu, saya menghadapi dua masalah. </p><br><h3>  Pembacaan CSV </h3><br><p>  Ya, Anda membacanya dengan benar, <i>penguraian CSV adalah masalah</i> .  Awalnya, saya ingin menggunakan ML.NET, perpustakaan Microsoft baru untuk pembelajaran mesin, untuk membaca file.  Namun, setelah membaca sekilas melalui dokumentasi, dan mengaturnya, saya menyadari, bahwa itu gagal memproses jeda baris dalam lagu dengan benar.  Tidak peduli apa yang saya lakukan, itu berjuang setelah beberapa ratus contoh, dan mulai mencampur potongan lirik dengan judul dan artis. </p><br><p>  Jadi saya harus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">beralih</a> ke perpustakaan tingkat bawah, yang sebelumnya saya punya pengalaman lebih baik: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">CsvHelper</a> .  Ini menyediakan antarmuka seperti <i>DataReader</i> .  Anda dapat melihat kode menggunakannya di <a href="" rel="nofollow">sini</a> .  Pada dasarnya, Anda membuka file, mengkonfigurasi <i>CsvReader</i> , dan kemudian interleave panggilan ke <i>.Read ()</i> dengan panggilan ke <i>.GetField (fieldName)</i> . </p><br><h3>  Lagu pendek </h3><br><p>  Sebagian besar lagu pendek dibandingkan dengan artikel rata-rata dalam dataset asli yang digunakan oleh OpenAI.  Pelatihan GPT-2 lebih efisien pada potongan teks besar, jadi saya harus menggabungkan beberapa lagu menjadi potongan teks berkelanjutan untuk memberi mereka makan kepada pelatih.  OpenAI juga tampaknya menggunakan teknik ini, jadi mereka memiliki token khusus <i>&lt;| endoftext |&gt;</i> , yang bertindak sebagai pemisah antara teks lengkap di dalam chunk, dan berfungsi ganda sebagai token awal.  Saya menggabungkan beberapa lagu hingga sejumlah token tercapai, lalu mengembalikan seluruh potongan untuk dimasukkan ke dalam data pelatihan.  Kode yang relevan ada di <a href="" rel="nofollow">sini</a> . </p><br><h3>  Persyaratan perangkat keras untuk penyetelan </h3><br><p>  Bahkan versi yang lebih kecil dari GPT-2 berukuran besar.  Dengan <b>12GB RAM GPU,</b> saya <b>hanya</b> dapat <b>mengatur ukuran bets menjadi 2</b> (mis. Melatih dua bong sekaligus, ukuran bets yang lebih besar meningkatkan kinerja GPU dan hasil pelatihan).  3 akan membuang <i>memori</i> di CUDA.  Dan butuh setengah hari untuk menyesuaikannya dengan kinerja yang diinginkan pada V100 saya.  Bonusnya adalah Anda dapat melihat progresnya, karena setiap sekarang dan kemudian kode pelatihan mengeluarkan beberapa sampel yang dihasilkan, yang dimulai dengan teks sederhana, dan semakin terlihat seperti lirik lagu saat pelatihan berlangsung. </p><br><p>  Saya belum mencobanya, tetapi <b>pelatihan pada CPU mungkin akan sangat lambat</b> . </p><br><h3>  Model yang sudah disetel sebelumnya </h3><br><p>  Ketika saya sedang mempersiapkan posting blog ini, saya menyadari akan lebih baik untuk tidak memaksa semua orang menghabiskan waktu berjam-jam memperbaiki <b>model</b> <b>lirik</b> , jadi saya <b>merilis yang</b> <b>sudah disetel</b> pada <a href="" rel="nofollow">repositori Billion Songs</a> .  Jika Anda hanya mencoba menjalankan Billion Lagu, Anda bahkan tidak perlu mengunduhnya secara manual.  Proyek akan melakukannya untuk Anda secara default. </p><br><div class="spoiler">  <b class="spoiler_title">model setengah terlatih bermain HAL9000 pada saya</b> <div class="spoiler_text">  Aku bersumpah, aku seharusnya menulis surat kepadamu <br>  Dan aku bersumpah, aku bersumpah <br>  Anda menghancurkannya sekarang, saya harap Anda berhasil <br>  Dan saya harap impian Anda, saya harap Anda bermimpi, saya harap Anda bermimpi. Saya harap Anda bermimpi. Saya harap Anda bermimpi <br>  Tentang <br>  apa yang saya pergi.  Saya pergi  Saya pergi  Aku pergi, aku akan, aku akan, aku akan, aku akan, aku akan, aku akan, <br>  Aku pergi, aku pergi, aku akan ... </div></div><br><h1>  Membuat situs web </h1><br><p>  Oke!  Itu terlihat seperti lagu (semacam), sekarang mari kita membuat situs web! </p><br><p>  Karena saya tidak berencana menyediakan API apa pun, saya memilih templat Razor Pages sebagai ganti MVC.  Saya mengaktifkan otorisasi juga, karena kami akan memungkinkan pengguna untuk memilih lirik terbaik dan memiliki chart 10 Besar. </p><br><p>  Bergegas MVP, saya pergi ke depan dan membuat halaman web Song.cshtml, yang tujuannya untuk saat ini adalah dengan hanya memanggil GPT-2 dan mendapatkan lagu acak.  Tata letak halaman itu sepele, dan pada dasarnya terdiri dari lagu dan judulnya: </p><br><pre> <code class="xml hljs">@page "/song/{id}" @model BillionSongs.Pages.SongModel<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> @{ ViewData["Title"] = @Model.Song.Title ?? "Untitled"; } <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">article</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text-align: center"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h3</span></span></span><span class="hljs-tag">&gt;</span></span>@(Model.Song.Title ?? "Untitled")<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h3</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">pre</span></span></span><span class="hljs-tag">&gt;</span></span>@Model.Song.Lyrics<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">pre</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">article</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br><p>  Sekarang karena saya suka kode saya dapat digunakan kembali, saya membuat antarmuka, yang akan membiarkan saya memasang generator lirik yang berbeda nantinya, yang akan disuntikkan oleh ASP.NET ke SongModel. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ILyricsGenerator</span></span> { <span class="hljs-function"><span class="hljs-function">Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateLyrics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> song, CancellationToken cancellation</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre><br><p>  Menghilangkan judul lagu untuk saat ini, yang perlu kita lakukan adalah mendaftar <i>Gpt2LyricsGenerator</i> di <i>Startup. Konfigurasikan Layanan</i> dan panggil dari <i>SongModel</i> .  Jadi mari kita mulai menggunakan generator.  Dan hal pertama yang perlu kita pastikan, adalah yang kita miliki </p><br><h2>  Generasi lirik berulang </h2><br><p>  Karena saya membuat pernyataan berani dalam judul, bahwa itu akan menjadi lebih dari 1 miliar lagu, bahkan tidak berpikir tentang menghasilkan dan menyimpan semuanya.  Pertama, tanpa metadata apa pun, itu akan mengambil sendiri lebih dari 1TB ruang disk.  Kedua, butuh ~ 3 menit di nettop saya untuk menghasilkan lagu baru, jadi akan butuh selamanya untuk menghasilkan semuanya.  Dan saya ingin dapat mengubah miliar itu menjadi trilyun dengan beralih ke <i>Int64</i> jika diperlukan!  Bayangkan kita bisa menghasilkan 1 sen per lagu, dengan 1 triliun lagu?  Itu akan lebih dari PDB tahunan dunia saat ini! </p><br><p>  Sebaliknya, yang perlu kita lakukan adalah memastikan, bahwa GPT-2 menghasilkan lagu yang sama berulang-ulang, mengingat <i>id</i> -nya, yang saya tentukan di rute.  Untuk itu TensorFlow memberikan kemampuan untuk mengatur seed dari generator nomor internal kapan saja melalui fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">tf.set_random_seed</a> seperti ini: <i>tf.set_random_seed (songNumber)</i> .  Lalu saya ingin memanggil <i>Gpt2Sampler.SampleSequence</i> , untuk mendapatkan teks lagu yang disandikan, mendekodekannya, dan mengembalikan hasilnya, sehingga melengkapi <i>Gpt2LyricsGenerator</i> . </p><br><p>  Sayangnya, pada percobaan pertama itu tidak berhasil seperti yang diharapkan.  Setiap kali saya menekan tombol refresh, teks unik baru akan dikembalikan pada halaman.  Setelah melakukan sedikit debug, akhirnya saya menemukan, bahwa TensorFlow 1.X memiliki masalah signifikan dengan kemampuan reproduksi: banyak operasi memiliki status internal, yang tidak terpengaruh oleh <i>set_random_seed</i> dan sulit dijangkau untuk diatur ulang. </p><br><p>  Inisialisasi ulang variabel model membantu mengimbangi masalah itu, tetapi juga berarti, bahwa sesi harus diciptakan kembali, dan bobot model harus dimuat ulang pada setiap panggilan.  Memuat kembali sesi sebesar itu menyebabkan kebocoran memori raksasa.  Untuk menghindari mencari penyebabnya dalam kode sumber TensorFlow C ++, alih-alih melakukan pembuatan teks dalam proses, saya memutuskan untuk menelurkan proses baru dengan <i>Process.Start</i> , menghasilkan teks di sana, dan membacanya dari output standar.  Sampai cara untuk mengatur ulang keadaan model di TensorFlow distabilkan, ini akan menjadi cara untuk pergi. </p><br><p>  Jadi saya berakhir dengan dua kelas: <a href="" rel="nofollow">Gpt2LyricsGenerator</a> , yang mengimplementasikan <i>ILyricsGenerator</i> dari atas dengan menelurkan instance baru BillionSongs.exe dengan parameter baris perintah, yang mencakup id lagu, dan akhirnya instantiate <a href="" rel="nofollow">Gpt2TextGenerator</a> , yang sebenarnya memanggil GPT-2 untuk menghasilkan lirik, dan cukup cetak saja. </p><br><p>  Sekarang menyegarkan halaman selalu memberi saya teks yang sama. </p><br><h2>  Berurusan dengan 3 menit waktu untuk menghasilkan lagu </h2><br><p>  Betapa mengerikan pengalaman pengguna itu!  Anda pergi ke situs web, klik "Buat Lagu Baru", dan <b>sama sekali tidak ada yang terjadi selama 3 (!) Menit</b> sementara nettop saya mengambil waktu untuk menghasilkan lirik lagu yang Anda minta. </p><br><p>  Saya memecahkan masalah ini pada beberapa tingkatan: </p><br><h3>  Lagu pregenerasi </h3><br><p>  Seperti yang disebutkan di atas, Anda tidak dapat membuat pregenerasi semua lagu, dan menyajikannya dari basis data.  Dan Anda tidak bisa hanya menghasilkan sesuai permintaan, karena itu lambat.  Jadi apa yang bisa kamu lakukan? </p><br><p>  Sederhana!  Karena cara utama bagi pengguna untuk melihat lagu baru adalah dengan mengklik tombol "Jadikan Acak", mari kita membuat banyak lagu sebelumnya, memasukkannya ke <i>ConcurrentQueue</i> , dan biarkan lagu pop "Make Random" darinya.  Sementara jumlah pengunjung rendah, server akan mengambil waktu di antara mereka untuk menghasilkan beberapa lagu, yang kemudian akan mudah diakses. </p><br><p>  Trik lain, yang saya gunakan adalah untuk mengulangi antrian itu beberapa kali, sehingga banyak pengguna dapat melihat lagu pregenerasi yang sama.  Satu hanya perlu menjaga keseimbangan antara penggunaan RAM, dan berapa kali pengguna harus mengklik "Jadikan Acak" untuk melihat sesuatu yang telah dilihatnya sebelumnya.  Saya hanya memilih 50.000 lagu sebagai jumlah yang masuk akal, yang hanya membutuhkan 50MB RAM, sambil memberikan cukup banyak klik untuk dilalui. </p><br><p>  Saya menerapkan fungsi itu di kelas <a href="" rel="nofollow">PregeneratedSongProvider</a> : <i>IRandomSongProvider</i> (antarmuka disuntikkan ke dalam kode, bertanggung jawab untuk menangani tombol "Jadikan Acak"). </p><br><h3>  Caching </h3><br><p>  Lagu-lagu pregenerated di-cache ke memori, tapi saya juga mengatur header <i>cache</i> HTTP ke <i>publik</i> untuk membiarkan browser, dan CDN (saya menggunakan CloudFlare) cache itu untuk menghindari tertabrak oleh masuknya pengguna. </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">ResponseCache(VaryByHeader = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"User-Agent"</span></span></span><span class="hljs-meta">, Duration = 3*60*60)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SongModel</span></span>: <span class="hljs-title"><span class="hljs-title">PageModel</span></span> { â€¦ }</code> </pre><br><h3>  Mengembalikan lagu-lagu populer </h3><br><p>  Sebagian besar lagu yang dihasilkan oleh GPT-2 yang disetel dengan baik dengan cara itu cukup membosankan, jika tidak sederhana.  Untuk membuat klik pada "Jadikan Secara Acak" lebih menarik, saya menambahkan probabilitas 25%, bahwa alih-alih lagu yang benar-benar acak, Anda akan mendapatkan beberapa lagu, yang sebelumnya diputuskan oleh pengguna lain.  Selain meningkatkan keterlibatan, ini meningkatkan peluang, bahwa Anda akan meminta lagu, disimpan dalam CDN, atau dalam memori. </p><br><p>  Semua trik di atas dihubungkan bersama menggunakan injeksi dependensi ASP.NET di kelas <a href="" rel="nofollow">Startup</a> . </p><br><h2>  Voting </h2><br><p>  Tidak banyak yang istimewa tentang implementasi pemungutan suara.  Ada <a href="" rel="nofollow">SongVoteCache</a> , yang membuat hitungan terus up to date.  Dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">iframe yang menampung tombol pilih</a> pada halaman lagu, yang memungkinkan bagian penting dari halaman - judul dan lirik di-cache, sementara jumlah suara dan status login dimuat kemudian. </p><br><h1>  Hasil akhirnya </h1><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><img src="https://habrastorage.org/webt/aw/c7/wf/awc7wfzablt9gotcrrv8nsihrvu.png" alt="Sampel lagu yang dihasilkan"></a> <br></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Versi demo yang</a> berjalan di <s>nettop saya, digawangi oleh CloudFlare (berikan sedikit kelonggaran, Core i3-nya)</s> sekarang dibekukan dan dipindahkan ke tingkat gratis Azure App Service. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Repositori GitHub</a> , berisi kode sumber, dan instruksi untuk menjalankan situs web dan menyetel model. </p><br><h1>  Rencana untuk masa depan / latihan </h1><br><h2>  Hasilkan judul </h2><br><p>  GPT-2 sangat mudah disempurnakan.  Orang bisa membuatnya menghasilkan judul lagu dengan mendahului atau suffixing setiap sampel lirik dari dataset dengan token buatan seperti <i>&lt;| startoftitle |&gt;</i> , diikuti oleh judul dari dataset yang sama. </p><br><p>  Sebagai alternatif, pengguna dapat diizinkan untuk menyarankan dan / atau memilih judul. </p><br><h2>  Hasilkan musik </h2><br><p>  Setengah jalan melalui pengembangan Billion Songs, saya pikir akan lebih baik untuk mengunduh banyak file MIDI (itu adalah format musik jadul, yang jauh lebih dekat dengan teks, daripada mp3), dan melatih GPT-2 untuk menghasilkan lebih banyak .  Beberapa file bahkan memiliki teks tertanam, sehingga <b>Anda bisa mendapatkan generasi karaoke</b> . </p><br><p>  Saya tahu generasi musik dengan cara ini sangat mungkin, karena kemarin <b>OpenAI benar-benar telah menerbitkan implementasi dari ide itu</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">di blog mereka</a> .  Tapi, hore, <b>mereka tidak melakukan karaoke!</b>  Saya menemukan, bahwa adalah mungkin untuk mengikis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">http://www.midi-karaoke.info</a> untuk tujuan itu. </p><br><h2>  Gradient alias TensorFlow untuk .NET </h2><br>  Silakan, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">blog</a> kami untuk setiap pembaruan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id453232/">https://habr.com/ru/post/id453232/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id453216/index.html">Sistem pemantauan lalu lintas di jaringan VoIP. Bagian Dua - Prinsip Organisasi</a></li>
<li><a href="../id453218/index.html">Hal utama dengan YaC 2019: seratus drone di jalan, Yandex.Module, makanan, rumah pintar</a></li>
<li><a href="../id453220/index.html">13 Kesalahan Pemasaran Email yang Harus Dihindari untuk Keterlibatan Lebih Baik</a></li>
<li><a href="../id453222/index.html">SphinxSearch-meetup SuperJob</a></li>
<li><a href="../id453228/index.html">Jam Nixie pada indikator IN-18</a></li>
<li><a href="../id453234/index.html">Membalikkan rekayasa protokol pertukaran dalam peralatan EOS</a></li>
<li><a href="../id453236/index.html">Membuat prototipe game seluler, mulai dari mana, dan bagaimana melakukannya. Bagian 2</a></li>
<li><a href="../id453238/index.html">Lampu berjalan di relay</a></li>
<li><a href="../id453242/index.html">Taman bermain untuk acara musim panas</a></li>
<li><a href="../id453246/index.html">ERP - Sistem Degradasi Berkelanjutan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>