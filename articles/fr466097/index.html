<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≤üèæ üôèüèæ üëí Surveillance des applications .NET üöÆ üöΩ üì•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=".NET est un runtime g√©r√© . Cela signifie qu'il contient des fonctions de haut niveau qui contr√¥lent votre programme pour vous (de l' introduction au C...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Surveillance des applications .NET</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/466097/"><p>  .NET est un <em>runtime g√©r√©</em> .  Cela signifie qu'il contient des fonctions de haut niveau qui contr√¥lent votre programme pour vous (de l' <a href="">introduction au Common Language Runtime (CLR), 2007</a> ): </p><br><blockquote>  Le runtime fournit de nombreuses fonctions, il est donc pratique de les diviser dans les cat√©gories suivantes: <br><br><ol><li>  <b>Les principales fonctions</b> qui affectent l'appareil des autres.  Cela comprend: <ol><li>  collecte des ordures; </li><li>  s√©curiser l'acc√®s √† la m√©moire et saisir la s√©curit√© du syst√®me; </li><li>  prise en charge de haut niveau des langages de programmation. </li></ol></li><li>  <b>Fonctions suppl√©mentaires</b> - fonctionnent sur la base des principales.  De nombreux programmes utiles s'en passent.  Ces fonctions comprennent: <ol><li>  Isoler des applications √† l'aide d'AppDomains </li><li>  protection de l'application et isolation du bac √† sable. </li></ol></li><li>  <b>D'autres fonctions</b> sont n√©cessaires √† tous les runtimes, mais elles n'utilisent pas les fonctions CLR de base.  Ces fonctionnalit√©s refl√®tent le d√©sir de cr√©er un environnement de programmation complet.  Cela comprend: <br><ol><li>  contr√¥le de version; </li><li>  d√©bogage / profilage; </li><li>  assurer l'interaction. </li></ol></li></ol></blockquote><p>  On peut voir que bien que le d√©bogage et le profilage ne soient pas les fonctions principales ou suppl√©mentaires, ils sont sur la liste en raison du ¬´ <em>d√©sir de cr√©er un environnement de programmation √† part enti√®re</em> ¬ª. </p><br><p><img src="https://habrastorage.org/webt/mh/eq/nn/mheqnnqmnlkhoroovhqseskeyba.jpeg"></p><a name="habracut"></a><br><p>  <strong>Le reste de l'article d√©crit les fonctions de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">surveillance</a> , d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">observabilit√©</a> et d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">introspection</a> qui existent dans le Core CLR, pourquoi elles sont utiles et comment l'environnement les fournit.</strong> </p><br><h2 id="diagnostika">  Diagnostics </h2><br><p>  Tout d'abord, jetez un ≈ìil aux informations de diagnostic que le CLR nous fournit.  Traditionnellement, le suivi des √©v√©nements pour Windows (ETW) a √©t√© utilis√© pour cela. <br>  Il existe de nombreux √©v√©nements sur lesquels le CLR fournit des informations.  Ils sont associ√©s √†: </p><br><ul><li>  collecte des ordures (GC); </li><li>  Compilation JIT; </li><li>  modules et domaines d'application; </li><li>  travailler avec les threads et les conflits lors du blocage; </li><li>  ainsi que de nombreux autres. </li></ul><br><p>  Par exemple, ici un <a href="https://github.com/dotnet/coreclr/blob/release/2.1/src/vm/corhost.cpp#">√©v√©nement</a> se produit <a href="https://github.com/dotnet/coreclr/blob/release/2.1/src/vm/corhost.cpp#">pendant le chargement dans AppDomain</a> , ici l' <a href="">√©v√©nement est associ√© au lancement d'une exception</a> , et ici au <a href="">cycle d'allocation de m√©moire par le garbage collector</a> . </p><br><h3 id="perf-view">  Vue Perf </h3><br><p> Si vous souhaitez voir les √©v√©nements dans le syst√®me de trace (ETW) li√©s √† vos applications .NET, je vous recommande d'utiliser l'excellent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">outil PerfView</a> et de commencer par ces <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vid√©os de formation</a> ou cette pr√©sentation de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PerfView: The Ultimate .NET Performance Tool</a> .  PerfView a √©t√© largement reconnu pour fournir des informations pr√©cieuses.  Par exemple, les ing√©nieurs de Microsoft l'utilisent r√©guli√®rement pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">analyser les performances</a> . </p><br><h3 id="obschaya-infrastruktura">  Infrastructure commune </h3><br><p>  Si soudain le nom n'est pas clair, le suivi des √©v√©nements dans ETW n'est disponible que sous Windows, ce qui ne correspond pas tr√®s bien au monde multiplateforme de .NET Core.  Vous pouvez utiliser <a href="">PerfView pour analyser les performances sous Linux</a> (en utilisant LTTng).  Cependant, cet outil de ligne de commande, appel√© PerfCollect, collecte uniquement des donn√©es.  Les capacit√©s d'analyse et une interface utilisateur riche (y compris les graphiques √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">flamme</a> ) ne sont actuellement disponibles que dans les solutions Windows. </p><br><p>  Mais si vous souhaitez toujours analyser les performances .NET sous Linux, il existe d'autres approches: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Obtention de piles pour les √©v√©nements LTTng avec .NET Core sous Linux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Probl√®me de performances Linux</a> </li></ul><br><p>  Le deuxi√®me lien ci-dessus m√®ne √† une discussion sur la nouvelle <strong>infrastructure EventPipe</strong> , qui est en cours d' <strong>√©laboration</strong> dans .NET Core (en plus d'EventSources &amp; EventListeners).  Ses objectifs de d√©veloppement se trouvent dans le document <a href="">Conception de la surveillance des performances multiplateforme</a> .  √Ä un niveau √©lev√©, cette infrastructure cr√©era un endroit unique o√π le CLR enverra des √©v√©nements li√©s aux diagnostics et aux performances.  Ces √©v√©nements seront ensuite redirig√©s vers un ou plusieurs enregistreurs, qui peuvent, par exemple, inclure ETW, LTTng et BPF.  L'enregistreur n√©cessaire sera d√©termin√© en fonction du syst√®me d'exploitation ou de la plate-forme sur lequel le CLR est ex√©cut√©.  Pour une explication d√©taill√©e des avantages et des inconv√©nients des diff√©rentes technologies de journalisation, consultez la <a href="">conception des performances et des √©v√©nements .NET Cross-Plat</a> . </p><br><p>  La progression d'EventPipes est surveill√©e via <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le projet de surveillance des performances</a> et les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">probl√®mes</a> li√©s √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´EventPipe¬ª</a> . </p><br><h3 id="plany-na-buduschee">  Plans futurs </h3><br><p>  Enfin, il est pr√©vu de cr√©er un <a href="">contr√¥leur de profilage des performances</a> , qui aura les t√¢ches suivantes: </p><br><p>  Le contr√¥leur doit g√©rer l'infrastructure de profilage et pr√©senter les donn√©es de performances g√©n√©r√©es par les composants .NET responsables des diagnostics de performances de mani√®re simple et multiplateforme. </p><br><p>  Selon le plan, le contr√¥leur doit fournir les <a href="">fonctionnalit√©s suivantes via le serveur HTTP</a> , en recevant toutes les donn√©es n√©cessaires de l'infrastructure EventPipes: </p><br><p>  <strong>API REST</strong> </p><br><ul><li>  Principe 1: profilage simple: profilez le runtime sur la p√©riode X et renvoyez la trace. </li><li>  Principe 1: profilage avanc√©: d√©marrage du suivi (avec configuration) </li><li>  Principe 1: profilage avanc√©: suivi complet (la r√©ponse √† cet appel sera la trace elle-m√™me). </li><li>  Principe 2: Obtenez des statistiques associ√©es √† tous les EventCounters ou √† un EventCounter sp√©cifique. </li></ul><br><p>  <strong>Pages HTML navigables</strong> </p><br><ul><li>  Principe 1: Une repr√©sentation textuelle de toutes les piles de code manag√© dans un processus. <br><ul><li>  Cr√©e des instantan√©s des processus en cours d'ex√©cution √† utiliser comme rapport de diagnostic simple. </li></ul></li><li>  Principe 2: affichage de l'√©tat actuel (√©ventuellement avec un historique) des compteurs EventCounters. <br><ul><li>  Fournit une vue d'ensemble des compteurs existants et de leurs valeurs. </li><li>  PROBL√àME NON R√âSOLU: je ne pense pas qu'il existe des API publiques n√©cessaires pour compter les EventCounters. </li></ul></li></ul><br><p>  Je veux vraiment voir ce qui se passe avec le contr√¥leur de profilage des performances (PPC?).  Je pense que s'il est int√©gr√© au CLR, il apportera de nombreux avantages √† .NET.  Cette fonctionnalit√© existe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans d'autres runtimes</a> . </p><br><h2 id="profilirovanie">  Profilage </h2><br><p>  Un autre outil efficace dont dispose le CLR est une API de profilage.  Il est (principalement) utilis√© par des outils tiers pour se connecter au runtime √† un niveau bas.  Vous pouvez en savoir plus sur l'API √† <a href="">partir de cette revue</a> , mais √† un niveau √©lev√©, vous pouvez l'utiliser pour effectuer des rappels qui sont activ√©s si: </p><br><ul><li>  les √©v√©nements li√©s au ramasse-miettes; </li><li>  des exceptions sont lev√©es; </li><li>  les assemblages sont charg√©s / d√©charg√©s; </li><li>  <a href="">et bien plus</a> . </li></ul><br><p>  <em>Image de la <a href="">page de l'API de profilage BOTR - Pr√©sentation</a></em> </p><br><p>  De plus, il poss√®de d'autres fonctionnalit√©s efficaces.  Tout d'abord, vous pouvez configurer des gestionnaires qui sont appel√©s √† chaque ex√©cution de la m√©thode .NET, que ce soit dans l'environnement lui-m√™me ou √† partir du code utilisateur.  Ces rappels sont appel√©s gestionnaires d'entr√©e / sortie.  Voici un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bon exemple de la</a> fa√ßon de les utiliser.  Cependant, pour cela, vous devez comprendre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les conventions d'appel pour diff√©rentes architectures de syst√®me d'exploitation et de processeur</a> , ce qui n'est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pas toujours facile</a> .  N'oubliez pas non plus que l'API de profilage est un composant COM accessible uniquement √† partir du code C / C ++, mais pas √† partir de C # / F # / VB.NET. </p><br><p>  Deuxi√®mement, le profileur peut r√©√©crire le code IL de n'importe quelle m√©thode .NET avant la compilation JIT √† l'aide de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">API SetILFunctionBody ()</a> .  Cette API est vraiment efficace.  Il sous-tend de nombreux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">outils APM .NET</a> .  Vous pouvez en savoir plus sur son utilisation dans mon article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment se moquer des classes scell√©es et des m√©thodes statiques</a> et du code associ√©. </p><br><h3 id="icorprofiler-api">  API ICorProfiler </h3><br><p>  Il s'av√®re que l'API de profilage a fonctionn√©, il devrait y avoir toutes sortes de trucs dans l'environnement d'ex√©cution.  Il suffit de regarder la discussion sur la page <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Autoriser le rejet sur pi√®ce jointe</a> (voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ReJIT: Un guide pratique pour</a> plus d'informations sur ReJIT). </p><br><p> Une d√©finition compl√®te de toutes les interfaces et rappels de l'API de profilage se trouve dans <a href="">\ vm \ inc \ corprof.idl</a> (voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Langage de description d'interface</a> ).  Il est divis√© en 2 parties logiques.  Une partie est l'interface <strong>Profiler -&gt; Runtime Environment (EE)</strong> , connue sous le nom de <code>ICorProfilerInfo</code> : </p><br><pre> <code class="plaintext hljs">//  ,    ICorProfilerInfo*,  //     .  ,  DLL   //          ,     //    .</code> </pre> <br><p>  Ceci est impl√©ment√© dans les fichiers suivants: </p><br><ul><li>  <a href="">\ vm \ proftoeeinterfaceimpl.h</a> </li><li>  <a href="">\ vm \ proftoeeinterfaceimpl.inl</a> </li><li>  <a href="">\ vm \ proftoeeinterfaceimpl.cpp</a> </li></ul><br><p>  L'autre partie principale est les callbacks Runtime -&gt; Profiler, qui sont regroup√©s sous l'interface <code>ICorProfilerCallback</code> : </p><br><pre> <code class="plaintext hljs">//       //  ICorProfilerCallaback* .       // ,     EEToProfInterfaceImpl.</code> </pre> <br><p>  Ces rappels sont impl√©ment√©s dans les fichiers suivants: </p><br><ul><li>  <a href="">vm \ eetoprofinterfaceimpl.h</a> </li><li>  <a href="">vm \ eetoprofinterfaceimpl.inl</a> </li><li>  <a href="">vm \ eetoprofinterfaceimpl.cpp</a> </li><li>  <a href="">vm \ eetoprofinterfacewrapper.inl</a> </li></ul><br><p>  Enfin, il convient de noter que les API de profilage peuvent ne pas fonctionner sur tous les syst√®mes d'exploitation et architectures ex√©cutant .NET Core.  Voici un exemple: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">probl√®mes de talon d'appels ELT sous Linux</a> .  Voir le <a href="">statut des API CoreCLR Profiler</a> pour plus d'informations. </p><br><h3 id="profiling-v-debugging">  Profilage v.  D√©bogage </h3><br><p>  Comme petite digression, je dois dire que le profilage et le d√©bogage se chevauchent encore un peu.  Par cons√©quent, il est utile de comprendre ce que diff√©rentes API fournissent dans le contexte du runtime .NET (extrait du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©bogage CLR par rapport au profilage CLR</a> ). </p><br><p>  <strong>La diff√©rence entre le d√©bogage et le profilage dans le CLR</strong> </p><br><div class="scrollable-table"><table><thead><tr><th>  D√©bogage </th><th>  Profilage </th></tr></thead><tbody><tr><td>  Con√ßu pour trouver des probl√®mes avec l'exactitude du code. </td><td>  Con√ßu pour diagnostiquer et d√©panner les probl√®mes de performances. </td></tr><tr><td>  Peut avoir un niveau d'interf√©rence tr√®s √©lev√©. </td><td>  Il a g√©n√©ralement un faible niveau d'intervention.  Bien que le profileur prenne en charge la modification du code IL ou l'installation de gestionnaires d'entr√©e / sortie, tout cela est destin√© √† l'instrumentation, pas aux changements radicaux de code. </td></tr><tr><td>  La t√¢che principale est le contr√¥le complet de la cible.  Cela inclut l'inspection, le contr√¥le d'ex√©cution (par exemple, la commande set-next-statement) et les modifications (fonction Edit-and-Continue). </td><td>  La t√¢che principale consiste √† inspecter la cible.  Pour ce faire, une instrumentation est fournie (modification du code IL, installation des gestionnaires d'entr√©e / sortie) </td></tr><tr><td>  API √©tendue et un mod√®le d'objet √©pais rempli d'abstractions. </td><td>  Une petite API.  Il y a peu ou pas d'abstractions. </td></tr><tr><td>  Haut niveau d'interactivit√©: les actions du d√©bogueur sont contr√¥l√©es par l'utilisateur (ou algorithme).  En fait, les √©diteurs et d√©bogueurs sont souvent int√©gr√©s (IDE). </td><td>  Pas d'interactivit√©: les donn√©es sont g√©n√©ralement collect√©es sans intervention de l'utilisateur, puis analys√©es. </td></tr><tr><td>  Un petit nombre de changements critiques si la compatibilit√© descendante est n√©cessaire.  Nous pensons que la migration de la version 1.1 vers la version 2.0 du profileur sera une t√¢che simple ou peu difficile. </td><td>  Un grand nombre de changements critiques si une compatibilit√© descendante est n√©cessaire.  Nous pensons que la migration de la version 1.1 vers la version 2.0 du profileur sera une t√¢che difficile, identique √† la r√©√©crire compl√®tement. </td></tr></tbody></table></div><br><h2 id="otladka">  D√©bogage </h2><br><p>  Les d√©veloppeurs comprennent diff√©remment ce qu'est le d√©bogage.  Par exemple, j'ai demand√© sur Twitter ¬´comment d√©boguer des programmes .NET¬ª et j'ai obtenu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">beaucoup de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©ponses diff√©rentes</a> .  En m√™me temps, les r√©ponses contenaient une bonne liste d'outils et de m√©thodes, je recommande donc de les consulter.  Merci #LazyWeb </p><br><p>  Je pense que le meilleur de l'essence du d√©bogage refl√®te ce message: </p><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="399339918213652480"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br><p>  Le CLR fournit une liste compl√®te des fonctionnalit√©s li√©es au d√©bogage.  Mais pourquoi ces fonds sont-ils n√©cessaires?  Au moins trois raisons sont mentionn√©es dans cet excellent article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pourquoi le d√©bogage g√©r√© est-il diff√©rent du d√©bogage natif?</a>  : </p><br><ol><li>  Le d√©bogage du code non manag√© peut √™tre abstrait au niveau mat√©riel, mais le d√©bogage du code manag√© doit √™tre abstrait au niveau du code IL. </li><li>  Le d√©bogage du code manag√© n√©cessite un grand nombre d'informations qui ne sont pas disponibles avant l'ex√©cution. </li><li>  Le d√©bogueur de code manag√© doit se coordonner avec le garbage collector (GC) </li></ol><br><p>  Par cons√©quent, pour plus de facilit√© d'utilisation, le CLR doit fournir une API de d√©bogage de haut niveau appel√©e <code>ICorDebug</code> .  Il est illustr√© dans la figure ci-dessous montrant un sc√©nario de d√©bogage g√©n√©ral (source: BOTR): </p><br><h3 id="icordebug-api">  API ICorDebug </h3><br><p>  Le principe d'impl√©mentation et la description des diff√©rents composants sont extraits du <a href="">d√©bogage CLR, une br√®ve introduction</a> : </p><br><blockquote>  Toute la prise en charge du d√©bogage dans .Net est impl√©ment√©e au-dessus de la biblioth√®que de DLL, que nous appelons The Dac.  Ce fichier (g√©n√©ralement appel√© <code>mscordacwks.dll</code> ) est un √©l√©ment structurel √† la fois pour notre API de d√©bogage publique ( <code>ICorDebug</code> ) et deux API de d√©bogage priv√©es: l'API SOS-Dac et IXCLR. <br>  Dans un monde id√©al, tout le monde utiliserait <code>ICorDebug</code> , notre API publique.  Cependant, <code>ICorDebug</code> manque de nombreuses fonctionnalit√©s dont les d√©veloppeurs d'outils ont besoin.  C'est le probl√®me que nous essayons de r√©soudre l√† o√π nous le pouvons.  Toutefois, ces am√©liorations sont pr√©sentes uniquement dans le CL.v.next, mais pas dans les versions ant√©rieures du CLR.  En fait, la prise en charge du d√©bogage de vidage sur <code>ICorDebug</code> est apparue dans l'API <code>ICorDebug</code> uniquement avec la sortie de CLR v4.  Quiconque utilise des <code>ICorDebug</code> sur <code>ICorDebug</code> pour le d√©bogage dans CLR v2 ne pourra pas du tout appliquer <code>ICorDebug</code> . </blockquote><p>  <em>(Voir SOS et ICorDebug pour plus d'informations)</em> </p><br><p>  En fait, l'API <code>ICorDebug</code> est divis√©e en plus de 70 interfaces.  Je ne les donnerai pas tous, mais je montrerai par quelles cat√©gories ils peuvent √™tre divis√©s.  Pour plus d'informations, consultez la partition de ICorDebug, o√π cette liste a √©t√© publi√©e. </p><br><ul><li>  <strong>Niveau sup√©rieur</strong> : ICorDebug + ICorDebug2 - interfaces de niveau sup√©rieur qui servent parfaitement de collection d'objets ICorDebugProcess. </li><li>  <strong>Rappels</strong> : les √©v√©nements de d√©bogage de code manag√© sont envoy√©s via des m√©thodes √† l'objet de rappel impl√©ment√© par le d√©bogueur. </li><li>  <strong>Processus</strong> : cet ensemble d'interfaces repr√©sente le code de travail et inclut des API li√©es aux √©v√©nements. </li><li>  <strong>Inspection de code / type</strong> : fonctionne principalement avec des images PE statiques, mais il existe des m√©thodes pratiques pour les donn√©es r√©elles. </li><li>  <strong>Contr√¥le d'ex√©cution</strong> : possibilit√© de suivre la progression du thread.  En pratique, cela signifie la possibilit√© de d√©finir des points d'arr√™t (F9) et de parcourir le code (entr√©e de code F11, contournement de code F10, sortie de code S + F11).  La fonction de contr√¥le d'ex√©cution ICorDebug ne fonctionne que dans le code manag√©. </li><li>  <strong>Threads + piles d'appels</strong> : les <strong>piles d'appels</strong> sont la base des fonctions d'inspection impl√©ment√©es par le d√©bogueur.  Le travail avec la pile d'appels s'effectue √† l'aide des interfaces suivantes.  ICorDebug prend uniquement en charge le d√©bogage du code manag√© et, par cons√©quent, vous pouvez suivre la pile de code manag√© uniquement. </li><li>  <strong>Inspection d'objets</strong> : l' <strong>inspection d'objets</strong> fait partie de l'API qui vous permet de voir les valeurs des variables dans le code d√©bogu√©.  Pour chaque interface, je donne la m√©thode MVP, qui, il me semble, devrait d√©crire bri√®vement le but de cette interface. </li></ul><br><p>  Comme pour les API de profilage, les niveaux de prise en charge des API de d√©bogage varient selon le syst√®me d'exploitation et l'architecture du processeur.  Par exemple, en ao√ªt 2018, il n'y avait toujours pas de solution Linux ARM pour diagnostiquer et d√©boguer le code manag√©.  Pour plus d'informations sur la prise en charge de Linux, consultez D√©bogage de .NET Core sous Linux avec LLDB et le r√©f√©rentiel de diagnostics de Microsoft, qui vise √† faciliter le d√©bogage des programmes .NET sous Linux. </p><br><p>  Enfin, si vous voulez voir √† quoi ressemble l'API <code>ICorDebug</code> en C #, jetez un ≈ìil aux wrappers de la biblioth√®que CLRMD, y compris tous les rappels disponibles (plus d'informations sur CLRMD seront discut√©es plus loin dans cet article). </p><br><h3 id="sos-i-dac">  SOS et DAC </h3><br><p>  Le composant d'acc√®s aux donn√©es (DAC) est d√©crit en d√©tail sur <a href="">la page BOTR</a> .  Essentiellement, il fournit un acc√®s hors processus aux structures de donn√©es CLR afin que les informations qu'elles contiennent puissent √™tre lues √† partir d'un autre processus.  Ainsi, le d√©bogueur (via <code>ICorDebug</code> ) ou l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">extension 'Son of Strike' (SOS)</a> peut acc√©der √† l'instance CLR ou au vidage de m√©moire en cours d'ex√©cution et trouver, par exemple: </p><br><ul><li>  tous les threads en cours d'ex√©cution; </li><li>  objets de tas g√©r√©s </li><li>  des informations compl√®tes sur la m√©thode, y compris le code machine; </li><li>  trace de pile actuelle. </li></ul><br><p>  <strong>Une petite digression</strong> : si vous voulez savoir d'o√π viennent ces noms √©tranges et obtenir une petite le√ßon sur l'histoire .NET, consultez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette r√©ponse sur Stack Overflow</a> . </p><br><p>  La liste compl√®te des commandes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SOS</a> est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">impressionnante</a> .  Si vous l'utilisez avec WinDBG, vous pouvez d√©couvrir ce qui se passe √† l'int√©rieur de votre programme et du CLR √† un niveau tr√®s bas.  Pour voir comment tout est impl√©ment√©, regardons la <code>!HeapStat</code> , qui affiche une description des tailles des diff√©rents tas que le GC .NET utilise: </p><br><p>  (Image extraite de SOS: la prochaine version contient quelques nouvelles commandes - HeapStat) </p><br><p>  Voici un flux de code qui montre comment SOS et DAC fonctionnent ensemble: </p><br><ul><li>  √âquipe compl√®te <strong>SOS</strong> <code>!HeapStat</code> ( <a href="">lien</a> ) </li><li>  Code <strong>SOS</strong> dans la <code>!HeapStat</code> qui fonctionne avec Workstation GC (lien) </li><li>  Fonction <strong>SOS</strong> <code>GCHeapUsageStats(..)</code> , qui effectue la partie la plus difficile du travail ( <a href="">lien</a> ) </li><li>  <code>DacpGcHeapDetails</code> donn√©es <code>DacpGcHeapDetails</code> <strong>partag√©e</strong> qui contient des pointeurs vers les donn√©es principales du tas GC, tels que des segments, des masques de bits et des g√©n√©rations individuelles ( <a href="">r√©f√©rence</a> ). </li><li>  <code>GetGCHeapStaticData</code> <strong>DAC</strong> <code>GetGCHeapStaticData</code> qui remplit la structure <code>DacpGcHeapDetails</code> ( <a href="">lien</a> ) </li><li>  <code>DacpHeapSegmentData</code> donn√©es <code>DacpHeapSegmentData</code> <strong>partag√©e</strong> qui contient des informations sur un segment de segment GC individuel ( <a href="">lien</a> ) </li><li>  <strong>DAC</strong> <code>GetHeapSegmentData(..)</code> , qui remplit la structure <code>DacpHeapSegmentData</code> ( <a href="">lien</a> ) </li></ul><br><h3 id="storonnie-otladchiki">  D√©bogueurs tiers </h3><br><p>  Depuis que Microsoft a publi√© l'API de d√©bogage, les d√©veloppeurs tiers ont pu utiliser les interfaces <code>ICorDebug</code> .  Voici une liste de ceux que j'ai r√©ussi √† trouver: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Samsung</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Debugger for .NET Core runtime</a> <br><ul><li>  Le d√©bogueur vous permet d'utiliser l'interface de l'adaptateur de d√©bogage GDB / MI ou VSCode pour corriger les erreurs dans les applications .NET sous le runtime .NET Core. </li><li>  <em>Probablement</em> √©crit dans le cadre d'un projet de portage de <a href="">.NET Core sur leur syst√®me d'exploitation Tizen</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dnSpy</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D√©bogueur</a> .NET et √©diteur d'assemblage <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Un outil tr√®s puissant</a> .  Il s'agit d'un d√©bogueur, d'un √©diteur d'assemblage, d'un √©diteur hexad√©cimal, d'un d√©compilateur et bien plus encore. </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MDbg.exe (d√©bogueur de ligne de commande .NET Framework)</a> <br><ul><li>  Disponible sous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">forme de package NuGet</a> .  Il peut √©galement √™tre t√©l√©charg√© √† partir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">du r√©f√©rentiel GitHub</a> ou du site Web de Microsoft. </li><li>  Cependant, pour le moment, MDBG ne semble pas prendre en charge .NET Core.  Voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Port MDBG vers CoreCLR</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ETA pour le portage de mdbg vers coreclr pour plus d'informations</a> . </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JetBrains 'Rider'</a> vous permet de d√©boguer .NET Core sous Windows. <br><ul><li>  Il y a eu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">quelques probl√®mes de</a> licence avec cet outil. </li><li>  Plus d'informations peuvent √™tre trouv√©es dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce fil HackerNews.</a> </li></ul></li></ul><br><h3 id="dampy-pamyati">  Vidages de m√©moire </h3><br><p>  La derni√®re chose dont nous parlerons est les vidages de m√©moire, qui peuvent √™tre obtenus √† partir d'un syst√®me de travail et analys√©s √† l'ext√©rieur.  Le runtime .NET a toujours pris en charge le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vidage de la m√©moire sous Windows</a> .  Et maintenant que .NET Core est devenu multiplateforme, des outils sont apparus qui effectuent la m√™me t√¢che sur d'autres syst√®mes d'exploitation. </p><br><p>  Lors de l'utilisation de vidages de m√©moire, il est parfois difficile d'obtenir les versions correctes et correspondantes des fichiers SOS et DAC.  Heureusement, Microsoft a r√©cemment publi√© l'outil CLI <code>dotnet symbol</code> , qui: </p><br><blockquote>  peut t√©l√©charger tous les fichiers n√©cessaires au d√©bogage (jeux de caract√®res, modules, fichiers SOS et DAC pour un module de coreclr sp√©cifique) pour tout vidage de m√©moire sp√©cifique, minidump ou fichiers de toute plate-forme prise en charge, y compris ELF, MachO, DLL Windows, PDB et portable PDB </blockquote><p>  Enfin, si vous faites un peu d'analyse des vidages de m√©moire, je vous recommande de jeter un ≈ìil √† l'excellente biblioth√®que CLR MD que Microsoft a publi√©e il y a plusieurs ann√©es.  J'ai d√©j√† √©crit sur ses fonctions.  En bref, en utilisant la biblioth√®que, vous pouvez travailler avec des vidages de m√©moire via une API C # intuitive contenant des classes qui donnent acc√®s √† ClrHeap, GC Roots, CLR Threads, Stack Frames et bien plus encore.  En fait, le CLR MD peut impl√©menter la plupart (sinon la totalit√©) des commandes SOS. </p><br><p>  Vous pouvez d√©couvrir comment cela fonctionne √† partir de ce <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">post</a> : </p><br><blockquote>  La biblioth√®que g√©r√©e ClrMD est un wrapper autour des API de d√©bogage destin√©es √† un usage interne uniquement dans le CLR.  Malgr√© le fait que ces API soient tr√®s efficaces pour les diagnostics, nous ne les prenons pas en charge sous la forme de versions publiques et document√©es, car leur utilisation est complexe et √©troitement li√©e √† d'autres fonctionnalit√©s de l'impl√©mentation CLR.  ClrMD r√©sout ce probl√®me en fournissant un wrapper facile √† utiliser et g√©rable autour de ces API de d√©bogage de bas niveau. </blockquote><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/97f/1d3/cf0/97f1d3cf0e2a6bf007066eb60a789c31.png"></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr466097/">https://habr.com/ru/post/fr466097/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr466075/index.html">Comment j'ai quitt√© la science fondamentale dans une startup</a></li>
<li><a href="../fr466077/index.html">Journ√©e Techdir de diffusion √† Saint-P√©tersbourg</a></li>
<li><a href="../fr466081/index.html">3 septembre</a></li>
<li><a href="../fr466089/index.html">Algorithme de pens√©e et de conscience, partie 2</a></li>
<li><a href="../fr466093/index.html">Comment fonctionne kubectl exec?</a></li>
<li><a href="../fr466099/index.html">Caract√©ristiques du test d'une application Web pour le service vid√©o</a></li>
<li><a href="../fr466103/index.html">Surveillance de la s√©curit√© du cloud</a></li>
<li><a href="../fr466105/index.html">Overclocking de l'API Magento Rest avec RoadRunner</a></li>
<li><a href="../fr466107/index.html">Syst√®me de maison intelligente √† faire soi-m√™me</a></li>
<li><a href="../fr466109/index.html">R√©solution de probl√®mes avec pwnable.kr 22 - brainfuck. Attaque Ret2libc</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>