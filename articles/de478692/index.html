<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéµ ü§¥üèæ ‚úâÔ∏è Wie Java 8 auf Android unterst√ºtzt wird ‚è∫Ô∏è üï∫üèº üé¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habr Ich mache Sie auf eine √úbersetzung eines wunderbaren Artikels aus einer Reihe von Artikeln des ber√ºchtigten Jake Worton aufmerksam, in dene...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie Java 8 auf Android unterst√ºtzt wird</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/478692/">  Hallo habr  Ich mache Sie auf eine √úbersetzung eines wunderbaren Artikels aus einer Reihe von Artikeln des <a href="https://twitter.com/JakeWharton%3Flang%3Den">ber√ºchtigten Jake Worton aufmerksam, in denen es</a> darum geht, wie Android 8 von Java unterst√ºtzt wird. <br><br><img src="https://habrastorage.org/webt/ho/ap/qe/hoapqe-nhkwts3ekeettjbuiao8.png"><br><br>  <font color="#0000ff"><a href="https://jakewharton.com/androids-java-8-support/">Der Originalartikel ist hier</a></font> <br><a name="habracut"></a><br>  Ich habe mehrere Jahre von zu Hause aus gearbeitet und oft geh√∂rt, wie sich meine Kollegen dar√ºber beschwert haben, dass Android verschiedene Java-Versionen unterst√ºtzt. <br><br>  Dies ist ein ziemlich kompliziertes Thema.  Zuerst m√ºssen Sie entscheiden, was wir unter ‚ÄûJava-Unterst√ºtzung in Android‚Äú verstehen, da es in einer Version der Sprache viele Dinge geben kann: Funktionen (z. B. Lambdas), Bytecode, Tools, APIs, JVM usw. <br><br>  Wenn von Java 8-Unterst√ºtzung in Android die Rede ist, bedeutet dies in der Regel Unterst√ºtzung f√ºr Sprachfunktionen.  Fangen wir also mit ihnen an. <br><br><h2>  Lambdas </h2><br>  Eine der Hauptinnovationen von Java 8 waren Lambdas. <br>  Der Code ist √ºbersichtlicher und einfacher geworden, und Lambdas haben uns das Schreiben umst√§ndlicher anonymer Klassen √ºber eine Schnittstelle mit einer einzigen darin enthaltenen Methode erspart. <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Java8</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ sayHi(s -&gt; System.out.println(s)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayHi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Logger logger)</span></span></span><span class="hljs-function"> </span></span>{ logger.log(<span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>); } }</code> </pre> <br>  Nach dem Kompilieren mit Javac und dem Legacy- <code>dx tool</code> wird der folgende Fehler angezeigt: <br><br><pre> <code class="plaintext hljs">$ javac *.java $ ls Java8.java Java8.class Java8$Logger.class $ $ANDROID_HOME/build-tools/28.0.2/dx --dex --output . *.class Uncaught translation error: com.android.dx.cf.code.SimException: ERROR in Java8.main:([Ljava/lang/String;)V: invalid opcode ba - invokedynamic requires --min-sdk-version &gt;= 26 (currently 13) 1 error; aborting</code> </pre> <br>  Dieser Fehler ist darauf zur√ºckzuf√ºhren, dass Lambdas eine neue Anweisung im Bytecode verwenden - <code>invokedynamic</code> , der in Java 7 hinzugef√ºgt wurde. Aus dem Fehlertext geht hervor, dass Android diese Anweisung nur ab der 26-API (Android 8) unterst√ºtzt. <br><br>  Es klingt nicht sehr gut, da kaum jemand eine Anwendung mit 26 minApi ver√∂ffentlicht.  Um dies zu <i>umgehen</i> , wird <i>der</i> sogenannte <i>Desugaring-</i> Prozess <i>verwendet</i> , der Lambda-Unterst√ºtzung f√ºr alle Versionen der API erm√∂glicht. <br><br><h2>  Geschichte der Entzuckerung </h2><br>  Sie ist ziemlich bunt in der Android-Welt.  Das Ziel der Entzuckerung ist immer dasselbe - neue Sprachfunktionen k√∂nnen auf allen Ger√§ten verwendet werden. <br><br>  Um beispielsweise Lambdas in Android zu unterst√ºtzen, haben Entwickler zun√§chst das <a href="https://github.com/evant/gradle-retrolambda">Retrolambda-</a> Plugin <a href="https://github.com/evant/gradle-retrolambda">eingebunden</a> .  Er verwendete denselben eingebauten Mechanismus wie die JVM, konvertierte Lambdas in Klassen, tat dies jedoch zur Laufzeit und nicht zur Kompilierungszeit.  Die generierten Klassen waren in Bezug auf die Anzahl der Methoden sehr teuer, aber im Laufe der Zeit ging dieser Indikator nach Verbesserungen und Verbesserungen auf etwas mehr oder weniger Vern√ºnftiges zur√ºck. <br><br>  Dann k√ºndigte das Android-Team <a href="https://android-developers.googleblog.com/2014/12/hello-world-meet-our-new-experimental.html">einen neuen Compiler an</a> , der alle Java 8-Funktionen unterst√ºtzt und produktiver ist.  Es wurde auf dem Eclipse Java-Compiler erstellt, aber anstatt einen Java-Bytecode zu generieren, wurde ein Dalvik-Bytecode generiert.  Die Leistung lie√ü jedoch noch zu w√ºnschen √ºbrig. <br><br>  Als der neue Compiler (zum Gl√ºck) aufgegeben wurde, wurde der Java-Bytecode-Umsetzer im Java-Bytecode, der die Jonglage durchf√ºhrte, <a href="https://android-developers.googleblog.com/2017/04/java-8-language-features-support-update.html">in das Android Gradle Plugin</a> von <a href="https://docs.bazel.build/versions/master/bazel-and-android.html">Bazel</a> , Googles Build-System, integriert.  Da die Leistung immer noch gering war, wurde die Suche nach einer besseren L√∂sung parallel fortgesetzt. <br><br>  Und jetzt wurde uns <a href="https://android-developers.googleblog.com/2017/08/next-generation-dex-compiler-now-in.html"><code>  dexer</code></a> - <i>D8</i> , der das <a href="https://android-developers.googleblog.com/2017/08/next-generation-dex-compiler-now-in.html"><code>  dexer</code></a> <code>dx tool</code> ersetzen sollte.  Die Desaccharisierung wurde nun w√§hrend der Konvertierung kompilierter JAR-Dateien nach <code>.dex</code> (Dexing) durchgef√ºhrt.  D8 hat eine viel bessere Leistung als DX und ist seit Android Gradle Plugin 3.1 zum Standard-Dexer geworden. <br><br><h2>  D8 </h2><br>  Jetzt k√∂nnen wir mit D8 den obigen Code kompilieren. <br><br><pre> <code class="plaintext hljs">$ java -jar d8.jar \ --lib $ANDROID_HOME/platforms/android-28/android.jar \ --release \ --output . \ *.class $ ls Java8.java Java8.class Java8$Logger.class classes.dex</code> </pre> <br>  Um zu sehen, wie der D8 Lambda konvertiert, k√∂nnen Sie das <code>dexdump tool</code> , das im Android SDK enthalten ist.  Es wird eine Menge von allem angezeigt, aber wir werden uns nur darauf konzentrieren: <br><br><pre> <code class="plaintext hljs">$ $ANDROID_HOME/build-tools/28.0.2/dexdump -d classes.dex [0002d8] Java8.main:([Ljava/lang/String;)V 0000: sget-object v0, LJava8$1;.INSTANCE:LJava8$1; 0002: invoke-static {v0}, LJava8;.sayHi:(LJava8$Logger;)V 0005: return-void [0002a8] Java8.sayHi:(LJava8$Logger;)V 0000: const-string v0, "Hello" 0002: invoke-interface {v1, v0}, LJava8$Logger;.log:(Ljava/lang/String;)V 0005: return-void ‚Ä¶</code> </pre> <br>  Wenn Sie den Bytecode noch nicht gelesen haben, machen Sie sich keine Sorgen: Vieles, was hier geschrieben ist, kann intuitiv verstanden werden. <br><br>  Im ersten Block erh√§lt unsere Hauptmethode mit dem Index <code>0000</code> eine Referenz aus dem Feld <code>INSTANCE</code> auf die <code>INSTANCE</code> Klasse <code>Java8$1</code> .  Diese Klasse wurde w√§hrend der <code></code> erzeugt.  Der Bytecode der Hauptmethode enth√§lt auch keine Erw√§hnung des K√∂rpers unseres Lambda, daher ist er h√∂chstwahrscheinlich mit der <code>Java8$1</code> Klasse <code>Java8$1</code> .  Der Index <code>0002</code> ruft dann die statische Methode <code>sayHi</code> √ºber die Verkn√ºpfung mit <code>INSTANCE</code> .  Die <code>sayHi</code> erfordert <code>Java8$Logger</code> , daher scheint <code>Java8$1</code> diese Schnittstelle zu implementieren.  Das k√∂nnen wir hier √ºberpr√ºfen: <br><br><pre> <code class="plaintext hljs">Class #2 - Class descriptor : 'LJava8$1;' Access flags : 0x1011 (PUBLIC FINAL SYNTHETIC) Superclass : 'Ljava/lang/Object;' Interfaces - #0 : 'LJava8$Logger;'</code> </pre> <br>  Das <code>SYNTHETIC</code> Flag bedeutet, dass die <code>Java8$1</code> Klasse generiert wurde und die darin enthaltene Schnittstellenliste den <code>Java8$Logger</code> . <br>  Diese Klasse repr√§sentiert unser Lambda.  Wenn Sie sich die Implementierung der <code>log</code> Methode ansehen, werden Sie den K√∂rper des Lambda nicht sehen. <br><br><pre> <code class="plaintext hljs">‚Ä¶ [00026c] Java8$1.log:(Ljava/lang/String;)V 0000: invoke-static {v1}, LJava8;.lambda$main$0:(Ljava/lang/String;)V 0003: return-void ‚Ä¶</code> </pre> <br>  Stattdessen hei√üt die <code>static</code> Methode der <code>Java8</code> Klasse <code>Java8</code> <code>lambda$main$0</code> .  Ich wiederhole, diese Methode wird nur in Bytecode dargestellt. <br><br><pre> <code class="plaintext hljs">‚Ä¶ #1 : (in LJava8;) name : 'lambda$main$0' type : '(Ljava/lang/String;)V' access : 0x1008 (STATIC SYNTHETIC) [0002a0] Java8.lambda$main$0:(Ljava/lang/String;)V 0000: sget-object v0, Ljava/lang/System;.out:Ljava/io/PrintStream; 0002: invoke-virtual {v0, v1}, Ljava/io/PrintStream;.println:(Ljava/lang/String;)V 0005: return-void</code> </pre> <br>  Das <code>SYNTHETIC</code> Flag gibt erneut an, dass diese Methode generiert wurde und ihr Bytecode nur den Lambda-Body enth√§lt: einen Aufruf von <code>System.out.println</code> .  Der Grund, warum der Lambda-Body in <i>Java8.class enthalten</i> ist, ist einfach: M√∂glicherweise muss er auf <code>private</code> Member der Klasse zugreifen, auf die die generierte Klasse keinen Zugriff hat. <br><br>  Alles, was Sie brauchen, um zu verstehen, wie die <i>Desaccharisierung</i> funktioniert, ist oben beschrieben.  Anhand des Dalvik-Bytecodes k√∂nnen Sie jedoch erkennen, dass dort alles viel komplizierter und erschreckender ist. <br><br><h2>  Quelltransformation </h2><br>  Um besser zu verstehen, wie die <i>Desaccharisierung</i> erfolgt, versuchen wir Schritt f√ºr Schritt, unsere Klasse in etwas zu konvertieren, das auf allen Versionen der API funktioniert. <br><br>  Nehmen wir die gleiche Klasse mit Lambda als Basis: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Java8</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ sayHi(s -&gt; System.out.println(s)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayHi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Logger logger)</span></span></span><span class="hljs-function"> </span></span>{ logger.log(<span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>); } }</code> </pre> <br>  Zun√§chst wird der Lambda-K√∂rper in die Methode <code>package private</code> verschoben. <br><br><pre> <code class="diff hljs"> public static void main(String... args) { - sayHi(s -&gt; System.out.println(s)); + sayHi(s -&gt; lambda$main$0(s)); } + + static void lambda$main$0(String s) { + System.out.println(s); + }</code> </pre> <br>  Anschlie√üend wird eine Klasse implementiert, die die <code>Logger</code> Schnittstelle implementiert, in der ein Codeblock aus dem Lambda-Body ausgef√ºhrt wird. <br><br><pre> <code class="diff hljs"> public static void main(String... args) { - sayHi(s -&gt; lambda$main$0(s)); + sayHi(new Java8$1()); } @@ } + +class Java8$1 implements Java8.Logger { + @Override public void log(String s) { + Java8.lambda$main$0(s); + } +}</code> </pre> <br>  Als n√§chstes wird eine Singleton-Instanz von <code>Java8$1</code> , die in der <code>static</code> Variablen <code>INSTANCE</code> . <br><br><pre> <code class="diff hljs"> public static void main(String... args) { - sayHi(new Java8$1()); + sayHi(Java8$1.INSTANCE); } @@ class Java8$1 implements Java8.Logger { + static final Java8$1 INSTANCE = new Java8$1(); + @Override public void log(String s) {</code> </pre> <br>  Hier ist die letzte <i>√ºberspielte</i> Klasse, die f√ºr alle Versionen der API verwendet werden kann: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Java8</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ sayHi(Java8$<span class="hljs-number"><span class="hljs-number">1</span></span>.INSTANCE); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> lambda$main$<span class="hljs-number"><span class="hljs-number">0</span></span>(String s) { System.out.println(s); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayHi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Logger logger)</span></span></span><span class="hljs-function"> </span></span>{ logger.log(<span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Java8</span></span></span><span class="hljs-class">$1 </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Java8</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Java8$<span class="hljs-number"><span class="hljs-number">1</span></span> INSTANCE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Java8$<span class="hljs-number"><span class="hljs-number">1</span></span>(); <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span><span class="hljs-function"> </span></span>{ Java8.lambda$main$<span class="hljs-number"><span class="hljs-number">0</span></span>(s); } }</code> </pre> <br>  Wenn Sie sich die generierte Klasse im Dalvik-Bytecode ansehen, werden Sie keine Namen wie Java8 $ 1 finden - es wird so etwas wie <code>-$$Lambda$Java8$QkyWJ8jlAksLjYziID4cZLvHwoY</code> .  Der Grund, warum eine solche Benennung f√ºr die Klasse generiert wird, und welche Vorteile dies hat, wird in einem separaten Artikel erl√§utert. <br><br><h2>  Eingeborene Lambda-Unterst√ºtzung </h2><br>  Als wir mit dem <code>dx tool</code> eine Klasse kompilierten, die Lambdas enthielt, wurde in einer Fehlermeldung darauf hingewiesen, dass dies nur mit 26 APIs funktioniert. <br><br><pre> <code class="plaintext hljs">$ $ANDROID_HOME/build-tools/28.0.2/dx --dex --output . *.class Uncaught translation error: com.android.dx.cf.code.SimException: ERROR in Java8.main:([Ljava/lang/String;)V: invalid opcode ba - invokedynamic requires --min-sdk-version &gt;= 26 (currently 13) 1 error; aborting</code> </pre> <br>  Daher erscheint es logisch, dass beim Kompilieren mit dem <code>‚Äîmin-api 26</code> keine Desaccharisierung erfolgt. <br><br><pre> <code class="bash hljs">$ java -jar d8.jar \ --lib <span class="hljs-variable"><span class="hljs-variable">$ANDROID_HOME</span></span>/platforms/android-28/android.jar \ --release \ --min-api 26 \ --output . \ *.class</code> </pre> <br>  Wenn wir jedoch die <code>.dex</code> Datei <code>.dex</code> , kann sie immer noch darin gefunden werden <code>-$$Lambda$Java8$QkyWJ8jlAksLjYziID4cZLvHwoY</code> .  Warum so?  Ist das ein D8-Bug? <br><br>  Um diese Frage zu beantworten und auch, warum <i>immer eine</i> Desaccharisierung <i>stattfindet</i> , m√ºssen wir den Java-Bytecode der <code>Java8</code> Klasse untersuchen. <br><br><pre> <code class="bash hljs">$ javap -v Java8.class class Java8 { public static void main(java.lang.String...); Code: 0: invokedynamic <span class="hljs-comment"><span class="hljs-comment">#2, 0 // InvokeDynamic #0:log:()LJava8$Logger; 5: invokestatic #3 // Method sayHi:(LJava8$Logger;)V 8: return } ‚Ä¶</span></span></code> </pre> <br>  In der <code>main</code> wir wieder <i>invokedynamic</i> bei Index <code>0</code> .  Das zweite Argument im Aufruf ist <code>0</code> - der Index der ihm zugeordneten <a href="https://stackoverflow.com/questions/30733557/what-is-a-bootstrap-method">Bootstrap-</a> Methode. <br><br>  Hier ist eine Liste der <i>Bootstrap-</i> Methoden: <br><br><pre> <code class="plaintext hljs">‚Ä¶ BootstrapMethods: 0: #27 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:( Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String; Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType; Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;) Ljava/lang/invoke/CallSite; Method arguments: #28 (Ljava/lang/String;)V #29 invokestatic Java8.lambda$main$0:(Ljava/lang/String;)V #28 (Ljava/lang/String;)V</code> </pre> <br>  Hier wird die <i>Bootstrap-</i> Methode in der Klasse <code>java.lang.invoke.LambdaMetafactory</code> als <code>metafactory</code> .  Er <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/LambdaMetafactory.html">lebt im JDK</a> und erstellt zur Laufzeit anonyme On-the-Fly-Klassen f√ºr Lambdas, so wie D8 sie in Rechenzeit generiert. <br><br>  Wenn Sie in der <a href="https://developer.android.com/reference/java/lang/invoke/package-summary"><code> Android  java.lang.invoke</code></a> suchen <br>  In den <a href="https://android.googlesource.com/platform/libcore/%2B/master/ojluni/src/main/java/java/lang/invoke/"><code> AOSP  java.lang.invoke</code></a> wir, dass sich diese Klasse nicht in der Laufzeit befindet.  Das ist der Grund, warum das De-Jonglieren immer zur Kompilierungszeit stattfindet, egal welche minApi Sie haben.  Die VM unterst√ºtzt Bytecode-Anweisungen √§hnlich wie <code>invokedynamic</code> , die im JDK integrierte <code>invokedynamic</code> steht jedoch nicht zur Verf√ºgung. <br><br><h2>  Methodenreferenzen </h2><br>  Neben Lambdas wurden in Java 8 Methodenreferenzen hinzugef√ºgt. Dies ist eine effektive M√∂glichkeit, ein Lambda zu erstellen, dessen K√∂rper auf eine vorhandene Methode verweist. <br><br>  Unsere <code>Logger</code> Oberfl√§che ist nur ein Beispiel.  Der Lambda-K√∂rper bezieht sich auf <code>System.out.println</code> .  Lassen Sie uns das Lambda in eine Referenzmethode umwandeln: <br><br><pre> <code class="diff hljs"> public static void main(String... args) { - sayHi(s -&gt; System.out.println(s)); + sayHi(System.out::println); }</code> </pre> <br>  Wenn wir es kompilieren und uns den Bytecode ansehen, werden wir einen Unterschied zur vorherigen Version feststellen: <br><br><pre> <code class="plaintext hljs">[000268] -$$Lambda$1Osqr2Z9OSwjseX_0FMQJcCG_uM.log:(Ljava/lang/String;)V 0000: iget-object v0, v1, L-$$Lambda$1Osqr2Z9OSwjseX_0FMQJcCG_uM;.f$0:Ljava/io/PrintStream; 0002: invoke-virtual {v0, v2}, Ljava/io/PrintStream;.println:(Ljava/lang/String;)V 0005: return-void</code> </pre> <br>  Anstatt das generierte <code>Java8.lambda$main$0</code> , das einen Aufruf von <code>System.out.println</code> , wird jetzt <code>System.out.println</code> direkt aufgerufen. <br><br>  Eine Klasse mit einem Lambda ist kein <code>static</code> Singleton mehr, aber durch den Index <code>0000</code> im Bytecode sehen wir, dass wir einen Link zu <code>PrintStream</code> - <code>System.out</code> , der dann verwendet wird, um <code>println</code> darauf <code>println</code> . <br><br>  Infolgedessen hat sich unsere Klasse wie folgt entwickelt: <br><br><pre> <code class="diff hljs"> public static void main(String... args) { - sayHi(System.out::println); + sayHi(new -$$Lambda$1Osqr2Z9OSwjseX_0FMQJcCG_uM(System.out)); } @@ } + +class -$$Lambda$1Osqr2Z9OSwjseX_0FMQJcCG_uM implements Java8.Logger { + private final PrintStream ps; + + -$$Lambda$1Osqr2Z9OSwjseX_0FMQJcCG_uM(PrintStream ps) { + this.ps = ps; + } + + @Override public void log(String s) { + ps.println(s); + } +}</code> </pre> <br><h2>  <code>Default</code> und <code>static</code> Methoden in Schnittstellen </h2><br>  Eine weitere wichtige und wichtige √Ñnderung, die Java 8 mit sich brachte, war die M√∂glichkeit, <code>default</code> und <code>static</code> Methoden in Schnittstellen zu deklarieren. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String tag, String s)</span></span></span><span class="hljs-function"> </span></span>{ log(tag + <span class="hljs-string"><span class="hljs-string">": "</span></span> + s); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Logger </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">systemOut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> System.out::println; } }</code> </pre> <br>  All dies wird auch von D8 unterst√ºtzt.  Mit den gleichen Tools wie zuvor ist es einfach, eine angemeldete Version von Logger mit <code>default</code> und <code>static</code> Methoden anzuzeigen.  Einer der Unterschiede zu Lambdas und <code>method references</code> besteht darin, dass die Standardmethoden und die statischen Methoden in der Android-VM implementiert sind und D8 sie ab der 24-API nicht <i>entkoppelt</i> . <br><br><h2>  Vielleicht einfach Kotlin benutzen? </h2><br>  Wahrscheinlich haben die meisten von Ihnen beim Lesen des Artikels an Kotlin gedacht.  Ja, es werden alle Java 8-Funktionen unterst√ºtzt, aber sie werden von <code>kotlinc</code> mit Ausnahme einiger Details auf dieselbe Weise wie D8 implementiert. <br><br>  Daher ist die Android-Unterst√ºtzung f√ºr neue Java-Versionen immer noch sehr wichtig, auch wenn Ihr Projekt zu 100% in Kotlin geschrieben ist. <br><br>  M√∂glicherweise wird Kotlin in Zukunft den Bytecode von Java 6 und Java 7. <a href="https://blog.jetbrains.com/idea/2015/12/intellij-idea-16-eap-144-2608-is-out/">IntelliJ IDEA</a> , Gradle 5.0 auf Java 8 umgestellt. Die Anzahl der Plattformen, die auf √§lteren JVMs ausgef√ºhrt werden, nimmt ab. <br><br><h2>  APIs desugarieren </h2><br>  Die ganze Zeit habe ich √ºber Java 8-Funktionen gesprochen, aber nichts √ºber die neuen APIs gesagt - Streams, <code>CompletableFuture</code> , Datum / Uhrzeit und so weiter. <br><br>  Zur√ºck zum Logger-Beispiel k√∂nnen wir die neue Datums- / Uhrzeit-API verwenden, um herauszufinden, wann Nachrichten gesendet wurden. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.time.*; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Java8</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LocalDateTime time, String s)</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ sayHi((time, s) -&gt; System.out.println(time + <span class="hljs-string"><span class="hljs-string">" "</span></span> + s)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayHi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Logger logger)</span></span></span><span class="hljs-function"> </span></span>{ logger.log(LocalDateTime.now(), <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>); } }</code> </pre> <br>  <i>Kompilieren Sie</i> es erneut mit <code>javac</code> und konvertieren Sie es mit D8 in den Dalvik-Bytecode, wodurch es f√ºr die Unterst√ºtzung aller API-Versionen <i>entkoppelt wird</i> . <br><br><pre> <code class="plaintext hljs">$ javac *.java $ java -jar d8.jar \ --lib $ANDROID_HOME/platforms/android-28/android.jar \ --release \ --output . \ *.class</code> </pre> <br>  Sie k√∂nnen dies sogar auf Ihrem Ger√§t ausf√ºhren, um sicherzustellen, dass es funktioniert. <br><br><pre> <code class="plaintext hljs">$ adb push classes.dex /sdcard classes.dex: 1 file pushed. 0.5 MB/s (1620 bytes in 0.003s) $ adb shell dalvikvm -cp /sdcard/classes.dex Java8 2018-11-19T21:38:23.761 Hello</code> </pre> <br>  Wenn API 26 und h√∂her auf diesem Ger√§t installiert ist, wird die Meldung Hallo angezeigt.  Wenn nicht, sehen wir folgendes: <br><br><pre> <code class="plaintext hljs">java.lang.NoClassDefFoundError: Failed resolution of: Ljava/time/LocalDateTime; at Java8.sayHi(Java8.java:13) at Java8.main(Java8.java:9)</code> </pre> <br>  D8 befasste sich mit Lambdas, einer Referenzmethode, funktionierte jedoch nicht mit <code>LocalDateTime</code> , und das ist sehr traurig. <br><br>  Entwickler m√ºssen ihre eigenen Implementierungen oder Wrapper f√ºr Datum / Uhrzeit-API verwenden oder Bibliotheken wie <code>ThreeTenBP</code> , um mit der Zeit zu arbeiten. Warum k√∂nnen Sie D8 nicht mit Ihren eigenen H√§nden <code>ThreeTenBP</code> ? <br><br><h2>  Nachwort </h2><br>  Der Mangel an Unterst√ºtzung f√ºr alle neuen Java 8-APIs bleibt ein gro√ües Problem im Android-√ñkosystem.  In der Tat ist es unwahrscheinlich, dass jeder von uns die 26-min√ºtige API in seinem Projekt festlegen kann.  Bibliotheken, die sowohl Android als auch JVM unterst√ºtzen, k√∂nnen es sich nicht leisten, die vor 5 Jahren eingef√ºhrte API zu verwenden! <br><br>  Auch wenn die Java 8-Unterst√ºtzung jetzt Teil von D8 ist, sollte jeder Entwickler die Quell- und Zielkompatibilit√§t in Java 8 explizit angeben. Wenn Sie Ihre eigenen Bibliotheken schreiben, k√∂nnen Sie diesen Trend verst√§rken, indem Sie Bibliotheken mit Java 8-Bytecode auslegen (Auch wenn Sie keine neuen Sprachfunktionen verwenden). <br><br>  An D8 wird viel gearbeitet, so dass es den Anschein hat, als ob in Zukunft alles in Ordnung sein wird, wenn Sprachfunktionen unterst√ºtzt werden.  Selbst wenn Sie nur auf Kotlin schreiben, ist es sehr wichtig, das Android-Entwicklungsteam zu zwingen, alle neuen Versionen von Java zu unterst√ºtzen, Bytecode und neue APIs zu verbessern. <br><br>  Dieser Beitrag ist eine schriftliche Version meines Vortrags <a href="https://jakewharton.com/digging-into-d8-and-r8/">Digging in D8 und R8</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de478692/">https://habr.com/ru/post/de478692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de478672/index.html">AI Testing und Startup: Interview mit Adam Carmi (Applitools)</a></li>
<li><a href="../de478680/index.html">Warum und vor allem, wohin gehen die Leute von der IT?</a></li>
<li><a href="../de478684/index.html">Einf√ºhrung in die SSD. Teil 2. Schnittstelle</a></li>
<li><a href="../de478688/index.html">Wie es war, 2019 Data Science zu studieren</a></li>
<li><a href="../de478690/index.html">Dynamische Assemblierung und Bereitstellung von Docker-Images mit werf anhand der Beispielsite der versionierten Dokumentation</a></li>
<li><a href="../de478694/index.html">Da empfehlen wir die neuesten Kataloge im ivi Online-Kino (+ Python-Code)</a></li>
<li><a href="../de478696/index.html">Wie ich Urban Tech 2019 besuchte. Veranstaltungsbericht</a></li>
<li><a href="../de478698/index.html">In 15 Minuten erstellen wir einen interaktiven Gel√§ndeplan</a></li>
<li><a href="../de478702/index.html">Metrische Verarbeitungstricks in Kapacitor</a></li>
<li><a href="../de478706/index.html">Hochlast-Architekt. Neuer Kurs von OTUS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>