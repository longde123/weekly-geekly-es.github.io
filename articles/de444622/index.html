<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐡 🤰🏼 👵🏿 R tidyr-Paket und seine neuen Funktionen pivot_longer und pivot_wider 🛏️ 👩🏿‍🤝‍👨🏽 🙌🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das tidyr- Paket ist Teil des Kerns einer der beliebtesten Bibliotheken in der R-Sprache - tidyverse . 
 Der Hauptzweck des Pakets besteht darin, die ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>R tidyr-Paket und seine neuen Funktionen pivot_longer und pivot_wider</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444622/"><p>  Das <strong>tidyr-</strong> Paket ist Teil des Kerns einer der beliebtesten Bibliotheken in der R-Sprache - <strong>tidyverse</strong> . <br>  Der Hauptzweck des Pakets besteht darin, die Daten in ein ordentliches Erscheinungsbild zu bringen. </p><br><p>  Auf Habré gibt es bereits eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Publikation</a> zu diesem Paket, die jedoch aus dem Jahr 2015 stammt.  Und ich möchte Ihnen über die wichtigsten Änderungen berichten, die der Autor Hadley Wickham vor einigen Tagen angekündigt hat. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/21a/cf9/6f5/21acf96f56c9b005b125708f5b122a2b.png" alt="Bild"><br><blockquote> <b>SJK</b> : <b>Werden die Funktionen</b> versammeln () und verbreiten () nicht mehr unterstützt? <br><br>  <b>Hadley Wickham</b> : Bis zu einem gewissen Grad.  Wir werden die Verwendung dieser Funktionen nicht mehr empfehlen und Fehler in ihnen korrigieren, sie werden jedoch im aktuellen Status weiterhin im Paket vorhanden sein. </blockquote><a name="habracut"></a><br><h2 id="soderzhanie">  Inhalt </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TidyData-Konzept</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Hauptfunktionen des tidyr-Pakets</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Neues Konzept zum Konvertieren von Daten von einem Breitformat in ein Langformat und umgekehrt</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Installation der aktuellsten Version von tidyr 0.8.3.9000</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wechseln Sie zu neuen Funktionen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein einfaches Beispiel für die Konvertierung von Daten von einem Breitformat in ein Langformat</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Technische Daten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Angabe mit mehreren Werten (.value)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Konvertieren von Datumsrahmen von lang nach breit</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das einfachste Beispiel für das Umwandeln einer Tabelle in ein breites Format</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Generieren eines Spaltennamens aus mehreren Quellvariablen</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einige fortgeschrittene Beispiele für die Arbeit mit dem neuen Tidyr-Konzept</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bringen Sie Daten anhand des US-amerikanischen Datensatzes für Einnahmen- und Mietzählungen zu einem ordentlichen Erscheinungsbild</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weltbank</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kontaktliste</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fazit</a> </li></ul><br><h2 id="koncepciya-tidydata">  TidyData-Konzept </h2><br><p>  Der Zweck von <strong>tidyr</strong> ist es, Ihnen zu helfen, die Daten zu einem sogenannten ordentlichen Erscheinungsbild zu bringen.  Genaue Daten sind Daten, bei denen: </p><br><ul><li>  Jede Variable befindet sich in einer Spalte. </li><li>  Jede Beobachtung ist eine Linie. </li><li>  Jeder Wert ist eine Zelle. </li></ul><br><p>  Die Daten, die für aufgeräumte Daten bereitgestellt werden, sind während der Analyse viel einfacher und bequemer zu bearbeiten. </p><br><h2 id="osnovnye-funkcii-vhodyaschie-v-paket-tidyr">  Die Hauptfunktionen des tidyr-Pakets </h2><br><p>  tidyr enthält eine Reihe von Funktionen zum Transformieren von Tabellen: </p><br><ul><li> <code>fill()</code> - Füllen Sie die fehlenden Werte in der Spalte mit den vorherigen Werten aus. </li><li>  <code>separate()</code> - teilt ein Feld durch ein Trennzeichen in mehrere auf; </li><li>  <code>unite()</code> - führt die Operation des Kombinierens mehrerer Felder zu einem aus, der Umkehrung der Funktion <code>separate()</code> ; </li><li>  <code>pivot_longer()</code> - eine Funktion, die Daten von einem breiten Format in ein langes konvertiert; </li><li>  <code>pivot_wider()</code> - eine Funktion, die Daten von einem langen Format in ein breites konvertiert.  Die Operation ist das Gegenteil von der <code>pivot_longer()</code> . </li><li>  <code>gather()</code> <strong>veraltet</strong> - eine Funktion, die Daten von einem breiten Format in ein langes konvertiert; </li><li>  <code>spread()</code> <strong>veraltet</strong> - eine Funktion, die Daten von einem langen Format in ein breites konvertiert.  Die Operation ist das Gegenteil von der, die <code>gather()</code> Funktion <code>gather()</code> ausführt. </li></ul><br><h2 id="novaya-koncepciya-preobrazovaniya-dannyh-iz-shirokogo-formata-v-dlinnyy-i-naoborot">  Neues Konzept zur Konvertierung von Daten vom Breitformat in das Langformat und umgekehrt </h2><br><p>  Bisher <code>spread()</code> für diese Art der Transformation die Funktionen <code>gather()</code> und <code>spread()</code> verwendet.  Im Laufe der Jahre, in denen diese Funktionen existierten, stellte sich heraus, dass für die meisten Benutzer, einschließlich des Autors des Pakets, die Namen dieser Funktionen und ihre Argumente nicht ganz offensichtlich waren und es schwierig war, sie zu finden und zu verstehen, welche dieser Funktionen den Datumsrahmen von weit nach lang bringt Format und umgekehrt. </p><br><p>  In diesem Zusammenhang wurden <strong>tidyr</strong> zwei neue wichtige Funktionen hinzugefügt, mit denen <strong>Datumsrahmen</strong> transformiert werden sollen. </p><br><p>  Die neuen Funktionen <code>pivot_longer()</code> und <code>pivot_wider()</code> wurden von einigen Funktionen des von John Mount und Nina Zumel erstellten <strong>cdata-</strong> Pakets inspiriert. </p><br><h3 id="ustanovka-naibolee-aktualnoy-versii-tidyr-0839000">  Installation der aktuellsten Version von tidyr 0.8.3.9000 </h3><br><p>  Verwenden Sie den folgenden Code, um die neue, aktuellste Version des <strong>Pakets tidyr 0.8.3.9000 zu installieren</strong> , in der neue Funktionen verfügbar sind. </p><br><p> <code>devtools::install_github("tidyverse/tidyr")</code> </p> <br><p>  Zum Zeitpunkt des Schreibens sind diese Funktionen nur in der Entwicklungsversion des Pakets auf GitHub verfügbar. </p><br><h3 id="perehod-na-novye-funkcii">  Wechseln Sie zu neuen Funktionen </h3><br><p>  Tatsächlich ist es nicht schwierig, alte Skripte zu übertragen, um mit neuen Funktionen zu arbeiten. Zum besseren Verständnis werde ich ein Beispiel aus der Dokumentation alter Funktionen nehmen und zeigen, wie dieselben Operationen mit den neuen <code>pivot_*()</code> werden. </p><br><p>  Konvertieren Sie ein breites in ein langes Format. </p><br><div class="spoiler">  <b class="spoiler_title">Beispielcode aus der Dokumentation der Erfassungsfunktion</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"># example library(dplyr) stocks &lt;- data.frame( time = as.Date('2009-01-01') + 0:9, X = rnorm(10, 0, 1), Y = rnorm(10, 0, 2), Z = rnorm(10, 0, 4) ) # old stocks_gather &lt;- stocks %&gt;% gather(key = stock, value = price, -time) # new stocks_long &lt;- stocks %&gt;% pivot_longer(cols = -time, names_to = "stock", values_to = "price")</code> </pre></div></div><br><p>  Konvertieren eines langen Formats in ein breites Format. </p><br><div class="spoiler">  <b class="spoiler_title">Beispielcode aus der Dokumentation der Spread-Funktion</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"># old stocks_spread &lt;- stocks_gather %&gt;% spread(key = stock, value = price) # new stock_wide &lt;- stocks_long %&gt;% pivot_wider(names_from = "stock", values_from = "price")</code> </pre></div></div><br><p>  Weil  In den obigen Beispielen für die Arbeit mit <code>pivot_longer()</code> und <code>pivot_wider()</code> sind in den Quellen der Quellentabelle keine Spalten in den <em>Argumenten</em> <em>names_to</em> und <em>values_to aufgeführt.</em> Ihre Namen müssen in Anführungszeichen angegeben werden. </p><br><p>  Die Tabelle, mit deren Hilfe Sie am einfachsten herausfinden, wie Sie mit dem neuen <strong>Tidyr-</strong> Konzept arbeiten können. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/127/fc7/70a/127fc770a8175c98168864954e498199.png" alt="Bild"></p><br><h2 id="primechanie-ot-avtora">  Anmerkung des Autors </h2><br><blockquote>  Der gesamte folgende Text ist anpassungsfähig, ich würde sogar eine kostenlose Übersetzung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vignette</a> von der offiziellen Website der Tidyverse-Bibliothek sagen. </blockquote><br><h2 id="prostoy-primer-preobrazovaniya-dannyh-iz-shirokogo-formata-v-dlinnyy">  Ein einfaches Beispiel für die Konvertierung von Daten von einem Breitformat in ein Langformat </h2><br><p>  <code>pivot_longer ()</code> - verlängert Datensätze, indem die Anzahl der Spalten verringert und die Anzahl der Zeilen erhöht wird. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/760/8bb/c5d/7608bbc5d0873682bb5cb8ad3fb9857e.png" alt="Bild"></p><br><p>  Um die im Artikel vorgestellten Beispiele auszuführen, müssen Sie zuerst die erforderlichen Pakete verbinden: </p><br><pre> <code class="plaintext hljs">library(tidyr) library(dplyr) library(readr)</code> </pre> <br><p>  Angenommen, wir haben eine Tabelle mit den Ergebnissen einer Umfrage, in der (unter anderem) Personen nach ihrer Religion und ihrem Jahreseinkommen befragt wurden: </p><br><pre> <code class="plaintext hljs">#&gt; # A tibble: 18 x 11 #&gt; religion `&lt;$10k` `$10-20k` `$20-30k` `$30-40k` `$40-50k` `$50-75k` #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Agnostic 27 34 60 81 76 137 #&gt; 2 Atheist 12 27 37 52 35 70 #&gt; 3 Buddhist 27 21 30 34 33 58 #&gt; 4 Catholic 418 617 732 670 638 1116 #&gt; 5 Don't k… 15 14 15 11 10 35 #&gt; 6 Evangel… 575 869 1064 982 881 1486 #&gt; 7 Hindu 1 9 7 9 11 34 #&gt; 8 Histori… 228 244 236 238 197 223 #&gt; 9 Jehovah… 20 27 24 24 21 30 #&gt; 10 Jewish 19 19 25 25 30 95 #&gt; # … with 8 more rows, and 4 more variables: `$75-100k` &lt;dbl&gt;, #&gt; # `$100-150k` &lt;dbl&gt;, `&gt;150k` &lt;dbl&gt;, `Don't know/refused` &lt;dbl&gt;</code> </pre> <br><p>  Diese Tabelle enthält die Religionsdaten der Befragten in Zeilen, und die Einkommensniveaus sind auf die Spaltennamen verteilt.  Die Anzahl der Befragten aus jeder Kategorie wird in den Zellwerten an der Schnittstelle von Religion und Einkommensniveau gespeichert.  Verwenden <code>pivot_longer()</code> einfach <code>pivot_longer()</code> um die Tabelle in ein ordentliches, korrektes Format zu bringen: </p><br><pre> <code class="plaintext hljs">pew %&gt;% pivot_longer(cols = -religion, names_to = "income", values_to = "count")</code> </pre> <br><pre> <code class="plaintext hljs">pew %&gt;% pivot_longer(cols = -religion, names_to = "income", values_to = "count") #&gt; # A tibble: 180 x 3 #&gt; religion income count #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 Agnostic &lt;$10k 27 #&gt; 2 Agnostic $10-20k 34 #&gt; 3 Agnostic $20-30k 60 #&gt; 4 Agnostic $30-40k 81 #&gt; 5 Agnostic $40-50k 76 #&gt; 6 Agnostic $50-75k 137 #&gt; 7 Agnostic $75-100k 122 #&gt; 8 Agnostic $100-150k 109 #&gt; 9 Agnostic &gt;150k 84 #&gt; 10 Agnostic Don't know/refused 96 #&gt; # … with 170 more rows</code> </pre> <br><p>  Argumente für <code>pivot_longer()</code> </p><br><ul><li>  Das erste Argument, <em>cols</em> , beschreibt, welche Spalten zusammengeführt werden sollen.  In diesem Fall alle Spalten außer <em>Zeit</em> . </li><li>  Das Argument <em>names_to</em> gibt den Namen der Variablen an, die aus den von uns kombinierten Spaltennamen erstellt wird. </li><li>  <em>values_to</em> gibt den Namen der Variablen an, die aus den in den <em>Zellenwerten</em> der <em>verknüpften</em> Spalten gespeicherten Daten erstellt wird. </li></ul><br><h2 id="specifikacii">  Technische Daten </h2><br><p>  Dies ist die neue Funktionalität des <strong>tidyr-</strong> Pakets, die zuvor bei der Arbeit mit veralteten Funktionen nicht verfügbar war. </p><br><p>  Eine Spezifikation ist ein Datenrahmen, dessen jede Zeile einer Spalte in einem neuen Ausgabedatum entspricht, und zwei spezielle Spalten, die beginnen mit: </p><br><ul><li>  <em>.name</em> enthält den ursprünglichen Namen der Spalte. </li><li>  <em>.value</em> enthält den Namen der Spalte, in die die <em>Zellenwerte eingefügt</em> werden. </li></ul><br><p>  Die verbleibenden Spalten der Spezifikation geben an, wie der Name der komprimierbaren Spalten aus <em>.name</em> in der neuen Spalte angezeigt wird. </p><br><p>  Die Spezifikation beschreibt die im Spaltennamen gespeicherten Metadaten mit einer Zeile für jede Spalte und einer Spalte für jede Variable in Kombination mit dem Spaltennamen. Diese Definition erscheint jetzt wahrscheinlich verwirrend, aber nach einigen Beispielen wird alles viel klarer. </p><br><p>  Die Bedeutung der Spezifikation besteht darin, dass Sie neue Metadaten für den konvertierten Datenrahmen abrufen, ändern und festlegen können. </p><br><p>  Die Funktion <code>pivot_longer_spec()</code> wird <code>pivot_longer_spec()</code> , um mit Spezifikationen zu arbeiten, wenn eine Tabelle von einem breiten Format in ein langes konvertiert wird. </p><br><p>  Wie diese Funktion funktioniert, nimmt sie einen beliebigen Datumsrahmen und generiert ihre Metadaten wie oben beschrieben. </p><br><p>  Nehmen wir zum Beispiel das who-Dataset, das mit dem <strong>tidyr-</strong> Paket <strong>geliefert wird</strong> .  Dieser Datensatz enthält Informationen der internationalen Gesundheitsorganisation zum Auftreten von Tuberkulose. </p><br><pre> <code class="plaintext hljs">who #&gt; # A tibble: 7,240 x 60 #&gt; country iso2 iso3 year new_sp_m014 new_sp_m1524 new_sp_m2534 #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 Afghan… AF AFG 1980 NA NA NA #&gt; 2 Afghan… AF AFG 1981 NA NA NA #&gt; 3 Afghan… AF AFG 1982 NA NA NA #&gt; 4 Afghan… AF AFG 1983 NA NA NA #&gt; 5 Afghan… AF AFG 1984 NA NA NA #&gt; 6 Afghan… AF AFG 1985 NA NA NA #&gt; 7 Afghan… AF AFG 1986 NA NA NA #&gt; 8 Afghan… AF AFG 1987 NA NA NA #&gt; 9 Afghan… AF AFG 1988 NA NA NA #&gt; 10 Afghan… AF AFG 1989 NA NA NA #&gt; # … with 7,230 more rows, and 53 more variables</code> </pre> <br><p>  Wir konstruieren seine Spezifikation. </p><br><pre> <code class="plaintext hljs">spec &lt;- who %&gt;% pivot_longer_spec(new_sp_m014:newrel_f65, values_to = "count")</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 56 x 3 #&gt; .name .value name #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 new_sp_m014 count new_sp_m014 #&gt; 2 new_sp_m1524 count new_sp_m1524 #&gt; 3 new_sp_m2534 count new_sp_m2534 #&gt; 4 new_sp_m3544 count new_sp_m3544 #&gt; 5 new_sp_m4554 count new_sp_m4554 #&gt; 6 new_sp_m5564 count new_sp_m5564 #&gt; 7 new_sp_m65 count new_sp_m65 #&gt; 8 new_sp_f014 count new_sp_f014 #&gt; 9 new_sp_f1524 count new_sp_f1524 #&gt; 10 new_sp_f2534 count new_sp_f2534 #&gt; # … with 46 more rows</code> </pre> <br><p>  Die Felder <em>Land</em> , <em>iso2</em> , <em>iso3</em> sind bereits Variablen.  Unsere Aufgabe ist es, die Spalten von <em>new_sp_m014</em> nach <em>newrel_f65</em> zu <em>wechseln</em> . </p><br><p>  Die Namen dieser Spalten enthalten die folgenden Informationen: </p><br><ul><li>  Das Präfix <code>new_</code> gibt an, dass die Spalte Daten zu neuen Fällen von Tuberkulose enthält. Der aktuelle <code>new_</code> enthält nur Informationen zu neuen Krankheiten. Daher hat dieses Präfix im aktuellen Kontext keine Bedeutung. </li><li>  <code>sp</code> / <code>rel</code> / <code>sp</code> / <code>ep</code> beschreibt eine Methode zur Diagnose einer Krankheit. </li><li>  <code>m</code> / <code>f</code> Geschlecht des Patienten. </li><li>  <code>014</code> Altersspanne des Patienten. </li></ul><br><p>  Wir können diese Spalten mithilfe der Funktion <code>extract()</code> mithilfe eines regulären Ausdrucks trennen. </p><br><pre> <code class="plaintext hljs">spec &lt;- spec %&gt;% extract(name, c("diagnosis", "gender", "age"), "new_?(.*)_(.)(.*)")</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 56 x 5 #&gt; .name .value diagnosis gender age #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 new_sp_m014 count sp m 014 #&gt; 2 new_sp_m1524 count sp m 1524 #&gt; 3 new_sp_m2534 count sp m 2534 #&gt; 4 new_sp_m3544 count sp m 3544 #&gt; 5 new_sp_m4554 count sp m 4554 #&gt; 6 new_sp_m5564 count sp m 5564 #&gt; 7 new_sp_m65 count sp m 65 #&gt; 8 new_sp_f014 count sp f 014 #&gt; 9 new_sp_f1524 count sp f 1524 #&gt; 10 new_sp_f2534 count sp f 2534 #&gt; # … with 46 more rows</code> </pre> <br><p>  Beachten Sie, dass die Spalte <em>.name</em> unverändert bleiben muss, da dies unser Index in den Spaltennamen des Quelldatensatzes ist. </p><br><p>  Geschlecht und Alter (Spalten <em>Geschlecht</em> und <em>Alter</em> ) haben feste und bekannte Werte. Daher wird empfohlen, diese Spalten in Faktoren umzuwandeln: </p><br><pre> <code class="plaintext hljs">spec &lt;- spec %&gt;% mutate( gender = factor(gender, levels = c("f", "m")), age = factor(age, levels = unique(age), ordered = TRUE) )</code> </pre> <br><p>  Um die von uns erstellte Spezifikation auf das ursprüngliche Datum des <em>who-</em> Frames anzuwenden, müssen wir das <em>spec-</em> Argument in der Funktion <code>pivot_longer()</code> verwenden. </p><br><p> <code>who %&gt;% pivot_longer(spec = spec)</code> </p> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 405,440 x 8 #&gt; country iso2 iso3 year diagnosis gender age count #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;fct&gt; &lt;ord&gt; &lt;int&gt; #&gt; 1 Afghanistan AF AFG 1980 sp m 014 NA #&gt; 2 Afghanistan AF AFG 1980 sp m 1524 NA #&gt; 3 Afghanistan AF AFG 1980 sp m 2534 NA #&gt; 4 Afghanistan AF AFG 1980 sp m 3544 NA #&gt; 5 Afghanistan AF AFG 1980 sp m 4554 NA #&gt; 6 Afghanistan AF AFG 1980 sp m 5564 NA #&gt; 7 Afghanistan AF AFG 1980 sp m 65 NA #&gt; 8 Afghanistan AF AFG 1980 sp f 014 NA #&gt; 9 Afghanistan AF AFG 1980 sp f 1524 NA #&gt; 10 Afghanistan AF AFG 1980 sp f 2534 NA #&gt; # … with 405,430 more rows</code> </pre> <br><p>  Alles, was wir gerade getan haben, kann wie folgt schematisch dargestellt werden: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/90c/84b/16d/90c84b16d3e4c9860b8ced6e411757b3.png" alt="Bild"></p><br><h2 id="specifikaciya-s-ispolzovaniem-neskolkih-znacheniyvalue">  Angabe mit mehreren Werten (.value) </h2><br><p>  Im obigen Beispiel enthielt die Spalte <em>.value-</em> Spezifikation nur einen Wert. In den meisten Fällen geschieht dies. </p><br><p>  Gelegentlich kann es jedoch vorkommen, dass Sie Daten aus Spalten mit unterschiedlichen Datentypen in den Werten erfassen müssen.  Mit der Funktion "Veraltete <code>spread()</code> wäre dies ziemlich schwierig. </p><br><p>  Das folgende Beispiel stammt aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vignette</a> für das Paket <strong>data.table</strong> . </p><br><p>  Lassen Sie uns einen Trainingsdatenrahmen erstellen. </p><br><pre> <code class="plaintext hljs">family &lt;- tibble::tribble( ~family, ~dob_child1, ~dob_child2, ~gender_child1, ~gender_child2, 1L, "1998-11-26", "2000-01-29", 1L, 2L, 2L, "1996-06-22", NA, 2L, NA, 3L, "2002-07-11", "2004-04-05", 2L, 2L, 4L, "2004-10-10", "2009-08-27", 1L, 1L, 5L, "2000-12-05", "2005-02-28", 2L, 1L, ) family &lt;- family %&gt;% mutate_at(vars(starts_with("dob")), parse_date)</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 5 x 5 #&gt; family dob_child1 dob_child2 gender_child1 gender_child2 #&gt; &lt;int&gt; &lt;date&gt; &lt;date&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 1998-11-26 2000-01-29 1 2 #&gt; 2 2 1996-06-22 NA 2 NA #&gt; 3 3 2002-07-11 2004-04-05 2 2 #&gt; 4 4 2004-10-10 2009-08-27 1 1 #&gt; 5 5 2000-12-05 2005-02-28 2 1</code> </pre> <br><p>  Der erstellte Datumsrahmen in jeder Zeile enthält Daten zu den Kindern einer Familie.  Familien können ein oder zwei Kinder haben.  Für jedes Kind werden Daten zum Geburtsdatum und Geschlecht bereitgestellt, und die Daten für jedes Kind befinden sich in separaten Spalten. Unsere Aufgabe besteht darin, diese Daten in das für die Analyse korrekte Format zu bringen. </p><br><p>  Bitte beachten Sie, dass wir zwei Variablen mit Informationen zu jedem Kind haben: sein Geschlecht und sein Geburtsdatum (Spalten mit dem Präfix <em>dop</em> enthalten das Geburtsdatum, Spalten mit dem Präfix <em>gender</em> enthalten das Geschlecht des Kindes).  Im erwarteten Ergebnis sollten sie in separaten Spalten stehen.  Wir können dies tun, indem wir eine Spezifikation generieren, in der die Spalte <code>.value</code> zwei verschiedene Werte hat. </p><br><pre> <code class="plaintext hljs">spec &lt;- family %&gt;% pivot_longer_spec(-family) %&gt;% separate(col = name, into = c(".value", "child"))%&gt;% mutate(child = parse_number(child))</code> </pre><br><pre> <code class="plaintext hljs">#&gt; # A tibble: 4 x 3 #&gt; .name .value child #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 dob_child1 dob 1 #&gt; 2 dob_child2 dob 2 #&gt; 3 gender_child1 gender 1 #&gt; 4 gender_child2 gender 2</code> </pre> <br><p>  Lassen Sie uns also die Schritte durchgehen, die vom obigen Code ausgeführt werden. </p><br><ul><li>  <code>pivot_longer_spec(-family)</code> - <code>pivot_longer_spec(-family)</code> eine Spezifikation, die alle verfügbaren Spalten mit Ausnahme der Familienspalte komprimiert. </li><li>  <code>separate(col = name, into = c(".value", "child"))</code> - trennt die <em>.name-</em> Spalte, die die Namen der <em>Quellfelder</em> enthält, unterstrichen und <em>fügt</em> die Werte in die <em>.value-</em> und <em>child-</em> Spalten ein. </li><li>  <code>mutate(child = parse_number(child))</code> - Konvertiert die Werte des <code>mutate(child = parse_number(child))</code> Felds vom Text in den numerischen Datentyp. </li></ul><br><p>  Jetzt können wir die empfangene Spezifikation auf den anfänglichen Datenrahmen anwenden und die Tabelle in die gewünschte Form bringen. </p><br><pre> <code class="plaintext hljs">family %&gt;% pivot_longer(spec = spec, na.rm = T)</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 9 x 4 #&gt; family child dob gender #&gt; &lt;int&gt; &lt;dbl&gt; &lt;date&gt; &lt;int&gt; #&gt; 1 1 1 1998-11-26 1 #&gt; 2 1 2 2000-01-29 2 #&gt; 3 2 1 1996-06-22 2 #&gt; 4 3 1 2002-07-11 2 #&gt; 5 3 2 2004-04-05 2 #&gt; 6 4 1 2004-10-10 1 #&gt; 7 4 2 2009-08-27 1 #&gt; 8 5 1 2000-12-05 2 #&gt; 9 5 2 2005-02-28 1</code> </pre> <br><p>  Wir verwenden das Argument <code>na.rm = TRUE</code> , da das aktuelle Datenformular uns zwingt, zusätzliche Zeilen für nicht vorhandene Beobachtungen zu erstellen.  Weil  Familie 2 hat nur ein Kind, <code>na.rm = TRUE</code> stellt sicher, dass Familie 2 eine Zeile in der Ausgabe hat. </p><br><h2 id="preobrazovanie-data-freymov-iz-dlinnogo-formata-k-shirokomu">  Konvertieren von Datumsrahmen von lang nach breit </h2><br><p>  <code>pivot_wider()</code> - ist die inverse Transformation, und umgekehrt wird die Anzahl der Spalten im <code>pivot_wider()</code> erhöht, indem die Anzahl der Zeilen verringert wird. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b0d/a51/f47/b0da51f47f968a49e485989eba044914.png" alt="Bild"></p><br><p>  Diese Art der Transformation wird selten verwendet, um Daten in ein ordentliches Erscheinungsbild zu bringen. Diese Technik kann jedoch nützlich sein, um Pivot-Tabellen zu erstellen, die in Präsentationen verwendet werden, oder um sie in andere Tools zu integrieren. </p><br><p>  Tatsächlich sind die Funktionen <code>pivot_longer()</code> und <code>pivot_wider()</code> symmetrisch und führen entgegengesetzte Aktionen aus, d. H.: <code>df %&gt;% pivot_longer(spec = spec) %&gt;% pivot_wider(spec = spec)</code> und <code>df %&gt;% pivot_wider(spec = spec) %&gt;% pivot_longer(spec = spec)</code> gibt den ursprünglichen df zurück. </p><br><h3 id="prosteyshiy-primer-privedeniya-tablicy-k-shirokomu-formatu">  Das einfachste Beispiel für das Umwandeln einer Tabelle in ein breites Format </h3><br><p>  Um die Funktionsweise der Funktion <code>pivot_wider()</code> zu demonstrieren, verwenden wir den <em>Datensatz fish_encounters</em> , in dem Informationen darüber <em>gespeichert sind</em> , wie verschiedene Stationen die Bewegung von Fischen entlang des Flusses aufzeichnen. </p><br><pre> <code class="plaintext hljs">#&gt; # A tibble: 114 x 3 #&gt; fish station seen #&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; #&gt; 1 4842 Release 1 #&gt; 2 4842 I80_1 1 #&gt; 3 4842 Lisbon 1 #&gt; 4 4842 Rstr 1 #&gt; 5 4842 Base_TD 1 #&gt; 6 4842 BCE 1 #&gt; 7 4842 BCW 1 #&gt; 8 4842 BCE2 1 #&gt; 9 4842 BCW2 1 #&gt; 10 4842 MAE 1 #&gt; # … with 104 more rows</code> </pre> <br><p>  In den meisten Fällen ist diese Tabelle informativer und bequemer zu verwenden, wenn Sie Informationen für jede Station in einer separaten Spalte angeben. </p><br><p> <code>fish_encounters %&gt;% pivot_wider(names_from = station, values_from = seen)</code> </p> <br><pre> <code class="plaintext hljs">fish_encounters %&gt;% pivot_wider(names_from = station, values_from = seen) #&gt; # A tibble: 19 x 12 #&gt; fish Release I80_1 Lisbon Rstr Base_TD BCE BCW BCE2 BCW2 MAE #&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 4842 1 1 1 1 1 1 1 1 1 1 #&gt; 2 4843 1 1 1 1 1 1 1 1 1 1 #&gt; 3 4844 1 1 1 1 1 1 1 1 1 1 #&gt; 4 4845 1 1 1 1 1 NA NA NA NA NA #&gt; 5 4847 1 1 1 NA NA NA NA NA NA NA #&gt; 6 4848 1 1 1 1 NA NA NA NA NA NA #&gt; 7 4849 1 1 NA NA NA NA NA NA NA NA #&gt; 8 4850 1 1 NA 1 1 1 1 NA NA NA #&gt; 9 4851 1 1 NA NA NA NA NA NA NA NA #&gt; 10 4854 1 1 NA NA NA NA NA NA NA NA #&gt; # … with 9 more rows, and 1 more variable: MAW &lt;int&gt;</code> </pre> <br><p>  Dieser Datensatz zeichnet Informationen nur auf, wenn der Fisch von der Station erkannt wurde, d. H.  Wenn ein Fisch nicht von einer Station repariert wurde, sind diese Daten nicht in der Tabelle enthalten.  Dies bedeutet, dass die Ausgabe von NA gefüllt wird. </p><br><p>  In diesem Fall wissen wir jedoch, dass das Fehlen eines Datensatzes bedeutet, dass der Fisch nicht bemerkt wurde. <em>Daher</em> können wir das Argument <em>values_fill</em> in der Funktion <code>pivot_wider()</code> verwenden und diese fehlenden Werte mit Nullen füllen: </p><br><pre> <code class="plaintext hljs">fish_encounters %&gt;% pivot_wider( names_from = station, values_from = seen, values_fill = list(seen = 0) )</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 19 x 12 #&gt; fish Release I80_1 Lisbon Rstr Base_TD BCE BCW BCE2 BCW2 MAE #&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 4842 1 1 1 1 1 1 1 1 1 1 #&gt; 2 4843 1 1 1 1 1 1 1 1 1 1 #&gt; 3 4844 1 1 1 1 1 1 1 1 1 1 #&gt; 4 4845 1 1 1 1 1 0 0 0 0 0 #&gt; 5 4847 1 1 1 0 0 0 0 0 0 0 #&gt; 6 4848 1 1 1 1 0 0 0 0 0 0 #&gt; 7 4849 1 1 0 0 0 0 0 0 0 0 #&gt; 8 4850 1 1 0 1 1 1 1 0 0 0 #&gt; 9 4851 1 1 0 0 0 0 0 0 0 0 #&gt; 10 4854 1 1 0 0 0 0 0 0 0 0 #&gt; # … with 9 more rows, and 1 more variable: MAW &lt;int&gt;</code> </pre> <br><h3 id="generaciya-imeni-stolbca-iz-neskolkih-ishodnyh-peremennyh">  Generieren eines Spaltennamens aus mehreren Quellvariablen </h3><br><p>  Stellen Sie sich vor, wir haben eine Tabelle mit einer Kombination aus Produkt, Land und Jahr.  Um ein Testframe-Datum zu generieren, können Sie den folgenden Code ausführen: </p><br><pre> <code class="plaintext hljs">df &lt;- expand_grid( product = c("A", "B"), country = c("AI", "EI"), year = 2000:2014 ) %&gt;% filter((product == "A" &amp; country == "AI") | product == "B") %&gt;% mutate(value = rnorm(nrow(.)))</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 45 x 4 #&gt; product country year value #&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 A AI 2000 -2.05 #&gt; 2 A AI 2001 -0.676 #&gt; 3 A AI 2002 1.60 #&gt; 4 A AI 2003 -0.353 #&gt; 5 A AI 2004 -0.00530 #&gt; 6 A AI 2005 0.442 #&gt; 7 A AI 2006 -0.610 #&gt; 8 A AI 2007 -2.77 #&gt; 9 A AI 2008 0.899 #&gt; 10 A AI 2009 -0.106 #&gt; # … with 35 more rows</code> </pre> <br><p>  Unsere Aufgabe ist es, den Datumsrahmen so zu erweitern, dass eine Spalte Daten für jede Kombination aus Produkt und Land enthält.  <em>Übergeben</em> Sie dazu einfach den Vektor mit den Namen der zu verbindenden Felder in das Argument <em>names_from</em> . </p><br><pre> <code class="plaintext hljs">df %&gt;% pivot_wider(names_from = c(product, country), values_from = "value")</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 15 x 4 #&gt; year A_AI B_AI B_EI #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2000 -2.05 0.607 1.20 #&gt; 2 2001 -0.676 1.65 -0.114 #&gt; 3 2002 1.60 -0.0245 0.501 #&gt; 4 2003 -0.353 1.30 -0.459 #&gt; 5 2004 -0.00530 0.921 -0.0589 #&gt; 6 2005 0.442 -1.55 0.594 #&gt; 7 2006 -0.610 0.380 -1.28 #&gt; 8 2007 -2.77 0.830 0.637 #&gt; 9 2008 0.899 0.0175 -1.30 #&gt; 10 2009 -0.106 -0.195 1.03 #&gt; # … with 5 more rows</code> </pre> <br><p>  Sie können auch Spezifikationen auf die Funktion <code>pivot_wider()</code> anwenden.  Bei <code>pivot_wider()</code> an <code>pivot_wider()</code> Spezifikation jedoch das Gegenteil von <code>pivot_longer()</code> : Die in <em>.name</em> angegebenen Spalten werden mit Werten aus <em>.value</em> und anderen Spalten erstellt. </p><br><p>  Für diesen Datensatz können Sie eine Benutzerspezifikation generieren, wenn jede mögliche Kombination aus Land und Produkt eine eigene Spalte haben soll und nicht nur diejenigen, die in den Daten vorhanden sind: </p><br><pre> <code class="plaintext hljs">spec &lt;- df %&gt;% expand(product, country, .value = "value") %&gt;% unite(".name", product, country, remove = FALSE)</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 4 x 4 #&gt; .name product country .value #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 A_AI A AI value #&gt; 2 A_EI A EI value #&gt; 3 B_AI B AI value #&gt; 4 B_EI B EI value</code> </pre> <br><pre> <code class="plaintext hljs">df %&gt;% pivot_wider(spec = spec) %&gt;% head()</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 6 x 5 #&gt; year A_AI A_EI B_AI B_EI #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2000 -2.05 NA 0.607 1.20 #&gt; 2 2001 -0.676 NA 1.65 -0.114 #&gt; 3 2002 1.60 NA -0.0245 0.501 #&gt; 4 2003 -0.353 NA 1.30 -0.459 #&gt; 5 2004 -0.00530 NA 0.921 -0.0589 #&gt; 6 2005 0.442 NA -1.55 0.594</code> </pre> <br><h2 id="neskolko-prodvinutyh-primerov-raboty-s-novoy-koncepciey-tidyr">  Einige fortgeschrittene Beispiele für die Arbeit mit dem neuen Tidyr-Konzept </h2><br><h3 id="privedenie-dannyh-k-akkuratnomu-vidu-na-primere-nabora-dannyh-o-perepisi-dohoda-i-arendnoy-platy-v-ssha">  Bringen Sie Daten anhand des US-amerikanischen Datensatzes für Einnahmen und Mietzählungen zu einem ordentlichen Erscheinungsbild </h3><br><p>  Der <em>Datensatz us_rent_income</em> enthält Informationen zum durchschnittlichen Einkommen und zur durchschnittlichen Miete für jeden Staat in den USA für 2017 (der Datensatz ist im <strong>Tidycensus-</strong> Paket verfügbar). </p><br><pre> <code class="plaintext hljs">us_rent_income #&gt; # A tibble: 104 x 5 #&gt; GEOID NAME variable estimate moe #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 01 Alabama income 24476 136 #&gt; 2 01 Alabama rent 747 3 #&gt; 3 02 Alaska income 32940 508 #&gt; 4 02 Alaska rent 1200 13 #&gt; 5 04 Arizona income 27517 148 #&gt; 6 04 Arizona rent 972 4 #&gt; 7 05 Arkansas income 23789 165 #&gt; 8 05 Arkansas rent 709 5 #&gt; 9 06 California income 29454 109 #&gt; 10 06 California rent 1358 3 #&gt; # … with 94 more rows</code> </pre> <br><p>  Es ist äußerst unpraktisch, mit ihnen in der Form zu arbeiten, in der die Daten im <em>Datensatz</em> us_rent_income gespeichert sind. Daher möchten wir einen Datensatz mit den folgenden Spalten erstellen: <em>rent</em> , <em>rent_moe</em> , <em>come</em> , <em>einkommen_moe</em> .  Es gibt viele Möglichkeiten, diese Spezifikation zu erstellen, aber die Hauptsache ist, dass wir jede Kombination aus Variablenwerten und <em>Schätzung / Moe</em> generieren und dann den Spaltennamen generieren müssen. </p><br><pre> <code class="plaintext hljs"> spec &lt;- us_rent_income %&gt;% expand(variable, .value = c("estimate", "moe")) %&gt;% mutate( .name = paste0(variable, ifelse(.value == "moe", "_moe", "")) )</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 4 x 3 #&gt; variable .value .name #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 income estimate income #&gt; 2 income moe income_moe #&gt; 3 rent estimate rent #&gt; 4 rent moe rent_moe</code> </pre> <br><p>  Wenn Sie diese Spezifikation für <code>pivot_wider()</code> , erhalten Sie das <code>pivot_wider()</code> Ergebnis: </p><br><p> <code>us_rent_income %&gt;% pivot_wider(spec = spec)</code> </p> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 52 x 6 #&gt; GEOID NAME income income_moe rent rent_moe #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 01 Alabama 24476 136 747 3 #&gt; 2 02 Alaska 32940 508 1200 13 #&gt; 3 04 Arizona 27517 148 972 4 #&gt; 4 05 Arkansas 23789 165 709 5 #&gt; 5 06 California 29454 109 1358 3 #&gt; 6 08 Colorado 32401 109 1125 5 #&gt; 7 09 Connecticut 35326 195 1123 5 #&gt; 8 10 Delaware 31560 247 1076 10 #&gt; 9 11 District of Columbia 43198 681 1424 17 #&gt; 10 12 Florida 25952 70 1077 3 #&gt; # … with 42 more rows</code> </pre> <br><h3 id="vsemirnyy-bank">  Weltbank </h3><br><p>  Manchmal sind mehrere Schritte erforderlich, um den Datensatz in die richtige Form zu bringen. <br>  Der <em>Datensatz</em> world_bank_pop enthält Daten der Weltbank zur Bevölkerung jedes Landes von 2000 bis 2018. </p><br><pre> <code class="plaintext hljs">#&gt; # A tibble: 1,056 x 20 #&gt; country indicator `2000` `2001` `2002` `2003` `2004` `2005` `2006` #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 ABW SP.URB.T… 4.24e4 4.30e4 4.37e4 4.42e4 4.47e+4 4.49e+4 4.49e+4 #&gt; 2 ABW SP.URB.G… 1.18e0 1.41e0 1.43e0 1.31e0 9.51e-1 4.91e-1 -1.78e-2 #&gt; 3 ABW SP.POP.T… 9.09e4 9.29e4 9.50e4 9.70e4 9.87e+4 1.00e+5 1.01e+5 #&gt; 4 ABW SP.POP.G… 2.06e0 2.23e0 2.23e0 2.11e0 1.76e+0 1.30e+0 7.98e-1 #&gt; 5 AFG SP.URB.T… 4.44e6 4.65e6 4.89e6 5.16e6 5.43e+6 5.69e+6 5.93e+6 #&gt; 6 AFG SP.URB.G… 3.91e0 4.66e0 5.13e0 5.23e0 5.12e+0 4.77e+0 4.12e+0 #&gt; 7 AFG SP.POP.T… 2.01e7 2.10e7 2.20e7 2.31e7 2.41e+7 2.51e+7 2.59e+7 #&gt; 8 AFG SP.POP.G… 3.49e0 4.25e0 4.72e0 4.82e0 4.47e+0 3.87e+0 3.23e+0 #&gt; 9 AGO SP.URB.T… 8.23e6 8.71e6 9.22e6 9.77e6 1.03e+7 1.09e+7 1.15e+7 #&gt; 10 AGO SP.URB.G… 5.44e0 5.59e0 5.70e0 5.76e0 5.75e+0 5.69e+0 4.92e+0 #&gt; # … with 1,046 more rows, and 11 more variables: `2007` &lt;dbl&gt;, #&gt; # `2008` &lt;dbl&gt;, `2009` &lt;dbl&gt;, `2010` &lt;dbl&gt;, `2011` &lt;dbl&gt;, `2012` &lt;dbl&gt;, #&gt; # `2013` &lt;dbl&gt;, `2014` &lt;dbl&gt;, `2015` &lt;dbl&gt;, `2016` &lt;dbl&gt;, `2017` &lt;dbl&gt;</code> </pre> <br><p>  Unser Ziel ist es, einen übersichtlichen Datensatz zu erstellen, in dem sich jede Variable in einer separaten Spalte befindet.  Es ist noch nicht klar, welche Schritte notwendig sind, aber wir beginnen mit dem offensichtlichsten Problem: Das Jahr ist auf mehrere Spalten verteilt. </p><br><p>  Um dies zu beheben, müssen Sie die Funktion <code>pivot_longer()</code> verwenden. </p><br><pre> <code class="plaintext hljs">pop2 &lt;- world_bank_pop %&gt;% pivot_longer(`2000`:`2017`, names_to = "year")</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 19,008 x 4 #&gt; country indicator year value #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 ABW SP.URB.TOTL 2000 42444 #&gt; 2 ABW SP.URB.TOTL 2001 43048 #&gt; 3 ABW SP.URB.TOTL 2002 43670 #&gt; 4 ABW SP.URB.TOTL 2003 44246 #&gt; 5 ABW SP.URB.TOTL 2004 44669 #&gt; 6 ABW SP.URB.TOTL 2005 44889 #&gt; 7 ABW SP.URB.TOTL 2006 44881 #&gt; 8 ABW SP.URB.TOTL 2007 44686 #&gt; 9 ABW SP.URB.TOTL 2008 44375 #&gt; 10 ABW SP.URB.TOTL 2009 44052 #&gt; # … with 18,998 more rows</code> </pre> <br><p>   —   indicator. <br> <code>pop2 %&gt;% count(indicator)</code> </p> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 4 x 2 #&gt; indicator n #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 SP.POP.GROW 4752 #&gt; 2 SP.POP.TOTL 4752 #&gt; 3 SP.URB.GROW 4752 #&gt; 4 SP.URB.TOTL 4752</code> </pre> <br><p>  SP.POP.GROW —  , SP.POP.TOTL —   ,  SP.URB. *  ,     .       : area —  (total  urban)      (population  growth): </p><br><pre> <code class="plaintext hljs">pop3 &lt;- pop2 %&gt;% separate(indicator, c(NA, "area", "variable"))</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 19,008 x 5 #&gt; country area variable year value #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 ABW URB TOTL 2000 42444 #&gt; 2 ABW URB TOTL 2001 43048 #&gt; 3 ABW URB TOTL 2002 43670 #&gt; 4 ABW URB TOTL 2003 44246 #&gt; 5 ABW URB TOTL 2004 44669 #&gt; 6 ABW URB TOTL 2005 44889 #&gt; 7 ABW URB TOTL 2006 44881 #&gt; 8 ABW URB TOTL 2007 44686 #&gt; 9 ABW URB TOTL 2008 44375 #&gt; 10 ABW URB TOTL 2009 44052 #&gt; # … with 18,998 more rows</code> </pre> <br><p>       variable   : </p><br><pre> <code class="plaintext hljs">pop3 %&gt;% pivot_wider(names_from = variable, values_from = value)</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 9,504 x 5 #&gt; country area year TOTL GROW #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 ABW URB 2000 42444 1.18 #&gt; 2 ABW URB 2001 43048 1.41 #&gt; 3 ABW URB 2002 43670 1.43 #&gt; 4 ABW URB 2003 44246 1.31 #&gt; 5 ABW URB 2004 44669 0.951 #&gt; 6 ABW URB 2005 44889 0.491 #&gt; 7 ABW URB 2006 44881 -0.0178 #&gt; 8 ABW URB 2007 44686 -0.435 #&gt; 9 ABW URB 2008 44375 -0.698 #&gt; 10 ABW URB 2009 44052 -0.731 #&gt; # … with 9,494 more rows</code> </pre> <br><h3 id="spisok-kontaktov">   </h3><br><p>  , ,      ,       -: </p><br><pre> <code class="plaintext hljs">contacts &lt;- tribble( ~field, ~value, "name", "Jiena McLellan", "company", "Toyota", "name", "John Smith", "company", "google", "email", "john@google.com", "name", "Huxley Ratcliffe" )</code> </pre> <br><p>        ,    ,   ,     .    , ,          ("name"),      ,       ,    field   “name”: </p><br><pre> <code class="plaintext hljs">contacts &lt;- contacts %&gt;% mutate( person_id = cumsum(field == "name") ) contacts</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 6 x 3 #&gt; field value person_id #&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 name Jiena McLellan 1 #&gt; 2 company Toyota 1 #&gt; 3 name John Smith 2 #&gt; 4 company google 2 #&gt; 5 email john@google.com 2 #&gt; 6 name Huxley Ratcliffe 3</code> </pre> <br><p> ,         ,        : </p><br><pre> <code class="plaintext hljs">contacts %&gt;% pivot_wider(names_from = field, values_from = value)</code> </pre> <br><pre> <code class="plaintext hljs">#&gt; # A tibble: 3 x 4 #&gt; person_id name company email #&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1 Jiena McLellan Toyota &lt;NA&gt; #&gt; 2 2 John Smith google john@google.com #&gt; 3 3 Huxley Ratcliffe &lt;NA&gt; &lt;NA&gt;</code> </pre> <br><h2 id="zaklyuchenie">  Fazit </h2><br><p>   ,    <strong>tidyr</strong>    ,        <code>spread()</code>  <code>gather()</code> .        <code>pivot_longer()</code>  <code>pivot_wider()</code> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444622/">https://habr.com/ru/post/de444622/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444610/index.html">Statistik und Überwachung von PHP-Skripten in Echtzeit. ClickHouse und Grafana helfen Pinba</a></li>
<li><a href="../de444612/index.html">Makroschaden für C ++ - Code</a></li>
<li><a href="../de444614/index.html">Die ganze Geschichte von Linux. Teil II: Unternehmen Höhen und Tiefen</a></li>
<li><a href="../de444616/index.html">Erstellen Sie Ihren eigenen Android Voice Recorder mit Kotlin</a></li>
<li><a href="../de444620/index.html">Verwenden von Linux-Kernel-Sequenzdateien</a></li>
<li><a href="../de444624/index.html">Elektroautos brennen und baden</a></li>
<li><a href="../de444630/index.html">Info Desk: Globale Internetinitiativen</a></li>
<li><a href="../de444634/index.html">Epic Games gibt Entwicklern 100 Millionen US-Dollar</a></li>
<li><a href="../de444636/index.html">Warum kann ich nicht für das Geld wachsen?</a></li>
<li><a href="../de444638/index.html">Qualitätssicherung beim CodeFest. Automatisierung, Management, Infrastruktur, Verkauf von Knödeln im Laden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>