<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçüéì ü§∑üèª üÜé Mesure du temps avec une pr√©cision en nanosecondes üë®üèº‚Äç‚úàÔ∏è üíÇüèº üë¶üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a quelques mois, un moment historique est venu pour moi. Les outils standard du syst√®me d'exploitation pour mesurer le temps ont cess√© de me suff...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mesure du temps avec une pr√©cision en nanosecondes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425237/"><img src="https://habrastorage.org/webt/zx/xf/se/zxxfse_sd5ma4wwfy0u6rilcai8.jpeg" alt="image"><br><br>  Il y a quelques mois, un moment historique est venu pour moi.  Les outils standard du syst√®me d'exploitation pour mesurer le temps ont cess√© de me suffire.  Il a fallu du temps pour mesurer avec une pr√©cision en nanosecondes et avec des frais g√©n√©raux en nanosecondes. <br><br>  J'ai d√©cid√© d'√©crire une biblioth√®que qui r√©soudrait ce probl√®me.  √Ä premi√®re vue, il semblait qu'il n'y avait rien de sp√©cial √† faire.  Mais apr√®s un examen plus approfondi, comme toujours, il s'est av√©r√© qu'il y avait de nombreux probl√®mes int√©ressants √† r√©gler.  Dans cet article, je vais parler des probl√®mes et comment ils ont √©t√© r√©solus. <br><br>  √âtant donn√© que vous pouvez mesurer diff√©rents types de temps sur un ordinateur, je vais imm√©diatement pr√©ciser que nous parlerons ici de ¬´temps par chronom√®tre¬ª.  Ou l'heure de l'horloge murale.  C‚Äôest le temps r√©el, le temps √©coul√©, etc.  C'est-√†-dire un temps "humain" simple, que nous d√©tectons au d√©but de la t√¢che et arr√™tons √† la fin. <br><a name="habracut"></a><br><h3>  Microseconde - presque pour toujours </h3><br>  Les d√©veloppeurs de syst√®mes haute performance au cours des derni√®res ann√©es se sont habitu√©s √† l'√©chelle de temps en microsecondes.  En microsecondes, vous pouvez lire les donn√©es d'un lecteur NVMe.  En microsecondes, les donn√©es peuvent √™tre envoy√©es sur le r√©seau.  Pas pour tout le monde, bien s√ªr, mais pour le r√©seau InifiniBand - facilement. <br><br>  En m√™me temps, la microseconde avait √©galement une structure.  Une pile d'E / S compl√®te se compose de plusieurs composants logiciels et mat√©riels.  Les retards introduits par certains d'entre eux se situent au niveau inf√©rieur √† la microseconde. <br><br>  Pour mesurer des retards de cette ampleur, la pr√©cision en microsecondes n'est plus suffisante.  Cependant, non seulement la pr√©cision est importante, mais aussi la surcharge de mesure du temps.  L'appel syst√®me Linux clock_gettime () renvoie le temps avec une pr√©cision en nanosecondes.  Sur une machine √† port√©e de main (Intel¬Æ Xeon¬Æ CPU E5-2630 v2 @ 2,60 GHz), cet appel se termine en environ 120 ns.  Tr√®s bonne silhouette.  De plus, clock_gettime () fonctionne de fa√ßon assez pr√©visible.  Cela vous permet de prendre en compte les frais g√©n√©raux de son appel et de prendre des mesures avec une pr√©cision de l'ordre de dizaines de nanosecondes.  Cependant, pr√™tons maintenant attention √† cela.  Pour mesurer l'intervalle de temps, vous devez effectuer deux appels de ce type: au d√©but et √† la fin.  C'est-√†-dire  d√©penser 240 ns.  Si des intervalles de temps dens√©ment espac√©s de l'ordre de 1 √† 10 Œºs sont mesur√©s, dans certains cas, le processus de mesure lui-m√™me d√©formera consid√©rablement le processus observ√©. <br><br>  J'ai commenc√© cette section avec la fa√ßon dont la pile d'E / S s'est acc√©l√©r√©e ces derni√®res ann√©es.  C'est nouveau, mais loin d'√™tre la seule raison de vouloir mesurer le temps rapidement et avec pr√©cision.  Un tel besoin a toujours √©t√©.  Par exemple, il y avait toujours un code que je voulais acc√©l√©rer d'au moins 1 cycle d'horloge du microprocesseur.  Ou un autre exemple, tir√© de l'article original sur la vuln√©rabilit√© sensationnelle Spectre: <br><br><img src="https://habrastorage.org/webt/db/5a/7o/db5a7oldvzrcqfi_ymamg4qzscu.jpeg" alt="image"><br><br>  Ici, les lignes 72 √† 74 mesurent le temps d'ex√©cution d'une seule op√©ration d'acc√®s √† la m√©moire.  Certes, Spectre ne s'int√©resse pas aux nanosecondes.  Le temps peut √™tre mesur√© en ¬´perroquets¬ª.  Nous reviendrons sur les perroquets et les secondes. <br><br><h3>  Compteur d'horodatage </h3><br>  La cl√© d'une mesure rapide et pr√©cise du temps est un compteur √† microprocesseur sp√©cial.  La valeur de ce compteur est g√©n√©ralement stock√©e dans un registre s√©par√© et est g√©n√©ralement - mais pas toujours - accessible depuis l'espace utilisateur.  Sur diff√©rentes architectures, le compteur est appel√© diff√©remment: <br><br><ol><li>  compteur d'horodatage x86 </li><li>  registre de base de temps sur PowerPC </li><li>  compteur de temps d'intervalle sur Itanium </li><li>  etc. </li></ol><br>  Ci-dessous, j'utiliserai toujours le nom de "compteur d'horodatage" ou TSC, bien qu'en fait je garde √† l'esprit un tel compteur, quelle que soit l'architecture. <br><br>  La lecture de la valeur TSC habituellement - mais encore une fois pas toujours - est possible avec une seule instruction.  Voici un exemple pour x86.  √Ä strictement parler, ce n'est pas une instruction d'assembleur pur, mais l'assembleur en ligne GNU: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> eax, edx; __asm__ __volatile__( <span class="hljs-string"><span class="hljs-string">"rdtsc"</span></span> : <span class="hljs-string"><span class="hljs-string">"=a"</span></span> (eax), <span class="hljs-string"><span class="hljs-string">"=d"</span></span> (edx));</code> </pre> <br>  L'instruction rdtsc place deux moiti√©s de 32 bits du registre TSC dans les registres eax et edx.  Parmi ceux-ci, vous pouvez ¬´coller¬ª une seule valeur 64 bits. <br><br>  Encore une fois, je note: ces instructions (et similaires) dans la plupart des cas peuvent √™tre appel√©es directement depuis l'espace utilisateur.  Aucun appel syst√®me.  Frais g√©n√©raux minimaux. <br><br>  Que faut-il faire maintenant pour mesurer le temps? <br><br><ol><li>  Ex√©cutez une telle instruction au d√©but de l'intervalle de temps qui nous int√©resse.  N'oubliez pas la contre-valeur </li><li>  Ex√©cutez une telle instruction √† la fin.  Nous pensons que la valeur du compteur de la premi√®re instruction √† la seconde augmentera.  Sinon, pourquoi est-il n√©cessaire?  Rappelez-vous la deuxi√®me valeur </li><li>  Nous consid√©rons la diff√©rence entre les deux valeurs stock√©es.  C'est notre temps </li></ol><br>  Cela semble simple, mais ... <br><br>  Le temps mesur√© par la proc√©dure d√©crite est exprim√© en ¬´perroquets¬ª.  Ce n'est pas en quelques secondes.  Mais parfois, les perroquets sont exactement ce dont vous avez besoin.  Il y a des situations o√π les valeurs absolues des intervalles de temps ne sont pas importantes, mais comment les diff√©rents intervalles sont li√©s les uns aux autres.  L'exemple Spectre ci-dessus illustre exactement cette situation.  La dur√©e de chaque acc√®s √† la m√©moire individuelle n'a pas d'importance.  Il est seulement important que les appels vers certaines adresses soient ex√©cut√©s beaucoup plus rapidement que vers d'autres (selon que les donn√©es sont stock√©es dans le cache ou dans la m√©moire principale). <br><br>  Mais que faire si ce n'est pas des perroquets, mais des secondes / microsecondes / nanosecondes, etc.?  On peut distinguer ici deux cas fondamentalement diff√©rents: <br><br><ol><li>  Des nanosecondes sont n√©cessaires, mais alors.  Autrement dit, il est permis de faire d'abord toutes les mesures n√©cessaires dans des perroquets et de les stocker quelque part pour un traitement ult√©rieur (par exemple, en m√©moire).  Et seulement une fois les mesures termin√©es, convertir lentement les perroquets collect√©s en secondes </li><li>  Les nanosecondes sont n√©cessaires "√† la vol√©e".  Par exemple, votre processus de mesure a une sorte de ¬´consommateur¬ª que vous ne contr√¥lez pas et qui attend du temps au format ¬´humain¬ª </li></ol><br>  Le premier cas est simple, le second - n√©cessite de l'ing√©niosit√©.  La conversion doit √™tre aussi efficace que possible.  S'il consomme beaucoup de ressources, il peut fausser consid√©rablement le processus de mesure.  Nous parlerons de la conversion efficace ci-dessous.  Nous avons jusqu'ici identifi√© ce probl√®me et passons √† un autre. <br><br>  Les compteurs d'horodatage ne sont pas aussi simples que nous le souhaiterions.  Sur certaines architectures: <br><br><ol><li>  il n'est pas garanti que le TSC soit mis √† jour √† haute fr√©quence.  Si le TSC est mis √† jour, disons, une fois toutes les microsecondes, il ne sera pas possible de corriger les nanosecondes avec lui. </li><li>  la fr√©quence de mise √† jour du TSC peut varier dans le temps </li><li>  sur diff√©rents CPU pr√©sents dans le syst√®me, les TSC peuvent √™tre mis √† jour √† diff√©rentes fr√©quences </li><li>  il peut y avoir un d√©calage entre les TSCs sur les diff√©rents processeurs </li></ol><br>  Voici un exemple illustrant le dernier probl√®me.  Supposons que nous ayons un syst√®me avec deux CPU: CPU1 et CPU2.  Supposons que le TSC sur le premier CPU soit derri√®re le second du nombre de ticks, ce qui √©quivaut √† 5 secondes.  Supposons en outre qu'un flux soit lanc√© dans le syst√®me qui mesure le temps des calculs, ce qu'il fait lui-m√™me.  Pour ce faire, le flux lit d'abord la valeur TSC, puis fait le calcul, puis lit la deuxi√®me valeur TSC.  Si pendant toute sa vie un thread reste sur un seul CPU - sur n'importe quel - alors il n'y a pas de probl√®mes.  Mais que se passe-t-il si le thread a d√©marr√© sur CPU1, a mesur√© la premi√®re valeur TSC l√†-bas, puis au milieu des calculs a √©t√© d√©plac√© par le syst√®me d'exploitation vers CPU2, o√π il a lu la deuxi√®me valeur TSC?  Dans ce cas, les calculs sembleront 5 secondes plus longs qu'ils ne le sont r√©ellement. <br><br>  En raison des probl√®mes r√©pertori√©s ci-dessus, TSC ne peut pas servir de source de temps fiable sur certains syst√®mes.  Cependant, sur d'autres syst√®mes "souffrant" des m√™mes probl√®mes, le TSC peut toujours √™tre utilis√©.  Ceci est rendu possible gr√¢ce √† des caract√©ristiques architecturales sp√©ciales: <br><br><ol><li>  l'√©quipement peut g√©n√©rer une interruption sp√©ciale chaque fois que la fr√©quence de mise √† jour du TSC change.  Dans le m√™me temps, l'√©quipement offre √©galement la possibilit√© de conna√Ætre la fr√©quence actuelle.  Alternativement, le taux de rafra√Æchissement TSC peut √™tre plac√© sous le contr√¥le du syst√®me d'exploitation (voir ¬´Power ISA version 2.06 r√©vision B, livre II, chapitre 5¬ª) </li><li>  le mat√©riel ainsi que la valeur TSC peuvent √©galement fournir l'ID du processeur sur lequel cette valeur est lue (voir les instructions Intel RDTSCP, "Intel 64 and IA-32 Architectures Software Developer's Manual", Volume 2) </li><li>  sur certains syst√®mes, vous pouvez ajuster par programme la valeur TSC pour chaque CPU (voir l'instruction Intel WRMSR et enregistrez IA32_TIME_STAMP_COUNTER, "Intel 64 and IA-32 Architectures Software Developer's Manual", Volume 3) </li></ol><br>  En g√©n√©ral, le th√®me de la fa√ßon dont les compteurs de temps sont mis en ≈ìuvre sur diff√©rentes architectures est fascinant et √©tendu.  Si vous avez le temps et l'int√©r√™t, je recommande la plong√©e.  Entre autres choses, vous apprendrez, par exemple, que certains syst√®mes vous permettent de d√©terminer par programme si TSC peut servir de source fiable de temps. <br><br>  Il existe donc de nombreuses impl√©mentations architecturales de TSC, chacune avec ses propres caract√©ristiques.  Mais il est int√©ressant qu'une tendance g√©n√©rale se soit √©tablie dans tout ce zoo.  <b>Le mat√©riel et les syst√®mes d'exploitation modernes s'efforcent de garantir que</b> : <br><br><ol><li>  TSC ticks √† la m√™me fr√©quence sur chaque CPU du syst√®me </li><li>  cette fr√©quence ne change pas dans le temps </li><li>  il n'y a pas de d√©calage entre les TSC qui cochent sur diff√©rents CPU </li></ol><br>  Lors de la conception de ma biblioth√®que, j'ai d√©cid√© de partir de cette pr√©misse, et non de la vinaigrette des impl√©mentations mat√©rielles. <br><br><h3>  La biblioth√®que </h3><br>  Je n'ai pas commenc√© √† m'√©tendre sur des puces mat√©rielles d'un tas d'architectures diff√©rentes.  Au lieu de cela, j'ai d√©cid√© que ma biblioth√®que serait orient√©e vers les tendances.  Elle a un objectif purement empirique: <br><br><ol><li>  il vous permet de v√©rifier exp√©rimentalement la fiabilit√© de TSC comme source de temps </li><li>  vous permet √©galement de calculer exp√©rimentalement les param√®tres n√©cessaires pour convertir rapidement les ticks en nanosecondes </li><li>  naturellement, la biblioth√®que fournit des interfaces pratiques pour lire TSC et convertir les ticks en nanosecondes "√† la vol√©e" </li></ol><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le code de la biblioth√®que est disponible ici.</a>  Il sera compil√© et ex√©cut√© uniquement sous Linux. <br><br>  Dans le code, vous pouvez voir les d√©tails de l'impl√©mentation de toutes les m√©thodes, qui seront discut√©es plus tard. <br><br><h3>  √âvaluation de la fiabilit√© TSC </h3><br>  La biblioth√®que fournit une interface qui renvoie deux classements: <br><br><ol><li>  d√©calage maximal entre les compteurs appartenant √† diff√©rents CPU.  Seuls les CPU disponibles pour le processus sont pris en compte.  Par exemple, si un processus dispose de trois CPU disponibles, et en m√™me temps TSC sur ces CPU est 50, 150, 20, alors le d√©calage maximum sera 150-20 = 130.  Naturellement, la biblioth√®que ne sera pas en mesure d'obtenir un v√©ritable d√©calage maximum exp√©rimentalement, mais elle donnera une estimation dans laquelle s'ins√©rera ce d√©calage.  Que faire ensuite avec l'√©valuation?  Comment utiliser?  Cela r√©sout d√©j√† le code client.  Mais la signification est approximativement la suivante.  Le d√©calage maximal est la valeur maximale par laquelle la dimension cr√©√©e par le code client peut √™tre d√©form√©e.  Supposons que, dans notre exemple avec trois CPU, le code client commence √† mesurer le temps sur CPU3 (o√π TSC √©tait 20) et se termine sur CPU2 (o√π TSC √©tait 150).  Il s'av√®re que 130 ticks suppl√©mentaires se glisseront dans l'intervalle mesur√©.  Et plus jamais.  La diff√©rence entre CPU1 et CPU2 ne serait que de 100 ticks.  Ayant une estimation de 130 ticks (en fait, ce sera beaucoup plus conservateur), le client peut d√©cider si une telle valeur de distorsion lui convient ou non </li><li>  Les valeurs TSC mesur√©es s√©quentiellement sur des CPU identiques ou diff√©rents augmentent-elles?  Voici l'id√©e.  Disons que nous avons plusieurs processeurs.  Supposons que leur horloge soit synchronis√©e et qu'elle coche √† la m√™me fr√©quence.  Ensuite, si vous mesurez d'abord le temps sur un processeur, puis le mesurez √† nouveau - d√©j√† sur l'un des processeurs disponibles - le deuxi√®me chiffre doit √™tre plus grand que le premier. <br><br>  J'appellerai cette estimation en dessous de l'estimation de la monotonie TSC <br></li></ol><br>  Voyons maintenant comment obtenir la premi√®re estimation: <br><br><ol><li>  l'un des processeurs disponibles pour le processus est d√©clar√© ¬´de base¬ª </li><li>  puis tous les autres CPU sont tri√©s, et pour chacun d'eux le d√©calage est calcul√©: <code>TSC___CPU ‚Äì TSC___CPU</code> .  Cela se fait comme suit: <br><ul><li>  a) trois valeurs mesur√©es sont prises s√©quentiellement (l'une apr√®s l'autre!): <code>TSC_base_1, TSC_current, TSC_base_2</code> .  Ici, le courant indique que la valeur a √©t√© mesur√©e sur le CPU actuel et la base sur la base </li><li>  b) le d√©calage <code>TSC___CPU ‚Äì TSC___CPU</code> doit se situer dans l'intervalle <code>[TSC_current ‚Äì TSC_base_2, TSC_current ‚Äì TSC_base_1]</code> .  C'est sous l'hypoth√®se que les TSC cochent √† la m√™me fr√©quence sur les deux CPU. </li><li>  c) les √©tapes a) -b) sont r√©p√©t√©es plusieurs fois.  L'intersection de tous les intervalles obtenus √† l'√©tape b) est calcul√©e.  L'intervalle r√©sultant est consid√©r√© comme l'estimation du d√©calage <code>TSC___CPU ‚Äì TSC___CPU</code> </li></ul><br></li><li>  apr√®s avoir obtenu une estimation de d√©calage pour chaque CPU par rapport √† la base, il est facile d'obtenir une estimation du d√©calage maximum entre tous les CPU disponibles: <br><ul><li>  a) l'intervalle minimum est calcul√©, ce qui inclut tous les intervalles r√©sultants obtenus √† l'√©tape 2 </li><li>  b) la largeur de cet intervalle est consid√©r√©e comme l'estimation du d√©calage maximal entre les TSCs cocher sur diff√©rents CPU </li></ul><br></li></ol><br>  Pour √©valuer la monotonie dans la biblioth√®que, l'algorithme suivant est impl√©ment√©: <br><br><ol><li>  Disons qu'un processus a N CPU disponible </li><li>  Mesurer TSC sur CPU1 </li><li>  Mesurer TSC sur CPU2 </li><li>  ... </li><li>  Mesurer TSC sur CPUN </li><li>  Mesurer √† nouveau TSC sur CPU1 </li><li>  Nous v√©rifions que les valeurs mesur√©es augmentent de fa√ßon monotone du premier au dernier </li></ol><br>  Il est important ici que les premi√®re et derni√®re valeurs soient mesur√©es sur la m√™me CPU.  Et voici pourquoi.  Disons que nous avons 3 processeurs.  Supposons que le TSC sur CPU2 soit d√©cal√© de +100 ticks par rapport au TSC sur CPU1.  Supposons √©galement que le TSC sur CPU3 soit d√©cal√© de +100 ticks par rapport au TSC sur CPU2.  Consid√©rez la cha√Æne d'√©v√©nements suivante: <br><br><ul><li>  Lisez le TSC sur CPU1.  Soit une valeur de 10 </li><li>  2 ticks pass√©s </li><li>  Lisez TSC sur CPU2.  Doit √™tre 112 </li><li>  2 ticks pass√©s </li><li>  Lisez TSC sur CPU3.  Doit √™tre 214 </li></ul><br>  Jusqu'√† pr√©sent, l'horloge semble synchronis√©e.  Mais mesurons √† nouveau le TSC sur CPU1: <br><br><ul><li>  2 ticks pass√©s </li><li>  Lisez le TSC sur CPU1.  Doit avoir 16 ans </li></ul><br>  Oups!  La monotonie est rompue.  Il s'av√®re que la mesure des premi√®re et derni√®re valeurs sur le m√™me CPU permet de d√©tecter des d√©calages plus ou moins importants entre les horloges.  La question suivante, bien s√ªr: "Quelle est l'ampleur des changements?"  La quantit√© de d√©calage qui peut √™tre d√©tect√©e d√©pend du temps qui s'√©coule entre les mesures TSC successives.  Dans l'exemple donn√©, ce ne sont que 2 ticks.  Les d√©calages entre les heures d√©passant 2 ticks seront d√©tect√©s.  De mani√®re g√©n√©rale, les d√©calages inf√©rieurs au temps √©coul√© entre les mesures successives ne seront pas d√©tect√©s.  Ainsi, plus les mesures sont localis√©es dans le temps, mieux c'est.  La pr√©cision des deux estimations en d√©pend.  Plus les mesures sont denses: <br><br><ul><li>  plus l'estimation du d√©calage maximal est faible </li><li>  plus la confiance dans l'√©valuation de la monotonie </li></ul><br>  Dans la section suivante, nous verrons comment prendre des mesures pr√©cises.  J'ajoute ici que lors du calcul des estimations de fiabilit√© TSC, la biblioth√®que effectue de nombreuses v√©rifications plus simples des "poux", par exemple: <br><br><ul><li>  v√©rification limit√©e que les TSC sur diff√©rents processeurs fonctionnent √† la m√™me vitesse </li><li>  v√©rifier que les compteurs changent vraiment au fil du temps, et pas seulement montrer la m√™me valeur </li></ul><br><h3>  Deux m√©thodes de collecte des contre-valeurs </h3><br>  Dans la biblioth√®que, j'ai impl√©ment√© deux m√©thodes pour collecter les valeurs TSC: <br><br><ol><li>  <b>Basculez entre les CPU</b> .  Dans cette m√©thode, toutes les donn√©es n√©cessaires pour √©valuer la fiabilit√© du TSC sont collect√©es par un seul thread qui ¬´saute¬ª d'un CPU √† l'autre.  Les deux algorithmes d√©crits dans la section pr√©c√©dente conviennent √† cette m√©thode et ne conviennent pas √† l'autre. <br>  La ¬´commutation entre les CPU¬ª n'a aucune utilit√© pratique.  La m√©thode a √©t√© mise en ≈ìuvre juste pour "jouer".  Le probl√®me avec la m√©thode est que le temps n√©cessaire pour ¬´faire glisser¬ª un flux d'un CPU √† un autre est tr√®s important.  En cons√©quence, beaucoup de temps s'√©coule entre les mesures TSC successives et la pr√©cision des estimations est tr√®s faible.  Par exemple, une estimation typique du d√©calage maximum entre TSC est obtenue dans la r√©gion de 23 000 ticks. <br><br>  Cependant, la m√©thode pr√©sente deux avantages: <br><ul><li>  c'est absolument d√©terministe.  Si vous avez besoin de mesurer TSC s√©quentiellement sur CPU1, CPU2, CPU3, alors nous le prenons et le faisons: passer √† CPU1, lire TSC, passer √† CPU2, lire TSC et enfin, passer √† CPU3, lire TSC </li><li>  vraisemblablement, si le nombre de CPU dans le syst√®me augmente tr√®s rapidement, le temps de commutation entre eux devrait augmenter beaucoup plus lentement.  Par cons√©quent, en th√©orie, apparemment, un syst√®me peut exister - un tr√®s grand syst√®me!  - dans lequel l'utilisation de la m√©thode sera justifi√©e.  Mais c'est encore peu probable </li></ul><br></li><li>  <b>Mesures command√©es en utilisant CAS</b> .  Dans cette m√©thode, les donn√©es sont collect√©es en parall√®le par plusieurs threads.  Chaque CPU disponible d√©marre un thread.  Les mesures prises par diff√©rents threads sont organis√©es en une seule s√©quence √† l'aide de l'op√©ration ¬´comparer et √©changer¬ª.  Ci-dessous est un morceau de code qui montre comment cela se fait. <br>  L'id√©e de la m√©thode est emprunt√©e √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fio</a> , un outil populaire pour g√©n√©rer des charges d'E / S. <br><br>  Les estimations de fiabilit√© obtenues avec la puissance de cette m√©thode semblent d√©j√† plut√¥t bonnes.  Par exemple, une estimation du d√©calage maximum est d√©j√† obtenue au niveau de plusieurs centaines de ticks.  Une v√©rification de la monotonie vous permet de rattraper l'horloge d√©synchronis√©e au sein de centaines de ticks. <br><br>  Cependant, les algorithmes donn√©s dans la section pr√©c√©dente ne conviennent pas √† cette m√©thode.  Il est important pour eux que les valeurs TSC soient mesur√©es dans un ordre pr√©d√©termin√©.  La m√©thode des ¬´mesures ordonn√©es par CAS¬ª ne le permet pas.  Au lieu de cela, une longue s√©quence de mesures al√©atoires est d'abord collect√©e, puis des algorithmes (d√©j√† diff√©rents) tentent de trouver des valeurs lues sur des processeurs ¬´appropri√©s¬ª dans cette s√©quence. <br><br>  Je ne donnerai pas ces algorithmes ici, afin de ne pas abuser de votre attention.  Vous pouvez les voir dans le code.  Il y a beaucoup de commentaires.  En th√©orie, ces algorithmes sont les m√™mes.  Un point fondamentalement nouveau est la v√©rification de la fa√ßon dont les s√©quences TSC de type al√©atoire sont statistiquement ¬´qualitatives¬ª.  Il est √©galement possible de fixer un niveau minimum acceptable de signification statistique pour les estimations de fiabilit√© du TSC. <br><br>  Th√©oriquement, sur de TR√àS grands syst√®mes, la m√©thode ¬´ordonn√©e CAS¬ª peut donner de mauvais r√©sultats.  La m√©thode exige que les processeurs se disputent l'acc√®s √† un emplacement de m√©moire commun.  S'il y a beaucoup de processeurs, la concurrence peut s'av√©rer tr√®s intense.  En cons√©quence, il sera difficile de cr√©er une s√©quence de mesure avec de bonnes propri√©t√©s statistiques.  Cependant, pour le moment, cette situation semble peu probable. <br></li></ol><br>  J'ai promis du code.  Voici √† quoi cela ressemble de construire des mesures dans une seule cha√Æne en utilisant CAS. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; arg-&gt;probes_count; i++ ) { <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> seq_num = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> tsc_val = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { __atomic_load( seq_counter, &amp;seq_num, __ATOMIC_ACQUIRE); __sync_synchronize(); tsc_val = WTMLIB_GET_TSC(); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( !__atomic_compare_exchange_n( seq_counter, &amp;seq_num, seq_num + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, __ATOMIC_ACQ_REL, __ATOMIC_RELAXED)); arg-&gt;tsc_probes[i].seq_num = seq_num; arg-&gt;tsc_probes[i].tsc_val = tsc_val; }</code> </pre><br>  Ce code est ex√©cut√© sur chaque CPU disponible.  Tous les threads ont acc√®s √† la variable partag√©e <code>seq_counter</code> .  Avant de lire le TSC, le flux lit la valeur de cette variable et la stocke dans la variable <code>seq_num</code> .  Lit ensuite TSC.  Il essaie ensuite d'augmenter atomiquement seq_counter de un, mais uniquement si la valeur de la variable n'a pas chang√© depuis sa lecture.  Si l'op√©ration r√©ussit, cela signifie que le thread a r√©ussi √† ¬´ <code>seq_num</code> ¬ª le num√©ro de s√©quence stock√© dans <code>seq_num</code> derri√®re la valeur TSC mesur√©e.  Le prochain num√©ro de s√©rie, qui pourra √™tre implant√© (peut-√™tre d√©j√† dans un autre thread) en sera un de plus.  Pour ce nombre est tir√© de la variable <code>seq_counter</code> , et chaque appel r√©ussi de <code>__atomic_compare_exchange_n()</code> augmente cette variable d'une <code>__atomic_compare_exchange_n()</code> . <br><br><div class="spoiler">  <b class="spoiler_title">__atomique avec __sync ???</b> <div class="spoiler_text">  Pour des raisons d' <code>__atomic</code> , il convient de noter que l'utilisation des fonctions int√©gr√©es de la famille <code>__atomic</code> avec une fonction de la famille obsol√®te <code>__sync</code> semble moche.  <code>__sync_synchronize()</code> utilis√© dans le code pour √©viter de r√©ordonner l'op√©ration de lecture TSC avec l'op√©ration en amont.  Cela n√©cessite une barri√®re de m√©moire compl√®te.  La famille <code>__atomic</code> n'a formellement pas de fonction avec les propri√©t√©s correspondantes.  Bien qu'il existe en fait: <code>__atomic_signal_fence()</code> .  Cette fonction organise les calculs de flux avec des gestionnaires de signaux qui s'ex√©cutent sur le m√™me flux.  En fait, c'est une barri√®re compl√®te.  Cependant, cela n'est pas explicitement indiqu√©.  Et je pr√©f√®re le code qui n'a pas de s√©mantique cach√©e.  Par cons√©quent, <code>__sync_synchronize()</code> est une barri√®re de m√©moire stop-full. <br></div></div><br>  Un autre point √† mentionner ici est le soin que tous les flux impliqu√©s dans les mesures d√©marrent plus ou moins simultan√©ment.  Nous sommes int√©ress√©s par le fait que les valeurs TSC lues sur diff√©rents CPU sont aussi m√©lang√©es que possible.  Nous ne sommes pas satisfaits de la situation o√π, par exemple, un thread d√©marre en premier, termine son travail, puis seulement tous les autres d√©marrent.  La s√©quence TSC r√©sultante aura des propri√©t√©s inutiles.  Aucune estimation ne peut en √™tre tir√©e.  Le d√©marrage simultan√© de tous les threads est important - et pour cela, des mesures ont √©t√© prises dans la biblioth√®que. <br><br><h3>  Convertissez les ticks en nanosecondes √† la vol√©e </h3><br>  Apr√®s avoir v√©rifi√© la fiabilit√© de TSC, le deuxi√®me objectif majeur de la biblioth√®que est de convertir les ticks en nanosecondes √† la vol√©e.  J'ai emprunt√© l'id√©e de cette conversion au fio d√©j√† mentionn√©.  Cependant, j'ai d√ª apporter des am√©liorations significatives, car, comme mon analyse l'a montr√©, en soi, la proc√©dure de conversion ne fonctionne pas assez bien.  L√†, vous obtenez une faible pr√©cision. <br><br>  Je vais commencer par un exemple. <br><br>  Id√©alement, je voudrais convertir les ticks en nanosecondes comme ceci: <br> <code>ns_time = tsc_ticks / tsc_per_ns</code> <br>  Nous voulons que le temps consacr√© √† la conversion soit minimal.  Par cons√©quent, nous visons √† utiliser exclusivement l'arithm√©tique enti√®re.  Voyons comment cela peut nous menacer. <br><br>  Si <code>tsc_per_ns = 3</code> , alors une simple division enti√®re, du point de vue de la pr√©cision, fonctionne tr√®s bien: <code>ns_time = tsc_ticks / 3</code> . <br><br>  Mais que faire si <code>tsc_per_ns = 3.333</code> ?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si ce nombre est arrondi √† 3, la pr√©cision de conversion sera tr√®s faible. Pour rem√©dier √† </font><font style="vertical-align: inherit;">ce probl√®me comme suit: </font></font><br> <code>ns_time = (tsc_ticks * factor) / (3.333 * factor)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si le facteur </font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est suffisamment grand, la pr√©cision sera bonne. Mais quelque chose restera mauvais. A savoir, les frais g√©n√©raux de conversion. La division enti√®re est une op√©ration tr√®s co√ªteuse. Par exemple, sur x86, il n√©cessite plus de 10 cycles d'horloge. De plus, les op√©rations de division enti√®re ne sont pas toujours en pipeline. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous r√©√©crivons notre formule sous la forme √©quivalente </font></font><br> <code>ns_time = (tsc_ticks * factor / 3.333) / factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La premi√®re division n'est pas un probl√®me. Nous pouvons pr√© </font></font><code>(factor / 3.333)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">calculer </font><font style="vertical-align: inherit;">√† l'avance. Mais la deuxi√®me division fait toujours mal. Pour se d√©barrasser d'elle, choisissons</font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√©gal √† la puissance de deux. Apr√®s cela, la deuxi√®me division peut √™tre remplac√©e par un d√©calage de bits - une op√©ration simple et rapide. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle taille pouvez-vous choisir </font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Malheureusement, </font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il ne peut pas √™tre arbitrairement important. Elle est limit√©e par la condition selon laquelle la multiplication dans le num√©rateur ne doit pas conduire √† un d√©bordement de type 64 bits. Oui, nous voulons utiliser uniquement des types ¬´natifs¬ª. Encore une fois, pour r√©duire les frais g√©n√©raux de conversion au minimum. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voyons maintenant sa taille </font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans notre exemple sp√©cifique. Supposons que nous voulons travailler avec des intervalles de temps allant jusqu'√† un an. Au </font><font style="vertical-align: inherit;">cours de </font><font style="vertical-align: inherit;">l'ann√©e, TSC tiknet les temps suivants: </font></font><code>3.333 * 1000000000 * 60 * 60 * 24 * 365 = 105109488000000000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Diviser une valeur maximale du num√©ro de type 64 bits est la suivante </font><font style="vertical-align: inherit;">: </font></font><code>18446744073709551615 / 105109488000000000 ~ 175.5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Donc l'expression</font></font><code>(factor / 3.333)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne doit pas d√©passer cette valeur. Ensuite , </font><font style="vertical-align: inherit;">nous avons </font></font><code>factor &lt;= 175.5 * 3.333 ~ 584.9</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. La plus grande puissance de deux qui ne d√©passe pas ce nombre est 512. Par cons√©quent, notre formule de conversion prend la forme: </font></font><br><br> <code>ns_time = (tsc_ticks * 512 / 3.333) / 512</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ou:</font></font><br><br> <code>ns_time = tsc_ticks * 153 / 512</code> <br> <br>  Super.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voyons maintenant ce que cette formule a avec pr√©cision. Un an contient des </font></font><code>1000000000 * 60 * 60 * 24 * 365 = 31536000000000000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nanosecondes. Notre formule donne: </font></font><code>105109488000000000 * 153 / 512 = 31409671218750000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. La diff√©rence avec la valeur actuelle est de 126328781250000 nanosecondes ou </font></font><code>126328781250000 / 1000000000 / 60 / 60 ~ 35</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">heures. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est une grosse erreur. Nous voulons une meilleure pr√©cision. Et si nous mesurons des intervalles de temps ne d√©passant pas une heure? Je vais omettre les calculs. Ils sont compl√®tement identiques √† ceux qui viennent d'√™tre r√©alis√©s. La formule finale sera: </font></font><br><br> <code>ns_time = tsc_ticks * 1258417 / 4194304</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'erreur de conversion ne sera que de 119 305 nanosecondes pendant 1 heure (ce qui est inf√©rieur √† 0,2 millisecondes). Tr√®s, tr√®s bien. Si la valeur convertible maximale est encore inf√©rieure √† une heure, la pr√©cision sera encore meilleure. Mais comment utilisons-nous cela? Ne limitez pas les mesures de temps √† une heure? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faisons attention au moment suivant:</font></font><br><br> <code>tsc_ticks = (tsc_ticks_per_1_hour * number_of_hours) + tsc_ticks_remainder</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous calculons </font></font><code>tsc_ticks_per_1_hour</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous pouvons extraire </font></font><code>number_of_hours</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de </font></font><code>tsc_ticks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ensuite, nous savons combien de nanosecondes sont contenues en une heure. Il ne nous sera donc pas difficile de traduire en nanosecondes la partie </font></font><code>tsc_ticks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">correspondant √† un nombre entier d'heures. Pour terminer la conversion, nous devrons traduire en nanosecondes </font></font><code>tsc_ticks_remainder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Cependant, nous savons que ce nombre de tiques est arriv√© en moins d'une heure. Donc, pour le convertir en nanosecondes, nous pouvons utiliser la formule (1). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est fait. Un tel m√©canisme de conversion nous convient. R√©sumons-le et optimisons-le maintenant. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout d'abord, nous voulons avoir un contr√¥le flexible sur les erreurs de conversion. Nous ne voulons pas lier les param√®tres de conversion √† un intervalle de temps de 1 heure. Soit un intervalle de temps arbitraire:</font></font><br><br> <code>tsc_ticks = modulus * number_of_moduli_periods + tsc_ticks_remainder</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rappelons une fois de plus comment convertir le reste en nanosecondes: </font></font><br><br> <code>ns_per_remainder = (tsc_ticks_remainder * factor / tsc_per_nsec) / factor</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calculer les param√®tres de conversion (on le sait </font></font><code>tsc_ticks_remainder &lt; modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">): </font><font style="vertical-align: inherit;">Par souci d'ennui, il faut noter que la derni√®re in√©galit√© n'est pas √©quivalente √† la premi√®re dans le cadre de l'arithm√©tique enti√®re. Mais je ne m'y attarderai pas longtemps. Je peux seulement dire que la derni√®re in√©galit√© est plus grave que la premi√®re, et donc s√ªre √† utiliser. </font><font style="vertical-align: inherit;">Apr√®s avoir obtenu de la derni√®re in√©galit√© </font><font style="vertical-align: inherit;">, nous calculons: </font><font style="vertical-align: inherit;">Et puis ces param√®tres sont utilis√©s pour convertir le reste en nanosecondes: </font><font style="vertical-align: inherit;">Donc, nous </font><font style="vertical-align: inherit;">avons calcul√© </font><font style="vertical-align: inherit;">la conversion du reste. Le prochain probl√®me √† r√©soudre - est l'extraction </font><font style="vertical-align: inherit;">et </font><font style="vertical-align: inherit;">de la</font></font><br><br> <code>modulus * (factor / tsc_per_nsec) &lt;= UINT64_MAX <br> factor &lt;= (UINT64_MAX / modulus) * tsc_per_nsec <br> 2 ^ shift &lt;= (UINT64_MAX / modulus) * tsc_per_nsec <br></code> <br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><code>shift</code><font style="vertical-align: inherit;"></font><br><br> <code>factor = 2 ^ shift <br> mult = factor / tsc_per_nsec <br></code> <br><br><font style="vertical-align: inherit;"></font><br><br> <code>ns_per_remainder = (tsc_ticks_remainder * mult) &gt;&gt; shift <br></code> <br><br><font style="vertical-align: inherit;"></font><code>tsc_ticks_remainder</code><font style="vertical-align: inherit;"></font><code>number_of_moduli_periods</code><font style="vertical-align: inherit;"></font><code>tsc_ticks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Comme toujours, nous voulons le faire rapidement. </font><font style="vertical-align: inherit;">Comme toujours, nous ne voulons pas utiliser la division. </font><font style="vertical-align: inherit;">Par cons√©quent, nous choisissons simplement </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√©gal √† la puissance de deux: </font></font><br><br> <code>modulus = 2 ^ remainder_bit_length</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alors:</font></font><br><br> <code>number_of_moduli_periods = tsc_ticks &gt;&gt; remainder_bit_length <br> tsc_ticks_remainder = tsc_ticks &amp; (modulus - 1)</code> <br> <br>  Super.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous savons maintenant comment extraire de </font></font><code>tsc_ticks</code> <code>number_of_moduli_periods</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>tsc_ticks_remainder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Et nous savons comment convertir </font></font><code>tsc_ticks_remainder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en nanosecondes. </font><font style="vertical-align: inherit;">Il reste √† comprendre comment convertir cette partie des ticks, qui est un multiple, en nanosecondes </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mais tout est simple: </font></font><br><br> <code>ns_per_moduli = ns_per_modulus * number_of_moduli_periods</code> <br> <br> <code>ns_per_modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vous pouvez calculer √† l'avance. </font><font style="vertical-align: inherit;">De plus, selon la m√™me formule par laquelle nous convertissons le reste. </font><font style="vertical-align: inherit;">Cette formule peut √™tre utilis√©e pour des p√©riodes qui ne d√©passent pas </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Lui </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">m√™me </font><font style="vertical-align: inherit;">, bien s√ªr, pas plus que </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br> <code>ns_per_modulus = (modulus * mult) &gt;&gt; shift</code> <br> <br>  C‚Äôest tout!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons pu calculer tous les param√®tres n√©cessaires pour convertir les tiques en nanosecondes √† la vol√©e. </font><font style="vertical-align: inherit;">R√©sumons maintenant bri√®vement la proc√©dure de conversion:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous avons </font></font><code>tsc_ticks</code> </li><li> <code>number_of_moduli_periods = tsc_ticks &gt;&gt; remainder_bit_length</code> </li> <li> <code>tsc_ticks_remainder = tsc_ticks &amp; (modulus - 1)</code> </li> <li> <code>ns = ns_per_modulus * number_of_moduli_periods + (tsc_ticks_remainder * mult) &gt;&gt; shift</code> </li> </ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cette proc√©dure, les </font><font style="vertical-align: inherit;">param√®tres </font></font><code>remainder_bit_length</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>modulus, ns_per_modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>mult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>shift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avance de pr√© - </font><font style="vertical-align: inherit;">calcul. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous lisez toujours ce post, alors vous √™tes super ou super. </font><font style="vertical-align: inherit;">Il est m√™me possible que vous soyez un analyste des performances ou un d√©veloppeur de logiciels hautes performances.</font></font><br><br>  Alors voil√†.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il s'av√®re que nous n'avons pas encore fini :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rappelez-vous comment nous avons calcul√© le param√®tre </font></font><code>mult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">C'√©tait comme √ßa: </font></font><br><br> <code>mult = factor / tsc_per_nsec</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Question: d'o√π vient-il </font></font><code>tsc_per_nsec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le nombre de ticks dans une nanoseconde est une tr√®s petite valeur. </font><font style="vertical-align: inherit;">En fait, ma biblioth√®que est </font></font><code>tsc_per_nsec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilis√©e √† la </font><font style="vertical-align: inherit;">place </font></font><code>(tsc_per_sec / 1000000000)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">C'est-√†-dire: </font></font><br><br> <code>mult = factor * 1000000000 / tsc_per_sec</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et il y a deux questions int√©ressantes:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et non </font></font><code>tsc_per_msec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, par exemple?</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O√π les obtenir </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commen√ßons par le premier. Fio utilise d√©sormais le nombre de ticks par milliseconde. Et cela pose des probl√®mes. Sur la machine, les param√®tres dont je cit√©s ci - </font><font style="vertical-align: inherit;">dessus </font></font><code>tsc_per_msec = 2599998</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Alors </font></font><code>tsc_per_sec = 2599998971</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Si nous amenons ces nombres √† une √©chelle, leur rapport sera tr√®s proche de l'unit√©: 0,999999626. Mais si nous utilisons le premier, et non le second, alors pour chaque seconde, nous aurons une erreur de 374 nanosecondes. Par cons√©quent - </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plus loin ... Comment compter </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela se fait sur la base d'une mesure directe: </font><font style="vertical-align: inherit;">¬´un certain temps¬ª est un param√®tre configurable. Elle peut √™tre plus grande, plus petite ou √©gale √† une seconde. Disons que c'est une demi-seconde. Supposons en outre que la diff√©rence r√©elle entre </font><font style="vertical-align: inherit;">et </font><font style="vertical-align: inherit;">s'est av√©r√©e √™tre de 0,6 seconde. Alors </font><font style="vertical-align: inherit;">.</font></font><br><br> <code>start_sytem_time = clock_gettime() <br> start_tsc = WTMLIB_GET_TSC() <br>  -  <br> end_system_time = clock_gettime() <br> end_tsc = WTMLIB_GET_TSC() <br></code> <br><br><font style="vertical-align: inherit;"></font><code>end_system_time</code><font style="vertical-align: inherit;"></font><code>start_system_time</code><font style="vertical-align: inherit;"></font><code>tsc_per_sec = (end_tsc ‚Äì start_tsc) / 0,6</code><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La biblioth√®que consid√®re plusieurs valeurs de cette mani√®re </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Et puis, en utilisant des m√©thodes standard, il les ¬´nettoie¬ª du bruit statistique et re√ßoit une valeur unique √† </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">laquelle on peut faire confiance. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le diagramme de mesure du temps ci-dessus, l'ordre des appels </font></font><code>clock_gettime()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et est </font><font style="vertical-align: inherit;">important </font></font><code>WTMLIB_GET_TSC()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Il est important </font></font><code>WTMLIB_GET_TSC()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que le m√™me temps s'√©coule entre deux appels qu'entre deux appels </font></font><code>clock_gettime()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Il sera alors possible de corr√©ler facilement l'heure du syst√®me avec les ticks TSC. Et puis la dispersion des valeurs </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut vraiment √™tre consid√©r√©e comme al√©atoire. Avec ce sch√©ma de mesure, les valeurs </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s'√©carteront de la valeur moyenne dans les deux sens avec la m√™me probabilit√©. Et il sera possible de leur appliquer des m√©thodes de filtrage standard.</font></font><br><br><h3>  Conclusion </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est peut-√™tre tout. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais le sujet de la mesure efficace du temps ne se limite pas √† cela. </font><font style="vertical-align: inherit;">Il existe de nombreuses nuances. </font><font style="vertical-align: inherit;">Pour les personnes int√©ress√©es, je propose de travailler de mani√®re ind√©pendante sur les questions suivantes:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> stocker les param√®tres de conversion dans le cache ou - mieux encore - sur les registres </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† quelles limites peut-on r√©duire </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(augmentant ainsi la pr√©cision de la conversion)?</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comme nous l'avons vu, la pr√©cision de la conversion est affect√©e non seulement </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais aussi par la taille de l'intervalle de temps, qui correspond aux ticks ( </font></font><code>tsc_per_msec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Comment √©quilibrer l'influence des deux facteurs?</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TSC dans la machine virtuelle. </font><font style="vertical-align: inherit;">Puis-je l'utiliser?</font></font></li><li>        . , fio        timespec.    : <br><br> <code>tp-&gt;tv_sec = nsecs / 1000000000ULL;</code> <br> <br> ,   TSC          .         ,  ,      <br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les m√©thodes discut√©es dans cet article nous permettent de mesurer l'√©chelle de temps d'une seconde avec une pr√©cision de l'ordre de plusieurs dizaines de nanosecondes. </font><font style="vertical-align: inherit;">C'est la pr√©cision que j'observe r√©ellement lors de l'utilisation de ma biblioth√®que. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fait int√©ressant, le fio, auquel j'ai emprunt√© certaines m√©thodes, perd exactement 700 √† 900 nanosecondes sur une deuxi√®me √©chelle (et il y a trois raisons √† cela). </font><font style="vertical-align: inherit;">De plus, il perd en vitesse de conversion en raison du stockage du temps dans un format Linux standard. </font><font style="vertical-align: inherit;">Cependant, je m'empresse de rassurer les fans de fio. </font><font style="vertical-align: inherit;">J'ai envoy√© aux d√©veloppeurs une </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">description de tous les probl√®mes de conversion que j'ai d√©couverts</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Les gens travaillent d√©j√†, ils le r√©pareront bient√¥t. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je vous souhaite de nombreuses nanosecondes agr√©ables!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr425237/">https://habr.com/ru/post/fr425237/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr425227/index.html">Les chercheurs ont trouv√© un moyen de d√©tecter et de contourner les cl√©s Honeytoken dans un certain nombre de services Amazon.</a></li>
<li><a href="../fr425229/index.html">Comment nous avons aid√© CDN MegaFon.TV √† ne pas participer √† la Coupe du monde 2018</a></li>
<li><a href="../fr425231/index.html">FAQ sur le travail d'une h√¥tesse de l'air</a></li>
<li><a href="../fr425233/index.html">Python 3 sur Facebook</a></li>
<li><a href="../fr425235/index.html">Un peu plus sur les graphiques, ou comment d√©tecter les d√©pendances entre vos applications</a></li>
<li><a href="../fr425241/index.html">D√©veloppeur 20 ans plus tard: Vasily Lebedev sur ICRE, l'√©ducation, son livre et sa programmation</a></li>
<li><a href="../fr425243/index.html">Le manuel de John Willis</a></li>
<li><a href="../fr425245/index.html">Annonce de RamblerFront & # 6</a></li>
<li><a href="../fr425247/index.html">Crowdsourcing dans les tests</a></li>
<li><a href="../fr425249/index.html">Comment est la connaissance du LLP √† l'Universit√© ITMO: le cours "Programmation de bas niveau"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>