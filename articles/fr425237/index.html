<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🎓 🤷🏻 🆎 Mesure du temps avec une précision en nanosecondes 👨🏼‍✈️ 💂🏼 👦🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a quelques mois, un moment historique est venu pour moi. Les outils standard du système d'exploitation pour mesurer le temps ont cessé de me suff...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mesure du temps avec une précision en nanosecondes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425237/"><img src="https://habrastorage.org/webt/zx/xf/se/zxxfse_sd5ma4wwfy0u6rilcai8.jpeg" alt="image"><br><br>  Il y a quelques mois, un moment historique est venu pour moi.  Les outils standard du système d'exploitation pour mesurer le temps ont cessé de me suffire.  Il a fallu du temps pour mesurer avec une précision en nanosecondes et avec des frais généraux en nanosecondes. <br><br>  J'ai décidé d'écrire une bibliothèque qui résoudrait ce problème.  À première vue, il semblait qu'il n'y avait rien de spécial à faire.  Mais après un examen plus approfondi, comme toujours, il s'est avéré qu'il y avait de nombreux problèmes intéressants à régler.  Dans cet article, je vais parler des problèmes et comment ils ont été résolus. <br><br>  Étant donné que vous pouvez mesurer différents types de temps sur un ordinateur, je vais immédiatement préciser que nous parlerons ici de «temps par chronomètre».  Ou l'heure de l'horloge murale.  C’est le temps réel, le temps écoulé, etc.  C'est-à-dire un temps "humain" simple, que nous détectons au début de la tâche et arrêtons à la fin. <br><a name="habracut"></a><br><h3>  Microseconde - presque pour toujours </h3><br>  Les développeurs de systèmes haute performance au cours des dernières années se sont habitués à l'échelle de temps en microsecondes.  En microsecondes, vous pouvez lire les données d'un lecteur NVMe.  En microsecondes, les données peuvent être envoyées sur le réseau.  Pas pour tout le monde, bien sûr, mais pour le réseau InifiniBand - facilement. <br><br>  En même temps, la microseconde avait également une structure.  Une pile d'E / S complète se compose de plusieurs composants logiciels et matériels.  Les retards introduits par certains d'entre eux se situent au niveau inférieur à la microseconde. <br><br>  Pour mesurer des retards de cette ampleur, la précision en microsecondes n'est plus suffisante.  Cependant, non seulement la précision est importante, mais aussi la surcharge de mesure du temps.  L'appel système Linux clock_gettime () renvoie le temps avec une précision en nanosecondes.  Sur une machine à portée de main (Intel® Xeon® CPU E5-2630 v2 @ 2,60 GHz), cet appel se termine en environ 120 ns.  Très bonne silhouette.  De plus, clock_gettime () fonctionne de façon assez prévisible.  Cela vous permet de prendre en compte les frais généraux de son appel et de prendre des mesures avec une précision de l'ordre de dizaines de nanosecondes.  Cependant, prêtons maintenant attention à cela.  Pour mesurer l'intervalle de temps, vous devez effectuer deux appels de ce type: au début et à la fin.  C'est-à-dire  dépenser 240 ns.  Si des intervalles de temps densément espacés de l'ordre de 1 à 10 μs sont mesurés, dans certains cas, le processus de mesure lui-même déformera considérablement le processus observé. <br><br>  J'ai commencé cette section avec la façon dont la pile d'E / S s'est accélérée ces dernières années.  C'est nouveau, mais loin d'être la seule raison de vouloir mesurer le temps rapidement et avec précision.  Un tel besoin a toujours été.  Par exemple, il y avait toujours un code que je voulais accélérer d'au moins 1 cycle d'horloge du microprocesseur.  Ou un autre exemple, tiré de l'article original sur la vulnérabilité sensationnelle Spectre: <br><br><img src="https://habrastorage.org/webt/db/5a/7o/db5a7oldvzrcqfi_ymamg4qzscu.jpeg" alt="image"><br><br>  Ici, les lignes 72 à 74 mesurent le temps d'exécution d'une seule opération d'accès à la mémoire.  Certes, Spectre ne s'intéresse pas aux nanosecondes.  Le temps peut être mesuré en «perroquets».  Nous reviendrons sur les perroquets et les secondes. <br><br><h3>  Compteur d'horodatage </h3><br>  La clé d'une mesure rapide et précise du temps est un compteur à microprocesseur spécial.  La valeur de ce compteur est généralement stockée dans un registre séparé et est généralement - mais pas toujours - accessible depuis l'espace utilisateur.  Sur différentes architectures, le compteur est appelé différemment: <br><br><ol><li>  compteur d'horodatage x86 </li><li>  registre de base de temps sur PowerPC </li><li>  compteur de temps d'intervalle sur Itanium </li><li>  etc. </li></ol><br>  Ci-dessous, j'utiliserai toujours le nom de "compteur d'horodatage" ou TSC, bien qu'en fait je garde à l'esprit un tel compteur, quelle que soit l'architecture. <br><br>  La lecture de la valeur TSC habituellement - mais encore une fois pas toujours - est possible avec une seule instruction.  Voici un exemple pour x86.  À strictement parler, ce n'est pas une instruction d'assembleur pur, mais l'assembleur en ligne GNU: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> eax, edx; __asm__ __volatile__( <span class="hljs-string"><span class="hljs-string">"rdtsc"</span></span> : <span class="hljs-string"><span class="hljs-string">"=a"</span></span> (eax), <span class="hljs-string"><span class="hljs-string">"=d"</span></span> (edx));</code> </pre> <br>  L'instruction rdtsc place deux moitiés de 32 bits du registre TSC dans les registres eax et edx.  Parmi ceux-ci, vous pouvez «coller» une seule valeur 64 bits. <br><br>  Encore une fois, je note: ces instructions (et similaires) dans la plupart des cas peuvent être appelées directement depuis l'espace utilisateur.  Aucun appel système.  Frais généraux minimaux. <br><br>  Que faut-il faire maintenant pour mesurer le temps? <br><br><ol><li>  Exécutez une telle instruction au début de l'intervalle de temps qui nous intéresse.  N'oubliez pas la contre-valeur </li><li>  Exécutez une telle instruction à la fin.  Nous pensons que la valeur du compteur de la première instruction à la seconde augmentera.  Sinon, pourquoi est-il nécessaire?  Rappelez-vous la deuxième valeur </li><li>  Nous considérons la différence entre les deux valeurs stockées.  C'est notre temps </li></ol><br>  Cela semble simple, mais ... <br><br>  Le temps mesuré par la procédure décrite est exprimé en «perroquets».  Ce n'est pas en quelques secondes.  Mais parfois, les perroquets sont exactement ce dont vous avez besoin.  Il y a des situations où les valeurs absolues des intervalles de temps ne sont pas importantes, mais comment les différents intervalles sont liés les uns aux autres.  L'exemple Spectre ci-dessus illustre exactement cette situation.  La durée de chaque accès à la mémoire individuelle n'a pas d'importance.  Il est seulement important que les appels vers certaines adresses soient exécutés beaucoup plus rapidement que vers d'autres (selon que les données sont stockées dans le cache ou dans la mémoire principale). <br><br>  Mais que faire si ce n'est pas des perroquets, mais des secondes / microsecondes / nanosecondes, etc.?  On peut distinguer ici deux cas fondamentalement différents: <br><br><ol><li>  Des nanosecondes sont nécessaires, mais alors.  Autrement dit, il est permis de faire d'abord toutes les mesures nécessaires dans des perroquets et de les stocker quelque part pour un traitement ultérieur (par exemple, en mémoire).  Et seulement une fois les mesures terminées, convertir lentement les perroquets collectés en secondes </li><li>  Les nanosecondes sont nécessaires "à la volée".  Par exemple, votre processus de mesure a une sorte de «consommateur» que vous ne contrôlez pas et qui attend du temps au format «humain» </li></ol><br>  Le premier cas est simple, le second - nécessite de l'ingéniosité.  La conversion doit être aussi efficace que possible.  S'il consomme beaucoup de ressources, il peut fausser considérablement le processus de mesure.  Nous parlerons de la conversion efficace ci-dessous.  Nous avons jusqu'ici identifié ce problème et passons à un autre. <br><br>  Les compteurs d'horodatage ne sont pas aussi simples que nous le souhaiterions.  Sur certaines architectures: <br><br><ol><li>  il n'est pas garanti que le TSC soit mis à jour à haute fréquence.  Si le TSC est mis à jour, disons, une fois toutes les microsecondes, il ne sera pas possible de corriger les nanosecondes avec lui. </li><li>  la fréquence de mise à jour du TSC peut varier dans le temps </li><li>  sur différents CPU présents dans le système, les TSC peuvent être mis à jour à différentes fréquences </li><li>  il peut y avoir un décalage entre les TSCs sur les différents processeurs </li></ol><br>  Voici un exemple illustrant le dernier problème.  Supposons que nous ayons un système avec deux CPU: CPU1 et CPU2.  Supposons que le TSC sur le premier CPU soit derrière le second du nombre de ticks, ce qui équivaut à 5 secondes.  Supposons en outre qu'un flux soit lancé dans le système qui mesure le temps des calculs, ce qu'il fait lui-même.  Pour ce faire, le flux lit d'abord la valeur TSC, puis fait le calcul, puis lit la deuxième valeur TSC.  Si pendant toute sa vie un thread reste sur un seul CPU - sur n'importe quel - alors il n'y a pas de problèmes.  Mais que se passe-t-il si le thread a démarré sur CPU1, a mesuré la première valeur TSC là-bas, puis au milieu des calculs a été déplacé par le système d'exploitation vers CPU2, où il a lu la deuxième valeur TSC?  Dans ce cas, les calculs sembleront 5 secondes plus longs qu'ils ne le sont réellement. <br><br>  En raison des problèmes répertoriés ci-dessus, TSC ne peut pas servir de source de temps fiable sur certains systèmes.  Cependant, sur d'autres systèmes "souffrant" des mêmes problèmes, le TSC peut toujours être utilisé.  Ceci est rendu possible grâce à des caractéristiques architecturales spéciales: <br><br><ol><li>  l'équipement peut générer une interruption spéciale chaque fois que la fréquence de mise à jour du TSC change.  Dans le même temps, l'équipement offre également la possibilité de connaître la fréquence actuelle.  Alternativement, le taux de rafraîchissement TSC peut être placé sous le contrôle du système d'exploitation (voir «Power ISA version 2.06 révision B, livre II, chapitre 5») </li><li>  le matériel ainsi que la valeur TSC peuvent également fournir l'ID du processeur sur lequel cette valeur est lue (voir les instructions Intel RDTSCP, "Intel 64 and IA-32 Architectures Software Developer's Manual", Volume 2) </li><li>  sur certains systèmes, vous pouvez ajuster par programme la valeur TSC pour chaque CPU (voir l'instruction Intel WRMSR et enregistrez IA32_TIME_STAMP_COUNTER, "Intel 64 and IA-32 Architectures Software Developer's Manual", Volume 3) </li></ol><br>  En général, le thème de la façon dont les compteurs de temps sont mis en œuvre sur différentes architectures est fascinant et étendu.  Si vous avez le temps et l'intérêt, je recommande la plongée.  Entre autres choses, vous apprendrez, par exemple, que certains systèmes vous permettent de déterminer par programme si TSC peut servir de source fiable de temps. <br><br>  Il existe donc de nombreuses implémentations architecturales de TSC, chacune avec ses propres caractéristiques.  Mais il est intéressant qu'une tendance générale se soit établie dans tout ce zoo.  <b>Le matériel et les systèmes d'exploitation modernes s'efforcent de garantir que</b> : <br><br><ol><li>  TSC ticks à la même fréquence sur chaque CPU du système </li><li>  cette fréquence ne change pas dans le temps </li><li>  il n'y a pas de décalage entre les TSC qui cochent sur différents CPU </li></ol><br>  Lors de la conception de ma bibliothèque, j'ai décidé de partir de cette prémisse, et non de la vinaigrette des implémentations matérielles. <br><br><h3>  La bibliothèque </h3><br>  Je n'ai pas commencé à m'étendre sur des puces matérielles d'un tas d'architectures différentes.  Au lieu de cela, j'ai décidé que ma bibliothèque serait orientée vers les tendances.  Elle a un objectif purement empirique: <br><br><ol><li>  il vous permet de vérifier expérimentalement la fiabilité de TSC comme source de temps </li><li>  vous permet également de calculer expérimentalement les paramètres nécessaires pour convertir rapidement les ticks en nanosecondes </li><li>  naturellement, la bibliothèque fournit des interfaces pratiques pour lire TSC et convertir les ticks en nanosecondes "à la volée" </li></ol><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le code de la bibliothèque est disponible ici.</a>  Il sera compilé et exécuté uniquement sous Linux. <br><br>  Dans le code, vous pouvez voir les détails de l'implémentation de toutes les méthodes, qui seront discutées plus tard. <br><br><h3>  Évaluation de la fiabilité TSC </h3><br>  La bibliothèque fournit une interface qui renvoie deux classements: <br><br><ol><li>  décalage maximal entre les compteurs appartenant à différents CPU.  Seuls les CPU disponibles pour le processus sont pris en compte.  Par exemple, si un processus dispose de trois CPU disponibles, et en même temps TSC sur ces CPU est 50, 150, 20, alors le décalage maximum sera 150-20 = 130.  Naturellement, la bibliothèque ne sera pas en mesure d'obtenir un véritable décalage maximum expérimentalement, mais elle donnera une estimation dans laquelle s'insérera ce décalage.  Que faire ensuite avec l'évaluation?  Comment utiliser?  Cela résout déjà le code client.  Mais la signification est approximativement la suivante.  Le décalage maximal est la valeur maximale par laquelle la dimension créée par le code client peut être déformée.  Supposons que, dans notre exemple avec trois CPU, le code client commence à mesurer le temps sur CPU3 (où TSC était 20) et se termine sur CPU2 (où TSC était 150).  Il s'avère que 130 ticks supplémentaires se glisseront dans l'intervalle mesuré.  Et plus jamais.  La différence entre CPU1 et CPU2 ne serait que de 100 ticks.  Ayant une estimation de 130 ticks (en fait, ce sera beaucoup plus conservateur), le client peut décider si une telle valeur de distorsion lui convient ou non </li><li>  Les valeurs TSC mesurées séquentiellement sur des CPU identiques ou différents augmentent-elles?  Voici l'idée.  Disons que nous avons plusieurs processeurs.  Supposons que leur horloge soit synchronisée et qu'elle coche à la même fréquence.  Ensuite, si vous mesurez d'abord le temps sur un processeur, puis le mesurez à nouveau - déjà sur l'un des processeurs disponibles - le deuxième chiffre doit être plus grand que le premier. <br><br>  J'appellerai cette estimation en dessous de l'estimation de la monotonie TSC <br></li></ol><br>  Voyons maintenant comment obtenir la première estimation: <br><br><ol><li>  l'un des processeurs disponibles pour le processus est déclaré «de base» </li><li>  puis tous les autres CPU sont triés, et pour chacun d'eux le décalage est calculé: <code>TSC___CPU – TSC___CPU</code> .  Cela se fait comme suit: <br><ul><li>  a) trois valeurs mesurées sont prises séquentiellement (l'une après l'autre!): <code>TSC_base_1, TSC_current, TSC_base_2</code> .  Ici, le courant indique que la valeur a été mesurée sur le CPU actuel et la base sur la base </li><li>  b) le décalage <code>TSC___CPU – TSC___CPU</code> doit se situer dans l'intervalle <code>[TSC_current – TSC_base_2, TSC_current – TSC_base_1]</code> .  C'est sous l'hypothèse que les TSC cochent à la même fréquence sur les deux CPU. </li><li>  c) les étapes a) -b) sont répétées plusieurs fois.  L'intersection de tous les intervalles obtenus à l'étape b) est calculée.  L'intervalle résultant est considéré comme l'estimation du décalage <code>TSC___CPU – TSC___CPU</code> </li></ul><br></li><li>  après avoir obtenu une estimation de décalage pour chaque CPU par rapport à la base, il est facile d'obtenir une estimation du décalage maximum entre tous les CPU disponibles: <br><ul><li>  a) l'intervalle minimum est calculé, ce qui inclut tous les intervalles résultants obtenus à l'étape 2 </li><li>  b) la largeur de cet intervalle est considérée comme l'estimation du décalage maximal entre les TSCs cocher sur différents CPU </li></ul><br></li></ol><br>  Pour évaluer la monotonie dans la bibliothèque, l'algorithme suivant est implémenté: <br><br><ol><li>  Disons qu'un processus a N CPU disponible </li><li>  Mesurer TSC sur CPU1 </li><li>  Mesurer TSC sur CPU2 </li><li>  ... </li><li>  Mesurer TSC sur CPUN </li><li>  Mesurer à nouveau TSC sur CPU1 </li><li>  Nous vérifions que les valeurs mesurées augmentent de façon monotone du premier au dernier </li></ol><br>  Il est important ici que les première et dernière valeurs soient mesurées sur la même CPU.  Et voici pourquoi.  Disons que nous avons 3 processeurs.  Supposons que le TSC sur CPU2 soit décalé de +100 ticks par rapport au TSC sur CPU1.  Supposons également que le TSC sur CPU3 soit décalé de +100 ticks par rapport au TSC sur CPU2.  Considérez la chaîne d'événements suivante: <br><br><ul><li>  Lisez le TSC sur CPU1.  Soit une valeur de 10 </li><li>  2 ticks passés </li><li>  Lisez TSC sur CPU2.  Doit être 112 </li><li>  2 ticks passés </li><li>  Lisez TSC sur CPU3.  Doit être 214 </li></ul><br>  Jusqu'à présent, l'horloge semble synchronisée.  Mais mesurons à nouveau le TSC sur CPU1: <br><br><ul><li>  2 ticks passés </li><li>  Lisez le TSC sur CPU1.  Doit avoir 16 ans </li></ul><br>  Oups!  La monotonie est rompue.  Il s'avère que la mesure des première et dernière valeurs sur le même CPU permet de détecter des décalages plus ou moins importants entre les horloges.  La question suivante, bien sûr: "Quelle est l'ampleur des changements?"  La quantité de décalage qui peut être détectée dépend du temps qui s'écoule entre les mesures TSC successives.  Dans l'exemple donné, ce ne sont que 2 ticks.  Les décalages entre les heures dépassant 2 ticks seront détectés.  De manière générale, les décalages inférieurs au temps écoulé entre les mesures successives ne seront pas détectés.  Ainsi, plus les mesures sont localisées dans le temps, mieux c'est.  La précision des deux estimations en dépend.  Plus les mesures sont denses: <br><br><ul><li>  plus l'estimation du décalage maximal est faible </li><li>  plus la confiance dans l'évaluation de la monotonie </li></ul><br>  Dans la section suivante, nous verrons comment prendre des mesures précises.  J'ajoute ici que lors du calcul des estimations de fiabilité TSC, la bibliothèque effectue de nombreuses vérifications plus simples des "poux", par exemple: <br><br><ul><li>  vérification limitée que les TSC sur différents processeurs fonctionnent à la même vitesse </li><li>  vérifier que les compteurs changent vraiment au fil du temps, et pas seulement montrer la même valeur </li></ul><br><h3>  Deux méthodes de collecte des contre-valeurs </h3><br>  Dans la bibliothèque, j'ai implémenté deux méthodes pour collecter les valeurs TSC: <br><br><ol><li>  <b>Basculez entre les CPU</b> .  Dans cette méthode, toutes les données nécessaires pour évaluer la fiabilité du TSC sont collectées par un seul thread qui «saute» d'un CPU à l'autre.  Les deux algorithmes décrits dans la section précédente conviennent à cette méthode et ne conviennent pas à l'autre. <br>  La «commutation entre les CPU» n'a aucune utilité pratique.  La méthode a été mise en œuvre juste pour "jouer".  Le problème avec la méthode est que le temps nécessaire pour «faire glisser» un flux d'un CPU à un autre est très important.  En conséquence, beaucoup de temps s'écoule entre les mesures TSC successives et la précision des estimations est très faible.  Par exemple, une estimation typique du décalage maximum entre TSC est obtenue dans la région de 23 000 ticks. <br><br>  Cependant, la méthode présente deux avantages: <br><ul><li>  c'est absolument déterministe.  Si vous avez besoin de mesurer TSC séquentiellement sur CPU1, CPU2, CPU3, alors nous le prenons et le faisons: passer à CPU1, lire TSC, passer à CPU2, lire TSC et enfin, passer à CPU3, lire TSC </li><li>  vraisemblablement, si le nombre de CPU dans le système augmente très rapidement, le temps de commutation entre eux devrait augmenter beaucoup plus lentement.  Par conséquent, en théorie, apparemment, un système peut exister - un très grand système!  - dans lequel l'utilisation de la méthode sera justifiée.  Mais c'est encore peu probable </li></ul><br></li><li>  <b>Mesures commandées en utilisant CAS</b> .  Dans cette méthode, les données sont collectées en parallèle par plusieurs threads.  Chaque CPU disponible démarre un thread.  Les mesures prises par différents threads sont organisées en une seule séquence à l'aide de l'opération «comparer et échanger».  Ci-dessous est un morceau de code qui montre comment cela se fait. <br>  L'idée de la méthode est empruntée à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fio</a> , un outil populaire pour générer des charges d'E / S. <br><br>  Les estimations de fiabilité obtenues avec la puissance de cette méthode semblent déjà plutôt bonnes.  Par exemple, une estimation du décalage maximum est déjà obtenue au niveau de plusieurs centaines de ticks.  Une vérification de la monotonie vous permet de rattraper l'horloge désynchronisée au sein de centaines de ticks. <br><br>  Cependant, les algorithmes donnés dans la section précédente ne conviennent pas à cette méthode.  Il est important pour eux que les valeurs TSC soient mesurées dans un ordre prédéterminé.  La méthode des «mesures ordonnées par CAS» ne le permet pas.  Au lieu de cela, une longue séquence de mesures aléatoires est d'abord collectée, puis des algorithmes (déjà différents) tentent de trouver des valeurs lues sur des processeurs «appropriés» dans cette séquence. <br><br>  Je ne donnerai pas ces algorithmes ici, afin de ne pas abuser de votre attention.  Vous pouvez les voir dans le code.  Il y a beaucoup de commentaires.  En théorie, ces algorithmes sont les mêmes.  Un point fondamentalement nouveau est la vérification de la façon dont les séquences TSC de type aléatoire sont statistiquement «qualitatives».  Il est également possible de fixer un niveau minimum acceptable de signification statistique pour les estimations de fiabilité du TSC. <br><br>  Théoriquement, sur de TRÈS grands systèmes, la méthode «ordonnée CAS» peut donner de mauvais résultats.  La méthode exige que les processeurs se disputent l'accès à un emplacement de mémoire commun.  S'il y a beaucoup de processeurs, la concurrence peut s'avérer très intense.  En conséquence, il sera difficile de créer une séquence de mesure avec de bonnes propriétés statistiques.  Cependant, pour le moment, cette situation semble peu probable. <br></li></ol><br>  J'ai promis du code.  Voici à quoi cela ressemble de construire des mesures dans une seule chaîne en utilisant CAS. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; arg-&gt;probes_count; i++ ) { <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> seq_num = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> tsc_val = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { __atomic_load( seq_counter, &amp;seq_num, __ATOMIC_ACQUIRE); __sync_synchronize(); tsc_val = WTMLIB_GET_TSC(); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( !__atomic_compare_exchange_n( seq_counter, &amp;seq_num, seq_num + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, __ATOMIC_ACQ_REL, __ATOMIC_RELAXED)); arg-&gt;tsc_probes[i].seq_num = seq_num; arg-&gt;tsc_probes[i].tsc_val = tsc_val; }</code> </pre><br>  Ce code est exécuté sur chaque CPU disponible.  Tous les threads ont accès à la variable partagée <code>seq_counter</code> .  Avant de lire le TSC, le flux lit la valeur de cette variable et la stocke dans la variable <code>seq_num</code> .  Lit ensuite TSC.  Il essaie ensuite d'augmenter atomiquement seq_counter de un, mais uniquement si la valeur de la variable n'a pas changé depuis sa lecture.  Si l'opération réussit, cela signifie que le thread a réussi à « <code>seq_num</code> » le numéro de séquence stocké dans <code>seq_num</code> derrière la valeur TSC mesurée.  Le prochain numéro de série, qui pourra être implanté (peut-être déjà dans un autre thread) en sera un de plus.  Pour ce nombre est tiré de la variable <code>seq_counter</code> , et chaque appel réussi de <code>__atomic_compare_exchange_n()</code> augmente cette variable d'une <code>__atomic_compare_exchange_n()</code> . <br><br><div class="spoiler">  <b class="spoiler_title">__atomique avec __sync ???</b> <div class="spoiler_text">  Pour des raisons d' <code>__atomic</code> , il convient de noter que l'utilisation des fonctions intégrées de la famille <code>__atomic</code> avec une fonction de la famille obsolète <code>__sync</code> semble moche.  <code>__sync_synchronize()</code> utilisé dans le code pour éviter de réordonner l'opération de lecture TSC avec l'opération en amont.  Cela nécessite une barrière de mémoire complète.  La famille <code>__atomic</code> n'a formellement pas de fonction avec les propriétés correspondantes.  Bien qu'il existe en fait: <code>__atomic_signal_fence()</code> .  Cette fonction organise les calculs de flux avec des gestionnaires de signaux qui s'exécutent sur le même flux.  En fait, c'est une barrière complète.  Cependant, cela n'est pas explicitement indiqué.  Et je préfère le code qui n'a pas de sémantique cachée.  Par conséquent, <code>__sync_synchronize()</code> est une barrière de mémoire stop-full. <br></div></div><br>  Un autre point à mentionner ici est le soin que tous les flux impliqués dans les mesures démarrent plus ou moins simultanément.  Nous sommes intéressés par le fait que les valeurs TSC lues sur différents CPU sont aussi mélangées que possible.  Nous ne sommes pas satisfaits de la situation où, par exemple, un thread démarre en premier, termine son travail, puis seulement tous les autres démarrent.  La séquence TSC résultante aura des propriétés inutiles.  Aucune estimation ne peut en être tirée.  Le démarrage simultané de tous les threads est important - et pour cela, des mesures ont été prises dans la bibliothèque. <br><br><h3>  Convertissez les ticks en nanosecondes à la volée </h3><br>  Après avoir vérifié la fiabilité de TSC, le deuxième objectif majeur de la bibliothèque est de convertir les ticks en nanosecondes à la volée.  J'ai emprunté l'idée de cette conversion au fio déjà mentionné.  Cependant, j'ai dû apporter des améliorations significatives, car, comme mon analyse l'a montré, en soi, la procédure de conversion ne fonctionne pas assez bien.  Là, vous obtenez une faible précision. <br><br>  Je vais commencer par un exemple. <br><br>  Idéalement, je voudrais convertir les ticks en nanosecondes comme ceci: <br> <code>ns_time = tsc_ticks / tsc_per_ns</code> <br>  Nous voulons que le temps consacré à la conversion soit minimal.  Par conséquent, nous visons à utiliser exclusivement l'arithmétique entière.  Voyons comment cela peut nous menacer. <br><br>  Si <code>tsc_per_ns = 3</code> , alors une simple division entière, du point de vue de la précision, fonctionne très bien: <code>ns_time = tsc_ticks / 3</code> . <br><br>  Mais que faire si <code>tsc_per_ns = 3.333</code> ?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si ce nombre est arrondi à 3, la précision de conversion sera très faible. Pour remédier à </font><font style="vertical-align: inherit;">ce problème comme suit: </font></font><br> <code>ns_time = (tsc_ticks * factor) / (3.333 * factor)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si le facteur </font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est suffisamment grand, la précision sera bonne. Mais quelque chose restera mauvais. A savoir, les frais généraux de conversion. La division entière est une opération très coûteuse. Par exemple, sur x86, il nécessite plus de 10 cycles d'horloge. De plus, les opérations de division entière ne sont pas toujours en pipeline. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous réécrivons notre formule sous la forme équivalente </font></font><br> <code>ns_time = (tsc_ticks * factor / 3.333) / factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La première division n'est pas un problème. Nous pouvons pré </font></font><code>(factor / 3.333)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">calculer </font><font style="vertical-align: inherit;">à l'avance. Mais la deuxième division fait toujours mal. Pour se débarrasser d'elle, choisissons</font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">égal à la puissance de deux. Après cela, la deuxième division peut être remplacée par un décalage de bits - une opération simple et rapide. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle taille pouvez-vous choisir </font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Malheureusement, </font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il ne peut pas être arbitrairement important. Elle est limitée par la condition selon laquelle la multiplication dans le numérateur ne doit pas conduire à un débordement de type 64 bits. Oui, nous voulons utiliser uniquement des types «natifs». Encore une fois, pour réduire les frais généraux de conversion au minimum. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voyons maintenant sa taille </font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans notre exemple spécifique. Supposons que nous voulons travailler avec des intervalles de temps allant jusqu'à un an. Au </font><font style="vertical-align: inherit;">cours de </font><font style="vertical-align: inherit;">l'année, TSC tiknet les temps suivants: </font></font><code>3.333 * 1000000000 * 60 * 60 * 24 * 365 = 105109488000000000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Diviser une valeur maximale du numéro de type 64 bits est la suivante </font><font style="vertical-align: inherit;">: </font></font><code>18446744073709551615 / 105109488000000000 ~ 175.5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Donc l'expression</font></font><code>(factor / 3.333)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne doit pas dépasser cette valeur. Ensuite , </font><font style="vertical-align: inherit;">nous avons </font></font><code>factor &lt;= 175.5 * 3.333 ~ 584.9</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. La plus grande puissance de deux qui ne dépasse pas ce nombre est 512. Par conséquent, notre formule de conversion prend la forme: </font></font><br><br> <code>ns_time = (tsc_ticks * 512 / 3.333) / 512</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ou:</font></font><br><br> <code>ns_time = tsc_ticks * 153 / 512</code> <br> <br>  Super.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voyons maintenant ce que cette formule a avec précision. Un an contient des </font></font><code>1000000000 * 60 * 60 * 24 * 365 = 31536000000000000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nanosecondes. Notre formule donne: </font></font><code>105109488000000000 * 153 / 512 = 31409671218750000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. La différence avec la valeur actuelle est de 126328781250000 nanosecondes ou </font></font><code>126328781250000 / 1000000000 / 60 / 60 ~ 35</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">heures. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est une grosse erreur. Nous voulons une meilleure précision. Et si nous mesurons des intervalles de temps ne dépassant pas une heure? Je vais omettre les calculs. Ils sont complètement identiques à ceux qui viennent d'être réalisés. La formule finale sera: </font></font><br><br> <code>ns_time = tsc_ticks * 1258417 / 4194304</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'erreur de conversion ne sera que de 119 305 nanosecondes pendant 1 heure (ce qui est inférieur à 0,2 millisecondes). Très, très bien. Si la valeur convertible maximale est encore inférieure à une heure, la précision sera encore meilleure. Mais comment utilisons-nous cela? Ne limitez pas les mesures de temps à une heure? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faisons attention au moment suivant:</font></font><br><br> <code>tsc_ticks = (tsc_ticks_per_1_hour * number_of_hours) + tsc_ticks_remainder</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous calculons </font></font><code>tsc_ticks_per_1_hour</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous pouvons extraire </font></font><code>number_of_hours</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de </font></font><code>tsc_ticks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ensuite, nous savons combien de nanosecondes sont contenues en une heure. Il ne nous sera donc pas difficile de traduire en nanosecondes la partie </font></font><code>tsc_ticks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">correspondant à un nombre entier d'heures. Pour terminer la conversion, nous devrons traduire en nanosecondes </font></font><code>tsc_ticks_remainder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Cependant, nous savons que ce nombre de tiques est arrivé en moins d'une heure. Donc, pour le convertir en nanosecondes, nous pouvons utiliser la formule (1). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est fait. Un tel mécanisme de conversion nous convient. Résumons-le et optimisons-le maintenant. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout d'abord, nous voulons avoir un contrôle flexible sur les erreurs de conversion. Nous ne voulons pas lier les paramètres de conversion à un intervalle de temps de 1 heure. Soit un intervalle de temps arbitraire:</font></font><br><br> <code>tsc_ticks = modulus * number_of_moduli_periods + tsc_ticks_remainder</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rappelons une fois de plus comment convertir le reste en nanosecondes: </font></font><br><br> <code>ns_per_remainder = (tsc_ticks_remainder * factor / tsc_per_nsec) / factor</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calculer les paramètres de conversion (on le sait </font></font><code>tsc_ticks_remainder &lt; modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">): </font><font style="vertical-align: inherit;">Par souci d'ennui, il faut noter que la dernière inégalité n'est pas équivalente à la première dans le cadre de l'arithmétique entière. Mais je ne m'y attarderai pas longtemps. Je peux seulement dire que la dernière inégalité est plus grave que la première, et donc sûre à utiliser. </font><font style="vertical-align: inherit;">Après avoir obtenu de la dernière inégalité </font><font style="vertical-align: inherit;">, nous calculons: </font><font style="vertical-align: inherit;">Et puis ces paramètres sont utilisés pour convertir le reste en nanosecondes: </font><font style="vertical-align: inherit;">Donc, nous </font><font style="vertical-align: inherit;">avons calculé </font><font style="vertical-align: inherit;">la conversion du reste. Le prochain problème à résoudre - est l'extraction </font><font style="vertical-align: inherit;">et </font><font style="vertical-align: inherit;">de la</font></font><br><br> <code>modulus * (factor / tsc_per_nsec) &lt;= UINT64_MAX <br> factor &lt;= (UINT64_MAX / modulus) * tsc_per_nsec <br> 2 ^ shift &lt;= (UINT64_MAX / modulus) * tsc_per_nsec <br></code> <br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><code>shift</code><font style="vertical-align: inherit;"></font><br><br> <code>factor = 2 ^ shift <br> mult = factor / tsc_per_nsec <br></code> <br><br><font style="vertical-align: inherit;"></font><br><br> <code>ns_per_remainder = (tsc_ticks_remainder * mult) &gt;&gt; shift <br></code> <br><br><font style="vertical-align: inherit;"></font><code>tsc_ticks_remainder</code><font style="vertical-align: inherit;"></font><code>number_of_moduli_periods</code><font style="vertical-align: inherit;"></font><code>tsc_ticks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Comme toujours, nous voulons le faire rapidement. </font><font style="vertical-align: inherit;">Comme toujours, nous ne voulons pas utiliser la division. </font><font style="vertical-align: inherit;">Par conséquent, nous choisissons simplement </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">égal à la puissance de deux: </font></font><br><br> <code>modulus = 2 ^ remainder_bit_length</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alors:</font></font><br><br> <code>number_of_moduli_periods = tsc_ticks &gt;&gt; remainder_bit_length <br> tsc_ticks_remainder = tsc_ticks &amp; (modulus - 1)</code> <br> <br>  Super.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous savons maintenant comment extraire de </font></font><code>tsc_ticks</code> <code>number_of_moduli_periods</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>tsc_ticks_remainder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Et nous savons comment convertir </font></font><code>tsc_ticks_remainder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en nanosecondes. </font><font style="vertical-align: inherit;">Il reste à comprendre comment convertir cette partie des ticks, qui est un multiple, en nanosecondes </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mais tout est simple: </font></font><br><br> <code>ns_per_moduli = ns_per_modulus * number_of_moduli_periods</code> <br> <br> <code>ns_per_modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vous pouvez calculer à l'avance. </font><font style="vertical-align: inherit;">De plus, selon la même formule par laquelle nous convertissons le reste. </font><font style="vertical-align: inherit;">Cette formule peut être utilisée pour des périodes qui ne dépassent pas </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Lui </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">même </font><font style="vertical-align: inherit;">, bien sûr, pas plus que </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br> <code>ns_per_modulus = (modulus * mult) &gt;&gt; shift</code> <br> <br>  C’est tout!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons pu calculer tous les paramètres nécessaires pour convertir les tiques en nanosecondes à la volée. </font><font style="vertical-align: inherit;">Résumons maintenant brièvement la procédure de conversion:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous avons </font></font><code>tsc_ticks</code> </li><li> <code>number_of_moduli_periods = tsc_ticks &gt;&gt; remainder_bit_length</code> </li> <li> <code>tsc_ticks_remainder = tsc_ticks &amp; (modulus - 1)</code> </li> <li> <code>ns = ns_per_modulus * number_of_moduli_periods + (tsc_ticks_remainder * mult) &gt;&gt; shift</code> </li> </ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cette procédure, les </font><font style="vertical-align: inherit;">paramètres </font></font><code>remainder_bit_length</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>modulus, ns_per_modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>mult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>shift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avance de pré - </font><font style="vertical-align: inherit;">calcul. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous lisez toujours ce post, alors vous êtes super ou super. </font><font style="vertical-align: inherit;">Il est même possible que vous soyez un analyste des performances ou un développeur de logiciels hautes performances.</font></font><br><br>  Alors voilà.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il s'avère que nous n'avons pas encore fini :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rappelez-vous comment nous avons calculé le paramètre </font></font><code>mult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">C'était comme ça: </font></font><br><br> <code>mult = factor / tsc_per_nsec</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Question: d'où vient-il </font></font><code>tsc_per_nsec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le nombre de ticks dans une nanoseconde est une très petite valeur. </font><font style="vertical-align: inherit;">En fait, ma bibliothèque est </font></font><code>tsc_per_nsec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilisée à la </font><font style="vertical-align: inherit;">place </font></font><code>(tsc_per_sec / 1000000000)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">C'est-à-dire: </font></font><br><br> <code>mult = factor * 1000000000 / tsc_per_sec</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et il y a deux questions intéressantes:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et non </font></font><code>tsc_per_msec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, par exemple?</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Où les obtenir </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commençons par le premier. Fio utilise désormais le nombre de ticks par milliseconde. Et cela pose des problèmes. Sur la machine, les paramètres dont je cités ci - </font><font style="vertical-align: inherit;">dessus </font></font><code>tsc_per_msec = 2599998</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Alors </font></font><code>tsc_per_sec = 2599998971</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Si nous amenons ces nombres à une échelle, leur rapport sera très proche de l'unité: 0,999999626. Mais si nous utilisons le premier, et non le second, alors pour chaque seconde, nous aurons une erreur de 374 nanosecondes. Par conséquent - </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plus loin ... Comment compter </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela se fait sur la base d'une mesure directe: </font><font style="vertical-align: inherit;">«un certain temps» est un paramètre configurable. Elle peut être plus grande, plus petite ou égale à une seconde. Disons que c'est une demi-seconde. Supposons en outre que la différence réelle entre </font><font style="vertical-align: inherit;">et </font><font style="vertical-align: inherit;">s'est avérée être de 0,6 seconde. Alors </font><font style="vertical-align: inherit;">.</font></font><br><br> <code>start_sytem_time = clock_gettime() <br> start_tsc = WTMLIB_GET_TSC() <br>  -  <br> end_system_time = clock_gettime() <br> end_tsc = WTMLIB_GET_TSC() <br></code> <br><br><font style="vertical-align: inherit;"></font><code>end_system_time</code><font style="vertical-align: inherit;"></font><code>start_system_time</code><font style="vertical-align: inherit;"></font><code>tsc_per_sec = (end_tsc – start_tsc) / 0,6</code><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La bibliothèque considère plusieurs valeurs de cette manière </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Et puis, en utilisant des méthodes standard, il les «nettoie» du bruit statistique et reçoit une valeur unique à </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">laquelle on peut faire confiance. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le diagramme de mesure du temps ci-dessus, l'ordre des appels </font></font><code>clock_gettime()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et est </font><font style="vertical-align: inherit;">important </font></font><code>WTMLIB_GET_TSC()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Il est important </font></font><code>WTMLIB_GET_TSC()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que le même temps s'écoule entre deux appels qu'entre deux appels </font></font><code>clock_gettime()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Il sera alors possible de corréler facilement l'heure du système avec les ticks TSC. Et puis la dispersion des valeurs </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut vraiment être considérée comme aléatoire. Avec ce schéma de mesure, les valeurs </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s'écarteront de la valeur moyenne dans les deux sens avec la même probabilité. Et il sera possible de leur appliquer des méthodes de filtrage standard.</font></font><br><br><h3>  Conclusion </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est peut-être tout. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais le sujet de la mesure efficace du temps ne se limite pas à cela. </font><font style="vertical-align: inherit;">Il existe de nombreuses nuances. </font><font style="vertical-align: inherit;">Pour les personnes intéressées, je propose de travailler de manière indépendante sur les questions suivantes:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> stocker les paramètres de conversion dans le cache ou - mieux encore - sur les registres </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à quelles limites peut-on réduire </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(augmentant ainsi la précision de la conversion)?</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comme nous l'avons vu, la précision de la conversion est affectée non seulement </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais aussi par la taille de l'intervalle de temps, qui correspond aux ticks ( </font></font><code>tsc_per_msec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Comment équilibrer l'influence des deux facteurs?</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TSC dans la machine virtuelle. </font><font style="vertical-align: inherit;">Puis-je l'utiliser?</font></font></li><li>        . , fio        timespec.    : <br><br> <code>tp-&gt;tv_sec = nsecs / 1000000000ULL;</code> <br> <br> ,   TSC          .         ,  ,      <br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les méthodes discutées dans cet article nous permettent de mesurer l'échelle de temps d'une seconde avec une précision de l'ordre de plusieurs dizaines de nanosecondes. </font><font style="vertical-align: inherit;">C'est la précision que j'observe réellement lors de l'utilisation de ma bibliothèque. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fait intéressant, le fio, auquel j'ai emprunté certaines méthodes, perd exactement 700 à 900 nanosecondes sur une deuxième échelle (et il y a trois raisons à cela). </font><font style="vertical-align: inherit;">De plus, il perd en vitesse de conversion en raison du stockage du temps dans un format Linux standard. </font><font style="vertical-align: inherit;">Cependant, je m'empresse de rassurer les fans de fio. </font><font style="vertical-align: inherit;">J'ai envoyé aux développeurs une </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">description de tous les problèmes de conversion que j'ai découverts</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Les gens travaillent déjà, ils le répareront bientôt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je vous souhaite de nombreuses nanosecondes agréables!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr425237/">https://habr.com/ru/post/fr425237/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr425227/index.html">Les chercheurs ont trouvé un moyen de détecter et de contourner les clés Honeytoken dans un certain nombre de services Amazon.</a></li>
<li><a href="../fr425229/index.html">Comment nous avons aidé CDN MegaFon.TV à ne pas participer à la Coupe du monde 2018</a></li>
<li><a href="../fr425231/index.html">FAQ sur le travail d'une hôtesse de l'air</a></li>
<li><a href="../fr425233/index.html">Python 3 sur Facebook</a></li>
<li><a href="../fr425235/index.html">Un peu plus sur les graphiques, ou comment détecter les dépendances entre vos applications</a></li>
<li><a href="../fr425241/index.html">Développeur 20 ans plus tard: Vasily Lebedev sur ICRE, l'éducation, son livre et sa programmation</a></li>
<li><a href="../fr425243/index.html">Le manuel de John Willis</a></li>
<li><a href="../fr425245/index.html">Annonce de RamblerFront & # 6</a></li>
<li><a href="../fr425247/index.html">Crowdsourcing dans les tests</a></li>
<li><a href="../fr425249/index.html">Comment est la connaissance du LLP à l'Université ITMO: le cours "Programmation de bas niveau"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>