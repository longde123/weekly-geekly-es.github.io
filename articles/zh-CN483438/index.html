<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🔬 📦 🤵🏼 播放“ osu！”，不要忘记错误 📦 👩🏽‍🤝‍👨🏿 👩🏾‍🤝‍👨🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我们欢迎所有热衷于异国情调的人，并且在代码中没有错误。 如今，在测试台上，PVS-Studio确实是一个难得的来宾-C＃游戏。 即大须！ 和往常一样：寻找错误，思考，玩耍。 

 游戏 
 大须！ -开源音乐节奏游戏。 从游戏网站上的信息来看，它非常受欢迎，因为拥有1500万注册玩家。 该项目的特点...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>播放“ osu！”，不要忘记错误</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/483438/"><p><img src="https://habrastorage.org/getpro/habr/post_images/3ac/9da/a12/3ac9daa12b519fc14e45f7f65abdd204.png" alt="图片1" align="left"></p> 我们欢迎所有热衷于异国情调的人，并且在代码中没有错误。 如今，在测试台上，PVS-Studio确实是一个难得的来宾-C＃游戏。 即大须！ 和往常一样：寻找错误，思考，玩耍。 <br><a name="habracut"></a><br><h2> 游戏 </h2><br> 大须！  -开源音乐节奏游戏。 从<a href="https://osu.ppy.sh/home">游戏网站上</a>的信息来看，它非常受欢迎，因为拥有1500万注册玩家。 该项目的特点是免费玩法，具有自定义卡片功能的多彩设计，用于编制玩家在线排名的高级功能，多人游戏的存在以及大量音乐作品。 我不会详细描述游戏，有兴趣的人将很容易在网络上找到所有信息。 例如， <a href="https://en.wikipedia.org/wiki/Osu!">这里</a> 。 <br><br> 我对项目的源代码更感兴趣，可以从<a href="https://github.com/ppy/osu">GitHub</a>下载该源代码。 对存储库的大量提交（超过24000次提交）立即引起关注，这表明该项目的积极开发一直持续到今天（游戏于2007年发布，但工作可能较早开始）。 同时，没有太多源代码-1813 .cs文件包含13.5万行代码，不包括空行。 这段代码包含了我通常在检查中没有考虑到的测试。 测试代码包含在306个.cs文件中，因此，包含2.5万行代码，不包括空行。 这是一个小项目：为了进行比较，PVS-Studio分析仪的C＃核心包含大约30万行代码。 <br><br> 总体而言，为了检查游戏中的错误，我使用了包含1507个源代码文件和11万行的非测试项目。 但是，结果使我感到有些满意，因为我不得不告诉您一些有趣的错误。 <br><br><h2> 失误 </h2><br>  <a href="https://www.viva64.com/ru/w/v3001/">V3001</a>在'||'的左侧和右侧有相同的子表达式'result == HitResult.Perfect' 操作员。  DrawableHoldNote.cs 266 <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckForResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... ApplyResult(r =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (holdNote.hasBroken &amp;&amp; (result == HitResult.Perfect || result == HitResult.Perfect)) result = HitResult.Good; .... }); }</code> </pre> <br> 面向复制粘贴的编程的一个很好的例子。 我的同事Val​​ery Komarov最近在他的文章“ <a href="https://www.viva64.com/ru/b/0699/">2019年Java项目中的十大错误</a> ”中使用（引入）了一个漫画术语。 <br><br> 因此，两个相同的检查接连进行。 其中一项检查最有可能包含另一个<i>HitResult</i>枚举<i>常量</i> ： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> HitResult { None, Miss, Meh, Ok, Good, Great, Perfect, }</code> </pre> <br> 需要使用哪个特定常数，或者根本不需要第二检查？ 只有开发人员才能回答的问题。 无论如何，都会产生错误，使程序的逻辑失真。 <br><br>  <a href="https://www.viva64.com/ru/w/v3001/">V3001</a>在'&amp;&amp;'运算符的左侧和右侧有相同的子表达式'family！= GetFamilyString（TournamentTypeface.Aquatico）'。  TournamentFont.cs 64 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWeightString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> family, FontWeight weight</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight == FontWeight.Regular &amp;&amp; family != GetFamilyString(TournamentTypeface.Aquatico) &amp;&amp; family != GetFamilyString(TournamentTypeface.Aquatico)) weightString = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Empty; .... }</code> </pre> <br> 并再次复制粘贴。 我格式化了代码，因此错误很容易引起注意。 在原始版本中，整个条件写在一行中。 很难说如何固定代码。  <i>TournamentTypeface</i>枚举包含单个常量： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> TournamentTypeface { Aquatico }</code> </pre> <br> 该条件可能错误地使用了两次<i>家庭</i>变量，但这并不准确。 <br><br>  <a href="https://www.viva64.com/ru/w/v3009/">V3009</a> [CWE-393]奇怪的是，此方法始终返回一个相同的'false'值。  KeyCounterAction.cs 19 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPressed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T action, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> forwards</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!EqualityComparer&lt;T&gt;.Default.Equals(action, Action)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; IsLit = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (forwards) Increment(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br> 该方法将始终返回<i>false</i> 。 对于此类错误，我通常检查调用代码，因为它们通常只是在任何地方都不使用返回值，所以没有错误（丑陋的编程风格除外）。 在这种情况下，我遇到了以下代码： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPressed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T action</span></span></span><span class="hljs-function">)</span></span> =&gt; Target.Children .OfType&lt;KeyCounterAction&lt;T&gt;&gt;() .Any(c =&gt; c.OnPressed(action, Clock.Rate &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre> <br> 如您所见，使用了<i>OnPressed</i>方法返回的结果。 并且由于它始终为<i>false</i> ，所以调用<i>OnPressed</i>的结果也将始终为<i>false</i> 。 我认为您应该再次仔细检查此代码，因为发生错误的可能性很高。 <br><br> 另一个类似的错误： <br><br><ul><li>  V3009 [CWE-393]奇怪的是，此方法始终返回一个相同的'false'值。  KeyCounterAction.cs 30 </li></ul><br>  <a href="https://www.viva64.com/ru/w/v3042/">V3042</a> [CWE-476]可能为NullReferenceException。  '？。' 和“。” 运算符用于访问“ val.NewValue”对象TournamentTeam.cs的成员41 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TournamentTeam</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Acronym.ValueChanged += val =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) FlagName.Value = val.NewValue.Length &gt;= <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-comment"><span class="hljs-comment">// &lt;= ? val.NewValue?.Substring(0, 2).ToUpper() : string.Empty; }; .... }</span></span></code> </pre> <br> 在<i>？：</i>运算符的条件下，变量<i>val.NewValue</i>不安全。 分析器得出这样的结论，从那时起，在随后的分支中，使用安全选项通过条件访问<i>语句val.NewValue？.Substring（....）</i>来访问变量。 <br><br> 另一个类似的错误： <br><br><ul><li>  V3042 [CWE-476]可能为NullReferenceException。  '？。' 和“。” 运算符用于访问“ val.NewValue”对象TournamentTeam.cs的成员48 </li></ul><br>  <a href="https://www.viva64.com/ru/w/v3042/">V3042</a> [CWE-476]可能为NullReferenceException。  '？。' 和“。” 运算符用于访问“ api”对象SetupScreen.cs的成员77 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reload</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ActionableInfo { Label = <span class="hljs-string"><span class="hljs-string">"Current User"</span></span>, ButtonText = <span class="hljs-string"><span class="hljs-string">"Change Login"</span></span>, Action = () =&gt; { api.Logout(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }, Value = api?.LocalUser.Value.Username, .... }, .... } private class ActionableInfo : LabelledDrawable&lt;Drawable&gt; { .... public Action Action; .... }</span></span></code> </pre> <br> 这段代码不太清楚，但我认为错误仍然存​​在。 创建类型为<i>ActionableInfo</i>的对象。  <i>Action</i>字段使用lambda初始化，在该lambda的正文中，使用可能为空的引用<i>api</i>是不安全的。 分析器认为此模式是错误的，因为此后，在初始化<i>Value</i>参数时， <i>api</i>变量可以安全运行。 我称该错误为模棱两可，因为lambda代码假定执行延迟，然后，也许开发人员以某种方式保证<i>api</i>链接的值不为零。 但这只是一个假设，因为lambda主体不包含任何安全链接的迹象（例如，初步检查）。 <br><br>  <a href="https://www.viva64.com/ru/w/v3066/">V3066</a> [CWE-683]传递给“ Atan2”方法的参数的可能错误顺序：“ diff.X”和“ diff.Y”。  SliderBall.cs 182 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateProgress</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> completionProgress</span></span></span><span class="hljs-function">)</span></span> { .... Rotation = <span class="hljs-number"><span class="hljs-number">-90</span></span> + (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(-Math.Atan2(diff.X, diff.Y) * <span class="hljs-number"><span class="hljs-number">180</span></span> / Math.PI); .... }</code> </pre> <br> 分析器怀疑使用<i>Math</i>类的<i>Atan2</i>方法时，开发人员会混淆参数的顺序。  <i>Atan2广告</i> ： <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Parameters: // y: // The y coordinate of a point. // // x: // The x coordinate of a point. public static double Atan2(double y, double x);</span></span></code> </pre> <br> 如您所见，这些值以相反的顺序传输。 我无法判断这是否是一个错误，因为<i>UpdateProgress</i>方法包含许多非平凡的计算。 我只是注意到代码中可能存在问题的事实。 <br><br>  <a href="https://www.viva64.com/ru/w/v3080/">V3080</a> [CWE-476]可能的空解除引用。 考虑检查“ Beatmap”。  WorkingBeatmap.cs 57 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> Track </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetVirtualTrack</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastObject = Beatmap.HitObjects.LastOrDefault(); .... }</code> </pre> <br> 分析器指出了通过<i>Beatmap</i>空链接访问的危险。 这是什么： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IBeatmap Beatmap { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LoadBeatmapAsync().Result; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (TaskCanceledException) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } }</code> </pre> <br> 好吧，分析仪是正确的。 <br><br> 有关PVS-Studio如何发现此类错误以及与类似主题相关的C＃8.0创新（使用潜在的空引用）的更多信息，请参见文章“ <a href="https://www.viva64.com/ru/b/0631/">C＃8.0和静态分析中的可空引用类型</a> ”。 <br><br>  <a href="https://www.viva64.com/ru/w/v3083/">V3083</a> [CWE-367]事件'ObjectConverted'的不安全调用，可能会发生NullReferenceException。 请考虑在调用事件之前将事件分配给局部变量。  BeatmapConverter.cs 82 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertHitObjects</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ObjectConverted != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { converted = converted.ToList(); ObjectConverted.Invoke(obj, converted); } .... }</code> </pre> <br> 非关键且很常见的错误。 在检查事件是否为<i>空</i>及其调用之间，他们可以取消订阅该事件，这将导致程序崩溃。 <br> 解决方法之一： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertHitObjects</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... converted = converted.ToList(); ObjectConverted?.Invoke(obj, converted); .... }</code> </pre> <br>  <a href="https://www.viva64.com/ru/w/v3095/">V3095</a> [CWE-476]在验证是否为null之前，已使用“列”对象。 检查线：141，142。SquareGraph.cs 141 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">redrawProgress</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ColumnCount; i++) columns[i].State = i &lt;= progress ? ColumnState.Lit : ColumnState.Dimmed; columns?.ForceRedraw(); }</code> </pre> <br> 在循环中绕过<i>列</i>集合是不安全的。 同时，开发人员假定<i>column</i>链接可能为null，因为在代码的后面，使用了条件访问运算符来访问集合。 <br><br>  <a href="https://www.viva64.com/ru/w/v3119/">V3119</a>调用重写的事件'OnNewResult'可能导致不可预测的行为。 考虑显式实现事件访问器或使用“ sealed”关键字。  DrawableRuleset.cs 256 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addHitObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TObject hitObject</span></span></span><span class="hljs-function">)</span></span> { .... drawableObject.OnNewResult += (_, r) =&gt; OnNewResult?.Invoke(r); .... } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action&lt;JudgementResult&gt; OnNewResult;</code> </pre> <br> 分析仪警告使用覆盖事件或虚拟事件的危险。 确切的危险是什么-我建议阅读<a href="https://www.viva64.com/ru/w/v3119/">说明书中</a>进行诊断。 另外，有一次我写了一篇关于该主题的文章，“ <a href="https://www.viva64.com/ru/b/0453/">C＃中的虚拟事件：出了点问题”</a> 。 <br><br> 代码中的另一个类似的不安全构造： <br><br><ul><li>  V3119调用重写的事件可能导致不可预测的行为。 考虑显式实现事件访问器或使用“ sealed”关键字。  DrawableRuleset.cs 257 </li></ul><br>  <a href="https://www.viva64.com/ru/w/v3123/">V3123</a> [CWE-783]也许是“ ??” 操作员的工作方式与预期不同。 它的优先级低于其左侧的其他运营商的优先级。  OsuScreenStack.cs 45 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onScreenChange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IScreen prev, IScreen next</span></span></span><span class="hljs-function">)</span></span> { parallaxContainer.ParallaxAmount = ParallaxContainer.DEFAULT_PARALLAX_AMOUNT * ((IOsuScreen)next)?.BackgroundParallaxAmount ?? <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; }</code> </pre> <br> 为了更好地理解问题，我将给出一个代码示例的综合示例： <br><br><pre> <code class="cs hljs">x = (c * a) ?? b;</code> </pre> <br> 由于*运算符具有比??运算符更高的优先级，因此产生了错误。 更正的代码版本（添加了括号）： <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onScreenChange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IScreen prev, IScreen next</span></span></span><span class="hljs-function">)</span></span> { parallaxContainer.ParallaxAmount = ParallaxContainer.DEFAULT_PARALLAX_AMOUNT * (((IOsuScreen)next)?.BackgroundParallaxAmount ?? <span class="hljs-number"><span class="hljs-number">1.0f</span></span>); }</code> </pre> <br> 代码中的另一个类似错误： <br><br>  <a href="https://www.viva64.com/ru/w/v3123/">V3123</a> [CWE-783]也许是“ ??” 操作员的工作方式与预期不同。 它的优先级低于其左侧的其他运营商的优先级。  FramedReplayInputHandler.cs 103 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> inImportantSection { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IsImportant(frame) &amp;&amp; Math.Abs(CurrentTime - NextFrame?.Time ?? <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt;= AllowedImportantTimeSpan; } }</code> </pre> <br> 在这里，与前面的代码片段一样，没有考虑运算符的优先级。 现在，传递给<i>Math.Abs</i>方法的表达式的计算如下： <br><br><pre> <code class="cs hljs">(a – b) ?? <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br> 更正的代码： <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> inImportantSection { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IsImportant(frame) &amp;&amp; Math.Abs(CurrentTime – (NextFrame?.Time ?? <span class="hljs-number"><span class="hljs-number">0</span></span>)) &lt;= AllowedImportantTimeSpan; } }</code> </pre> <br>  <a href="https://www.viva64.com/ru/w/v3142/">V3142</a> [CWE-561]未检测到代码。 可能存在错误。  DrawableHoldNote.cs 214 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPressed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ManiaAction action</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnPressed(action)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Result.Type == HitResult.Miss) <span class="hljs-comment"><span class="hljs-comment">// &lt;= holdNote.hasBroken = true; .... }</span></span></code> </pre> <br> 分析器声称从第二个<i>if语句</i>开始的<i>OnPressed</i>处理程序<i>代码</i>不可访问。 这是基于第一个条件始终为true的假设，即<i>base.OnPressed</i>方法<i>将</i>始终返回<i>false</i> 。 看一下<i>base.OnPressed</i>方法： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPressed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ManiaAction action</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action != Action.Value) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UpdateResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre> <br> 我们继续执行<i>UpdateResult</i>方法： <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userTriggered</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Time.Elapsed &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Judged) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Judged; }</code> </pre> <br> 请注意，此处的<i>Judged</i>属性的实现并不重要，因为<i>UpdateResult</i>方法的逻辑意味着最后的<i>return语句</i>与此等效： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br> 因此， <i>UpdateResult</i>方法<i>将</i>始终返回<i>false</i> ，这将导致堆栈上方代码中的代码无法到达的错误。 <br><br>  <a href="https://www.viva64.com/ru/w/v3146/">V3146</a> [CWE-476]可能对'规则集'进行空引用。  “ FirstOrDefault”可以返回默认的空值。  APILegacyScoreInfo.cs 24 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ScoreInfo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateScoreInfo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RulesetStore rulesets</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ruleset = rulesets.GetRuleset(OnlineRulesetID); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mods = Mods != <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? ruleset.CreateInstance() <span class="hljs-comment"><span class="hljs-comment">// &lt;= .GetAllMods().Where(....) .ToArray() : Array.Empty&lt;Mod&gt;(); .... }</span></span></code> </pre> <br> 分析器认为<i>ruleset.CreateInstance（）</i>调用不安全。  <i>规则集</i>变量先前通过调用<i>GetRuleset来</i>获取值： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RulesetInfo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRuleset</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> =&gt; AvailableRulesets.FirstOrDefault(....);</code> </pre> <br> 如您所见，分析器警告是合理的，因为调用链包含<i>FirstOrDefault</i> ，它可以返回<i>null</i> 。 <br><br><h2> 结论 </h2><br> 通常，游戏项目“ osu！”对少量错误感到满意。 不过，我建议开发人员注意发现的问题。 并让游戏继续取悦其粉丝。 <br><br> 对于想深入研究代码的人，我想提醒您， <a href="https://www.viva64.com/ru/pvs-studio-download/">可以</a>从官方网站上轻松<a href="https://www.viva64.com/ru/pvs-studio-download/">下载</a>的PVS-Studio分析仪将是一个很好的帮助。 我还注意到，如上所述的一次性项目检查与在实际工作中使用静态分析器无关。 只有在构建服务器上和直接在开发人员的计算机上定期使用该工具（增量分析），才能实现最大的抗错误效率。 最大的目标是防止错误进入版本控制系统，修复在编写代码阶段已经存在的缺陷。 <br><br> 祝你好运，成功！ <br><br><h2> 参考文献 </h2><br> 这是2020年的第一本出版物。 借此机会，我将提供有关去年检查C＃项目的文章的链接： <br><br><ul><li>  <a href="https://www.viva64.com/ru/b/0605/">在Amazon Web Services SDK for .NET源代码中寻找错误</a> </li><li>  <a href="https://www.viva64.com/ru/b/0622/">检查Roslyn的源代码</a> </li><li>  <a href="https://www.viva64.com/ru/b/0631/">C＃8.0中的可空引用类型和静态分析</a> </li><li>  <a href="https://www.viva64.com/ru/b/0653/">WinForms：错误，福尔摩斯</a> </li><li>  <a href="https://www.viva64.com/ru/b/0654/">有关PVS-Studio如何在... PVS-Studio中使用的库中发现错误的故事</a> </li><li>  <a href="https://www.viva64.com/ru/b/0656/">通过PVS-Studio静态分析器验证.NET Core库的源代码</a> </li><li>  <a href="https://www.viva64.com/ru/b/0664/">检查罗斯林分析仪</a> </li><li>  <a href="https://www.viva64.com/ru/b/0677/">检查Telerik UI以获取UWP以了解PVS-Studio</a> </li><li>  <a href="https://www.viva64.com/ru/b/0678/">Azure PowerShell：“几乎无害”</a> </li><li>  <a href="https://www.viva64.com/ru/b/0681/">我们搜索并分析Orchard CMS代码中的错误</a> </li><li>  <a href="https://www.viva64.com/ru/b/0683/">使用PVS-Studio通过OpenCV检查OpenCvSharp包装器</a> </li><li>  <a href="https://www.viva64.com/ru/b/0692/">.NET的Azure SDK：困难的错误查找器的故事</a> </li><li>  <a href="https://www.viva64.com/ru/b/0694/">SARIF SDK及其错误</a> </li><li>  <a href="https://www.viva64.com/ru/b/0698/">2019年C＃项目中的十大bug</a> </li></ul><br><p> <a href="https://habr.com/en/company/pvs-studio/blog/483436/"><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br> 如果您想与讲英语的读者分享这篇文章，请使用以下链接：Sergey Khrenov。  <a href="https://habr.com/en/company/pvs-studio/blog/483436/">播放“ osu！”，但请注意错误</a> 。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN483438/">https://habr.com/ru/post/zh-CN483438/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN483418/index.html">票务系统：您如何获得三笔免费的OTRS付款？</a></li>
<li><a href="../zh-CN483424/index.html">DBA：在PostgreSQL数据库之间传输SEQUENCE值</a></li>
<li><a href="../zh-CN483426/index.html">星期五标签调查</a></li>
<li><a href="../zh-CN483428/index.html">电子签名法修正案生效后，电子文档管理将如何？</a></li>
<li><a href="../zh-CN483436/index.html">播放“ osu！”，但请注意错误</a></li>
<li><a href="../zh-CN483440/index.html">最新的D编译器</a></li>
<li><a href="../zh-CN483444/index.html">DORA报告2019：如何提高DevOps性能</a></li>
<li><a href="../zh-CN483446/index.html">科学家发现了一种降低饮用水中铁含量的新方法</a></li>
<li><a href="../zh-CN483448/index.html">迪士尼-人类历史上最伟大的双向</a></li>
<li><a href="../zh-CN483454/index.html">在Atlassian Bitbucket中从Mercurial切换到GIT，并用西里尔文保存文件</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>