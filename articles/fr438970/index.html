<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèø‚Äçü§ù‚Äçüßëüèª üë®üèº‚Äçü§ù‚Äçüë®üèª ü§¥ Haskell serait une langue pour les g√©nies et les universitaires. Non? ‚èèÔ∏è üêï üë©üèº‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="J'ai parl√© une fois avec le fondateur d'une startup isra√©lienne qui d√©veloppait une base de donn√©es GPU √† haute vitesse. Haskell et C ++ √©taient sur l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Haskell serait une langue pour les g√©nies et les universitaires. Non?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438970/"><img src="https://habrastorage.org/webt/o6/qs/0d/o6qs0dg9mgydyepqfcn6kpobfnc.jpeg"><br><br>  J'ai parl√© une fois avec le fondateur d'une startup isra√©lienne qui d√©veloppait une base de donn√©es GPU √† haute vitesse.  Haskell et C ++ √©taient sur leur pile, et le fondateur s'est plaint de la difficult√© de trouver des gens dans l'√©quipe.  Il s'est envol√© pour Moscou, notamment pour chercher de bons programmeurs. <br><br>  J'ai soigneusement demand√© s'il √©tait pr√©f√©rable d'utiliser quelque chose de plus commun et de nouveau.  Et bien que la r√©ponse ait √©t√© polie et constructive, entre les lignes, il m'a sembl√©: "Pff, ne parle m√™me pas de ces jouets." <br><br>  Tout ce que j'ai entendu parler de Haskell depuis ce moment-l√† se r√©sumait √† une chose - "les blagues sont mauvaises avec lui".  Pour mieux conna√Ætre les Haskellistes, je suis venu au chat t√©l√©gramme pour leur poser des questions.  C'√©tait assez effrayant, et en fin de compte, pas en vain. <br><br>  Ils ne veulent pas parler de Haskell de fa√ßon populaire, et il semble qu'ils envisagent ces entreprises avec m√©pris.  D√©j√† en train de parler - avec un maximum d'exhaustivit√© et d'objectivit√©.  ¬´L'une des qualit√©s caract√©ristiques de Haskell en tant que langue et communaut√© est qu'ensemble, ils n'ont pas cherch√© √† devenir populaires, donnant une r√©ponse simple aux questions populaires.  Au lieu de cela, ils ont construit une fa√ßon logique de r√©soudre des probl√®mes r√©els plut√¥t que de p√©n√©trer rapidement dans le c≈ìur d'un passant par une personne int√©ress√©e ¬ª, m'ont-ils √©crit l√†-bas. <br><br>  Cependant, plusieurs personnes ont partag√© leurs exp√©riences et j'ai rassembl√© leurs opinions ici. <br><a name="habracut"></a><br>  <b>Denis Mirzoev ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">nolane</a> )</b> : √Ä l'universit√©, sur le th√®me des ¬´langages de programmation¬ª, on m'a propos√© de suivre un cours √† Haskell Coursera pour un point suppl√©mentaire sur cent.  Ensuite, il y a eu un cours de programmation fonctionnelle au cours duquel Haskell a eu lieu.  Il a √©crit un article de fin d'√©tudes et un travail d'√©tudes sup√©rieures du baccalaur√©at sur GHC.  Trouv√© un emploi en tant que programmeur Haskell. <br><br>  C'√©tait dur, et toujours dur.  Lorsque vous commencez √† √©tudier Haskell, vous devez comprendre de nombreux nouveaux concepts.  C'est un travail difficile.  Vous r√©apprenez litt√©ralement √† programmer. <br><br>  Il sera difficile pour beaucoup maintenant de se rappeler comment ils ont commenc√© leur voyage dans la programmation, combien il √©tait difficile de comprendre ce qu'est un ¬´pointeur¬ª, ce qu'est une ¬´fonction¬ª, ce qu'est une ¬´classe¬ª.  C'est peut-√™tre la raison pour laquelle √©tudier Haskell est si difficile.  Avec l'√¢ge, il devient plus difficile d'apprendre de nouvelles choses. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : Une fois en p√©riode d'essai, je suis tomb√© dans Redux, alors en regardant les le√ßons de son cr√©ateur, j'ai d√©cid√© de mieux conna√Ætre tout le monde.  Au d√©but, j'ai appliqu√© les pratiques apprises en JavaScript, mais j'ai ensuite d√©couvert Haskell, qui est consid√©r√© comme un v√©ritable langage fonctionnel.  J'ai tout de suite √©t√© attir√©e par son √©l√©gance et un tas de nouveaux concepts qui m'√©taient inconnus. <br><br>  Ce n'√©tait pas facile avec des tutoriels sans fin sur les monades sur l'exemple des burritos, qui sont tr√®s d√©routants.  De plus, un contexte imp√©ratif rend difficile l'ouverture de nouveaux concepts. <br><br>  <b>Yuri Syrovetsky ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">cblp</a> )</b> : La chose la plus difficile √† apprendre est la seconde de Haskell, lorsque le syndrome du caneton n'est pas pass√© dans la premi√®re langue. <br><br><h2>  Qu'est-ce qui est bon et mauvais langage? </h2><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : Le langage est tr√®s concis, √©l√©gant et flexible, pas pour rien que la moiti√© des biblioth√®ques qu'il contient sont EDSL (au moins cette impression). <br><br>  <b>Yuri Syrovetsky ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">cblp</a> )</b> : haute expressivit√©, facile √† transf√©rer le domaine √† coder, combinaison optimale de paradigmes imp√©ratifs et fonctionnels.  Il est facile de construire des abstractions sur des donn√©es et des algorithmes, ce qui vous permet de penser au probl√®me sans √™tre distrait par de petites choses sans rapport. <br><br>  <b>John Doe</b> : typage strict fort (je dirais fasciste). <br><br>  <b>Igor Shevnin ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">interphx</a> )</b> : Un syst√®me de type tr√®s expressif.  Pas aussi puissant que Idris ou Agda, mais il atteint ce terrain d'entente quand presque tout peut √™tre exprim√©, et l'inf√©rence de type fonctionne bien.  Vous n'avez pas besoin de les marquer manuellement partout. <br><br>  Mais un syst√®me de type puissant vous fait pr√™ter attention aux valeurs transmises.  Un tas de d√©finitions de types pourrait ressembler √† un passe-partout.  Chaque √©quipe utilise son propre ensemble d'extensions ou ne les utilise pas du tout.  Le code est plus "dense" - une ligne contient souvent plus d'informations que dans d'autres langues, il est donc plus difficile pour un d√©veloppeur inexp√©riment√© de le lire. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : Lorsque vous √©tudiez Haskell, vous rencontrerez tr√®s probablement le dicton "si cela se compile, c'est probablement correct".  Il n'y a pas de null, le paradigme fonctionnel lui-m√™me est tr√®s strict et vous oblige √† suivre certaines r√®gles, qui dans la plupart des cas conduisent √† une meilleure conception. <br><br>  Par exemple, il n'y a pas de variables dans le langage, uniquement des constantes.  Vous n'avez pas √† garder une trace de quoi et o√π vous attribuez.  Haskell encourage l'utilisation de fonctions pures, ce qui n'entra√Æne aucun effet secondaire.  La conception fonctionnelle fait simplement fonctionner le programme dans son ensemble, contrairement √† la POO, o√π un tas d'objets sont jet√©s dans le monde et les objets essaient de communiquer les uns avec les autres par des effets secondaires, transformant l'application en un g√¢chis impr√©visible.  Au travail, nous en souffrons assez avec C # dans Unity. <br><br>  <b>Denis Mirzoev</b> : La paresse int√©gr√©e augmente l'expressivit√© de la langue.  De nombreux algorithmes deviennent plus faciles.  Il peut augmenter la productivit√© si les r√©sultats des calculs interm√©diaires ne sont pas utilis√©s.  (Par exemple, `head. Sort` fonctionne en temps lin√©aire). <br><br>  <b>Igor Shevnin</b> : Un mod√®le de calcul paresseux aide g√©n√©ralement, mais lorsque l'ordre des fonctions d'appel est important, il peut √™tre difficile de comprendre ce qui se passe. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : Il est compil√©, ce qui donne imm√©diatement une √©norme augmentation de vitesse. <br><br>  <b>Denis Mirzoev</b> : Compar√© √† Java en vitesse, mais pas aussi vite que C. <br><br>  <b>Igor Shevnin</b> : <b>Pr√™t √† l'emploi</b> , il existe un support pour les extensions qui vous permettent de terminer le syst√®me de langue et de type.  Cependant, il existe de nombreuses extensions largement utilis√©es qui sont famili√®res √† la communaut√©, ont des exemples et une documentation d√©cents et ne sont pas des niches. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : La biblioth√®que standard de Prelude a des fonctions tr√®s m√©diocres comme read, head, readFile, qui peuvent lever une exception et mettre dans un programme, au lieu de retourner peut-√™tre.  Par cons√©quent, vous devez utiliser des alternatives ou √©crire vos propres impl√©mentations. <br><br>  <b>Igor Shevnin</b> : Le principal probl√®me est le manque de standardisation, dans la mesure o√π beaucoup remplacent la biblioth√®que standard par l'une des alternatives incompatibles.  Il y a des d√©saccords dans la communaut√© sur ce qu'une biblioth√®que standard devrait √™tre, ce qui devrait √™tre inclus dans le noyau de la langue et ce qui devrait √™tre compl√©t√© par des extensions, et il me semble que cela ralentit le d√©veloppement de la langue. <br><br>  <b>Denis Mirzoev</b> : Il n'y a pas assez d'outils: il n'y a pas d'IDE √† part enti√®re, il y a tr√®s peu d'outils pour mesurer les performances, il n'y a pas de d√©bogage "pas √† pas" - c'est g√©n√©ralement un probl√®me fondamental. <br><br><h2>  Pour quels projets Haskell est-il le mieux adapt√©? </h2><br>  <b>Yuri Syrovetsky</b> : Pour les t√¢ches complexes li√©es √† la s√©curit√© ou √† l'argent, o√π le co√ªt des erreurs est √©lev√©. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : Pour tout ce dont vous avez besoin pour effectuer des calculs, des transformations et l'analyse de donn√©es.  Tr√®s surpris que Haskell soit moins populaire en Data Science que Python. <br><br>  <b>Igor Shevnin</b> : Je ne risquerais pas de l'utiliser pour des syst√®mes embarqu√©s (les performances ne sont pas mauvaises, mais il y a encore une surcharge importante pour la consommation de m√©moire en raison de calculs paresseux) et de petits scripts (cette rigueur n'est tout simplement pas n√©cessaire l√†-bas).  Vous devez √©galement comprendre qu'il est beaucoup plus difficile de trouver des d√©veloppeurs dans une √©quipe que pour les langages traditionnels. <br><br>  <b>John Doe</b> : Pour √©crire du code de l'industrie que d'autres liront, vous aurez besoin de toute une √©quipe de Haskellistes.  Ces quelques personnes ont r√©ussi √† se rassembler. <br><br>  <b>Igor Shevnin</b> : Mais en raison de sa bri√®vet√© et de sa rigueur, Haskell convient √† presque toutes les t√¢ches. <br><br><h2>  Commencer √† apprendre le d√©veloppement avec Haskell est une bonne id√©e? </h2><br>  Igor Shevnin: Il est peu probable que cela commence, car la grande majorit√© des bases de code avec lesquelles une personne devra travailler ne sont pas √©crites dessus. <br><br>  <b>John Doe</b> : Mauvaise, mauvaise id√©e!  Les langues non pas de la famille ML - mais des langues industrielles en g√©n√©ral - seront alors un choc pour vous. <br><br>  <b>Denis Mirzoev</b> : Habituellement, les gens √©tudient d'abord les math√©matiques, puis passent √† la programmation.  Par cons√©quent, l'apprentissage d'une langue √† l'aide de concepts math√©matiques (types de donn√©es alg√©briques, fonctions pures) devrait √™tre plus simple qu'imp√©ratif.  Autrement dit, je pense que c'est une bonne id√©e. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : Tous les nouveaux arrivants que je forme, je vais certainement vous pr√©senter Haskell.  Les gens qui n'ont pas √©tudi√© le style imp√©ratif sont beaucoup plus faciles √† naviguer dans le code fonctionnel et √† apprendre plus rapidement, puis m√™me s'ils travaillent avec des langages orient√©s objet, ils apportent de bonnes solutions architecturales et des pratiques fonctionnelles. <br><br>  <b>Yuri Syrovetsky</b> : il vaut mieux commencer tout de suite avec plusieurs langues fondamentalement diff√©rentes, par exemple, C, Haskell et Smalltok, dans n'importe quel ordre.  Pas une seule langue en <br>  s√©par√©ment ne donnera pas une compr√©hension compl√®te. <br><br><h2>  Haskell est une langue assez ancienne.  Est-ce bon ou mauvais? </h2><br>  Yuri Syrovetsky: Le langage se d√©veloppe tr√®s activement, la charge de compatibilit√© juste pour des raisons de compatibilit√© ne tire pas. <br><br>  <b>John Doe</b> : La norme a √©t√© adopt√©e en 1998, mais cela n'est pas perceptible: jusqu'√† pr√©sent, de nouvelles versions du compilateur, susceptibles de rompre la compatibilit√© descendante, sont publi√©es environ tous les six mois. <br><br>  <b>Denis Mirzoev</b> : Haskell n'est pas vieux, mais a fait ses preuves.  Des changements irr√©fl√©chis n'entreront jamais dans la langue.  C'est donc plut√¥t bien. <br><br><h2>  Haskell serait l'une des langues les plus complexes.  En est-il ainsi? </h2><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : Comme la langue elle-m√™me, non.  Les abstractions qui y sont utilis√©es sont plus probables.  Une personne qui n'a jamais vu le code Haskell peut simplement devenir folle avec le flux de nouvelles informations et diverses constructions inhabituelles. <br><br>  Le p√©trole ajoute au feu que le langage impose un tas de "restrictions", ne permet pas ou complique grandement un tas de choses qui ne rentrent pas dans un concept fonctionnel. <br><br>  <b>John Doe</b> : Pour que le premier projet √©l√©mentaire soit au moins compil√©, il a fallu pr√®s de deux mois pour fumer des manuels, des manuels et des tutoriels le soir.  Certes, apr√®s la compilation, le projet a imm√©diatement commenc√© √† fonctionner et les figues √† pleine charge (6k rps avec des pics jusqu'√† 15) pendant six mois, sans aucun changement. <br><br>  <b>Denis Mirzoev</b> : Je parie que si un √©tudiant commence √† √©tudier la programmation √† partir de Haskell et va assez loin, la programmation imp√©rative lui semblera plus compliqu√©e et moins intuitive. <br><br>  <b>Igor Shevnin</b> : La complexit√© est relative.  Parmi les langages traditionnels, je trouve toujours le C ++ le plus complexe.  Les langages de d√©monstration des th√©or√®mes (Agda, Coq) seront plus compliqu√©s que Haskell au sens conceptuel.  Haskell est un langage simple, mais ses mod√®les et biblioth√®ques - standard et tiers - peuvent √™tre apprises imm√©diatement. <br><br><h2>  Sa complexit√© est-elle toujours justifi√©e? </h2><br>  <b>Igor Shevnin</b> : Les mod√®les et un haut niveau d'abstraction sont justifi√©s, car ils rendent le code plus fiable et plus court.  Mais je pense que les op√©rateurs, les noms de fonction et bien d'autres choses pourraient √™tre plus clairs. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : Souvent, les constructions Haskell complexes vous permettent de cr√©er des solutions tr√®s courtes, qui s'av√®rent √©galement tr√®s flexibles et modulaires. <br><br>  <b>Yuri Syrovetsky</b> : Sauf que la gestion des effets est lourde, bien que presque <br>  c‚Äôest toujours mieux que le manque de contr√¥le.  Mais par trop simplifier <br>  les travaux sont en cours. <br><br>  <b>John Doe</b> : Le langage pour ceux qui sont habitu√©s au python / php / habituel le fait g√©n√©ralement sembler orthogonal √† la r√©alit√©.  Pour les personnes qui n'√©taient pas initialement int√©ress√©es par la th√©orie des cat√©gories, obtenir des r√©sultats √† partir du z√©ro absolu est tr√®s difficile. <br><br>  Mais lorsque vous comprenez la langue, vous obtenez une nouvelle fa√ßon de penser au probl√®me r√©solu. <br><br><h2>  Haskell semble √™tre un langage pour les math√©maticiens, pas pour les d√©veloppeurs.  Pensez-vous que ce n'est pas r√©pandu √† cause de cela? </h2><br>  <b>Denis Mirzoev</b> : Ceci est une d√©monstration du principe que les principaux d√©veloppeurs de Haskell suivent - ¬´√©viter le succ√®s √† tout prix¬ª.  Il ne s'agit bien s√ªr pas d'√©viter le succ√®s, mais d'√©viter le succ√®s dont le prix est trop √©lev√©. <br><br>  Haskell pourrait √™tre rendu populaire.  Par exemple, Microsoft prend en charge cette langue.  Il √©tait possible de rendre le langage plus imp√©ratif, de prendre des d√©cisions rapides et mal con√ßues pour gagner en popularit√©.  Il √©tait possible d'utiliser beaucoup de trucs sales, mais gr√¢ce √† une telle position des d√©veloppeurs principaux, il n'y avait rien de tel. <br><br>  Oui, la popularit√© de la langue n'est pas tr√®s √©lev√©e, mais sa qualit√© n'en souffre pas.  Les avantages de Haskell par rapport aux langues imp√©ratives sont √©vidents pour moi, la plupart de ses probl√®mes sont r√©solubles, donc je suis s√ªr qu'une grande popularit√© viendra √† mesure qu'elle se d√©veloppera. <br><br>  <b>Yuri Syrovetsky</b> : Il n'est donc vu que par des gens qui ne savent rien de lui.  Dans <br>  Haskell utilise le "vrai" d√©veloppement depuis longtemps, les exemples sont faciles √† trouver dans <br>  votre moteur de recherche pr√©f√©r√©.  En particulier, nous sommes en LC en utilisant <br>  Haskell est satisfait et nous ne voyons rien d'autre √† sa place. <br><br>  <b>Igor Shevnin</b> : Qu'est-ce qu'un "langage pour les math√©maticiens", je ne sais vraiment pas.  Il s'agit soit de R / MatLab / Mathematica pour les calculs et les statistiques, soit de Python, car il est simple et n√©cessite moins de connaissances en ing√©nierie.  Mais pas Haskell.  Des concepts alg√©briques tels que les mono√Ødes y sont utilis√©s pour des raisons pratiques, et pas seulement pour une rigueur suppl√©mentaire. <br><br>  Le r√¥le principal dans la popularit√© a √©t√© jou√© par la pr√©valence historique du C / C ++ / Java / C # dans l'entreprise, ils occupaient une niche.  Mais maintenant, de nombreuses entreprises commencent √† utiliser Haskell et d'autres langages fonctionnels. <br><br><h2>  √Ä quoi pensez-vous comparer Haskell et en faveur de qui? </h2><br>  <b>John Doe</b> : Plus ou moins commun - avec Erlang.  Mais Erlang est toujours plus facile √† √©crire et √† apprendre, me semble-t-il. <br><br>  <b>Denis Mirzoev</b> : Je connais bien C, C ++, Java et Haskell.  Le C ++ n'a m√™me pas besoin d'√™tre compar√© √† quoi que ce soit, le langage est terrible.  C est un bon langage pour le d√©veloppement de bas niveau.  Dans ce cr√©neau, il ira mieux.  Sinon, je pr√©f√©rerais Haskell. <br><br>  Le choix entre Java et Haskell est d√©j√† plus difficile, mais ici vous devez √©galement regarder une t√¢che sp√©cifique.  Pour Android sur Haskell, il sera probablement difficile d'√©crire, dans ce cas, Java est meilleur.  Mais le serveur pour √©crire en Haskell est presque aussi pratique qu'en Java.  Si l'environnement le permet - r√©glage, accessibilit√© des biblioth√®ques - alors je choisis habituellement Haskell. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : Avec C #, il suffit de google pour impl√©menter Maybe en C # et en Haskell.  Il est tr√®s √©trange que le Haskell dictatorial purement fonctionnel se sente beaucoup plus flexible et libre.  En fait, ce sont deux extr√™mes. <br><br>  C # est l'un des langages les plus orient√©s objet, et les avantages de Haskell sont en contraste frappant avec lui.  En C #, vous devez constamment √©crire un tas de choses inutiles, et tout cela est tr√®s d√©sagr√©able.  L'utilisation de fonctions d'ordre sup√©rieur peut g√¢cher le code en termes de syntaxe.  Au milieu de tout cela, il est d√©j√† difficile de revenir des solutions courtes et √©l√©gantes de Haskell. <br><br>  <b>Igor Shevnin</b> : Avec Rust, jusqu'ici en faveur de Rust.  Cela prend beaucoup de Haskell et d'autres langages FP, mais en m√™me temps, l'approche fonctionnelle est amicale avec l'imp√©ratif, et les d√©veloppeurs et la communaut√© sont beaucoup plus comp√©tents et plus coh√©rents dans le d√©veloppement du langage d√®s le d√©but. <br><br><h2>  Que pensez-vous de la communaut√© haskelliste? </h2><br>  <b>John Doe</b> : La grande majorit√© sont des gens tr√®s sympathiques qui sont toujours pr√™ts √† aider.  Une belle diff√©rence avec les communaut√©s de nombreuses autres langues. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : Les communaut√©s Haskell contiennent souvent des gens <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">extr√™mement</a></b> effrayants qui sont toujours pr√™ts √† aider.  Ce n'est pas pour rien que les m√®mes locaux sur le doctorat, la th√©orie des cat√©gories et les universitaires vont.  Si vous entrez dans le chat dans d'autres langues, vous voyez que les gens discutent des probl√®mes de production ordinaires et des structures de donn√©es.  Dans une conversation Haskell, des monades, le lemme de Yoneda, des foncteurs applicatifs, des types fous, etc., apparaissent imm√©diatement devant vous. <br><br>  Vous voyez imm√©diatement tellement de nouveaut√©s que vous ne connaissiez pas auparavant - compositions folles, transformations et transformations √©l√©gantes, solutions √† des probl√®mes qui occupent des dizaines de lignes dans les langues traditionnelles, presque en une seule ligne. <br><br><h2>  Ils disent que les Haskellistes sont arrogants.  Non? </h2><br>  <b>Denis Mirzoev</b> : Oui.  Il me semble que l'arrogance est due au fait qu'ils aiment vraiment leur langue et sont boulevers√©s par sa sous-estimation. <br><br>  <b>John Doe</b> : Nifiga comme √ßa. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : Tr√®s probablement, cette opinion a disparu, car de nombreux d√©veloppeurs grand public sont tr√®s ennuy√©s lorsque les Haskelists commencent √† parler de la programmation fonctionnelle et de ses avantages.  Un terrible malentendu, √† son tour, peut agacer le Haskelist lui-m√™me, et il commencera √† se pr√©cipiter en termes, pour lesquels il est stigmatis√© par la FAQ. <br><br>  <b>Igor Shevnin</b> : L'arrogance est un mot trop fort.  Le point ici est plut√¥t que FP, OOP, la diff√©rence entre les classes OOP et les types d'union, le probl√®me d'extension et de nombreux autres concepts s'ajoutent une fois √† une image tr√®s claire, et apr√®s cela, il devient difficile de percevoir les personnes qui essaient de s'opposer √† OOP et FI ou imaginent autrement probl√®me r√©pandu dans une perspective √©troite. <br><br><h2>  Pourquoi les langues FP sont-elles encore des niches? </h2><br>  <b>Denis Mirzoev</b> : Leurs avantages ne sont pas encore suffisants pour int√©resser un grand nombre de programmeurs.  La difficult√© d'apprentissage n'est pas propice √† la popularit√©.  Les probl√®mes de r√©glage en effrayent √©galement beaucoup, mais il me semble que l'augmentation de la taille de la communaut√© pourrait r√©soudre ce probl√®me.  Il en r√©sulte un cercle vicieux. <br><br>  <b>Igor Shevnin</b> : La niche passe progressivement et les concepts fonctionnels sont tir√©s vers d'autres langues. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Doctor_Ryner</a></b> : Les principes fonctionnels eux-m√™mes et les langages qui les prennent en charge sont d√©j√† omnipr√©sents.  M√™me pour les objets tranchants, il existe Linq et quelques autres biblioth√®ques.  Les cr√©neaux sont des langages plut√¥t purement fonctionnels, car ils utilisent des concepts non standard. <br><br>  N'oubliez pas qu'il y a 20 ans, le fer n'√©tait pas suffisamment productif pour les langages fonctionnels, de sorte que le fonctionnalisme a commenc√© √† entrer dans le courant dominant ces derni√®res ann√©es, et l'int√©r√™t pour Haskell ne fait que cro√Ætre. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr438970/">https://habr.com/ru/post/fr438970/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr438960/index.html">Comment j'ai abandonn√© Ruby en faveur de Python tout en travaillant sur un backend</a></li>
<li><a href="../fr438962/index.html">Pour la plupart, des perspectives positives pour l'avenir des puces</a></li>
<li><a href="../fr438964/index.html">Qui est vraiment derri√®re les VPN gratuits populaires?</a></li>
<li><a href="../fr438966/index.html">Historique des errances de la documentation Haproxy, ou ce qu'il faut rechercher lors de sa configuration</a></li>
<li><a href="../fr438968/index.html">Marquage des chaussures en Russie: le march√© n'est pas pr√™t, mais devra fonctionner</a></li>
<li><a href="../fr438972/index.html">Le cerveau de l'int√©rieur (visualisation du passage du motif √† travers le mod√®le de r√©seau de neurones artificiels)</a></li>
<li><a href="../fr438974/index.html">La r√©alit√© virtuelle aide √† faire face aux troubles mentaux</a></li>
<li><a href="../fr438976/index.html">Le livre "Spring. Tous les mod√®les de conception ¬ª</a></li>
<li><a href="../fr438978/index.html">Apprendre toujours et partout! Podcasts pour les d√©veloppeurs en anglais</a></li>
<li><a href="../fr438980/index.html">Spring Boot 2: quoi de neuf?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>