<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöÆ ü§∂üèª üåá √âcrire une application sur Flutter en collaboration avec Redux üçü ‚ùáÔ∏è üñïüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour √† tous! Dans cet article, je voudrais vous montrer comment cr√©er une application Flutter √† l'aide de Redux. Si vous ne savez pas ce qu'est Flu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√âcrire une application sur Flutter en collaboration avec Redux</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481624/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/xp/kq/1p/xpkq1phvyqjcztfqddbiedcjijw.jpeg" alt="image"></div><br><br>  Bonjour √† tous!  Dans cet article, je voudrais vous montrer comment cr√©er une application Flutter √† l'aide de Redux.  Si vous ne savez pas ce qu'est <a href="https://flutter.dev/">Flutter</a> , il s'agit d'un SDK open source pour cr√©er des applications mobiles √† partir de Google.  Il est utilis√© pour d√©velopper des applications pour Android et iOS, et c'est √©galement le seul moyen de d√©velopper des applications pour Google Fuchsia. <br><br>  Si vous connaissez Flutter et que vous souhaitez cr√©er une application bien con√ßue, facile √† tester et ayant un comportement tr√®s pr√©visible, continuez √† lire cet article et vous le saurez bient√¥t! <br><br>  Mais avant de commencer √† √©crire l'application elle-m√™me.  Apprenons un peu la th√©orie, commen√ßons par expliquer ce qu'est Redux. <br><a name="habracut"></a><br><h3>  Qu'est-ce que Redux? </h3><br>  <a href="https://redux.js.org/">Redux</a> est une architecture cr√©√©e √† l'origine pour le langage JavaScript et utilis√©e dans des applications cr√©√©es √† l'aide de <i><b>cadres r√©actifs</b></i> (tels que React Native ou Flutter).  Redux est une version simplifi√©e de l'architecture Flux cr√©√©e par Facebook.  Essentiellement, vous devez savoir trois choses: <br><br><ol><li>  La seule source de v√©rit√© - l' <b>√©tat</b> complet <b>de</b> votre application est stock√© en un seul endroit (appel√© <b>magasin</b> ). </li><li>  l'√©tat est en lecture seule / l'√©tat est en lecture seule - pour modifier l'√©tat de l'application, vous devez envoyer des actions (action), apr√®s quoi un nouvel √©tat sera cr√©√© </li><li>  les modifications sont effectu√©es √† l'aide de fonctions pures / fonctions pures - une fonction pure (pour plus de simplicit√©, c'est une fonction sans effets secondaires) prend l'application et l'action de l'√©tat actuel et renvoie le nouvel √©tat de l'application </li></ol><br>  <b>Remarque:</b> <i>Un effet secondaire de la fonction est la capacit√©, en train d'effectuer ses calculs: de lire et de modifier les valeurs des variables globales, d'effectuer des op√©rations d'E / S, de r√©pondre √† des situations exceptionnelles et d'appeler leurs gestionnaires.</i>  <i>Si vous appelez une fonction avec un effet secondaire deux fois avec le m√™me ensemble de valeurs d'argument d'entr√©e, il peut arriver que des valeurs diff√©rentes soient renvoy√©es comme r√©sultat.</i>  <i>Ces fonctions sont appel√©es fonctions non d√©terministes avec des effets secondaires.</i> <br><br>  √áa a l'air cool, mais quels sont les avantages de cette solution? <br><br><ul><li>  nous contr√¥lons l' <b>√©tat / l'√©tat</b> - cela signifie que nous savons exactement ce qui a caus√© le changement d'√©tat, nous n'avons pas d'√©tat en double et nous pouvons facilement surveiller le flux de donn√©es </li><li>  <b>Les r√©ducteurs</b> sont de simples fonctions faciles √† tester - nous pouvons passer l'√©tat, l'action √† l'entr√©e et v√©rifier si le r√©sultat est vrai </li><li>  L'application est clairement structur√©e - nous avons diff√©rentes couches pour les actions, les mod√®les, la logique m√©tier, etc. - donc vous savez exactement o√π ajouter une autre nouvelle <i>fonctionnalit√©</i> </li><li>  c'est une excellente architecture pour des applications plus complexes - vous n'avez pas besoin de passer l'√©tat dans toute l'arborescence de votre vue du parent √† l'enfant </li><li>  et il y en a un de plus ... </li></ul><br><h3>  Voyage dans le temps Redux </h3><br>  Redux a une opportunit√© int√©ressante - Voyage dans le temps!  Avec Redux et les outils associ√©s, vous pouvez suivre l'√©tat de votre application au fil du temps, v√©rifier l'√©tat r√©el et le recr√©er √† tout moment.  D√©couvrez cette fonctionnalit√© en action: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4c/d8e/168/e4cd8e16824e262401b8c2f7fae2a181.gif" alt="image"></div><br><h3>  Widgets Redux avec un exemple simple </h3><br>  Toutes les r√®gles ci-dessus rendent le flux de donn√©es dans Redux unidirectionnel.  Mais qu'est-ce que cela signifie?  En pratique, tout cela se fait √† l'aide d' <b>actions</b> , de <b>r√©ducteurs</b> , de <b>magasins</b> et d' <b>√©tats</b> .  Imaginons une application qui affiche un compteur: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/871/eb8/5e8/871eb85e8a5a12340a0b03d81ada4635.png" alt="image"></div><br><ol><li>  Votre application a un certain <b>√©tat</b> au d√©marrage (le nombre de clics, qui est 0) </li><li>  En fonction de cet √©tat, la <b>vue est</b> rendue. </li><li>  Si l'utilisateur clique sur le bouton, l' <b>action</b> est envoy√©e (par exemple, IncrementCounter) </li><li>  Apr√®s cela, l' <i>action</i> re√ßoit un <b>r√©ducteur</b> qui conna√Æt l' <i>√©tat</i> pr√©c√©dent (compteur 0), et re√ßoit l' <i>action</i> (IncrementCounter) et peut retourner un nouvel <b>√©tat</b> (le compteur est maintenant 1) </li><li>  Notre application a un nouvel <b>√©tat</b> (le compteur est 1) </li><li>  En fonction du nouvel <b>√©tat</b> , la <b>vue est</b> redessin√©e, qui affiche l'√©tat actuel </li></ol><br>  Donc, comme vous pouvez le voir, il s'agit g√©n√©ralement de l' <b>√©tat</b> .  Vous avez un √©tat de l'application enti√®re, l' <b>√©tat est en</b> <i>lecture seule</i> , et pour cr√©er un nouvel <b>√©tat,</b> vous devez envoyer une <b>action</b> .  La soumission d' <i>actions</i> lance un <b>r√©ducteur</b> , qui cr√©e et nous renvoie un nouvel <b>√©tat</b> .  Et l'histoire se r√©p√®te. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/abd/064/a28/abd064a286704f7c441d19257ed8a390.png" alt="image"></div><br>  Cr√©ons une petite application et d√©couvrons la mise en ≈ìuvre de l'approche Redux en action, l'application s'appellera ¬´ <i>Shopping List</i> ¬ª <br><br>  Nous verrons comment Redux fonctionne dans la pratique.  Nous allons cr√©er une simple application ShoppingCart.  L'application aura des fonctionnalit√©s telles que: <br><br><ul><li>  ajout d'achats </li><li>  il sera possible de marquer l'achat comme termin√© </li><li>  et c'est essentiellement tout </li></ul><br>  L'application ressemblera √† ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85c/b09/372/85cb09372a6f1e4fa72817ab2f2f855a.png" alt="image"></div><br>  Commen√ßons √† √©crire du code! <br><br><h3>  Pr√©requis </h3><br>  Dans cet article, je ne montrerai pas la cr√©ation de l'interface utilisateur pour cette application.  <a href="https://github.com/pszklarska/flutter_shopping_cart">Vous pouvez vous familiariser avec le code que j'ai pr√©par√© pour vous avant de poursuivre la plong√©e Redux</a> .  Apr√®s quoi, nous continuerons √† √©crire du code et √† ajouter <i>Redux</i> √† l'application actuelle. <br><br>  <b>Remarque:</b> <i>Si vous n'avez jamais utilis√© Flutter auparavant, je vous sugg√®re d'essayer <a href="https://codelabs.developers.google.com/codelabs/flutter/">Flutter Codelabs de Google</a> .</i> <br><br><h3>  Pr√©paration pr√©liminaire </h3><br>  Pour commencer √† utiliser <b>Redux</b> pour Flutter, nous devons ajouter des d√©pendances au fichier <i>pubspec.yaml</i> : <br><br><pre><code class="swift hljs">flutter_redux: ^<span class="hljs-number"><span class="hljs-number">0.5</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  Vous pouvez √©galement v√©rifier la version actuelle de cette d√©pendance en acc√©dant √† la page <a href="https://pub.dartlang.org/packages/flutter_redux">flutter_redux</a> . <br><br>  <i>Au moment de la r√©daction, la version √©tait, flutter_redux 0.6.0</i> <br><br><h3>  Mod√®le </h3><br>  Notre application devrait √™tre capable de contr√¥ler l'ajout et la modification d'√©l√©ments, nous allons donc utiliser un mod√®le <i>CartItem</i> simple pour stocker l'√©tat d'un √©l√©ment.  Tous nos √©tats d'application ne seront qu'une liste de CartItems.  Comme vous pouvez le voir, CartItem n'est qu'un objet. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CartItem</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-type"><span class="hljs-type">String</span></span> name; bool checked; <span class="hljs-type"><span class="hljs-type">CartItem</span></span>(this.name, this.checked); }</code> </pre><br>  Tout d'abord, nous devons d√©clarer des actions.  L'action est, en fait, toute intention qui peut √™tre invoqu√©e pour changer l'√©tat d'une application.  En substance, il y aura deux actions pour ajouter et modifier un √©l√©ment: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddItemAction</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-type"><span class="hljs-type">CartItem</span></span> item; <span class="hljs-type"><span class="hljs-type">AddItemAction</span></span>(this.item); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToggleItemStateAction</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-type"><span class="hljs-type">CartItem</span></span> item; <span class="hljs-type"><span class="hljs-type">ToggleItemStateAction</span></span>(this.item); }</code> </pre><br>  Ensuite, nous devons dire √† notre application quoi faire avec ces <i>actions</i> .  C'est pourquoi les <i>r√©ducteurs</i> sont utilis√©s - ils prennent simplement l'√©tat actuel de l'application et l'action (√©tat et action de l'application), puis cr√©ent et renvoient un nouvel √©tat.  Nous aurons deux m√©thodes de <i>r√©duction</i> : <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt; appReducers(<span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt; items, <span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> action) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-type"><span class="hljs-type">AddItemAction</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> addItem(items, action); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-type"><span class="hljs-type">ToggleItemStateAction</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> toggleItemState(items, action); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items; } <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt; addItem(<span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt; items, <span class="hljs-type"><span class="hljs-type">AddItemAction</span></span> action) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">List</span></span>.from(items)..add(action.item); } <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt; toggleItemState(<span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt; items, <span class="hljs-type"><span class="hljs-type">ToggleItemStateAction</span></span> action) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>((item) =&gt; item.name == action.item.name ? action.item : item).toList(); }</code> </pre><br>  La m√©thode <i>appReducers ()</i> d√©l√®gue l'action aux m√©thodes appropri√©es.  Les <i>m√©thodes addItem ()</i> et <i>toggleItemState ()</i> renvoient de nouvelles listes - c'est notre nouvel √©tat / √©tat.  Comme vous pouvez le voir, vous <b>ne</b> devez <b>pas modifier la liste actuelle</b> .  Au lieu de cela, nous cr√©ons une nouvelle liste √† chaque fois. <br><br><h3>  StoreProvider </h3><br>  Maintenant que nous avons des <i>actions</i> et des <i>r√©ducteurs</i> , nous devons fournir un emplacement pour stocker l' <i>√©tat de l'application</i> .  Dans Redux, il est appel√© <b>magasin</b> et est la seule source de v√©rit√© pour l'application. <br><br><pre> <code class="swift hljs">void main() { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> store = new <span class="hljs-type"><span class="hljs-type">Store</span></span>&lt;<span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt;&gt;( appReducers, initialState: new <span class="hljs-type"><span class="hljs-type">List</span></span>()); runApp(new <span class="hljs-type"><span class="hljs-type">FlutterReduxApp</span></span>(store)); }</code> </pre><br>  Pour cr√©er un <b>magasin</b> , nous devons passer la m√©thode des <i>r√©ducteurs</i> et l' <b>√©tat</b> initial.  Si nous avons cr√©√© un <b>magasin</b> , nous devons le transmettre √† <i>StoreProvider</i> pour indiquer √† notre application que le <i>magasin</i> peut √™tre utilis√© par toute personne qui souhaite demander l' <b>√©tat</b> actuel <b>de l'</b> application. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FlutterReduxApp</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-type"><span class="hljs-type">Store</span></span>&lt;<span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt;&gt; store; <span class="hljs-type"><span class="hljs-type">FlutterReduxApp</span></span>(this.store); @<span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-type"><span class="hljs-type">Widget</span></span> build(<span class="hljs-type"><span class="hljs-type">BuildContext</span></span> context) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new <span class="hljs-type"><span class="hljs-type">StoreProvider</span></span>&lt;<span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt;&gt;( store: store, child: new <span class="hljs-type"><span class="hljs-type">ShoppingCartApp</span></span>(), ); } }</code> </pre><br>  Dans l'exemple ci-dessus, <i>ShoppingCartApp (</i> ) est le widget principal de notre application. <br><br><h3>  StoreConnector </h3><br>  Nous avons actuellement tout sauf ... ajouter et modifier des articles √† acheter.  Comment faire  Pour rendre cela possible, nous devons utiliser <i>StoreConnector</i> .  C'est un moyen d'obtenir le <b>magasin</b> et de lui envoyer une <i>action</i> ou simplement d'obtenir l' <b>√©tat</b> actuel. <br><br>  Tout d'abord, nous voulons obtenir les donn√©es actuelles et les afficher sous forme de liste √† l'√©cran: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShoppingList</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessWidget</span></span></span><span class="hljs-class"> </span></span>{ @<span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-type"><span class="hljs-type">Widget</span></span> build(<span class="hljs-type"><span class="hljs-type">BuildContext</span></span> context) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new <span class="hljs-type"><span class="hljs-type">StoreConnector</span></span>&lt;<span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt;, <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt;&gt;( converter: (store) =&gt; store.state, builder: (context, list) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new <span class="hljs-type"><span class="hljs-type">ListView</span></span>.builder( itemCount: list.length, itemBuilder: (context, position) =&gt; new <span class="hljs-type"><span class="hljs-type">ShoppingListItem</span></span>(list[position])); }, ); } }</code> </pre><br>  Le code ci-dessus enveloppe <i>ListView.builder</i> avec un <i>StoreConnector</i> .  <b>StoreConnector</b> peut accepter l' <b>√©tat</b> actuel (qui est une liste d'√©l√©ments <i>) et √† l'aide des fonctions de <i>carte</i> , nous pouvons le convertir en n'importe quoi.</i>  <i>Mais dans notre cas, ce sera le m√™me <b>√©tat</b> (Liste), car ici nous avons besoin d'une liste de courses.</i> <i><br><br></i>  <i>Ensuite, dans la fonction de <i>g√©n√©rateur</i> , nous obtenons une liste - qui est essentiellement une liste de <i>CartItems</i> du <b>magasin</b> , que nous pouvons utiliser pour cr√©er un <b>ListView</b> .</i> <i><br><br></i>  <i>Ok, cool - nous avons des donn√©es.</i>  <i>Maintenant, comment d√©finir certaines donn√©es?</i> <i><br><br></i>  <i>Pour cela, nous utiliserons √©galement <i>StoreConnector</i> , mais d'une mani√®re l√©g√®rement diff√©rente.</i> <i><br><br></i> <pre> <i><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddItemDialog</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessWidget</span></span></span><span class="hljs-class"> </span></span>{ @<span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-type"><span class="hljs-type">Widget</span></span> build(<span class="hljs-type"><span class="hljs-type">BuildContext</span></span> context) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new <span class="hljs-type"><span class="hljs-type">StoreConnector</span></span>&lt;<span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt;, <span class="hljs-type"><span class="hljs-type">OnItemAddedCallback</span></span>&gt;( converter: (store) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (itemName) =&gt; store.dispatch(<span class="hljs-type"><span class="hljs-type">AddItemAction</span></span>(<span class="hljs-type"><span class="hljs-type">CartItem</span></span>(itemName, <span class="hljs-literal"><span class="hljs-literal">false</span></span>))); }, builder: (context, callback) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new <span class="hljs-type"><span class="hljs-type">AddItemDialogWidget</span></span>(callback); }); } }typedef <span class="hljs-type"><span class="hljs-type">OnItemAddedCallback</span></span> = <span class="hljs-type"><span class="hljs-type">Function</span></span>(<span class="hljs-type"><span class="hljs-type">String</span></span> itemName);</code></i> </pre> <i><br></i>  <i>Regardons le code.</i>  <i>Nous avons utilis√© <i>StoreConnector</i> , comme dans l'exemple pr√©c√©dent, mais cette fois au lieu de faire correspondre la liste <i>CartItems</i> avec la m√™me liste, nous ferons une <i>conversion de</i> <b>carte</b> en <i>OnItemAddedCallback</i> .</i>  <i>Ainsi, nous pouvons passer <a href="https://developer.mozilla.org/ru/docs/%25D0%25A1%25D0%25BB%25D0%25BE%25D0%25B2%25D0%25B0%25D1%2580%25D1%258C/%25D1%2584%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F_%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE_%25D0%25B2%25D1%258B%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0">la fonction de rappel</a> √† <i>AddItemDialogWidget</i> et l'appeler lorsque l'utilisateur <i>ajoute un</i> nouvel √©l√©ment:</i> <i><br><br></i> <pre> <i><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddItemDialogWidgetState</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddItemDialogWidget</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-type"><span class="hljs-type">String</span></span> itemName; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-type"><span class="hljs-type">OnItemAddedCallback</span></span> callback; <span class="hljs-type"><span class="hljs-type">AddItemDialogWidgetState</span></span>(this.callback); @<span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-type"><span class="hljs-type">Widget</span></span> build(<span class="hljs-type"><span class="hljs-type">BuildContext</span></span> context) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new <span class="hljs-type"><span class="hljs-type">AlertDialog</span></span>( ... actions: &lt;<span class="hljs-type"><span class="hljs-type">Widget</span></span>&gt;[ ... new <span class="hljs-type"><span class="hljs-type">FlatButton</span></span>( child: const <span class="hljs-type"><span class="hljs-type">Text</span></span>('<span class="hljs-type"><span class="hljs-type">ADD'</span></span>), onPressed: () { ... callback(itemName); }) ], ); } }</code></i> </pre> <i><br></i>  <i>D√©sormais, chaque fois que l'utilisateur clique sur le bouton AJOUTER, la fonction de rappel envoie une <b>action</b> <i>AddItemAction ()</i> .</i> <i><br><br></i>  <i>Maintenant, nous pouvons faire une impl√©mentation tr√®s similaire pour changer l'√©tat d'un √©l√©ment.</i> <i><br><br></i> <pre> <i><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShoppingListItem</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-type"><span class="hljs-type">CartItem</span></span> item; <span class="hljs-type"><span class="hljs-type">ShoppingListItem</span></span>(this.item); @<span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-type"><span class="hljs-type">Widget</span></span> build(<span class="hljs-type"><span class="hljs-type">BuildContext</span></span> context) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new <span class="hljs-type"><span class="hljs-type">StoreConnector</span></span>&lt;<span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt;, <span class="hljs-type"><span class="hljs-type">OnStateChanged</span></span>&gt;( converter: (store) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (item) =&gt; store.dispatch(<span class="hljs-type"><span class="hljs-type">ToggleItemStateAction</span></span>(item)); }, builder: (context, callback) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new <span class="hljs-type"><span class="hljs-type">ListTile</span></span>( title: new <span class="hljs-type"><span class="hljs-type">Text</span></span>(item.name), leading: new <span class="hljs-type"><span class="hljs-type">Checkbox</span></span>( value: item.checked, onChanged: (bool newValue) { callback(<span class="hljs-type"><span class="hljs-type">CartItem</span></span>(item.name, newValue)); }), ); }); } }</code></i> </pre> <i><br></i>  <i>Comme dans l'exemple pr√©c√©dent, nous utilisons <b>StoreConnector</b> pour afficher la <i>liste de la fonction de rappel <i>OnStateChanged</i> .</i></i>  <i><i>D√©sormais, chaque fois que l'indicateur change (dans la m√©thode onChanged), la fonction de rappel d√©clenche l'√©v√©nement <i>ToggleItemStateAction</i> .</i></i> <i><i><br><br></i></i> <h3>  <i><i>R√©sum√©</i></i> </h3> <i><i><br></i></i>  <i><i>C'est tout!</i></i>  <i><i>Dans cet article, nous avons cr√©√© une application simple qui affiche une liste de courses et un peu plong√©e dans l'utilisation de l'architecture Redux.</i></i>  <i><i>Dans notre application, nous pouvons ajouter des √©l√©ments et changer leur √©tat.</i></i>  <i><i>L'ajout de nouvelles fonctionnalit√©s √† cette application est aussi simple que l'ajout de nouvelles <i>actions</i> et <i>r√©ducteurs</i> .</i></i> <i><i><br><br></i></i>  <i><i><a href="https://github.com/pszklarska/FlutterShoppingCart">Ici</a> vous pouvez trouver le code source de cette application, y compris le widget <b>Time Travel</b> :</i></i> <i><i><br><br></i></i>  <i><i>J'esp√®re que vous avez appr√©ci√© ce post!</i></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr481624/">https://habr.com/ru/post/fr481624/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr481610/index.html">PostgreSQL Antipatterns: mise √† jour d'une grande table en charge</a></li>
<li><a href="../fr481612/index.html">Notre petite contribution √† la lutte d'Avalonia UI pour moins de plateformes</a></li>
<li><a href="../fr481616/index.html">D√¥me g√©od√©sique. √Ä propos de l'appareil et mon exp√©rience des calculs</a></li>
<li><a href="../fr481618/index.html">MVP dans Unity ou comment simplifier la vie</a></li>
<li><a href="../fr481620/index.html">Juniper SRX et Cisco ASA: nouvelle s√©rie</a></li>
<li><a href="../fr481626/index.html">Collections d'affichage complexes dans iOS: probl√®mes et solutions sur l'exemple du flux VKontakte</a></li>
<li><a href="../fr481628/index.html">R√®gles de r√©daction des √©tapes pr√©liminaires dans les cas de test</a></li>
<li><a href="../fr481630/index.html">Meilleurs outils et ressources utiles pour rendre une startup plus intelligente en 2019</a></li>
<li><a href="../fr481632/index.html">Fournisseurs de cloud: qui est le plus beau du march√©?</a></li>
<li><a href="../fr481634/index.html">Food Design Digest, novembre 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>