<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏾‍🤝‍🧑🏼 👰 👩🏽‍🤝‍👩🏼 Apa yang Baru di Versi Angular 8 💑 😰 🚎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jadi sudut 8 keluar, itu termasuk pratinjau Ivy, dukungan untuk pekerja layanan, pemuatan diferensial, dan beberapa sentuhan akhir lainnya. Manfred St...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apa yang Baru di Versi Angular 8</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455493/">  Jadi sudut 8 keluar, itu termasuk pratinjau Ivy, dukungan untuk pekerja layanan, pemuatan diferensial, dan beberapa sentuhan akhir lainnya.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Manfred Steyer</a> menjelaskan perubahan paling penting dalam rilis terbaru. <br><br>  Seperti yang direncanakan, tidak ada kejutan: memperbarui kerangka kerja dan CLI dapat dilakukan dengan menggunakan pembaruan, dan fitur-fitur baru adalah tambahan yang bagus untuk moto "evolusi bukannya revolusi". <br><br>  Dalam artikel ini, penulis berbicara tentang fitur-fitur baru yang paling penting dari Angular 8 dan Angular CLI 8. Contoh-contoh yang digunakan dalam artikel ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> . <br><br><h4>  Di bawah potongan: </h4><br><ul><li>  Pertama kali melihat Ivy </li><li>  Pekerja web </li><li>  Pemuatan diferensial </li><li>  Modul pemuatan malas </li><li>  Perubahan Kritis di ViewChild dan ContentChild </li><li>  Fitur Baru ngUpgrade </li></ul><br><a name="habracut"></a><br><h2>  Pertama kali melihat Ivy </h2><br>  Berita besar berikutnya yang ditunggu komunitas Angular adalah Ivy, kompiler baru, dan juga mesin rendering baru.  Ivy dapat menghasilkan bundel yang jauh lebih kecil, kompilasi tambahan, dan juga merupakan dasar untuk inovasi masa depan di Angular. <br><br>  Karena banyak bagian dasar Angular telah diubah, tim Angular telah memberikan perhatian khusus pada kompatibilitas dengan versi sebelumnya: setelah meningkatkan ke Ivy, aplikasi yang ada harus bekerja dengan cara yang sama seperti sebelumnya.  Paling-paling, Anda akan mendapatkan bundel yang jauh lebih kecil.  Ini bukan halangan, karena lebih dari 600 aplikasi di Google secara resmi didasarkan pada Angular - angka sebenarnya dikabarkan jauh lebih tinggi. <br><br>  Dengan Angular 8, versi awal Ivy tersedia untuk pengujian.  Tujuan dari versi ini adalah untuk mendapatkan umpan balik cepat.  Oleh karena itu, tim sudut merekomendasikan untuk tidak menggunakan Ivy di prod sekarang, tetapi terus menggunakan mesin tampilan klasik (Gbr. 1) <br><img src="https://habrastorage.org/webt/wn/rb/ti/wnrbtie8kro1xuebbrv-emal3te.png"><br><br>  Berkat pemuatan diferensial (seperti yang terlihat di bawah), ukuran bundel dapat dioptimalkan sekarang. <br><br>  Menurut Brad Green, CTO dari tim Angular di Google, di ngconf 2019, Ivy akan secara signifikan meningkatkan ukuran paket dalam mode kompatibilitas dikombinasikan dengan pemuatan diferensial.  Dengan demikian, pemberani sudah dapat menguji API Ivy di masa depan.  Mode ini, khususnya, memiliki potensi besar untuk optimasi.  API masih ditandai pribadi.  Melihat kelas dan fungsinya, Anda dapat mengatakan: mereka mulai dengan simbol khusus ɵ. <br><br>  Jika Anda sudah ingin mencoba Ivy, Anda dapat membuat proyek baru dengan sakelar enable-ivy: <br><pre><code class="bash hljs">ng new ivy-project --<span class="hljs-built_in"><span class="hljs-built_in">enable</span></span>-ivy</code> </pre> <br>  Kunci ini memberitahu CLI untuk menyimpan entri berikut di konfigurasi tsconfig.app.json: <br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"angularCompilerOptions"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"enableIvy"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre><br>  Entri ini juga dapat ditambahkan secara manual setelah memutakhirkan ke versi 8, untuk menguji aplikasi yang ada menggunakan Ivy. <br>  Untuk menjalankan aplikasi dalam mode debug, disarankan untuk menggunakan AOT: <br><pre> <code class="bash hljs">ng serve --aot</code> </pre> <br>  Selain itu, Anda harus memperhatikan ukuran aplikasi yang dibuat menggunakan ng build.  Dengan sudut 9, Ivy harus diaktifkan secara default.  Sampai saat itu, tim Angular berencana untuk terus bekerja untuk memastikan kompatibilitas dengan versi yang lebih lama. <br><br><h2>  Pekerja web </h2><br>  JavaScript adalah utas tunggal berdasarkan definisi.  Karena itu, tugas yang memakan waktu, seperti kueri data, biasanya dilakukan secara tidak serempak.  Tidak perlu dikatakan, ini tidak membantu dalam perhitungan yang rumit.  Mereka terutama menjadi lebih umum dengan solusi JavaScript yang luas, jadi kami mendukung pekerja web di hampir semua browser web.  Ini adalah skrip yang diluncurkan oleh browser di utas terpisah.  Komunikasi dengan streaming di tab browser dilakukan melalui pesan. <br>  Meskipun pekerja web tidak terkait dengan Angular, mereka harus diperhitungkan saat membangun.  Tujuannya adalah untuk menyediakan satu paket untuk setiap pekerja web.  Tugas ini telah diselesaikan oleh CLI baru. <br>  Untuk menunjukkan fitur baru, saya akan menunjukkan JavaScript implementasi dari apa yang disebut " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah n queens</a> ." Idenya adalah menempatkan satu ratu dalam satu baris di papan catur, tanpa dapat saling mengancam. baris, kolom atau diagonal yang sama tidak boleh menjadi ratu lain. <br><img src="https://habrastorage.org/webt/wx/px/es/wxpxesfv9odlgydmnrejoxjw-eq.png"><br>  Algoritma untuk menghitung semua solusi yang mungkin pada papan catur dianggap kompleks secara komputasi.  Meskipun perhitungan untuk papan catur delapan baris dan delapan kolom cukup cepat, komputer konvensional telah mencapai batas dengan papan 12 x 12. Solusi untuk papan 27 x 27 adalah catatan saat ini.  Untuk tugas ini, superkomputer Rusia digunakan. <br>  Untuk menerjemahkan perhitungan ini ke latar belakang, pertama-tama kita harus membuat pekerja web menggunakan CLI: <br><pre> <code class="bash hljs">ng generate worker n-queens</code> </pre> <br>  Instruksi ini membuat file tidak hanya untuk karyawan, tetapi juga untuk file konfigurasi yang diperlukan untuk proses pembuatan dan entri dalam file yang ada.  Jika folder yang sama berisi komponen dengan nama yang sama dengan ekstensi file .component.ts yang umum, CLI juga akan menambahkan kode untuk berinteraksi dengan pekerja web. <br>  Pekerja itu sendiri terdiri dari pendengar untuk acara tersebut: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> nQueens <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./n-queens'</span></span>; addEventListener(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, ({ data }) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = nQueens(data.count); postMessage(result, <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>); });</code> </pre><br>  Acara dijalankan ketika utas mengirim pesan ke pekerja.  Parameter berisi informasi yang dikirim dari arus utama.  Dalam hal ini, dibatasi oleh properti hitungan, yang menentukan ukuran papan catur.  Setelah mengevaluasi fungsi nQueens, yang dihilangkan di sini, eventListener mengirim hasilnya kembali ke utas utama melalui postMessage.  Dengan demikian, browser menampilkan peristiwa pesan. <br>  Kelas Worker digunakan dalam komponen using untuk berinteraksi dengan skrip pekerja: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = <span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.count, <span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> worker = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Worker(<span class="hljs-string"><span class="hljs-string">'../logic/n-queens.worker'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'module'</span></span> <span class="hljs-comment"><span class="hljs-comment">// Worker uses EcmaScript modules }); worker.postMessage({count}); worker.addEventListener('message', (event) =&gt; { // tslint:disable-next-line: no-console console.debug('worker result', event.data); // Update chessboard this.processResult(event.data); });</span></span></code> </pre><br>  Komponen mengirimkan pesan dengan ukuran papan catur yang diinginkan kepada pekerja melalui postMessage dan dengan demikian memulai perhitungan di sana.  Ini menerima hasilnya melalui acara pesan. <br>  Di masa depan, CLI menangani perakitan skrip pekerja yang benar.  Compiler TypeScript mengenali mereka di akhir .worker.ts, yang terdaftar di tsconfig.worker.json yang dibuat oleh perintah <i>ng menghasilkan pekerja</i> .  Untuk memastikan bahwa CLI tidak mempengaruhi file-file ini lagi ketika membangun aplikasi utama, <i>ng menghasilkan pekerja</i> menempatkan templat file yang sama di bagian mengecualikan tsconfig.app.json. <br>  Implementasi penuh ada dalam proyek dengan contoh-contoh penulis.  Sebagai perbandingan, contoh tugas N queens dapat diselesaikan baik di utas utama maupun di pekerja web.  Ketika Anda mencoba memecahkan masalah untuk papan catur 12 x 12, misalnya, Anda akan melihat bahwa UI hang dalam kasus pertama, sedangkan perhitungan latar belakang dengan pekerja web tidak akan mengurangi kinerja. <br><br><h2>  Pemuatan diferensial </h2><br>  Sampai sekarang, sudah biasa untuk mengkompilasi aplikasi ke dalam ES 5 lama yang baik, karena versi "JavaScript ayah kami" ini bekerja hampir di mana-mana.  Ini berarti bahwa IE11 dan perayap web Google dapat mengeksekusi kode ini. <br>  Namun, ES 2015 yang baru dan versi selanjutnya lebih efisien: mereka memungkinkan Anda untuk membuat paket yang lebih ringkas dan peramban juga dapat menafsirkannya dengan lebih efisien.  Karena sebelumnya sudah biasa untuk kembali ke ES 5 sebagai penyebut yang paling tidak umum, browser modern, sayangnya, tidak dapat mengambil keuntungan dari versi bahasa yang baru. <br>  Sekarang sudah berakhir: dimulai dengan versi 8, CLI memiliki fitur yang disebut pembebanan diferensial.  Idenya adalah untuk menyediakan dua kelompok paket: satu berdasarkan ECMAScript 5 dan dirancang untuk browser yang lebih lama, yang lain berdasarkan pada versi baru ECMAScript, seperti ECMAScript 2015, dan menyediakan browser modern dengan manfaat yang disebutkan sebelumnya. <br>  Anda tidak perlu melakukan banyak pekerjaan untuk mengaktifkan pemuatan diferensial: yang diperlukan hanyalah mengatur batas atas dan bawah dari versi ECMAScript yang didukung.  Batas atas ditunjukkan dalam tsconfig.json sebagai berikut: <br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"target"</span></span>: <span class="hljs-string"><span class="hljs-string">"es2015"</span></span></code> </pre> <br>  Batas bawah didefinisikan dalam file daftar browser.  File ini termasuk browser yang akan didukung sesuai dengan kriteria tertentu, seperti pangsa pasar, misalnya.  Mereka dapat disimpan, misalnya, dalam file daftar browser, yang dibuat CLI di root proyek ketika membuat proyek baru: <br> <code>&gt; 0.5% <br> last 2 versions <br> Firefox ESR <br> not dead <br> IE 9-11 <br></code> <br>  Dalam hal ini, daftar browser menyertakan browser ES 5 dengan entri IE 9-11.  Dengan demikian, CLI mendefinisikan ambang yang lebih rendah sebagai versi ini.  Ketika CLI menerima perintah ng build, proses build akan berjalan untuk kedua versi: <br><img src="https://habrastorage.org/webt/ao/ln/iv/aolnivkwgyupqjziwm1whw6mlhg.png"><br>  Kerugian dari proses ini adalah ini: waktu yang dibutuhkan untuk perakitan berlipat ganda. <br>  Browser sekarang dapat memutuskan versi paket mana yang akan diunduh.  Untuk melakukan ini, mereka mendapatkan tautan ke skrip dalam add-on index.html: mereka yang menunjuk ke paket ECMAScript 5 menerima penambahan nomodule.  Dengan demikian, browser dengan dukungan ECMAScript dan, karenanya, dukungan ECMAScript 2015+ tidak akan mengabaikan skrip ini.  Di sisi lain, paket ECMAScript 2015+ diimplementasikan oleh CLI dengan type = "module".  Dengan demikian, browser lama akan mengabaikan skrip ini: <br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"main-es2015.js"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"module"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"main-es5.js"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">nomodule</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Tidak seperti ng build, perintah CLI lainnya hanya menggunakan (!) Batas atas dukungan ES.  Dalam kasus kami, ini adalah ECMAScript 2015. Ini terjadi, termasuk untuk alasan efisiensi: selama debugging dan pengujian, pengembang biasanya ingin melihat hasilnya sesegera mungkin, tanpa menunggu build kedua. <br><br><h2>  Modul pemuatan malas </h2><br>  Sejak hari-hari pertama, router sudut mendukung pemuatan yang malas.  Sampai sekarang, ini telah dicapai dengan definisi ajaib dari modul yang dapat dimuat: <br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'lazy'</span></span>, <span class="hljs-attr"><span class="hljs-attr">loadChildren</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'./lazy/lazy.module#LayzModule'</span></span> }</code> </pre><br>  Nilai sebelum # menjelaskan jalur yang mengarah ke file implementasi modul;  nilai setelah berarti kelas yang terkandung di dalamnya.  Gaya uraian ini berfungsi di Angular 8, tetapi telah usang sehubungan dengan impor dinamis ECMAScript: <br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'lazy'</span></span>, <span class="hljs-attr"><span class="hljs-attr">loadChildren</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./lazy/lazy.module'</span></span>).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">m</span></span></span><span class="hljs-function"> =&gt;</span></span> m.LazyModule) }</code> </pre><br>  Opsi rekam baru masih berisi nama file sebagai nilai ajaib.  Namun, karena impor didukung oleh banyak IDE, nilai yang tidak valid akan segera mengembalikan kesalahan. <br><br><h2>  Perubahan Kritis di ViewChild dan ContentChild </h2><br>  Ada perubahan kritis untuk penggunaan ViewChild dan ContentChild, yang, sayangnya, di masa lalu tidak selalu berhasil diprediksi.  Jika dalam versi sebelumnya mereka digunakan oleh komponen untuk kueri elemen yang tidak di dalam arahan struktural, seperti ngIf atau ngFor, hasil kueri sudah tersedia di ngOnInit.  Kalau tidak, kita bisa mengaksesnya tidak lebih awal dari ngAfterViewInit (atau ngAfterContentInit untuk ContentChild).  Untuk elemen yang dimuat ke DOM nanti karena pengikatan data, kode program harus ngAfterViewChecked atau, karenanya, ngAfterContentChecked. <br>  Karena perilaku ini membingungkan, komponen sekarang harus menunjukkan kapan resolusi harus terjadi: <br><pre> <code class="javascript hljs">@ViewChild(<span class="hljs-string"><span class="hljs-string">'info'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">static</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }) paragraph: ElementRef;</code> </pre><br>  Jika flag statis benar, Angular akan mencoba menemukan elemen ketika komponen diinisialisasi.  Ini hanya berfungsi jika mereka tidak berada dalam arahan struktural.  Saat menggunakan statis: false, resolusi dilakukan setelah menginisialisasi atau memperbarui tampilan. <br>  ng pembaruan akan mencoba untuk secara otomatis memasukkan nilai yang benar, jika ini tidak mungkin, itu akan menambahkan komentar dengan TODO. <br>  Perubahan ini tidak akan memengaruhi kueri dengan dekorator ViewChildren dan ContentChildren.  Mereka selalu memiliki perilaku dinamis, dalam istilah baru dalam arti statis: salah. <br><br><h2>  Fitur Baru ngUpgrade </h2><br>  Sejauh ini, salah satu masalah dengan AngularJS 1.X dan Angular digabung dengan ngUpgrade adalah bahwa router dari kedua kerangka kerja bersaing karena URL.  Hal ini menyebabkan sulitnya menjelaskan efek samping.  Untuk menghindari hal ini, kemampuan untuk menggunakan layanan lokasi URL tunggal di kedua versi ditambahkan. <br>  Untuk melakukan ini, tim Angular memperluas kemampuan layanan lokasi Angular dan dengan demikian memberikan pengganti $ lokasi di AngularJS. <br>  Karena alasan ini, metode onUrlChange baru telah ditambahkan ke layanan lokasi untuk melacak perubahan URL: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(loc: Location, pLoc: PlatformLocation) { loc.onUrlChange(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.debug(<span class="hljs-string"><span class="hljs-string">'url change'</span></span>, url)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.debug(<span class="hljs-string"><span class="hljs-string">'hostname: '</span></span>, pLoc.hostname); } }</code> </pre><br>  Layanan PlatformLocation menawarkan akses tambahan ke bagian-bagian tertentu dari URL.  Penjelasan terperinci tentang bagaimana penggantian $ lokasi berdasarkan itu digunakan untuk kerangka kerja integrasi yang lebih baik dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Selain itu, Anda sekarang dapat menemukan solusi pemuatan malas AngularJS, yang didasarkan pada impor ECMAScript dinamis yang disebutkan sebelumnya. <br><br><h2>  Kesimpulan </h2><br>  Sekali lagi, tim Angular menepati janji mereka: transisi ke versi baru Angular sederhana dan tidak termasuk perubahan besar.  Sebaliknya, beberapa sudut dihaluskan, membuat bekerja dengan kerangka SPA Google menjadi lebih nyaman.  Pemuatan diferensial memberikan peluang untuk pengoptimalan ukuran paket lebih lanjut jika browser lama tidak didukung atau didukung oleh paket terpisah.  Dukungan untuk pekerja Web menunjukkan bahwa tugas intensif komputasi menemukan cara mereka untuk memproses di browser.  Penggemar sekarang dapat mengambil langkah pertama mereka dengan Ivy. <br><br>  PS: Ini adalah terjemahan pertama saya, jadi tolong perhatikan komentar, saran dan kesalahan dalam komentar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455493/">https://habr.com/ru/post/id455493/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455479/index.html">Bagaimana kami menerapkan navigasi dari Jetpack ke dalam aplikasi pertempuran. Yandex. Laporan Makanan</a></li>
<li><a href="../id455481/index.html">Tiga cerita tentang perburuan liar</a></li>
<li><a href="../id455483/index.html">Artis Ai-Da: robot humanoid mempersiapkan pameran solo pertamanya</a></li>
<li><a href="../id455485/index.html">Check Point Scripts - jalankan skrip langsung dari Smart Console</a></li>
<li><a href="../id455489/index.html">Menghubungkan solusi audio dan video pihak ketiga ke Tim Microsoft</a></li>
<li><a href="../id455497/index.html">Penyaringan linear optimal: mulai dari gradient descent hingga filter adaptif</a></li>
<li><a href="../id455499/index.html">Ekstraksi gigi bungsu: bagaimana ini dilakukan?</a></li>
<li><a href="../id455501/index.html">Bagaimana Hollywood Secara Diam-diam Menggunakan AI untuk Membuat Keputusan Pembuatan Film Kunci</a></li>
<li><a href="../id455503/index.html">19 konsep yang perlu Anda pelajari untuk menjadi pengembang Angular yang efektif</a></li>
<li><a href="../id455507/index.html">Ikhtisar Paket Python Datatable</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>