<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌟 🕺🏾 👩🏾‍🎨 N个物体的任务或如何在不离开厨房的情况下炸毁星系 👨🏽‍✈️ 😃 🤹🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="不久前，我读了刘奇新的科幻小说《三体问题》 。 在其中，一些外星人遇到了一个问题-他们不知道如何以足够的准确度来计算自己星球的轨迹。 与我们不同，他们生活在三星级系统中，星球上的“天气”在很大程度上取决于它们的相对位置-从焚烧的热量到冰冷的天气。 我决定检查我们是否可以解决此类问题。 

 现象的物...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>N个物体的任务或如何在不离开厨房的情况下炸毁星系</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437014/"><br><img src="https://habrastorage.org/webt/ke/eo/en/keeoenv3rtuxqu19szhk5hzfb7q.png"><br><br> 不久前，我读了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">刘奇新的</a>科幻小说<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">《三体问题》</a> 。 在其中，一些外星人遇到了一个问题-他们不知道如何以足够的准确度来计算自己星球的轨迹。 与我们不同，他们生活在三星级系统中，星球上的“天气”在很大程度上取决于它们的相对位置-从焚烧的热量到冰冷的天气。 我决定检查我们是否可以解决此类问题。 <br><a name="habracut"></a><br><h2> 现象的物理 </h2><br> 要理解问题，有必要处理现象的物理现象。 在古典理论的框架中，两个物体的吸引力由<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">牛顿</a>定律确定： <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-1"><span class="MJXp-mtext" id="MJXp-Span-2">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-3">v</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-5">c</span><span class="MJXp-mrow" id="MJXp-Span-6"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-7">F</span></span><span class="MJXp-mrow" id="MJXp-Span-8"><span class="MJXp-mo" id="MJXp-Span-9" style="margin-left: 0.278em; margin-right: 0.278em;">（</span></span><span class="MJXp-mtext" id="MJXp-Span-10">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-11">v</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-12">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-13">c</span><span class="MJXp-msubsup" id="MJXp-Span-14"><span class="MJXp-mrow" id="MJXp-Span-15" style="margin-right: 0.05em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-16">r</span></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-17" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mrow" id="MJXp-Span-18"><span class="MJXp-mo" id="MJXp-Span-19" style="margin-left: 0.278em; margin-right: 0.278em;">，</span></span><span class="MJXp-mtext" id="MJXp-Span-20">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-21">v</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-22">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23">c</span><span class="MJXp-msubsup" id="MJXp-Span-24"><span class="MJXp-mrow" id="MJXp-Span-25" style="margin-right: 0.05em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-26">r</span></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-27" style="vertical-align: -0.4em;">2</span></span><span class="MJXp-mrow" id="MJXp-Span-28"><span class="MJXp-mo" id="MJXp-Span-29" style="margin-left: 0.278em; margin-right: 0.278em;">）</span></span><span class="MJXp-mo" id="MJXp-Span-30" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mo" id="MJXp-Span-31" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-32">G</span><span class="MJXp-msubsup" id="MJXp-Span-33"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-34" style="margin-right: 0.05em;">m</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-35" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-msubsup" id="MJXp-Span-36"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-37" style="margin-right: 0.05em;">m</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-38" style="vertical-align: -0.4em;">2</span></span><span class="MJXp-mtext" id="MJXp-Span-39">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-40">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-41">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-42">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-43">c</span><span class="MJXp-mrow" id="MJXp-Span-44"><span class="MJXp-mtext" id="MJXp-Span-45">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-46">v</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-47">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-48">c</span><span class="MJXp-msubsup" id="MJXp-Span-49"><span class="MJXp-mrow" id="MJXp-Span-50" style="margin-right: 0.05em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-51">r</span></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-52" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-53" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mtext" id="MJXp-Span-54">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-55">v</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-56">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-57">c</span><span class="MJXp-msubsup" id="MJXp-Span-58"><span class="MJXp-mrow" id="MJXp-Span-59" style="margin-right: 0.05em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-60">r</span></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-61" style="vertical-align: -0.4em;">2</span></span></span><span class="MJXp-mrow" id="MJXp-Span-62"><span class="MJXp-mrow" id="MJXp-Span-63"><span class="MJXp-mo" id="MJXp-Span-64" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span><span class="MJXp-mtext" id="MJXp-Span-65">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-66">v</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-67">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-68">c</span><span class="MJXp-msubsup" id="MJXp-Span-69"><span class="MJXp-mrow" id="MJXp-Span-70" style="margin-right: 0.05em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-71">r</span></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-72" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-73" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mtext" id="MJXp-Span-74">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-75">v</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-76">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-77">c</span><span class="MJXp-msubsup" id="MJXp-Span-78"><span class="MJXp-mrow" id="MJXp-Span-79" style="margin-right: 0.05em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-80">r</span></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-81" style="vertical-align: -0.4em;">2</span></span><span class="MJXp-msubsup" id="MJXp-Span-82"><span class="MJXp-mrow" id="MJXp-Span-83" style="margin-right: 0.05em;"><span class="MJXp-mo" id="MJXp-Span-84" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-85" style="vertical-align: 0.5em;">3</span></span></span><span class="MJXp-mrow" id="MJXp-Span-86"><span class="MJXp-mo" id="MJXp-Span-87" style="margin-left: 0.278em; margin-right: 0.278em;">，</span></span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> \ vec {F}（\ vec {r} _1，\ vec {r} _2）=-G m_1 m_2 \ frac {\ vec {r} _1-\ vec {r} _2} {| \ vec {r} _1-\ vec {r} _2 | ^ 3}，</script></p><br><br> 在哪里 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-88"><span class="MJXp-mtext" id="MJXp-Span-89">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-90">v</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-91">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-92">c</span><span class="MJXp-msubsup" id="MJXp-Span-93"><span class="MJXp-mrow" id="MJXp-Span-94" style="margin-right: 0.05em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-95">r</span></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-96" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mrow" id="MJXp-Span-97"><span class="MJXp-mo" id="MJXp-Span-98" style="margin-left: 0.278em; margin-right: 0.278em;">，</span></span><span class="MJXp-mtext" id="MJXp-Span-99">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-100">v</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-101">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-102">c</span><span class="MJXp-msubsup" id="MJXp-Span-103"><span class="MJXp-mrow" id="MJXp-Span-104" style="margin-right: 0.05em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-105">r</span></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-106" style="vertical-align: -0.4em;">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-2"> \ vec {r} _1，\ vec {r} _2 </script>  -物体在太空中的位置， <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-107"><span class="MJXp-msubsup" id="MJXp-Span-108"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-109" style="margin-right: 0.05em;">m</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-110" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mrow" id="MJXp-Span-111"><span class="MJXp-mo" id="MJXp-Span-112" style="margin-left: 0.278em; margin-right: 0.278em;">，</span></span><span class="MJXp-msubsup" id="MJXp-Span-113"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-114" style="margin-right: 0.05em;">m</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-115" style="vertical-align: -0.4em;">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-3"> m_1，m_2 </script>  -大量的身体， <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-116"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-117">G</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-4"> G </script>  -重力常数。 <br> 在系统中 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-118"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-119">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-5"> N </script> 每个身体上的身体都会受到其余身体的吸引力的影响，其方程式如下： <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-120"><span class="MJXp-mtext" id="MJXp-Span-121">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-122">v</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-123">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-124">c</span><span class="MJXp-msubsup" id="MJXp-Span-125"><span class="MJXp-mrow" id="MJXp-Span-126" style="margin-right: 0.05em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-127">F</span></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-128" style="vertical-align: -0.4em;">n</span></span><span class="MJXp-mo" id="MJXp-Span-129" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mo" id="MJXp-Span-130" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-131">G</span><span class="MJXp-mtext" id="MJXp-Span-132">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-133">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-134">u</span><span class="MJXp-msubsup" id="MJXp-Span-135"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-136" style="margin-right: 0.05em;">m</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-137" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-138">k</span><span class="MJXp-mtext" id="MJXp-Span-139">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-140">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-141">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-142">q</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-143">n</span></span></span><span class="MJXp-msubsup" id="MJXp-Span-144"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-145" style="margin-right: 0.05em;">m</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-146" style="vertical-align: -0.4em;">n</span></span><span class="MJXp-msubsup" id="MJXp-Span-147"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-148" style="margin-right: 0.05em;">m</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-149" style="vertical-align: -0.4em;">k</span></span><span class="MJXp-mtext" id="MJXp-Span-150">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-151">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-152">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-153">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-154">c</span><span class="MJXp-mrow" id="MJXp-Span-155"><span class="MJXp-mtext" id="MJXp-Span-156">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-157">v</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-158">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-159">c</span><span class="MJXp-msubsup" id="MJXp-Span-160"><span class="MJXp-mrow" id="MJXp-Span-161" style="margin-right: 0.05em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-162">r</span></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-163" style="vertical-align: -0.4em;">n</span></span><span class="MJXp-mo" id="MJXp-Span-164" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mtext" id="MJXp-Span-165">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-166">v</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-167">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-168">c</span><span class="MJXp-msubsup" id="MJXp-Span-169"><span class="MJXp-mrow" id="MJXp-Span-170" style="margin-right: 0.05em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-171">r</span></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-172" style="vertical-align: -0.4em;">k</span></span></span><span class="MJXp-mrow" id="MJXp-Span-173"><span class="MJXp-mrow" id="MJXp-Span-174"><span class="MJXp-mo" id="MJXp-Span-175" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span><span class="MJXp-mtext" id="MJXp-Span-176">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-177">v</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-178">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-179">c</span><span class="MJXp-msubsup" id="MJXp-Span-180"><span class="MJXp-mrow" id="MJXp-Span-181" style="margin-right: 0.05em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-182">r</span></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-183" style="vertical-align: -0.4em;">n</span></span><span class="MJXp-mo" id="MJXp-Span-184" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mtext" id="MJXp-Span-185">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-186">v</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-187">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-188">c</span><span class="MJXp-msubsup" id="MJXp-Span-189"><span class="MJXp-mrow" id="MJXp-Span-190" style="margin-right: 0.05em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-191">r</span></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-192" style="vertical-align: -0.4em;">k</span></span><span class="MJXp-msubsup" id="MJXp-Span-193"><span class="MJXp-mrow" id="MJXp-Span-194" style="margin-right: 0.05em;"><span class="MJXp-mo" id="MJXp-Span-195" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-196" style="vertical-align: 0.5em;">3</span></span></span><span class="MJXp-mrow" id="MJXp-Span-197"><span class="MJXp-mo" id="MJXp-Span-198" style="margin-left: 0.278em; margin-right: 0.278em;">。</span></span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-6"> \ vec {F} _n = -G \ sum_ {k \ neq n} m_n m_k \ frac {\ vec {r} _n-\ vec {r} _k} {| \ vec {r} _n-\ vec {r } _k | ^ 3}。 </script></p><br><br> 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">牛顿第二定律，</a>我们为每个粒子写加速度： <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-199"><span class="MJXp-mtext" id="MJXp-Span-200">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-201">v</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-202">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-203">c</span><span class="MJXp-msubsup" id="MJXp-Span-204"><span class="MJXp-mrow" id="MJXp-Span-205" style="margin-right: 0.05em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-206">a</span></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-207" style="vertical-align: -0.4em;">n</span></span><span class="MJXp-mo" id="MJXp-Span-208" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mtext" id="MJXp-Span-209">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-210">v</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-211">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-212">c</span><span class="MJXp-msubsup" id="MJXp-Span-213"><span class="MJXp-mrow" id="MJXp-Span-214" style="margin-right: 0.05em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-215">F</span></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-216" style="vertical-align: -0.4em;">n</span></span><span class="MJXp-mrow" id="MJXp-Span-217"><span class="MJXp-mo" id="MJXp-Span-218" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-msubsup" id="MJXp-Span-219"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-220" style="margin-right: 0.05em;">m</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-221" style="vertical-align: -0.4em;">n</span></span><span class="MJXp-mo" id="MJXp-Span-222" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mo" id="MJXp-Span-223" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-224">G</span><span class="MJXp-mtext" id="MJXp-Span-225">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-226">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-227">u</span><span class="MJXp-msubsup" id="MJXp-Span-228"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-229" style="margin-right: 0.05em;">m</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-230" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-231">k</span><span class="MJXp-mtext" id="MJXp-Span-232">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-233">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-234">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-235">q</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-236">n</span></span></span><span class="MJXp-msubsup" id="MJXp-Span-237"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-238" style="margin-right: 0.05em;">m</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-239" style="vertical-align: -0.4em;">k</span></span><span class="MJXp-mtext" id="MJXp-Span-240">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-241">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-242">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-243">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-244">c</span><span class="MJXp-mrow" id="MJXp-Span-245"><span class="MJXp-mtext" id="MJXp-Span-246">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-247">v</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-248">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-249">c</span><span class="MJXp-msubsup" id="MJXp-Span-250"><span class="MJXp-mrow" id="MJXp-Span-251" style="margin-right: 0.05em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-252">r</span></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-253" style="vertical-align: -0.4em;">n</span></span><span class="MJXp-mo" id="MJXp-Span-254" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mtext" id="MJXp-Span-255">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-256">v</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-257">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-258">c</span><span class="MJXp-msubsup" id="MJXp-Span-259"><span class="MJXp-mrow" id="MJXp-Span-260" style="margin-right: 0.05em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-261">r</span></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-262" style="vertical-align: -0.4em;">k</span></span></span><span class="MJXp-mrow" id="MJXp-Span-263"><span class="MJXp-mrow" id="MJXp-Span-264"><span class="MJXp-mo" id="MJXp-Span-265" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span><span class="MJXp-mtext" id="MJXp-Span-266">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-267">v</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-268">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-269">c</span><span class="MJXp-msubsup" id="MJXp-Span-270"><span class="MJXp-mrow" id="MJXp-Span-271" style="margin-right: 0.05em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-272">r</span></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-273" style="vertical-align: -0.4em;">n</span></span><span class="MJXp-mo" id="MJXp-Span-274" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mtext" id="MJXp-Span-275">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-276">v</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-277">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-278">c</span><span class="MJXp-msubsup" id="MJXp-Span-279"><span class="MJXp-mrow" id="MJXp-Span-280" style="margin-right: 0.05em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-281">r</span></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-282" style="vertical-align: -0.4em;">k</span></span><span class="MJXp-msubsup" id="MJXp-Span-283"><span class="MJXp-mrow" id="MJXp-Span-284" style="margin-right: 0.05em;"><span class="MJXp-mo" id="MJXp-Span-285" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-286" style="vertical-align: 0.5em;">3</span></span></span><span class="MJXp-mrow" id="MJXp-Span-287"><span class="MJXp-mo" id="MJXp-Span-288" style="margin-left: 0.278em; margin-right: 0.278em;">。</span></span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-7"> \ vec {a} _n = \ vec {F} _n / m_n = -G \ sum_ {k \ neq n} m_k \ frac {\ vec {r} _n-\ vec {r} _k} {| \ vec { r} _n-\ vec {r} _k | ^ 3}。 </script></p><br><br> 回顾加速度是坐标的第二时间导数，我们获得了一个二阶偏微分方程，必须求解该方程才能获得每个物体的轨迹： <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-289"><span class="MJXp-mtext" id="MJXp-Span-290">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-291">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-292">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-293">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-294">c</span><span class="MJXp-mrow" id="MJXp-Span-295"><span class="MJXp-mtext" id="MJXp-Span-296" style="color: red;">\部</span><span class="MJXp-msubsup" id="MJXp-Span-297"><span class="MJXp-mrow" id="MJXp-Span-298" style="margin-right: 0.05em;"><span class="MJXp-mo" id="MJXp-Span-299" style="margin-left: 0.278em; margin-right: 0.278em;">分</span></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-300" style="vertical-align: 0.5em;">2</span></span><span class="MJXp-mtext" id="MJXp-Span-301">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-302">v</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-303">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-304">c</span><span class="MJXp-msubsup" id="MJXp-Span-305"><span class="MJXp-mrow" id="MJXp-Span-306" style="margin-right: 0.05em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-307">r</span></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-308" style="vertical-align: -0.4em;">n</span></span></span><span class="MJXp-mrow" id="MJXp-Span-309"><span class="MJXp-mtext" id="MJXp-Span-310" style="color: red;">\部</span><span class="MJXp-mrow" id="MJXp-Span-311"><span class="MJXp-mo" id="MJXp-Span-312" style="margin-left: 0.278em; margin-right: 0.278em;">分</span></span><span class="MJXp-msubsup" id="MJXp-Span-313"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-314" style="margin-right: 0.05em;">t</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-315" style="vertical-align: 0.5em;">2</span></span></span><span class="MJXp-mo" id="MJXp-Span-316" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-msubsup" id="MJXp-Span-317"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-318" style="margin-right: 0.05em;">f</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-319" style="vertical-align: -0.4em;">n</span></span><span class="MJXp-mo" id="MJXp-Span-320" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mo" id="MJXp-Span-321" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-322">G</span><span class="MJXp-mtext" id="MJXp-Span-323">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-324">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-325">u</span><span class="MJXp-msubsup" id="MJXp-Span-326"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-327" style="margin-right: 0.05em;">m</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-328" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-329">k</span><span class="MJXp-mtext" id="MJXp-Span-330">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-331">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-332">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-333">q</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-334">n</span></span></span><span class="MJXp-msubsup" id="MJXp-Span-335"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-336" style="margin-right: 0.05em;">m</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-337" style="vertical-align: -0.4em;">k</span></span><span class="MJXp-mtext" id="MJXp-Span-338">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-339">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-340">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-341">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-342">c</span><span class="MJXp-mrow" id="MJXp-Span-343"><span class="MJXp-mtext" id="MJXp-Span-344">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-345">v</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-346">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-347">c</span><span class="MJXp-msubsup" id="MJXp-Span-348"><span class="MJXp-mrow" id="MJXp-Span-349" style="margin-right: 0.05em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-350">r</span></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-351" style="vertical-align: -0.4em;">n</span></span><span class="MJXp-mo" id="MJXp-Span-352" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mtext" id="MJXp-Span-353">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-354">v</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-355">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-356">c</span><span class="MJXp-msubsup" id="MJXp-Span-357"><span class="MJXp-mrow" id="MJXp-Span-358" style="margin-right: 0.05em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-359">r</span></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-360" style="vertical-align: -0.4em;">k</span></span></span><span class="MJXp-mrow" id="MJXp-Span-361"><span class="MJXp-mrow" id="MJXp-Span-362"><span class="MJXp-mo" id="MJXp-Span-363" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span><span class="MJXp-mtext" id="MJXp-Span-364">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-365">v</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-366">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-367">c</span><span class="MJXp-msubsup" id="MJXp-Span-368"><span class="MJXp-mrow" id="MJXp-Span-369" style="margin-right: 0.05em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-370">r</span></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-371" style="vertical-align: -0.4em;">n</span></span><span class="MJXp-mo" id="MJXp-Span-372" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mtext" id="MJXp-Span-373">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-374">v</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-375">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-376">c</span><span class="MJXp-msubsup" id="MJXp-Span-377"><span class="MJXp-mrow" id="MJXp-Span-378" style="margin-right: 0.05em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-379">r</span></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-380" style="vertical-align: -0.4em;">k</span></span><span class="MJXp-msubsup" id="MJXp-Span-381"><span class="MJXp-mrow" id="MJXp-Span-382" style="margin-right: 0.05em;"><span class="MJXp-mo" id="MJXp-Span-383" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-384" style="vertical-align: 0.5em;">3</span></span></span><span class="MJXp-mrow" id="MJXp-Span-385"><span class="MJXp-mo" id="MJXp-Span-386" style="margin-left: 0.278em; margin-right: 0.278em;">。</span></span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-8"> \ frac {\部分^ 2 \ vec {r} _n} {\部分t ^ 2} = f_n = -G \ sum_ {k \ neq n} m_k \ frac {\ vec {r} _n-\ vec {r } _k} {| \ vec {r} _n-\ vec {r} _k | ^ 3}。 </script></p><br> 这里要注意的是，计算函数的复杂性 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-387"><span class="MJXp-msubsup" id="MJXp-Span-388"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-389" style="margin-right: 0.05em;">f</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-390" style="vertical-align: -0.4em;">n</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9"> f_n </script> 等于 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-391"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-392">O</span><span class="MJXp-mrow" id="MJXp-Span-393"><span class="MJXp-mo" id="MJXp-Span-394" style="margin-left: 0.278em; margin-right: 0.278em;">（</span></span><span class="MJXp-msubsup" id="MJXp-Span-395"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-396" style="margin-right: 0.05em;">N</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-397" style="vertical-align: 0.5em;">2</span></span><span class="MJXp-mrow" id="MJXp-Span-398"><span class="MJXp-mo" id="MJXp-Span-399" style="margin-left: 0.278em; margin-right: 0.278em;">）</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-10"> O（N ^ 2）</script> 并且随着相互作用体数量的增加而显着增加。 <br><br><h2> 数学 </h2><br> 求解微分方程的第一个也是最简单的方法是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Euler方法</a> ，该方法设计用于求解以下形式的方程： <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-400"><span class="MJXp-mtext" id="MJXp-Span-401">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-402">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-403">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-404">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-405">c</span><span class="MJXp-mrow" id="MJXp-Span-406"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-407">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-408">y</span></span><span class="MJXp-mrow" id="MJXp-Span-409"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-410">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-411">x</span></span><span class="MJXp-mo" id="MJXp-Span-412" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-413">f</span><span class="MJXp-mrow" id="MJXp-Span-414"><span class="MJXp-mo" id="MJXp-Span-415" style="margin-left: 0.278em; margin-right: 0.278em;">（</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-416">x</span><span class="MJXp-mrow" id="MJXp-Span-417"><span class="MJXp-mo" id="MJXp-Span-418" style="margin-left: 0.278em; margin-right: 0.278em;">，</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-419">y</span><span class="MJXp-mrow" id="MJXp-Span-420"><span class="MJXp-mo" id="MJXp-Span-421" style="margin-left: 0.278em; margin-right: 0.278em;">）</span></span><span class="MJXp-mrow" id="MJXp-Span-422"><span class="MJXp-mo" id="MJXp-Span-423" style="margin-left: 0.278em; margin-right: 0.278em;">。</span></span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-11"> \ frac {dy} {dx} = f（x，y）。 </script></p><br> 过渡到离散区域后，我们获得： <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-424"><span class="MJXp-msubsup" id="MJXp-Span-425"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-426" style="margin-right: 0.05em;">y</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-427" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-428">i</span></span></span><span class="MJXp-mo" id="MJXp-Span-429" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-msubsup" id="MJXp-Span-430"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-431" style="margin-right: 0.05em;">y</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-432" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-433">i</span><span class="MJXp-mo" id="MJXp-Span-434">−</span><span class="MJXp-mn" id="MJXp-Span-435">1</span></span></span><span class="MJXp-mo" id="MJXp-Span-436" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-437">h</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-438">f</span><span class="MJXp-mrow" id="MJXp-Span-439"><span class="MJXp-mo" id="MJXp-Span-440" style="margin-left: 0.278em; margin-right: 0.278em;">（</span></span><span class="MJXp-msubsup" id="MJXp-Span-441"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-442" style="margin-right: 0.05em;">x</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-443" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-444">i</span><span class="MJXp-mo" id="MJXp-Span-445">−</span><span class="MJXp-mn" id="MJXp-Span-446">1</span></span></span><span class="MJXp-mrow" id="MJXp-Span-447"><span class="MJXp-mo" id="MJXp-Span-448" style="margin-left: 0.278em; margin-right: 0.278em;">，</span></span><span class="MJXp-msubsup" id="MJXp-Span-449"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-450" style="margin-right: 0.05em;">y</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-451" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-452">i</span><span class="MJXp-mo" id="MJXp-Span-453">−</span><span class="MJXp-mn" id="MJXp-Span-454">1</span></span></span><span class="MJXp-mrow" id="MJXp-Span-455"><span class="MJXp-mo" id="MJXp-Span-456" style="margin-left: 0.278em; margin-right: 0.278em;">）</span></span><span class="MJXp-mrow" id="MJXp-Span-457"><span class="MJXp-mo" id="MJXp-Span-458" style="margin-left: 0.278em; margin-right: 0.278em;">，</span></span><span class="MJXp-mtext" id="MJXp-Span-459">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-460">q</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-461">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-462">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-463">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-464">i</span><span class="MJXp-mo" id="MJXp-Span-465" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-466">1</span><span class="MJXp-mo" id="MJXp-Span-467" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mn" id="MJXp-Span-468">2</span><span class="MJXp-mo" id="MJXp-Span-469" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mn" id="MJXp-Span-470">3</span><span class="MJXp-mrow" id="MJXp-Span-471"><span class="MJXp-mo" id="MJXp-Span-472" style="margin-left: 0.278em; margin-right: 0.278em;">，</span></span><span class="MJXp-mtext" id="MJXp-Span-473" style="color: red;">\点</span><span class="MJXp-mrow" id="MJXp-Span-474"><span class="MJXp-mo" id="MJXp-Span-475" style="margin-left: 0.278em; margin-right: 0.278em;">，</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-476">m</span><span class="MJXp-mrow" id="MJXp-Span-477"><span class="MJXp-mo" id="MJXp-Span-478" style="margin-left: 0.278em; margin-right: 0.278em;">，</span></span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-12"> y_ {i} = y_ {i-1} + h f（x_ {i-1}，y_ {i-1}），\ quad i = 1,2,3，\点，m，</script></p><br> 在哪里 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-479"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-480">h</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-13"> h </script> 是整合步骤，并且 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-481"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-482">m</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-14"> m </script>  -集成步骤数。 因此，如果我们需要一次计算物体的位置 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-483"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-484">T</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-15"> T </script> 那我们应该做 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-485"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-486">m</span><span class="MJXp-mo" id="MJXp-Span-487" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mrow" id="MJXp-Span-488"><span class="MJXp-mo" id="MJXp-Span-489" style="margin-left: 0.278em; margin-right: 0.278em;">吨</span></span><span class="MJXp-mrow" id="MJXp-Span-490"><span class="MJXp-mo" id="MJXp-Span-491" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-mrow" id="MJXp-Span-492"><span class="MJXp-mo" id="MJXp-Span-493" style="margin-left: 0.278em; margin-right: 0.278em;">小</span></span><span class="MJXp-mrow" id="MJXp-Span-494"><span class="MJXp-mo" id="MJXp-Span-495" style="margin-left: 0.278em; margin-right: 0.278em;">时</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-16"> m =吨/小时</script> 整合步骤。 在这里第一个问题是可见的-如果 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-496"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-497">T</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-17-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-17"> T </script> 很大，那么我们需要采取大量的集成步骤。 <br><br> 要将欧拉方法应用于我们的问题，应将其简化为一阶系统。 为此，我们引入了另一个变量-粒子速度： <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-498"><span class="MJXp-mtext" id="MJXp-Span-499">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-500">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-501">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-502">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-503">c</span><span class="MJXp-mrow" id="MJXp-Span-504"><span class="MJXp-mtext" id="MJXp-Span-505" style="color: red;">\部</span><span class="MJXp-mrow" id="MJXp-Span-506"><span class="MJXp-mo" id="MJXp-Span-507" style="margin-left: 0.278em; margin-right: 0.278em;">分</span></span><span class="MJXp-mtext" id="MJXp-Span-508">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-509">v</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-510">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-511">c</span><span class="MJXp-msubsup" id="MJXp-Span-512"><span class="MJXp-mrow" id="MJXp-Span-513" style="margin-right: 0.05em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-514">v</span></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-515" style="vertical-align: -0.4em;">n</span></span></span><span class="MJXp-mrow" id="MJXp-Span-516"><span class="MJXp-mtext" id="MJXp-Span-517" style="color: red;">\部</span><span class="MJXp-mrow" id="MJXp-Span-518"><span class="MJXp-mo" id="MJXp-Span-519" style="margin-left: 0.278em; margin-right: 0.278em;">分</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-520">t</span></span><span class="MJXp-mo" id="MJXp-Span-521" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-msubsup" id="MJXp-Span-522"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-523" style="margin-right: 0.05em;">f</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-524" style="vertical-align: -0.4em;">n</span></span><span class="MJXp-mrow" id="MJXp-Span-525"><span class="MJXp-mo" id="MJXp-Span-526" style="margin-left: 0.278em; margin-right: 0.278em;">，</span></span><span class="MJXp-mspace" id="MJXp-Span-527" style="width: 0em; height: 0em;"></span><span class="MJXp-mtext" id="MJXp-Span-528">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-529">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-530">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-531">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-532">c</span><span class="MJXp-mrow" id="MJXp-Span-533"><span class="MJXp-mtext" id="MJXp-Span-534" style="color: red;">\部</span><span class="MJXp-mrow" id="MJXp-Span-535"><span class="MJXp-mo" id="MJXp-Span-536" style="margin-left: 0.278em; margin-right: 0.278em;">分</span></span><span class="MJXp-mtext" id="MJXp-Span-537">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-538">v</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-539">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-540">c</span><span class="MJXp-msubsup" id="MJXp-Span-541"><span class="MJXp-mrow" id="MJXp-Span-542" style="margin-right: 0.05em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-543">r</span></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-544" style="vertical-align: -0.4em;">n</span></span></span><span class="MJXp-mrow" id="MJXp-Span-545"><span class="MJXp-mtext" id="MJXp-Span-546" style="color: red;">\部</span><span class="MJXp-mrow" id="MJXp-Span-547"><span class="MJXp-mo" id="MJXp-Span-548" style="margin-left: 0.278em; margin-right: 0.278em;">分</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-549">t</span></span><span class="MJXp-mo" id="MJXp-Span-550" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mtext" id="MJXp-Span-551">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-552">v</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-553">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-554">c</span><span class="MJXp-msubsup" id="MJXp-Span-555"><span class="MJXp-mrow" id="MJXp-Span-556" style="margin-right: 0.05em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-557">v</span></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-558" style="vertical-align: -0.4em;">n</span></span><span class="MJXp-mrow" id="MJXp-Span-559"><span class="MJXp-mo" id="MJXp-Span-560" style="margin-left: 0.278em; margin-right: 0.278em;">。</span></span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-18-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-18"> \ frac {\部分\ vec {v} _n} {\部分t} = f_n，\\ \ frac {\部分\ vec {r} _n} {\部分t} = \ vec {v} _n。 </script></p><br><br> 解微分方程组的第二个问题是解及其控制的准确性。 可以通过两种方式提高准确性：通过减少积分步骤和选择具有更高准确性的方法。 两种方法都导致计算复杂性的增加，但是方式不同。 例如，您可以使用经典的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">四阶Runge-Kutta方法</a> ；它需要四个函数计算 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-561"><span class="MJXp-msubsup" id="MJXp-Span-562"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-563" style="margin-right: 0.05em;">f</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-564" style="vertical-align: -0.4em;">n</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-19"> f_n </script> 在每个步骤中，但具有一定的准确性 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-565"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-566">O</span><span class="MJXp-mrow" id="MJXp-Span-567"><span class="MJXp-mo" id="MJXp-Span-568" style="margin-left: 0.278em; margin-right: 0.278em;">（</span></span><span class="MJXp-msubsup" id="MJXp-Span-569"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-570" style="margin-right: 0.05em;">h</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-571" style="vertical-align: 0.5em;">4</span></span><span class="MJXp-mrow" id="MJXp-Span-572"><span class="MJXp-mo" id="MJXp-Span-573" style="margin-left: 0.278em; margin-right: 0.278em;">）</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-20-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-20"> O（h ^ 4）</script>  （为了进行比较，欧拉方法的精度为 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-574"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-575">O</span><span class="MJXp-mrow" id="MJXp-Span-576"><span class="MJXp-mo" id="MJXp-Span-577" style="margin-left: 0.278em; margin-right: 0.278em;">（</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-578">h</span><span class="MJXp-mrow" id="MJXp-Span-579"><span class="MJXp-mo" id="MJXp-Span-580" style="margin-left: 0.278em; margin-right: 0.278em;">）</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-21-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-21"> O（h）</script> 并需要进行一次计算 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-581"><span class="MJXp-msubsup" id="MJXp-Span-582"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-583" style="margin-right: 0.05em;">f</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-584" style="vertical-align: -0.4em;">n</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-22-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-22"> f_n </script>  ） 解决方案的准确性也可以通过多种方式控制：与分析解决方案进行比较，使用不同方法或不同步骤进行解决并比较结果，控制解决方案必须遵守的第三方参数和限制。 <br> 而且，这些方法中的每一种都有其缺点。 可能没有分析决定，或者甚至在大多数情况下，甚至是完全没有。 例如，对于我们的任务 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-585"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-586">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-23-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-23"> N </script> 电话分析解决方案仅适用于 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-587"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-588">N</span><span class="MJXp-mo" id="MJXp-Span-589" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-590">2</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-24-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-24"> N = 2 </script>  ，但这足以测试方法的准确性。 用两种方法或用不同的步骤解决问题会增加计算时间，但是这种方法几乎可以应用于任何任务。 并非每项任务都有局限性，但对我们而言，它们都有局限性：在整合的每个步骤中，我们都可以控制<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">保护法</a>的执行。 这种方法也增加了计算的复杂性，但是有很多选择，所有粒子的动量和或角动量之和的计算都非常复杂。 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-591"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-592">O</span><span class="MJXp-mrow" id="MJXp-Span-593"><span class="MJXp-mo" id="MJXp-Span-594" style="margin-left: 0.278em; margin-right: 0.278em;">（</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-595">N</span><span class="MJXp-mrow" id="MJXp-Span-596"><span class="MJXp-mo" id="MJXp-Span-597" style="margin-left: 0.278em; margin-right: 0.278em;">）</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-25-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-25"> O（N）</script>  ，而计算系统的总能量具有阶数复杂性 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-598"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-599">O</span><span class="MJXp-mrow" id="MJXp-Span-600"><span class="MJXp-mo" id="MJXp-Span-601" style="margin-left: 0.278em; margin-right: 0.278em;">（</span></span><span class="MJXp-msubsup" id="MJXp-Span-602"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-603" style="margin-right: 0.05em;">N</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-604" style="vertical-align: 0.5em;">2</span></span><span class="MJXp-mrow" id="MJXp-Span-605"><span class="MJXp-mo" id="MJXp-Span-606" style="margin-left: 0.278em; margin-right: 0.278em;">）</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-26-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-26"> O（N ^ 2）</script><br><br><div class="spoiler">  <b class="spoiler_title">关于计算总能量的注意事项</b> <div class="spoiler_text"> 在我们的案例中，系统的总能量由两部分组成-动能和势能。 动能由所有物体的动能之和组成。 要计算势能，我们需要在剩余粒子的引力场中将每个粒子的势能相加，因此我们需要添加 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-607"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-608">O</span><span class="MJXp-mrow" id="MJXp-Span-609"><span class="MJXp-mo" id="MJXp-Span-610" style="margin-left: 0.278em; margin-right: 0.278em;">（</span></span><span class="MJXp-msubsup" id="MJXp-Span-611"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-612" style="margin-right: 0.05em;">N</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-613" style="vertical-align: 0.5em;">2</span></span><span class="MJXp-mrow" id="MJXp-Span-614"><span class="MJXp-mo" id="MJXp-Span-615" style="margin-left: 0.278em; margin-right: 0.278em;">）</span></span></span></span><script type="math/tex" id="MathJax-Element-27"> O（N ^ 2）</script> 条款。 困难在于所有项的阶次非常不同，即使使用双精度计算，也无法以足以在不同步骤进行比较的精度来计算该值。 为了克服这个问题，有必要根据<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Kahan算法进行</a>求和。 <br></div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d8/270/e1d/4d8270e1d2f39d30e9d2e5beabec6fa0.png" alt="椭圆轨迹"></div><br><p>  <b>图1.</b> <i>椭圆轨迹的示例。</i> </p><br><br><br> 考虑一下卫星绕地球椭圆轨道运动的简单情况。 随着卫星接近地球，其速度会增加，而当远离地球移动时，其速度会降低，因此有可能减少轨道绿色部分的时间积分步长，并以红色和蓝色增加积分步长而不会改变解决方案的精度。 让我们尝试更详细地比较。 <br><br>  <b>表1.</b> <i>研究微分方程的研究方法</i> <br><table><tbody><tr><th> 已标记 </th><th> 订购 </th><th> 内容描述 </th></tr><tr><td> 亚当斯 </td><td>  1-5 </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">亚当斯-巴什福特法</a> </td></tr><tr><td> 欧拉 </td><td>  1个 </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">欧拉法</a> </td></tr><tr><td>  rk4 </td><td>  4 </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">经典Runge-Kutta方法</a> </td></tr><tr><td> 尔克 </td><td>  5 </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">卡什卡普方法</a> </td></tr><tr><td>  rkdp </td><td>  5 </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">多曼王子法</a> </td></tr><tr><td>  rkdverk </td><td>  6 </td><td>  Werner方法<a href="">1）</a> p。  181 </td></tr><tr><td>  rkf </td><td>  7 </td><td> 费尔伯格方法<a href="">1）</a> p。  180 </td></tr><tr><td>  kg </td><td>  6 </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">隐含高斯-勒格德方法</a> </td></tr><tr><td>  rklc </td><td>  4 </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">隐式Lobatto方法</a> </td></tr><tr><td> 空中飞人 </td><td>  2 </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">梯形法</a> </td></tr></tbody></table><br> 要为我们的任务选择最佳方法，我们将比较几种已知方法。 为此，我们模拟了两个物体系统的碰撞 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-616"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-617">N</span><span class="MJXp-mo" id="MJXp-Span-618" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-619">512</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-28-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-28"> N = 512 </script> 并在仿真结束时测量<a href="">总能量</a> ， <a href="">动量</a>及其<a href="">矩</a>的相对变化（最大仿真时间 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-620"><span class="MJXp-msubsup" id="MJXp-Span-621"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-622" style="margin-right: 0.05em;">T</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-623" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-624">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-625">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-626">x</span></span></span><span class="MJXp-mo" id="MJXp-Span-627" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-628">2.5</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-29-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-29"> T_ {max} = 2.5 </script>  ） 在这种情况下，我们将更改集成方法的步骤和参数，并测量函数调用的次数 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-629"><span class="MJXp-msubsup" id="MJXp-Span-630"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-631" style="margin-right: 0.05em;">f</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-632" style="vertical-align: -0.4em;">n</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-30-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-30"> f_n </script> 分别地，那些具有较少调用次数的方法将导致较少的损失，我们将认为更可接受。 <br><br><table><tbody><tr><td align="center"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/c0c/9de/886/c0c9de886418710c403863bc34021d9a.svg"><br></a> <br></td><td align="center"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/311/f1b/614/311f1b6146bb4b13a4bd1db313ee1372.svg"><br></a> <br></td></tr><tr><td align="center">  a） </td><td align="center">  b） </td></tr><tr><td colspan="2" align="center">  <b>图2.</b> <i>系统仿真结束时能量的相对变化a），动量b）</i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-633"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-634">N</span><span class="MJXp-mo" id="MJXp-Span-635" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-636">512</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-31-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-31"> N = 512 </script></i>   <i>根据函数计算的数量，通过各种方法选择主体</i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-637"><span class="MJXp-msubsup" id="MJXp-Span-638"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-639" style="margin-right: 0.05em;">f</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-640" style="vertical-align: -0.4em;">n</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-32-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-32"> f_n </script></i>   <i>双精度</i> </td></tr></tbody></table><br> 从图2的图表可以看出，函数计算量的最佳比率 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-641"><span class="MJXp-msubsup" id="MJXp-Span-642"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-643" style="margin-right: 0.05em;">f</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-644" style="vertical-align: -0.4em;">n</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-33-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-33"> f_n </script> 以及五阶Adams和Dorman-Prince方法中物体系统能量的相对变化。 还可以看到，对于所有方法，计算量都会增加 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-645"><span class="MJXp-msubsup" id="MJXp-Span-646"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-647" style="margin-right: 0.05em;">f</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-648" style="vertical-align: -0.4em;">n</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-34-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-34"> f_n </script> 系统动量的相对变化增加。 对于能量的相对变化，这也很明显，但仅适用于可能达到阈值的几种方法 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-649"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-650">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-651">E</span><span class="MJXp-mrow" id="MJXp-Span-652"><span class="MJXp-mo" id="MJXp-Span-653" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-msubsup" id="MJXp-Span-654"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-655" style="margin-right: 0.05em;">E</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-656" style="vertical-align: -0.4em;">0</span></span><span class="MJXp-mo" id="MJXp-Span-657" style="margin-left: 0.333em; margin-right: 0.333em;">&lt;</span><span class="MJXp-msubsup" id="MJXp-Span-658"><span class="MJXp-mn" id="MJXp-Span-659" style="margin-right: 0.05em;">10</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-660" style="vertical-align: 0.5em;"><span class="MJXp-mo" id="MJXp-Span-661">−</span><span class="MJXp-mn" id="MJXp-Span-662">12</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-35-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-35"> dE / E_0 <10 ^ {-12} </script>  。 这种影响不能再归因于方法的错误，而应归因于计算的错误，并且只有随着浮点数计算精度的提高，精度的进一步提高才可能实现。 <br><table><tbody><tr><td align="center"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/c8e/e99/4ba/c8ee994ba56d3dcbb7c305aad402f0e3.svg"><br></a> <br></td><td align="center"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/745/6a2/7f4/7456a27f4253ae5ac634dcc2ebf0776d.svg"><br></a> <br></td></tr><tr><td align="center">  a） </td><td align="center">  b） </td></tr><tr><td colspan="2" align="center">  <b>图3.</b> <i>系统仿真结束时，能量a），动量b）的相对变化</i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-663"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-664">N</span><span class="MJXp-mo" id="MJXp-Span-665" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-666">512</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-36-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-36"> N = 512 </script></i>   <i>根据函数计算的数量，通过各种方法选择主体</i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-667"><span class="MJXp-msubsup" id="MJXp-Span-668"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-669" style="margin-right: 0.05em;">f</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-670" style="vertical-align: -0.4em;">n</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-37-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-37"> f_n </script></i>   <i>具有四倍精度（__float128）</i> </td></tr></tbody></table><br> 图3a和3b表明，使用具有四倍精度的计算可以将相对能量损失降低至 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-671"><span class="MJXp-msubsup" id="MJXp-Span-672"><span class="MJXp-mn" id="MJXp-Span-673" style="margin-right: 0.05em;">10</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-674" style="vertical-align: 0.5em;"><span class="MJXp-mo" id="MJXp-Span-675">−</span><span class="MJXp-mn" id="MJXp-Span-676">23</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-38-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-38"> 10 ^ {-23} </script>  ，但您需要了解，与双精度相比，计算时间增加了两个数量级。 与双精度计算一样，最佳精度比率和函数计算次数 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-677"><span class="MJXp-msubsup" id="MJXp-Span-678"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-679" style="margin-right: 0.05em;">f</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-680" style="vertical-align: -0.4em;">n</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-39-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-39"> f_n </script> 拥有五阶亚当斯和多曼王子的方法。 <br><br>  Dorman-Prince和Werner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">方法</a>属于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">嵌套方法</a>类，可以同时计算两个精度高低的解决方案（对于Dorman-Prince方法，精度为5和4，对于Werner方法，精度为6和5）。 如果这两种解决方案非常不同，那么我们可以将当前的集成步骤分解为更小的解决方案。 这使我们能够动态更改集成步骤，并仅在需要的地方减少集成步骤。 <br><br> 让我们在更长的系统仿真间隔内更详细地比较五阶Dorman-Prince，Werner和Adams方法（ <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-681"><span class="MJXp-msubsup" id="MJXp-Span-682"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-683" style="margin-right: 0.05em;">T</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-684" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-685">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-686">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-687">x</span></span></span><span class="MJXp-mo" id="MJXp-Span-688" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-689">300</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-40-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-40"> T_ {max} = 300 </script>  ） <br><table><tbody><tr><td align="center"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/dcf/431/463/dcf431463350504334895ae590038f54.svg"><br></a> <br></td></tr><tr><td align="center">  <b>a）</b> <i>建模过程中能量，动量及其动量</i> <b>的</b> <i>相对变化</i> <br></td></tr><tr><td align="center"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/a2f/039/e55/a2f039e5575a01df083f913ab5cbb6d7.svg"><br></a> <br></td></tr><tr><td align="center">  <b>b）</b> <i>函数计算次数</i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-690"><span class="MJXp-msubsup" id="MJXp-Span-691"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-692" style="margin-right: 0.05em;">f</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-693" style="vertical-align: -0.4em;">n</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-41-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-41"> f_n </script></i>   <i>在模拟间隔</i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-694"><span class="MJXp-mtext" id="MJXp-Span-695">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-696">D</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-697">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-698">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-699">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-700">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-701">T</span><span class="MJXp-mo" id="MJXp-Span-702" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-703">0.3</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-42-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-42"> \ Delta T = 0.3 </script></i> <br></td></tr><tr><td align="center">  <b>图4.</b> <i>系统物理参数的相对变化与功能计算次数的关系</i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-704"><span class="MJXp-msubsup" id="MJXp-Span-705"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-706" style="margin-right: 0.05em;">f</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-707" style="vertical-align: -0.4em;">n</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-43-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-43"> f_n </script></i>   <i>使用Dorman-Prince可变步长法不时建模</i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-708"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-709">h</span><span class="MJXp-mo" id="MJXp-Span-710" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-msubsup" id="MJXp-Span-711"><span class="MJXp-mn" id="MJXp-Span-712" style="margin-right: 0.05em;">10</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-713" style="vertical-align: 0.5em;"><span class="MJXp-mo" id="MJXp-Span-714">−</span><span class="MJXp-mn" id="MJXp-Span-715">5</span></span></span><span class="MJXp-mtext" id="MJXp-Span-716" style="color: red;">\点</span><span class="MJXp-msubsup" id="MJXp-Span-717"><span class="MJXp-mn" id="MJXp-Span-718" style="margin-right: 0.05em;">10</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-719" style="vertical-align: 0.5em;"><span class="MJXp-mo" id="MJXp-Span-720">−</span><span class="MJXp-mn" id="MJXp-Span-721">9</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-44-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-44"> h = 10 ^ {-5} \点10 ^ {-9} </script></i> <br></td></tr></tbody></table><br><table><tbody><tr><td align="center"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/db6/ed7/96b/db6ed796b48734885acac334d62bf74c.svg"><br></a> <br></td></tr><tr><td align="center">  <b>a）</b> <i>建模过程中能量，动量及其动量</i> <b>的</b> <i>相对变化</i> <br></td></tr><tr><td align="center"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/1a8/b05/599/1a8b05599c05680aa8501197f70f8d5c.svg"><br></a> <br></td></tr><tr><td align="center">  <b>b）</b> <i>函数计算次数</i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-722"><span class="MJXp-msubsup" id="MJXp-Span-723"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-724" style="margin-right: 0.05em;">f</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-725" style="vertical-align: -0.4em;">n</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-45-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-45"> f_n </script></i>   <i>在模拟间隔</i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-726"><span class="MJXp-mtext" id="MJXp-Span-727">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-728">D</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-729">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-730">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-731">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-732">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-733">T</span><span class="MJXp-mo" id="MJXp-Span-734" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-735">0.3</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-46-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-46"> \ Delta T = 0.3 </script></i> <br></td></tr><tr><td align="center">  <b>图5.</b> <i>系统物理参数的相对变化和功能计算次数的依赖性</i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-736"><span class="MJXp-msubsup" id="MJXp-Span-737"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-738" style="margin-right: 0.05em;">f</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-739" style="vertical-align: -0.4em;">n</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-47-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-47"> f_n </script></i>   <i>可变步长的Werner方法进行时间建模</i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-740"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-741">h</span><span class="MJXp-mo" id="MJXp-Span-742" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-msubsup" id="MJXp-Span-743"><span class="MJXp-mn" id="MJXp-Span-744" style="margin-right: 0.05em;">10</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-745" style="vertical-align: 0.5em;"><span class="MJXp-mo" id="MJXp-Span-746">−</span><span class="MJXp-mn" id="MJXp-Span-747">5</span></span></span><span class="MJXp-mtext" id="MJXp-Span-748" style="color: red;">\点</span><span class="MJXp-msubsup" id="MJXp-Span-749"><span class="MJXp-mn" id="MJXp-Span-750" style="margin-right: 0.05em;">10</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-751" style="vertical-align: 0.5em;"><span class="MJXp-mo" id="MJXp-Span-752">−</span><span class="MJXp-mn" id="MJXp-Span-753">9</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-48-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-48"> h = 10 ^ {-5} \点10 ^ {-9} </script></i> <br></td></tr></tbody></table><br><table><tbody><tr><td align="center"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/f6b/b1e/832/f6bb1e8323381a14ab438133218fdcc8.svg"><br></a> <br></td></tr><tr><td align="center">  <b>图6.</b> <i>用五阶Adams-Bashfort方法建模时，能量，动量及其矩的相对变化</i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-754"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-755">h</span><span class="MJXp-mo" id="MJXp-Span-756" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-msubsup" id="MJXp-Span-757"><span class="MJXp-mn" id="MJXp-Span-758" style="margin-right: 0.05em;">10</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-759" style="vertical-align: 0.5em;"><span class="MJXp-mo" id="MJXp-Span-760">−</span><span class="MJXp-mn" id="MJXp-Span-761">6</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-49-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-49"> h = 10 ^ {-6} </script></i> <br></td></tr></tbody></table><br><table><tbody><tr><td align="center"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/fc2/19e/8fa/fc219e8fa8a9bc8dfddc4ebb5a2aeae5.svg"><br></a> <br></td></tr><tr><td align="center">  <b>图7.</b> <i>函数计算数量的依存关系</i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-762"><span class="MJXp-msubsup" id="MJXp-Span-763"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-764" style="margin-right: 0.05em;">f</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-765" style="vertical-align: -0.4em;">n</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-50-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-50"> f_n </script></i>   <i>从仿真时间开始用于五阶Adams，Dorman-Prince和Werner方法</i> <br></td></tr></tbody></table><br> 可以看出，在我们系统发展的初期（ <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-766"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-767">T</span><span class="MJXp-mo" id="MJXp-Span-768" style="margin-left: 0.333em; margin-right: 0.333em;">&lt;</span><span class="MJXp-mn" id="MJXp-Span-769">25</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-51-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-51"> T <25 </script>  ）这三种方法都显示出相似的特性，但是在后期系统中会发生某些事件，其结果是系统主要参数（总能量，动量及其动量）的误差急剧上升。 但是由于减少了“复杂”部分中的积分步骤的能力，Dorman-Prince和Werner方法能够更好地应对这些变化，结果是函数计算的数量增加了 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-770"><span class="MJXp-msubsup" id="MJXp-Span-771"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-772" style="margin-right: 0.05em;">f</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-773" style="vertical-align: -0.4em;">n</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-52-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-52"> f_n </script> 如图4b和5b所示，但计算总数 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-774"><span class="MJXp-msubsup" id="MJXp-Span-775"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-776" style="margin-right: 0.05em;">f</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-777" style="vertical-align: -0.4em;">n</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-53-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-53"> f_n </script> 嵌套方法比Adams-Bashfort方法要小，如图7所示。 <br><br><div class="spoiler">  <b class="spoiler_title">我不知道这些时候系统发生了什么</b> <div class="spoiler_text"><table><tbody><tr><td align="center"><iframe width="560" height="315" src="https://www.youtube.com/embed/ZPyM6PRXjkY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></td></tr><tr><td align="center">  <b>视频1.</b> <i>建模512个实体的系统。</i>  <i>Dorman-Prince方法。</i>  <i>动态步进</i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-778"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-779">h</span><span class="MJXp-mo" id="MJXp-Span-780" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-msubsup" id="MJXp-Span-781"><span class="MJXp-mn" id="MJXp-Span-782" style="margin-right: 0.05em;">10</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-783" style="vertical-align: 0.5em;"><span class="MJXp-mo" id="MJXp-Span-784">−</span><span class="MJXp-mn" id="MJXp-Span-785">5</span></span></span><span class="MJXp-mtext" id="MJXp-Span-786" style="color: red;">\点</span><span class="MJXp-msubsup" id="MJXp-Span-787"><span class="MJXp-mn" id="MJXp-Span-788" style="margin-right: 0.05em;">10</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-789" style="vertical-align: 0.5em;"><span class="MJXp-mo" id="MJXp-Span-790">−</span><span class="MJXp-mn" id="MJXp-Span-791">9</span></span></span></span></span><script type="math/tex" id="MathJax-Element-54"> h = 10 ^ {-5} \点10 ^ {-9} </script></i> <br></td></tr></tbody></table><br></div></div><br> 视频演示了这一点 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-792"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-793">T</span><span class="MJXp-mo" id="MJXp-Span-794" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-795">25</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-55-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-55"> T = 25 </script> 运动相对平静，此后“星系”中心发生碰撞，这导致轨迹的急剧变化和某些粒子的速度大大增加。 此外，为了保持解决方案的准确性，有必要减少集成步骤。 嵌套方法可以自动执行此操作；图表显示，在系统演化的某些部分中，集成步骤减少了近两个数量级 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-796"><span class="MJXp-msubsup" id="MJXp-Span-797"><span class="MJXp-mn" id="MJXp-Span-798" style="margin-right: 0.05em;">10</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-799" style="vertical-align: 0.5em;"><span class="MJXp-mo" id="MJXp-Span-800">−</span><span class="MJXp-mn" id="MJXp-Span-801">5</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-56-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-56"> 10 ^ {-5} </script> 之前 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-802"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-803">h</span><span class="MJXp-mo" id="MJXp-Span-804" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-msubsup" id="MJXp-Span-805"><span class="MJXp-mn" id="MJXp-Span-806" style="margin-right: 0.05em;">10</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-807" style="vertical-align: 0.5em;"><span class="MJXp-mo" id="MJXp-Span-808">−</span><span class="MJXp-mn" id="MJXp-Span-809">7</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-57-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-57"> h = 10 ^ {-7} </script>  。 当使用Adams方法以及在整个系统演化过程中采取这样的步骤时，我们就不必等待解决方案了。 <br><br><h4> 总结 </h4><br> 对于该解决方案，最好使用嵌套方法，这些方法允许您动态控制积分步骤，并仅在轨迹的“复杂”部分上减少积分步骤。 <br><br> 不要追逐最高顺序的方法。 即使使用“双精度”数据类型，它们也无法发挥其潜在功能，但以更高的精度使用相同的数据类型会极大地增加解决问题所需的时间。 <br><br><h2>  CPU实施 </h2><br> 现在定义了求解方程的方法的选择，让我们尝试计算每个粒子的相互作用力的计算。 对于所有粒子，我们得到一个双循环： <br><br><div class="spoiler">  <b class="spoiler_title">实现代码“简单”</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> body1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; body1 &lt; count; ++body1) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> nbvertex_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">v1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rx[ body1 ], ry[ body1 ], rz[ body1 ])</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">nbvertex_t</span></span> total_force; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> body2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; body2 != count; ++body2) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(body1 == body2) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> nbvertex_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">v2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rx[ body2 ], ry[ body2 ], rz[ body2 ])</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> nbvertex_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">force</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m_data-&gt;force(v1, v2, mass[body1], mass[body2]))</span></span></span></span>; total_force += force; } frx[body1] = vx[body1]; fry[body1] = vy[body1]; frz[body1] = vz[body1]; fvx[body1] = total_force.x / mass[body1]; fvy[body1] = total_force.y / mass[body1]; fvz[body1] = total_force.z / mass[body1]; }</code> </pre> <br></div></div><br> 每个物体的重力是独立计算的，要使用所有处理器核心，在第一个循环之前编写OpenMP指令就足够了： <br><br><div class="spoiler">  <b class="spoiler_title">一段来自“ openmp”实现的代码</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp parallel for for(size_t body1 = 0; body1 &lt; count; ++body1)</span></span></code> </pre><br></div></div><br> 因为 每个主体彼此交互，然后减少处理器与RAM的交互次数并提高缓存使用率，我们可以将部分数据加载到缓存中并重复使用： <br><br><div class="spoiler">  <b class="spoiler_title">实现代码“ openmp +块”</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp parallel for for(size_t n1 = 0; n1 </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; count; n1 += BLOCK_SIZE) { nbcoord_t x1[BLOCK_SIZE]; nbcoord_t y1[BLOCK_SIZE]; nbcoord_t z1[BLOCK_SIZE]; nbcoord_t m1[BLOCK_SIZE]; nbvertex_t total_force[BLOCK_SIZE]; for(size_t b1 = 0; b1 != BLOCK_SIZE; ++b1) { size_t local_n1 = b1 + n1; x1[b1] = rx[local_n1]; y1[b1] = ry[local_n1]; z1[b1] = rz[local_n1]; m1[b1] = mass[local_n1]; } for(size_t n2 = 0; n2 &lt; count; n2 += BLOCK_SIZE) { nbcoord_t x2[BLOCK_SIZE]; nbcoord_t y2[BLOCK_SIZE]; nbcoord_t z2[BLOCK_SIZE]; nbcoord_t m2[BLOCK_SIZE]; for(size_t b2 = 0; b2 != BLOCK_SIZE; ++b2) { size_t local_n2 = b2 + n2; x2[b2] = rx[local_n2]; y2[b2] = ry[local_n2]; z2[b2] = rz[local_n2]; m2[b2] = mass[n2 + b2]; } for(size_t b1 = 0; b1 != BLOCK_SIZE; ++b1) { const nbvertex_t v1(x1[ b1 ], y1[ b1 ], z1[ b1 ]); for(size_t b2 = 0; b2 != BLOCK_SIZE; ++b2) { const nbvertex_t v2(x2[ b2 ], y2[ b2 ], z2[ b2 ]); const nbvertex_t force(m_data-&gt;force(v1, v2, m1[b1], m2[b2])); total_force[b1] += force; } } } for(size_t b1 = 0; b1 != BLOCK_SIZE; ++b1) { size_t local_n1 = b1 + n1; frx[local_n1] = vx[local_n1]; fry[local_n1] = vy[local_n1]; frz[local_n1] = vz[local_n1]; fvx[local_n1] = total_force[b1].x / m1[b1]; fvy[local_n1] = total_force[b1].y / m1[b1]; fvz[local_n1] = total_force[b1].z / m1[b1]; } }</span></span></span></span></code> </pre><br></div></div><br> 进一步的优化包括取出计算主循环力的功能内容，并消除体重m1 [b1]的除法和乘法。 除了我们稍微减少了计算量这一事实外，编译器将能够在如此扩展的周期上应用SSE和AVX处理器的矢量指令。 <br><br><div class="spoiler">  <b class="spoiler_title">实现代码“ openmp +块+优化”</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp parallel for for(size_t n1 = 0; n1 &lt; count; n1 += BLOCK_SIZE) { nbcoord_t x1[BLOCK_SIZE]; nbcoord_t y1[BLOCK_SIZE]; nbcoord_t z1[BLOCK_SIZE]; nbcoord_t total_force_x[BLOCK_SIZE]; nbcoord_t total_force_y[BLOCK_SIZE]; nbcoord_t total_force_z[BLOCK_SIZE]; for(size_t b1 = 0; b1 != BLOCK_SIZE; ++b1) { size_t local_n1 = b1 + n1; x1[b1] = rx[local_n1]; y1[b1] = ry[local_n1]; z1[b1] = rz[local_n1]; total_force_x[b1] = 0; total_force_y[b1] = 0; total_force_z[b1] = 0; } for(size_t n2 = 0; n2 &lt; count; n2 += BLOCK_SIZE) { nbcoord_t x2[BLOCK_SIZE]; nbcoord_t y2[BLOCK_SIZE]; nbcoord_t z2[BLOCK_SIZE]; nbcoord_t m2[BLOCK_SIZE]; for(size_t b2 = 0; b2 != BLOCK_SIZE; ++b2) { size_t local_n2 = b2 + n2; x2[b2] = rx[local_n2]; y2[b2] = ry[local_n2]; z2[b2] = rz[local_n2]; m2[b2] = mass[n2 + b2]; } for(size_t b1 = 0; b1 != BLOCK_SIZE; ++b1) { for(size_t b2 = 0; b2 != BLOCK_SIZE; ++b2) { nbcoord_t dx = x1[b1] - x2[b2]; nbcoord_t dy = y1[b1] - y2[b2]; nbcoord_t dz = z1[b1] - z2[b2]; nbcoord_t r2(dx * dx + dy * dy + dz * dz); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(r2 &lt; NBODY_MIN_R) { r2 = NBODY_MIN_R; } nbcoord_t r = sqrt(r2); nbcoord_t coeff = (m2[b2]) / (r * r2); dx *= coeff; dy *= coeff; dz *= coeff; total_force_x[b1] -= dx; total_force_y[b1] -= dy; total_force_z[b1] -= dz; } } } for(size_t b1 = 0; b1 != BLOCK_SIZE; ++b1) { size_t local_n1 = b1 + n1; frx[local_n1] = vx[local_n1]; fry[local_n1] = vy[local_n1]; frz[local_n1] = vz[local_n1]; fvx[local_n1] = total_force_x[b1]; fvy[local_n1] = total_force_y[b1]; fvz[local_n1] = total_force_z[b1]; } }</span></span></code> </pre><br></div></div><br>  <b>表2.</b> <i>函数计算时间的依赖性（以秒为单位）</i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-810"><span class="MJXp-msubsup" id="MJXp-Span-811"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-812" style="margin-right: 0.05em;">f</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-813" style="vertical-align: -0.4em;">n</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-58-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-58"> f_n </script></i>   <i>相互作用体的数量</i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-814"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-815">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-59-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-59"> N </script></i>   <i>用于各种CPU实现</i> <br><table><tbody><tr><th><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-816"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-817">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-60-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-60"> N </script></th><th>  2048 </th><th>  4096 </th><th>  8192 </th><th>  16384 </th><th>  32768 </th></tr><tr><td> 简单的 </td><td>  0.0425 </td><td>  0.1651 </td><td>  0.6594 </td><td>  2.65 </td><td>  10.52 </td></tr><tr><td> 的openmp </td><td>  0.0078 </td><td>  0.0260 </td><td>  0.1079 </td><td>  0.417 </td><td>  1.655 </td></tr><tr><td>  openmp +块+优化 </td><td>  0.0037 </td><td>  0.0128 </td><td>  0.0495 </td><td>  0.194 </td><td>  0.774 </td></tr></tbody></table><br><div class="spoiler">  <b class="spoiler_title">系统参数：</b> <div class="spoiler_text"><ul><li> 系统： <i>Debian 9，Intel Core i7-5820K（6核心）</i> </li><li> 编译器： <i>gcc 6.3.0</i> </li></ul><br></div></div><br> 可以清楚地看到，具有OpenMP支持的版本在内核数量方面的速度提高了六倍，而优化版本的速度甚至快了两倍多。 因此，通过优化，您不应该仅依赖于并发。 有趣的是，在单流计算中，处理器的工作频率为3.6 GHz，在并行版本（openmp）中，该频率降至3.4 GHz，而在并行优化中（openmp + block +最优化），该频率降至3.3 GHz，但这这并没有阻止她更快地工作13.6倍。 还可以看到，随着问题大小的增加，计算时间的增加是二次方的，并且进一步增加 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-818"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-819">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-61-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-61"> N </script> 使任务在合理的时间内无法解决。 <br><br><h2>  GPU实施 </h2><br> 但是，人们希望更快地进行计算。 有几种方向可用于加速：GPU计算，函数逼近 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-820"><span class="MJXp-msubsup" id="MJXp-Span-821"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-822" style="margin-right: 0.05em;">f</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-823" style="vertical-align: -0.4em;">n</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-62-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-62"> f_n </script>  。 首先，对于GPU计算，我选择了OpenCL技术。 为了更方便的工作，使用了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CLHPP</a>库。  OpenCL的主要优点是代码可以在处理器和GPU上运行，从而简化了编写和调试，并扩展了要运行的硬件列表。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Oclgrind</a>工具有助于调试，该调试在运行时显示不正确的OpenCL API调用和内存访问问题。 <br><br><h4>  Opencl的 </h4><br> 要开始使用OpenCL，您需要获取可用平台的列表。 最常见的平台是AMD，Intel和NVidia。 <br><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;cl::Platform&gt; platforms; cl::Platform::get(&amp;platforms);</code> </pre><br></div></div><br> 接下来，在选择平台之后，您需要选择该平台代表的计算设备： <br><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cl::<span class="hljs-function"><span class="hljs-function">Platform&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">platform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(platforms[platform_n])</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;cl::Device&gt; all_devices; platform.getDevices(CL_DEVICE_TYPE_ALL, &amp;all_devices);</code> </pre><br></div></div><br> 在准备阶段的最后，有必要创建一个上下文和队列，以在其中分配内存并执行计算。 例如，创建一个将选定平台的所有计算设备组合在一起的上下文，如下所示： <br><br><div class="spoiler">  <b class="spoiler_title">上下文和队列创建代码</b> <div class="spoiler_text"><pre> <code class="cpp hljs">cl::<span class="hljs-function"><span class="hljs-function">Context </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">context</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(all_devices)</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;cl::CommandQueue&gt; queues; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(cl::Device device: all_devices) queues.push_back(cl::CommandQueue(context, device));</code> </pre><br></div></div><br> 要将源代码下载到计算设备，必须将其编译，cl :: Program类用于此目的。 <br><br><div class="spoiler">  <b class="spoiler_title">内核编译代码</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &gt; source_data; cl::Program::Sources sources; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i != files.size(); ++i) { source_data.push_back(load_program(files[i]));<span class="hljs-comment"><span class="hljs-comment">//   sources.push_back(std::make_pair(source_data.back().data(), source_data.back().size())); } cl::Program prog(context, sources); devices.push_back(all_devices); prog.build(devices, options);</span></span></code> </pre><br></div></div><br> 为了描述在计算设备上执行的功能（内核）的参数，有一个cl模板：make_kernel。 <br><br><div class="spoiler">  <b class="spoiler_title">交互强度计算内核示例</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> cl::make_kernel&lt; cl_int, cl_int, <span class="hljs-comment"><span class="hljs-comment">//Block offset cl::Buffer, //mass cl::Buffer, //y cl::Buffer, //f cl_int, cl_int, //yoff,foff cl_int, cl_int //points_count,stride &gt; ComputeBlock;</span></span></code> </pre><br></div></div><br> 此外，一切都很简单：我们声明一个具有内核类型的变量，将编译后的程序和计算内核的名称传递给它，我们几乎可以像正常函数一样启动内核。 <br><br><div class="spoiler">  <b class="spoiler_title">内核启动代码</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ComputeBlock </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fcompute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(prog, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ComputeBlockLocal"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; cl::<span class="hljs-function"><span class="hljs-function">NDRange </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">global_range</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(device_data_size)</span></span></span></span>; cl::<span class="hljs-function"><span class="hljs-function">NDRange </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">local_range</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block_size)</span></span></span></span>; cl::<span class="hljs-function"><span class="hljs-function">EnqueueArgs </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eargs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx.m_queue, global_range, local_range)</span></span></span></span>; fcompute(eargs, ...  ); <span class="hljs-comment"><span class="hljs-comment">//,   .</span></span></code> </pre><br></div></div><br>  OpenCL本身的计算核心与CPU的'openmp + block +最优化'选项非常相似，仅与CPU版本不同，第一个周期是使用OpenCL来控制的（周期范围由内核启动代码中的global_range变量确定，而当前的迭代编号可从内核获取）使用函数get_global_id（0））。 首先，部分身体数据从本地内存加载，然后进行处理。 本地内存是该组中所有线程所共有的，因此该下载对于该组仅发生一次，并由该组中的每个线程进行处理，并且 本地内存比全局内存要快得多，计算要快得多。 <br><br><div class="spoiler">  <b class="spoiler_title">内核代码</b> <div class="spoiler_text"><pre> <code class="cpp hljs">__<span class="hljs-function"><span class="hljs-function">kernel </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ComputeBlockLocal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset_n1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset_n2, __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">nbcoord_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* mass, __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">nbcoord_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* y, __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">nbcoord_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* f, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> yoff, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> foff, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> points_count, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> stride)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n1 = get_global_id(<span class="hljs-number"><span class="hljs-number">0</span></span>) + offset_n1; __global <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* rx = y + yoff; __global <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* ry = rx + stride; __global <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* rz = rx + <span class="hljs-number"><span class="hljs-number">2</span></span> * stride; __global <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* vx = rx + <span class="hljs-number"><span class="hljs-number">3</span></span> * stride; __global <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* vy = rx + <span class="hljs-number"><span class="hljs-number">4</span></span> * stride; __global <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* vz = rx + <span class="hljs-number"><span class="hljs-number">5</span></span> * stride; __global <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* frx = f + foff; __global <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* fry = frx + stride; __global <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* frz = frx + <span class="hljs-number"><span class="hljs-number">2</span></span> * stride; __global <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* fvx = frx + <span class="hljs-number"><span class="hljs-number">3</span></span> * stride; __global <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* fvy = frx + <span class="hljs-number"><span class="hljs-number">4</span></span> * stride; __global <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* fvz = frx + <span class="hljs-number"><span class="hljs-number">5</span></span> * stride; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> x1 = rx[n1]; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> y1 = ry[n1]; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> z1 = rz[n1]; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> res_x = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> res_y = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> res_z = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; __local <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> x2[NBODY_DATA_BLOCK_SIZE]; __local <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> y2[NBODY_DATA_BLOCK_SIZE]; __local <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> z2[NBODY_DATA_BLOCK_SIZE]; __local <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> m2[NBODY_DATA_BLOCK_SIZE]; <span class="hljs-comment"><span class="hljs-comment">// NB! get_local_size(0) == NBODY_DATA_BLOCK_SIZE for(int b2 = 0; b2 &lt; points_count; b2 += NBODY_DATA_BLOCK_SIZE) { int n2 = b2 + offset_n2 + get_local_id(0); // Copy data block to local memory x2[ get_local_id(0) ] = rx[n2]; y2[ get_local_id(0) ] = ry[n2]; z2[ get_local_id(0) ] = rz[n2]; m2[ get_local_id(0) ] = mass[n2]; // Synchronize local work-items copy operations barrier(CLK_LOCAL_MEM_FENCE); nbcoord_t local_res_x = 0.0; nbcoord_t local_res_y = 0.0; nbcoord_t local_res_z = 0.0; for(int local_n2 = 0; local_n2 != NBODY_DATA_BLOCK_SIZE; ++local_n2) { nbcoord_t dx = x1 - x2[local_n2]; nbcoord_t dy = y1 - y2[local_n2]; nbcoord_t dz = z1 - z2[local_n2]; nbcoord_t r2 = (dx * dx + dy * dy + dz * dz); if(r2 &lt; NBODY_MIN_R) { r2 = NBODY_MIN_R; } nbcoord_t r = sqrt(r2); nbcoord_t coeff = (m2[local_n2]) / (r * r2); dx *= coeff; dy *= coeff; dz *= coeff; local_res_x -= dx; local_res_y -= dy; local_res_z -= dz; } // Synchronize local work-items computations barrier(CLK_LOCAL_MEM_FENCE); res_x += local_res_x; res_y += local_res_y; res_z += local_res_z; } frx[n1] = vx[n1]; fry[n1] = vy[n1]; frz[n1] = vz[n1]; fvx[n1] = res_x; fvy[n1] = res_y; fvz[n1] = res_z; }</span></span></code> </pre><br></div></div><br><h4> 库达 </h4><br>  NVidia CUDA平台的实现比OpenCL更为简单，我们不需要创建设备上下文并自行管理执行队列（至少在我们要进行多GPU实现之前）。 与OpenCL一样，我们需要在GPU上分配内存，将数据复制到其中，然后才能启动计算核心。 <br><br> 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>阅读有关使用CUDA的更多信息。 <br><br><div class="spoiler">  <b class="spoiler_title">CUDA内核启动代码</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">dim3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(count / block_size)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">dim3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">block</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block_size)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> shared_size(<span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>) * block_size); kfcompute &lt;&lt;&lt; grid, block, shared_size &gt;&gt;&gt; (... ...);</code> </pre><br></div></div><br> 与OpenCL不同，CUDA并未指定完整的迭代范围（在OpenCL实现中为global_range），而是在网格中设置了网格大小和块大小，因此，当前主体数的计算会略有变化，否则内核与OpenCL非常相似，除了其他名称之外共享内存的同步和说明符功能。  CUDA的另一个有用的区别功能是，我们可以在内核启动时指定所需的共享内存大小。 与OpenCL实施一样，在每个迭代块的开头，我们将部分数据复制到共享内存中，然后从该块的所有线程中使用该内存。 <br><br><div class="spoiler">  <b class="spoiler_title">CUDA内核代码</b> <div class="spoiler_text"><pre> <code class="cpp hljs">__<span class="hljs-function"><span class="hljs-function">global__ </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kfcompute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset_n2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">nbcoord_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> yoff, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">nbcoord_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* f, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> foff, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">nbcoord_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* mass, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> points_count, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> stride)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n1 = blockDim.x * blockIdx.x + threadIdx.x; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* rx = y + yoff; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* ry = rx + stride; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* rz = rx + <span class="hljs-number"><span class="hljs-number">2</span></span> * stride; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> x1 = rx[n1]; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> y1 = ry[n1]; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> z1 = rz[n1]; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> res_x = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> res_y = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> res_z = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> __shared__ <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> shared_xyzm_buf[]; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* x2 = shared_xyzm_buf; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* y2 = x2 + blockDim.x; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* z2 = y2 + blockDim.x; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* m2 = z2 + blockDim.x; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; b2 &lt; points_count; b2 += blockDim.x) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n2 = b2 + offset_n2 + threadIdx.x; <span class="hljs-comment"><span class="hljs-comment">// Copy data block to local memory x2[ threadIdx.x ] = rx[n2]; y2[ threadIdx.x ] = ry[n2]; z2[ threadIdx.x ] = rz[n2]; m2[ threadIdx.x ] = mass[n2]; // Synchronize local work-items copy operations __syncthreads(); nbcoord_t local_res_x = 0.0; nbcoord_t local_res_y = 0.0; nbcoord_t local_res_z = 0.0; for(int n2 = 0; n2 != blockDim.x; ++n2) { nbcoord_t dx = x1 - x2[n2]; nbcoord_t dy = y1 - y2[n2]; nbcoord_t dz = z1 - z2[n2]; nbcoord_t r2 = (dx * dx + dy * dy + dz * dz); if(r2 &lt; NBODY_MIN_R) { r2 = NBODY_MIN_R; } nbcoord_t r = sqrt(r2); nbcoord_t coeff = (m2[n2]) / (r * r2); dx *= coeff; dy *= coeff; dz *= coeff; local_res_x -= dx; local_res_y -= dy; local_res_z -= dz; } // Synchronize local work-items computations __syncthreads(); res_x += local_res_x; res_y += local_res_y; res_z += local_res_z; } n1 += foff; f[n1 + 3 * stride] = res_x; f[n1 + 4 * stride] = res_y; f[n1 + 5 * stride] = res_z; }</span></span></code> </pre><br></div></div><br>  <b>表3.</b> <i>计算时间（以秒为单位）函数的依赖性</i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-824"><span class="MJXp-msubsup" id="MJXp-Span-825"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-826" style="margin-right: 0.05em;">f</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-827" style="vertical-align: -0.4em;">n</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-63-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-63"> f_n </script></i>   <i>相互作用体的数量</i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-828"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-829">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-64-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-64"> N </script></i>   <i>适用于各种GPU实现和更好的CPU实现</i> <br><table><tbody><tr><th><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-830"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-831">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-65-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-65"> N </script></th><th>  4096 </th><th>  8192 </th><th>  16384 </th><th>  32768 </th><th>  65536 </th><th>  131072 </th></tr><tr><td>  openmp +块+优化 </td><td>  0.0128 </td><td>  0.0495 </td><td>  0.194 </td><td>  0.774 </td><td>  --- </td><td>  --- </td></tr><tr><td>  OpenCL +一半NVidia K80 </td><td>  0.004 </td><td>  0.008 </td><td>  0.026 </td><td>  0.134 </td><td>  0.322 </td><td>  1.18 </td></tr><tr><td>  CUDA +一半NVidia K80 </td><td>  0.004 </td><td>  0.008 </td><td>  0.0245 </td><td>  0.115 </td><td>  0.291 </td><td>  1.13 </td></tr></tbody></table><br><div class="spoiler">  <b class="spoiler_title">哪里可以买到NVidia K80</b> <div class="spoiler_text">  Google的免费<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Colab</a>服务启动了OpenCL和CUDA实施，该服务提供对NVidia K80计算机的访问。 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">集线器</a>上阅读有关使用此服务的更多信息。 <br></div></div><br> 通常，结果令人失望，仅比CPU实现快5-6倍。 即使我们对整个K80进行计算，我们也会获得高达12倍的加速度，但是 由于任务的复杂性是二次的，因此在合理的时间内，我们将不能处理32768个交互体，而可以处理131072，仅多了4倍。 <br><br><h2> 函数近似 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-832"><span class="MJXp-msubsup" id="MJXp-Span-833"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-834" style="margin-right: 0.05em;">f</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-835" style="vertical-align: -0.4em;">n</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-66-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-66"> f_n </script></h2><br> 如果仔细看一下由两个物体的吸引力设置的函数，很明显它随距离呈二次方减小。 因此，我们可以准确地计算出近身之间以及近身之间的相互作用力。 一种著名的方法 <br> 是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">D.Barnes</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">P.Hat</a>提出的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">树码</a>算法。 在模拟空间中构造了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">八叉树</a> ，其叶子中包含模拟物体的坐标和质量。 父节点包含质心，子节点的总质量以及围绕子节点的实体描述的球体的半径。 树的根包含所有物体的质心，它们的总质量以及围绕它们描述的球体的半径。 在计算相互作用力时，如果到节点的距离与其半径之比大于某个常数，则首先要考虑到树根的距离 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-836"><span class="MJXp-mtext" id="MJXp-Span-837">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-838">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-839">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-840">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-841">b</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-842">d</span><span class="MJXp-msubsup" id="MJXp-Span-843"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-844" style="margin-right: 0.05em;">a</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-845" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-846">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-847">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-848">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-849">t</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-67-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-67"> \ lambda_ {crit} </script>  ，则该根被认为是一个坐标等于其所包含的物体的质心坐标的物体，并且如果该比率小于或等于，则其质量等于子节点的质量之和。 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-850"><span class="MJXp-mtext" id="MJXp-Span-851">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-852">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-853">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-854">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-855">b</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-856">d</span><span class="MJXp-msubsup" id="MJXp-Span-857"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-858" style="margin-right: 0.05em;">a</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-859" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-860">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-861">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-862">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-863">t</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-68-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-68"> \ lambda_ {crit} </script>  ，然后为每个子节点递归地重复该过程。 如果到达树的叶子，则以通常的方式考虑相互作用力。 因此，如果一个物体远离其他物体的紧凑组，则将该组作为一个物体呈现给它，并且不计算每个物体的相互作用力，而只计算一个物体。 因此，算法的复杂度随着 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-864"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-865">O</span><span class="MJXp-mrow" id="MJXp-Span-866"><span class="MJXp-mo" id="MJXp-Span-867" style="margin-left: 0.278em; margin-right: 0.278em;">（</span></span><span class="MJXp-msubsup" id="MJXp-Span-868"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-869" style="margin-right: 0.05em;">N</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-870" style="vertical-align: 0.5em;">2</span></span><span class="MJXp-mrow" id="MJXp-Span-871"><span class="MJXp-mo" id="MJXp-Span-872" style="margin-left: 0.278em; margin-right: 0.278em;">）</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-69-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-69"> O（N ^ 2）</script> 之前 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-873"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-874">O</span><span class="MJXp-mrow" id="MJXp-Span-875"><span class="MJXp-mo" id="MJXp-Span-876" style="margin-left: 0.278em; margin-right: 0.278em;">（</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-877">N</span><span class="MJXp-mtext" id="MJXp-Span-878" style="color: red;">\日</span><span class="MJXp-mrow" id="MJXp-Span-879"><span class="MJXp-mo" id="MJXp-Span-880" style="margin-left: 0.278em; margin-right: 0.278em;">志</span></span><span class="MJXp-mrow" id="MJXp-Span-881"><span class="MJXp-mo" id="MJXp-Span-882" style="margin-left: 0.278em; margin-right: 0.278em;">（</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-883">N</span><span class="MJXp-mrow" id="MJXp-Span-884"><span class="MJXp-mo" id="MJXp-Span-885" style="margin-left: 0.278em; margin-right: 0.278em;">）</span></span><span class="MJXp-mrow" id="MJXp-Span-886"><span class="MJXp-mo" id="MJXp-Span-887" style="margin-left: 0.278em; margin-right: 0.278em;">）</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-70-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-70"> O（N \日志（N））</script> 以牺牲一些准确性为代价。 <br><br> 在我的方法中，我决定不使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">octree</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">树</a> ，而是使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">kd树，</a>因为 与八叉树相比，它更易于使用并且具有较低的存储开销。 <br><br> 让我们回到在CPU上的实现。  kd-tree节点可以以类的形式表示，该类包含指向左右后代的指针以及有关坐标和质量的信息： <br><br><div class="spoiler">  <b class="spoiler_title">Kd树节点</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node</span></span></span><span class="hljs-class"> {</span></span> node* m_left; <span class="hljs-comment"><span class="hljs-comment">//!&lt;   node* m_right; //!&lt;   nbvertex_t m_mass_center; //!&lt;     nbcoord_t m_mass; //!&lt;   nbcoord_t m_radius_sqr; //!&lt;    ,   lambda_crit nbvertex_t m_bmin; //!&lt;     nbvertex_t m_bmax; //!&lt;     size_t m_body_n; //!&lt;  ,    };</span></span></code> </pre><br></div></div><br> 使用这种存储树的方法，我们有两种可能的遍历树的选项：使用显式递归或自己使用堆栈。 我选择了第二个选项。 <br><br><div class="spoiler">  <b class="spoiler_title">通过遍历树计算相互作用力</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">nbvertex_t</span></span> force_compute(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nbvertex_t</span></span>&amp; v1, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> mass1) { <span class="hljs-keyword"><span class="hljs-keyword">nbvertex_t</span></span> total_force; node* stack_data[MAX_STACK_SIZE] = {}; node** <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span> = stack_data; node** stack_head = <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>; *<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>++ = m_root; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span> != stack_head) { node* curr = *--<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> nbcoord_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distance_sqr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">((v1 - curr-&gt;m_mass_center).norm())</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(distance_sqr &gt; curr-&gt;m_radius_sqr) {<span class="hljs-comment"><span class="hljs-comment">//  ,       total_force += force(v1, curr-&gt;m_mass_center, mass1, curr-&gt;m_mass); } else {//   ,      if(curr-&gt;m_right != NULL) { *stack++ = curr-&gt;m_right; } if(curr-&gt;m_left != NULL) { *stack++ = curr-&gt;m_left; } } } return total_force; }</span></span></code> </pre><br></div></div><br> 与“精确” CPU实现的情况一样，每个主体都需要调用力计算功能。 使用OpenMP指令可以轻松地并行化所有主体之间的循环。 <br><br> 但是在这种情况下，相邻循环迭代将引用树的完全不同的部分，这不允许有效使用处理器缓存。 为了克服这个问题，所有物体都不必以原始顺序遍历，而是以物体位于kd-tree的叶子中的顺序遍历，然后对空间紧密的物体进行相邻的迭代，并将沿几乎相同的路径遍历树。 <br><br><div class="spoiler">  <b class="spoiler_title">树叶遍历</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Visitor</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">traverse</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Visitor</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">visit</span></span></span><span class="hljs-class">) {</span></span> node* stack_data[MAX_STACK_SIZE] = {}; node** <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span> = stack_data; node** stack_head = <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>; *<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>++ = m_root; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span> != stack_head) { node* curr = *--<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curr-&gt;m_radius_sqr &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) {<span class="hljs-comment"><span class="hljs-comment">//  .    . if(curr-&gt;m_left != NULL) { *stack++ = curr-&gt;m_left; } if(curr-&gt;m_right != NULL) { *stack++ = curr-&gt;m_right; } } else {//   .  . visit(curr-&gt;m_body_n, curr-&gt;m_mass_center, curr-&gt;m_mass); } } }</span></span></code> </pre><br></div></div><br> 此实现还有另一个问题-没有通用的方法可以并行化这种树遍历。 但是，我们可以完全改变树在内存中的存储方式-我们可以将所有节点存储在一个线性数组中，并通过类似于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">二进制堆</a>的构造完全放弃对后代的指针的存储。 用以下命令开始编号节点时 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-888"><span class="MJXp-mn" id="MJXp-Span-889">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-71-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-71"> 1 </script> 如果节点在单元格编号中 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-890"><span class="MJXp-mrow" id="MJXp-Span-891"><span class="MJXp-mo" id="MJXp-Span-892" style="margin-left: 0.278em; margin-right: 0.278em;">我</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-72-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-72">我</script>  ，那么他的左孩子在牢房中 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-893"><span class="MJXp-mn" id="MJXp-Span-894">2</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-895">i</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-73-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-73"> 2i </script>  ，单元格中的对子 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-896"><span class="MJXp-mn" id="MJXp-Span-897">2</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-898">i</span><span class="MJXp-mo" id="MJXp-Span-899" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-900">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-74-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-74"> 2i + 1 </script>  ，以及单元格中的父级 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-901"><span class="MJXp-mrow" id="MJXp-Span-902"><span class="MJXp-mo" id="MJXp-Span-903" style="margin-left: 0.278em; margin-right: 0.278em;">我</span></span><span class="MJXp-mrow" id="MJXp-Span-904"><span class="MJXp-mo" id="MJXp-Span-905" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-mn" id="MJXp-Span-906">2</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-75-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-75">我/ 2 </script>  。 右边的节点与左边对应的数字 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-907"><span class="MJXp-mrow" id="MJXp-Span-908"><span class="MJXp-mo" id="MJXp-Span-909" style="margin-left: 0.278em; margin-right: 0.278em;">我</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-76-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-76">我</script> 将有一个数字 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-910"><span class="MJXp-mrow" id="MJXp-Span-911"><span class="MJXp-mo" id="MJXp-Span-912" style="margin-left: 0.278em; margin-right: 0.278em;">我</span></span><span class="MJXp-mo" id="MJXp-Span-913" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-914">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-77-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-77">我+ 1 </script>  。 数组本身将有一个长度 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-915"><span class="MJXp-mn" id="MJXp-Span-916">2</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-917">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-78-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-78"> 2N </script>  ，并且所有叶节点将位于最后一个 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-918"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-919">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-79-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-79"> N </script> 此外，单元间距很近的节点将位于阵列的紧密单元中。 树遍历函数将有所变化，但是框架保持不变： <br><br><div class="spoiler">  <b class="spoiler_title">通过遍历数组中的树来计算力</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">nbvertex_t</span></span> force_compute(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nbvertex_t</span></span>&amp; v1, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> mass1) { <span class="hljs-keyword"><span class="hljs-keyword">nbvertex_t</span></span> total_force; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> stack_data[MAX_STACK_SIZE] = {}; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>* <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span> = stack_data; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>* stack_head = <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>; *<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>++ = NBODY_HEAP_ROOT_INDEX; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span> != stack_head) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> curr = *--<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> nbcoord_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distance_sqr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">((v1 - m_mass_center[curr]).norm())</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(distance_sqr &gt; m_radius_sqr[curr]) { total_force += force(v1, m_mass_center[curr], mass1, m_mass[curr]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> left(left_idx(curr)); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> rght(rght_idx(curr)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(rght &lt; m_body_n.size()) { *<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>++ = rght; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left &lt; m_body_n.size()) { *<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>++ = left; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total_force; }</code> </pre><br></div></div><br> 但这并不是将节点存储在数组中的所有可能，我们可以在爬网时拒绝堆栈。 为此，在转到该节点的子节点的代码分支中，添加该函数以计算下一个节点（ <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-920"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-921">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-922">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-923">x</span><span class="MJXp-msubsup" id="MJXp-Span-924"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-925" style="margin-right: 0.05em;">t</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-926" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-927">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-928">p</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-80-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-80"> next_ {up} </script>  ），并在计算相互作用力的分支中，添加跳过当前子树的下一个节点的计算（ <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-929"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-930">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-931">k</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-932">i</span><span class="MJXp-msubsup" id="MJXp-Span-933"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-934" style="margin-right: 0.05em;">p</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-935" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-936">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-937">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-938">w</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-939">n</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-81-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-81"> skip_ {down} </script>  ） <br><br> 要跳过当前子树，我们需要向下到根（方向 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-940"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-941">D</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-82-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-82"> D </script>  ），当我们在右后代中时，一到达左后，便转到相应的右子树（方向 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-942"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-943">R</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-83-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-83"> R </script>  ），如果我们到达根，那么树遍历就完成了。 <br><br><div class="spoiler">  <b class="spoiler_title">子树跳过功能代码</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">index_t</span></span> skip_down(<span class="hljs-keyword"><span class="hljs-keyword">index_t</span></span> idx) { <span class="hljs-comment"><span class="hljs-comment">// While index is 'right' -&gt; go down while(is_right(idx)) { index_t parent = parent_idx(idx); // We at root again. Stop traverse. if(parent == NBODY_HEAP_ROOT_INDEX) { return NBODY_HEAP_ROOT_INDEX; } idx = parent; } return left2right(idx); }</span></span></code> </pre><br></div></div><br><img src="https://habrastorage.org/getpro/habr/post_images/f29/d13/fe4/f29d13fe464d49022665ac28be8912cf.svg"><br>  <b>图8.</b> <i>跳过子树</i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-944"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-945">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-946">k</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-947">i</span><span class="MJXp-msubsup" id="MJXp-Span-948"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-949" style="margin-right: 0.05em;">p</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-950" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-951">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-952">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-953">w</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-954">n</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-84-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-84"> skip_ {down} </script></i>   <i>。</i> <br><br> 要转到下一个节点，请尽可能转到左子节点（方向 <math></math><img src="https://habrastorage.org/getpro/habr/formulas/d07/cc5/b26/d07cc5b26db621faab45e0e0b54ede62.svg" alt="U" data-tex="inline">  ），如果没有后代，则使用函数“从下面”转到下一个节点 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-955"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-956">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-957">k</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-958">i</span><span class="MJXp-msubsup" id="MJXp-Span-959"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-960" style="margin-right: 0.05em;">p</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-961" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-962">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-963">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-964">w</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-965">n</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-85-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-85"> skip_ {down} </script>  。 <br><br><div class="spoiler">  <b class="spoiler_title">转到下一个节点功能代码</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">index_t</span></span> next_up(<span class="hljs-keyword"><span class="hljs-keyword">index_t</span></span> idx, <span class="hljs-keyword"><span class="hljs-keyword">index_t</span></span> tree_size) { <span class="hljs-keyword"><span class="hljs-keyword">index_t</span></span> left = left_idx(idx); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left &lt; tree_size) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> skip_down(idx); }</code> </pre><br></div></div><br><img src="https://habrastorage.org/getpro/habr/post_images/26d/909/a33/26d909a33c617b955c256a3f717fa116.svg"><br>  <b>图9.</b> <i>过渡到下一个节点</i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-966"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-967">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-968">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-969">x</span><span class="MJXp-msubsup" id="MJXp-Span-970"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-971" style="margin-right: 0.05em;">t</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-972" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-973">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-974">p</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-86-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-86"> next_ {up} </script></i>   <i>。</i> <br><br> 似乎我们用循环替换了递归 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-975"><span class="MJXp-mrow" id="MJXp-Span-976"><span class="MJXp-mo" id="MJXp-Span-977" style="margin-left: 0.278em; margin-right: 0.278em;">而</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-87-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-87">而</script> 在功能上 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-978"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-979">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-980">k</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-981">i</span><span class="MJXp-msubsup" id="MJXp-Span-982"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-983" style="margin-right: 0.05em;">p</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-984" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-985">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-986">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-987">w</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-988">n</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-88-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-88"> skip_ {down} </script>  ，这样的替换不会给出任何结果，但是让我们看看如何确定一个节点是否带有数字 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-989"><span class="MJXp-mrow" id="MJXp-Span-990"><span class="MJXp-mo" id="MJXp-Span-991" style="margin-left: 0.278em; margin-right: 0.278em;">我</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-89-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-89">我</script> 右后裔。 只需检查其奇数即可完成操作（正确的孩子在单元格中 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-992"><span class="MJXp-mn" id="MJXp-Span-993">2</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-994">i</span><span class="MJXp-mo" id="MJXp-Span-995" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-996">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-90-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-90"> 2i + 1 </script>  ），因此足以计算 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-997"><span class="MJXp-mrow" id="MJXp-Span-998"><span class="MJXp-mo" id="MJXp-Span-999" style="margin-left: 0.278em; margin-right: 0.278em;">我</span></span><span class="MJXp-mtext" id="MJXp-Span-1000" style="color: red;">\＆</span><span class="MJXp-mn" id="MJXp-Span-1001">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-91-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-91">我\＆1 </script>  。 即 我们将数字相除 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1002"><span class="MJXp-mrow" id="MJXp-Span-1003"><span class="MJXp-mo" id="MJXp-Span-1004" style="margin-left: 0.278em; margin-right: 0.278em;">我</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-92-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-92">我</script> 如果最低有效位设置为1，则为2。 但这无需循环即可完成，在许多处理器中，都有一条<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">查找第一设置</a>指令返回第一设置位的位置，使用它我们将循环变成四个处理器指令。 <br><br><div class="spoiler">  <b class="spoiler_title">优化的跳过子树功能代码</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">index_t</span></span> skip_down(<span class="hljs-keyword"><span class="hljs-keyword">index_t</span></span> idx) { idx = idx &gt;&gt; (__builtin_ffs(~idx) - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left2right(idx); }</code> </pre><br></div></div><br> 之后，我们可以从树遍历函数中排除堆栈，并用一对替换 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1005"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1006">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1007">k</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1008">i</span><span class="MJXp-msubsup" id="MJXp-Span-1009"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1010" style="margin-right: 0.05em;">p</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1011" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1012">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1013">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1014">w</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1015">n</span></span></span><span class="MJXp-mo" id="MJXp-Span-1016" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1017">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1018">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1019">x</span><span class="MJXp-msubsup" id="MJXp-Span-1020"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1021" style="margin-right: 0.05em;">t</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1022" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1023">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1024">p</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-93-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-93"> skip_ {down} + next_ {up} </script>  ，之后函数看起来更简单： <br><br><div class="spoiler">  <b class="spoiler_title">通过遍历数组中的树而不使用堆栈来计算力</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">nbvertex_t</span></span> force_compute(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nbvertex_t</span></span>&amp; v1, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> mass1) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">nbvertex_t</span></span> total_force; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> curr = NBODY_HEAP_ROOT_INDEX; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> tree_size = m_mass_center.size(); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> nbcoord_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distance_sqr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">((v1 - m_mass_center[curr]).norm())</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(distance_sqr &gt; m_radius_sqr[curr]) { total_force += force(v1, m_mass_center[curr], mass1, m_mass[curr]); curr = skip_down(curr); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { curr = next_up(curr, tree_size); } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(curr != NBODY_HEAP_ROOT_INDEX); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total_force; }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">总共，我们得到了树遍历和力计算的六个组合。</font><font style="vertical-align: inherit;">比较这些方法的计算时间和质量。</font><font style="vertical-align: inherit;">我们将经过100次迭代后系统总能量的相对变化作为质量度量。</font><font style="vertical-align: inherit;">作为模型系统，我们采用两个相互作用的“星系”</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1025"><span class="MJXp-mn" id="MJXp-Span-1026"><font style="vertical-align: inherit;"></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个</font><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1025"><span class="MJXp-mn" id="MJXp-Span-1026"><font style="vertical-align: inherit;"> 16384具</font></span></span></span><font style="vertical-align: inherit;">尸体。</font><b><font style="vertical-align: inherit;">表4.</font></b><i><font style="vertical-align: inherit;">树木遍历方法和力计算的组合</font></i></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-94-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-94">16384</script><font style="vertical-align: inherit;"></font><br><br> <b><font style="vertical-align: inherit;"></font></b> <i><font style="vertical-align: inherit;"></font></i> <br><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 树遍历/力计算类型 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 树与堆栈 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 堆的“堆” </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 没有堆的“堆” </font></font></th></tr><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 按主体编号进行迭代 </font></font></th><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 循环+树 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 循环+堆 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 周期+无堆 </font></font></td></tr><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 叶旁路 </font></font></th><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nestedtree +树 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nestedtree +堆 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 嵌套树+无堆 </font></font></td></tr></tbody></table><br><table><tbody><tr><td align="center"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/dc4/be0/e89/dc4be0e898fd575d0bdf4228a5310884.svg"><br></a> <br></td><td align="center"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/aa2/ca4/e2d/aa2ca4e2daa0cfa77f59f0e6112a3714.svg"><br></a> <br></td></tr><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a）</font></font></b> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数计算时间依赖性</font></font></i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1027"><span class="MJXp-msubsup" id="MJXp-Span-1028"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1029" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f </font></font></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-1030" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-95-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-95">f_n</script></i>  <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从到树节点的关键距离到它的半径的比率（</font></font></i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1031"><span class="MJXp-msubsup" id="MJXp-Span-1032"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1033" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">λ </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1034" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1035"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ç </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1036"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ř </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1037"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我</font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1038"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">吨</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-96-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-96">\lambda_{crit}</script></i>  <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font></i> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b）</font></font></b> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">系统中能量的相对变化对到树节点的临界距离与其半径之比的依赖关系（</font></font></i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1039"><span class="MJXp-msubsup" id="MJXp-Span-1040"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1041" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">λ </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1042" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1043"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ç </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1044"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ř </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1045"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我</font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1046"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">吨</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-97-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-97">\lambda_{crit}</script></i>  <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font></i> </td></tr><tr><td colspan="2" align="center"> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图10. </font></font></b> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数计算结果</font></font></i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1047"><span class="MJXp-msubsup" id="MJXp-Span-1048"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1049" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f </font></font></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-1050" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n以</font></font></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-98-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-98">f_n</script></i>  <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各种方式在CPU上（主体数</font></font></i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1051"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1052"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N </font></font></span><span class="MJXp-mo" id="MJXp-Span-1053" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mn" id="MJXp-Span-1054"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32768</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-99-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-99">N=32768</script></i>  <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></i> </td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以看出，“嵌套树+树”的实现速度毫无希望地落后，因为 </font><font style="vertical-align: inherit;">它缺乏并发性。</font><font style="vertical-align: inherit;">最重要的是实现在数组中具有树节点的位置并在二进制堆中建立索引的实现。</font><font style="vertical-align: inherit;">能量的相对变化对于所有具有</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1055"><span class="MJXp-msubsup" id="MJXp-Span-1056"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1057" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">λ </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1058" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1059"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ç </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1060"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ř </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1061"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我</font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1062"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">吨</font></font></span></span></span><span class="MJXp-mo" id="MJXp-Span-1063" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &gt; </font></font></span><span class="MJXp-mn" id="MJXp-Span-1064"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-100-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-100">\lambda_{crit} > 1</script>  。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同样在图。</font><font style="vertical-align: inherit;">图10a显示了</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1065"><span class="MJXp-msubsup" id="MJXp-Span-1066"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1067" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">λ </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1068" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1069"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ç </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1070"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ř </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1071"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我</font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1072"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">吨</font></font></span></span></span><span class="MJXp-mo" id="MJXp-Span-1073" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &lt; </font></font></span><span class="MJXp-mn" id="MJXp-Span-1074"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），所有实施例函数运算</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-101-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-101">\lambda_{crit} < 10</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1075"><span class="MJXp-msubsup" id="MJXp-Span-1076"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1077" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f </font></font></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-1078" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></span></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大大超过了精确计算的最优化版本（“ openmp +块+优化”），并且进一步提高了速度</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-102-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-102">f_n</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1079"><span class="MJXp-msubsup" id="MJXp-Span-1080"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1081" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">λ </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1082" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1083"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ç </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1084"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[R </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1085"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我</font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1086"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">牛逼</font></font></span></span></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">树木损失精度版本的实现。</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-103-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-103">\lambda_{crit}</script><font style="vertical-align: inherit;"></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GPU树遍历 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我尝试使用OpenCL技术和CUDA绕过GPU上的树。</font><font style="vertical-align: inherit;">以树形式存储节点的选项被立即丢弃，仅剩下将树存储在具有索引的数组中的选项，如在二进制堆中那样。</font><font style="vertical-align: inherit;">通常，计算核心的实现与CPU版本没有太大区别。</font></font><br><br><div class="spoiler"> <b class="spoiler_title">OpenCL        (    )</b> <div class="spoiler_text"><pre> <code class="cpp hljs">__<span class="hljs-function"><span class="hljs-function">kernel </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ComputeTreeBH</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset_n1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> points_count, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tree_size, __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">nbcoord_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* y, __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">nbcoord_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* f, __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">nbcoord_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* tree_cmx, __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">nbcoord_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* tree_cmy, __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">nbcoord_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* tree_cmz, __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">nbcoord_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* tree_mass, __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">nbcoord_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* tree_crit_r2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n1 = get_global_id(<span class="hljs-number"><span class="hljs-number">0</span></span>) + offset_n1; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> stride = points_count; __global <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* rx = y; __global <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* ry = rx + stride; __global <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* rz = rx + <span class="hljs-number"><span class="hljs-number">2</span></span> * stride; __global <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* vx = rx + <span class="hljs-number"><span class="hljs-number">3</span></span> * stride; __global <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* vy = rx + <span class="hljs-number"><span class="hljs-number">4</span></span> * stride; __global <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* vz = rx + <span class="hljs-number"><span class="hljs-number">5</span></span> * stride; __global <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* frx = f; __global <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* fry = frx + stride; __global <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* frz = frx + <span class="hljs-number"><span class="hljs-number">2</span></span> * stride; __global <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* fvx = frx + <span class="hljs-number"><span class="hljs-number">3</span></span> * stride; __global <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* fvy = frx + <span class="hljs-number"><span class="hljs-number">4</span></span> * stride; __global <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* fvz = frx + <span class="hljs-number"><span class="hljs-number">5</span></span> * stride; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> x1 = rx[n1]; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> y1 = ry[n1]; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> z1 = rz[n1]; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> res_x = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> res_y = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> res_z = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> stack_data[MAX_STACK_SIZE] = {}; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> stack_head = <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>; stack_data[<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>++] = NBODY_HEAP_ROOT_INDEX; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span> != stack_head) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> curr = stack_data[--<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> dx = x1 - tree_cmx[curr]; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> dy = y1 - tree_cmy[curr]; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> dz = z1 - tree_cmz[curr]; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> r2 = (dx * dx + dy * dy + dz * dz); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(r2 &gt; tree_crit_r2[curr]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(r2 &lt; NBODY_MIN_R) { r2 = NBODY_MIN_R; } <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> r = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(r2); <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> coeff = tree_mass[curr] / (r * r2); dx *= coeff; dy *= coeff; dz *= coeff; res_x -= dx; res_y -= dy; res_z -= dz; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> left = left_idx(curr); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rght = rght_idx(curr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left &lt; tree_size) { stack_data[<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>++] = left; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(rght &lt; tree_size) { stack_data[<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>++] = rght; } } } frx[n1] = vx[n1]; fry[n1] = vy[n1]; frz[n1] = vz[n1]; fvx[n1] = res_x; fvy[n1] = res_y; fvz[n1] = res_z; }</code> </pre><br></div></div><br>             ,        ,        GPU.       ,    ,           , ..        .  ,           ,   ,          ,    ,   ,          tn1. <br><br><div class="spoiler"> <b class="spoiler_title">OpenCL        (     )</b> <div class="spoiler_text"><pre> <code class="cpp hljs">__<span class="hljs-function"><span class="hljs-function">kernel </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ComputeHeapBH</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset_n1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> points_count, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tree_size, __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">nbcoord_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* y, __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">nbcoord_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* f, __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">nbcoord_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* tree_cmx, __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">nbcoord_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* tree_cmy, __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">nbcoord_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* tree_cmz, __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">nbcoord_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* tree_mass, __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">nbcoord_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* tree_crit_r2, __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* body_n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tree_offset = points_count - <span class="hljs-number"><span class="hljs-number">1</span></span> + NBODY_HEAP_ROOT_INDEX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> stride = points_count; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tn1 = get_global_id(<span class="hljs-number"><span class="hljs-number">0</span></span>) + offset_n1 + tree_offset; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n1 = body_n[tn1]; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> x1 = tree_cmx[tn1]; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> y1 = tree_cmy[tn1]; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> z1 = tree_cmz[tn1]; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> res_x = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> res_y = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> res_z = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> stack_data[MAX_STACK_SIZE] = {}; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> stack_head = <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>; stack_data[<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>++] = NBODY_HEAP_ROOT_INDEX; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span> != stack_head) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> curr = stack_data[--<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> dx = x1 - tree_cmx[curr]; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> dy = y1 - tree_cmy[curr]; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> dz = z1 - tree_cmz[curr]; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> r2 = (dx * dx + dy * dy + dz * dz); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(r2 &gt; tree_crit_r2[curr]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(r2 &lt; NBODY_MIN_R) { r2 = NBODY_MIN_R; } <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> r = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(r2); <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> coeff = tree_mass[curr] / (r * r2); dx *= coeff; dy *= coeff; dz *= coeff; res_x -= dx; res_y -= dy; res_z -= dz; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> left = left_idx(curr); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rght = rght_idx(curr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left &lt; tree_size) { stack_data[<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>++] = left; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(rght &lt; tree_size) { stack_data[<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>++] = rght; } } } __global <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* vx = y + <span class="hljs-number"><span class="hljs-number">3</span></span> * stride; __global <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* vy = y + <span class="hljs-number"><span class="hljs-number">4</span></span> * stride; __global <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* vz = y + <span class="hljs-number"><span class="hljs-number">5</span></span> * stride; __global <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* frx = f; __global <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* fry = frx + stride; __global <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* frz = frx + <span class="hljs-number"><span class="hljs-number">2</span></span> * stride; __global <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* fvx = frx + <span class="hljs-number"><span class="hljs-number">3</span></span> * stride; __global <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* fvy = frx + <span class="hljs-number"><span class="hljs-number">4</span></span> * stride; __global <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>* fvz = frx + <span class="hljs-number"><span class="hljs-number">5</span></span> * stride; frx[n1] = vx[n1]; fry[n1] = vy[n1]; frz[n1] = vz[n1]; fvx[n1] = res_x; fvy[n1] = res_y; fvz[n1] = res_z; }</code> </pre><br></div></div><br>           .      .  ,      ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> , ..      ,     .   ,      ,        ,       ,       ,      ,        .    ,   ,      . 即<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当遍历树的其余部分时，计算核心的相邻线程不会访问树的相同节点，而是紧密位于内存中。</font><font style="vertical-align: inherit;">要优化此内存访问，可以使用纹理内存。</font><font style="vertical-align: inherit;">但是有一个障碍。</font><font style="vertical-align: inherit;">目前，纹理不支持使用双精度数据（我们要精确计算）。</font><font style="vertical-align: inherit;">但是在CUDA中，有一个</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__hiloint2double</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">，它从两个整数中收集一个双精度数。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来自存储整数的纹理的双精度数字请求代码</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nb1Dfetch</span></span></span><span class="hljs-class">&lt;double&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> double4 vec4; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> __<span class="hljs-function"><span class="hljs-function">device__ </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cudaTextureObject_t tex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">int2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tex1Dfetch&lt;int2&gt;(tex, i))</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> __hiloint2double(py, px); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> __<span class="hljs-function"><span class="hljs-function">device__ vec4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cudaTextureObject_t tex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ii</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * i)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">int4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tex1Dfetch&lt;int4&gt;(tex, ii))</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">int4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tex1Dfetch&lt;int4&gt;(tex, ii + </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span></span>; vec4 d4 = {__hiloint2double(p1.y, p1.x), __hiloint2double(p1.w, p1.z), __hiloint2double(p2.y, p2.x), __hiloint2double(p2.w, p2.z) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d4; } };</code> </pre><br></div></div><br>      ,      (x, y, z, tree_crit_r2)  ,        .      ,     <i>r2 &gt; tree_crit_r2[curr]</i> ,         .      CUDA       L1     ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">cudaFuncSetCacheConfig</a> ).         ,      L1   . <br><br><div class="spoiler"> <b class="spoiler_title">CUDA        (     )</b> <div class="spoiler_text"><pre> <code class="cpp hljs">__<span class="hljs-function"><span class="hljs-function">global__ </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kfcompute_heap_bh_tex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset_n1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> points_count, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tree_size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">nbcoord_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* f, cudaTextureObject_t tree_xyzr, cudaTextureObject_t tree_mass, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* body_n)</span></span></span><span class="hljs-function"> </span></span>{ nb1Dfetch&lt;<span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>&gt; tex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tree_offset = points_count - <span class="hljs-number"><span class="hljs-number">1</span></span> + NBODY_HEAP_ROOT_INDEX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> stride = points_count; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tn1 = blockDim.x * blockIdx.x + threadIdx.x + offset_n1 + tree_offset; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n1 = body_n[tn1]; <span class="hljs-keyword"><span class="hljs-keyword">nbvec4_t</span></span> xyzr = tex.fetch4(tree_xyzr, tn1); <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> x1 = xyzr.x; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> y1 = xyzr.y; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> z1 = xyzr.z; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> res_x = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> res_y = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> res_z = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> stack_data[MAX_STACK_SIZE] = {}; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> stack_head = <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>; stack_data[<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>++] = NBODY_HEAP_ROOT_INDEX; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span> != stack_head) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> curr = stack_data[--<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">nbvec4_t</span></span> xyzr2 = tex.fetch4(tree_xyzr, curr); <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> dx = x1 - xyzr2.x; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> dy = y1 - xyzr2.y; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> dz = z1 - xyzr2.z; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> r2 = (dx * dx + dy * dy + dz * dz); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(r2 &gt; xyzr2.w) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(r2 &lt; NBODY_MIN_R) { r2 = NBODY_MIN_R; } <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> r = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(r2); <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> coeff = tex.fetch(tree_mass, curr) / (r * r2); dx *= coeff; dy *= coeff; dz *= coeff; res_x -= dx; res_y -= dy; res_z -= dz; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> left = nbody_heap_func&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::left_idx(curr); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rght = nbody_heap_func&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::rght_idx(curr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left &lt; tree_size) { stack_data[<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>++] = left; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(rght &lt; tree_size) { stack_data[<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>++] = rght; } } } f[n1 + <span class="hljs-number"><span class="hljs-number">3</span></span> * stride] = res_x; f[n1 + <span class="hljs-number"><span class="hljs-number">4</span></span> * stride] = res_y; f[n1 + <span class="hljs-number"><span class="hljs-number">5</span></span> * stride] = res_z; }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对nvprof分析器中的程序进行的分析表明，即使使用纹理内存存储树，全局内存上的负载仍然非常高。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际上，在CUDA中，所有寻址到“计算出的”地址的内核内存都存储在全局内存中，因此，遍历树所需的堆栈位于全局内存中，并且吞噬了内存芯片带宽的很大一部分，因为该堆栈具有每个运行线程，并且有很多线程。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，幸运的是，我们已经知道如何在不使用堆栈的情况下遍历树。</font><font style="vertical-align: inherit;">用计算下一个树节点的功能对先前的计算核心进行补充，我们得到了一个新的内核，而且更加紧凑。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CUDA核心，无需遍历堆栈即可遍历树来计算强度</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">__<span class="hljs-function"><span class="hljs-function">global__ </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kfcompute_heap_bh_stackless</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset_n1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> points_count, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tree_size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">nbcoord_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* f, cudaTextureObject_t tree_xyzr, cudaTextureObject_t tree_mass, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* body_n)</span></span></span><span class="hljs-function"> </span></span>{ nb1Dfetch&lt;<span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span>&gt; tex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tree_offset = points_count - <span class="hljs-number"><span class="hljs-number">1</span></span> + NBODY_HEAP_ROOT_INDEX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> stride = points_count; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tn1 = blockDim.x * blockIdx.x + threadIdx.x + offset_n1 + tree_offset; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n1 = body_n[tn1]; <span class="hljs-keyword"><span class="hljs-keyword">nbvec4_t</span></span> xyzr = tex.fetch4(tree_xyzr, tn1); <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> x1 = xyzr.x; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> y1 = xyzr.y; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> z1 = xyzr.z; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> res_x = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> res_y = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> res_z = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> curr = NBODY_HEAP_ROOT_INDEX; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">nbvec4_t</span></span> xyzr2 = tex.fetch4(tree_xyzr, curr); <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> dx = x1 - xyzr2.x; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> dy = y1 - xyzr2.y; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> dz = z1 - xyzr2.z; <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> r2 = (dx * dx + dy * dy + dz * dz); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(r2 &gt; xyzr2.w) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(r2 &lt; NBODY_MIN_R) { r2 = NBODY_MIN_R; } <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> r = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(r2); <span class="hljs-keyword"><span class="hljs-keyword">nbcoord_t</span></span> coeff = tex.fetch(tree_mass, curr) / (r * r2); dx *= coeff; dy *= coeff; dz *= coeff; res_x -= dx; res_y -= dy; res_z -= dz; curr = nbody_heap_func&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::skip_idx(curr); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { curr = nbody_heap_func&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::next_up(curr, tree_size); } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(curr != NBODY_HEAP_ROOT_INDEX); f[n1 + <span class="hljs-number"><span class="hljs-number">3</span></span> * stride] = res_x; f[n1 + <span class="hljs-number"><span class="hljs-number">4</span></span> * stride] = res_y; f[n1 + <span class="hljs-number"><span class="hljs-number">5</span></span> * stride] = res_z; }</code> </pre><br></div></div><br>  ,   GPU,     ,     .    ,  ,          .     ,          ,        ,  ,                 .                .        NVidia K80. <br><br> <b> 5.</b> <i>   ( ) </i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1087"><span class="MJXp-msubsup" id="MJXp-Span-1088"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1089" style="margin-right: 0.05em;">f</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-1090" style="vertical-align: -0.4em;">n</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-104-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-104">f_n</script></i>  <i>     GPU    </i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1091"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1092">N</span><span class="MJXp-mo" id="MJXp-Span-1093" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-1094">131072</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-105-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-105">N=131072</script></i>  <i></i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1095"><span class="MJXp-msubsup" id="MJXp-Span-1096"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1097" style="margin-right: 0.05em;">λ</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1098" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1099">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1100">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1101">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1102">t</span></span></span><span class="MJXp-mo" id="MJXp-Span-1103" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-1104">10</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-106-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-106">\lambda_{crit}=10</script></i> <br><table><tbody><tr><th>  / </th><th>  8 </th><th>  16 </th><th> 32 </th><th> 64 </th><th> 128 </th><th> 256 </th><th> 512 </th><th> 1024 </th></tr><tr><td> opencl+dense </td><td> 5.77 </td><td> 2.84 </td><td> 1.46 </td><td> <b>1.13</b> </td><td> 1.15 </td><td> 1.14 </td><td> 1.14 </td><td> 1.13 </td></tr><tr><td> cuda+dense </td><td> 5.44 </td><td> 2.55 </td><td> 1.27 </td><td> <b>0.96</b> </td><td> 0.97 </td><td> 0.99 </td><td> 0.99 </td><td>  -- </td></tr><tr><td> opencl+heap+cycle </td><td> 5.88 </td><td> 5.65 </td><td> 5.74 </td><td> 5.96 </td><td> 5.37 </td><td> 5.38 </td><td> <b>5.35</b> </td><td> 5.38 </td></tr><tr><td> opencl+heap+nested </td><td> 4.54 </td><td> <b>3.68</b> </td><td> 3.98 </td><td> 5.25 </td><td> 5.46 </td><td> 5.41 </td><td> 5.48 </td><td> 5.31 </td></tr><tr><td> cuda+heap+nested </td><td>  3.62 </td><td>  2.81 </td><td> <b>2.68</b> </td><td> 4.26 </td><td> 4.84 </td><td> 4.75 </td><td> 4.8 </td><td> 4.67 </td></tr><tr><td> cuda+heap+nested+tex </td><td> 2.6 </td><td> 1.51 </td><td> 0.912 </td><td> <b>0.7</b> </td><td> 1.85 </td><td> 1.75 </td><td> 1.69 </td><td> 1.61 </td></tr><tr><td> cuda+heap+nested+tex+stackless </td><td> 2.3 </td><td> 1.29 </td><td> 0.773 </td><td> <b>0.5</b> </td><td> 0.51 </td><td> 0.52 </td><td> 0.52 </td><td> 0.52 </td></tr></tbody></table><br><br> <b> 6.</b> <i>   ( ) </i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1105"><span class="MJXp-msubsup" id="MJXp-Span-1106"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1107" style="margin-right: 0.05em;">f</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-1108" style="vertical-align: -0.4em;">n</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-107-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-107">f_n</script></i>  <i>     GPU    </i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1109"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1110">N</span><span class="MJXp-mo" id="MJXp-Span-1111" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-1112">1</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1113">M</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-108-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-108">N=1M</script></i>  <i></i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1114"><span class="MJXp-msubsup" id="MJXp-Span-1115"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1116" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">λ </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1117" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1118"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ç </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1119"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ř </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1120"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我</font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1121"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">吨</font></font></span></span></span><span class="MJXp-mo" id="MJXp-Span-1122" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font></span><span class="MJXp-mn" id="MJXp-Span-1123"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-109-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-109">\lambda_{crit}=4</script></i> <br><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 块大小/核心 </font></font></th><th>  8 </th><th>  16 </th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 32 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 64 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 128 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 256 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 512 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1024 </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> opencl +密集 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 366 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 179 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 89.9 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 69.3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 70.3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 69.1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 68.9 </font></font></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">68.0</font></font></b> </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CUDA +密集 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 346 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 162 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 79.6 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 60.8 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 60.8 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 60.7 </font></font></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">59.6</font></font></b> </td><td>  -- </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> opencl +堆+周期 </font></font></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16.2</font></font></b> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 18.2 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 20.1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 21.2 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 21.2 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 21.3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 21.2 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 21.1 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> opencl +堆+嵌套 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10.5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7.63 </font></font></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.38</font></font></b> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8.23 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9.95 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9.89 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9.65 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9.66 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CUDA +堆+嵌套 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8.67 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6.44 </font></font></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.39</font></font></b> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5.93 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8.65 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8.61 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8.41 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8.27 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CUDA +堆+嵌套+ TEX </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6.38 </font></font></td><td>  3.57 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.13 </font></font></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.44</font></font></b> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3.56 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3.46 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3.30 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3.29 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cuda +堆+嵌套+ tex +无堆栈 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5.78 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3.19 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1.83 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1.21 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1.11 </font></font></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.10</font></font></b> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1.11 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1.13 </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是一个困难的情况，但是与树遍历的CPU版本不同，很明显，每个优化步骤都会带来切实的结果。</font><font style="vertical-align: inherit;">与完全函数计算的精确解决方案相比，“ opencl +堆+周期”的实现慢了近6倍</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1124"><span class="MJXp-msubsup" id="MJXp-Span-1125"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1126" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">˚F </font></font></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-1127" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ñ</font></font></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-110-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-110">f_n</script>  。  'opencl+heap+nested',        ,    1.4 , ..    .   'cuda+heap+nested'   L1    ,       1.4 ,   ,   cuda       (  'opencl+dense'  'cuda+dense'  ,    cuda    ~1.2 ).      ( 3.8 )              .        'cuda+heap+nested+tex+stackless'    1.4 , ..                     .  ,  <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1128"><span class="MJXp-msubsup" id="MJXp-Span-1129"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1130" style="margin-right: 0.05em;">λ</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1131" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1132">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1133">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1134">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1135">t</span></span></span><span class="MJXp-mo" id="MJXp-Span-1136" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-1137">10</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-111-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-111">\lambda_{crit}=10</script>             <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1138"><span class="MJXp-msubsup" id="MJXp-Span-1139"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1140" style="margin-right: 0.05em;">f</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-1141" style="vertical-align: -0.4em;">n</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-112-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-112">f_n</script>  。 但是 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1142"><span class="MJXp-msubsup" id="MJXp-Span-1143"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1144" style="margin-right: 0.05em;">λ</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1145" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1146">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1147">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1148">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1149">t</span></span></span><span class="MJXp-mo" id="MJXp-Span-1150" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-1151">10</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-113-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-113">\lambda_{crit}=10</script>    ,                    CPU  ,       <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1152"><span class="MJXp-msubsup" id="MJXp-Span-1153"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1154" style="margin-right: 0.05em;">λ</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1155" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1156">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1157">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1158">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1159">t</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-114-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-114">\lambda_{crit}</script>     .   <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1160"><span class="MJXp-msubsup" id="MJXp-Span-1161"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1162" style="margin-right: 0.05em;">λ</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1163" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1164">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1165">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1166">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1167">t</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-115-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-115">\lambda_{crit}</script>    ,      . <br><table><tbody><tr><td align="center"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/ae8/8b7/344/ae88b7344bf6c884545168e2870edeec.svg"><br></a> <br></td><td align="center"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/85e/073/df6/85e073df6103f00705376ff7deb32ca1.svg"><br></a> <br></td></tr><tr><td align="center"> <b>a)</b> <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1168"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1169"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N </font></font></span><span class="MJXp-mo" id="MJXp-Span-1170" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mn" id="MJXp-Span-1171"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">128 </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1172"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">K</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-116-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-116">N=128K</script><br></td><td align="center"> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b）</font></font></b> <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1173"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1174"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N </font></font></span><span class="MJXp-mo" id="MJXp-Span-1175" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mn" id="MJXp-Span-1176"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1177"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">百万</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-117-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-117">N=1M</script><br></td></tr><tr><td colspan="2" align="center"> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图11. </font></font></b> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数计算时间的依赖性。</font></font></i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1178"><span class="MJXp-msubsup" id="MJXp-Span-1179"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1180" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f </font></font></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-1181" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-118-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-118">f_n</script></i>  <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从到树节点的关键距离到它的半径的比率（</font></font></i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1182"><span class="MJXp-msubsup" id="MJXp-Span-1183"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1184" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">λ </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1185" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1186"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ç </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1187"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ř </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1188"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我</font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1189"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">吨</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-119-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-119">\lambda_{crit}</script></i>  <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于各种GPU遍历的实现）</font></font></i> <br></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 可以看出，对于小 </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1190"><span class="MJXp-msubsup" id="MJXp-Span-1191"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1192" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">λ </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1193" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1194"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ç </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1195"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ř </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1196"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我</font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1197"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ť</font></font></span></span></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计算特征的所有方法</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-120-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-120">\lambda_{crit}</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1198"><span class="MJXp-msubsup" id="MJXp-Span-1199"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1200" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f </font></font></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-1201" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></span></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接近于关闭值，该值由构造kd-tree和准备GPU数据时确定。</font><font style="vertical-align: inherit;">此外，植树的时间对</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-121-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-121">f_n</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1202"><span class="MJXp-msubsup" id="MJXp-Span-1203"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1204" style="margin-right: 0.05em;">λ</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1205" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1206">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1207">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1208">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1209">t</span></span></span><span class="MJXp-mo" id="MJXp-Span-1210" style="margin-left: 0.333em; margin-right: 0.333em;">≤</span><span class="MJXp-mn" id="MJXp-Span-1211">4</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-122-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-122">\lambda_{crit}\leq 4</script> ,     .  ,   <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1212"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1213">N</span><span class="MJXp-mo" id="MJXp-Span-1214" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-1215">128</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1216">K</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-123-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-123">N=128K</script>      <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1217"><span class="MJXp-msubsup" id="MJXp-Span-1218"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1219" style="margin-right: 0.05em;">λ</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1220" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1221">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1222">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1223">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1224">t</span></span></span><span class="MJXp-mo" id="MJXp-Span-1225" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-1226">1024</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-124-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-124">\lambda_{crit}=1024</script> ,     ,    GPU        ,     L1    <i>'branch divergence'</i> .  ,         (cuda+heap+nested+tex+stackless),          <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1227"><span class="MJXp-mn" id="MJXp-Span-1228"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.4 </font></font></span><span class="MJXp-mo" id="MJXp-Span-1229" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mn" id="MJXp-Span-1230"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.5</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">倍。</font><font style="vertical-align: inherit;">其他实现则慢了好几倍。</font><font style="vertical-align: inherit;">为了合并结果，我们将在具有更新架构的GPU上计算时间。</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-125-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-125">1.4-1.5</script><font style="vertical-align: inherit;"></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GeForce GTX 1080 Ti的发布结果（单精度）</font></font></b> <div class="spoiler_text"> <b> 7.</b> <i>   ( ) </i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1231"><span class="MJXp-msubsup" id="MJXp-Span-1232"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1233" style="margin-right: 0.05em;">f</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-1234" style="vertical-align: -0.4em;">n</span></span></span></span><script type="math/tex" id="MathJax-Element-126">f_n</script></i>  <i>     GPU    </i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1235"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1236">N</span><span class="MJXp-mo" id="MJXp-Span-1237" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-1238">1</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1239">M</span></span></span><script type="math/tex" id="MathJax-Element-127">N=1M</script></i>  <i></i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1240"><span class="MJXp-msubsup" id="MJXp-Span-1241"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1242" style="margin-right: 0.05em;">λ</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1243" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1244">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1245">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1246">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1247">t</span></span></span><span class="MJXp-mo" id="MJXp-Span-1248" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-1249">4</span></span></span><script type="math/tex" id="MathJax-Element-128">\lambda_{crit}=4</script></i> <br><table><tbody><tr><th>  / </th><th>  8 </th><th>  16 </th><th> 32 </th><th> 64 </th><th> 128 </th><th> 256 </th><th> 512 </th><th> 1024 </th></tr><tr><td> opencl+dense </td><td> 47.8 </td><td> 23.4 </td><td> 11.6 </td><td> <b>11.59</b> </td><td> 12.8 </td><td> 12.8 </td><td> 12.8 </td><td> 12.8 </td></tr><tr><td> cuda+dense </td><td> 49.0 </td><td> 23.8 </td><td> 11.9 </td><td> 11.8 </td><td> <b>11.7</b> </td><td> 11.7 </td><td> 11.7 </td><td> 11.7 </td></tr><tr><td> opencl+heap+cycle </td><td> 7.48 </td><td> 8.26 </td><td> 7.73 </td><td> 7.36 </td><td> 7.33 </td><td> <b>7.27</b> </td><td> 7.25 </td><td> 7.26 </td></tr><tr><td> opencl+heap+nested </td><td> 1.33 </td><td> <b>1.20</b> </td><td> 1.41 </td><td> 2.46 </td><td> 2.53 </td><td> 2.49 </td><td> 2.44 </td><td> 2.47 </td></tr><tr><td> cuda+heap+nested </td><td> 1.23 </td><td> <b>1.10</b> </td><td> 1.31 </td><td> 2.28 </td><td> 2.29 </td><td> 2.28 </td><td> 2.23 </td><td> 2.25 </td></tr><tr><td> cuda+heap+nested+tex </td><td> 0.88 </td><td> 0.68 </td><td> <b>0.654</b> </td><td>  1.6 </td><td>  1.6 </td><td>  1.6 </td><td>  1.6 </td><td>  1.6 </td></tr><tr><td> cuda+heap+nested+tex+stackless </td><td> 0.71 </td><td> 0.47 </td><td> 0.45 </td><td> 0.43 </td><td> 0.43 </td><td> 0.42 </td><td> 0.41 </td><td> <b>0.395</b> </td></tr></tbody></table><br><table><tbody><tr><td align="center"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/b14/d81/e27/b14d81e271e2edf7b1d70faa815e1710.svg"><br></a> <br></td></tr><tr><td align="center"> <b> 12.</b> <i>   </i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1250"><span class="MJXp-msubsup" id="MJXp-Span-1251"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1252" style="margin-right: 0.05em;">f</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-1253" style="vertical-align: -0.4em;">n</span></span></span></span><script type="math/tex" id="MathJax-Element-129">f_n</script></i>  <i>          (</i> <math> </math><i><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1254"><span class="MJXp-msubsup" id="MJXp-Span-1255"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1256" style="margin-right: 0.05em;">λ</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1257" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1258">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1259">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1260">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1261">t</span></span></span></span></span><script type="math/tex" id="MathJax-Element-130">\lambda_{crit}</script></i>  <i>)   GPU   </i> <br></td></tr></tbody></table><br></div></div><br>   GeForce GTX 1080 Ti  ,             ,  ,      .      ,      GPU   .    5-7 ,                 GPU, ,       ,        .  ,            . <br><br> ,    —          ( <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1262"><span class="MJXp-msubsup" id="MJXp-Span-1263"><span class="MJXp-mn" id="MJXp-Span-1264" style="margin-right: 0.05em;">2</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1265" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-1266">20</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-131-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-131">2^{20}</script> )     ,    GPU.    GPU (Tesla V100), ,            , ..       ,    Tesla K80. ,            ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  </a> , ,   ,  . <br><br><h2> 结论 </h2><br>                   ,               .  ,      «  »,      <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1267"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1268">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-132-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-132">N</script> ,          ,      . <br><br><h4> 可视化 </h4><br>  ,              . <br><br>    .    60 . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/AYzgTC0qqV0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模拟由一百万颗恒星组成的星系的演化。</font><font style="vertical-align: inherit;">中心是质量总计为99％的物体。</font><font style="vertical-align: inherit;">单个颗粒几乎无法区分。</font><font style="vertical-align: inherit;">已经更像一滴液体中的波浪。</font><font style="vertical-align: inherit;">根据速度模块着色。</font><font style="vertical-align: inherit;">低速-蓝色，中-绿色，高-红色。</font><font style="vertical-align: inherit;">可以看出，在中心速度较高，并逐渐减小到边缘，而在赤道面最低。</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/0_8nZCrVqWI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">百万星系演化的更“动态”模拟。</font><font style="vertical-align: inherit;">中心是质量占总质量10％的物体。</font><font style="vertical-align: inherit;">中央身体对其余部分的影响明显较小。</font><font style="vertical-align: inherit;">首先，“星星”飞散，然后聚集成几个星团，最后又形成一个大星团。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在建模过程中，约有5％的“星星”不可撤销地离开了初始区域。</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/XLvIPK6m6QI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在第十秒，它非常类似于现有的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">车轮星系</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">项目代码可以在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上找到</font><font style="vertical-align: inherit;">。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN437014/">https://habr.com/ru/post/zh-CN437014/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN437002/index.html">有效的ASP.NET Core</a></li>
<li><a href="../zh-CN437004/index.html">YML程序员是否梦想过可以进行测试？</a></li>
<li><a href="../zh-CN437006/index.html">Wanhao Duplicator 10 3D打印机评论</a></li>
<li><a href="../zh-CN437008/index.html">NLP。 基础知识。 技术。 自我发展。 第一部分</a></li>
<li><a href="../zh-CN437010/index.html">过去的回声：年轻的经验，基于新的X射线光谱法</a></li>
<li><a href="../zh-CN437018/index.html">Python中静态类型的一些陷阱</a></li>
<li><a href="../zh-CN437020/index.html">强化学习有什么问题？</a></li>
<li><a href="../zh-CN437022/index.html">噪声安全位0x22（故障注入攻击，35C3和Wallet.fail）</a></li>
<li><a href="../zh-CN437026/index.html">Google因滥用个人数据而对GDPR处以5000万欧元的罚款</a></li>
<li><a href="../zh-CN437030/index.html">一个豪华办公室的基础设施自动化：外观</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>