<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¼â€âš•ï¸ ğŸ”’ ğŸ¤´ğŸ¿ Pengkodean dan pengujian KNN di Julia ğŸ–ï¸ ğŸ–ï¸ ğŸ‘ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bahasa baru dalam Ilmu Data. Julia adalah bahasa yang agak jarang di Rusia, meskipun telah digunakan di luar negeri selama 5 tahun (mereka mengejutkan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengkodean dan pengujian KNN di Julia</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417967/"><img src="https://habrastorage.org/webt/hx/ll/o1/hxllo1o7cjoe3cc4qu5ozcz-_lk.jpeg"><br><br>  Bahasa baru dalam Ilmu Data.  Julia adalah bahasa yang agak jarang di Rusia, meskipun telah digunakan di luar negeri selama 5 tahun (mereka mengejutkan saya juga).  Tidak ada sumber dalam bahasa Rusia, jadi saya memutuskan untuk menjelaskan kasus Julia, diambil dari satu buku yang bagus.  Cara terbaik untuk belajar bahasa adalah mulai menulis sesuatu di dalamnya.  <s>Dan agar ini juga menarik perhatian, gunakan pembelajaran mesin.</s> <br><a name="habracut"></a><br>  Halo habrozhitelam. <br><br>  Beberapa waktu yang lalu, saya mulai belajar bahasa baru Julia.  Yah, seperti baru.  Ini adalah sesuatu antara Matlab dan Python, sintaksinya sangat mirip, dan bahasanya sendiri ditulis dalam C / C ++.  Secara umum, sejarah penciptaan, apa, mengapa dan mengapa ada di Wikipedia dan dalam beberapa artikel tentang HabrÃ©. <br><br>  Hal pertama yang memulai studi saya tentang bahasa - benar, Google on Coursera <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kursus online</a> google dalam bahasa Inggris.  Di sana, tentang sintaksis dasar +, sebuah proyek mini tentang prediksi penyakit di Afrika ditulis secara paralel.  Dasar-dasar dan latihan segera.  Jika Anda memerlukan sertifikat, beli versi lengkap.  Saya pergi secara gratis.  Perbedaan antara versi ini adalah tidak ada yang akan memeriksa tes dan DZ Anda.  Lebih penting bagi saya untuk berkenalan daripada sertifikat.  (Baca macet 50 dolar) <br><br>  Setelah itu saya memutuskan untuk membaca buku tentang Julia.  Google mengeluarkan daftar buku dan mempelajari ulasan serta ulasan lebih lanjut, memilih salah satunya dan memesannya di Amazon.  Versi buku selalu lebih bagus untuk dibaca dan digambar dengan pensil. <br><br>  Buku ini disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Julia for Data Science</a> oleh Zacharias Voulgaris, PhD.  Kutipan yang ingin saya sajikan berisi banyak kesalahan ketik dalam kode yang saya perbaiki dan karenanya akan menyajikan versi yang berfungsi + hasil saya. <br><br><h3>  KNN </h3><br>  Ini adalah contoh penerapan algoritma klasifikasi untuk metode tetangga terdekat.  Mungkin salah satu algoritma pembelajaran mesin tertua.  Algoritma tidak memiliki fase pembelajaran dan cukup cepat.  Artinya cukup sederhana: untuk mengklasifikasikan objek baru, Anda perlu menemukan "tetangga" yang serupa dari kumpulan data (database) dan kemudian menentukan kelas dengan memilih. <br><br>  Saya akan segera memesan bahwa Julia memiliki paket yang sudah jadi, dan lebih baik menggunakannya untuk mengurangi waktu dan mengurangi kesalahan.  Tetapi kode ini, dengan cara tertentu, menunjukkan sintaks Julia.  Lebih mudah bagi saya untuk belajar bahasa baru dengan contoh daripada membaca ekstrak kering dari bentuk umum suatu fungsi. <br><br>  Jadi, apa yang kita miliki di pintu masuk: <br><br>  <i>Data pelatihan X</i> (sampel pelatihan), <i>label data pelatihan x</i> (label yang sesuai), <i>data pengujian Y</i> (pemilihan tes), <i>jumlah tetangga k</i> (jumlah tetangga). <br><br>  Anda akan membutuhkan 3 fungsi: <i>fungsi perhitungan jarak, fungsi klasifikasi</i> dan <i>utama</i> . <br><br>  Intinya adalah: mengambil satu elemen dari array tes, menghitung jarak dari itu ke elemen-elemen dari array pelatihan.  Kemudian kami memilih indeks elemen <i>k</i> yang ternyata sedekat mungkin.  Kami menetapkan elemen yang diuji untuk kelas yang paling umum di antara tetangga terdekat. <br><br><pre><code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalculateDistance</span></span></span></span>{T&lt;:Number}(x::Array{T,<span class="hljs-number"><span class="hljs-number">1</span></span>}, y::Array{T,<span class="hljs-number"><span class="hljs-number">1</span></span>}) dist = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>:length(x) dist += (x[<span class="hljs-type"><span class="hljs-type">i</span></span>] - y[<span class="hljs-type"><span class="hljs-type">i</span></span>])^<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> dist = sqrt(dist) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dist <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Fungsi utama dari algoritma.  Matriks jarak antara objek pelatihan dan sampel uji, label set pelatihan, dan jumlah "tetangga" terdekat datang ke input.  Outputnya adalah label yang diprediksi untuk objek baru dan probabilitas masing-masing label. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Classify{T&lt;:<span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>}(distances::<span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>{Float64,<span class="hljs-number"><span class="hljs-number">1</span></span>}, labels::<span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>{T,<span class="hljs-number"><span class="hljs-number">1</span></span>}, k::<span class="hljs-type"><span class="hljs-type">Int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">unique</span></span>(labels) nc = length(<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>) #number <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> classes indexes = <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>(<span class="hljs-type"><span class="hljs-type">Int</span></span>,k) #initialize vector <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> indexes <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the nearest neighbors M = typemax(typeof(distances[<span class="hljs-number"><span class="hljs-number">1</span></span>])) #the largest possible number that this vector can have class_count = zeros(<span class="hljs-type"><span class="hljs-type">Int</span></span>, nc) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>:k indexes[i] = indmin(distances) #<span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the minimum element <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a collection distances[indexes[i]] = M #make sure this element <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> selected again <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> klabels = labels[indexes] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>:nc <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>:k <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> klabels[j] == <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>[i] class_count[i] +=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> m, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = findmax(class_count) conf = m/k #confidence <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> prediction <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>], conf <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Dan tentu saja, semua fungsinya. <br><br>  Kami akan memiliki set pelatihan <i>X</i> pada input, tanda pelatihan set <i>x</i> , set tes <i>Y</i> dan jumlah "tetangga" <i>k</i> . <br><br>  Pada output kami akan menerima label yang diprediksi dan probabilitas yang sesuai dari setiap penghargaan kelas. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> main{T1&lt;:Number, T2&lt;:<span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>}(X::<span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>{T1,<span class="hljs-number"><span class="hljs-number">2</span></span>}, x::<span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>{T2,<span class="hljs-number"><span class="hljs-number">1</span></span>}, Y::<span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>{T1,<span class="hljs-number"><span class="hljs-number">2</span></span>}, k::<span class="hljs-type"><span class="hljs-type">Int</span></span>) N = size(X,<span class="hljs-number"><span class="hljs-number">1</span></span>) n = size(Y,<span class="hljs-number"><span class="hljs-number">1</span></span>) D = <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>(Float64,N) #initialize distance matrix z = <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>(eltype(x),n) #initialize labels vector c = <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>(Float64, n) #confidence <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> prediction <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>:n <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>:N D[j] = CalculateDistance(X[j,:], vec(Y[i,:])) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> z[i], c[i] = Classify(D,x,k) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> z, c <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><h3>  Pengujian </h3><br>  Mari kita uji apa yang kita dapatkan.  Untuk kenyamanan, kami menyimpan algoritme dalam file kNN.jl. <br><br>  Pangkalan tersebut dipinjam dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kursus Pembelajaran Mesin Terbuka</a> .  Dataset ini disebut Pengenalan Aktivitas Manusia Samsung.  Data berasal dari accelerometer dan giroskop ponsel Samsung Galaxy S3, jenis aktivitas seseorang dengan ponsel di sakunya juga diketahui - apakah ia berjalan, berdiri, berbaring, duduk atau berjalan naik / turun tangga.  Kami akan memecahkan masalah menentukan jenis aktivitas fisik secara tepat sebagai masalah klasifikasi. <br><br>  Tag akan sesuai dengan yang berikut: <br>  1 - berjalan <br>  2 - memanjat tangga <br>  3 - menuruni tangga <br>  4 - kursi <br>  5 - seseorang berdiri saat ini <br>  6 - orang itu berbohong <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">include</span></span>("kNN.jl") training = readdlm("samsung_train.txt"); training_label = readdlm("samsung_train_labels.txt"); testing = readdlm("samsung_test.txt"); testing_label = readdlm("samsung_test_labels.txt"); training_label = map(<span class="hljs-type"><span class="hljs-type">Int</span></span>, training_label) testing_label = map(<span class="hljs-type"><span class="hljs-type">Int</span></span>, testing_label) z = main(training, vec(training_label), testing, <span class="hljs-number"><span class="hljs-number">7</span></span>) n = length(testing_label) println(sum(testing_label .== z[<span class="hljs-number"><span class="hljs-number">1</span></span>]) / n)</code> </pre><br>  <i><u>Hasil:</u> 0.9053274516457415</i> <br><br>  Kualitas dinilai dengan rasio objek yang diprediksi dengan benar terhadap seluruh sampel uji.  Sepertinya tidak terlalu buruk.  Tetapi tujuan saya lebih untuk menunjukkan Julia, dan bahwa ia memiliki tempat untuk berada di Ilmu Data. <br><br><h3>  Visualisasi </h3><br>  Selanjutnya, saya ingin mencoba memvisualisasikan hasil klasifikasi.  Untuk melakukan ini, Anda perlu membuat gambar dua dimensi, memiliki 561 tanda dan tidak tahu mana yang paling signifikan.  Oleh karena itu, untuk mengurangi dimensi dan desain data selanjutnya pada subruang ortogonal fitur, diputuskan untuk menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Principal Component Analysis</a> (PCA).  Di Julia, seperti halnya di Python, ada paket yang sudah jadi, jadi kami sedikit menyederhanakan hidup kami. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MultivariateStats #<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> PCA A = testing[<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>,:] #PCA <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> A M_A = fit(PCA, A<span class="hljs-string"><span class="hljs-string">'; maxoutdim = 2) Jtr_A = transform(M_A, A'</span></span>); #PCA <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> training M = fit(PCA, training<span class="hljs-string"><span class="hljs-string">'; maxoutdim = 2) Jtr = transform(M, training'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Gadfly #shows training points <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> uncertain <span class="hljs-type"><span class="hljs-type">point</span></span> pl1 = plot(training, layer(x = Jtr[<span class="hljs-number"><span class="hljs-number">1</span></span>,:], y = Jtr[<span class="hljs-number"><span class="hljs-number">2</span></span>,:],color = training_label, Geom.point), layer(x = Jtr_A[<span class="hljs-number"><span class="hljs-number">1</span></span>,:], y = Jtr_A[<span class="hljs-number"><span class="hljs-number">2</span></span>,:], Geom.point)) #predicted <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> uncertain points <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> testing data z1 = main(training, vec(training_label), A, <span class="hljs-number"><span class="hljs-number">7</span></span>) pl2 = plot(training, layer(x = Jtr[<span class="hljs-number"><span class="hljs-number">1</span></span>,:], y = Jtr[<span class="hljs-number"><span class="hljs-number">2</span></span>,:],color = training_label, Geom.point), layer(x = Jtr_A[<span class="hljs-number"><span class="hljs-number">1</span></span>,:], y = Jtr_A[<span class="hljs-number"><span class="hljs-number">2</span></span>,:],color = z[<span class="hljs-number"><span class="hljs-number">1</span></span>], Geom.point)) vstack(pl1, pl2)</code> </pre><br>  Pada gambar pertama, set pelatihan dan beberapa objek dari set tes ditandai, yang perlu ditugaskan ke kelas mereka.  Dengan demikian, gambar kedua menunjukkan bahwa benda-benda ini ditandai. <br><br><img src="https://habrastorage.org/webt/uh/zw/31/uhzw311gbulqnu5dokanhemvpc0.png"><br><img src="https://habrastorage.org/webt/qv/jl/w3/qvjlw39ux5t7dgq-ahepadrhutq.png"><br><br><pre> <code class="hljs markdown">println(z[<span class="hljs-string"><span class="hljs-string">1</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">1:10</span></span>], z[<span class="hljs-string"><span class="hljs-string">2</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">1:10</span></span>]) &gt; [<span class="hljs-string"><span class="hljs-string">5, 5, 5, 5, 5, 5, 5, 5, 5, 4</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">1.0, 0.888889, 0.888889, 0.888889, 1.0, 1.0, 1.0, 1.0, 0.777778, 0.555556</span></span>]</code> </pre><br>  Melihat gambar-gambar, saya ingin mengajukan pertanyaan "mengapa cluster seperti itu jelek?".  Saya akan jelaskan.  Cluster individu tidak digambarkan dengan sangat jelas karena sifat data dan penggunaan PCA.  Untuk PCA, hanya berjalan dan menaiki tangga seperti satu kelas - kelas gerak.  Dengan demikian, kelas kedua adalah kelas istirahat (duduk, berdiri, berbaring, yang tidak terlalu berbeda di antara mereka sendiri).  Dan karena itu, pemisahan yang jelas dapat ditelusuri ke dalam dua kelas, bukan enam. <br><br><h3>  Kesimpulan </h3><br>  Bagi saya, ini hanyalah perendaman awal dalam Julia dan penggunaan bahasa ini dalam pembelajaran mesin.  Omong-omong, di mana saya juga lebih cenderung menjadi amatir daripada seorang profesional.  Tetapi sementara saya tertarik, saya akan terus mempelajari masalah ini lebih dalam.  Banyak sumber asing bertaruh pada Julia.  Baiklah, tunggu dan lihat. <br><br>  PS: Jika itu menarik, saya dapat memberi tahu Anda di posting berikut tentang fitur sintaks, tentang IDE, dengan instalasi yang saya punya masalah. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417967/">https://habr.com/ru/post/id417967/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417955/index.html">Bagaimana menjadi perancang antarmuka. Keterampilan yang diperlukan dan alat yang kuat yang tidak kita ketahui</a></li>
<li><a href="../id417957/index.html">Buka webinar Mekanisme Kontainer Linux</a></li>
<li><a href="../id417959/index.html">10 tips desain antarmuka</a></li>
<li><a href="../id417963/index.html">Angin, belalang, dan tenggat waktu: bagaimana kami membangun gardu listrik</a></li>
<li><a href="../id417965/index.html">Buka pelajaran â€œKami menulis perpustakaan kami untuk bekerja dengan file xlsxâ€</a></li>
<li><a href="../id417969/index.html">Giliran saya adalah yang paling lambat: perusahaan berusaha untuk menghilangkan antrian</a></li>
<li><a href="../id417971/index.html">Time-to-Market sebagai kartu truf untuk implementasi DevOps</a></li>
<li><a href="../id417973/index.html">Tanya Ethan: Film mana yang menunjukkan perjalanan waktu dengan benar?</a></li>
<li><a href="../id417975/index.html">Eksekusi tidak dapat diampuni</a></li>
<li><a href="../id417977/index.html">Hasil Diskusi dengan topik: Pemikiran Pribadi, Tim dan Organisasi â€(LAF 2018)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>