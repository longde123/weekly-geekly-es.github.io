<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïò üòî üßôüèæ F√ºhren Sie Unit-Tests lokal in STM32CubeIDE unter Windows aus üöª üè∞ ü¶Ä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 


 Jeder kennt die Vorteile von Unit-Tests. Wenn Sie Tests gleichzeitig mit dem Code schreiben, k√∂nnen Sie Fehler fr√ºher erkennen und ansc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>F√ºhren Sie Unit-Tests lokal in STM32CubeIDE unter Windows aus</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469367/"><h3 id="vvedenie">  Einf√ºhrung </h3><br><p><img src="https://habrastorage.org/webt/8f/3q/2r/8f3q2rt_-eycgp3_ejr_hfwqnva.png" align="left" width="200">  Jeder kennt die Vorteile von Unit-Tests.  Wenn Sie Tests gleichzeitig mit dem Code schreiben, k√∂nnen Sie Fehler fr√ºher erkennen und anschlie√üend keine Zeit mit zeitaufw√§ndigem komplexem Debugging verschwenden.  Bei der Embedded-Entwicklung weisen Unit-Tests Funktionen auf, die zum einen darauf zur√ºckzuf√ºhren sind, dass der Code irgendwo tief im Darm des Ger√§ts ausgef√ºhrt wird und es ziemlich schwierig ist, mit ihm zu interagieren, und zum anderen ist der Code stark an die Zielhardware gebunden . </p><br><p>  Wenn das Projekt Fragmente enth√§lt, die nicht von der Hardware abh√§ngig sind und gleichzeitig eine recht komplexe Logik implementieren, bietet die Verwendung von Komponententests f√ºr sie den gr√∂√üten Vorteil.  Beispielsweise kann es sich um die Implementierung eines Daten√ºbertragungsprotokolls, verschiedener Berechnungen oder einer steuernden Zustandsmaschine handeln. </p><br><p>  Es gibt drei M√∂glichkeiten, Unit-Tests f√ºr eingebettete Plattformen durchzuf√ºhren: </p><a name="habracut"></a><br><ol><li>  Starten Sie direkt auf der Zielplattform.  In diesem Fall k√∂nnen Sie mit der Ausr√ºstung des Ger√§ts arbeiten, und der Code funktioniert genauso wie unter Kampfbedingungen.  Zum Testen ben√∂tigen Sie jedoch physischen Zugriff auf das Ger√§t.  Dar√ºber hinaus ist der Testzyklus ziemlich lang, da st√§ndig Code auf das Ger√§t heruntergeladen werden muss. </li><li>  Laufen auf einem Emulator.  Diese Methode ist vor allem deshalb gut, weil Sie damit arbeiten k√∂nnen, auch wenn die Zielplattform nicht verf√ºgbar ist (z. B. weil dies noch nicht geschehen ist).  Nachteile sind die begrenzte Genauigkeit bei der Wiedergabe des Verhaltens von Eisen (und der umgebenden Welt) sowie die Schwierigkeit, einen solchen Emulator zu erzeugen. </li><li>  Wird auf dem Host-Computer (lokal) ausgef√ºhrt.  Es funktioniert nicht mit dem Ger√§t (Sie k√∂nnen stattdessen Teststubs verwenden), aber die Tests werden schnell gestartet und funktionieren, und Sie ben√∂tigen keinen Zugriff auf das Zielger√§t.  Ein gutes Beispiel f√ºr die Verwendung dieser Methode ist das Testen der Implementierung eines Rechenalgorithmus auf einem Mikrocontroller, der an sich nicht von der Hardware abh√§ngt, sondern die Sensordaten des Ger√§ts verwendet.  Das Testen eines Algorithmus mit einer realen Datenquelle ist sehr unpraktisch. Es ist viel besser, diese Messungen einmal aufzuzeichnen und Tests f√ºr die gespeicherten Daten durchzuf√ºhren.  Dieses Skript f√ºhrt Tests lokal aus und wird sp√§ter erl√§utert. </li></ol><br><p>  Diese Ver√∂ffentlichung bietet eine M√∂glichkeit zum Konfigurieren von Komponententests in der STM32CubeIDE-Umgebung, basierend auf Eclipse und f√ºr die Entwicklung f√ºr Controller der STM32-Familie vorgesehen.  Die Entwicklungssprache ist C, aber die Tests selbst sind in C ++ geschrieben.  Die Tests werden auf einem Windows-Hostcomputer mit Cygwin ausgef√ºhrt.  Als Testframework wird Google Test verwendet.  Die Ergebnisse werden in einem speziellen Plug-In-Fenster f√ºr Unit-Tests angezeigt und k√∂nnen mit einer Schaltfl√§che aus dem Projekt f√ºr STM32 gestartet werden: </p><br><p><img src="https://habrastorage.org/webt/mo/_j/gw/mo_jgwdlc6e3qqzjkcbsxrslvaq.png"></p><br><p>  Die beschriebene Methode eignet sich f√ºr andere auf Eclipse basierende Entwicklungsumgebungen, es sei denn, die guten Hersteller haben sie aus Gr√ºnden der Benutzerfreundlichkeit zu stark gek√ºrzt.  Diese Methode funktioniert auch mit CubeIDE unter Linux, ohne dass Sie sich um Cygwin k√ºmmern m√ºssen. </p><br><h3 id="vam-ponadobyatsya">  Du wirst brauchen </h3><br><ol><li>  Cygwin 3.0.7 x86 (da die Tests f√ºr einen 32-Bit-Mikrocontroller gelten, verwenden wir eine 32-Bit-Umgebung auch auf einer 64-Bit-Plattform) </li><li>  STM32CubeIDE 1.0.2 f√ºr Windows. </li><li>  Google Test Framework 1.8.1 </li></ol><br><h3 id="ustanovka-cygwin-i-stm32cubeide">  Installieren Sie Cygwin und STM32CubeIDE </h3><br><h4 id="cygwin">  Cygwin </h4><br><p>  Installieren Sie Cygwin, x86-Version.  W√§hlen Sie im Installationsprogramm zus√§tzliche Pakete aus: gcc-core, g ++, binutils, automake, autoconf, cmake, libtool, gdb, make.  Sie k√∂nnen die neuesten stabilen Versionen von Paketen installieren. </p><br><p><img src="https://habrastorage.org/webt/xc/fj/6v/xcfj6v0wun10fgdbskuccodkqqk.png"></p><br><p>  Sie m√ºssen auch Umgebungsvariablen registrieren: </p><br><p>  <strong>PFAD:</strong> ...; C: \ &lt;Pfad_zu_Cygwin&gt; \ Cygwin \ bin;  C: \ &lt;Pfad_zu_Cygwin&gt; \ Cygwin \ lib <br>  <strong>Klassenpfad:</strong> C: \ &lt;Pfad_zu_Cygwin&gt; \ Cygwin \ lib </p><br><h4 id="stm32cubeide">  STM32CubeIDE </h4><br><p>  Die Umgebung wird wie gewohnt installiert.  Es ist ratsam, CubeIDE nach Cygwin zu installieren, da Cube in diesem Fall die vorhandene Cygwin-Toolchain √ºbernimmt. </p><br><p>  Erstellen Sie zun√§chst ein C ++ - Projekt f√ºr die x86-Cygwin-Plattform.  Wir werden es ben√∂tigen, um erstens die Funktionalit√§t der Toolchain zu √ºberpr√ºfen und zweitens, um es als ‚ÄûSpender‚Äú der Baugruppenkonfiguration f√ºr das Hauptprojekt zu verwenden. </p><br><p>  W√§hlen Sie "Datei"&gt; "Neu"&gt; "C / C ++ - Projekt".  W√§hlen Sie C ++ Managed Build.  Wir erstellen ein Projekt vom Typ Hallo Welt f√ºr die Cygwin GCC-Toolchain: </p><br><p><img src="https://habrastorage.org/webt/jc/ny/1n/jcny1ntttq4rzapxeth3-s2emim.png"></p><br><p>  Als N√§chstes m√ºssen Sie ausw√§hlen, welche Baugruppenkonfigurationen erstellt werden sollen.  Nur Debug ist genug. <br>  Jetzt k√∂nnen Sie √ºberpr√ºfen, ob das Projekt ausgef√ºhrt wird, indem Sie Projekt&gt; Alle erstellen w√§hlen.  Es ist auch ratsam, das Debuggen unter Cygwin zu √ºberpr√ºfen, indem Sie Ausf√ºhren&gt; Debuggen als&gt; Lokale C / C ++ - Anwendung ausf√ºhren.  Die Anwendung gibt "Hallo Welt" an die Konsole in CubeIDE aus. </p><br><p>  Damit der Debugger ausf√ºhrbare Zeilen in Quellcodedateien anzeigt, m√ºssen Sie die Anzeige von Pfaden konfigurieren.  W√§hlen Sie im Fenster Fenster&gt; Einstellungen auf der Registerkarte C / C ++&gt; Debug die Option Quellensuchpfad aus und f√ºgen Sie eine neue Anzeige hinzu: Hinzuf√ºgen&gt; Pfadzuordnung.  Im Fenster m√ºssen Sie so etwas wie eine neue Anzeige benennen und Zeilen f√ºr die Festplatten im System hinzuf√ºgen: </p><br><ul><li>  \ cygdrive \ c - C: \ </li><li>  \ cygdrive \ g - G: \ </li></ul><br><p><img src="https://habrastorage.org/webt/fe/ro/2h/fero2hpb7i_n1cjf4sie1nfdndm.png"></p><br><p><img src="https://habrastorage.org/webt/cc/y3/4e/ccy34eo_dtfubifpmfnmkgzkjgu.png"></p><br><p>  F√ºr einen sch√∂nen Testlauf ben√∂tigen wir au√üerdem ein Plug-In f√ºr Eclipse mit Unterst√ºtzung f√ºr Unit-Tests f√ºr C ++.  Es wird direkt von STM32CubeIDE installiert: Men√º Hilfe&gt; Neue Software installieren, w√§hlen Sie das Eclipse-Repository aus und installieren Sie das C / C ++ - Plugin zur Unterst√ºtzung von Unit-Tests. </p><br><p><img src="https://habrastorage.org/webt/67/eh/ns/67ehnsuupvabu-i1vvkp6dfz4yc.png"></p><br><h3 id="sborka-biblioteki-google-test">  Erstellen Sie die Google Test Library </h3><br><p>  Der Quellcode der Bibliothek finden Sie unter: <a href="">https://github.com/google/googletest/tree/release-1.8.1</a> <br>  Entpacken Sie die Quellen, wechseln Sie mit dem Cygwin-Terminal in das Verzeichnis googletest-release-1.8.1 und f√ºhren Sie Folgendes aus: </p><br><pre><code class="bash hljs">cmake . make</code> </pre> <br><p>  Nach erfolgreicher Assemblierung befindet sich die statische Bibliotheksdatei im Verzeichnis ./googlemock/lib/libgtest.a und die Headerdateien im Verzeichnis ./googletest/include/gtest/.  Sie m√ºssen in unser Projekt kopiert werden (oder schreiben Sie den Pfad zu diesen Dateien in die Projekteinstellungen). </p><br><h3 id="sozdanie-proekta-dlya-stm32">  Erstellen eines Projekts f√ºr STM32 </h3><br><p>  Design f√ºr STM32L476G-DISCO Debug Board.  Das Beispiel wird nicht zu komplex sein - es gibt zwei LEDs auf der Platine, die einen Bin√§rz√§hler von 00 bis 11 anzeigen. Wir werden ein separates Modul f√ºr den Z√§hler implementieren, das in einem Paar von .h- und .c-Dateien beschrieben ist, und einen Test daf√ºr schreiben. <br>  Das Projekt kann wie gewohnt mit dem Cube-Konfigurator erstellt werden. Hauptsache muss sichergestellt werden, dass die PB2- und PE8-Pins als digitale Ausg√§nge konfiguriert sind.  Wenn Sie ein Projekt erstellen, ist es besser, den Typ C ++ anzugeben. Dies wird zum Kompilieren der Tests ben√∂tigt (der Hauptcode wird weiterhin vom C-Compiler kompiliert).  Das Konvertieren eines Projekts aus C ist sp√§ter m√∂glich, indem Sie auf den Namen des RMB-Projekts klicken und "In C ++ konvertieren" ausw√§hlen. </p><br><p>  F√ºr die Kompilierung unter MK und f√ºr Tests ben√∂tigen wir zwei verschiedene Baugruppenkonfigurationen.  In diesen Konfigurationen werden verschiedene Dateigruppen gesammelt - die Hauptdateien erhalten die Module f√ºr die Arbeit mit Hardware und die getesteten Module, und die Testmodule erhalten dieselben getesteten Module und Testdateien.  Daher erstellen wir verschiedene Verzeichnisse im Stammverzeichnis des Projekts - Anwendung mit dem Anwendungscode f√ºr MK (Sie k√∂nnen das von Cube erstellte Src-Verzeichnis einfach umbenennen), Allgemein f√ºr Module, die nicht von Eisen abh√§ngig sind (die wir testen werden) und Tests f√ºr Tests.  Verzeichnisse k√∂nnen von der Assembly ausgeschlossen werden, indem Sie in ihrem Namen im Men√º Ressourcenkonfiguration&gt; Vom Build ausschlie√üen auf RMB klicken. </p><br><p>  F√ºgen Sie unser Z√§hlermodul zum allgemeinen Verzeichnis hinzu: </p><br><div class="spoiler">  <b class="spoiler_title">Led_counter Code</b> <div class="spoiler_text"><p>  (led_counter.h): </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> LED_COUNTER_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LED_COUNTER_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdint.h&gt; void Led_Counter_Init(); uint8_t Led_Counter_Get_Next(); #endif /* LED_COUNTER_H_ */</span></span></span></span></code> </pre> <br><p>  led_counter.cpp: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"led_counter.h"</span></span></span><span class="hljs-meta"> static uint8_t led_cnt_state = 0; void Led_Counter_Init() { led_cnt_state = 0; } uint8_t Led_Counter_Get_Next() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(++led_cnt_state &gt; 3) led_cnt_state = 0; return led_cnt_state; }</span></span></code> </pre> </div></div><br><p>  Die Verzeichnisse Common und Tests m√ºssen dem Suchpfad f√ºr Include-Dateien hinzugef√ºgt werden: Projekteigenschaften (Eigenschaften)&gt; C / C ++ Allgemein&gt; Pfade und Symbole&gt; Includes. </p><br><p>  Hinzuf√ºgen, um mit Haupt-LEDs zu arbeiten </p><br><div class="spoiler">  <b class="spoiler_title">Fragment main.c</b> <div class="spoiler_text"><p>  main.c: </p><br><pre> <code class="cpp hljs">‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN Includes */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"led_counter.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END Includes */</span></span></span><span class="hljs-meta"> ‚Ä¶ int main(void) { ‚Ä¶ </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE BEGIN WHILE */</span></span></span><span class="hljs-meta"> Led_Counter_Init(); uint8_t led_state = 0; while (1) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END WHILE */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE BEGIN 3 */</span></span></span><span class="hljs-meta"> led_state = Led_Counter_Get_Next(); HAL_GPIO_WritePin(GPIOB, GPIO_PIN_2, led_state &amp; (1&lt;&lt;0)); HAL_GPIO_WritePin(GPIOE, GPIO_PIN_8, led_state &amp; (1&lt;&lt;1)); HAL_Delay(500); } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END 3 */</span></span></span><span class="hljs-meta"> ‚Ä¶ }</span></span></code> </pre> </div></div><br><p>  Das Projekt sollte kompiliert und ausgef√ºhrt werden und die LEDs sollten blinken. </p><br><h3 id="napisanie-testov">  Tests schreiben </h3><br><p>  Nun das, wof√ºr alles begonnen wurde. </p><br><p>  Erstellen Sie eine neue Build-Konfiguration √ºber die Projekteigenschaften - Eigenschaften&gt; C / C ++ - Build&gt; Einstellungen&gt; Konfigurationen verwalten.  Mit CubeIDE k√∂nnen Sie einfach keine Konfiguration f√ºr die Erstellung unter Cygwin erstellen. Kopieren Sie sie daher aus dem zuvor erstellten Projekt: </p><br><p><img src="https://habrastorage.org/webt/4d/ro/kd/4drokdgkom2o6z18duo1v_tbmwi.png"></p><br><p>  Jetzt m√ºssen Sie zu dieser Konfiguration wechseln und die Pfade zu den Quelldateien und Header-Dateien konfigurieren.  In den Eigenschaften des Projekts auf der Registerkarte Pfade und Symbole, die wir vorschreiben (beim Hinzuf√ºgen eines Eintrags ist es besser, das Feld "Zu allen Sprachen hinzuf√ºgen" zu aktivieren): </p><br><ul><li>  Beinhaltet - Tests / Inc, Common / Inc. </li><li>  Bibliotheken - gtest </li><li>  Bibliothekspfade - Tests / Lib </li><li>  Quellspeicherort - / &lt;prj_name&gt; / Common und / &lt;prj_name&gt; / Tests (ersetzen Sie &lt;prj_name&gt; durch den Projektnamen) </li></ul><br><p>  Kopieren Sie anschlie√üend die gtest-Bibliothek - die .a-Datei in das Verzeichnis Tests / Lib in das Projekt und die Header-Dateien im Ordner gtest - in den Ordner Tests / Inc.  Erstellen Sie im Ordner Tests eine neue Datei main.cpp, in der Tests ausgef√ºhrt werden.  Sein Inhalt ist Standard: </p><br><p>  main.cpp: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Unit tests main file */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"gtest/gtest.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { ::testing::InitGoogleTest(&amp;argc, argv); return RUN_ALL_TESTS(); }</span></span></code> </pre> <br><p>  Um das Setup zu √ºberpr√ºfen, erstellen wir einen Test, der √ºberpr√ºft, ob die Gr√∂√üe des Zeigers in unserer Umgebung 32 Bit betr√§gt (wir m√∂chten sicherstellen, dass er mit dem Mikrocontroller identisch ist, daf√ºr setzen wir 32-Bit-Cygwin). </p><br><p>  Erstellen Sie die folgende Testdatei test_platform.cpp: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"gtest/gtest.h"</span></span></span><span class="hljs-meta"> TEST(PlatformTest, TestPointerSize) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//Check pointer size is 32 bit ASSERT_EQ(sizeof(void*)*8, 32U); }</span></span></span></span></code> </pre> <br><p>  Wenn das Projekt nun als normale C ++ - Anwendung ausgef√ºhrt wird, wird in der Debug-Ausgabe eine Meldung von Google Test angezeigt, die besagt, dass alle Tests bestanden wurden. </p><br><p>  Die Projektstruktur sollte ungef√§hr so ‚Äã‚Äãaussehen: <br><img src="https://habrastorage.org/webt/ev/ld/g2/evldg2fj_pqta199knozgvzicu8.png"></p><br><p>  Jetzt werden wir Tests f√ºr unser LED-Z√§hlermodul schreiben.  Die Testdateien befinden sich im Ordner Tests: </p><br><div class="spoiler">  <b class="spoiler_title">test_led_counter.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"gtest/gtest.h"</span></span></span><span class="hljs-meta"> extern </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"C"</span></span></span><span class="hljs-meta"> { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"led_counter.h"</span></span></span><span class="hljs-meta"> } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Test fixture class LedCounterTest: public ::testing::Test { protected: void SetUp() { Led_Counter_Init(); } }; // Check initial value TEST_F(LedCounterTest, TestInitialValue) { Led_Counter_Init(); ASSERT_EQ(Led_Counter_Get_Next(), 1); } // Check how value is incremented TEST_F(LedCounterTest, TestIncrementValue) { Led_Counter_Init(); unsigned int val = Led_Counter_Get_Next(); for(int i=0;i&lt;1;i++) { ASSERT_EQ(Led_Counter_Get_Next(), ++val); } } // Check how value return to 0 after 3 TEST_F(LedCounterTest, TestZeroCrossing) { Led_Counter_Init(); for(int i=0;i&lt;3;i++) { Led_Counter_Get_Next(); } ASSERT_EQ(Led_Counter_Get_Next(), 0); }</span></span></span></span></code> </pre> </div></div><br><p>  Damit die Testergebnisse in einem sch√∂nen Fenster angezeigt werden, m√ºssen Sie im Men√º Ausf√ºhren&gt; Debug-Konfigurationen eine neue Startkonfiguration erstellen.  Mit dem installierten Plugin k√∂nnen Sie Konfigurationen wie C / C ++ Unit erstellen.  Erstellen Sie es, rufen Sie Tests ausf√ºhren auf, w√§hlen Sie die verwendete Konfiguration der Assembly "Test" aus und deaktivieren Sie das Kontrollk√§stchen "Beim Start stoppen um" auf der Registerkarte "Debugger".  Danach kann die Konfiguration gestartet werden. </p><br><p>  Damit ein Fenster mit den Ergebnissen angezeigt wird, w√§hlen Sie es unter Fenster&gt; Ansicht anzeigen&gt; Andere&gt; C / C ++&gt; C / C ++ - Einheit aus. </p><br><p><img src="https://habrastorage.org/webt/ip/qd/cr/ipqdcrsjl0iohvf1yq4_99xwieq.png"></p><br><p>  Fertig!  Jetzt kann das Projekt wie gewohnt unter dem Ziel-MK kompiliert und ausgef√ºhrt werden.  Wenn Sie lokale Tests ausf√ºhren m√ºssen und die Konfiguration "Tests ausf√ºhren" ausgef√ºhrt wird, wird das Projekt automatisch f√ºr x86 neu erstellt. Die Umgebung f√ºhrt die Tests aus und zeigt das Ergebnis an. </p><br><h3 id="literatura">  Literatur </h3><br><ol><li>  J. Grenning.  Testgetriebene Entwicklung f√ºr Embedded C. - Grundlegende Arbeiten zum Unit-Test von Embedded-Systemen und zur Anwendung der TDD-Methodik. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://uncannier.com/unit-testing-of-embedded-firmware-part-1-software-confucius/</a> - Unit-Test von x86-Mikrocontroller-Code in Texas Instruments Code Composer Studio, CppUTest-Framework </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://blog.atollic.com/why-running-your-embedded-arm-cortex-code-on-a-host-pc-is-a-good-thing</a> - ein Artikel dar√ºber, warum es n√ºtzlich sein k√∂nnte, Code auszuf√ºhren f√ºr einen Mikrocontroller auf einer Desktop-Plattform </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de469367/">https://habr.com/ru/post/de469367/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de469351/index.html">Intel Comet Lake-U und Comet Lake-Y: Bis zu 6 Kerne f√ºr d√ºnne und leichte Laptops</a></li>
<li><a href="../de469353/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 317 (23. - 29. September)</a></li>
<li><a href="../de469355/index.html">Ein langweiliges NumPy-Tutorial</a></li>
<li><a href="../de469357/index.html">Lauf, Gopher, lauf! - wor√ºber werden wir auf der GolangConf sprechen?</a></li>
<li><a href="../de469361/index.html">Schmerz und Tr√§nen in Svelte 3</a></li>
<li><a href="../de469369/index.html">Digitale Veranstaltungen in Moskau vom 30. September bis 06. Oktober</a></li>
<li><a href="../de469371/index.html">Beschreibung des Ansatzes zum Organisieren und Testen von Code mit Redux Thunk</a></li>
<li><a href="../de469373/index.html">Die Ergebnisse des Projekts zur Schaffung einer neuronalen Schnittstelle f√ºr vollst√§ndig gel√§hmte Patienten wurden in Frage gestellt</a></li>
<li><a href="../de469375/index.html">Warum stellen Mozilla, Coil und Creative Commons 100 Millionen US-Dollar f√ºr Open Source-Projekte zur Verf√ºgung?</a></li>
<li><a href="../de469379/index.html">Anwendung formaler Modellvalidierungsmethoden f√ºr die Benutzeroberfl√§che</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>