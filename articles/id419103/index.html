<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ’‡ğŸ¾ ğŸ¥’ ğŸ¤¹ Menulis Penerjemah Sederhana dalam Lisp - I ğŸ¤™ğŸ» ğŸ‘©ğŸ¼â€ğŸ¤ ğŸ˜¡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mari kita coba menulis dalam Lisp ... penerjemah bahasa imperatif sederhana. Tidak, tidak, saya tidak salah - itu adalah penerjemah. Ini akan disiarka...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menulis Penerjemah Sederhana dalam Lisp - I</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419103/"><p>  Mari kita coba menulis dalam Lisp ... penerjemah bahasa imperatif sederhana.  Tidak, tidak, saya tidak salah - itu adalah penerjemah.  Ini akan disiarkan dalam kode Lisp.  Dan kemudian kode ini dapat dieksekusi oleh sistem Lisp. </p><br><p>  Di sini, layanan yang tak ternilai harganya akan disediakan oleh fakta bahwa di Lisp tidak ada penghalang antara kode dan data (ini adalah properti langka dari beberapa bahasa pemrograman yang disebut "homo-identity").  Tetapi kemampuan visual Lisp juga akan memainkan peran penting. </p><br><p>  Sebagai implementasi, saya akan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HomeLisp</a> .  Mereka yang tertarik dapat menyesuaikan proyek ini dengan Common Lisp.  Saya akan mengatakan segera - dalam kaitannya dengan masalah yang sedang dipertimbangkan, perbedaan yang signifikan antara Common Lisp dan HomeLisp hanya dalam pemrosesan baris dan file. </p><br><p>  Unduh versi portabel HomeLisp di <a href="">sini</a> .  Dokumentasi juga terletak di situs yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sama</a> .  Mereka yang ingin dapat menyalin kode dari artikel dan segera memeriksa kinerjanya. </p><br><p> Topik yang menjadi perhatian Anda menjadi dasar bagi lokakarya saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di Novosibirsk LSHUP-2018 yang terkenal</a> .  Hasil lokakarya dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Dan kemudian saya memulai pendekatan saya.  Saya kira pembaca sudah terbiasa dengan bahasa Lisp. </p><br><h4 id="pristupaem">  Turun </h4><br><p>  Mari kita mulai dengan "bahasa imperatif sederhana" yang akan kami siarankan di Lisp. <br>  Bahasa hanya akan memproses data numerik.  Kode dalam bahasa ini terdiri dari fungsi (prosedur yang mengembalikan nilai).  Di antara fungsi-fungsi ini, seseorang harus disebut main.  Dengan fungsi inilah eksekusi kode dimulai.  Meski begitu mengapa mengikat dirimu sendiri?  Kami menulis fungsi dalam bahasa imperatif, mereka disiarkan dalam Lisp dan dapat digunakan bersama dengan fungsi Lisp.  Tapi jangan maju dulu ... </p><a name="habracut"></a><br><p>  Seperangkat operator bahasa biasa: penugasan, percabangan, siklus aritmatika, keluar awal dari siklus, input, output dan panggilan fungsi.  Namun, secara fungsi pemanggilan fungsi dieksekusi sebagai tugas (hasil dari panggilan).  Biarkan komentar berisi tanda bintang di posisi pertama baris.  Bahasa, tentu saja, harus menyediakan kemampuan untuk menciptakan fungsi rekursif.  Untuk membuatnya lebih jelas, saya akan memberikan contoh kode - mencetak nomor ganjil berturut-turut dan menghitung jumlah mereka: </p><br><pre><code class="hljs lua">proc main() <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> s,n,k <span class="hljs-built_in"><span class="hljs-built_in">input</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i=<span class="hljs-number"><span class="hljs-number">1</span></span> to n k=<span class="hljs-number"><span class="hljs-number">2</span></span>*i<span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> k s=s+k end_for <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> s end_proc</code> </pre> <br><p>  Dalam semangatnya, itu adalah bahasa dasar seperti.  Saya akan menyebutnya "mini-basic."  Penerjemah kami harus mengonversi kode yang diberikan ke fungsi Lisp berikut: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> main <span class="hljs-literal"><span class="hljs-literal">nil</span></span> (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">s</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">n</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">k</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> n (<span class="hljs-name"><span class="hljs-name">read</span></span>)) (<span class="hljs-name"><span class="hljs-name">iter</span></span> (<span class="hljs-name"><span class="hljs-name">for</span></span> i from <span class="hljs-number"><span class="hljs-number">1</span></span> to n) (<span class="hljs-name"><span class="hljs-name">setq</span></span> k (<span class="hljs-name"><span class="hljs-name">-</span></span> (<span class="hljs-name"><span class="hljs-name">*</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> i) <span class="hljs-number"><span class="hljs-number">1</span></span>)) (<span class="hljs-name"><span class="hljs-name">printline</span></span> k) (<span class="hljs-name"><span class="hljs-name">setq</span></span> s (<span class="hljs-name"><span class="hljs-name">+</span></span> sk))) (<span class="hljs-name"><span class="hljs-name">printline</span></span> s)))</code> </pre> <br><p>  Saya sangat suka paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">iterate</a> , yang diimplementasikan sebagai makro dalam paket Common Lisp profesional.  Dalam HomeLisp, fungsi iter (yang mengimplementasikan sebagian besar kemampuan iterate makro) termasuk dalam bahasa inti.  Kecanduan saya pada iter yang menyebabkan siklus "mini-basic" kami diterjemahkan ke dalam panggilan iter. </p><br><p>  Di mana memulai implementasi?  Mari kita mulai dengan memilih file yang akan disiarkan dan membaca dan mencetak file itu baris demi baris.  Kami harus memulai penerjemah berkali-kali, jadi biarkan ini mulai dari awal menjadi mudah.  Seperti inilah fungsi ini: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> start (<span class="hljs-name"><span class="hljs-name">&amp;optional</span></span> (<span class="hljs-name"><span class="hljs-name">fname</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *numline* <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">null</span></span> fname) (<span class="hljs-name"><span class="hljs-name">setq</span></span> fname (<span class="hljs-name"><span class="hljs-name">sysGetOpenName</span></span> (<span class="hljs-name"><span class="hljs-name">sysHome</span></span>) <span class="hljs-string"><span class="hljs-string">"-|*.mbs"</span></span>))) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">fi</span></span> (<span class="hljs-name"><span class="hljs-name">gensym</span></span> 'fi))) (<span class="hljs-name"><span class="hljs-name">when</span></span> fname (<span class="hljs-name"><span class="hljs-name">filOpen</span></span> fi fname _INPUT) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">getLine</span></span> fi) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">or</span></span> *flagerr* (<span class="hljs-name"><span class="hljs-name">filEOF</span></span> fi)) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>))) (<span class="hljs-name"><span class="hljs-name">filClose</span></span> fi) (<span class="hljs-name"><span class="hljs-name">when</span></span> *flagerr* (<span class="hljs-name"><span class="hljs-name">printsline</span></span> <span class="hljs-string"><span class="hljs-string">"****   "</span></span>)))) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*numline*) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*flagerr*))</code> </pre> <br><p>  Fungsi ini memiliki parameter opsional <strong>fname</strong> - nama file yang isinya akan disiarkan.  Saat memasukkan fungsi, dua variabel global dibuat: <strong><em>numLine,</em></strong> nomor baris file sumber, dan <strong><em>flagerr</em></strong> , bendera status kesalahan.  Sebelum fungsi berakhir, variabel-variabel ini dihancurkan (fungsi HomeLisp <strong>tidak disetel</strong> menghancurkan variabel global). </p><br><p>  Jika nama file input dihilangkan, maka dialog windows standar untuk memilih file <strong>(sysGetOpenName)</strong> dipanggil.  Direktori saat ini <strong>(sysHome)</strong> digunakan sebagai direktori awal.  Selanjutnya, karakter unik dibuat untuk manipulator file dan file dibuka untuk membaca teks.  Kemudian, dalam loop tanpa akhir, file tersebut dibaca baris demi baris (fungsi <strong>getLine</strong> ).  Setelah setiap operasi, diperiksa apakah kesalahan telah terjadi dan jika akhir file tercapai.  Jika kesalahan terjadi atau akhir file diperbaiki, siklus terputus, file ditutup, dan jika ada kesalahan, pesan terakhir ditampilkan. <br>  Sebenarnya membaca dari file dilakukan oleh fungsi <strong>getLine</strong> : </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> getLine (<span class="hljs-name"><span class="hljs-name">fil</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">stri</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">filEof</span></span> fil) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *numline* (<span class="hljs-name"><span class="hljs-name">add1</span></span> *numline*)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> stri (<span class="hljs-name"><span class="hljs-name">filGetline</span></span> fil)) (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> (<span class="hljs-name"><span class="hljs-name">format</span></span> *numline* <span class="hljs-string"><span class="hljs-string">"0000"</span></span>) <span class="hljs-string"><span class="hljs-string">" "</span></span> (<span class="hljs-name"><span class="hljs-name">strRTrim</span></span> stri))) (<span class="hljs-name"><span class="hljs-name">setq</span></span> stri (<span class="hljs-name"><span class="hljs-name">strATrim</span></span> stri)) (<span class="hljs-name"><span class="hljs-name">unless</span></span> (<span class="hljs-name"><span class="hljs-name">or</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> stri) (<span class="hljs-name"><span class="hljs-name">eq</span></span> <span class="hljs-string"><span class="hljs-string">"*"</span></span> (<span class="hljs-name"><span class="hljs-name">strLeft</span></span> stri <span class="hljs-number"><span class="hljs-number">1</span></span>))) (<span class="hljs-name"><span class="hljs-name">return</span></span> stri)))))</code> </pre> <br><p>  Fungsi ini menerima pengidentifikasi file yang terbuka dan, dalam loop tak terbatas, melakukan tindakan berikut: </p><br><ul><li>  memeriksa akhir status file.  Dalam hal ini, loop terputus dan fungsi mengembalikan string kosong; </li><li>  penghitung garis baca bertambah satu; </li><li>  baris file selanjutnya dibaca; </li><li>  baris baca dicetak dengan menghilangkan ruang yang mungkin ada di sebelah kanan; </li><li>  jika baris baca tidak kosong dan tidak mengandung tanda bintang di posisi pertama, maka itu <br>  kembali dari fungsi; </li></ul><br><p>  Dengan demikian, semua baris file dalam bentuk aslinya termasuk dalam daftar output. </p><br><h4 id="razbivaem-na-procedury">  Kami membobol prosedur </h4><br><p>  Sekarang mari kita ajarkan kode kita untuk memecah aliran input ke dalam prosedur terpisah.  Pertama, string yang dimasukkan harus dibagi menjadi token (input unit leksikal yang tidak dapat dibagi).  Proses ini disebut parsing;  kita harus membuat parser.  Menulis parser adalah tema klasik, ada pustaka parser siap pakai dan alat khusus yang memungkinkan Anda untuk menghasilkan parser yang diperlukan ... Kami akan pergi dengan cara kami sendiri. </p><br><p>  Sebelum menjelaskan algoritma parser, kami memperhatikan fakta bahwa semua karakter dari string input dapat dibagi menjadi dua kelas: </p><br><ul><li>  Karakter biasa; </li><li>  Karakter pemisah. </li></ul><br><p>  Jadi, di operator penugasan <strong>"x = 15 + y ^ 2",</strong> karakter <strong>x, 1,5, y</strong> dan <strong>2</strong> adalah karakter biasa, dan karakter <strong>"spasi"</strong> , <strong>+</strong> , <strong>^</strong> adalah pembatas.  Bagaimana karakter normal berbeda dari pemisah?  Pemisah - selalu memisahkan satu token dari yang lain.  Operator penugasan kami, yang dibagi menjadi token, terlihat seperti ini: <strong>"x", "=", "15", "y", "^", "2"</strong> . </p><br><p>  Seperti yang Anda lihat, tidak semua pembatas jatuh ke dalam hasil parsing (spasi, khususnya, tidak jatuh).  Kami akan memanggil pemisah yang tidak termasuk dalam hasil sebagai pemisah dari tipe pertama.  Pemisah lain akan disebut pemisah dari tipe kedua. </p><br><p>  Input parser akan berupa string, outputnya adalah daftar token string.  Sebagai drive, variabel lokal akan digunakan - baterai.  Baterai awalnya berisi string kosong. </p><br><p>  Algoritma parsing dapat sebagai berikut: kita membaca karakter baris input oleh karakter.  Jika Anda bertemu karakter biasa, gabungkan dengan baterai.  Jika pembatas ditemukan, maka: </p><br><ul><li>  Untuk pemisah dari tipe pertama, kami mereset nilai baterai (jika tidak kosong) ke daftar output, kosongkan baterai dan lanjutkan membaca karakter berikutnya; </li><li>  Untuk pemisah jenis kedua, kami juga membuang nilai baterai yang tidak kosong ke dalam daftar keluaran, dan setelah itu kami memasukkan pemisah yang diterima untuk jenis kedua (sebagai token independen) ke dalam daftar keluaran, kosongkan baterai dan lanjutkan membaca karakter berikutnya. </li></ul><br><p>  Berikut adalah kode parser: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> parser (<span class="hljs-name"><span class="hljs-name">txt</span></span> <span class="hljs-symbol"><span class="hljs-symbol">&amp;optional</span></span> (<span class="hljs-name"><span class="hljs-name">d1</span></span> <span class="hljs-string"><span class="hljs-string">" ,"</span></span>) (<span class="hljs-name"><span class="hljs-name">d2</span></span> <span class="hljs-string"><span class="hljs-string">"()+-*/\^=&lt;&gt;%"</span></span>)) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">res</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">lex</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>) ) (<span class="hljs-name"><span class="hljs-name">iter</span></span> (<span class="hljs-name"><span class="hljs-name">for</span></span> s in-string (<span class="hljs-name"><span class="hljs-name">strCat</span></span> txt (<span class="hljs-name"><span class="hljs-name">strLeft</span></span> d1 <span class="hljs-number"><span class="hljs-number">1</span></span>))) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">plusp</span></span> (<span class="hljs-name"><span class="hljs-name">strInd</span></span> d1 s)) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> (<span class="hljs-name"><span class="hljs-name">strLen</span></span> lex) <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">collecting</span></span> lex into res)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> lex <span class="hljs-string"><span class="hljs-string">""</span></span>)) ((<span class="hljs-name"><span class="hljs-name">plusp</span></span> (<span class="hljs-name"><span class="hljs-name">strInd</span></span> d2 s)) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> (<span class="hljs-name"><span class="hljs-name">strLen</span></span> lex) <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">collecting</span></span> lex into res)) (<span class="hljs-name"><span class="hljs-name">collecting</span></span> s into res) (<span class="hljs-name"><span class="hljs-name">setq</span></span> lex <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">setq</span></span> lex (<span class="hljs-name"><span class="hljs-name">strCat</span></span> lex s))))) res))</code> </pre> <br><p>  Selain parameter yang diperlukan, fungsi memiliki dua parameter opsional: <strong>d1</strong> berisi string, masing-masing karakter memiliki pemisah dari tipe pertama, dan garis <strong>d2</strong> berisi pemisah dari tipe kedua. </p><br><p>  Logika program dari fungsi <strong>parser</strong> dijelaskan di atas.  Hanya perlu dicatat bahwa sebelum memulai pekerjaan, pemisah ditambahkan ke akhir jalur input.  Hal ini dilakukan agar token yang diproses terakhir "hang" di baterai (variabel lokal <strong>lex</strong> memainkan peran baterai). </p><br><p>  Mari kita periksa parser kami "beraksi": </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">parser</span></span> <span class="hljs-string"><span class="hljs-string">"x = 15 + y^2"</span></span>) ==&gt; (<span class="hljs-string"><span class="hljs-string">"x"</span></span> <span class="hljs-string"><span class="hljs-string">"="</span></span> <span class="hljs-string"><span class="hljs-string">"15"</span></span> <span class="hljs-string"><span class="hljs-string">"+"</span></span> <span class="hljs-string"><span class="hljs-string">"y"</span></span> <span class="hljs-string"><span class="hljs-string">"^"</span></span> <span class="hljs-string"><span class="hljs-string">"2"</span></span>)</code> </pre> <br><p>  Itu benar, bukan?  Tetapi bekerja dengan daftar string tidak cukup Lisp.  Mari kita beralih dari daftar string ke daftar atom.  Untuk melakukan ini, kita memerlukan fungsi yang ... menempelkan semua token lagi menjadi garis panjang (tapi menyisipkan spasi di antara token), lalu menempelkan braket pembuka ke awal baris ini, menutup braket penutup sampai akhir ... dan kemudian memaksa Lisp untuk membaca daftar: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> mk-intf (<span class="hljs-name"><span class="hljs-name">txt</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">lex</span></span> (<span class="hljs-name"><span class="hljs-name">parser</span></span> txt <span class="hljs-string"><span class="hljs-string">" ,"</span></span> <span class="hljs-string"><span class="hljs-string">"()+-*/\^=&lt;&gt;%"</span></span>)) (<span class="hljs-name"><span class="hljs-name">intf</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">iter</span></span> (<span class="hljs-name"><span class="hljs-name">for</span></span> a in lex) (<span class="hljs-name"><span class="hljs-name">setq</span></span> intf (<span class="hljs-name"><span class="hljs-name">strCat</span></span> intf a <span class="hljs-string"><span class="hljs-string">" "</span></span>))) (<span class="hljs-name"><span class="hljs-name">input</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"("</span></span> intf <span class="hljs-string"><span class="hljs-string">")"</span></span>))))</code> </pre> <br><p>  Sekarang, jika kita mengirimkan operator penugasan ke input dari fungsi mk-intf, kita mendapatkan: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">mk-intf</span></span> <span class="hljs-string"><span class="hljs-string">"x = 15 + y^2"</span></span>) ==&gt; (<span class="hljs-name"><span class="hljs-name">X</span></span> = <span class="hljs-number"><span class="hljs-number">15</span></span> + Y ^ <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br><p>  Yang, Anda lihat, jauh lebih baik. </p><br><p>  Sekarang mari kita ubah sedikit fungsi mulai: fungsi ini harus membaca dan memproses seluruh prosedur: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> start (<span class="hljs-name"><span class="hljs-name">&amp;optional</span></span> (<span class="hljs-name"><span class="hljs-name">fname</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *numline* <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">null</span></span> fname) (<span class="hljs-name"><span class="hljs-name">setq</span></span> fname (<span class="hljs-name"><span class="hljs-name">sysGetOpenName</span></span> (<span class="hljs-name"><span class="hljs-name">sysHome</span></span>) <span class="hljs-string"><span class="hljs-string">"-|*.mbs"</span></span>))) (<span class="hljs-name"><span class="hljs-name">when</span></span> fname (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">fi</span></span> (<span class="hljs-name"><span class="hljs-name">gensym</span></span> 'fi))) (<span class="hljs-name"><span class="hljs-name">filOpen</span></span> fi fname _INPUT) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">curr-proc</span></span> (<span class="hljs-name"><span class="hljs-name">action-proc</span></span> fi))) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">or</span></span> *flagerr* (<span class="hljs-name"><span class="hljs-name">filEOF</span></span> fi)) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) (<span class="hljs-name"><span class="hljs-name">eval</span></span> curr-proc))) (<span class="hljs-name"><span class="hljs-name">filClose</span></span> fi)) (<span class="hljs-name"><span class="hljs-name">when</span></span> *flagerr* (<span class="hljs-name"><span class="hljs-name">printsline</span></span> <span class="hljs-string"><span class="hljs-string">"****   "</span></span>))) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*numline*) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*flagerr*))</code> </pre> <br><p>  Dalam tubuh loop, fungsi <strong>action-proc</strong> dipanggil (untuk memproses prosedur), yang akan membentuk tubuh prosedur yang diterima yang sudah ada di Lisp.  Tubuh prosedur, disimpan sebagai ekspresi S dalam variabel arus <strong>-proc</strong> , kemudian diteruskan ke input <strong>eval</strong> .  Dan fungsi yang diterima adalah "bereinkarnasi" di lingkungan Lisp! </p><br><p>  Apa yang harus <strong>dilakukan tindakan-proc</strong> ?  Fungsi ini menerima pengidentifikasi file yang terbuka sebagai parameter.  Fungsi membaca baris file demi baris dari file, melompati baris kosong dan komentar, mem-parsing sisa baris, menerjemahkannya ke dalam bentuk daftar, dan menghasilkan isi prosedur. </p><br><p>  Kami secara bertahap akan "belajar" menghasilkan <strong>tindakan-proc</strong> .  Dan mari kita mulai dengan mengajarkan fungsi kita untuk mengenali awal dan akhir suatu prosedur.  Dalam mini-basic, awal prosedur adalah: </p><br><pre> <code class="hljs lisp">proc name(<span class="hljs-name"><span class="hljs-name">p1</span></span>,p2,p3)</code> </pre> <br><p>  coba parsing baris seperti ini: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">mk-intf</span></span> <span class="hljs-string"><span class="hljs-string">"proc name(p1,p2,p3)"</span></span>) ==&gt; (<span class="hljs-name"><span class="hljs-name">PROC</span></span> NAME (<span class="hljs-name"><span class="hljs-name">P1</span></span> P2 P3))</code> </pre> <br><p>  Bagaimana seharusnya fungsi <strong>tindakan-proc</strong> menanggapi input ini?  Tentu saja, memastikan bahwa kepala daftar adalah atom <strong>PROC</strong> , Anda perlu mengambil elemen kedua dari daftar sebagai nama fungsi, dan elemen ketiga sebagai daftar parameter.  Nama dan daftar parameter harus disimpan dalam variabel lokal.  Ketika operator <strong>end_proc dibaca</strong> , maka Anda perlu membentuk bentuk <strong>defun</strong> dengan tubuh kosong (sejauh ini) dari nama fungsi dan daftar parameter, dan mengembalikan formulir ini sebagai hasilnya.  Begini tampilannya: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> action-proc (<span class="hljs-name"><span class="hljs-name">fi</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">stmt</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">proc-name</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">proc-parm</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">setq</span></span> stmt (<span class="hljs-name"><span class="hljs-name">mk-intf</span></span> (<span class="hljs-name"><span class="hljs-name">getLine</span></span> fi))) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">null</span></span> stmt) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'proc) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-name (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> stmt)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-parm (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> stmt))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'end_proc) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"****  "</span></span> (<span class="hljs-name"><span class="hljs-name">output</span></span> stmt) <span class="hljs-string"><span class="hljs-string">"  "</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">t</span></span>)))) `(defun ,proc-name ,proc-parm (quote OK))))</code> </pre> <br><p>  Untuk pembentukan akhir klausa <strong>defun</strong> , kunci terbalik digunakan.  Perhatikan bahwa prosedur yang dihasilkan akan mengembalikan atom <strong>OK</strong> sebagai hasilnya. </p><br><p>  Sekarang kita dapat memeriksa kode kita dalam aksi.  Masukkan kode berikut ke dalam file 0000.mbs: </p><br><pre> <code class="hljs lisp">proc f1(<span class="hljs-name"><span class="hljs-name">x</span></span>,y) end_proc proc f2(<span class="hljs-name"><span class="hljs-name">x</span></span>) end_proc</code> </pre> <br><p>  Jalankan prosedur <strong>mulai</strong> , pilih 0000.mbs dan lihat di konsol: </p><br><pre> <code class="hljs lisp"><span class="hljs-number"><span class="hljs-number">0001</span></span> proc f1(<span class="hljs-name"><span class="hljs-name">x</span></span>,y) <span class="hljs-number"><span class="hljs-number">0002</span></span> end_proc <span class="hljs-number"><span class="hljs-number">0003</span></span> proc f2(<span class="hljs-name"><span class="hljs-name">x</span></span>) <span class="hljs-number"><span class="hljs-number">0004</span></span> end_proc</code> </pre> <br><p>  Jika mau, Anda dapat memastikan bahwa mesin Lisp sekarang memiliki dua fungsi (sejauh ini tidak berguna) <strong>f1</strong> dan <strong>f2</strong> : </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">getd</span></span> 'f1) ==&gt; (<span class="hljs-name"><span class="hljs-name">EXPR</span></span> (<span class="hljs-name"><span class="hljs-name">XY</span></span>) (<span class="hljs-name"><span class="hljs-name">QUOTE</span></span> OK)) (<span class="hljs-name"><span class="hljs-name">getd</span></span> 'f2) ==&gt; (<span class="hljs-name"><span class="hljs-name">EXPR</span></span> (<span class="hljs-name"><span class="hljs-name">X</span></span>) (<span class="hljs-name"><span class="hljs-name">QUOTE</span></span> OK))</code> </pre> <br><p>  Apalagi!  Itu sudah bisa dimulai: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">f1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) ==&gt; OK (<span class="hljs-name"><span class="hljs-name">f2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) ==&gt; OK</code> </pre> <br><p>  Penerjemah kami menarik napas pertama ... </p><br><h4 id="vvod-vyvod-i-lokalnye-peremennye">  Input, output, dan variabel lokal </h4><br><p>  Sekarang adalah waktunya untuk mengajar penerjemah kami yang baru lahir bagaimana menangani <strong>input</strong> , <strong>cetak,</strong> dan operator <strong>lokal</strong> . </p><br><p>  Cara termudah untuk menangani input dan pencetakan.  Kedua operator memiliki struktur sintaksis yang sama: kata kunci dan variabel.  <strong>Input</strong> operator <strong>x</strong> harus berubah menjadi bentuk Lisp <strong>(setq x (baca))</strong> .  Dengan demikian, operator <strong>cetak x</strong> berubah menjadi formulir <strong>(printline x)</strong> .  Untuk menyimpan formulir ini, Anda harus menyediakan variabel lokal di fungsi <strong>action-proc</strong> .  Variabel ini akan mengakumulasi formulir yang melakukan perhitungan fungsi di masa mendatang.  Maka semuanya sangat sederhana: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> action-proc (<span class="hljs-name"><span class="hljs-name">fi</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">stmt</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">proc-name</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">proc-parm</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">loc-var</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">body</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">setq</span></span> stmt (<span class="hljs-name"><span class="hljs-name">mk-intf</span></span> (<span class="hljs-name"><span class="hljs-name">getLine</span></span> fi))) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">null</span></span> stmt) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'proc) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-name (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> stmt)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-parm (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> stmt))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'end_proc) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'print) (<span class="hljs-name"><span class="hljs-name">setq</span></span> body (<span class="hljs-name"><span class="hljs-name">append</span></span> body (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> 'printline (<span class="hljs-name"><span class="hljs-name">cdr</span></span> stmt)))))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'input) (<span class="hljs-name"><span class="hljs-name">setq</span></span> body (<span class="hljs-name"><span class="hljs-name">append</span></span> body (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">list</span></span> 'setq (<span class="hljs-name"><span class="hljs-name">cadr</span></span> stmt) (<span class="hljs-name"><span class="hljs-name">list</span></span> 'read) ))))) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"****  "</span></span> (<span class="hljs-name"><span class="hljs-name">output</span></span> stmt) <span class="hljs-string"><span class="hljs-string">"  "</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">t</span></span>)))) `(defun ,proc-name ,proc-parm ,@body)))</code> </pre> <br><p>  Sekarang mari kita siapkan kode sumber ini pada mini-basic: </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">proc</span></span> f1(x,y) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> y end_proc <span class="hljs-keyword"><span class="hljs-keyword">proc</span></span> f2(x) input x <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> x end_proc</code> </pre> <br><p>  dan coba terjemahkan ... Kami akan memiliki dua fungsi Lisp <strong>f1</strong> dan <strong>f2</strong> .  Mari kita lihat ekspresi mereka dan pastikan mereka dihasilkan dengan benar: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">getd</span></span> 'f1) ==&gt; (<span class="hljs-name"><span class="hljs-name">EXPR</span></span> (<span class="hljs-name"><span class="hljs-name">XY</span></span>) (<span class="hljs-name"><span class="hljs-name">PRINTLINE</span></span> X) (<span class="hljs-name"><span class="hljs-name">PRINTLINE</span></span> Y)) (<span class="hljs-name"><span class="hljs-name">getd</span></span> 'f2) ==&gt; (<span class="hljs-name"><span class="hljs-name">EXPR</span></span> (<span class="hljs-name"><span class="hljs-name">X</span></span>) (<span class="hljs-name"><span class="hljs-name">SETQ</span></span> X (<span class="hljs-name"><span class="hljs-name">READ</span></span>)) (<span class="hljs-name"><span class="hljs-name">PRINTLINE</span></span> X))</code> </pre> <br><p>  Anda dapat memanggil fungsi-fungsi ini, dan memastikan fungsinya persis seperti yang dimaksudkan.  Biarkan itu tidak mengganggu Anda bahwa kami memasukkan nilai dalam variabel parameter - kami hanya belum memiliki variabel lokal ... Mari kita tambahkan mereka. </p><br><p>  Operator <strong>lokal</strong> dapat berada di mana saja dalam prosedur dan terjadi lebih dari satu kali.  Jika operator <strong>lokal</strong> ditemui selama pemrosesan prosedur, maka Anda perlu mengambil daftar variabel dan menyimpannya dalam variabel lokal.  Setelah pernyataan <strong>end_proc terpenuhi,</strong> Anda perlu membuat form <strong>let</strong> dan â€œmelampirkanâ€ semua pernyataan yang dapat dieksekusi di dalamnya (untuk saat ini, hanya <strong>masukan</strong> dan <strong>cetak</strong> ).  Inilah yang akan terlihat seperti <strong>tindakan-proc</strong> : </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> action-proc (<span class="hljs-name"><span class="hljs-name">fi</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">stmt</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">proc-name</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">proc-parm</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">loc-var</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">lv</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">body</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">setq</span></span> stmt (<span class="hljs-name"><span class="hljs-name">mk-intf</span></span> (<span class="hljs-name"><span class="hljs-name">getLine</span></span> fi))) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">null</span></span> stmt) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'proc) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-name (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> stmt)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-parm (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> stmt))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'end_proc) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'print) (<span class="hljs-name"><span class="hljs-name">setq</span></span> body (<span class="hljs-name"><span class="hljs-name">append</span></span> body (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> 'printline (<span class="hljs-name"><span class="hljs-name">cdr</span></span> stmt)))))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'input) (<span class="hljs-name"><span class="hljs-name">setq</span></span> body (<span class="hljs-name"><span class="hljs-name">append</span></span> body (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">list</span></span> 'setq (<span class="hljs-name"><span class="hljs-name">cadr</span></span> stmt) (<span class="hljs-name"><span class="hljs-name">list</span></span> 'read) ))))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'local) (<span class="hljs-name"><span class="hljs-name">setq</span></span> loc-var (<span class="hljs-name"><span class="hljs-name">append</span></span> loc-var (<span class="hljs-name"><span class="hljs-name">cdr</span></span> stmt)))) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"****  "</span></span> (<span class="hljs-name"><span class="hljs-name">output</span></span> stmt) <span class="hljs-string"><span class="hljs-string">"  "</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">t</span></span>)))) (<span class="hljs-name"><span class="hljs-name">iter</span></span> (<span class="hljs-name"><span class="hljs-name">for</span></span> a in (<span class="hljs-name"><span class="hljs-name">setof</span></span> loc-var)) (<span class="hljs-name"><span class="hljs-name">collecting</span></span> (<span class="hljs-name"><span class="hljs-name">list</span></span> a <span class="hljs-number"><span class="hljs-number">0</span></span>) into lv)) `(defun ,proc-name ,proc-parm (let ,lv ,@body))))</code> </pre> <br><p>  Daftar variabel lokal diakumulasikan dalam variabel <strong>loc-var</strong> .  Setelah pemrosesan prosedur selesai, daftar pasangan bentuk <strong>(nama 0)</strong> dibuat dari daftar ini.  Pada saat yang sama, duplikasi nama yang identik tidak diinginkan ... Bagaimana mencegahnya?  Tentu saja, dimungkinkan untuk memeriksa setiap pemrosesan operator <strong>lokal</strong> apakah ada nama duplikat (jika ada, berikan pesan kesalahan).  Tapi, menurut saya, lebih baik menghilangkan pengulangan, yang dilakukan oleh <strong>setof</strong> call.  Sekarang mari kita terjemahkan dan jalankan program ini: </p><br><pre> <code class="hljs lua">proc f1(x,y) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> a,b,c <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> x <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> y <span class="hljs-built_in"><span class="hljs-built_in">input</span></span> a <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> a end_proc</code> </pre> <br><p>  Kami memastikan bahwa itu berfungsi persis seperti yang disarankan algoritma.  Tapi yang paling menarik ada di depan! </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dari sini,</a> Anda dapat mengunduh versi final dari apa yang kami aktifkan <del>  w </del>  berkode ... </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Untuk dilanjutkan!</a> <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id419103/">https://habr.com/ru/post/id419103/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id419091/index.html">Benda radioaktif di antara kita</a></li>
<li><a href="../id419095/index.html">Kami menulis CSS lebih baik dan lebih indah</a></li>
<li><a href="../id419097/index.html">Mambot - bot di Telegram untuk wanita hamil</a></li>
<li><a href="../id419099/index.html">WebSockets di Angular. Bagian 2. Solusi Produk</a></li>
<li><a href="../id419101/index.html">Buat game di malam hari hackathon</a></li>
<li><a href="../id419105/index.html">Tautan ke siaran Slurm (Kubernetes Intensive)</a></li>
<li><a href="../id419107/index.html">Ikhtisar Komponen dan Contoh Konfigurasi Dell EMC Unity</a></li>
<li><a href="../id419109/index.html">Jelaskan poni di Android P. Apa yang harus dilakukan dengan Android Cutout?</a></li>
<li><a href="../id419111/index.html">Intisari Desain Makanan Juli 2018</a></li>
<li><a href="../id419115/index.html">Bootable CD dan game retro dalam satu tweet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>