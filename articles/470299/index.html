<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì¶ üöÉ üÜî Gesti√≥n eficiente de la conexi√≥n SignalR üó≥Ô∏è üë®üèø‚Äçü§ù‚Äçüë®üèæ üò£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola habrahabr. Actualmente estoy trabajando en un motor de chat basado en la biblioteca SignalR . Adem√°s del fascinante proceso de inmersi√≥n en el mu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gesti√≥n eficiente de la conexi√≥n SignalR</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470299/">  Hola habrahabr.  Actualmente estoy trabajando en un motor de chat basado en la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SignalR</a> .  Adem√°s del fascinante proceso de inmersi√≥n en el mundo de las aplicaciones en tiempo real, tambi√©n tuve que enfrentar una serie de desaf√≠os t√©cnicos.  Sobre uno de ellos, quiero compartir con ustedes en este art√≠culo. <br><br><h3>  Introduccion </h3><br>  Qu√© es SignalR: es una especie de fachada sobre <b>WebSockets</b> , <b>sondeo largo</b> , tecnolog√≠as de <b>eventos de env√≠o de servidor</b> .  Gracias a esta fachada, puede trabajar de manera uniforme con cualquiera de estas tecnolog√≠as y no preocuparse por los detalles.  Adem√°s, gracias a la tecnolog√≠a Long Polling, puede ayudar a los clientes que, por alguna raz√≥n, no pueden trabajar en sockets web, como IE-8.  La fachada est√° representada por una API de alto nivel basada en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RPC</a> .  Adem√°s, SignalR ofrece construir comunicaciones de acuerdo con el principio de "editor-suscriptor", que en la terminolog√≠a API se llama grupos.  Esto se discutir√° m√°s a fondo. <br><br><h3>  Desaf√≠os </h3><br>  Quiz√°s lo m√°s interesante en la programaci√≥n es la capacidad de resolver problemas no est√°ndar.  Y hoy designaremos una de estas tareas y consideraremos su soluci√≥n. <br><a name="habracut"></a><br>  En la era del desarrollo de ideas de escalado y, en primer lugar, horizontal, el principal desaf√≠o es la necesidad de tener m√°s de un servidor.  Y los desarrolladores de la biblioteca indicada ya han respondido a esta llamada, se puede encontrar una descripci√≥n de la soluci√≥n en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MSDN</a> .  En resumen, se propone, utilizando el principio editor-suscriptor, sincronizar las llamadas entre servidores.  Cada servidor se suscribe a un bus compartido y todos los comandos <b>enviados</b> desde este servidor se env√≠an primero al bus.  Adem√°s, el comando se aplica a todos los servidores y solo a los clientes: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd6/7b5/81f/fd67b581f8437bf5f8984dd9470cf60f.png" alt="imagen"><br><br>  Es importante tener en cuenta que cada cliente conectado al servidor tiene su propio identificador de conexi√≥n √∫nico, <b>ConnectionId</b> , y todos los mensajes se abordan en √∫ltima instancia utilizando este identificador.  Por lo tanto, cada servidor almacena estas conexiones. <br><br>  Sin embargo, por razones desconocidas, la API de la biblioteca SignalR no proporciona acceso a estos datos.  Y aqu√≠ nos enfrentamos a una cuesti√≥n muy aguda de acceso a estas conexiones.  Este es nuestro desaf√≠o. <br><br><h3>  ¬øPor qu√© necesitamos conectarnos? </h3><br>  Como se se√±al√≥ anteriormente, SignalR ofrece un modelo de editor-suscriptor.  Aqu√≠, la unidad de enrutamiento de mensajes no es un <b>ConnectionId</b> sino un grupo.  Un grupo es una colecci√≥n de conexiones.  Al enviar un mensaje a un grupo, enviamos un mensaje a todos los ConnectionId que est√°n en este grupo.  Es conveniente crear grupos: al conectar un cliente al servidor, simplemente llamamos al m√©todo API <b>AddToGroupAsync</b> : <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnConnectedAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> chat <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _options.Chats) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Groups.AddToGroupAsync(ConnectionId, chat); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Groups.AddToGroupAsync(ConnectionId, Client); }</code> </pre> <br>  ¬øY c√≥mo dejar el grupo?  Los desarrolladores ofrecen el m√©todo API <b>RemoveFromGroupAsync</b> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDisconnectedAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Exception exception</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> chat <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _options.Chats) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Groups.RemoveFromGroupAsync(ConnectionId, chat); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Groups.RemoveFromGroupAsync(ConnectionId, Client); }</code> </pre> <br>  Tenga en cuenta que la unidad de datos es ConnectionId.  Sin embargo, desde el punto de vista del modelo de dominio, ConnectionId no existe, pero hay clientes.  En este sentido, la organizaci√≥n de la asignaci√≥n de clientes a la matriz ConnectionId y viceversa se asigna a los usuarios de la biblioteca especificada. <br><br>  Es la matriz de todos los clientes ConnectionId que se necesita cuando abandona el grupo.  Sin embargo, tal matriz no existe.  Necesitas organizarlo t√∫ mismo.  La tarea se vuelve mucho m√°s interesante en el caso de un sistema a escala horizontal.  En este caso, parte de las conexiones pueden estar en un servidor, el resto en otros servidores. <br><br><h3>  Formas de asignar clientes a conexiones </h3><br>  Una secci√≥n completa en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MSDN est√°</a> dedicada a este problema.  Se proponen los siguientes m√©todos para su consideraci√≥n: <br><br><ul><li>  Almacenamiento en memoria </li><li>  "Grupo de usuarios" </li><li>  Almacenamiento externo permanente </li></ul><br><div class="spoiler">  <b class="spoiler_title">¬øC√≥mo rastrear las conexiones?</b> <div class="spoiler_text">  Puede realizar un seguimiento de las conexiones utilizando los m√©todos del centro <b>OnConnectedAsync</b> y <b>OnDisconnectedAsync</b> . <br></div></div><br>  Inmediatamente, observo que no se consideran las opciones que no admiten la escala.  Estos incluyen la opci√≥n de almacenar conexiones en la memoria del servidor.  No hay acceso a las conexiones del cliente en otros servidores, si hay alguno.  La opci√≥n de almacenar en almacenamiento externo persistente est√° asociada con sus inconvenientes, que incluyen el problema de limpiar conexiones inactivas.  Dichas conexiones se producen en caso de un reinicio completo del servidor.  Detectar y limpiar estas conexiones no es una tarea trivial. <br><br>  Entre las opciones anteriores, la opci√≥n "grupo de usuarios" es interesante.  La simplicidad ciertamente se aplica a sus ventajas: no se requieren bibliotecas, repositorios.  Igualmente importante es la consecuencia de la simplicidad de este m√©todo: la fiabilidad. <br><br><div class="spoiler">  <b class="spoiler_title">¬øPero qu√© hay de Redis?</b> <div class="spoiler_text">  Por cierto, usar Redis para almacenar conexiones tambi√©n es una mala opci√≥n.  Existe un grave problema de organizar los datos en la memoria.  Por un lado, la clave es el cliente, por otro, el grupo. <br></div></div><br><h3>  "Grupo de usuarios" </h3><br>  ¬øQu√© es un "grupo de usuarios"?  Este es un grupo en terminolog√≠a de SignalR donde solo un cliente puede ser cliente: √©l mismo.  Esto garantiza 2 cosas: <br><br><ol><li>  Los mensajes se entregar√°n a una sola persona. </li><li>  Los mensajes se enviar√°n a todos los dispositivos humanos. </li></ol><br>  ¬øC√≥mo nos ayudar√° esto?  Perm√≠tame recordarle que nuestro desaf√≠o es resolver el problema de dejar al cliente del grupo.  Necesit√°bamos que, dejando el grupo desde un dispositivo, el resto tambi√©n se dar√≠a de baja, pero no ten√≠amos una lista de conexiones para este cliente, excepto para el que iniciamos la salida. <br><br>  "Grupo de usuarios" es el primer paso para resolver este problema.  El segundo paso es construir un "espejo" en el cliente.  S√≠, s√≠, espejos. <br><br><h3>  El espejo </h3><br>  La fuente de los comandos enviados desde el cliente al servidor son las acciones del usuario.  Publique un mensaje: env√≠e un comando al servidor: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.hubConnection .invoke(<span class="hljs-string"><span class="hljs-string">'post'</span></span>, {message, group, nick}) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err));</code> </pre> <br>  Y notificamos a todos los clientes del grupo sobre la nueva publicaci√≥n: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PostMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PostMessage message</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Clients.Group(message.Group).SendAsync(<span class="hljs-string"><span class="hljs-string">"message"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { Message = message.Message, Group = message.Group, Nick = ClientNick }); }</code> </pre> <br>  Sin embargo, se deben ejecutar varios comandos sincr√≥nicamente en todos los dispositivos.  ¬øC√≥mo lograr esto?  Tenga una matriz de conexiones y ejecute un comando para cada conexi√≥n en un cliente espec√≠fico, o utilice el m√©todo que se describe a continuaci√≥n.  Considere este m√©todo saliendo del chat. <br><br>  El equipo que llega desde el cliente primero ir√° al "grupo de usuarios" para un m√©todo especial, que simplemente lo redirigir√° al servidor, es decir.  " <b>Espejos</b> ".  Por lo tanto, no el servidor cancelar√° la suscripci√≥n de los dispositivos, pero se les pedir√° a los dispositivos mismos que se den de baja. <br><br>  Aqu√≠ hay un ejemplo de un comando para darse de baja del chat del servidor: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LeaveChat</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">LeaveChatMessage message</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Clients.OthersInGroup(message.Group).SendAsync(<span class="hljs-string"><span class="hljs-string">"lost"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClientCommand { Group = message.Group, Nick = Client }); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Clients.Group(Client).SendAsync(<span class="hljs-string"><span class="hljs-string">"mirror"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MirrorChatCommand { Method = <span class="hljs-string"><span class="hljs-string">"unsubscribe"</span></span>, Payload = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UnsubscribeChatMessage { Group = message.Group } }); }</code> </pre> <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Unsubscribe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">UnsubscribeChatMessage message</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Groups.RemoveFromGroupAsync(ConnectionId, message.Group); }</code> </pre> <br>  Y aqu√≠ est√° el c√≥digo del cliente: <br><br><pre> <code class="javascript hljs">connection.on(<span class="hljs-string"><span class="hljs-string">'mirror'</span></span>, (message) =&gt; { connection .invoke(message.method, message.payload) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err)); });</code> </pre> <br>  Examinemos con m√°s detalle lo que est√° sucediendo aqu√≠: <br><br><ol><li>  El cliente inicia la cancelaci√≥n de la suscripci√≥n: env√≠a el comando "dejar" al servidor </li><li>  El servidor env√≠a el comando "cancelar suscripci√≥n" al "grupo de usuarios" en el "espejo" </li><li>  El mensaje se entrega a todos los dispositivos del cliente. </li><li>  Un mensaje en el cliente se env√≠a de vuelta al servidor utilizando el m√©todo especificado por el servidor </li><li>  En cada servidor, el cliente se da de baja del grupo </li></ol><br>  Como resultado, todos los dispositivos se dar√°n de baja de los servidores a los que est√°n conectados.  Cada uno se dar√° de baja de la suya y no necesitamos almacenar nada.  Tampoco surgir√°n problemas en el caso de un reinicio completo del servidor. <br><br><h3>  Entonces, ¬øpor qu√© necesitamos conectarnos? </h3><br>  Tener un "grupo de usuarios" y un "espejo" en el cliente elimina la necesidad de trabajar con conexiones.  ¬øQu√© piensan, queridos lectores, sobre esto?  Comparte tu opini√≥n en los comentarios. <br><br>  C√≥digo fuente para ejemplos: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github.com/aesamson/signalr-server</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github.com/aesamson/signalr-client</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/470299/">https://habr.com/ru/post/470299/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../470285/index.html">Un tigre agazapado al acecho en SQLAlchemy. Los fundamentos</a></li>
<li><a href="../470287/index.html">Migrante</a></li>
<li><a href="../470289/index.html">El lenguaje de programaci√≥n de mis sue√±os.</a></li>
<li><a href="../470293/index.html">C√≥mo la vulnerabilidad en Yandex.Stations me inspir√≥ al proyecto: transferencia de datos de m√∫sica</a></li>
<li><a href="../470295/index.html">Cifrado SQlite DB simple</a></li>
<li><a href="../470301/index.html">√Årbol de palabras clave: an√°lisis gr√°fico para extracci√≥n sem√°ntica</a></li>
<li><a href="../470303/index.html">Instale el servidor tftp en CentOS 8 o RedHat 8</a></li>
<li><a href="../470305/index.html">Preparaci√≥n para la certificaci√≥n profesional de primavera. Contenedor, IoC, Frijoles</a></li>
<li><a href="../470309/index.html">Xamarin.Forms Shell</a></li>
<li><a href="../470311/index.html">Juguetes de madera, parte siete - 1993</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>