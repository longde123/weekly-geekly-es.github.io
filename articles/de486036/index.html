<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👸🏼 🕋 🙉 Text-Stimmungsanalyse auf Node.js 🎅🏽 ⏯️ 🎶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits. Das Thema ist sehr interessant und scheint schwierig umzusetzen zu sein. Aber ich bin ein praktischer Mensch und möchte das Schöne b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Text-Stimmungsanalyse auf Node.js</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486036/"><p><img src="https://habrastorage.org/webt/ib/_g/vg/ib_gvg4f3vdu0wiwjyhrjctmd8g.jpeg"></p><br><p>  Hallo allerseits.  Das Thema ist sehr interessant und scheint schwierig umzusetzen zu sein.  Aber ich bin ein praktischer Mensch und möchte das Schöne besonders ohne Anstrengung berühren.  Heute werden wir einen "Microservice" für die Analyse der Sentimentalität / Tonalität des Textes erstellen.  Und der Fall, einige weitere interessante Dinge, die Ihnen helfen werden, Ihren textlichen Appell an Skynet vorzubereiten. </p><a name="habracut"></a><br><h3 id="intro">  Intro </h3><br><p>  Warum?  Das ist eine sehr gute Frage.  Aber bevor wir darauf antworten, lassen Sie uns ein bisschen schlauer werden und herausfinden, wie die Tonalität des Textes analysiert wird und was die Tonalität ist. </p><br><blockquote> Die Analyse der Texttonalität (Stimmungsanalyse, englische Stimmungsanalyse, englisches Opinion Mining) ist eine Klasse von Methoden zur Inhaltsanalyse in der Computerlinguistik, mit denen in Texten automatisch emotional gefärbtes Vokabular und emotionale Einschätzung von Autoren (Meinungen) in Bezug auf Objekte, Sprache identifiziert werden das geht in den text. <br><br>  Tonalität ist die emotionale Einstellung des Autors einer Aussage zu einem Objekt (einem Objekt der realen Welt, einem Ereignis, einem Prozess oder ihren Eigenschaften / Attributen), die im Text ausgedrückt wird.  Die emotionale Komponente, ausgedrückt auf der Ebene des Lexems oder des kommunikativen Fragments, wird als lexikalische Tonalität (oder lexikalisches Gefühl) bezeichnet.  Die Tonalität des gesamten Textes kann als Funktion (im einfachsten Fall die Summe) der lexikalischen Tonalität seiner Einheiten (Sätze) und der Regeln für deren Kombination definiert werden. </blockquote><p>  von Wikipedia </p><br><h3 id="zachem">  Warum? </h3><br><p>  Ich habe oft mehr Fragen als Antworten, wenn ich Wikipedia lese.  Lassen Sie uns vereinfachen - der Schlüssel des Textes gibt Auskunft über die "Stimmung des Textes".  Zum Beispiel bedeutet "Komm her, deine Mutter ...", dass der Zuhörer Probleme hat.  "Schatz, ich bin zu Hause" - ein bisschen besser, aber je nach Situation. </p><br><p><img src="https://habrastorage.org/webt/5s/xz/dl/5sxzdlj-cbh9r3axka1xf0lmcwq.gif"></p><br><p>  Mithilfe dieser Analyse können Sie nach positiven Nachrichten suchen, negative Kommentare filtern, Produktbewertungen nach Bewertungen erstellen usw.  Ich denke, die allgemeine Idee ist klar. </p><br><h3 id="ustanavlivaem-neobhodimoe">  Installieren Sie die erforderlichen </h3><br><p>  Da wir Node.js verwenden, benötigen wir Express.  Sie können alles verwenden, Express ala low level und nicht kritisch für die Aufgabe. </p><br><pre><code class="bash hljs">npm install -g express-generator</code> </pre> <br><p>  <a href="https://expressjs.com/en/starter/generator.html" rel="nofollow">Express-Generator</a> ist eine Art <a href="https://reactjs.org/docs/create-a-new-react-app.html" rel="nofollow">Create-React-App</a> für das Express-Framework. </p><br><p>  Wir generieren die Anwendung im Ordner <code>node_nlp</code> : </p><br><pre> <code class="bash hljs">express node_nlp --no-view</code> </pre> <br><p>  Sie können die letzten beiden Befehle mit npx vereinfachen: </p><br><pre> <code class="bash hljs">npx express-generator node_nlp --no-view</code> </pre> <br><p>  Um die Anwendung zu starten, gehen Sie in den Ordner, laden Sie die Abhängigkeiten herunter und starten Sie sie: </p><br><pre> <code class="plaintext hljs">cd node_nlp npm install npm start</code> </pre> <br><p>  Um nicht bei jeder Änderung Zeit für einen manuellen Neustart des Servers zu <code>nodemon</code> und konfigurieren <code>nodemon</code> : </p><br><pre> <code class="bash hljs">npm install --save nodemon</code> </pre> <br><p>  Kleinere Änderungen in package.json: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"dev"</span></span>: <span class="hljs-string"><span class="hljs-string">"nodemon ./bin/www"</span></span></code> </pre> <br><p>  Und für die Entwicklung verwenden wir: </p><br><pre> <code class="bash hljs">npm run dev</code> </pre> <br><p>  Lassen Sie uns gleich einen Arm voll Pakete einpacken, ich sage Ihnen, warum sie unterwegs gebraucht werden.  Es ist nur ein anderes Tutorial, um ein Projekt-Setup zu sein, und ich habe bereits vergessen, was ich mit all diesen <code>npm install</code> schreibe. </p><br><pre> <code class="bash hljs">npm install --save natural apos-to-lex-form spelling-corrector stopword</code> </pre> <br><p><img src="https://habrastorage.org/webt/yd/q5/6y/ydq56yhahqjyit4dpuqgntr0s2i.png"></p><br><h3 id="routing">  Routing </h3><br><p>  In der Tat werden wir nur einen Endpunkt haben, im Ordner <code>./routers</code> gibt es eine <code>index.js</code> Datei, die wir zerkleinern werden: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> express = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'express'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> natural = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'natural'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = express.Router(); router.post(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res, next</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { text } = req.body; }); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = router;</code> </pre> <br><p>  Ein einfacher <code>POST</code> Endpunkt, der einen <code>text</code> mit einem <code>text</code> . </p><br><h3 id="processing">  Bearbeitung </h3><br><p>  Wenn Sie, wie ich, irgendwie mit der Schöpfung in Kontakt gekommen sind <del>  Skynet </del>  Wenn Sie die Daten verarbeitet haben, wissen Sie wahrscheinlich, dass der Vorbereitungsprozess genauso wichtig ist wie der Datenverarbeitungsprozess.  Wir müssen verschiedene Geräusche und mögliche Fehler minimieren, damit Sie nicht auf den Sprecher zugehen. "Nun, kommen Sie her, Ihre Mutter ...". </p><br><h3 id="izbavlyaemsya-ot-sokrascheniy">  Schnitte loswerden </h3><br><p><img src="https://habrastorage.org/webt/p6/bf/b4/p6bfb4bi1gveyau9ek44ed7hxhc.gif"></p><br><p>  Da der Microservice mit der Analyse der Tonalität der englischen Sprache befasst sein wird, müssen wir uns überlegen, wie man solche Abkürzungen umdreht, wie ich, du, ich bin, du bist. <br>  Hierfür verwenden wir die <a href="https://www.npmjs.com/package/apos-to-lex-form" rel="nofollow">Apos-to-Lex-Form</a> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> express = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'express'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> natural = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'natural'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> aposToLexForm = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'apos-to-lex-form'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = express.Router(); router.post(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res, next</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { text } = req.body; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lexedText = aposToLexForm(text); }); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = router;</code> </pre> <br><h3 id="konvertiruem-tekst-v-lowercase-nizhniy-registr">  Text in Kleinbuchstaben umwandeln </h3><br><p>  Damit die Wörter HIER GEHEN und hierher kommen, müssen Sie sicherstellen, dass sich der gesamte Text in einem Register befindet. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> casedReview = lexedText.toLowerCase();</code> </pre> <br><h3 id="udalyaem-lishnie-simvoly">  Löschen Sie zusätzliche Zeichen </h3><br><p>  Für die nächste Verbesserung der Genauigkeit unserer Analyse sollten Sie die zusätzlichen Zeichen entfernen. Es fällt mir schwer zu sagen, welche Tonalität @ # $% ^ # solche Zeichen sind.  Deshalb entfernen wir alle unnötigen und lassen nur Buchstaben. <br>  Wir verwenden die Standard-JavaScript-Funktion - <code>replace()</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> alphaOnlyReview = casedReview.replace(<span class="hljs-regexp"><span class="hljs-regexp">/[^a-zA-Z\s]+/g</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>)</code> </pre> <br><h3 id="tokenizaciya">  Tokenisierung </h3><br><p>  Tokenisierung ist das Aufteilen von Text in einzelne Komponenten.  Beispielsweise ist das Wort das Satzzeichen und der Satz wiederum das Absatzzeichen. </p><br><p>  Hier stürzt unser Hauptpferd <a href="https://www.npmjs.com/package/natural" rel="nofollow">Natural</a> in die Szene. <br>  In diesem Paket ist das <code>WordTokenizer</code> Tokenisierungstool enthalten: </p><br><pre> <code class="javascript hljs">... const { WordTokenizer } = natural; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tokenizer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WordTokenizer(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tokenizedReview = tokenizer.tokenize(alphaOnlyReview); ...</code> </pre> <br><h3 id="ispravlyaem-oshibki">  Fehlerbehebungen </h3><br><p>  Da der Text von überall kommen kann, besteht die Möglichkeit von Fehlern.  Wir müssen versuchen, sie zu reparieren.  Die <a href="https://www.npmjs.com/package/spelling-corrector" rel="nofollow">Rechtschreibkorrektur</a> hilft uns dabei. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> express = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'express'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> natural = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'natural'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> aposToLexForm = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'apos-to-lex-form'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SpellCorrector = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'spelling-corrector'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = express.Router(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> spellCorrector = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpellCorrector(); spellCorrector.loadDictionary(); router.post(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res, next</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { text } = req.body; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lexedText = aposToLexForm(text); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> casedReview = lexedText.toLowerCase(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> alphaOnlyReview = casedReview.replace(<span class="hljs-regexp"><span class="hljs-regexp">/[^a-zA-Z\s]+/g</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { WordTokenizer } = natural; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tokenizer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WordTokenizer(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tokenizedReview = tokenizer.tokenize(alphaOnlyReview); tokenizedReview.forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">word, index</span></span></span><span class="hljs-function">) =&gt;</span></span> { tokenizedReview[index] = spellCorrector.correct(word); }); }); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = router;</code> </pre> <br><h3 id="udalyaem-stop-slova">  Stoppwörter löschen </h3><br><p><img src="https://habrastorage.org/webt/lp/5r/_u/lp5r_uo_fh_dra2is3ct56ufrzq.gif"></p><br><p>  Stoppen Sie Wörter, diese sind irgendeine Art Wortparasiten.  Sozusagen, äh, ouu, hey, nicht wie Parasiten, sondern nur überflüssige Worte, die für unser Tonikum absolut kein Wetter machen.  <a href="https://www.npmjs.com/package/stopword" rel="nofollow">Wenn</a> solche Wörter entfernt werden, hilft uns das <a href="https://www.npmjs.com/package/stopword" rel="nofollow">Stopword-</a> Paket. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SW = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'stopword'</span></span>); ... const filteredReview = SW.removeStopwords(tokenizedReview);</code> </pre> <br><h3 id="stemming-stemming">  Stemming </h3><br><p>  Stemming ist der Prozess der Normalisierung von Wörtern.  Zum Beispiel "Geben", "Geben" und "Geber" in der einfachen Form "Geben". <br>  Wir werden dies nicht als separaten Schritt betrachten, da der <code>SentimentAnalyzer</code> , der uns das <code>Natural</code> Paket zur Verfügung stellt, dies für uns tun kann. </p><br><h3 id="tonalnyy-analiz-teksta-s-pomoschyu-natural">  Tontextanalyse mit Natural </h3><br><p>  Das ist alles!  Wir sind dort angekommen.  Jetzt wird Skynet unsere akzeptieren und alles verstehen.  Es ist Zeit, den Text in <code>SentimentAnalyzer</code> und zu verstehen, ob wir in einer so toleranten Gesellschaft positiv klingen oder nicht. </p><br><p>  Die Tonanalyse funktioniert ziemlich kompliziert.  Natural Package hat ein eigenes Wörterbuch mit der "Polarität" der Wörter.  Zum Beispiel hat das Wort "gut" eine Polarität von 3 und das Wort "schlecht" ist -3.  Tatsächlich werden alle diese „Punkte“ zusammengefasst und auf die Größe des Vorschlags normiert.  Tatsächlich haben wir also so viel unternommen, um unseren Text von allem Überflüssigen zu befreien, sodass uns nichts daran hindert, eine angemessene Bewertung zu erhalten. <br>  Der Text ist positiv, wenn die Bewertung positiv ist, negativ, wenn negativ und neutral, wenn wir 0 erhalten. </p><br><p>  <code>SentimentAnalyzer</code> <a href="https://www.npmjs.com/package/natural" rel="nofollow">akzeptiert 3 Parameter</a> : </p><br><ul><li>  Textsprache </li><li>  Streamen oder nicht streamen </li><li>  Wörterbuch (AFINN, Senticon, Pattern), es ist eingebaut </li></ul><br><p>  Aller endgültige Code mit Tonanalyse des Textes am Ende: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> express = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'express'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> natural = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'natural'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> aposToLexForm = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'apos-to-lex-form'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SpellCorrector = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'spelling-corrector'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SW = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'stopword'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = express.Router(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> spellCorrector = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpellCorrector(); spellCorrector.loadDictionary(); router.post(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res, next</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { text } = req.body; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lexedText = aposToLexForm(text); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> casedReview = lexedText.toLowerCase(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> alphaOnlyReview = casedReview.replace(<span class="hljs-regexp"><span class="hljs-regexp">/[^a-zA-Z\s]+/g</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { WordTokenizer } = natural; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tokenizer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WordTokenizer(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tokenizedReview = tokenizer.tokenize(alphaOnlyReview); tokenizedReview.forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">word, index</span></span></span><span class="hljs-function">) =&gt;</span></span> { tokenizedReview[index] = spellCorrector.correct(word); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> filteredReview = SW.removeStopwords(tokenizedReview); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { SentimentAnalyzer, PorterStemmer } = natural; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> analyzer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SentimentAnalyzer(<span class="hljs-string"><span class="hljs-string">'English'</span></span>, PorterStemmer, <span class="hljs-string"><span class="hljs-string">'afinn'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> analysis = analyzer.getSentiment(filteredReview); res.status(<span class="hljs-number"><span class="hljs-number">200</span></span>).json({ analysis }); }); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = router;</code> </pre> <br><p>  Wir haben einige neue Zeilen hinzugefügt.  Destruction <code>natural</code> , um die Werkzeuge zu erhalten, die wir benötigen, haben wir eine Variable für den Analysator erstellt und das Ergebnis der Variablenanalyse zugewiesen. <br>  Die Parameter des <code>SentimentAnalyzer</code> sind relativ offensichtlich.  Die Sprache ist Englisch als der Text, den wir in Englisch verarbeiten.  Stempeln der oben genannten Wörter und des Wörterbuchs, das uns vom <code>Natrual</code> Paket zur Verfügung gestellt wird. </p><br><p>  Ich möchte eine Benutzeroberfläche für diesen Fall erstellen, aber Sie können sie in einigen DevTools testen: </p><br><pre> <code class="javascript hljs">fetch(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">'POST'</span></span>, <span class="hljs-attr"><span class="hljs-attr">headers</span></span>: { <span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify({<span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">'hey'</span></span>}) }) <span class="hljs-comment"><span class="hljs-comment">// {"analysis":0} fetch('/', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({text: 'hey f*** you'}) }) // {"analysis":-2} fetch('/', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({text: 'hey love you'}) }) // {"analysis":1}</span></span></code> </pre> <br><p>  Wie wir sehen, funktioniert es :) </p><br><p>  <a href="https://github.com/DmitryOlkhovoi/sentiment-analysis-nodejs" rel="nofollow">Github Repo</a> </p><br><h3 id="zaklyuchenie">  Fazit </h3><br><p>  In diesem Artikel haben wir einen "Microservice" erstellt, der die Tonalität des Textes analysiert.  Nehmen Sie es zu einem Showdown und analysieren Sie, was Ihre Gegner sagen.  Wir haben auch das Thema Datenaufbereitung angesprochen und eine Menge Abhängigkeiten installiert.  Vielen Dank für Ihre Aufmerksamkeit! </p><br><p>  Lies dasselbe </p><br><ul><li>  <a href="https://habr.com/ru/post/485768/">2020 Web-Trends sind es wert, ausprobiert zu werden</a> </li><li>  <a href="https://habr.com/ru/post/485562/">Surfen im Internet mit einem Gamepad (Javascript)</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de486036/">https://habr.com/ru/post/de486036/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de486024/index.html">Wirklich einfache Grafiken in R für Wissenschaft und Journalismus</a></li>
<li><a href="../de486028/index.html">Neuronale Netze bei der Herstellung von Zahnersatz</a></li>
<li><a href="../de486030/index.html">TL-SREET 55 5K LED Straßenlaterne Bewertung</a></li>
<li><a href="../de486032/index.html">So werden Sie Dialogdesigner</a></li>
<li><a href="../de486034/index.html">Schneller Einstieg in das Produktmanagement über Open Source</a></li>
<li><a href="../de486042/index.html">Gesetzgebung für Boten und Telekommunikation</a></li>
<li><a href="../de486046/index.html">Der Linux-Kernel enthielt WireGuard VPN</a></li>
<li><a href="../de486048/index.html">Was ist das und was frisst es?</a></li>
<li><a href="../de486050/index.html">Webix JavaScript-Bibliothek mit den Augen eines Anfängers. Teil 3. Module, Diagramme, Baumtabellen</a></li>
<li><a href="../de486052/index.html">Verbrannte Erde ist die Mutter aller Spiele. Interview mit dem Schöpfer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>