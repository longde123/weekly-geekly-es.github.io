<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò• üßëüèø‚Äçü§ù‚Äçüßëüèª üì° C√≥mo hacer que los contenedores est√©n a√∫n m√°s aislados: una revisi√≥n de las tecnolog√≠as de sandbox de contenedores ‚òÇÔ∏è üìé üßùüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A pesar de que la mayor√≠a de la industria de TI implementa soluciones de infraestructura basadas en contenedores y soluciones en la nube, es necesario...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo hacer que los contenedores est√©n a√∫n m√°s aislados: una revisi√≥n de las tecnolog√≠as de sandbox de contenedores</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/457760/">  A pesar de que la mayor√≠a de la industria de TI implementa soluciones de infraestructura basadas en contenedores y soluciones en la nube, es necesario comprender las limitaciones de estas tecnolog√≠as.  Tradicionalmente, Docker, Linux Containers (LXC) y Rocket (rkt) no est√°n realmente aislados porque comparten el n√∫cleo del sistema operativo principal en su trabajo.  S√≠, son efectivos en t√©rminos de recursos, pero el n√∫mero total de vectores de ataque estimados y las p√©rdidas potenciales por pirater√≠a a√∫n son grandes, especialmente en el caso de un entorno de nube multiinquilino en el que se encuentran los contenedores. <br><br><img src="https://habrastorage.org/webt/ls/er/x_/lserx_gyy2iflakk5liv6en4yty.png"><br><br>  La ra√≠z de nuestro problema radica en la delimitaci√≥n d√©bil de los contenedores en el momento en que el sistema operativo host crea un √°rea de usuario virtual para cada uno de ellos.  S√≠, la investigaci√≥n y el desarrollo se han llevado a cabo con el objetivo de crear "contenedores" reales con una caja de arena completa.  Y la mayor√≠a de las soluciones resultantes conducen a una reestructuraci√≥n de los l√≠mites entre contenedores para mejorar su aislamiento.  En este art√≠culo, veremos cuatro proyectos √∫nicos de IBM, Google, Amazon y OpenStack, respectivamente, que utilizan diferentes m√©todos para lograr el mismo objetivo: crear un aislamiento confiable.  Entonces, IBM Nabla despliega contenedores sobre Unikernel, Google gVisor crea un kernel invitado especializado, Amazon Firecracker utiliza un hipervisor extremadamente liviano para aplicaciones de sandbox, y OpenStack coloca contenedores en una m√°quina virtual especializada optimizada para herramientas de orquestaci√≥n. <br><a name="habracut"></a><br><h3>  Resumen de la tecnolog√≠a moderna de contenedores </h3><br>  Los contenedores son una forma moderna de empaquetar, compartir e implementar una aplicaci√≥n.  A diferencia de una aplicaci√≥n monol√≠tica, en la que todas las funciones se empaquetan en un solo programa, las aplicaciones de contenedor o los microservicios est√°n destinados a un uso espec√≠fico y se especializan en una sola tarea. <br><br>  Un contenedor incluye todas las dependencias (por ejemplo, paquetes, bibliotecas y binarios) que una aplicaci√≥n necesita para completar su tarea espec√≠fica.  Como resultado, las aplicaciones en contenedores son independientes de la plataforma y pueden ejecutarse en cualquier sistema operativo, independientemente de la versi√≥n o los paquetes instalados.  Esta conveniencia ahorra a los desarrolladores una gran cantidad de trabajo en la adaptaci√≥n de diferentes versiones de software para diferentes plataformas o clientes.  Aunque conceptualmente no es del todo exacto, a muchas personas les gusta pensar en los contenedores como "m√°quinas virtuales livianas". <br><br>  Cuando un contenedor se implementa en un host, los recursos de cada contenedor, como su sistema de archivos, proceso y pila de red, se colocan en un entorno pr√°cticamente aislado al que otros contenedores no pueden acceder.  Esta arquitectura permite que cientos y miles de contenedores se ejecuten simult√°neamente en un solo cl√∫ster, y cada aplicaci√≥n (o microservicio) se puede escalar f√°cilmente replicando una gran cantidad de instancias. <br><br>  En este caso, el dise√±o del contenedor se basa en dos "bloques de construcci√≥n" clave: el espacio de nombres de Linux y los grupos de control de Linux (cgroups). <br><br>  El espacio de nombres crea un espacio de usuario pr√°cticamente aislado y proporciona a la aplicaci√≥n recursos dedicados del sistema, como el sistema de archivos, la pila de red, la identificaci√≥n del proceso y la identificaci√≥n del usuario.  En este espacio de usuario aislado, la aplicaci√≥n controla el directorio ra√≠z del sistema de archivos y se puede ejecutar como ra√≠z.  Este espacio abstracto permite que cada aplicaci√≥n funcione de forma independiente, sin interferir con otras aplicaciones que viven en el mismo host.  Actualmente hay seis espacios de nombres disponibles: montaje, comunicaci√≥n entre procesos (ipc), sistema de tiempo compartido UNIX (uts), id de proceso (pid), red y usuario.  Se propone completar esta lista con dos espacios de nombres adicionales: tiempo y syslog, pero la comunidad de Linux a√∫n no ha decidido las especificaciones finales. <br><br>  Cgroups proporciona limitaci√≥n de recursos de hardware, priorizaci√≥n, monitoreo y control de aplicaciones.  Un ejemplo de los recursos de hardware que pueden controlar es el procesador, la memoria, el dispositivo y la red.  Al combinar el espacio de nombres y los grupos de c, podemos ejecutar m√∫ltiples aplicaciones de manera segura en el mismo host, con cada aplicaci√≥n en su propio entorno aislado, que es la propiedad fundamental del contenedor. <br><br>  La principal diferencia entre una m√°quina virtual (VM) y un contenedor es que la m√°quina virtual es virtualizaci√≥n a nivel de hardware, y el contenedor es virtualizaci√≥n a nivel de sistema operativo.  El hipervisor VM emula el entorno de hardware para cada m√°quina, donde el tiempo de ejecuci√≥n del contenedor ya emula el sistema operativo para cada objeto.  Las m√°quinas virtuales comparten el hardware f√≠sico del host y los contenedores comparten tanto el hardware como el n√∫cleo del sistema operativo.  Dado que los contenedores generalmente comparten m√°s recursos con el host, su trabajo con los ciclos de almacenamiento, memoria y CPU es mucho m√°s eficiente que con una m√°quina virtual.  Sin embargo, la desventaja de este acceso compartido es un problema en el plano de la seguridad de la informaci√≥n, ya que se establece la confianza entre los contenedores y el host.  La figura 1 ilustra la diferencia arquitect√≥nica entre un contenedor y una m√°quina virtual. <br><br><img src="https://habrastorage.org/webt/_7/qr/bk/_7qrbkpwq4ee_ep709hxsqzyl8o.png"><br><br>  En general, el aislamiento de equipos virtualizados crea un per√≠metro de seguridad mucho m√°s fuerte que el simple aislamiento de un espacio de nombres.  El riesgo de que un atacante abandone con √©xito un proceso aislado es mucho mayor que la posibilidad de abandonar con √©xito la m√°quina virtual.  La raz√≥n del mayor riesgo de ir m√°s all√° del entorno de contenedor limitado es el aislamiento deficiente creado por el espacio de nombres y los grupos c.  Linux los implementa asociando nuevos campos de propiedad con cada proceso.  Estos campos en el sistema de archivos <code>/proc</code> indican al sistema operativo del host si un proceso puede ver a otro o cu√°ntos recursos de procesador / memoria puede usar un proceso en particular.  Al ver procesos y subprocesos en ejecuci√≥n desde el sistema operativo principal (por ejemplo, el comando top o ps), el proceso del contenedor se parece a cualquier otro.  Por lo general, las soluciones tradicionales, como LXC o Docker, no se consideran completamente aisladas porque usan el mismo n√∫cleo dentro del mismo host.  Por lo tanto, no es sorprendente que los contenedores tengan un n√∫mero suficiente de vulnerabilidades.  Por ejemplo, CVE-2014-3519, CVE-2016-5195, CVE-2016-9962, CVE-2017-5123 y CVE-2019-5736 podr√≠an provocar que un atacante obtenga acceso a datos fuera del contenedor. <br><br>  La mayor√≠a de las vulnerabilidades del kernel crean un vector para un ataque exitoso, porque generalmente resultan en la escalada de privilegios y permiten que un proceso comprometido obtenga el control fuera de su espacio de nombres previsto.  Adem√°s de los vectores de ataque en el contexto de vulnerabilidades de software, la configuraci√≥n incorrecta tambi√©n puede desempe√±ar un papel.  Por ejemplo, la implementaci√≥n de im√°genes con privilegios excesivos (CAP_SYS_ADMIN, acceso privilegiado) o puntos cr√≠ticos de montaje ( <code>/var/run/docker.sock</code> ) puede provocar una fuga.  Dadas estas consecuencias potencialmente catastr√≥ficas, debe comprender el riesgo que corre al implementar el sistema en un espacio multiinquilino o al usar contenedores para almacenar datos confidenciales. <br><br>  Estos problemas motivan a los investigadores a crear per√≠metros de seguridad m√°s fuertes.  La idea es crear un contenedor de sandbox real que est√© lo m√°s aislado posible del sistema operativo principal.  La mayor√≠a de estas soluciones incluyen el desarrollo de una arquitectura h√≠brida que utiliza una distinci√≥n estricta entre la aplicaci√≥n y la m√°quina virtual, y se enfoca en mejorar la eficiencia de las soluciones de contenedor. <br><br>  Al momento de escribir este art√≠culo, no hab√≠a un solo proyecto que pudiera llamarse lo suficientemente maduro como para ser aceptado como est√°ndar, pero en el futuro, los desarrolladores aceptar√°n indudablemente algunos de estos conceptos como los principales. <br><br>  Comenzamos nuestra revisi√≥n con Unikernel, el sistema altamente especializado m√°s antiguo que empaqueta una aplicaci√≥n en una imagen usando un conjunto m√≠nimo de bibliotecas del sistema operativo.  El concepto de Unikernel en s√≠ demostr√≥ ser fundamental para muchos proyectos cuyo objetivo era crear im√°genes seguras, compactas y optimizadas.  Despu√©s de eso, pasaremos a considerar IBM Nabla, un proyecto para lanzar aplicaciones Unikernel, incluidos los contenedores.  Adem√°s, tenemos Google gVisor, un proyecto para lanzar contenedores en el espacio del kernel del usuario.  A continuaci√≥n, pasaremos a soluciones de contenedor basadas en m√°quinas virtuales: Amazon Firecracker y OpenStack Kata.  Para resumir esta publicaci√≥n comparando todas las soluciones anteriores. <br><br><h3>  Unikernel </h3><br>  El desarrollo de tecnolog√≠as de virtualizaci√≥n nos ha permitido pasar a la computaci√≥n en la nube.  Los hipervisores como Xen y KVM han sentado las bases de lo que ahora conocemos como Amazon Web Services (AWS) y Google Cloud Platform (GCP).  Y aunque los hipervisores modernos pueden trabajar con cientos de m√°quinas virtuales combinadas en un solo cl√∫ster, los sistemas operativos tradicionales de prop√≥sito general no est√°n demasiado adaptados y optimizados para funcionar en dicho entorno.  El SO de prop√≥sito general est√° destinado, en primer lugar, a admitir y trabajar con tantas aplicaciones diferentes como sea posible, por lo tanto, sus n√∫cleos incluyen todo tipo de controladores, bibliotecas, protocolos, programadores, etc.  Sin embargo, la mayor√≠a de las m√°quinas virtuales que ahora se implementan en alg√∫n lugar de la nube se utilizan para ejecutar una sola aplicaci√≥n, por ejemplo, para proporcionar DNS, un proxy o alg√∫n tipo de base de datos.  Dado que una aplicaci√≥n de este tipo solo se basa en su trabajo en una parte peque√±a y espec√≠fica del n√∫cleo del sistema operativo, todas sus otras "faldas" simplemente desperdician recursos del sistema y, por el solo hecho de su existencia, aumentan el n√∫mero de vectores para un posible ataque.  De hecho, cuanto m√°s grande es la base del c√≥digo, m√°s dif√≠cil es eliminar todas las deficiencias y m√°s vulnerabilidades, errores y otras debilidades potenciales.  Este problema alienta a los especialistas a desarrollar sistemas operativos altamente especializados con un conjunto m√≠nimo de funcionalidades del n√∫cleo, es decir, crear herramientas para admitir una aplicaci√≥n espec√≠fica. <br><br>  Por primera vez, la idea de Unikernel naci√≥ en los a√±os 90.  Luego tom√≥ forma como una imagen especializada de una m√°quina con un solo espacio de direcciones que puede trabajar directamente en hipervisores.  Empaqueta las aplicaciones y funciones principales y dependientes del n√∫cleo en una sola imagen.  Nemesis y Exokernel son las dos primeras versiones de investigaci√≥n del proyecto Unikernel.  El proceso de empaquetado y despliegue se muestra en la Figura 2. <br><br><img src="https://habrastorage.org/webt/lv/pl/2q/lvpl2q9eel5loxodhibvhzjc93m.png"><br>  <i>Figura 2. Sistemas operativos multiprop√≥sito dise√±ados para admitir todo tipo de aplicaciones, por lo que muchas bibliotecas y controladores se cargan por adelantado.</i>  <i>Los Unikernels son sistemas operativos altamente especializados que est√°n dise√±ados para admitir una aplicaci√≥n espec√≠fica.</i> <i><br></i> <br>  Unikernel divide el n√∫cleo en varias bibliotecas y coloca solo los componentes necesarios en la imagen.  Al igual que las m√°quinas virtuales normales, unikernel se implementa y se ejecuta en el hipervisor VM.  Debido a su peque√±o tama√±o, puede cargarse r√°pidamente y tambi√©n escalar r√°pidamente.  Las caracter√≠sticas m√°s importantes de Unikernel son una mayor seguridad, un tama√±o reducido, un alto grado de optimizaci√≥n y una carga r√°pida.  Dado que estas im√°genes contienen solo bibliotecas dependientes de la aplicaci√≥n, y el shell del sistema operativo no es accesible si no estaba conectado a prop√≥sito, la cantidad de vectores de ataque que los atacantes pueden usar en ellas es m√≠nima. <br><br>  Es decir, no solo es dif√≠cil para los atacantes obtener un punto de apoyo en estos n√∫cleos √∫nicos, sino que su influencia tambi√©n se limita a una instancia central.  Dado que el tama√±o de las im√°genes de Unikernel es de solo unos pocos megabytes, se descargan en decenas de milisegundos y, literalmente, cientos de instancias pueden ejecutarse en un solo host.  Al utilizar la asignaci√≥n de memoria en el mismo espacio de direcciones en lugar de una tabla de p√°ginas multinivel, como es el caso en la mayor√≠a de los sistemas operativos modernos, las aplicaciones unikernel tienen un menor retraso de acceso a la memoria en comparaci√≥n con la misma aplicaci√≥n que se ejecuta en una m√°quina virtual normal.  Debido a que las aplicaciones se unen con el n√∫cleo al construir la imagen, los compiladores simplemente pueden realizar una verificaci√≥n de tipo est√°tico para optimizar los archivos binarios. <br><br>  Unikernel.org mantiene una lista de proyectos unikernel.  Pero con todas sus caracter√≠sticas y propiedades distintivas, unikernel no se usa ampliamente.  Cuando Docker adquiri√≥ Unikernel Systems en 2016, la comunidad decidi√≥ que la compa√±√≠a ahora empacar√≠a contenedores en ellos.  Pero han pasado tres a√±os y todav√≠a no hay signos de integraci√≥n.  Una de las principales razones de esta implementaci√≥n lenta es que todav√≠a no existe una herramienta madura para crear aplicaciones Unikernel, y la mayor√≠a de estas aplicaciones solo pueden funcionar en ciertos hipervisores.  Adem√°s, portar una aplicaci√≥n a unikernel puede requerir reescribir manualmente el c√≥digo en otros idiomas, incluida la reescritura de bibliotecas de kernel dependientes.  Tambi√©n es importante que el monitoreo o la depuraci√≥n en unikernels sea imposible o tenga un impacto significativo en el rendimiento. <br><br>  Todas estas restricciones evitan que los desarrolladores cambien a esta tecnolog√≠a.  Cabe se√±alar que unikernel y contenedores tienen muchas propiedades similares.  Tanto el primero como el segundo son im√°genes inmutables altamente enfocadas, lo que significa que los componentes dentro de ellos no pueden actualizarse o repararse, es decir, siempre debe crear una nueva imagen para el parche de la aplicaci√≥n.  Hoy, Unikernel es similar al antecesor de Docker: entonces el tiempo de ejecuci√≥n del contenedor no estaba disponible y los desarrolladores tuvieron que usar las herramientas b√°sicas para crear un entorno de aplicaci√≥n aislado (chroot, unshare y cgroups). <br><br><h3>  Ibm nabla </h3><br>  Una vez, los investigadores de IBM propusieron el concepto de "Unikernel como un proceso", es decir, la aplicaci√≥n unikernel que se ejecutar√≠a como un proceso en un hipervisor especializado.  El proyecto de IBM "contenedores Nabla" fortaleci√≥ el per√≠metro de seguridad de unikernel, reemplazando el hipervisor universal (por ejemplo, QEMU) con su propio desarrollo llamado Nabla Tender.  La raz√≥n detr√°s de este enfoque es que las llamadas entre unikernel y el hipervisor a√∫n proporcionan la mayor√≠a de los vectores de ataque.  Es por eso que el uso de un hipervisor dedicado a unikernel con menos llamadas al sistema permitidas puede fortalecer significativamente el per√≠metro de seguridad.  Nabla Tender intercepta las llamadas que desv√≠an las rutas al hipervisor y ya las traduce en solicitudes del sistema.  Al mismo tiempo, la pol√≠tica seccomp Linux bloquea todas las dem√°s llamadas al sistema que no son necesarias para que Tender funcione.  Por lo tanto, Unikernel junto con Nabla Tender se ejecuta como un proceso en el espacio de usuario del host.  A continuaci√≥n, en la figura # 3, se muestra c√≥mo Nabla crea una interfaz delgada entre unikernel y el host. <br><br><img src="https://habrastorage.org/webt/wy/je/p6/wyjep6mcxwfd8n-ogesrx1rnjyi.png"><br>  <i>Figura 3. Para vincular Nabla con las plataformas de tiempo de ejecuci√≥n de contenedores existentes, Nabla utiliza un entorno compatible con OCI, que a su vez se puede conectar a Docker o Kubernetes.</i> <br><br>  Los desarrolladores afirman que Nabla Tender utiliza menos de siete llamadas al sistema en su trabajo para interactuar con el host.  Dado que las llamadas al sistema sirven como una especie de puente entre los procesos en el espacio del usuario y el n√∫cleo del sistema operativo, mientras menos llamadas tengamos disponibles, menor ser√° el n√∫mero de vectores disponibles para atacar el n√∫cleo.  Otra ventaja de ejecutar unikernel como proceso es que puede depurar dichas aplicaciones usando una gran cantidad de herramientas, por ejemplo, usando gdb. <br><br>  Para trabajar con plataformas de orquestaci√≥n de contenedores, Nabla proporciona un <code>runnc</code> dedicado que se implementa utilizando el est√°ndar Open Container Initiative (OCI).  Este √∫ltimo define una API entre clientes (por ejemplo, Docker, Kubectl) y el entorno de tiempo de ejecuci√≥n (por ejemplo, runc).  Nabla tambi√©n viene con un constructor de im√°genes que <code>runnc</code> luego podr√° ejecutar.  Sin embargo, debido a las diferencias en el sistema de archivos entre unikernels y contenedores tradicionales, las im√°genes de Nabla no cumplen con las especificaciones de imagen OCI y, por lo tanto, las im√°genes de Docker no son compatibles con <code>runnc</code> .  Al momento de escribir, el proyecto a√∫n se encuentra en las primeras etapas de desarrollo.  Existen otras restricciones, por ejemplo, la falta de soporte para montar / acceder a sistemas de archivos host, agregar varias interfaces de red (necesarias para Kubernetes) o usar im√°genes de otras im√°genes unikernel (por ejemplo, MirageOS). <br><br><h3>  Google gVisor </h3><br>  Google gVisor es una tecnolog√≠a de espacio aislado que utiliza el motor de aplicaciones de Google Cloud Platform (GCP), las funciones de la nube y CloudML.  En alg√∫n momento, Google se dio cuenta del riesgo de ejecutar aplicaciones no confiables en la infraestructura de la nube p√∫blica y la ineficiencia de las aplicaciones de sandbox que usan m√°quinas virtuales.  Como resultado, se desarroll√≥ un n√∫cleo de espacio de usuario para un entorno aislado de aplicaciones poco confiables.  gVisor coloca estas aplicaciones en el sandbox, interceptando todas las llamadas del sistema desde ellas al kernel host y proces√°ndolas en el entorno del usuario utilizando el kernel gVisor Sentry.  En esencia, funciona como una combinaci√≥n de un n√∫cleo invitado y un hipervisor.  La Figura 4 muestra la arquitectura gVisor. <br><br><img src="https://habrastorage.org/webt/rk/xe/eq/rkxeeqqm9qs73q5enqp6zy99rfk.png"><br>  <i>Figura 4. Implementaci√≥n del kernel gVisor // Los sistemas de archivos Sentry y gVisor Gofer utilizan una peque√±a cantidad de llamadas del sistema para interactuar con el host</i> <br><br>  gVisor crea un fuerte per√≠metro de seguridad entre la aplicaci√≥n y su host.  Limita las llamadas al sistema que las aplicaciones pueden usar en el espacio del usuario.  Sin depender de la virtualizaci√≥n, gVisor funciona como un proceso de host que interact√∫a entre una aplicaci√≥n independiente y un host.  Sentry admite la mayor√≠a de las llamadas al sistema Linux y las caracter√≠sticas principales del n√∫cleo, como la entrega de se√±al, la administraci√≥n de memoria, la pila de red y el modelo de transmisi√≥n.  Sentry implementa m√°s del 70% de las 319 llamadas al sistema Linux para admitir aplicaciones de espacio aislado.  Sin embargo, Sentry utiliza menos de 20 llamadas al sistema Linux para interactuar con el n√∫cleo del host.  Vale la pena se√±alar que gVisor y Nabla tienen una estrategia muy similar: proteger el sistema operativo host y ambas soluciones utilizan menos del 10% de las llamadas al sistema Linux para interactuar con el n√∫cleo.  Pero debe comprender que gVisor crea un n√∫cleo multiprop√≥sito y, por ejemplo, Nabla se basa en n√∫cleos √∫nicos.  Al mismo tiempo, ambas soluciones lanzan un n√∫cleo invitado especializado en el espacio de usuario para admitir aplicaciones aisladas en las que conf√≠an. <br><br>  Alguien puede preguntarse por qu√© gVisor necesita su propio n√∫cleo, cuando el n√∫cleo de Linux ya es de c√≥digo abierto y de f√°cil acceso.  ,  gVisor,   Golang,  ,   ‚Äã‚ÄãLinux,   C.           Golang.      gVisor ‚Äî    Docker, Kubernetes   OCI.   Docker        gVisor,     gVisor runsc.   Kubernetes  ¬´¬ª       gVisor    ¬´¬ª-. <br><br>  gVisor      ,     .  gVisor     ,    ,   ,       . ( ,   Nabla   ,   unikernel    . Nabla        hypercall).  gVisor     (passthrough),  ,   , ,  GPU,     . ,  gVisor   70%   Linux, ,       ,     gVisor. <br><br><h3> Amazon Firecracker </h3><br> Amazon Firecracker ‚Äî  ,     AWS Lambda  AWS Fargate.  ,   ¬´  ¬ª (MicroVM)   multi-tenant     .   Firecracker  Lambda  Fargate         EC2  ,    .            ,      ,                . Firecracker    ,   ,      .  Firecracker                ,   .       Linux     ext4      . Amazon   Firecracker  2017 ,   2018      . <br><br>   unikernel, Firecracker          .       micro-VM      ,        .  ,  micro-VM  Firecracker   5      ~125        2 CPU + 256  RAM.   5   Firecracker    . <br><br><img src="https://habrastorage.org/webt/_i/rd/qu/_irdqutnwf2v659vbsxz47igzo0.png"><br> <i> 5.  Firecracker         </i> <br><br> Firecracker   KVM,         .   Firecracker   seccomp, cgroups  namespaces,   ,  ,         .    Firecracker   . ,  API         microVM.        virtIO (  ). Firecracker        microVM: virtio-block, virtio-net, serial console  1-button  ,     microVM.               .   ,   ,   microVM  File Block Devices,       .       ,      cgroups.         ,           . <br><br>      Firecracker         Docker  Kubernetes. Firecracker      ,  ,          ,   .               .   ,     ,        OCI     . <br><br><h3> OpenStack Kata </h3><br>     ,  2015   Intel         Clear Containers. Clear Containers      Intel VT     QEMU-KVM <code>qemu-lite</code> .   2017   Clear Containers   Hyper RunV,     OCI,     Kata.    Clear Containers, Kata        . <br><br> Kata    OCI,    (CRI)    (CNI).       (, passthrough, MacVTap, bridge, tc mirroring)    ,        ,       .   6 ,      Kata     . <br><br><img src="https://habrastorage.org/webt/f0/7k/yy/f07kyyzusufaygo32ysb8hjjb-i.png"><br> <i> 6.    Kata  Docker  Kubernetes</i> <br><br>   Kata     .       Kata     Kata Shim,    API   (, docker  kubectl)         VSock.  Kata   . NEMU ‚Äî    QEMU    ~80%   . VM-Templating     Kata VM         .          ,          ,  ,  CVE-2015-2877.   ¬´ ¬ª        (, , ,  virtio),      . <br><br>  Kata  Firecracker ‚Äî   ¬´¬ª    ,    .    ,   . Firecracker ‚Äî   ,        ,      Kata ‚Äî    ,      .      Kata  Firecracker.         ,        . <br><br><h3>  Conclusi√≥n </h3><br>    ,   ‚Äî        . <br><br> IBM Nabla ‚Äî     unikernel,       . <br><br> Google gVisor ‚Äî        ,         . <br><br> Amazon Firecracker ‚Äî   ,           . <br><br> OpenStack Kata ‚Äî        ,      . <br><br>  ,       ,         .             . Nabla   ,     ,   unikernel-,   MirageOS  IncludeOS. gVisor      Docker  Kubernetes,  -         . Firecracker         ,         .  Kata    OCI      KVM,     Xen.        . <br><br><img src="https://habrastorage.org/webt/50/d1/gr/50d1grnpu0ushkd6pkjl74vbeju.png"><br><br>  ,      ,   ,      ,           . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/457760/">https://habr.com/ru/post/457760/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../457750/index.html">Trabaja con JSON RPC en Symfony 4</a></li>
<li><a href="../457752/index.html">No rovers lunares ni bromistas. ¬øQu√© sabemos sobre los robots en Fukushima?</a></li>
<li><a href="../457754/index.html">Estado y asesinos en T</a></li>
<li><a href="../457756/index.html">El libro Kafka Streams en acci√≥n. Aplicaciones y microservicios en tiempo real ¬ª</a></li>
<li><a href="../457758/index.html">Los ingenieros salvan a las personas perdidas en el bosque, pero el bosque a√∫n no se ha rendido</a></li>
<li><a href="../457762/index.html">Regla CCD: con qu√© se come</a></li>
<li><a href="../457764/index.html">10 errores del joven PO (parte II)</a></li>
<li><a href="../457766/index.html">Generamos niveles de mosaico y ocultamos cuadrados del jugador</a></li>
<li><a href="../457768/index.html">C√≥mo me volv√≠ vulnerable: escaneando la infraestructura de TI con Qualys</a></li>
<li><a href="../457770/index.html">Escribimos transformadores personalizados AST en TypeScript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>