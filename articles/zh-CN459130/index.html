<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧛🏽 🤧 🙋🏻 微服务中的温和错误处理 📱 😄 👍🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本文介绍了如何在Go中基于“ Made and Forgot”原理实现错误处理和日志记录。 该方法专为Go上的微服务而设计，可在Docker容器中工作，并符合Clean Architecture的原则构建。 


 本文是最近在喀山举行的Go会议的报告的详细版本。 如果您对Go感兴趣，并且住在喀山，...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>微服务中的温和错误处理</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459130/"><p> 本文介绍了如何在Go中基于“ Made and Forgot”原理实现错误处理和日志记录。 该方法专为Go上的微服务而设计，可在Docker容器中工作，并符合Clean Architecture的原则构建。 </p><a name="habracut"></a><br><p> 本文是最近<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在喀山举行的Go会议</a>的报告的详细版本。 如果您对Go感兴趣，并且住在喀山，Innopolis，美丽的Yoshkar-Ola或附近的其他城市，则应该访问社区页面： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">golangkazan.github.io</a> 。 </p><br><p> 在会议上，我们的团队在两份报告中展示了我们如何在Go上开发微服务-我们遵循的原则以及如何简化生活。 本文重点介绍错误处理的概念，现在将其扩展到所有新的微服务。 </p><br>
<h2 id="soglasheniya-o-strukture-mikroservisa"> 微服务结构协议 </h2><br><p> 在探讨错误处理规则之前，有必要确定在设计和编码时要遵守哪些限制。 为此，值得告诉我们微服务的外观。 </p><br><p> 首先，我们尊重干净的架构。 我们将代码分为三个级别并遵守相关性规则：更深层次的包独立于外部包，并且没有循环依赖。 幸运的是，Go中禁止直接循环依赖包。 通过借用术语，关于行为或转换为类型的假设的间接依赖性仍然会出现，应避免使用它们。 </p><br><p> 这是我们的关卡外观： </p><br><ol><li> 域级别包含主题领域规定的业务逻辑规则。 <br><ul><li> 如果任务很简单，有时我们会没有领域 </li><li>  <em>规则：</em>域级别的代码仅取决于Go的功能，标准Go库和扩展Go语言的所选库 </li></ul></li><li> 应用程序层包含由应用程序的任务规定的业务逻辑规则。 <br><ul><li>  <em>规则：</em>应用程序级别的代码可能取决于域 </li></ul></li><li> 基础结构级别包含将应用程序与各种技术（用于存储（MySQL，Redis），传输（GRPC，HTTP），与外部环境和其他服务的交互）连接的基础结构代码。 <br><ul><li>  <em>规则：</em>基础架构级别的代码可能取决于域和应用程序 </li><li>  <em>规则：</em>每个Go软件包仅一种技术 </li></ul></li><li> 主程序包创建所有对象-“生命周期单例”，将它们连接在一起并启动寿命长的协程-例如，它开始处理来自端口8081的HTTP请求 </li></ol><br><p> 这是微服务目录树的外观（Go代码所在的部分）： </p><br><p><img src="https://habrastorage.org/webt/dk/ft/id/dkftidhxmqh30yy9zbdaeajfbgy.png" alt="图片：转到项目树"></p><br><p> 对于每个应用程序上下文（模块），包结构如下所示： </p><br><ul><li>应用程序包声明一个Service接口，其中包含在给定级别上实现服务结构接口和<code>func NewService(...) Service</code>函数<code>func NewService(...) Service</code>所有可能操作<code>func NewService(...) Service</code> </li><li> 由于域或应用程序包声明了存储库接口，因此实现了数据库工作的隔离，该接口是在包中的基础结构级别以可视名称“ mysql”实现的 </li><li> 运输代码位于<code>infrastructure/transport</code>包中 <br><ul><li> 我们使用GRPC，因此服务器存根是从原始文件中生成的（即服务器接口，响应/请求结构以及所有客户端交互代码） </li></ul></li></ul><br><p> 所有这些都显示在图中： </p><br><p><img src="https://habrastorage.org/webt/-p/gm/hi/-pgmhid0ohkvijl2zmghnlokz7y.png" alt="图片：Go项目包装图"></p><br><h2 id="principy-obrabotki-oshibok"> 错误处理原则 </h2><br><p> 这里的一切都很简单： </p><br><ol><li> 我们认为在处理对API的请求时会发生错误和紧急情况-这意味着错误或紧急情况只会影响一个请求 </li><li> 我们认为日志仅用于事件分析（并且有用于调试的调试器），因此，在日志中接收到有关请求的信息，首先是处理请求时出现意外错误 </li><li> 我们相信，整个基础架构都是为处理日志而构建的（例如，基于ELK）-微服务在其中扮演着被动的角色，将日志写入stderr </li></ol><br><p> 我们不会关注于紧急情况：只是不要忘记在每个goroutine中处理紧急情况，并且在处理每个请求，每个消息，由请求启动的每个异步任务的过程中。 恐慌几乎总是会变成错误，以防止整个应用程序完成。 </p><br><h2 id="idioma-sentinel-errors"> 成语前哨错误 </h2><br><p> 在业务逻辑级别，仅处理由业务规则定义的预期错误。 前哨错误将帮助您识别此类错误-我们使用此惯用语，而不是为错误编写我们自己的数据类型。 一个例子： </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> app <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"errors"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ErrNoCake = errors.New(<span class="hljs-string"><span class="hljs-string">"no cake found"</span></span>)</code> </pre> <br><p> 这里声明了一个全局变量，根据我们的先生的同意，我们不应在任何地方进行更改。 如果您不喜欢全局变量并使用linter来检测它们，则可以使用一些常量，如Dave Cheney在“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">常量错误”</a>帖子中建议的那样： </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> app <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Error <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e Error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(e) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ErrNoCake = Error(<span class="hljs-string"><span class="hljs-string">"no cake found"</span></span>)</code> </pre> <br><blockquote> 如果您喜欢这种方法，则可能需要将<code>ConstError</code>类型添加到公司的Go语言库中。 </blockquote><br><h2 id="kompoziciya-oshibok"> 错误的构成 </h2><br><p> 前哨错误的主要优点是可以轻松编写错误。 特别是在创建错误或从外部接收错误时，最好向其添加stacktrace。 为此，有两种流行的解决方案。 </p><br><ul><li>  xerrors软件包，该软件包在Go 1.13中将作为实验包含在标准库中 </li><li>  Dave Cheney的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github.com/pkg/errors</a>包 <br><ul><li> 包装是冷冻的，不会膨胀，但是还是不错的 </li></ul></li></ul><br><p> 我们的团队仍然使用<code>github.com/pkg/errors</code>和<code>errors.WithStack</code>函数（当我们除了stacktrace之外没有其他可添加的东西）或<code>errors.Wrap</code> （当我们对这个错误有<code>errors.Wrap</code>时）。 这两个函数都在输入处接受错误并返回新的错误，但是具有堆栈跟踪。 基础结构层的示例： </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> mysql <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/pkg/errors"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *repository)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindOne</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> { row := r.client.QueryRow(sql, params...) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> err := row.Scan(...) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> sql.ErrNoRows: <span class="hljs-comment"><span class="hljs-comment">//     stacktrace return nil, errors.WithStack(app.ErrNoCake) } }</span></span></code> </pre> <br><p> 我们建议每个错误只包装一次。 如果遵循规则，这很容易做到： </p><br><ul><li> 任何外部错误都将打包到一个基础结构软件包中 </li><li> 由业务逻辑规则生成的任何错误都将在创建时由stacktrace进行补充 </li></ul><br><h2 id="pervoprichina-oshibki"> 错误的根本原因 </h2><br><p> 预期将所有错误分为预期错误和意外错误。 要处理预期的错误，您需要摆脱合成的影响。  xerrors和<code>github.com/pkg/errors</code>软件包具有您所需的一切：尤其是errors软件包具有<code>errors.Cause</code>函数，该函数返回错误的根本原因。 循环执行此函数，一个接一个，检索较早的错误，而下一个提取的错误具有<code>Cause() error</code>方法。 </p><br><p> 我们从中提取根本原因并将其与前哨错误直接进行比较的示例： </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *service)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SaveCake</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { state, err := s.repo.FindOne(...) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.Cause(err) == ErrNoCake { err = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-comment"><span class="hljs-comment">// No cake is OK, create a new one // ... } else if err != nil { // ... } }</span></span></code> </pre> <br><h2 id="obrabotka-oshibok-v-defer"> 延误处理 </h2><br><p> 也许您正在使用linter，这使您可以手动检查所有错误。 在这种情况下，当linter要求您使用<code>.Close()</code>方法和仅<code>defer</code>其他方法来检查错误时，您可能会很生气。 您是否曾经尝试过正确地延迟处理错误，尤其是在此之前还有其他错误的情况下？ 而且我们已经尝试并急于分享食谱。 </p><br><p> 想象一下，我们与数据库的所有工作都是严格通过事务进行的。 根据依赖关系规则，应用程序和域级别不应直接或间接依赖于基础结构和SQL技术。 这意味着<strong>在应用程序和域级别没有单词“ transaction”</strong> 。 </p><br><p> 最简单的解决方案是将“交易”一词替换为抽象的东西。 这样就产生了工作单位模式。 在我们的实现中，应用程序包中的服务通过UnitOfWorkFactory接口接收工厂，并在每次操作期间创建一个隐藏事务的UnitOfWork对象。  UnitOfWork对象允许您获取存储库。 </p><br><div class="spoiler">  <b class="spoiler_title">有关UnitOfWork的更多信息</b> <div class="spoiler_text"><p> 为了更好地理解工作单元的用法，请看一下该图： </p><br><p><img src="https://habrastorage.org/webt/08/hi/iy/08hiiyavd51o3_aof9ys_s9noue.png" alt="Image Go工作单元"></p><br><ul><li> 存储库表示已定义类型的对象（例如，域级聚合）的抽象持久性集合 </li><li>  UnitOfWork隐藏事务并创建存储库对象 </li><li>  UnitOfWorkFactory仅允许服务创建新交易，而无需了解任何交易。 </li></ul><br><p> 为每个操作（即使最初是原子操作）创建事务都不过分吗？ 由您决定； 我们认为，保持业务逻辑的独立性比节省创建事务更为重要。 </p><br><p> 是否可以将UnitOfWork和存储库结合在一起？ 有可能，但我们认为这违反了单一责任原则。 </p></div></div><br><p> 界面如下所示： </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> UnitOfWork <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Repository() Repository Complete(err *error) }</code> </pre> <br><p>  UnitOfWork接口提供了Complete方法，该方法采用一个in-out参数：指向错误接口的指针。 是的，它是指针，它是in-out参数-在任何其他情况下，调用方的代码都将更加复杂。 </p><br><p> 使用unitOfWork的示例操作： </p><br><blockquote> 注意：错误<strong>必须</strong>声明为命名返回值。 如果您使用局部变量err而不是命名的返回值err，则不能延后使用它！ 而且还没有一个短绒棉能够检测到这种情况-见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">批评家＃801</a> </blockquote><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *service)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CookCake</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span></span> { unitOfWork, err := s.unitOfWorkFactory.New() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> unitOfWork.Complete(&amp;err) repo := unitOfWork.Repository() } <span class="hljs-comment"><span class="hljs-comment">// ...  </span></span></code> </pre> <br><p> 这样就完成了 <del> 交易 </del> 工作单位： </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u *unitOfWork)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Complete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err *error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">//     -  commit txErr := u.tx.Commit() *err = errors.Wrap(txErr, "cannot complete transaction") } else { //    -  rollback txErr := return u.tx.Rollback() //  rollback   ,    *err = mergeErrors(*err, errors.Wrap(txErr, "cannot rollback transaction")) } }</span></span></code> </pre> <br><p>  <code>mergeErrors</code>函数合并两个错误，但是它处理nil时没有问题，而不是一个或两个错误。 同时，我们认为这两个错误都发生在不同阶段执行一个操作的过程中，第一个错误更为重要-因此，当两个错误都不为零时，我们将保存第一个错误，而从第二个错误中仅保存消息： </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> errors <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mergeErrors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error, nextErr error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { err = nextErr } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> nextErr != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { err = errors.Wrap(err, nextErr.Error()) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err }</code> </pre> <br><blockquote> 也许您应该将<code>mergeErrors</code>函数添加到Go的公司库中。 </blockquote><br><h2 id="podsistema-logirovaniya"> 记录子系统 </h2><br><p> 文章<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">清单：在prod中启动微服务之前，您必须做什么</a> ： </p><br><ul><li> 日志以stderr编写 </li><li> 日志应使用JSON，每行一个紧凑的JSON对象 </li><li> 应该有一组标准的字段： <br><ul><li>  timestamp-事件时间（以<strong>毫秒为单位）</strong> ，最好采用RFC 3339格式（例如：“ 1985-04-12T23：20：50.52Z”） </li><li> 级别-重要性级别，例如“信息”或“错误” </li><li>  app_name-应用程序名称 </li><li> 和其他领域 </li></ul></li></ul><br><p> 我们更愿意在错误消息中添加两个字段： <code>"error"</code>和<code>"stacktrace"</code> 。 </p><br><p> 我们使用了许多Golang语言的优质日志记录库，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">sirupsen / logrus</a> 。 但是我们不直接使用该库。 首先，在我们的<code>log</code>包中，我们将过度扩展的库接口简化为一个Logger接口： </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> log <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Logger <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { WithField(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) Logger WithFields(Fields) Logger Debug(...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) Info(...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) Error(error, ...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) }</code> </pre> <br><p> 如果程序员要编写日志，则必须从外部获取Logger接口，并且应该在基础结构级别（而不是应用程序或域）上完成此操作。 记录器界面简洁明了： </p><br><ul><li> 正如文章所建议的，它减少了调试，信息和错误的严重性级别的数量<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">。</a> </li><li> 它为Error方法引入了特殊规则：该方法始终接受错误对象 </li></ul><br><p> 这样的严格性可以指导程序员朝正确的方向：如果有人想对日志记录系统本身进行改进，那么他应该考虑到他们收集和处理的整个基础结构，而这仅从微服务开始（通常在Kibana和Zabbix）。 </p><br><p> 但是，日志包中还有另一个接口，允许您在发生致命错误时中断程序，因此只能在主包中使用： </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> log <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MainLogger <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Logger FatalError(error, ...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) }</code> </pre> <br><h2 id="paket-jsonlog">  Jsonlog包 </h2><br><p> 在<code>jsonlog</code>包中实现Logger接口，该接口配置logrus库并对其进行抽象处理。 示意图如下所示： </p><br><p><img src="https://habrastorage.org/webt/g4/we/6m/g4we6m81oxxtd1nlvwklblru6eq.png" alt="图像记录仪仪包装图"></p><br><p> 专有软件包允许您连接微服务的需求（由<code>log.Logger</code>接口表示），logrus库的功能以及基础架构的功能（日志记录）。 </p><br><p> 例如，我们使用ELK（Elastic Search，Logstash，Kibana），因此在jsonlog包中，我们： </p><br><ul><li> 设置logrus的logrus.JSONFormatter格式 <br><ul><li> 同时，我们设置FieldMap选项，通过该选项，我们将<code>"time"</code>字段转换为<code>"@timestamp"</code> ，将<code>"msg"</code>字段转换为<code>"message"</code> </li></ul></li><li> 选择日志级别 </li><li> 添加一个挂钩，该挂钩从传递给<code>Error(error, ...interface{})</code>方法的<code>Error(error, ...interface{})</code>对象中提取stacktrace </li></ul><br><p> 微服务在主要功能中初始化记录器： </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initLogger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(config Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(log.MainLogger, error)</span></span></span></span> { logLevel, err := jsonlog.ParseLevel(config.LogLevel) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.Wrap(err, <span class="hljs-string"><span class="hljs-string">"failed to parse log level"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jsonlog.NewLogger(&amp;jsonlog.Config{ Level: logLevel, AppName: <span class="hljs-string"><span class="hljs-string">"cookingservice"</span></span> }), <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><h2 id="obrabotka-oshibok-i-logirovanie-s-pomoschyu-middleware"> 使用中间件进行错误处理和记录 </h2><br><p> 我们正在Go上的微服务中切换到GRPC。 但是，即使您使用HTTP API，一般原则也适用于您。 </p><br><p> 首先，错误处理和日志记录应该在负责传输的程序包中的<code>infrastructure</code>级别上进行，因为正是他将传输协议规则的知识与<code>app.Service</code>接口<code>app.Service</code>知识相结合。 回想一下包关系如何： </p><br><p><img src="https://habrastorage.org/webt/fw/zn/hz/fwznhzsxd35ydgajmotnvprqbum.png" alt="图像GRPC封装图"></p><br><p> 使用中间件模式可以方便地处理错误和维护日志（中间件是Golang和Node.js世界中Decorator模式的名称）： </p><br><p> 在哪里添加中间件？ 应该有几个？ </p><br><p> 有多种添加中间件的选项，您可以选择： </p><br><ul><li> 您可以装饰<code>app.Service</code>接口，但我们不建议您这样做，因为此接口不会接收传输层信息，例如客户端IP </li><li> 使用GRPC，您可以在所有请求上挂一个处理程序（更确切地说，两个处理程序-一元和Steam），但是所有API方法将以相同的样式和相同的字段集记录 </li><li> 使用GRPC，代码生成器为我们创建了一个服务器接口，在其中我们称为<code>app.Service</code>方法-我们修饰了该接口，因为它具有传输级信息以及以不同方式记录不同API方法的能力 </li></ul><br><p> 示意图如下所示： </p><br><p><img src="https://habrastorage.org/webt/vn/dl/eh/vndlehx5hogpu09hj3zekrzmyie.png" alt="图像GRPC中间件包装图"></p><br><p> 您可以创建不同的中间件来进行错误处理（和紧急处理）以及进行日志记录。 您可以将所有内容合而为一。 我们将考虑一个示例，其中所有内容都跨入一个中间件，该中间件是这样创建的： </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewMiddleware</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(next api.BackendService, logger log.Logger)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">api</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BackendService</span></span></span></span> { server := &amp;errorHandlingMiddleware{ next: next, logger: logger, } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> server }</code> </pre> <br><p> 我们将<code>api.BackendService</code>接口作为<code>api.BackendService</code>并进行装饰，将<code>api.BackendService</code>接口的实现作为<code>api.BackendService</code> 。 </p><br><p> 中间件中的任意API方法实现如下： </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *errorHandlingMiddleware)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ctx context.Context, req *api.ListCakesRequest)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*api.ListCakesResponse, error)</span></span></span></span> { start := time.Now() res, err := m.next.ListCakes(ctx, req) m.logCall(start, err, <span class="hljs-string"><span class="hljs-string">"ListCakes"</span></span>, log.Fields{ <span class="hljs-string"><span class="hljs-string">"cookIDs"</span></span>: req.CookIDs, }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res, translateError(err) }</code> </pre> <br><p> 在这里，我们执行三个任务： </p><br><ol><li> 调用装饰对象的ListCakes方法 </li><li> 我们<code>logCall</code>方法，将所有重要信息传递给其中，包括单独选择的属于日志的字段集 </li><li> 最后，我们通过调用translateError替换错误。 </li></ol><br><p> 错误翻译将在后面讨论。  <code>logCall</code>由<code>logCall</code>方法执行，该方法仅调用正确的Logger接口方法： </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *errorHandlingMiddleware)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(start time.Time, err error, method </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, fields log.Fields)</span></span></span></span> { fields[<span class="hljs-string"><span class="hljs-string">"duration"</span></span>] = fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%v"</span></span>, time.Since(start)) fields[<span class="hljs-string"><span class="hljs-string">"method"</span></span>] = method logger := m.logger.WithFields(fields) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { logger.Error(err, <span class="hljs-string"><span class="hljs-string">"call failed"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { logger.Info(<span class="hljs-string"><span class="hljs-string">"call finished"</span></span>) } }</code> </pre> <br><h2 id="translyaciya-oshibok"> 错误翻译 </h2><br><p> 我们必须找出错误的根本原因，并将其变成在传输级别可以理解并记录在服务API中的错误。 </p><br><p> 在GRPC中，这很简单-使用<code>status.Errorf</code>函数创建带有状态码的错误。 如果您具有HTTP API（REST API），则可以创建自己的错误类型， <strong>应用程序和域级别不应该知道。</strong> </p><br><p> 初步近似，错误翻译如下： </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// ! ! -   err  status.Error func translateError(err error) error { switch errors.Cause(err) { case app.ErrNoCake: err = status.Errorf(codes.NotFound, err.Error()) default: err = status.Errorf(codes.Internal, err.Error()) } return err }</span></span></code> </pre> <br><p> 验证输入参数时，修饰后的接口可以返回状态错误。状态类型带有状态代码，而第一个版本的translateError将丢失此状态代码。 </p><br><p> 让我们通过强制转换为接口类型（鸭子长寿！）来改进版本： </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> statusError <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { GRPCStatus() *status.Status } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isGrpcStatusError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(er error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { _, ok := err.(statusError) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">translateError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isGrpcStatusError(err) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> errors.Cause(err) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> app.ErrNoCake: err = status.Errorf(codes.NotFound, err.Error()) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: err = status.Errorf(codes.Internal, err.Error()) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err }</code> </pre> <br><p> 为您的微服务中的每个上下文（独立模块）分别创建了<code>translateError</code>函数，并将业务逻辑错误转换为传输级错误。 </p><br><h2 id="podvedyom-itogi"> 总结一下 </h2><br><p> 我们为您提供一些规则来处理错误和处理日志。 是否遵循它们取决于您。 </p><br><ol><li> 遵循Clean Architecture的原则，不要直接或间接破坏依赖关系规则。 业务逻辑应仅取决于编程语言，而不取决于外部技术。 </li><li> 使用提供错误组合和堆栈跟踪创建的程序包。 例如，“ github.com/pkg/errors”或xerrors包，它将很快成为Go标准库的一部分。 </li><li> 请勿在微服务中使用第三方日志记录库-使用log和jsonlog包创建自己的库，这将隐藏日志记录实现的详细信息 </li><li> 使用中间件模式来处理错误并在程序的基础结构级别的传输方向上写日志 </li></ol><br><p> 在这里，我们没有提及查询跟踪技术（例如OpenTracing），指标监视（例如数据库查询性能）以及其他类似日志记录的内容。 您自己会处理的，我们相信您。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN459130/">https://habr.com/ru/post/zh-CN459130/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN459118/index.html">我们如何在莫斯科办公室的华为上设计和实现新网络，第2部分</a></li>
<li><a href="../zh-CN459120/index.html">UNO-1000 / 2000系列模块化嵌入式计算机</a></li>
<li><a href="../zh-CN459122/index.html">Aleksey Savvateev：因分析不完善的市场（2014年）和集体声誉而获得Jean Tyrol的诺贝尔奖</a></li>
<li><a href="../zh-CN459126/index.html">带有Intel Neural Computer Stick 2的Raspberry Pi机器人储物箱</a></li>
<li><a href="../zh-CN459128/index.html">现实世界中的日语界面</a></li>
<li><a href="../zh-CN459134/index.html">使用BDD的经验</a></li>
<li><a href="../zh-CN459136/index.html">假蓝丸</a></li>
<li><a href="../zh-CN459138/index.html">华为密钥如何进入思科路由器固件</a></li>
<li><a href="../zh-CN459140/index.html">植入物放置：如何完成？</a></li>
<li><a href="../zh-CN459142/index.html">在R中建立动画的移动平均线形图。通过NBA API检索数据</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>