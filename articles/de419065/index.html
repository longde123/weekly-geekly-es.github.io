<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úã üì† üêë Virtuelle Welt Intel. √úbe üßùüèø üíÖüèª ‚öúÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel m√∂chte ich die praktischen Aspekte der Erstellung eines einfachen Hypervisors auf der Basis der Intel VMX-Hardwarevirtualisierungste...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Virtuelle Welt Intel. √úbe</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419065/">  In diesem Artikel m√∂chte ich die praktischen Aspekte der Erstellung eines <u>einfachen</u> Hypervisors auf der Basis der Intel VMX-Hardwarevirtualisierungstechnologie ber√ºcksichtigen. <br><br>  Die Hardwarevirtualisierung ist ein eher eng spezialisierter Bereich der Systemprogrammierung und hat in Russland mit Sicherheit keine gro√üe Community.  Ich hoffe, dass das Material in diesem Artikel denjenigen hilft, die die Hardwarevirtualisierung und die damit verbundenen M√∂glichkeiten entdecken m√∂chten.  Wie eingangs gesagt, m√∂chte ich nur den praktischen Aspekt betrachten, ohne in die Theorie einzutauchen. Daher wird davon ausgegangen, dass der Leser mit der x86-64-Architektur vertraut ist und zumindest eine allgemeine Vorstellung von VMX-Mechanismen hat.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellen f√ºr den Artikel</a> . <br><br>  Beginnen wir mit der Festlegung von Zielen f√ºr den Hypervisor: <br><a name="habracut"></a><br><ol><li>  Wird ausgef√ºhrt, bevor das Gastbetriebssystem geladen wird </li><li>  Unterst√ºtzung f√ºr einen logischen Prozessor und 4 GB physischen Gastspeicher </li><li>  Stellen Sie sicher, dass das Gastbetriebssystem ordnungsgem√§√ü mit Ger√§ten funktioniert, die im physischen Speicherbereich projiziert werden </li><li>  VMexits-Verarbeitung </li><li>  Das Gastbetriebssystem der ersten Befehle sollte in einer virtuellen Umgebung ausgef√ºhrt werden. </li><li>  Ausgabe von Debugging-Informationen √ºber den COM-Port (universelle Methode, einfach zu implementieren) </li></ol><br>  Als Gastbetriebssystem habe ich Windows 7 x32 gew√§hlt, in dem die folgenden Einschr√§nkungen festgelegt wurden: <br><br><ul><li>  Es ist nur ein CPU-Kern beteiligt </li><li>  Die PAE-Option ist deaktiviert, sodass ein 32-Bit-Betriebssystem mehr als 4 GB physischen Speicher verwenden kann </li><li>  BIOS im Legacy-Modus, UEFI deaktiviert </li></ul><br><h3>  Beschreibung des Bootloaders </h3><br>  Damit der Hypervisor beim Starten des PCs gestartet werden kann, habe ich den einfachsten Weg gew√§hlt, n√§mlich meinen Bootloader im MBR-Sektor der Festplatte aufzuschreiben, auf der das Gastbetriebssystem installiert ist.  Es war auch notwendig, den Hypervisor-Code irgendwo auf der Festplatte zu platzieren.  In meinem Fall liest der urspr√ºngliche MBR den Bootloader ab dem Sektor 2048, der einen bedingt freien Bereich zum Schreiben in (2047 * 512) Kb bietet.  Dies ist mehr als genug, um alle Komponenten eines Hypervisors aufzunehmen. <br><br>  Unten sehen Sie das Layout des Hypervisors auf der Festplatte. Alle Werte sind in Sektoren festgelegt. <br><br><img src="https://habrastorage.org/webt/ek/tv/_z/ektv_zcfq5gcq4bslygiyc2lbqc.jpeg"><br><br>  Der Download-Vorgang ist wie folgt: <br><br><img src="https://habrastorage.org/webt/ba/ej/ae/baejaecukny9u7mi6b8udh9crfo.jpeg"><br><ol><li>  loader.mbr liest den Loader-Code loader.main von der Festplatte und √ºbertr√§gt die Kontrolle auf diese. </li><li>  loader.main wechselt in den Long-Modus und liest dann die Tabelle der geladenen loader.table-Elemente, auf deren Grundlage das weitere Laden der Hypervisor-Komponenten in den Speicher durchgef√ºhrt wird. </li><li>  Nachdem der Bootloader die Arbeit im physischen Speicher unter der Adresse 0x100000000 beendet hat, gibt es einen Hypervisor-Code. Diese Adresse wurde so gew√§hlt, dass der Bereich von 0 bis 0xFFFFFFFF f√ºr die direkte Zuordnung zum physischen Gastspeicher verwendet werden kann. </li><li>  Das urspr√ºngliche Windows-Netzwerk wird unter der physischen Adresse 0x7C00 gestartet. </li></ol><br>  Ich m√∂chte darauf aufmerksam machen, dass der Bootloader nach dem Wechsel in den Langmodus die BIOS-Dienste nicht mehr f√ºr die Arbeit mit physischen Festplatten verwenden kann. Daher habe ich die "Advance Host Controller Interface" zum Lesen der Festplatte verwendet. <br><br>  Weitere Details dazu finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h3>  Hypervisor-Jobbeschreibung </h3><br>  Nachdem der Hypervisor die Kontrolle erhalten hat, besteht seine erste Aufgabe darin, die Umgebung zu initialisieren, in der er arbeiten muss. Dazu werden die Funktionen nacheinander aufgerufen: <br><br><ul><li>  <b>InitLongModeGdt ()</b> - <b>Erstellt</b> und l√§dt eine Tabelle mit 4 Deskriptoren: NULL, CS64, DS64, TSS64 </li><li>  <b>InitLongModeIdt (isr_vector)</b> - initialisiert die ersten 32 Interrupt-Vektoren durch einen gemeinsamen Handler bzw. dessen Stub <br></li><li>  <b>InitLongModeTSS ()</b> - Initialisiert das <b>Taskstatussegment</b> </li><li>  <b>InitLongModePages ()</b> - Initialisierung von Paging: <br><br>  [0x00000000 - 0xFFFFFFFF] - Seitengr√∂√üe 2 MB, Cache deaktivieren; <br>  [0x100000000 - 0x13FFFFFFF] - Seitengr√∂√üe 2 MB, Cache-R√ºckschreiben, globale Seiten; <br>  [0x140000000 - n] - nicht vorhanden; </li><li>  <b>InitControlAndSegmenRegs ()</b> - Segmentregister neu laden </li></ul><br>  Als N√§chstes m√ºssen Sie sicherstellen, dass der Prozessor VMX unterst√ºtzt. Die √úberpr√ºfung wird von der Funktion <b>CheckVMXConditions () durchgef√ºhrt</b> : <br><br><ul><li>  CPUID.1: ECX.VMX [Bit 5] muss auf 1 gesetzt sein </li><li>  Im MSR-Register IA32_FEATURE_CONTROL muss Bit 2 gesetzt sein - aktiviert VMXON au√üerhalb des SMX-Betriebs und Bit 0 - Lock (relevant beim Debuggen in Bochs) </li></ul><br>  Wenn alles in Ordnung ist und der Hypervisor auf einem Prozessor ausgef√ºhrt wird, der die Hardwarevirtualisierung unterst√ºtzt, fahren Sie mit der anf√§nglichen Initialisierung von VMX fort. <b>Weitere Informationen finden Sie in der</b> Funktion <b>InitVMX ()</b> : <br><br><ul><li>  Erstellt Speicherbereiche VMXON und VMCS (Virtual Data Control Data Structures) mit einer Gr√∂√üe von 4096 Byte.  Die VMCS-Revisionskennung aus MSR IA32_VMX_BASIC wird in den ersten 31 Bits jedes Bereichs aufgezeichnet. </li><li>  Es wird gepr√ºft, ob in den Systemregistern CR0 und CR4 alle Bits gem√§√ü den Anforderungen von VMX gesetzt sind. </li><li>  Der logische Prozessor wird durch den Befehl VMXON (die physikalische Adresse der VMXON-Region als Argument) in den VMX-Root-Modus versetzt. </li><li>  Der Befehl VMCLEAR (VMCS) setzt den Startstatus von VMCS auf Clear, und der Befehl setzt implementierungsspezifische Werte auf VMCS. </li><li>  Der Befehl VMPTRLD (VMCS) l√§dt die aktuelle VMCS-Adresse, die als Argument √ºbergeben wurde, in den aktuellen VMCS-Zeiger. </li></ul><br>  Die Ausf√ºhrung des Gastbetriebssystems beginnt im Real-Modus ab der Adresse 0x7C00, an der, wie wir uns erinnern, der Loader.main-Loader win7.mbr platziert.  Um eine virtuelle Umgebung neu zu erstellen, die mit der identisch ist, in der mbr normalerweise ausgef√ºhrt wird, wird die Funktion <b>InitGuestRegisterState () aufgerufen, mit</b> der die vmx-Nicht-Root-Register wie folgt festgelegt werden: <br><br><pre><code class="hljs pgsql">CR0 = <span class="hljs-number"><span class="hljs-number">0x10</span></span> CR3 = <span class="hljs-number"><span class="hljs-number">0</span></span> CR4 = <span class="hljs-number"><span class="hljs-number">0</span></span> DR7 = <span class="hljs-number"><span class="hljs-number">0</span></span> RSP = <span class="hljs-number"><span class="hljs-number">0xFFD6</span></span> RIP = <span class="hljs-number"><span class="hljs-number">0x7C00</span></span> RFLAGS = <span class="hljs-number"><span class="hljs-number">0x82</span></span> ES.base = <span class="hljs-number"><span class="hljs-number">0</span></span> CS.base = <span class="hljs-number"><span class="hljs-number">0</span></span> SS.base = <span class="hljs-number"><span class="hljs-number">0</span></span> DS.base = <span class="hljs-number"><span class="hljs-number">0</span></span> FS.base = <span class="hljs-number"><span class="hljs-number">0</span></span> GS.base = <span class="hljs-number"><span class="hljs-number">0</span></span> LDTR.base = <span class="hljs-number"><span class="hljs-number">0</span></span> TR.base = <span class="hljs-number"><span class="hljs-number">0</span></span> ES.<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> = <span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span> CS.<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> = <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span> SS.<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> = <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span> DS.<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> = <span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span> FS.<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> = <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span> GS.<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> = <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span> LDTR.<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> = <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span> TR.<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> = <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span> ES.<span class="hljs-keyword"><span class="hljs-keyword">access</span></span> rights = <span class="hljs-number"><span class="hljs-number">0xF093</span></span> CS.<span class="hljs-keyword"><span class="hljs-keyword">access</span></span> rights = <span class="hljs-number"><span class="hljs-number">0x93</span></span> SS.<span class="hljs-keyword"><span class="hljs-keyword">access</span></span> rights = <span class="hljs-number"><span class="hljs-number">0x93</span></span> DS.<span class="hljs-keyword"><span class="hljs-keyword">access</span></span> rights = <span class="hljs-number"><span class="hljs-number">0xF093</span></span> FS.<span class="hljs-keyword"><span class="hljs-keyword">access</span></span> rights = <span class="hljs-number"><span class="hljs-number">0x93</span></span> GS.<span class="hljs-keyword"><span class="hljs-keyword">access</span></span> rights = <span class="hljs-number"><span class="hljs-number">0x93</span></span> LDTR.<span class="hljs-keyword"><span class="hljs-keyword">access</span></span> rights = <span class="hljs-number"><span class="hljs-number">0x82</span></span> TR.<span class="hljs-keyword"><span class="hljs-keyword">access</span></span> rights = <span class="hljs-number"><span class="hljs-number">0x8B</span></span> ES.selector = <span class="hljs-number"><span class="hljs-number">0</span></span> CS.selector = <span class="hljs-number"><span class="hljs-number">0</span></span> SS.selector = <span class="hljs-number"><span class="hljs-number">0</span></span> DS.selector = <span class="hljs-number"><span class="hljs-number">0</span></span> FS.selector = <span class="hljs-number"><span class="hljs-number">0</span></span> GS.selector = <span class="hljs-number"><span class="hljs-number">0</span></span> LDTR.selector = <span class="hljs-number"><span class="hljs-number">0</span></span> TR.selector = <span class="hljs-number"><span class="hljs-number">0</span></span> GDTR.base = <span class="hljs-number"><span class="hljs-number">0</span></span> IDTR.base = <span class="hljs-number"><span class="hljs-number">0</span></span> GDTR.<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> IDTR.<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> = <span class="hljs-number"><span class="hljs-number">0x3FF</span></span></code> </pre> <br>  Es ist zu beachten, dass das Grenzfeld des Deskriptor-Cache f√ºr die Segmentregister DS und ES 0xFFFFFFFF ist.  Dies ist ein Beispiel f√ºr die Verwendung des unwirklichen Modus - eine x86-Prozessorfunktion, mit der Sie die Begrenzung von Segmenten im realen Modus umgehen k√∂nnen.  Mehr dazu lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Im VMX-Nicht-Root-Modus kann es vorkommen, dass das Gastbetriebssystem im VMX-Root-Modus die Steuerung an den Host zur√ºckgeben muss.  In diesem Fall tritt ein VM-Exit auf, bei dem der aktuelle Status von vmx non-root gespeichert und vmx-root geladen wird.  Initialisierung VMX-root l√§uft <b>InitHostStateArea ()</b> Funktion, die den Wert der folgenden Register setzt: <br><br><pre> <code class="hljs cs">CR0 = <span class="hljs-number"><span class="hljs-number">0x80000039</span></span> CR3 = PML4_addr CR4 = <span class="hljs-number"><span class="hljs-number">0x420A1</span></span> RSP =     STACK64 RIP =   VMEXIT_handler ES.selector = <span class="hljs-number"><span class="hljs-number">0x10</span></span> CS.selector = <span class="hljs-number"><span class="hljs-number">0x08</span></span> SS.selector = <span class="hljs-number"><span class="hljs-number">0x10</span></span> DS.selector = <span class="hljs-number"><span class="hljs-number">0x10</span></span> FS.selector = <span class="hljs-number"><span class="hljs-number">0x10</span></span> GS.selector = <span class="hljs-number"><span class="hljs-number">0x10</span></span> TR.selector = <span class="hljs-number"><span class="hljs-number">0x18</span></span> TR.<span class="hljs-keyword"><span class="hljs-keyword">base</span></span> =  TSS GDTR.<span class="hljs-keyword"><span class="hljs-keyword">base</span></span> =  GDT64 IDTR.<span class="hljs-keyword"><span class="hljs-keyword">base</span></span> =  IDTR</code> </pre> <br>  Als n√§chstes wird die Erstellung des physischen <b>Gastadressraums durchgef√ºhrt (InitEPT ()</b> -Funktion).  Dies ist einer der wichtigsten Momente beim Erstellen eines Hypervisors, da eine falsch eingestellte Gr√∂√üe oder ein falsch eingestellter Typ an einem der Speicherorte zu Fehlern f√ºhren kann, die sich m√∂glicherweise nicht sofort manifestieren, aber mit hoher Wahrscheinlichkeit zu unerwarteten Bremsen oder Einfrierungen des Gastbetriebssystems f√ºhren.  Im Allgemeinen gibt es hier wenig Angenehmes und es ist besser, der Abstimmung des Ged√§chtnisses gen√ºgend Aufmerksamkeit zu schenken. <br><br>  Das folgende Bild zeigt das Modell des physischen Adressraums des Gastes: <br><br><img src="https://habrastorage.org/webt/lm/7b/ll/lm7bllv6hrh9kjv4aoopbzapz1q.jpeg"><br><br>  Also, was wir hier sehen: <br><br><ul><li>  [0 - 0xFFFFFFFF] der gesamte Bereich des Gastadressraums.  Standardtyp: zur√ºckschreiben </li><li>  [0xA0000 - 0xBFFFFF] - Video-RAM.  Typ: nicht zwischenspeicherbar </li><li>  [0xBA647000 - 0xFFFFFFFF] - Ger√§te-RAM.  Typ: nicht zwischenspeicherbar </li><li>  [0x0000000 - 0xCFFFFFFF] - Video-RAM.  Typ: Schreibkombination </li><li>  [0xD0000000 - 0xD1FFFFFF] - Video-RAM.  Typ: Schreibkombination </li><li>  [0xFA000000 - 0xFAFFFFFF] - Video-RAM.  Typ: Schreibkombination </li></ul><br>  Ich habe die Informationen zum Erstellen solcher Bereiche aus dem Dienstprogramm RAMMap (Registerkarte Physikalische Bereiche) √ºbernommen und auch die Daten aus dem Windows-Ger√§te-Manager verwendet.  Nat√ºrlich unterscheiden sich die Adressbereiche auf einem anderen PC wahrscheinlich.  Der Gastspeichertyp wird in meiner Implementierung nur durch den in den EPT-Tabellen angegebenen Wert bestimmt.  Es ist einfach, aber nicht ganz korrekt, und im Allgemeinen sollte die Art des Speichers ber√ºcksichtigt werden, den das Gastbetriebssystem in seiner Seitenadressierung installieren m√∂chte. <br><br>  Nachdem die Erstellung des <b>Gastadressraums</b> abgeschlossen ist, k√∂nnen Sie mit den Feldeinstellungen f√ºr die VM-Ausf√ºhrungssteuerung <b>fortfahren (</b> Funktion <b>InitExecutionControlFields ()</b> ).  Dies ist eine ziemlich gro√üe Auswahl an Optionen, mit denen Sie die Betriebsbedingungen des Gastbetriebssystems im VMX-Nicht-Root-Modus festlegen k√∂nnen.  Sie k√∂nnen beispielsweise Anrufe an Eingabe- / Ausgabeports verfolgen oder √Ñnderungen in MSR-Registern √ºberwachen.  In unserem Fall verwende ich jedoch nur die M√∂glichkeit, die Einstellung bestimmter Bits im CR0-Register zu steuern.  Tatsache ist, dass 30 (CD) und 29 (NW) Bits sowohl f√ºr den vmx-Nicht-Root- als auch f√ºr den vmx-Root-Modus gleich sind. Wenn das Gastbetriebssystem diese Bits auf 1 setzt, wirkt sich dies negativ auf die Leistung aus. <br><br>  Der Konfigurationsprozess des Hypervisors ist fast abgeschlossen. Es bleibt nur die Kontrolle √ºber den √úbergang zum Gastmodus vmx non-root und die R√ºckkehr zum Hostmodus vmx root.  Einstellungen werden in den Funktionen vorgenommen: <br><br>  <b>InitVMEntryControl ()</b> -Einstellungen f√ºr den √úbergang zu vmx non-root: <br><br><ul><li>  Laden Sie den Gast IA32_EFER </li><li>  Laden Sie den Gast IA32_PAT </li><li>  Gast-MSRs laden (IA32_MTRR_PHYSBASE0, IA32_MTRR_PHYSMASK0, IA32_MTRR_DEF_TYPE) </li></ul><br>  <b>InitVMExitControl ()</b> -Einstellungen f√ºr den Wechsel zu vmx root: <br><br><ul><li>  Host laden IA32_EFER; </li><li>  Gast speichern IA32_EFER; </li><li>  Host laden IA32_PAT; </li><li>  Gast speichern IA32_PAT; </li><li>  Host.CS.L = 1, Host.IA32_EFER.LME = 1, Host.IA32_EFER.LMA = 1; </li><li>  Gast-MSRs speichern (IA32_MTRR_PHYSBASE0, IA32_MTRR_PHYSMASK0, IA32_MTRR_DEF_TYPE); </li><li>  Host-MSRs laden (IA32_MTRR_PHYSBASE0, IA32_MTRR_PHYSMASK0, IA32_MTRR_DEF_TYPE); </li></ul><br>  <b>Nachdem</b> alle Einstellungen abgeschlossen sind, <b>versetzt die</b> Funktion <b>VMLaunch () den</b> Prozessor in den VMX-Nicht-Root-Modus und das Gastbetriebssystem wird ausgef√ºhrt.  Wie bereits erw√§hnt, k√∂nnen Bedingungen in den Einstellungen f√ºr die VM-Ausf√ºhrungssteuerung festgelegt werden. In diesem Fall gibt der Hypervisor die Steuerung im VMX-Root-Modus an sich selbst zur√ºck.  In meinem einfachen Beispiel gebe ich dem Gastbetriebssystem vollst√§ndige Handlungsfreiheit. In einigen F√§llen muss der Hypervisor jedoch noch eingreifen und das Betriebssystem anpassen. <br><br><ol><li>  Wenn das Gastbetriebssystem versucht, die CD- und NW-Bits im CR0-Register zu √§ndern, wird der VM-Exit-Handler verwendet <br>  korrigiert die in CR0 aufgezeichneten Daten.  Das CR0-Leseschattenfeld wird ebenfalls so ge√§ndert, dass das Gastbetriebssystem beim Lesen von CR0 den aufgezeichneten Wert empf√§ngt. </li><li>  Ausf√ºhren des Befehls xsetbv.  Dieser Befehl ruft unabh√§ngig von den Einstellungen immer VM Exit auf, daher habe ich gerade seine Ausf√ºhrung im VMX-Root-Modus hinzugef√ºgt. </li><li>  Ausf√ºhren des Befehls cupid.  Dieser Befehl ruft auch einen bedingungslosen VM-Exit auf.  Aber ich habe eine kleine √Ñnderung an seinem Handler vorgenommen.  Wenn die Werte im eax-Argument 0x80000002 - 0x80000004 sind, gibt cpuid nicht den Namen der Prozessormarke zur√ºck, sondern die Zeile: <i>VMX Study Core :)</i> Das Ergebnis ist im Screenshot zu sehen: </li></ol><br><img src="https://habrastorage.org/webt/gx/br/cg/gxbrcgcfoiara6ivchp_lm0hgja.jpeg"><br><br><h3>  Zusammenfassung </h3><br>  Der als Beispiel f√ºr den Artikel geschriebene Hypervisor kann den stabilen Betrieb des Gastbetriebssystems durchaus unterst√ºtzen, obwohl es sich nat√ºrlich nicht um eine vollst√§ndige L√∂sung handelt.  Intel VT-d wird nicht verwendet, es wird nur ein logischer Prozessor unterst√ºtzt, es gibt keine Kontrolle √ºber Unterbrechungen und den Betrieb von Peripherieger√§ten.  Im Allgemeinen habe ich fast nichts aus den umfangreichen Tools verwendet, die Intel f√ºr die Hardwarevirtualisierung bereitstellt.  Wenn die Community jedoch interessiert ist, werde ich weiterhin √ºber Intel VMX schreiben, zumal es etwas zu schreiben gibt. <br><br>  Ja, ich h√§tte fast vergessen, dass es praktisch ist, den Hypervisor und seine Komponenten mit Bochs zu debuggen.  Zun√§chst ist es ein unverzichtbares Werkzeug.  Leider unterscheidet sich das Herunterladen eines Hypervisors in Bochs vom Herunterladen auf einen physischen PC.  Einmal habe ich eine spezielle Versammlung zusammengestellt, um diesen Prozess zu vereinfachen. Ich werde versuchen, die Quellen in Ordnung zu bringen und sie in naher Zukunft mit dem Projekt zusammenzustellen. <br><br>  Das ist alles.  Vielen Dank f√ºr Ihre Aufmerksamkeit. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de419065/">https://habr.com/ru/post/de419065/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de419051/index.html">Wie Flant Anf√§ngern hilft</a></li>
<li><a href="../de419053/index.html">Testen der Adaptec RAID Cache-Technologie</a></li>
<li><a href="../de419055/index.html">In der Stringtheorie kommt man mit deutlich weniger Universen aus.</a></li>
<li><a href="../de419061/index.html">Was ist neu in GoLand 2018.2?</a></li>
<li><a href="../de419063/index.html">Automatisierung des Abrufs von Informationen von USRLE mit Freepascal</a></li>
<li><a href="../de419067/index.html">Wie man personenbezogene Daten verkauft oder warum es schwierig ist, Informationen mit einem Preisschild zu versehen</a></li>
<li><a href="../de419069/index.html">Die globale Erw√§rmung wird unsere Welt gr√ºner machen, aber freuen Sie sich nicht</a></li>
<li><a href="../de419071/index.html">Nach dem TP-Link-Hack</a></li>
<li><a href="../de419075/index.html">Zur Bildung von Sequenzen in der Collatz-Hypothese (3n + 1)</a></li>
<li><a href="../de419077/index.html">Lokalisierung von Anwendungen in iOS. Teil 1. Was haben wir?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>