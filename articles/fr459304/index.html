<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌉 🖐🏾 👵🏼 Contournement angulaire de l'écueil et gain de temps 🖍️ 💃 👸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Avec Angular, vous pouvez tout faire. Ou presque tout. Mais parfois, cette insidieuse «presque» conduit au fait que le développeur perd du temps en cr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Contournement angulaire de l'écueil et gain de temps</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/459304/">  Avec Angular, vous pouvez tout faire.  Ou presque tout.  Mais parfois, cette insidieuse «presque» conduit au fait que le développeur perd du temps en créant des solutions de contournement, ou en essayant de comprendre pourquoi quelque chose se passe, ou pourquoi quelque chose ne fonctionne pas comme prévu. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/bl/sj/vq/blsjvqaqs4fhtnqmscwlw7lx0zs.jpeg"></a> <br><br>  L'auteur de l'article que nous traduisons aujourd'hui dit qu'il souhaite partager des conseils qui aideront les développeurs Angular à gagner du temps.  Il va parler des pièges d'Angular, qu'il (et pas seulement lui) a eu la chance de rencontrer. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">N ° 1.</font>  <font color="#3AC1EF">La directive personnalisée que vous avez appliquée ne fonctionne pas</font> </h2><br>  Donc, vous avez trouvé une belle directive angulaire tierce et avez décidé de l'utiliser avec des éléments standard dans le modèle angulaire.  Super!  Essayons de faire ceci: <br><br><pre><code class="javascript hljs">&lt;span awesomeTooltip=<span class="hljs-string"><span class="hljs-string">"'Tooltip text'"</span></span>&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  Vous démarrez l'application ... Et rien ne se passe.  Vous, comme tout programmeur expérimenté, consultez la console Chrome Developer Tools.  Et vous n'y voyez rien.  La directive ne fonctionne pas et Angular est silencieux. <br><br>  Ensuite, une tête brillante de votre équipe décide de placer la directive entre crochets. <br><br><pre> <code class="javascript hljs">&lt;span [awesomeTooltip]=<span class="hljs-string"><span class="hljs-string">"'Tooltip text'"</span></span>&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  Après cela, après avoir perdu un peu de temps, nous voyons ce qui suit dans la console. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/532/4aa/95f/5324aa95f7aa2d0d1a20e74f93953eb1.png"></div><br>  <i><font color="#999999">Voici la chose: nous avons juste oublié d'importer le module avec la directive</font></i> <br><br>  Maintenant, la cause du problème est assez évidente: nous avons juste oublié d'importer le module directive dans le module d'application Angular. <br>  Cela conduit à une règle importante: ne jamais utiliser de directives sans crochets. <br><br>  Vous pouvez expérimenter avec des directives <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h2>  <font color="#3AC1EF">N ° 2.</font>  <font color="#3AC1EF">ViewChild renvoie undefined</font> </h2><br>  Supposons que vous ayez créé un lien vers un élément d'entrée de texte décrit dans un modèle angulaire. <br><br><pre> <code class="javascript hljs">&lt;input type=<span class="hljs-string"><span class="hljs-string">"text"</span></span> name=<span class="hljs-string"><span class="hljs-string">"fname"</span></span> #inputTag&gt;</code> </pre> <br>  Vous allez, en utilisant la fonction RxJS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fromEvent</a> , créer un flux dans lequel tombera ce qui est entré dans le champ.  Pour ce faire, vous avez besoin d'un lien vers le champ de saisie, qui peut être obtenu à l'aide du décorateur Angular <code>ViewChild</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AfterViewInit</span></span></span><span class="hljs-class"> </span></span>{    @ViewChild(<span class="hljs-string"><span class="hljs-string">'inputTag'</span></span>) inputTag: ElementRef;    ngAfterViewInit(){        <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> input$ = fromEvent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputTag.nativeElement, <span class="hljs-string"><span class="hljs-string">'keyUp'</span></span>)    } ...   }</code> </pre> <br>  Ici, en utilisant la fonction RxJS <code>fromEvent</code> , nous créons un flux dans lequel les données entrées dans le champ tomberont. <br>  Testez ce code. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f0/504/558/4f0504558e9daf73a87d78da7f00fb04.png"></div><br>  <i><font color="#999999">Erreur</font></i> <br><br>  Qu'est-il arrivé? <br><br>  En fait, la règle suivante s'applique ici: si <code>ViewChild</code> retourne <code>undefined</code> , recherchez <code>*ngIf</code> dans le modèle. <br><br><pre> <code class="javascript hljs">&lt;div *ngIf=<span class="hljs-string"><span class="hljs-string">"someCondition"</span></span>&gt;    <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">input</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"text"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"fname"</span></span></span></span><span class="xml"><span class="hljs-tag"> #</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">inputTag</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  Ici, il est le coupable du problème. <br><br>  De plus, vérifiez le modèle pour d'autres directives structurelles ou <code>ng-template</code> au <code>ng-template</code> dessus de l'élément problème. <br>  Considérez les solutions possibles à ce problème. <br><br><h3>  <font color="#3AC1EF">▍Variant de résoudre le problème №1</font> </h3><br>  Vous pouvez simplement masquer l'élément de modèle si vous n'en avez pas besoin.  Dans ce cas, l'élément continuera toujours d'exister et <code>ViewChild</code> pourra lui renvoyer un lien dans le hook <code>ngAfterViewInit</code> . <br><br><pre> <code class="javascript hljs">&lt;div [hidden]=<span class="hljs-string"><span class="hljs-string">"!someCondition"</span></span>&gt;    <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">input</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"text"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"fname"</span></span></span></span><span class="xml"><span class="hljs-tag"> #</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">inputTag</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍Variant de résoudre le problème №2</font> </h3><br>  Une autre façon de résoudre ce problème consiste à utiliser des setters. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{   @ViewChild(<span class="hljs-string"><span class="hljs-string">'inputTag'</span></span>) set inputTag(input: ElementRef|<span class="hljs-literal"><span class="hljs-literal">null</span></span>) {    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!input) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.doSomething(input);  }  doSomething(input) {    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> input$ = keysfromEvent(input.nativeElement, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>);    ...  } }</code> </pre> <br>  Ici, dès que Angular attribue une valeur spécifique à la propriété <code>inputTag</code> , nous créons un flux à partir des données entrées dans le champ de saisie. <br><br>  Voici quelques ressources utiles liées à ce problème: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ici,</a> vous pouvez lire que les résultats de <code>ViewChild</code> dans Angular 8 peuvent être statiques et dynamiques. </li><li>  Si vous éprouvez des difficultés à travailler avec les RxJ, consultez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce</a> cours vidéo. </li></ul><br><h2>  <font color="#3AC1EF">Numéro 3.</font>  <font color="#3AC1EF">Exécution de code lors de la mise à jour de la liste générée avec * ngFor (après que les éléments soient apparus dans le DOM)</font> </h2><br>  Supposons que vous ayez une directive personnalisée intéressante pour organiser les listes déroulantes.  Vous allez l'appliquer à une liste créée à l'aide de la <code>*ngFor</code> Angular <code>*ngFor</code> . <br><br><pre> <code class="javascript hljs">&lt;div *ngFor=<span class="hljs-string"><span class="hljs-string">"let item of itemsList; let i = index;"</span></span>     [customScroll]     &gt;  <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag"> *</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">ngFor</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"let item of items"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"list-item"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{{item}}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>   &lt;<span class="hljs-regexp"><span class="hljs-regexp">/div&gt;</span></span></code> </pre> <br>  Habituellement, dans de tels cas, lors de la mise à jour de la liste, vous devez appeler quelque chose comme <code>scrollDirective.update</code> pour configurer le comportement de défilement, en tenant compte des modifications qui se sont produites dans la liste. <br><br>  Il peut sembler que cela peut être fait en utilisant le hook <code>ngOnChanges</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnChanges</span></span></span><span class="hljs-class"> </span></span>{  @Input() itemsList = [];   @ViewChild(CustomScrollDirective) scroll: CustomScrollDirective;  ngOnChanges(changes) {    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (changes.itemsList) {      <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scroll.update();    }  } ... }</code> </pre> <br>  Certes, nous sommes ici face à un problème.  Le hook est appelé avant que le navigateur affiche la liste mise à jour.  Par conséquent, le recalcul des paramètres de directive pour faire défiler la liste est effectué de manière incorrecte. <br><br>  Comment passer un appel juste après que <code>*ngFor</code> fini de fonctionner? <br><br>  Vous pouvez le faire en suivant ces 3 étapes simples: <br><br><h3>  <font color="#3AC1EF">▍Etape numéro 1</font> </h3><br>  Placez les liens vers les éléments où <code>*ngFor</code> ( <code>#listItems</code> ) est <code>#listItems</code> . <br><br><pre> <code class="javascript hljs">&lt;div [customScroll]&gt;    <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag"> *</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">ngFor</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"let item of items"</span></span></span></span><span class="xml"><span class="hljs-tag"> #</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">listItems</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{{item}}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;<span class="hljs-regexp"><span class="hljs-regexp">/div&gt;</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍Étape numéro 2</font> </h3><br>  Obtenez une liste de ces éléments à l'aide du décorateur Angular <code>ViewChildren</code> .  Il renvoie une entité de type <code>QueryList</code> . <br><br><h3>  <font color="#3AC1EF">▍Étape numéro 3</font> </h3><br>  La classe <code>QueryList</code> possède une propriété de <a href="">modifications en</a> lecture seule qui <code>QueryList</code> événements chaque fois que la liste change. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AfterViewInit</span></span></span><span class="hljs-class"> </span></span>{  @Input() itemsList = [];   @ViewChild(CustomScrollDirective) scroll: CustomScrollDirective;  @ViewChildren(<span class="hljs-string"><span class="hljs-string">'listItems'</span></span>) listItems: QueryList&lt;any&gt;;  private sub: Subscription;   ngAfterViewInit() {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sub = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listItems.changes.subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scroll.update())  } ... }</code> </pre> <br>  Maintenant, le problème est résolu.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ici,</a> vous pouvez expérimenter avec l'exemple correspondant. <br><br><h2>  <font color="#3AC1EF">Numéro 4.</font>  <font color="#3AC1EF">Problèmes avec ActivatedRoute.queryParam qui se produisent lorsque des requêtes peuvent être exécutées sans paramètres</font> </h2><br>  Le code suivant nous aidera à comprendre l'essence de ce problème. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// app-routing.module.ts const routes: Routes = [    {path: '', redirectTo: '/home', pathMatch: 'full'},    {path: 'home', component: HomeComponent},  ];   @NgModule({    imports: [RouterModule.forRoot(routes)], //  #1    exports: [RouterModule]  })  export class AppRoutingModule { }    //app.module.ts  @NgModule({    ...    bootstrap: [AppComponent] //  #2  })  export class AppModule { }   // app.component.html  &lt;router-outlet&gt;&lt;/router-outlet&gt; //  #3    // app.component.ts  export class AppComponent implements OnInit {    title = 'QueryTest';     constructor(private route: ActivatedRoute) { }     ngOnInit() {      this.route.queryParams          .subscribe(params =&gt; {            console.log('saveToken', params); //  #4          });    }  }</span></span></code> </pre> <br>  Certains fragments de ce code sont des commentaires comme le <code> #x</code> .  Considérez-les: <br><br><ol><li>  Dans le module principal de l'application, nous avons défini les routes et y <code>RouterModule</code> ajouté le <code>RouterModule</code> .  Les itinéraires sont configurés de sorte que si un itinéraire n'est pas fourni dans l'URL, nous redirige l'utilisateur vers la page <code>/home</code> . </li><li>  En tant que composant à télécharger, nous <code>AppComponent</code> dans le module principal <code>AppComponent</code> . </li><li>  <code>AppComponent</code> utilise <code>&lt;router-outlet&gt;</code> pour sortir les composants de route appropriés. </li><li>  Maintenant, la chose la plus importante.  Nous devons obtenir <code>queryParams</code> pour l'itinéraire à partir de l'URL </li></ol><br>  Supposons que nous ayons l'URL suivante: <br><br><pre> <code class="javascript hljs">https:<span class="hljs-comment"><span class="hljs-comment">//localhost:4400/home?accessToken=someTokenSequence</span></span></code> </pre> <br>  Dans ce cas, <code>queryParams</code> ressemblera à ceci: <br><br><pre> <code class="javascript hljs">{<span class="hljs-attr"><span class="hljs-attr">accessToken</span></span>: <span class="hljs-string"><span class="hljs-string">'someTokenSequence'</span></span>}</code> </pre> <br>  Regardons le travail de tout cela dans le navigateur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/29f/aef/ae5/29faefae56d8e01e314cb6eab9fae6dc.png"></div><br>  <i><font color="#999999">Test d'une application qui implémente un système de routage</font></i> <br><br>  Ici, vous pouvez avoir une question sur l'essence du problème.  Nous avons les paramètres, tout fonctionne comme prévu ... <br><br>  Jetez un œil à la capture d'écran ci-dessus du navigateur et à ce qui s'affiche dans la console.  Ici, vous pouvez voir que l'objet <code>queryParams</code> est émis deux fois.  Le premier objet est vide; il est émis lors du processus d'initialisation du routeur angulaire.  Ce n'est qu'après cela que nous obtenons un objet qui contient les paramètres de la demande (dans notre cas - <code>{accessToken: 'someTokenSequence'}</code> ). <br><br>  Le problème est que s'il n'y a pas de paramètres de requête dans l'URL, le routeur ne renverra rien.  C'est-à-dire qu'après avoir émis le premier objet vide, le deuxième objet, également vide, ce qui pourrait indiquer l'absence de paramètres, ne sera pas émis. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e16/1b7/8be/e161b78be5051b1ee9f9ca1ec2c9d31a.png"></div><br>  <i><font color="#999999">Le deuxième objet lors de l'exécution d'une demande sans paramètres n'est pas émis</font></i> <br><br>  Par conséquent, il s'avère que si le code attend un deuxième objet à partir duquel il peut recevoir des données de demande, il ne sera pas lancé s'il n'y avait aucun paramètre de demande dans l'URL. <br><br>  Comment résoudre ce problème?  Ici, les RxJ peuvent nous aider.  Nous allons créer deux objets observables basés sur <code>ActivatedRoute.queryParams</code> .  Comme d'habitude - envisagez une solution étape par étape au problème. <br><br><h3>  <font color="#3AC1EF">▍Etape numéro 1</font> </h3><br>  Le premier objet observable, <code>paramsInUrl$</code> , <code>paramsInUrl$</code> données si <code>queryParams</code> pas vide: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnInit</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private route: ActivatedRoute,                private locationService: Location) {    }    ngOnInit() {             <span class="hljs-comment"><span class="hljs-comment">//            //              const paramsInUrl$ = this.route.queryParams.pipe(            filter(params =&gt; Object.keys(params).length &gt; 0)        );     ...    } }</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍Étape numéro 2</font> </h3><br>  Le deuxième objet observable, <code>noParamsInUrl$</code> , <code>noParamsInUrl$</code> valeur vide uniquement si aucun paramètre de requête n'a été trouvé dans l'URL: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnInit</span></span></span><span class="hljs-class"> </span></span>{    title = <span class="hljs-string"><span class="hljs-string">'QueryTest'</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private route: ActivatedRoute,                private locationService: Location) {    }    ngOnInit() {                 ...        <span class="hljs-comment"><span class="hljs-comment">//   ,     ,   URL        //             const noParamsInUrl$ = this.route.queryParams.pipe(            filter(() =&gt; !this.locationService.path().includes('?')),            map(() =&gt; ({}))        );            ...    } }</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍Étape numéro 3</font> </h3><br>  Combinez maintenant les objets observés à l'aide de la fonction de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fusion</a> RxJS: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnInit</span></span></span><span class="hljs-class"> </span></span>{    title = <span class="hljs-string"><span class="hljs-string">'QueryTest'</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private route: ActivatedRoute,                private locationService: Location) {    }    ngOnInit() {             <span class="hljs-comment"><span class="hljs-comment">//            //              const paramsInUrl$ = this.route.queryParams.pipe(            filter(params =&gt; Object.keys(params).length &gt; 0)        );        //   ,     ,   URL        //             const noParamsInUrl$ = this.route.queryParams.pipe(            filter(() =&gt; !this.locationService.path().includes('?')),            map(() =&gt; ({}))        );        const params$ = merge(paramsInUrl$, noParamsInUrl$);        params$.subscribe(params =&gt; {            console.log('saveToken', params);        });    } }</span></span></code> </pre> <br>  Désormais, l'objet <code>param$</code> observé <code>param$</code> valeur <code>param$</code> seule fois, que quelque chose soit <code>queryParams</code> dans <code>queryParams</code> (un objet avec des paramètres de requête est <code>queryParams</code> ) ou non (un objet vide est <code>queryParams</code> ). <br><br>  Vous pouvez expérimenter avec ce code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h2>  <font color="#3AC1EF">N ° 5.</font>  <font color="#3AC1EF">Pages lentes</font> </h2><br>  Supposons que vous ayez un composant qui affiche des données formatées: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// home.component.html &lt;div class="wrapper" (mousemove)="mouseCoordinates = {x: $event.x, y: $event.y}"&gt;  &lt;div *ngFor="let item of items"&gt;     &lt;span&gt;{{formatItem(item)}}&lt;/span&gt;  &lt;/div&gt; &lt;/div&gt; {{mouseCoordinates | json}} // home.component.ts export class HomeComponent {    items = [1, 2, 3, 4, 5, 6];    mouseCoordinates = {};    formatItem(item) {              //           const t = Array.apply(null, Array(5)).map(() =&gt; 1);             console.log('formatItem');        return item + '%';    } }</span></span></code> </pre> <br>  Ce composant résout deux problèmes: <br><br><ol><li>  Il affiche un tableau d'éléments (on suppose que cette opération est effectuée une fois).  De plus, il formate ce qui est affiché en appelant la méthode <code>formatItem</code> . </li><li>  Il affiche les coordonnées de la souris (cette valeur sera évidemment mise à jour très souvent). </li></ol><br>  Vous ne vous attendez pas à ce que ce composant rencontre des problèmes de performances.  Par conséquent, exécutez un test de performance uniquement pour respecter toutes les formalités.  Cependant, certaines bizarreries apparaissent lors de ce test. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/015/97d/621/01597d6210a35f37a8030702c0b71753.png"></div><br>  <i><font color="#999999">Beaucoup d'appels formatItem et beaucoup de charge CPU</font></i> <br><br>  Quelle est la question?  Mais le fait est que lorsque Angular redessine le modèle, il appelle toutes les fonctions du modèle (dans notre cas, la fonction <code>formatItem</code> ).  Par conséquent, si des calculs lourds sont effectués dans les fonctions de modèle, cela met à rude épreuve le processeur et affecte la façon dont les utilisateurs perçoivent la page correspondante. <br><br>  Comment y remédier?  Il suffit d'effectuer à l'avance les calculs effectués dans <code>formatItem</code> , et d'afficher les données déjà prêtes sur la page. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// home.component.html &lt;div class="wrapper" (mousemove)="mouseCoordinates = {x: $event.x, y: $event.y}"&gt;  &lt;div *ngFor="let item of displayedItems"&gt;    &lt;span&gt;{{item}}&lt;/span&gt;  &lt;/div&gt; &lt;/div&gt; {{mouseCoordinates | json}} // home.component.ts @Component({    selector: 'app-home',    templateUrl: './home.component.html',    styleUrls: ['./home.component.sass'] }) export class HomeComponent implements OnInit {    items = [1, 2, 3, 4, 5, 6];    displayedItems = [];    mouseCoordinates = {};    ngOnInit() {        this.displayedItems = this.items.map((item) =&gt; this.formatItem(item));    }    formatItem(item) {        console.log('formatItem');        const t = Array.apply(null, Array(5)).map(() =&gt; 1);        return item + '%';    } }</span></span></code> </pre> <br>  Maintenant, le test de performance semble beaucoup plus décent. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ce/f49/118/2cef4911810ce0a506dd0697ee801119.png"></div><br>  <i><font color="#999999">Seulement 6 appels de formatItem et faible charge de processeur</font></i> <br><br>  Maintenant, l'application fonctionne beaucoup mieux.  Mais la solution utilisée ici présente des fonctionnalités qui ne sont pas toujours agréables: <br><br><ul><li>  Puisque nous affichons les coordonnées de la souris dans le modèle, l'événement <code>mousemove</code> déclenche toujours une vérification des modifications.  Mais, comme nous avons besoin des coordonnées de la souris, nous ne pouvons pas nous en débarrasser. </li><li>  Si le <code>mousemove</code> événements <code>mousemove</code> n'a besoin que d'effectuer certains calculs (qui n'affectent pas ce qui est affiché sur la page), alors pour accélérer l'application, vous pouvez procéder comme suit: <br><br><ol><li>  Vous pouvez utiliser <code>NgZone.runOutsideOfAngular</code> dans la fonction de gestionnaire d'événements.  Cela empêche la vérification des modifications de démarrer lorsque l'événement <code>mousemove</code> (cela n'affectera que ce gestionnaire). </li><li>  Vous pouvez empêcher le correctif zone.js pour certains événements en utilisant la ligne de code suivante dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">polyfills.ts</a> .  Cela affectera l'ensemble de l'application angulaire. </li></ol></li></ul><br><pre> <code class="javascript hljs">* (<span class="hljs-built_in"><span class="hljs-built_in">window</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> any).__zone_symbol__UNPATCHED_EVENTS = [<span class="hljs-string"><span class="hljs-string">'scroll'</span></span>, <span class="hljs-string"><span class="hljs-string">'mousemove'</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//     </span></span></code> </pre> <br>  Si vous êtes intéressé par les questions d'amélioration des performances des applications angulaires - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> - des documents utiles à ce sujet. <br><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>  Maintenant que vous avez lu cet article, 5 nouveaux outils devraient apparaître dans votre arsenal de développeur angulaire avec lesquels vous pouvez résoudre certains problèmes courants.  Nous espérons que les conseils que vous trouverez ici vous permettront de gagner du temps. <br><br>  <b>Chers lecteurs!</b>  Savez-vous quelque chose qui vous aide à gagner du temps lors du développement d'applications angulaires? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/rw/6v/yn/rw6vyn2bxx4usoqc39holmj2z8m.jpeg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr459304/">https://habr.com/ru/post/fr459304/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr459294/index.html">Quoi de plus important: connaître un langage de programmation ou être capable de résoudre un problème métier?</a></li>
<li><a href="../fr459296/index.html">Prix ​​JavaScript 2019</a></li>
<li><a href="../fr459298/index.html">Angulaire: statut en 2019</a></li>
<li><a href="../fr459300/index.html">Quasar 1.0: un nouvel outil utile pour les développeurs de Vue et pas seulement pour eux</a></li>
<li><a href="../fr459302/index.html">Nouvelle tentative de requêtes HTTP ayant échoué dans Angular</a></li>
<li><a href="../fr459306/index.html">Rendu de serveur dans un environnement sans serveur</a></li>
<li><a href="../fr459308/index.html">Le référencement ne fonctionne pas en 2019?</a></li>
<li><a href="../fr459310/index.html">Outils d'automatisation de test ou testeur de stéroïdes mobile</a></li>
<li><a href="../fr459312/index.html">Cher Agile, j'en ai marre de faire semblant</a></li>
<li><a href="../fr459314/index.html">Visualisez et traitez avec Hash Match Join</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>