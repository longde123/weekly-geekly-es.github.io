<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍✈️ 👍🏾 🚴 代码性能对JavaScript中变量声明上下文的依赖 🦖 👩🏻‍🚒 🖱️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="最初，本文被认为是其自用的一个小型基准，并且通常不打算成为本文，但是，在进行测量的过程中， JavaScript体系结构的实现中浮现出一些有趣的功能，这些功能在某些情况下会严重影响最终代码的性能。 我建议和您熟悉所获得的结果，同时还要分析一些相关主题：循环，环境（执行上下文）和块。 

 在我的文章...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>代码性能对JavaScript中变量声明上下文的依赖</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469523/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ud/cx/hu/udcxhuvjpmyigj19lmdrz8ojyja.jpeg"></div><br> 最初，本文被认为是其自用的一个小型基准，并且通常不打算成为本文，但是，在进行测量的过程中， <i><b>JavaScript</b></i>体系结构的实现中浮现出一些有趣的功能，这些功能在某些情况下会严重影响最终代码的性能。 我建议和您熟悉所获得的结果，同时还要分析一些相关主题：循环，环境（执行上下文）和块。 <br><br><a name="habracut"></a> 在我的文章<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“使用let变量声明和所产生的JavaScript闭包的功能”</a>的结尾<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，</a>我简要地谈到了比较循环中<i><b>let（LexicalDeclaration）</b></i>和<i><b>var（VarDeclaredNames）</b></i>变量声明的性能的主题。 为了进行比较，我们使用了手动运行时（无需<i><b>Array.prototype.sort（）</b></i>的帮助）对数组进行排序，最简单的方法之一就是通过选择进行排序，因为数组长度为100,000，我们得到的略多于50亿。 在两个循环（外部循环和嵌套循环）中进行迭代，并且此数字最终应允许进行足够的评估。 <br><br> 对于<i><b>var，</b></i>它正在对视图进行排序： <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, len = arr.length; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> min, mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 9.082 . //   Chrome: 10.783 .</span></span></code> </pre> <br> 并且<i><b>让</b></i> ： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, len = arr.length; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min, mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 5.261 . //   Chrome: 5.391 .</span></span></code> </pre> <br> 看到这些数字，似乎可以毫不含糊地争论说， <i><b>让</b></i>广告的速度完全超过<i><b>var</b></i> 。 但是，除了这个结论之外，还有一个悬而未决的问题：如果将<i><b>let</b></i>声明放在<i><b>for</b></i>循环之外会发生什么？ <br><br> 但是，在执行此操作之前，您需要在当前<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><i>ECMAScript 2019</i></a>规范<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><i>（ECMA-262）的</i></a>指导下深入研究<i><b>for</b></i>循环的工作： <br><br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">13</span></span>.<span class="hljs-number"><span class="hljs-number">7</span></span>.<span class="hljs-number"><span class="hljs-number">4</span></span>.<span class="hljs-number"><span class="hljs-number">7</span></span>Runtime Semantics: LabelledEvaluation With parameter labelSet. IterationStatement':'<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(Expression;Expression;Expression)Statement <span class="hljs-number"><span class="hljs-number">1</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> the first Expression is present, then a. Let exprRef be the result of evaluating the first Expression. b. Perform ? GetValue(exprRef). <span class="hljs-number"><span class="hljs-number">2</span></span>. Return ? ForBodyEvaluation(the second Expression, the third Expression, Statement, « », labelSet). IterationStatement':'<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(varVariableDeclarationList;Expression;Expression)Statement <span class="hljs-number"><span class="hljs-number">1</span></span>. Let varDcl be the result of evaluating VariableDeclarationList. <span class="hljs-number"><span class="hljs-number">2</span></span>. ReturnIfAbrupt(varDcl). <span class="hljs-number"><span class="hljs-number">3</span></span>. Return ? ForBodyEvaluation(the first Expression, the second Expression, Statement, « », labelSet). IterationStatement':'<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(LexicalDeclarationExpression;Expression)Statement <span class="hljs-number"><span class="hljs-number">1</span></span>. Let oldEnv be the running execution context's LexicalEnvironment. <span class="hljs-number"><span class="hljs-number">2</span></span>. Let loopEnv be NewDeclarativeEnvironment(oldEnv). <span class="hljs-number"><span class="hljs-number">3</span></span>. Let loopEnvRec be loopEnv's EnvironmentRecord. <span class="hljs-number"><span class="hljs-number">4</span></span>. Let isConst be the result of performing IsConstantDeclaration of LexicalDeclaration. <span class="hljs-number"><span class="hljs-number">5</span></span>. Let boundNames be the BoundNames of LexicalDeclaration. <span class="hljs-number"><span class="hljs-number">6</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> each element dn of boundNames, <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> a. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> isConst is true, then i. Perform ! loopEnvRec.CreateImmutableBinding(dn, true). b. <span class="hljs-keyword"><span class="hljs-keyword">Else</span></span>, i. Perform ! loopEnvRec.CreateMutableBinding(dn, false). <span class="hljs-number"><span class="hljs-number">7</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> the running execution context's LexicalEnvironment to loopEnv. <span class="hljs-number"><span class="hljs-number">8</span></span>. Let forDcl be the result of evaluating LexicalDeclaration. <span class="hljs-number"><span class="hljs-number">9</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> forDcl is an abrupt completion, then a. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> the running execution context's LexicalEnvironment to oldEnv. b. Return Completion(forDcl). <span class="hljs-number"><span class="hljs-number">10</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> isConst is false, let perIterationLets be boundNames; otherwise let perIterationLets be « ». <span class="hljs-number"><span class="hljs-number">11</span></span>. Let bodyResult be ForBodyEvaluation(the first Expression, the second Expression, Statement, perIterationLets, labelSet). <span class="hljs-number"><span class="hljs-number">12</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> the running execution context's LexicalEnvironment to oldEnv. <span class="hljs-number"><span class="hljs-number">13</span></span>. Return Completion(bodyResult).</code> </pre>  <i>注意：在源代码中，IterationStatement之后的冒号未用撇号括起来-在此处添加了冒号，因此没有自动格式化会大大破坏文本的可读性。</i> <br><br> 正如我们所看到的，这里有三个选项可供调用和<i><b>for</b></i>循环的进一步工作： <br><ul><li>  with <i>for（表达式;表达式;表达式）语句</i> <br>  <i><b>ForBodyEvaluation</b> （第二个Expression，第三个Expression，Statement，“”，labelSet）</i> 。 </li><li> 与<i><b>for</b> （varVariableDeclarationList; Expression; Expression）语句一起使用</i> <br>  <i><b>ForBodyEvaluation</b> （第一个Expression，第二个Expression，Statement，“”，labelSet）。</i> </li><li>  at <i><b>for</b> （LexicalDeclarationExpression; Expression）语句</i> <br>  <i><b>ForBodyEvaluation</b> （第一个表达式，第二个表达式，语句，perIterationLets，labelSet）</i> </li></ul><br> 在最后的第三个变量中，与前两个变量不同，第四个参数不为空<i><b>-perIterationLets-</b></i>这些实际上是传递给<i><b>for</b></i>循环的第一个参数中的<i><b>let</b></i>声明。 它们在第10段中指定： <br>  <i>-如果<b>isConst</b>为<b>false</b> ，则让<b>perIterationLets</b>为boundNames;</i>  <i>否则，让perIterationLets为“”。</i> <br> 如果将常量传递给<i><b>for</b></i> ，而不是传递给变量，则<i><b>perIterationLets</b></i>参数<i><b>将为</b></i>空。 <br><br> 另外，在第三个选项中，有必要注意第2段： <br>  <i>-让loopEnv为<b>NewDeclarativeEnvironment</b> （oldEnv）。</i> <br><br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">8</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>NewDeclarativeEnvironment ( E ) When the abstract operation NewDeclarativeEnvironment is called with a Lexical Environment as argument E the following steps are performed: <span class="hljs-number"><span class="hljs-number">1</span></span>. Let env be a new Lexical Environment. <span class="hljs-number"><span class="hljs-number">2</span></span>. Let envRec be a new declarative Environment Record containing no bindings. <span class="hljs-number"><span class="hljs-number">3</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> env's EnvironmentRecord to envRec. <span class="hljs-number"><span class="hljs-number">4</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> the outer lexical environment reference of env to E. <span class="hljs-number"><span class="hljs-number">5</span></span>. Return env.</code> </pre> <br> 在此，作为参数<i><b>E</b></i> ，采用从中调用<i><b>for</b></i>循环的环境（全局，任何函数等），并创建一个新环境以参考创建它的外部环境执行<i><b>for</b></i>循环（第4点）。 由于环境是执行的上下文，因此我们对此事实感兴趣。 <br><br> 我们还记得<i><b>let</b></i>和<i><b>const</b></i>变量声明在上下文中绑定到了声明它们的块。 <br><br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">13</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>.<span class="hljs-number"><span class="hljs-number">14</span></span>Runtime Semantics: BlockDeclarationInstantiation ( code, env ) Note When a Block or CaseBlock is evaluated a new declarative Environment Record is created and bindings <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> each block scoped variable, constant, function, or class declared <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the block are instantiated <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the Environment Record. BlockDeclarationInstantiation is performed as follows using arguments code and env. code is the Parse Node corresponding to the body of the block. env is the Lexical Environment <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> which bindings are to be created. <span class="hljs-number"><span class="hljs-number">1</span></span>. Let envRec be env's EnvironmentRecord. <span class="hljs-number"><span class="hljs-number">2</span></span>. Assert: envRec is a declarative Environment Record. <span class="hljs-number"><span class="hljs-number">3</span></span>. Let declarations be the LexicallyScopedDeclarations of code. <span class="hljs-number"><span class="hljs-number">4</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> each element d <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> declarations, <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> a. <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> each element dn of the BoundNames of d, <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> i. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> IsConstantDeclaration of d is true, then <span class="hljs-number"><span class="hljs-number">1</span></span>. Perform ! envRec.CreateImmutableBinding(dn, true). ii. <span class="hljs-keyword"><span class="hljs-keyword">Else</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>. Perform ! envRec.CreateMutableBinding(dn, false). b. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> d is a FunctionDeclaration, a GeneratorDeclaration, an AsyncFunctionDeclaration, or an AsyncGeneratorDeclaration, then i. Let fn be the sole element of the BoundNames of d. ii. Let fo be the result of performing InstantiateFunctionObject <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> d with argument env. iii. Perform envRec.InitializeBinding(fn, fo).</code> </pre> <br> 注意：由于在调用<i><b>for</b></i>循环的前两个变体中没有此类声明，因此无需为它们创建新的环境。 <br><br> 我们进一步考虑一下什么是<i><b>ForBodyEvaluation</b></i> ： <br><br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">13</span></span>.<span class="hljs-number"><span class="hljs-number">7</span></span>.<span class="hljs-number"><span class="hljs-number">4</span></span>.<span class="hljs-number"><span class="hljs-number">8</span></span>Runtime Semantics: ForBodyEvaluation ( test, increment, stmt, perIterationBindings, labelSet ) The abstract operation ForBodyEvaluation with arguments test, increment, stmt, perIterationBindings, and labelSet is performed as follows: <span class="hljs-number"><span class="hljs-number">1</span></span>. Let V be undefined. <span class="hljs-number"><span class="hljs-number">2</span></span>. Perform ? CreatePerIterationEnvironment(perIterationBindings). <span class="hljs-number"><span class="hljs-number">3</span></span>. Repeat, a. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> test is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> [empty], then i. Let testRef be the result of evaluating test. ii. Let testValue be ? GetValue(testRef). iii. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> ToBoolean(testValue) is false, return NormalCompletion(V). b. Let result be the result of evaluating stmt. c. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> LoopContinues(result, labelSet) is false, return Completion(UpdateEmpty(result, V)). d. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> result.[[Value]] is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> empty, <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> V to result.[[Value]]. e. Perform ? CreatePerIterationEnvironment(perIterationBindings). f. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> increment is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> [empty], then i. Let incRef be the result of evaluating increment. ii. Perform ? GetValue(incRef).</code> </pre> <br> 首先要注意的是： <br><ul><li> 传入参数的描述： <br><ul><li>  <i><b>test</b></i> ：在循环体的下一次迭代之前检查表达式是否为真（例如： <i><b>i &lt;len</b></i> ）； </li><li>  <i><b>增量</b></i> ：在每个新迭代的开始（第一个迭代除外）开始时评估的表达式（例如： <i><b>i ++</b></i> ）； </li><li>  <i><b>stmt</b></i> ：循环体 </li><li>  <i><b>perIterationBindings</b></i> ：在第一个<i><b>for</b></i>参数中用<i><b>let</b></i>声明的变量（例如： <i><b>let i = 0 || let i || let i，j</b></i> ）； </li><li>  <i><b>labelSet</b></i> ：循环的标签； </li></ul></li><li> 要点2：这里，如果<i><b>传递</b></i>了非空参数<i><b>perIterationBindings</b></i> ，则会创建第二个环境来执行循环的初始传递； </li><li> 第3.a段：检查给定条件以继续执行周期； </li><li> 第3.b条：执行循环体； </li><li>  3.e点：创建一个新环境。 </li></ul><br> 那么，直接地，用于创建<i><b>for</b></i>循环内部环境的算法： <br><br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">13</span></span>.<span class="hljs-number"><span class="hljs-number">7</span></span>.<span class="hljs-number"><span class="hljs-number">4</span></span>.<span class="hljs-number"><span class="hljs-number">9</span></span>Runtime Semantics: CreatePerIterationEnvironment ( perIterationBindings ) <span class="hljs-number"><span class="hljs-number">1</span></span>. The abstract operation CreatePerIterationEnvironment with argument perIterationBindings is performed as follows: <span class="hljs-number"><span class="hljs-number">1</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> perIterationBindings has any elements, then a. Let lastIterationEnv be the running execution context's LexicalEnvironment. b. Let lastIterationEnvRec be lastIterationEnv's EnvironmentRecord. c. Let outer be lastIterationEnv's outer environment reference. d. Assert: outer is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> null. e. Let thisIterationEnv be NewDeclarativeEnvironment(outer). f. Let thisIterationEnvRec be thisIterationEnv's EnvironmentRecord. g. <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> each element bn of perIterationBindings, <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> i. Perform ! thisIterationEnvRec.CreateMutableBinding(bn, false). ii. Let lastValue be ? lastIterationEnvRec.GetBindingValue(bn, true). iii. Perform thisIterationEnvRec.InitializeBinding(bn, lastValue). h. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> the running execution context's LexicalEnvironment to thisIterationEnv. <span class="hljs-number"><span class="hljs-number">2</span></span>. Return undefined.</code> </pre> <br> 如我们所见，第一段检查传递的参数中是否存在任何元素，而只有在有<i><b>let</b></i>公告的情况下才执行第一段。 所有新环境都是参照相同的外部上下文创建的，并采用前一次迭代的最新值（先前的工作环境）作为<i><b>let</b></i>变量的新绑定。 <br><br> 例如，考虑一个类似的表达式： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) { arr.push(i); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// Array(3) [ 0, 1, 2 ]</span></span></code> </pre> <br> 这是不使用<i><b>for</b></i>即可分解<i><b>的方式</b></i> （具有一定的常规性）： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = []; <span class="hljs-comment"><span class="hljs-comment">//    { let i = 0; //     for } //   ,   { let i = 0; //    i    if (i &lt; 3) arr.push(i); } //    { let i = 0; //    i    i++; if (i &lt; 3) arr.push(i); } //    { let i = 1; //    i    i++; if (i &lt; 3) arr.push(i); } //    { let i = 2; //    i    i++; if (i &lt; 3) arr.push(i); } console.log(arr); // Array(3) [ 0, 1, 2 ]</span></span></code> </pre> <br> 实际上，我们得出的结论是，对于每个上下文，这里有五个，我们为在变量for中声明为第一个参数的<i><b>let</b></i>变量建立新的绑定（重要：这不适用于直接在循环体内的<i><b>let</b></i>声明）。 <br><br> 例如，这是在没有附加绑定的情况下使用<i><b>var</b></i>时此循环的外观： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr2 = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) arr.push(i); i++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) arr.push(i); i++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) arr.push(i); i++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) arr.push(i); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// Array(3) [ 0, 1, 2 ]</span></span></code> </pre> <br> 我们可以得出一个看似合乎逻辑的结论，即如果在循环执行期间不需要为每次迭代创建单独的绑定（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">相反，这可能更有意义</a> ），我们应该在声明增量变量之前使用<i><b>for</b></i>循环，这可以避免我们创建和删除大量上下文，并且从理论上讲可以提高性能。 <br><br> 让我们尝试以相同的方式对100,000个元素的数组进行排序，以达到此目的。为了美观，我们还<i><b>为for</b></i>定义了所有其他变量： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i, j, min, mini, len = arr.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 34.246 . //   Chrome: 10.803 .</span></span></code> </pre> <br> 出乎意料的结果...确切地说，与预期相反。 这项测试中的<i><b>Firefox</b></i>下降特别引人注目。 <br><br> 好啦 这没有用，让我们将<i><b>i</b></i>和<i><b>j</b></i>变量的声明返回到相应循环的参数： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min, mini, len = arr.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 6.575 . //   Chrome: 6.749 .</span></span></code> </pre> <br> 嗯 从技术上讲，最后一个示例与本文开头的示例之间的唯一区别似乎是在<i><b>for</b></i>循环外对变量<i><b>min，mini</b></i>和<i><b>len</b></i>进行了声明，尽管该区别仍是上下文相关的，但对于我们而言，这并不是很有趣，此外，我们摆脱了在上层循环的主体中将这些变量声明为99,999次的需要，从理论上讲，这又应该提高生产率，而不是将生产率降低一秒钟以上。 <br><br> 也就是说，事实证明，以某种方式处理在<i><b>for</b></i>循环的参数或主体中声明的变量比在其外部进行处理要快得多。 <br><br> 但是，我们似乎没有在<i><b>for</b></i>循环的规范中看到任何“ turbo”指令会导致我们产生这种想法。 因此，不是<i><b>for</b></i>循环的具体工作，而是其他一些事情。例如， <i><b>let</b></i>声明的功能： <i><b>let</b></i>与<i><b>var</b></i>的主要区别是什么？ 阻止执行上下文！ 在我们的最后两个示例中，我们在块外使用了广告。 但是，如果不将这些声明移回原处<i><b>，</b></i>而只是为它们选择一个单独的块怎么办？ <br><br><pre> <code class="javascript hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i, j, min, mini, len = arr.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 5.262 . //   Chrome: 5.405 .</span></span></code> </pre> <br> 瞧！ 事实证明，要注意的是， <i><b>让</b></i>公告是在全球范围内进行的，一旦我们为它们分配了单独的区域，所有问题就在那里消失了。 <br><br> 在这里，最好回忆起另一种稍微不受欢迎的声明变量的方法<i><b>var</b></i> 。 <br><br> 在本文开头的示例中，相对于<i><b>let</b></i> ，使用<i><b>var</b></i>进行排序的时间显示出极其糟糕的结果。 但是，如果您仔细查看此示例，可能会发现，由于<i><b>var</b></i>没有变量块绑定，因此变量的实际上下文是全局的。 而且，在<i><b>let</b></i>的示例中， <i><b>我们</b></i>已经发现了它如何影响性能（而且，通常，使用<i><b>let时</b></i> ，速度下降的结果要比使用<i><b>var</b></i>的情况要强，尤其是在<i><b>Firefox中</b></i> ）。 因此，为了公平起见，我们将执行一个示例，其中<i><b>var</b></i>为变量创建了新的上下文： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i, j, min, mini, len = arr.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } } test(); <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 5.255 . //   Chrome: 5.411 .</span></span></code> </pre> <br> 并且，我们得到的结果几乎与使用<i><b>let</b></i>时的结果相同。 <br><br> 最后，让我们通过读取全局变量而不更改其值来检查减速是否发生。 <br><br>  <i><b>让</b></i> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> len = arr.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min, mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 5.262 . //   Chrome: 5.391 .</span></span></code> </pre> <br>  <i><b>变种</b></i> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> len = arr.length; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i, j, min, mini; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } } test(); <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 5.258 . //   Chrome: 5.439 .</span></span></code> </pre> <br> 结果表明，读取全局变量不会影响执行时间。 <br><br><h3> 总结一下 </h3><br><ol><li> 更改全局变量比更改局部变量要慢得多。 考虑到这一点，可以通过创建单独的块或函数（包括用于声明变量）而不是在全局上下文中执行部分代码来在适当情况下优化代码。 是的，在几乎所有教科书中，您都可以找到有关建议建立尽可能少的全局绑定的建议，但通常仅表示阻塞全局名称空间是一个原因，而不是任何有关可能的性能问题的字眼。 </li><li> 尽管实际上在第一个<i><b>for</b></i>参数中使用<i><b>let</b></i>声明执行循环会创建大量环境，但与将此类声明放在块外的情况不同，这几乎对性能没有影响。 然而，当这一因素将极大地影响生产力时，不应排除存在异国情调的可能性。 </li><li>  <i><b>var</b></i>变量的性能仍然不逊于<i><b>let</b></i>变量，但是它没有超过<i><b>let</b></i>变量（同样，在一般情况下），这使我们得出下一个结论<i><b>：</b></i>除了出于兼容性目的，没有理由使用<i><b>var</b></i>声明。 但是，如果需要通过更改全局变量的值来操作全局变量，则在性能方面具有<i><b>var</b></i>的变体将是更好的选择（至少在目前，尤其是假设脚本也可以在Gecko引擎上运行）。 </li></ol><br><h4> 参考文献 </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">ECMAScript 2019（ECMA-262）</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在JavaScript中使用变量的let声明和结果闭包的功能</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN469523/">https://habr.com/ru/post/zh-CN469523/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN469505/index.html">将业务推向国外市场的3种实用方法：实际公司的方法和技巧</a></li>
<li><a href="../zh-CN469507/index.html">第三个Steam Windows Client漏洞，但不是0day</a></li>
<li><a href="../zh-CN469509/index.html">角度示意图，或我如何编写角度cli模板</a></li>
<li><a href="../zh-CN469515/index.html">为Istio准备应用程序</a></li>
<li><a href="../zh-CN469521/index.html">我买了摩托车骑，不摔倒</a></li>
<li><a href="../zh-CN469525/index.html">矿用挖掘机的自动控制系统</a></li>
<li><a href="../zh-CN469527/index.html">对讲机是间谍的耳朵吗？</a></li>
<li><a href="../zh-CN469529/index.html">文字渲染讨厌你</a></li>
<li><a href="../zh-CN469531/index.html">“在更好的基础上比较编程语言是完全愚蠢的职业。”</a></li>
<li><a href="../zh-CN469533/index.html">生物识别的问题和威胁</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>