<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∫ üë©üèæ‚Äçü§ù‚Äçüë®üèº üë®üèº‚Äçüöí Creaci√≥n de defensa de la torre en la unidad: torres y enemigos que disparan üçÜ üß¶ ü§ôüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[ La primera y segunda parte del tutorial] 



- Lo colocamos en el campo de la torre. 
- Apuntamos a los enemigos con la ayuda de la f√≠sica. 
- Los r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Creaci√≥n de defensa de la torre en la unidad: torres y enemigos que disparan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459070/">  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La primera</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">segunda</a> parte del tutorial] <br><br><ul><li>  Lo colocamos en el campo de la torre. </li><li>  Apuntamos a los enemigos con la ayuda de la f√≠sica. </li><li>  Los rastreamos mientras es posible. </li><li>  Les disparamos con un rayo l√°ser. </li></ul><br>  Esta es la tercera parte de una serie de tutoriales sobre c√≥mo crear un g√©nero de defensa de torre simple.  Describe la creaci√≥n de torres, apuntando y disparando a los enemigos. <br><br>  El tutorial fue creado en Unity 2018.3.0f2. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/470/ceb/183/470ceb1832b49ee7372fb79b8425b567.jpg" width="512" height="256"></div><br>  <i>Vamos a calentar a los enemigos.</i> <br><br><h2>  Creaci√≥n de la torre </h2><br>  Los muros solo ralentizan a los enemigos, lo que aumenta la longitud del camino que deben recorrer.  Pero el objetivo del juego es destruir a los enemigos antes de que lleguen al punto final.  Este problema se resuelve colocando torres en el campo que les disparar√°. <br><a name="habracut"></a><br><h3>  Contenido del azulejo </h3><br>  Las torres son otro tipo de contenido de mosaico, as√≠ <code>GameTileContent</code> agreguemos una entrada para ellas en <code>GameTileContent</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> GameTileContentType { Empty, Destination, Wall, SpawnPoint, Tower‚Ç¨ }</code> </pre> <br>  En este tutorial, solo <code>GameTileContentFactory</code> un tipo de torre, que se puede implementar al proporcionar <code>GameTileContentFactory</code> un enlace al prefabricado de la torre, una instancia de la cual tambi√©n se puede crear a trav√©s de <code>Get</code> . <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContent towerPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContentType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Tower‚Ç¨: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(towerPrefab); } ‚Ä¶ }</code> </pre> <br>  Pero las torres deben disparar, por lo que su condici√≥n deber√° actualizarse y necesitar√°n su propio c√≥digo.  Crea una clase <code>Tower</code> para este prop√≥sito que ampl√≠e la clase <code>GameTileContent</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Tower</span></span> : <span class="hljs-title"><span class="hljs-title">GameTileContent</span></span> {}</code> </pre> <br>  Puede hacer que la torre prefabricada tenga su propio componente cambiando el tipo de campo de f√°brica a <code>Tower</code> .  Dado que la clase todav√≠a se considera un <code>GameTileContent</code> , no es necesario cambiar nada m√°s. <br><br><pre> <code class="cs hljs"> Tower towerPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><h3>  Prefabricados </h3><br>  Crea una casa prefabricada para la torre.  Puede comenzar duplicando el prefabricado de pared y reemplazando su componente <code>GameTileContent</code> con el componente <code>Tower</code> , y luego cambiar su tipo a <em>Torre</em> .  Para hacer que la torre se ajuste a las paredes, guarde el cubo de la pared como la base de la torre.  Luego coloca otro cubo encima.  Le di una escala de 0.5.  Pon otro cubo sobre √©l, indicando una torreta, esta parte apuntar√° y disparar√° a los enemigos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/392/e5d/633/392e5d63397672627c3b5ec018df0444.png" width="190" height="260"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d92/dec/c33/d92decc33036a1e973a7f20a3df2c00e.png" width="320" height="120"></div><br>  <i>Tres cubos formando una torre.</i> <br><br>  La torre girar√°, y dado que tiene un colisionador, ser√° rastreada por un motor f√≠sico.  Pero no necesitamos ser tan precisos, porque usamos colisionadores de torre solo para seleccionar celdas.  Esto se puede hacer aproximadamente.  Retire el colisionador del cubo de la torreta y cambie el colisionador del cubo de la torre para que cubra ambos cubos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e01/11e/3b7/e0111e3b7221bbbe4e5b0d23373e4b3a.png" width="190" height="260"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1f/857/09b/a1f85709bd504d176a18930240edea5a.png" width="320" height="152"></div><br>  <i>Torre del cubo colisionador.</i> <br><br>  La torre disparar√° un rayo l√°ser.  Se puede visualizar de muchas maneras, pero solo usamos un cubo transl√∫cido, que estiraremos para formar una viga.  Cada torre debe tener su propio haz, as√≠ que agr√©guelo a la torre prefabricada.  Col√≥quelo dentro de la torreta para que quede oculto de manera predeterminada y d√©le una escala m√°s peque√±a, por ejemplo 0.2.  Hag√°moslo hijo de la ra√≠z prefabricada, no del cubo de la torreta. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19a/1dc/29e/19a1dc29e70adb158e07f29653db2d66.png" width="190" height="260" alt="rayo l√°ser"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45a/273/081/45a273081365aa9e483f1aa97cbe39c8.png" width="226" height="108" alt="jerarqu√≠a"></div><br>  <i>Cubo oculto de un rayo l√°ser.</i> <br><br>  Cree un material adecuado para el rayo l√°ser.  Simplemente utilic√© el material negro transl√∫cido est√°ndar y apagu√© todos los reflejos, y tambi√©n le di un color rojo emitido. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2fb/e49/860/2fbe498604cc4cc4ed6ee60a45eea63d.png" width="320" height="284" alt="color"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0eb/b46/483/0ebb4648376a7fe68c96b7a16ce27db9.png" width="320" height="56" alt="sin reflejos"></div><br>  <i>El material del rayo l√°ser.</i> <br><br>  Verifique que el rayo l√°ser no tenga un colisionador, y tambi√©n apague su yeso y sombra. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecf/f21/0ad/ecff210ad75ef4b12cb0a74102365492.png" width="320" height="162"></div><br>  <i>El rayo l√°ser no interact√∫a con las sombras.</i> <br><br>  Una vez completada la creaci√≥n de la torre prefabricada, la agregaremos a la f√°brica. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/626/37c/935/62637c9353cf1e20e170e82bbefcdb11.png" width="320" height="114"></div><br>  <i>F√°brica con una torre.</i> <br><br><h3>  Colocaci√≥n de la torre </h3><br>  Agregaremos y eliminaremos torres usando otro m√©todo de cambio.  Simplemente puede duplicar <code>GameBoard.ToggleWall</code> cambiando el nombre del m√©todo y el tipo de contenido. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleTower</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Tower‚Ç¨) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.Tower‚Ç¨); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!FindPaths()) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } } }</code> </pre> <br>  En <code>Game.HandleTouch</code> , al mantener presionada la tecla May√∫s se cambiar√°n las torres en lugar de las paredes. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { board.ToggleTower(tile); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { board.ToggleWall(tile); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/926/804/2ac/9268042acc19a28d6ff1a6d74d83144f.png" width="230" height="230"></div><br>  <i>Torres en el campo.</i> <br><br><h3>  Bloqueo de ruta </h3><br>  Hasta ahora, solo las paredes pueden bloquear la b√∫squeda de un camino, por lo que los enemigos se mueven a trav√©s de las torres.  <code>GameTileContent</code> propiedad auxiliar a <code>GameTileContent</code> que indica si el contenido bloquea la ruta.  El camino est√° bloqueado si es un muro o una torre. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> BlocksPath =&gt; Type == GameTileContentType.Wall || Type == GameTileContentType.Tower‚Ç¨;</code> </pre> <br>  Use esta propiedad en <code>GameTile.GrowPathTo</code> en lugar de verificar el tipo de contenido. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor, Direction direction</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-comment"><span class="hljs-comment">//neighbor.Content.Type != GameTileContentType.Wall ? neighbor : null; neighbor.Content.BlocksPath ? null : neighbor; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fa/93f/eed/6fa93feedb4925ee12decb4233612a4c.png" width="230" height="230"></div><br>  <i>Ahora el camino est√° bloqueado por muros y torres.</i> <br><br><h3>  Reemplazar las paredes </h3><br>  Lo m√°s probable es que el jugador a menudo reemplace las paredes con torres.  Ser√° inconveniente para √©l quitar la pared primero, y adem√°s, los enemigos pueden penetrar en este espacio temporalmente aparecido.  Puede implementar un reemplazo directo forzando <code>GameBoard.ToggleTower</code> para verificar si la pared est√° actualmente en el mosaico.  Si es as√≠, reempl√°celo inmediatamente con una torre.  En este caso, no tenemos que buscar otras formas, porque el mosaico todav√≠a las bloquea. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleTower</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Tower) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Wall) { tile.Content = contentFactory.Get(GameTileContentType.Tower); } }</code> </pre> <br><h2>  Apuntamos a los enemigos. </h2><br>  Una torre puede cumplir su tarea solo cuando encuentra un enemigo.  Despu√©s de encontrar al enemigo, debe decidir a qu√© parte apuntar. <br><br><h3>  Punto de punter√≠a </h3><br>  Para detectar objetivos, utilizaremos el motor de f√≠sica.  Como en el caso del colisionador de la torre, no necesitamos que el colisionador enemigo coincida necesariamente con su forma.  Puedes elegir el colisionador m√°s simple, es decir, una esfera.  Despu√©s de detectar al enemigo, utilizaremos la posici√≥n del objeto del juego con el colisionador adjunto como un punto para apuntar. <br><br>  No podemos unir el colisionador al objeto ra√≠z del enemigo, porque no siempre coincide con la posici√≥n del modelo y har√° que la torre apunte al suelo.  Es decir, debe colocar el colisionador en alg√∫n lugar del modelo.  El motor de f√≠sica nos dar√° un enlace a este objeto, que podemos usar para apuntar, pero a√∫n necesitamos acceso al componente <code>Enemy</code> del objeto ra√≠z.  Para simplificar la tarea, <code>TargetPoint</code> componente <code>TargetPoint</code> .  Vamos a darle una propiedad para asignaci√≥n privada y recibo p√∫blico del componente <code>Enemy</code> , y otra propiedad para obtener su posici√≥n en el mundo. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TargetPoint</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Enemy Enemy‚Ç¨ { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 Position =&gt; transform.position; }</code> </pre> <br>  Vamos a darle un m√©todo <code>Awake</code> que configura un enlace a su componente <code>Enemy</code> .  Vaya directamente al objeto ra√≠z usando <code>transform.root</code> .  Si el componente <code>Enemy</code> no existe, cometimos un error al crear el enemigo, as√≠ que agreguemos una declaraci√≥n para esto. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Enemy‚Ç¨ = transform.root.GetComponent&lt;Enemy&gt;(); Debug.Assert(Enemy‚Ç¨ != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point without Enemy root!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  Adem√°s, el colisionador debe estar conectado al mismo objeto del juego al que <code>TargetPoint</code> conectado <code>TargetPoint</code> . <br><br><pre> <code class="cs hljs"> Debug.Assert(Enemy‚Ç¨ != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point without Enemy root!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); Debug.Assert( GetComponent&lt;SphereCollider&gt;() != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point without sphere collider!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> );</code> </pre> <br>  Agrega un componente y un colisionador al cubo prefabricado del enemigo.  Esto har√° que las torres apunten al centro del cubo.  Utilizamos un colisionador esf√©rico con un radio de 0.25.  El cubo tiene una escala de 0.5, por lo que el radio verdadero del colisionador ser√° 0.125.  Gracias a esto, el enemigo tendr√° que cruzar visualmente el c√≠rculo de alcance de la torre, y solo despu√©s de un tiempo se convierte en el objetivo real.  El tama√±o del colisionador tambi√©n se ve afectado por la escala aleatoria del enemigo, por lo que su tama√±o en el juego tambi√©n variar√° ligeramente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85e/5ca/5e4/85e5ca5e47b8d59fa4211c78126bd512.png" width="176" height="176"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ae/a71/aec/7aea71aecbd64d4e045df141ecd1c711.png" width="320" height="176" alt="inspector"></div><br>  <i>Un enemigo con un punto de punter√≠a y un colisionador en un cubo.</i> <br><br><h3>  Capa enemiga </h3><br>  Las torres solo se preocupan por los enemigos y no apuntan a nada m√°s, por lo que colocaremos a todos los enemigos en una capa separada.  Usaremos la capa 9. Cambie su nombre a <em>Enemigo</em> en la ventana <em>Capas y etiquetas</em> , que se puede abrir a trav√©s de la opci√≥n <em>Editar capas</em> en el men√∫ desplegable <em>Capas</em> en la esquina superior derecha del editor. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e6/9a5/762/8e69a5762e8eb1856175f9d9dc1ab388.png" width="320" height="308"></div><br>  <i>La capa 9 se usar√° para los enemigos.</i> <br><br>  Esta capa es necesaria solo para el reconocimiento de los enemigos, y no para las interacciones f√≠sicas.  Vamos a se√±alarlo deshabilit√°ndolos en la <em>Matriz de colisi√≥n de capas</em> , que se encuentra en el panel <em>F√≠sica</em> de los par√°metros del proyecto. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/876/06e/e7d/87606ee7dfc4777760d81219517125ce.png" width="200" height="200"></div><br>  <i>Matriz de colisiones de capas.</i> <br><br>  Aseg√∫rese de que el objeto del juego del punto de punter√≠a est√© en la capa deseada.  El resto de la casa prefabricada del enemigo puede estar en otras capas, pero ser√° m√°s f√°cil coordinar todo y colocar toda la casa prefabricada en la capa <em>Enemiga</em> .  Si cambia la capa del objeto ra√≠z, se le pedir√° que cambie la capa para todos sus objetos secundarios. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d1/f75/062/6d1f75062420abadb285e9efca1e1a5e.png" width="320" height="44"></div><br>  <i>Enemigo en la capa derecha.</i> <br><br>  <code>TargetPoint</code> la afirmaci√≥n de que <code>TargetPoint</code> realmente en la capa correcta. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ Debug.Assert(gameObject.layer == <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point on wrong layer!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  Adem√°s, las acciones del jugador deben ser ignoradas por los colisionadores enemigos.  Esto se puede lograr agregando un argumento de m√°scara de capa a <code>Physics.Raycast</code> en <code>GameBoard.GetTile</code> .  Este m√©todo tiene una forma que toma la distancia al haz y la m√°scara de capa como argumentos adicionales.  Le daremos la distancia m√°xima y la m√°scara de capa por defecto, es decir, 1. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTile</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ray ray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> RaycastHit hit, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>.MaxValue, <span class="hljs-number"><span class="hljs-number">1</span></span>)) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">¬øNo deber√≠a ser la m√°scara de capa 0?</b> <div class="spoiler_text">  El √≠ndice de capa predeterminado es cero, pero pasamos la m√°scara de capa.  La m√°scara cambia los bits individuales de un entero a 1 si la capa necesita ser activada.  En este caso, debe establecer solo el primer bit, es decir, el menos significativo, lo que significa 2 <sup>0</sup> , que equivale a 1. </div></div><br><h3>  Actualizaci√≥n del contenido del mosaico </h3><br>  Las torres pueden realizar su tarea solo cuando se actualiza su estado.  Lo mismo se aplica al contenido de todos los mosaicos, aunque el resto de los contenidos no hacen nada hasta ahora.  Por lo tanto, agregue un m√©todo virtual <code>GameTileContent</code> a <code>GameUpdate</code> , que no hace nada por defecto. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {}</code> </pre> <br>  Hagamos que <code>Tower</code> redefina, incluso si por ahora simplemente muestra en la consola que est√° buscando un objetivo. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Searching for target..."</span></span>); }</code> </pre> <br>  <code>GameBoard</code> ocupa de los mosaicos y sus contenidos, por lo que tambi√©n realizar√° un seguimiento de qu√© contenido debe actualizarse.  Para hacer esto, agregue la lista y el m√©todo p√∫blico <code>GameUpdate</code> , que actualiza todo en la lista. <br><br><pre> <code class="cs hljs"> List&lt;GameTileContent&gt; updatingContent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;GameTileContent&gt;(); ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; updatingContent.Count; i++) { updatingContent[i].GameUpdate(); } }</code> </pre> <br>  En nuestro tutorial solo necesita actualizar las torres.  Cambie <code>ToggleTower</code> para que agregue y elimine contenido si es necesario.  Si tambi√©n se necesita otro contenido, necesitaremos un enfoque m√°s general, pero por ahora, esto es suficiente. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleTower</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Tower) { updatingContent.Remove(tile.Content); tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.Tower); <span class="hljs-comment"><span class="hljs-comment">//if (!FindPaths()) { if (FindPaths()) { updatingContent.Add(tile.Content); } else { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } } else if (tile.Content.Type == GameTileContentType.Wall) { tile.Content = contentFactory.Get(GameTileContentType.Tower); updatingContent.Add(tile.Content); } }</span></span></code> </pre> <br>  Para que esto funcione, ahora es suficiente para nosotros simplemente actualizar el campo en <code>Game.Update</code> .  Actualizaremos el campo despu√©s de los enemigos.  Gracias a esto, las torres podr√°n apuntar exactamente donde est√°n los enemigos.  Si hici√©ramos lo contrario, las torres apuntar√≠an donde estaban los enemigos en el √∫ltimo cuadro. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ enemies.GameUpdate(); board.GameUpdate(); }</code> </pre> <br><h3>  Rango de punter√≠a </h3><br>  Las torres tienen un radio de punter√≠a limitado.  Hag√°moslo personalizado agregando un campo a la clase <code>Tower</code> .  La distancia se mide desde el centro del mosaico de la torre, por lo que en un rango de 0.5 solo cubrir√° su propio mosaico.  Por lo tanto, un rango m√≠nimo y est√°ndar razonable ser√≠a 1.5, cubriendo la mayor√≠a de las losetas vecinas. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(1.5f, 10.5f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> targetingRange = <span class="hljs-number"><span class="hljs-number">1.5f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c38/ae4/ee8/c38ae4ee885cf5d89f24164b9c6bc5fe.png" width="320" height="74"></div><br>  <i>Rango de punter√≠a 2.5.</i> <br><br>  Visualicemos el rango con gizmo.  No necesitamos verlo constantemente, por lo tanto crearemos el m√©todo <code>OnDrawGizmosSelected</code> llamado solo para los objetos seleccionados.  Dibujamos el marco amarillo de la esfera con un radio igual a la distancia y centrado en relaci√≥n con la torre.  Col√≥quelo ligeramente sobre el suelo para que siempre sea claramente visible. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmosSelected</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Gizmos.color = Color.yellow; Vector3 position = transform.localPosition; position.y += <span class="hljs-number"><span class="hljs-number">0.01f</span></span>; Gizmos.DrawWireSphere(position, targetingRange); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/674/6b7/3cd/6746b73cd2e015fd599b770bb89e1c8a.png" width="230" height="230"></div><br>  <i>Gizmo rango de punter√≠a.</i> <br><br>  Ahora podemos ver cu√°l de los enemigos es un objetivo asequible para cada una de las torres.  Pero elegir torres en la ventana de escena es inconveniente, porque tenemos que seleccionar uno de los cubos secundarios y luego cambiar al objeto ra√≠z de la torre.  Otros tipos de contenido de mosaico tambi√©n sufren el mismo problema.  Podemos forzar la selecci√≥n de la ra√≠z del contenido del <code>GameTileContent</code> en la ventana de escena agregando el atributo <code>SelectionBase</code> al <code>GameTileContent</code> . <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">SelectionBase</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTileContent</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ }</code> </pre> <br><h3>  Captura de objetivos </h3><br>  Agregue un campo <code>TargetPoint</code> a la clase <code>Tower</code> para que pueda rastrear su objetivo capturado.  Luego <code>GameUpdate</code> para llamar al nuevo m√©todo <code>AquireTarget</code> , que devuelve informaci√≥n sobre si encontr√≥ el objetivo.  Tras la detecci√≥n, mostrar√° un mensaje en la consola. <br><br><pre> <code class="cs hljs"> TargetPoint target; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (AcquireTarget()) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Acquired target!"</span></span>); } }</code> </pre> <br>  En <code>AcquireTarget</code> obtenemos todos los objetivos disponibles llamando a <code>Physics.OverlapSphere</code> con una posici√≥n de torre y rango como argumentos.  El resultado ser√° una matriz <code>Collider</code> contiene todos los colisionadores en contacto con la esfera.  Si la longitud de la matriz es positiva, entonces hay al menos un punto de punter√≠a, y simplemente seleccionamos el primero.  Tome su componente <code>TargetPoint</code> , que siempre debe existir, <code>TargetPoint</code> al campo objetivo e informe el √©xito.  De lo contrario, despejamos el objetivo e informamos el fallo. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Collider[] targets = Physics.OverlapSphere( transform.localPosition, targetingRange ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (targets.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { target = targets[<span class="hljs-number"><span class="hljs-number">0</span></span>].GetComponent&lt;TargetPoint&gt;(); Debug.Assert(target != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Targeted non-enemy!"</span></span>, targets[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Tenemos la garant√≠a de obtener los puntos de punter√≠a correctos, si tenemos en cuenta los colisionadores solo en la capa de enemigos.  Esta es la capa 9, por lo que pasaremos la m√°scara de capa correspondiente. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> enemyLayerMask = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">9</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Collider[] targets = Physics.OverlapSphere( transform.localPosition, targetingRange, enemyLayerMask ); ‚Ä¶ }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">¬øC√≥mo funciona esta m√°scara de bits?</b> <div class="spoiler_text">  Como la capa enemiga tiene un √≠ndice de 9, el d√©cimo bit de la m√°scara de bits debe tener el valor 1. Esto corresponde a un n√∫mero entero 2 <sup>9</sup> , que es 512. Pero dicho registro de m√°scara de bits no es intuitivo.  Tambi√©n podemos escribir un literal binario, por ejemplo <code>0b10_0000_0000</code> , pero luego tenemos que contar ceros.  En este caso, la entrada m√°s conveniente ser√≠a usar el operador de desplazamiento a la izquierda <code>&lt;&lt;</code> , que desplaza los bits a la izquierda.  que corresponde a un n√∫mero en el poder de dos. </div></div><br>  Puede visualizar el objetivo capturado dibujando una l√≠nea de artilugio entre las posiciones de la torre y el objetivo. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmosSelected</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Gizmos.DrawLine(position, target.Position); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a5/e99/4be/7a5e994be6b7d848c2d4bfe7d627c708.png" width="230" height="230"></div><br>  <i>Visualizaci√≥n de objetivos.</i> <br><br><div class="spoiler">  <b class="spoiler_title">¬øPor qu√© no utilizar m√©todos como OnTriggerEnter?</b> <div class="spoiler_text">  La ventaja de verificar manualmente los objetivos transversales es que solo podemos hacer esto cuando sea necesario.  No hay raz√≥n para buscar objetivos si la torre ya tiene uno.  Adem√°s, al obtener todos los objetivos potenciales a la vez, no tenemos que procesar una lista de objetivos potenciales para cada torre, que cambia constantemente. </div></div><br><h3>  Bloqueo de objetivo </h3><br>  El objetivo elegido para capturar depende del orden en que est√°n representados por el motor f√≠sico, es decir, de hecho, es arbitrario.  Por lo tanto, parecer√° que el objetivo capturado est√° cambiando sin ning√∫n motivo.  Despu√©s de que la torre recibe el objetivo, es m√°s l√≥gico que rastree a su objetivo y no cambie a otro.  Agregue un m√©todo <code>TrackTarget</code> que implemente dicho seguimiento y devuelva informaci√≥n sobre si fue exitoso.  Primero, le informaremos si se captura el objetivo. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Llamaremos a este m√©todo en <code>GameUpdate</code> y solo cuando <code>GameUpdate</code> falso llamaremos a <code>AcquireTarget</code> .  Si el m√©todo devuelve verdadero, entonces tenemos un objetivo.  Esto se puede hacer colocando ambas llamadas de m√©todo en una comprobaci√≥n de <code>if</code> con el operador OR, porque si el primer operando devuelve <code>true</code> , el segundo no se comprobar√° y se perder√° la llamada.  El operador AND act√∫a de manera similar. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TrackTarget() || AcquireTarget()) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Locked on target!"</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ec/27c/0a2/8ec27c0a2201434cba3725621b68aaa1.png" width="230" height="230"></div><br>  <i>Seguimiento de objetivos.</i> <br><br>  Como resultado, las torres se fijan en el objetivo hasta que alcanza el punto final y se destruye.  Si usa enemigos repetidamente, entonces debe verificar la correcci√≥n del enlace, como se hace con los enlaces a las figuras procesadas en una serie de tutoriales de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gesti√≥n</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Objetos</a> . <br><br>  Para rastrear objetivos solo cuando est√°n dentro del alcance, <code>TrackTarget</code> debe rastrear la distancia entre la torre y el objetivo.  Si excede el valor del rango, entonces el objetivo debe restablecerse y devolver falso.  Puede usar el m√©todo <code>Vector3.Distance</code> para esta verificaci√≥n. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } Vector3 a = transform.localPosition; Vector3 b = target.Position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Vector3.Distance(a, b) &gt; targetingRange) { target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Sin embargo, este c√≥digo no tiene en cuenta el radio del colisionador.  Por lo tanto, como resultado, la torre puede perder el objetivo, luego capturarlo nuevamente, solo para dejar de seguirlo en el siguiente cuadro, y as√≠ sucesivamente.  Podemos evitar esto agregando un radio de colisionador al rango. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Vector3.Distance(a, b) &gt; targetingRange + <span class="hljs-number"><span class="hljs-number">0.125f</span></span>) { ‚Ä¶ }</code> </pre> <br>  Esto nos da los resultados correctos, pero solo si la escala del enemigo no cambia.  Como le damos a cada enemigo una escala aleatoria, debemos tenerla en cuenta al cambiar el rango.  Para hacer esto, necesitamos recordar la escala dada por <code>Enemy</code> y abrirla usando la propiedad getter. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Scale { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathOffset</span></span></span><span class="hljs-function">)</span></span> { Scale = scale; ‚Ä¶ }</code> </pre> <br>  Ahora podemos verificar el rango correcto en <code>Tower.TrackTarget</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Vector3.Distance(a, b) &gt; targetingRange + <span class="hljs-number"><span class="hljs-number">0.125f</span></span> * target.Enemy‚Ç¨.Scale) { ‚Ä¶ }</code> </pre> <br><h3>  Sincronizamos f√≠sica </h3><br>  Todo parece estar funcionando bien, pero las torres que pueden apuntar al centro del campo son capaces de capturar objetivos que deber√≠an estar fuera del alcance.  No podr√°n seguir estos objetivos, por lo que se fijan en ellos solo durante un fotograma. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e91/0a1/836/e910a1836ef729d95ebee121a67c3f2c.png" width="230" height="230"></div><br>  <i>Apuntamiento incorrecto.</i> <br><br>  Esto sucede porque el estado del motor f√≠sico est√° imperfectamente sincronizado con el estado del juego.  Las instancias de todos los enemigos se crean en el origen del mundo, que coincide con el centro del campo.  Luego los movemos al punto de creaci√≥n, pero el motor de f√≠sica no lo sabe de inmediato. <br><br>  Puede habilitar la sincronizaci√≥n instant√°nea que ocurre cuando cambia las transformaciones de objetos estableciendo <code>Physics.autoSyncTransforms</code> en <code>true</code> .  Pero por defecto est√° deshabilitado, porque es mucho m√°s eficiente sincronizar todo junto y si es necesario.  En nuestro caso, la sincronizaci√≥n se requiere solo cuando se actualiza el estado de las torres.  Podemos ejecutarlo llamando a <code>Physics.SyncTransforms</code> entre actualizaciones enemigas y de campo en <code>Game.Update</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ enemies.GameUpdate(); Physics.SyncTransforms(); board.GameUpdate(); }</code> </pre> <br><h3>  Ignora la altura </h3><br>  De hecho, nuestra jugabilidad tiene lugar en 2D.  Por lo tanto, cambiemos la <code>Tower</code> para que, al apuntar y seguir, tenga en cuenta solo las coordenadas X y Z. El motor f√≠sico funciona en el espacio 3D, pero en esencia podemos realizar <code>AcquireTarget</code> en 2D: estire la esfera para que cubra todos los colisionadores, independientemente desde su posici√≥n vertical.  Esto se puede hacer usando una c√°psula en lugar de una esfera, cuyo segundo punto estar√° a varias unidades sobre el suelo (por ejemplo, tres). <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a = transform.localPosition; Vector3 b = a; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> += <span class="hljs-number"><span class="hljs-number">3f</span></span>; Collider[] targets = Physics.OverlapCapsule( a, b, targetingRange, enemyLayerMask ); ‚Ä¶ }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øNo es posible usar un motor f√≠sico 2D?</font></font></b> <div class="spoiler_text">   ,       XZ,   2D-    XY.     ,     ,    2D-   .     3D-. </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n es necesario cambiar </font></font><code>TrackTarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Por supuesto, podemos usar vectores 2D y </font></font><code>Vector2.Distance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero hagamos los c√°lculos nosotros mismos y, en su lugar, compararemos los cuadrados de distancias, esto ser√° suficiente. </font><font style="vertical-align: inherit;">Entonces nos deshacemos de la operaci√≥n de calcular la ra√≠z cuadrada.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } Vector3 a = transform.localPosition; Vector3 b = target.Position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = ax - bx; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> z = az - bz; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> r = targetingRange + <span class="hljs-number"><span class="hljs-number">0.125f</span></span> * target.Enemy‚Ç¨.Scale; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x * x + z * z &gt; r * r) { target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øC√≥mo funcionan estos c√°lculos matem√°ticos?</font></font></b> <div class="spoiler_text">     2D-   ,     .     ,       .  ,        ,    . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Evitar la asignaci√≥n de memoria </font></font></h3><br>   <code>Physics.OverlapCapsule</code>   ,        .   ,         <code>OverlapCapsuleNonAlloc</code>      .       .       .        ,      1. <br><br>   <code>OverlapCapsuleNonAlloc</code>    ,    ,          . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Collider[] targetsBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Collider[<span class="hljs-number"><span class="hljs-number">1</span></span>]; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a = transform.localPosition; Vector3 b = a; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> += <span class="hljs-number"><span class="hljs-number">2f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hits = Physics.OverlapCapsuleNonAlloc( a, b, targetingRange, targetsBuffer, enemyLayerMask ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hits &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { target = targetsBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>].GetComponent&lt;TargetPoint&gt;(); Debug.Assert(target != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Targeted non-enemy!"</span></span>, targetsBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><h2>    </h2><br> ,      ,     .    ,     . <br><br><h3>   </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para dirigir la torreta hacia el objetivo, la clase </font></font><code>Tower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">necesita tener un enlace al componente de la </font></font><code>Transform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">torreta. </font><font style="vertical-align: inherit;">Agregue un campo de configuraci√≥n para esto y con√©ctelo a la torre prefabricada.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] Transform turret = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0f/3be/41b/e0f3be41b0936993268316b8f01e1f67.png" width="320" height="90"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La torreta adjunta. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si </font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hay un objetivo real, entonces debemos dispararlo. </font><font style="vertical-align: inherit;">Ponga el c√≥digo de disparo en un m√©todo separado. </font><font style="vertical-align: inherit;">Hazle girar la torreta hacia el objetivo, llamando a su m√©todo </font></font><code>Transform.LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con el punto de punter√≠a como argumento.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TrackTarget() || AcquireTarget()) { <span class="hljs-comment"><span class="hljs-comment">//Debug.Log("Locked on target!"); Shoot(); } } void Shoot () { Vector3 point = target.Position; turret.LookAt(point); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00e/5bb/e9d/00e5bbe9d98e739800bf47435ca574af.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solo apuntando.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Disparamos un laser </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para posicionar el rayo l√°ser, la clase </font></font><code>Tower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tambi√©n necesita un enlace.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] Transform turret = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, laserBeam = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/802/c9c/86e/802c9c86eac24112cb2b4f072fd0f410.png" width="320" height="110"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conectamos un rayo l√°ser. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para convertir un cubo en un rayo l√°ser real, debe seguir tres pasos. </font><font style="vertical-align: inherit;">En primer lugar, su orientaci√≥n debe corresponder a la orientaci√≥n de la torreta. </font><font style="vertical-align: inherit;">Esto se puede hacer copiando su rotaci√≥n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shoot</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 point = target.Position; turret.LookAt(point); laserBeam.localRotation = turret.localRotation; }</code> </pre> <br> -     ,               .      Z,    ,    .      XY,      (Awake) . <br><br><pre> <code class="cs hljs"> Vector3 laserBeamScale; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { laserBeamScale = laserBeam.localScale; } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shoot</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 point = target.Position; turret.LookAt(point); laserBeam.localRotation = turret.localRotation; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d = Vector3.Distance(turret.position, point); laserBeamScale.z = d; laserBeam.localScale = laserBeamScale; }</code> </pre> <br> -,         . <br><br><pre> <code class="cs hljs"> laserBeam.localScale = laserBeamScale; laserBeam.localPosition = turret.localPosition + <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * d * laserBeam.forward;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/288/d96/438/288d96438354bd732fd7a3bb84ead491.png" width="230" height="230"></div><br> <i>  .</i> <br><br><div class="spoiler"> <b class="spoiler_title">       ?</b> <div class="spoiler_text">     ,         ,       forward.       ,     .     . </div></div><br>  ,     .    ,   .     ,     <code>GameUpdate</code>  0. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TrackTarget() || AcquireTarget()) { Shoot(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { laserBeam.localScale = Vector3.zero; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39b/8c8/c23/39b8c8c239e0936137c646f91a4197de.png" width="230" height="230"></div><br> <i>   .</i> <br><br><h3>   </h3><br>              .   ,     .      ,   <code>Enemy</code>  .       ,    100.   ,       ,     . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Health { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathOffset</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Health = <span class="hljs-number"><span class="hljs-number">100f</span></span> * scale; }</code> </pre> <br>     ,    <code>ApplyDamage</code> ,     .   ,   ,     . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplyDamage</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> damage</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(damage &gt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-string"><span class="hljs-string">"Negative damage applied."</span></span>); Health -= damage; }</code> </pre> <br>       ,      .           <code>GameUpdate</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Health &lt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { OriginFactory.Reclaim(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } ‚Ä¶ }</code> </pre> <br>         ,    ,       ,     ,     . <br><br><h3>    </h3><br>    ,     .     <code>Tower</code>  .       ,        (damage per second).  <code>Shoot</code>     <code>Enemy</code>      . <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(1f, 100f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> damagePerSecond = <span class="hljs-number"><span class="hljs-number">10f</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shoot</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ target.Enemy.ApplyDamage(damagePerSecond * Time.deltaTime); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/886/18f/199/88618f199c9c08e7eaeb89b16083f545.png" width="320" height="128" alt="inspector"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gk/vt/sf/gkvtsfa1ya4igbsjagqhtnzu0wq.gif"></div><br> <i>   ‚Äî 20   .</i> <br><br><h3>    </h3><br>        ,     ,       .     ,      ,    ,         .       ,     . <br><br>  ,      ,    .   ,     ,   100. ,              ,       . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Collider[] targetsBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Collider[<span class="hljs-number"><span class="hljs-number">100</span></span>];</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora, en lugar de elegir el primer objetivo potencial, seleccionaremos un elemento aleatorio de la matriz. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hits &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { target = targetsBuffer[Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, hits)].GetComponent&lt;TargetPoint&gt;(); ‚Ä¶ } target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nv/lt/hi/nvlthij_ixh6lsxgwujtoipjwg4.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apuntando al azar.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øSe pueden utilizar otros criterios para elegir objetivos?</font></font></b> <div class="spoiler_text"> , ,        .  ,      ,     .    .             . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces, en nuestro juego de defensa de la torre, las torres finalmente han aparecido. </font><font style="vertical-align: inherit;">En la siguiente parte, el juego tomar√° su forma final a√∫n m√°s.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/459070/">https://habr.com/ru/post/459070/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459052/index.html">C√≥mo comparar: "coche incre√≠ble" y "choza fea", en una encuesta de marketing y en Big Data</a></li>
<li><a href="../459054/index.html">Mapa de calor de clics: c√≥mo se comportan los usuarios en el sitio</a></li>
<li><a href="../459062/index.html">El resumen de materiales interesantes para el desarrollador m√≥vil # 305 (del 1 al 7 de julio)</a></li>
<li><a href="../459066/index.html">Balance de escritura y lectura de bases de datos</a></li>
<li><a href="../459068/index.html">Windows Server 2008 R2 - El rey est√° muerto, viva el rey</a></li>
<li><a href="../459074/index.html">Petty little joy # 7: tres por el precio de uno: animaci√≥n de consola, algoritmos y depuraci√≥n</a></li>
<li><a href="../459078/index.html">CERN cambia a software de c√≥digo abierto, ¬øpor qu√©?</a></li>
<li><a href="../459080/index.html">Caracter√≠sticas HttpUrlConnection de java.net</a></li>
<li><a href="../459082/index.html">¬øQui√©nes son los eid√©ticos, c√≥mo funcionan los recuerdos falsos y tres mitos populares sobre la memoria?</a></li>
<li><a href="../459084/index.html">Un poco sobre Google Home Hub, o c√≥mo compr√© un marco de fotos por 130 euros</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>