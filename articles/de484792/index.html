<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛴 📼 🥞 Optimierung von 3D-Modellen für die Spielszene 🆚 👨🏾‍🍳 🈯️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel vervollständigt eine Reihe von Veröffentlichungen aus dem Krasnodar-Studio Plarium zu verschiedenen Aspekten der Arbeit mit 3D-Modellen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimierung von 3D-Modellen für die Spielszene</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/plarium/blog/484792/">  Dieser Artikel vervollständigt eine Reihe von Veröffentlichungen aus dem Krasnodar-Studio Plarium zu verschiedenen Aspekten der Arbeit mit 3D-Modellen in Unity.  Vorherige Artikel: <a href="https://habr.com/ru/company/plarium/blog/440690/">„Funktionen für die Arbeit mit Mesh in Unity“</a> , <a href="https://habr.com/ru/company/plarium/blog/443870/">„Unity: Prozedurale Bearbeitung von Mesh“</a> , <a href="https://habr.com/ru/company/plarium/blog/447820/">„Import von 3D-Modellen in Unity und Fallstricke“</a> , <a href="https://habr.com/ru/company/plarium/blog/451794/">„Pixeleinzug beim Scannen von Texturen“</a> . <br><br>  Vor fast 2 Jahren haben wir <a href="https://habr.com/ru/company/plarium/blog/348494/">einen Artikel geschrieben,</a> in dem wir über die Möglichkeit der Optimierung der 3D-Geometrie in einer Szene mit Einschränkungen des Kamerawinkels und der Drehung der entsprechenden Objekte gesprochen haben.  Seitdem ist nicht viel passiert, aber die Möglichkeit, die Lösung zu verbessern, verschiedene Ansätze in Betracht zu ziehen und andere auszuspionieren, beschäftigt die Entwickler.  In diesem Artikel beschreiben wir eine verbesserte Version des Algorithmus, der auf dem Zeichnen von Polygonen basiert, sowie den Versuch, einen Teil dieser Arbeit auf ein 3D-Paket zu übertragen. <br><br><img src="https://habrastorage.org/webt/jl/v-/pz/jlv-pzi5qagnnmqhgkqaddzo1uo.jpeg"><a name="habracut"></a><br><br><h3>  In der Szene zuschneiden </h3><br>  Das Grundprinzip dieses Algorithmus haben wir bereits im obigen Artikel betrachtet: Wir löschen alle Effekte und transparenten Objekte, malen unverarbeitete Polygone mit einer Farbe und verarbeiten sie mit anderen, rendern und extrahieren das Ergebnis.  In der alten Version wurde so gemalt, dass alles Schwarz überflüssig war und nur ein Dreieck rot markiert war. <br><br>  <a href="https://habr.com/ru/company/plarium/blog/348494/">In den Kommentaren</a> zu diesem Artikel wies einer der Leser auf die Möglichkeit hin, den Algorithmus zu optimieren, indem eine Eins-zu-Eins-Entsprechung zwischen der Menge von Polygonen und einer Menge von eindeutigen Zahlen hergestellt wird.  Dann ist es möglich, mehr als ein Dreieck auf die gleiche Weise zu verarbeiten.  Betrachten Sie diese Option. <br><br>  In diesem Fall und beim letzten Mal sollte ein Teil des Vortrainings mit der Deaktivierung aller pfeifenden Objekte auf der Bühne und von Objekten verbunden sein, von denen garantiert wird, dass sie die Sichtbarkeit des Zielmodells nicht beeinträchtigen.  Kameraansichten werden fast unabhängig voneinander verarbeitet und nur durch einen gemeinsamen Indexpuffer aus sichtbaren Polygonen verbunden.  Zusätzlich wird für jeden Winkel eine Geometrievorbearbeitung durchgeführt, bei der Polygone gedreht werden, die zurück zur Kamera ( <b>Rückseite</b> ) gedreht werden.  Dies geschieht, weil in einer bestimmten Phase des Algorithmus ein temporäres Netz mit einer erheblich größeren Anzahl von Scheitelpunkten als dem ursprünglichen erstellt wird.  Diese Zahl kann den Schwellenwert von 65.535 leicht überschreiten, was zusätzliche Gesten in den Berechnungen erfordert und zu einer verringerten Leistung führt.  In jedem Fall werden diese Polygone gelöscht, da ihre Farbe nicht in den Rahmen fällt.  Aufgrund der Tatsache, dass jedes Dreieck möglicherweise drei Garbage Vertices erzeugt, erleichtert die vorherige Eliminierung unnötiger Polygone die Hauptphase des Algorithmus und senkt die Speicherkosten. <br><br>  Es gebe ein 3D-Modell, dessen Geometrie durch ein Netz dargestellt wird.  Um ein bestimmtes Polygon in einer eindeutigen Farbe zu zeichnen, müssen Sie alle Scheitelpunkte in dieser Farbe zeichnen.  Da im allgemeinen Fall ein Knoten zu verschiedenen Polygonen gehören kann, ist es nicht möglich, das Problem direkt zu lösen.  Unabhängig davon, wie wir einen Scheitelpunkt färben, kriecht seine Farbe beim Rendern gemäß dem Interpolationsalgorithmus auf der Seite der Grafikkarte über alle Dreiecke, deren Eigentümer er ist. <br><br><img src="https://habrastorage.org/webt/ay/td/qo/aytdqo0ah1fzsl7pcasymag9rf8.jpeg"><br>  <i>Ein Beispiel für die Farbinterpolation bei der Anzeige von Polygonen mit gemeinsamen Eckpunkten</i> <br><br>  Aus diesem Grund ist es notwendig, das Netz in separate unabhängige Polygone zu unterteilen und dabei die Topologie und Geometrie des Objekts beizubehalten.  Dictum factum.  Wir transformieren die Arrays von Dreiecken und Scheitelpunkten so, dass für jedes Dreieck 3 eindeutige Scheitelpunkte erstellt werden, deren Position durch die entsprechenden Scheitelpunkte des ursprünglichen Netzes bestimmt wird.  Es ist anzumerken, dass ein solches Netz im allgemeinen Fall eine bedeutend größere Anzahl von Eckpunkten aufweist als das Original.  Wenn diese Zahl 65.535 überschreitet, müssen Sie beim Erstellen des Netzes das entsprechende Indizierungsformat angeben. <br><br><div class="spoiler">  <b class="spoiler_title">Konvertieren Sie das ursprüngliche Netz in ein Netz mit Scheitelpunkten, die für jedes Polygon eindeutig sind</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Mesh </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNotSmoothMesh</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Mesh origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oVertices = origin.vertices; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oTriangles = origin.triangles; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3[oTriangles.Length]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> triangles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[oTriangles.Length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; triangles.Length; i++) { vertices[i] = oVertices[oTriangles[i]]; triangles[i] = i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh() { indexFormat = vertices.Length &gt; <span class="hljs-number"><span class="hljs-number">65535</span></span> ? IndexFormat.UInt32 : IndexFormat.UInt16, vertices = vertices, triangles = triangles }; }</code> </pre> <br></div></div><br>  Nun müssen Sie die Polygone dieses Netzes bestimmen, damit nach dem Rendern festgestellt werden kann, welches auf dem Bildschirm angezeigt wird.  Wie bereits erwähnt, generieren wir eindeutige Farben für Polygone und malen jeweils drei Scheitelpunkte in der entsprechenden Farbe.  Das Ergebnis ist ein neues Netz, das wir <b>Byte-Colored Mesh nennen</b> . <br><br><img src="https://habrastorage.org/webt/jl/l0/co/jll0coliukddunmhl5kizfzwpzq.jpeg"><br>  <i><b>Byte-farbiges Netz</b></i> <br><br><div class="spoiler">  <b class="spoiler_title">Maschenfärbung, bei der jeder Scheitelpunkt nur zu einem Polygon gehört</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ColorizePolygons</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Mesh mesh</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pColors = ColorsOfPolygons(mesh); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color[mesh.vertexCount]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; colors.Length; i++) { colors[i] = pColors[i / <span class="hljs-number"><span class="hljs-number">3</span></span>]; } mesh.colors = colors; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Color[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetColorsOfPolygons</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Mesh mesh</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color[mesh.triangles.Length / <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; colors.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> color = Int2Color(i);<span class="hljs-comment"><span class="hljs-comment">//         ,     Color2Int //      ,       int     Color32 colors[i] = color; } return colors; }</span></span></code> </pre> <br></div></div><br>  Erinnere dich an die Färbung.  Es ist Zeit zu rendern.  Wir führen für alle Kamerawinkel ein 3D-Rendering durch und füllen bei jeder Verarbeitung den Puffer mit eindeutigen Polygonindizes auf, deren Farben im Rahmen erkannt wurden.  Während der Berechnungen für die Kamera müssen Sie das Anti-Aliasing deaktivieren, um das Auftreten neuer Farben aufgrund der Interpolation benachbarter Pixel zu vermeiden. <br><br><div class="spoiler">  <b class="spoiler_title">Lesen und Speichern von Farben aus verschiedenen Kamerawinkeln</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// CameraTransform —         //      SetCameraTransform private static HashSet&lt;Color&gt; GetVisibleColors(Camera camera, CameraTransform[] cameraTransforms) { var renderTexture = new RenderTexture(1920, 1080, 24);//for example var rtRect = new Rect(0, 0, renderTexture.width, renderTexture.height); var frame = new Texture2D(renderTexture.width, renderTexture.height, TextureFormat.RGB24, false);//    -  RGB24   ,    RGBA32 var visibleColorsSet = new HashSet&lt;Color&gt;(); foreach (var cameraTransform in cameraTransforms) { SetCameraTransform(camera, cameraTransform); CreateScreenShot(camera, renderTexture, frame, rtRect); visibleColorsSet.UnionWith(GetTextureColors(frame)); } return visibleColorsSet; } public static void SetCameraTransform(Camera camera, CameraTransform camTransform) { camera.transform.position = camTransform.Position; camera.transform.rotation = camTransform.Rotation; camera.fieldOfView = camTransform.FieldOfView; camera.orthographic = camTransform.IsOrthographic; camera.nearClipPlane = camTransform.NearClippingPlane; camera.farClipPlane = camTransform.FarClippingPlane; } private static HashSet&lt;Color&gt; GetTextureColors(Texture2D texture) { return new HashSet&lt;Color&gt;(texture.GetPixels()); } private static void CreateScreenShot(Camera cam, RenderTexture renderTexture, Texture2D screenShot, Rect renderTextureRect) { cam.targetTexture = renderTexture; cam.Render(); RenderTexture.active = cam.targetTexture; screenShot.ReadPixels(renderTextureRect, 0, 0); RenderTexture.active = null; cam.targetTexture = null; } }</span></span></code> </pre> <br></div></div><br>  Es ist erwähnenswert, dass aufgrund der Diskretisierung einige Dreiecke aufgrund der besonders geringen Größe ihrer Projektion auf den Bildschirm möglicherweise nicht angezeigt werden und nicht, weil sich etwas mit ihnen überlappt oder sie auf der falschen Seite gedreht sind.  Wir haben eine konservative Version des Algorithmus implementiert.  In diesem Fall wird die <b>AABB der</b> Projektion des Dreiecks auf dem Bildschirm berechnet, und wenn mindestens eine seiner Seiten kleiner als die Texelseite im Bild ist, wird ein solches Polygon als sichtbar markiert.  Dieser Ansatz schützt vor Artefakten, wenn der Algorithmus mit einer Auflösung ausgeführt wird, die geringer ist als die Bildschirmauflösung des Zielgeräts.  Wenn Sie kleine Polygone ignorieren, ist das Ergebnis auch akzeptabel, vorausgesetzt, die Auflösung der verwendeten Rendertextur ist höher als die Auflösung der Bildschirme der vorgesehenen Geräte. <br><br>  Wir haben diesen Beschneidungsalgorithmus in <b>Unity</b> implementiert und verwenden ihn, um statische Objekte zu optimieren, deren Modelle in der Szene mehrmals an verschiedenen Positionen gefunden werden.  Dies ist hauptsächlich die Szenerie: Steine, Bäume, Statuen, Vasen usw., die sich auf das häufig verwendete Fertighaus bezieht.  Wir möchten solche Objekte bereits in der Phase der Erstellung eines 3D-Pakets optimieren, aber wer weiß, in welcher phantasmagorischen Pose der Leveldesigner seinen Lieblingskandelaber platzieren möchte. <br><br>  Das Trimmen der <b>Objektmenge</b> desselben Typs mit einem solchen Werkzeug verringert die Größe der Szene, da während des <b>statischen Stapelns die</b> Daten des gemeinsamen <b>vorgefertigten</b> Netzes sowieso in der Erstellungsphase so oft kopiert werden, wie die aktiven gezeichneten Objekte mit diesem Netz in der Szene dargestellt werden.  Unsere Methode gibt auch Speicherplatz in <b>Texturatlanten</b> wie <b>Lightmap frei</b> .  Wir nutzen den gesparten Platz, um die Details der Teile der Modelle zu verbessern, die die Reinigung überstanden haben. <br><br><h3>  3D-Ernte </h3><br>  Trotzdem ist es besser, wenn der Künstler in seinem Editor alles Unnötige abschneidet und dadurch die Anzahl der Stufen der Inhaltserstellung verringert.  Dies ist gerechtfertigt, wenn das Modell in einer Szene mit nur einer vorgegebenen Drehung relativ zur Kamera verwendet wird.  Zuvor wurden Objekte, die dem Benutzer von einer Seite genau zugewandt waren, häufig manuell vereinfacht, bevor sie in das Projekt integriert wurden.  Es ist wichtig zu beachten, dass die programmgesteuerte Implementierung einer solchen Vereinfachung in <b>Unity</b> aufgrund der Komplexität der <b>UV-</b> Verpackungsentwicklung sehr viel schwieriger ist. <b>Daher</b> erleichtert die Automatisierung auf der Stufe eines 3D-Pakets einem Künstler manchmal das Leben. <br><br>  Eines der Werkzeuge für die Arbeit mit 3D-Modellen in unserem Unternehmen ist <b>Blender</b> .  Wir stiegen hinein.  Es scheint, dass eine solche "erwachsene" Software, wie <b>Blender</b> , eine ähnliche Funktionalität haben sollte.  Es stellte sich jedoch heraus, dass er nicht sollte.  Ich musste mein eigenes Fahrrad sehen. <br><br>  Die erste Idee war, das vertraute Auswahlwerkzeug zu verwenden - im Wesentlichen einen Teil der manuellen Arbeit des Künstlers für einen Kamerawinkel zu wiederholen: sichtbare Polygone auswählen, Auswahl umkehren, löschen.  Der Plan war: Bewegen Sie die Kamera, bestimmen Sie die <b>AABB-</b> Projektion des Modells an jeder Position, fordern Sie dann das Ergebnis der Auswahl der Polygone des Bereichs an, der dem <b>AABB entspricht</b> , ermitteln Sie die Vereinigung der Polygonsätze der aktuellen Ansicht mit den vorherigen und löschen Sie am Ende nicht ausgewählte Polygone. <br><br>  Bei der Implementierung des Skripts wurde jedoch ein erheblicher Nachteil in Bezug auf die Aufgabe festgestellt.  Auswahlwerkzeuge in <b>Blender (Rechteckauswahl, Kreisauswahl)</b> <a href="https://blender.stackexchange.com/questions/43886/why-wont-lasso-or-box-select-select-all-of-the-faces-in-the-region/93482">verlieren</a> mit zunehmender Anzahl der ausgewählten Elemente pro Flächeneinheit des Bildschirms <a href="https://blender.stackexchange.com/questions/43886/why-wont-lasso-or-box-select-select-all-of-the-faces-in-the-region/93482">an Genauigkeit</a> (einige Polygone bleiben nicht ausgewählt), was ihre Verwendung in unseren Automatisierungswerkzeugen unmöglich macht.  Interessante Tatsache: In <b>3ds Max wird ein</b> solches Problem nicht beobachtet. <br><br><img src="https://habrastorage.org/webt/ai/rr/bf/airrbf1enz0jfiucjtrhrbzv8bw.jpeg"><br>  <i>Hervorheben aus der Ferne in <b>Blender</b></i> <br><br><img src="https://habrastorage.org/webt/gt/vy/mh/gtvymh56yk7vp5lrwsvuav4fjqq.jpeg"><br>  <i>Auswahlergebnis</i> <br><br>  Der nächste Versuch zielte darauf ab, das Problem auf der Stirn zu lösen: Wir sendeten Strahlen von der Kamera durch jedes Pixel des Ansichtsfensters und schauten, welche Polygone sich als erste mit mindestens einem Strahl schneiden.  Wir haben nicht auf genaue Ergebnisse mit diesem Ansatz gehofft, aber es war einen Versuch wert.  Das Ergebnis ist offensichtlich: Sehr geringe Produktivität bei der Verarbeitung auf der <b>CPU</b> oder den gleichen Löchern mit einer geringen Anzahl von Strahlen. <br><br>  Trotzdem haben wir uns für die Umsetzung eines weiter fortgeschrittenen Ansatzes eingesetzt.  Die Idee war, eine bestimmte Anzahl zufälliger Punkte auf jedem Polygon auszuwählen und dann Strahlen von der Kamera in ihre Richtung zu senden.  Dieser Ansatz hat gut funktioniert, aber wir hatten einige Grenzfälle: Es wurden auch Polygone abgeschnitten, bei denen der Winkel zwischen dem Strahl und ihrer Normalen ungefähr π / 2 betrug.  Wenn die Kamera aufgrund von perspektivischen Verzerrungen zoomt, können sich daher ausgeschnittene Bereiche öffnen. <br><br>  Diese Methode war nach Meinung der Künstler zu aggressiv, sodass wir uns darauf konzentrierten, nur die <b>Rückflächen zu beschneiden</b> . <br><br><h3>  Fazit </h3><br>  Es ist kein Geheimnis, dass ein sorgfältiger Umgang mit den Ressourcen des Geräts beim Erstellen von Spielen der wichtigste Faktor ist, der die Qualität des Endprodukts beeinflusst.  Dies gilt insbesondere für mobile Plattformen, die auf die aktive Nutzung des Arbeitsspeichers eingestellt sind.  Wenn Sie die Anzahl der Polygone verringern, können Sie den Bereich der Texturatlanten effektiver ausfüllen und die Rechenlast etwas verringern. <br><br>  Vergessen Sie auch nicht die Personalkosten und die Fehlerkosten, wenn Sie die oben beschriebenen Werkzeuge und dergleichen verwenden.  Der vorgeschlagene Ansatz setzt eine gut funktionierende Pipeline für die Arbeit der Kunstabteilung voraus, insbesondere für Mitarbeiter, die an der Integration von Modellen in das Projekt beteiligt sind. <br><br>  Mit den in diesem Artikel beschriebenen Bedingungen und Tools halten wir uns daher an die folgenden Regeln.  Wenn davon ausgegangen wird, dass das erstellte Modell immer von einer Seite zum Benutzer gedreht wird und auch wenn aus diesen Winkeln die Überlappung einiger Teile des Modells durch andere recht gering ist, verwendet der Künstler unseren <b>Rückflächentrimmer</b> in einem 3D-Editor, überprüft die Richtigkeit und fährt mit der <b>UV-</b> Verpackungsentwicklung fort .  Wenn das Modell häufig an verschiedenen Positionen verwendet wird oder eine komplexere Geometrie aufweist, führen Sie nach dem Import in das Projekt den im ersten Teil des Artikels beschriebenen Algorithmus aus und verarbeiten damit alle statischen Objekte in der Szene. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de484792/">https://habr.com/ru/post/de484792/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de484776/index.html">Digitale Veranstaltungen in St. Petersburg vom 21. bis 26. Januar</a></li>
<li><a href="../de484778/index.html">Intel Parallel Studio XE 2020: alles Gute für Entwickler</a></li>
<li><a href="../de484782/index.html">Blazor Client Side Online-Shop: Teil 2 - CI / CD</a></li>
<li><a href="../de484788/index.html">Weitere Funktionen für Ihr System: Telefonie-Integration und CRM / ERP / Helpdesk. Was, wie und warum?</a></li>
<li><a href="../de484790/index.html">Die Geschichte, wie aufgrund einer Option unter Server Windows unsere Websites langsamer wurden</a></li>
<li><a href="../de484796/index.html">Wie habe ich die OSWE-Zertifizierung erhalten?</a></li>
<li><a href="../de484798/index.html">Warum ist das schnelle Sortieren so langsam? Neue Array-Sortiermethode</a></li>
<li><a href="../de484800/index.html">Microsoft Application Inspector-Quellcodeanalyse</a></li>
<li><a href="../de484802/index.html">Selbstzerstörungsmodus: Zersetzung der endoskopischen Kapsel durch Licht</a></li>
<li><a href="../de484804/index.html">Was muss in einem Unternehmenssystem verschlüsselt werden? Und warum das machen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>