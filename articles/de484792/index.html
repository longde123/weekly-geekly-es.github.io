<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ¥ üìº ü•û Optimierung von 3D-Modellen f√ºr die Spielszene üÜö üë®üèæ‚Äçüç≥ üàØÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel vervollst√§ndigt eine Reihe von Ver√∂ffentlichungen aus dem Krasnodar-Studio Plarium zu verschiedenen Aspekten der Arbeit mit 3D-Modellen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimierung von 3D-Modellen f√ºr die Spielszene</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/plarium/blog/484792/">  Dieser Artikel vervollst√§ndigt eine Reihe von Ver√∂ffentlichungen aus dem Krasnodar-Studio Plarium zu verschiedenen Aspekten der Arbeit mit 3D-Modellen in Unity.  Vorherige Artikel: <a href="https://habr.com/ru/company/plarium/blog/440690/">‚ÄûFunktionen f√ºr die Arbeit mit Mesh in Unity‚Äú</a> , <a href="https://habr.com/ru/company/plarium/blog/443870/">‚ÄûUnity: Prozedurale Bearbeitung von Mesh‚Äú</a> , <a href="https://habr.com/ru/company/plarium/blog/447820/">‚ÄûImport von 3D-Modellen in Unity und Fallstricke‚Äú</a> , <a href="https://habr.com/ru/company/plarium/blog/451794/">‚ÄûPixeleinzug beim Scannen von Texturen‚Äú</a> . <br><br>  Vor fast 2 Jahren haben wir <a href="https://habr.com/ru/company/plarium/blog/348494/">einen Artikel geschrieben,</a> in dem wir √ºber die M√∂glichkeit der Optimierung der 3D-Geometrie in einer Szene mit Einschr√§nkungen des Kamerawinkels und der Drehung der entsprechenden Objekte gesprochen haben.  Seitdem ist nicht viel passiert, aber die M√∂glichkeit, die L√∂sung zu verbessern, verschiedene Ans√§tze in Betracht zu ziehen und andere auszuspionieren, besch√§ftigt die Entwickler.  In diesem Artikel beschreiben wir eine verbesserte Version des Algorithmus, der auf dem Zeichnen von Polygonen basiert, sowie den Versuch, einen Teil dieser Arbeit auf ein 3D-Paket zu √ºbertragen. <br><br><img src="https://habrastorage.org/webt/jl/v-/pz/jlv-pzi5qagnnmqhgkqaddzo1uo.jpeg"><a name="habracut"></a><br><br><h3>  In der Szene zuschneiden </h3><br>  Das Grundprinzip dieses Algorithmus haben wir bereits im obigen Artikel betrachtet: Wir l√∂schen alle Effekte und transparenten Objekte, malen unverarbeitete Polygone mit einer Farbe und verarbeiten sie mit anderen, rendern und extrahieren das Ergebnis.  In der alten Version wurde so gemalt, dass alles Schwarz √ºberfl√ºssig war und nur ein Dreieck rot markiert war. <br><br>  <a href="https://habr.com/ru/company/plarium/blog/348494/">In den Kommentaren</a> zu diesem Artikel wies einer der Leser auf die M√∂glichkeit hin, den Algorithmus zu optimieren, indem eine Eins-zu-Eins-Entsprechung zwischen der Menge von Polygonen und einer Menge von eindeutigen Zahlen hergestellt wird.  Dann ist es m√∂glich, mehr als ein Dreieck auf die gleiche Weise zu verarbeiten.  Betrachten Sie diese Option. <br><br>  In diesem Fall und beim letzten Mal sollte ein Teil des Vortrainings mit der Deaktivierung aller pfeifenden Objekte auf der B√ºhne und von Objekten verbunden sein, von denen garantiert wird, dass sie die Sichtbarkeit des Zielmodells nicht beeintr√§chtigen.  Kameraansichten werden fast unabh√§ngig voneinander verarbeitet und nur durch einen gemeinsamen Indexpuffer aus sichtbaren Polygonen verbunden.  Zus√§tzlich wird f√ºr jeden Winkel eine Geometrievorbearbeitung durchgef√ºhrt, bei der Polygone gedreht werden, die zur√ºck zur Kamera ( <b>R√ºckseite</b> ) gedreht werden.  Dies geschieht, weil in einer bestimmten Phase des Algorithmus ein tempor√§res Netz mit einer erheblich gr√∂√üeren Anzahl von Scheitelpunkten als dem urspr√ºnglichen erstellt wird.  Diese Zahl kann den Schwellenwert von 65.535 leicht √ºberschreiten, was zus√§tzliche Gesten in den Berechnungen erfordert und zu einer verringerten Leistung f√ºhrt.  In jedem Fall werden diese Polygone gel√∂scht, da ihre Farbe nicht in den Rahmen f√§llt.  Aufgrund der Tatsache, dass jedes Dreieck m√∂glicherweise drei Garbage Vertices erzeugt, erleichtert die vorherige Eliminierung unn√∂tiger Polygone die Hauptphase des Algorithmus und senkt die Speicherkosten. <br><br>  Es gebe ein 3D-Modell, dessen Geometrie durch ein Netz dargestellt wird.  Um ein bestimmtes Polygon in einer eindeutigen Farbe zu zeichnen, m√ºssen Sie alle Scheitelpunkte in dieser Farbe zeichnen.  Da im allgemeinen Fall ein Knoten zu verschiedenen Polygonen geh√∂ren kann, ist es nicht m√∂glich, das Problem direkt zu l√∂sen.  Unabh√§ngig davon, wie wir einen Scheitelpunkt f√§rben, kriecht seine Farbe beim Rendern gem√§√ü dem Interpolationsalgorithmus auf der Seite der Grafikkarte √ºber alle Dreiecke, deren Eigent√ºmer er ist. <br><br><img src="https://habrastorage.org/webt/ay/td/qo/aytdqo0ah1fzsl7pcasymag9rf8.jpeg"><br>  <i>Ein Beispiel f√ºr die Farbinterpolation bei der Anzeige von Polygonen mit gemeinsamen Eckpunkten</i> <br><br>  Aus diesem Grund ist es notwendig, das Netz in separate unabh√§ngige Polygone zu unterteilen und dabei die Topologie und Geometrie des Objekts beizubehalten.  Dictum factum.  Wir transformieren die Arrays von Dreiecken und Scheitelpunkten so, dass f√ºr jedes Dreieck 3 eindeutige Scheitelpunkte erstellt werden, deren Position durch die entsprechenden Scheitelpunkte des urspr√ºnglichen Netzes bestimmt wird.  Es ist anzumerken, dass ein solches Netz im allgemeinen Fall eine bedeutend gr√∂√üere Anzahl von Eckpunkten aufweist als das Original.  Wenn diese Zahl 65.535 √ºberschreitet, m√ºssen Sie beim Erstellen des Netzes das entsprechende Indizierungsformat angeben. <br><br><div class="spoiler">  <b class="spoiler_title">Konvertieren Sie das urspr√ºngliche Netz in ein Netz mit Scheitelpunkten, die f√ºr jedes Polygon eindeutig sind</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Mesh </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNotSmoothMesh</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Mesh origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oVertices = origin.vertices; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oTriangles = origin.triangles; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3[oTriangles.Length]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> triangles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[oTriangles.Length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; triangles.Length; i++) { vertices[i] = oVertices[oTriangles[i]]; triangles[i] = i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh() { indexFormat = vertices.Length &gt; <span class="hljs-number"><span class="hljs-number">65535</span></span> ? IndexFormat.UInt32 : IndexFormat.UInt16, vertices = vertices, triangles = triangles }; }</code> </pre> <br></div></div><br>  Nun m√ºssen Sie die Polygone dieses Netzes bestimmen, damit nach dem Rendern festgestellt werden kann, welches auf dem Bildschirm angezeigt wird.  Wie bereits erw√§hnt, generieren wir eindeutige Farben f√ºr Polygone und malen jeweils drei Scheitelpunkte in der entsprechenden Farbe.  Das Ergebnis ist ein neues Netz, das wir <b>Byte-Colored Mesh nennen</b> . <br><br><img src="https://habrastorage.org/webt/jl/l0/co/jll0coliukddunmhl5kizfzwpzq.jpeg"><br>  <i><b>Byte-farbiges Netz</b></i> <br><br><div class="spoiler">  <b class="spoiler_title">Maschenf√§rbung, bei der jeder Scheitelpunkt nur zu einem Polygon geh√∂rt</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ColorizePolygons</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Mesh mesh</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pColors = ColorsOfPolygons(mesh); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color[mesh.vertexCount]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; colors.Length; i++) { colors[i] = pColors[i / <span class="hljs-number"><span class="hljs-number">3</span></span>]; } mesh.colors = colors; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Color[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetColorsOfPolygons</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Mesh mesh</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color[mesh.triangles.Length / <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; colors.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> color = Int2Color(i);<span class="hljs-comment"><span class="hljs-comment">//         ,     Color2Int //      ,       int     Color32 colors[i] = color; } return colors; }</span></span></code> </pre> <br></div></div><br>  Erinnere dich an die F√§rbung.  Es ist Zeit zu rendern.  Wir f√ºhren f√ºr alle Kamerawinkel ein 3D-Rendering durch und f√ºllen bei jeder Verarbeitung den Puffer mit eindeutigen Polygonindizes auf, deren Farben im Rahmen erkannt wurden.  W√§hrend der Berechnungen f√ºr die Kamera m√ºssen Sie das Anti-Aliasing deaktivieren, um das Auftreten neuer Farben aufgrund der Interpolation benachbarter Pixel zu vermeiden. <br><br><div class="spoiler">  <b class="spoiler_title">Lesen und Speichern von Farben aus verschiedenen Kamerawinkeln</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// CameraTransform ‚Äî         //      SetCameraTransform private static HashSet&lt;Color&gt; GetVisibleColors(Camera camera, CameraTransform[] cameraTransforms) { var renderTexture = new RenderTexture(1920, 1080, 24);//for example var rtRect = new Rect(0, 0, renderTexture.width, renderTexture.height); var frame = new Texture2D(renderTexture.width, renderTexture.height, TextureFormat.RGB24, false);//    -  RGB24   ,    RGBA32 var visibleColorsSet = new HashSet&lt;Color&gt;(); foreach (var cameraTransform in cameraTransforms) { SetCameraTransform(camera, cameraTransform); CreateScreenShot(camera, renderTexture, frame, rtRect); visibleColorsSet.UnionWith(GetTextureColors(frame)); } return visibleColorsSet; } public static void SetCameraTransform(Camera camera, CameraTransform camTransform) { camera.transform.position = camTransform.Position; camera.transform.rotation = camTransform.Rotation; camera.fieldOfView = camTransform.FieldOfView; camera.orthographic = camTransform.IsOrthographic; camera.nearClipPlane = camTransform.NearClippingPlane; camera.farClipPlane = camTransform.FarClippingPlane; } private static HashSet&lt;Color&gt; GetTextureColors(Texture2D texture) { return new HashSet&lt;Color&gt;(texture.GetPixels()); } private static void CreateScreenShot(Camera cam, RenderTexture renderTexture, Texture2D screenShot, Rect renderTextureRect) { cam.targetTexture = renderTexture; cam.Render(); RenderTexture.active = cam.targetTexture; screenShot.ReadPixels(renderTextureRect, 0, 0); RenderTexture.active = null; cam.targetTexture = null; } }</span></span></code> </pre> <br></div></div><br>  Es ist erw√§hnenswert, dass aufgrund der Diskretisierung einige Dreiecke aufgrund der besonders geringen Gr√∂√üe ihrer Projektion auf den Bildschirm m√∂glicherweise nicht angezeigt werden und nicht, weil sich etwas mit ihnen √ºberlappt oder sie auf der falschen Seite gedreht sind.  Wir haben eine konservative Version des Algorithmus implementiert.  In diesem Fall wird die <b>AABB der</b> Projektion des Dreiecks auf dem Bildschirm berechnet, und wenn mindestens eine seiner Seiten kleiner als die Texelseite im Bild ist, wird ein solches Polygon als sichtbar markiert.  Dieser Ansatz sch√ºtzt vor Artefakten, wenn der Algorithmus mit einer Aufl√∂sung ausgef√ºhrt wird, die geringer ist als die Bildschirmaufl√∂sung des Zielger√§ts.  Wenn Sie kleine Polygone ignorieren, ist das Ergebnis auch akzeptabel, vorausgesetzt, die Aufl√∂sung der verwendeten Rendertextur ist h√∂her als die Aufl√∂sung der Bildschirme der vorgesehenen Ger√§te. <br><br>  Wir haben diesen Beschneidungsalgorithmus in <b>Unity</b> implementiert und verwenden ihn, um statische Objekte zu optimieren, deren Modelle in der Szene mehrmals an verschiedenen Positionen gefunden werden.  Dies ist haupts√§chlich die Szenerie: Steine, B√§ume, Statuen, Vasen usw., die sich auf das h√§ufig verwendete Fertighaus bezieht.  Wir m√∂chten solche Objekte bereits in der Phase der Erstellung eines 3D-Pakets optimieren, aber wer wei√ü, in welcher phantasmagorischen Pose der Leveldesigner seinen Lieblingskandelaber platzieren m√∂chte. <br><br>  Das Trimmen der <b>Objektmenge</b> desselben Typs mit einem solchen Werkzeug verringert die Gr√∂√üe der Szene, da w√§hrend des <b>statischen Stapelns die</b> Daten des gemeinsamen <b>vorgefertigten</b> Netzes sowieso in der Erstellungsphase so oft kopiert werden, wie die aktiven gezeichneten Objekte mit diesem Netz in der Szene dargestellt werden.  Unsere Methode gibt auch Speicherplatz in <b>Texturatlanten</b> wie <b>Lightmap frei</b> .  Wir nutzen den gesparten Platz, um die Details der Teile der Modelle zu verbessern, die die Reinigung √ºberstanden haben. <br><br><h3>  3D-Ernte </h3><br>  Trotzdem ist es besser, wenn der K√ºnstler in seinem Editor alles Unn√∂tige abschneidet und dadurch die Anzahl der Stufen der Inhaltserstellung verringert.  Dies ist gerechtfertigt, wenn das Modell in einer Szene mit nur einer vorgegebenen Drehung relativ zur Kamera verwendet wird.  Zuvor wurden Objekte, die dem Benutzer von einer Seite genau zugewandt waren, h√§ufig manuell vereinfacht, bevor sie in das Projekt integriert wurden.  Es ist wichtig zu beachten, dass die programmgesteuerte Implementierung einer solchen Vereinfachung in <b>Unity</b> aufgrund der Komplexit√§t der <b>UV-</b> Verpackungsentwicklung sehr viel schwieriger ist. <b>Daher</b> erleichtert die Automatisierung auf der Stufe eines 3D-Pakets einem K√ºnstler manchmal das Leben. <br><br>  Eines der Werkzeuge f√ºr die Arbeit mit 3D-Modellen in unserem Unternehmen ist <b>Blender</b> .  Wir stiegen hinein.  Es scheint, dass eine solche "erwachsene" Software, wie <b>Blender</b> , eine √§hnliche Funktionalit√§t haben sollte.  Es stellte sich jedoch heraus, dass er nicht sollte.  Ich musste mein eigenes Fahrrad sehen. <br><br>  Die erste Idee war, das vertraute Auswahlwerkzeug zu verwenden - im Wesentlichen einen Teil der manuellen Arbeit des K√ºnstlers f√ºr einen Kamerawinkel zu wiederholen: sichtbare Polygone ausw√§hlen, Auswahl umkehren, l√∂schen.  Der Plan war: Bewegen Sie die Kamera, bestimmen Sie die <b>AABB-</b> Projektion des Modells an jeder Position, fordern Sie dann das Ergebnis der Auswahl der Polygone des Bereichs an, der dem <b>AABB entspricht</b> , ermitteln Sie die Vereinigung der Polygons√§tze der aktuellen Ansicht mit den vorherigen und l√∂schen Sie am Ende nicht ausgew√§hlte Polygone. <br><br>  Bei der Implementierung des Skripts wurde jedoch ein erheblicher Nachteil in Bezug auf die Aufgabe festgestellt.  Auswahlwerkzeuge in <b>Blender (Rechteckauswahl, Kreisauswahl)</b> <a href="https://blender.stackexchange.com/questions/43886/why-wont-lasso-or-box-select-select-all-of-the-faces-in-the-region/93482">verlieren</a> mit zunehmender Anzahl der ausgew√§hlten Elemente pro Fl√§cheneinheit des Bildschirms <a href="https://blender.stackexchange.com/questions/43886/why-wont-lasso-or-box-select-select-all-of-the-faces-in-the-region/93482">an Genauigkeit</a> (einige Polygone bleiben nicht ausgew√§hlt), was ihre Verwendung in unseren Automatisierungswerkzeugen unm√∂glich macht.  Interessante Tatsache: In <b>3ds Max wird ein</b> solches Problem nicht beobachtet. <br><br><img src="https://habrastorage.org/webt/ai/rr/bf/airrbf1enz0jfiucjtrhrbzv8bw.jpeg"><br>  <i>Hervorheben aus der Ferne in <b>Blender</b></i> <br><br><img src="https://habrastorage.org/webt/gt/vy/mh/gtvymh56yk7vp5lrwsvuav4fjqq.jpeg"><br>  <i>Auswahlergebnis</i> <br><br>  Der n√§chste Versuch zielte darauf ab, das Problem auf der Stirn zu l√∂sen: Wir sendeten Strahlen von der Kamera durch jedes Pixel des Ansichtsfensters und schauten, welche Polygone sich als erste mit mindestens einem Strahl schneiden.  Wir haben nicht auf genaue Ergebnisse mit diesem Ansatz gehofft, aber es war einen Versuch wert.  Das Ergebnis ist offensichtlich: Sehr geringe Produktivit√§t bei der Verarbeitung auf der <b>CPU</b> oder den gleichen L√∂chern mit einer geringen Anzahl von Strahlen. <br><br>  Trotzdem haben wir uns f√ºr die Umsetzung eines weiter fortgeschrittenen Ansatzes eingesetzt.  Die Idee war, eine bestimmte Anzahl zuf√§lliger Punkte auf jedem Polygon auszuw√§hlen und dann Strahlen von der Kamera in ihre Richtung zu senden.  Dieser Ansatz hat gut funktioniert, aber wir hatten einige Grenzf√§lle: Es wurden auch Polygone abgeschnitten, bei denen der Winkel zwischen dem Strahl und ihrer Normalen ungef√§hr œÄ / 2 betrug.  Wenn die Kamera aufgrund von perspektivischen Verzerrungen zoomt, k√∂nnen sich daher ausgeschnittene Bereiche √∂ffnen. <br><br>  Diese Methode war nach Meinung der K√ºnstler zu aggressiv, sodass wir uns darauf konzentrierten, nur die <b>R√ºckfl√§chen zu beschneiden</b> . <br><br><h3>  Fazit </h3><br>  Es ist kein Geheimnis, dass ein sorgf√§ltiger Umgang mit den Ressourcen des Ger√§ts beim Erstellen von Spielen der wichtigste Faktor ist, der die Qualit√§t des Endprodukts beeinflusst.  Dies gilt insbesondere f√ºr mobile Plattformen, die auf die aktive Nutzung des Arbeitsspeichers eingestellt sind.  Wenn Sie die Anzahl der Polygone verringern, k√∂nnen Sie den Bereich der Texturatlanten effektiver ausf√ºllen und die Rechenlast etwas verringern. <br><br>  Vergessen Sie auch nicht die Personalkosten und die Fehlerkosten, wenn Sie die oben beschriebenen Werkzeuge und dergleichen verwenden.  Der vorgeschlagene Ansatz setzt eine gut funktionierende Pipeline f√ºr die Arbeit der Kunstabteilung voraus, insbesondere f√ºr Mitarbeiter, die an der Integration von Modellen in das Projekt beteiligt sind. <br><br>  Mit den in diesem Artikel beschriebenen Bedingungen und Tools halten wir uns daher an die folgenden Regeln.  Wenn davon ausgegangen wird, dass das erstellte Modell immer von einer Seite zum Benutzer gedreht wird und auch wenn aus diesen Winkeln die √úberlappung einiger Teile des Modells durch andere recht gering ist, verwendet der K√ºnstler unseren <b>R√ºckfl√§chentrimmer</b> in einem 3D-Editor, √ºberpr√ºft die Richtigkeit und f√§hrt mit der <b>UV-</b> Verpackungsentwicklung fort .  Wenn das Modell h√§ufig an verschiedenen Positionen verwendet wird oder eine komplexere Geometrie aufweist, f√ºhren Sie nach dem Import in das Projekt den im ersten Teil des Artikels beschriebenen Algorithmus aus und verarbeiten damit alle statischen Objekte in der Szene. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de484792/">https://habr.com/ru/post/de484792/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de484776/index.html">Digitale Veranstaltungen in St. Petersburg vom 21. bis 26. Januar</a></li>
<li><a href="../de484778/index.html">Intel Parallel Studio XE 2020: alles Gute f√ºr Entwickler</a></li>
<li><a href="../de484782/index.html">Blazor Client Side Online-Shop: Teil 2 - CI / CD</a></li>
<li><a href="../de484788/index.html">Weitere Funktionen f√ºr Ihr System: Telefonie-Integration und CRM / ERP / Helpdesk. Was, wie und warum?</a></li>
<li><a href="../de484790/index.html">Die Geschichte, wie aufgrund einer Option unter Server Windows unsere Websites langsamer wurden</a></li>
<li><a href="../de484796/index.html">Wie habe ich die OSWE-Zertifizierung erhalten?</a></li>
<li><a href="../de484798/index.html">Warum ist das schnelle Sortieren so langsam? Neue Array-Sortiermethode</a></li>
<li><a href="../de484800/index.html">Microsoft Application Inspector-Quellcodeanalyse</a></li>
<li><a href="../de484802/index.html">Selbstzerst√∂rungsmodus: Zersetzung der endoskopischen Kapsel durch Licht</a></li>
<li><a href="../de484804/index.html">Was muss in einem Unternehmenssystem verschl√ºsselt werden? Und warum das machen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>