<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©â€ğŸ‘¦â€ğŸ‘¦ ğŸ§– ğŸ© Kami menghubungkan meteran air ke rumah pintar ğŸ‘¨ğŸ¾â€ğŸ“ ğŸ§‘ğŸ»â€ğŸ¤â€ğŸ§‘ğŸ» ğŸ’‡ğŸ¿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pernah sistem otomasi rumah, atau yang sering disebut "rumah pintar", sangat mahal dan hanya orang kaya yang mampu membelinya. Hari ini di pasaran And...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami menghubungkan meteran air ke rumah pintar</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/411259/">  Pernah sistem otomasi rumah, atau yang sering disebut "rumah pintar", sangat mahal dan hanya orang kaya yang mampu membelinya.  Hari ini di pasaran Anda dapat menemukan kit yang cukup murah dengan sensor, tombol / sakelar dan aktuator untuk mengendalikan pencahayaan, soket, ventilasi, pasokan air, dan konsumen lainnya.  Dan bahkan DIY-shnik yang <s>paling krivoruky</s> dapat bergabung dengan perangkat cantik dan mengoleksi rumah pintar dengan harga murah. <br><br><img src="https://habrastorage.org/webt/-a/k2/x6/-ak2x6li6an5gyqbrg2ett_-_au.jpeg"><br><br>  Sebagai aturan, perangkat yang diusulkan adalah sensor atau aktuator.  Mereka membuatnya mudah untuk menerapkan skenario seperti "nyalakan lampu ketika sensor gerak dipicu" atau "sakelar di pintu keluar memadamkan cahaya di seluruh apartemen".  Tetapi telemetri entah bagaimana tidak berhasil.  Paling-paling, ini adalah grafik suhu dan kelembaban, atau daya sesaat di outlet tertentu. <br><br>  Baru-baru ini saya memasang meteran air dengan output pulsa.  Saklar buluh dipicu melalui setiap liter melalui meter dan menutup kontak.  Satu-satunya yang tersisa adalah menempel pada kabel dan mencoba untuk mendapatkan keuntungan darinya.  Misalnya, analisis konsumsi air per jam dan hari dalam seminggu.  Nah, jika ada beberapa riser untuk air di apartemen, maka akan lebih mudah untuk melihat semua indikator saat ini di satu layar daripada naik relung yang sulit dijangkau dengan senter. <br><br>  Di bawah potongan, versi perangkat saya didasarkan pada ESP8266, yang menghitung pulsa dari meter air dan mengirimkan bacaan ke server rumah pintar melalui MQTT.  Kami akan memprogram dalam micropython menggunakan perpustakaan uasyncio.  Saat membuat firmware, saya menemukan beberapa kesulitan menarik, yang juga akan saya bahas di artikel ini.  Ayo pergi! <br><a name="habracut"></a><br><h3>  Skema </h3><br><img src="https://habrastorage.org/webt/i-/w2/o7/i-w2o7b8mfsommteri_mss88oa8.png"><br><br>  Jantung dari seluruh rangkaian adalah modul pada mikrokontroler ESP8266.  ESP-12 awalnya direncanakan, tetapi milik saya ternyata rusak.  Saya harus puas dengan modul ESP-07, yang tersedia.  Untungnya, keduanya sama dalam kesimpulan dan fungsionalitas, perbedaannya hanya pada antena - ESP-12 memiliki built-in, dan ESP-07 memiliki yang eksternal.  Namun, bahkan tanpa antena WiFi, sinyal di kamar mandi saya tertangkap secara normal. <br><br>  Penjilidan modul adalah standar: <br><br><ul><li>  tombol reset dengan suspender dan kapasitor (meskipun keduanya sudah ada di dalam modul) </li><li>  Aktifkan sinyal (CH_PD) ditarik ke kekuasaan </li><li>  GPIO15 ditarik ke tanah.  Ini hanya diperlukan pada awalnya, tetapi saya masih tidak memiliki apa-apa lagi untuk melekat pada kaki ini </li></ul><br>  Untuk meletakkan modul ke mode firmware, Anda harus menutup GPIO2 ke ground, dan agar lebih nyaman, saya telah menyediakan tombol Boot.  Dalam kondisi normal, pin ini ditarik ke daya. <br><br>  Status jalur GPIO2 diperiksa hanya pada awal pekerjaan - ketika daya diterapkan atau segera setelah reset.  Jadi modul memuat seperti biasa, atau masuk ke mode firmware.  Setelah memuat, output ini dapat digunakan sebagai GPIO biasa.  Nah, karena sudah ada tombol di sana, Anda dapat meletakkan beberapa fungsi yang berguna di sana. <br><br>  Untuk pemrograman dan debugging, saya akan menggunakan UART, yang dibawa ke sisir.  Bila perlu - saya cukup mencolokkan adaptor USB-UART.  Anda hanya perlu mengingat bahwa modul ini ditenagai oleh 3.3V.  Jika Anda lupa mengganti adaptor ke tegangan ini dan menerapkan 5V, modul kemungkinan besar akan terbakar. <br><br>  Saya tidak punya masalah dengan listrik di kamar mandi - stopkontak terletak sekitar satu meter dari meter, jadi saya akan menyalakannya dari 220V.  Sebagai sumber daya, saya akan mengerjakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blok</a> kecil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HLK-PM03</a> dari Tenstar Robot.  Secara pribadi, saya ketat dengan elektronik analog dan listrik, tapi di sini ada catu daya yang sudah jadi dalam wadah kecil. <br><br>  Untuk memberi sinyal pada mode operasi, saya menyediakan LED yang terhubung ke GPIO2.  Namun, saya tidak mulai menyoldernya, karena  modul ESP-07 sudah memiliki LED, apalagi, terhubung ke GPIO2 yang sama.  Tapi biarlah itu ada di papan - tiba-tiba saya ingin membawa LED ini ke kasing. <br><br>  Kami lolos ke yang paling menarik.  Meter air tidak memiliki logika, mereka tidak dapat diminta untuk pembacaan saat ini.  Satu-satunya hal yang tersedia bagi kita adalah pulsa - menutup kontak saklar buluh setiap liter.  Kesimpulan dari saklar buluh diatur di GPIO12 / GPIO13.  Saya akan menyalakan resistor pull-up secara terprogram di dalam modul. <br><br>  Awalnya, saya lupa memberikan resistor R8 dan R9, dan dalam versi board saya, mereka tidak.  Tetapi karena saya sudah menempatkan skema ini pada tampilan publik, ada baiknya memperbaiki pengawasan ini.  Resistor diperlukan agar tidak membakar port jika firmware bermasalah dan menempatkan unit pada pin, dan buluh beralih memendekkan baris ini ke ground (maksimum 3.3V / 1000Ohm = 3.3mA akan mengalir bersama resistor). <br><br>  Inilah saatnya memikirkan apa yang harus dilakukan jika listrik padam.  Opsi pertama adalah meminta server untuk penghitung awal di awal.  Tetapi ini akan membutuhkan komplikasi signifikan dari protokol pertukaran.  Selain itu, pengoperasian perangkat dalam hal ini tergantung pada status server.  Jika, setelah mematikan lampu, server tidak memulai (atau mulai nanti), maka meter air tidak akan dapat meminta nilai awal dan akan bekerja dengan tidak benar. <br><br>  Oleh karena itu, saya memutuskan untuk menerapkan penyimpanan nilai penghitung dalam chip memori yang terhubung melalui I2C.  Saya tidak memiliki persyaratan khusus untuk ukuran memori flash - Saya hanya perlu menyimpan 2 angka (jumlah liter dengan meter air panas dan dingin).  Bahkan modul terkecil akan dilakukan.  Tetapi pada jumlah siklus rekaman Anda perlu memperhatikan.  Untuk sebagian besar modul, ini adalah 100 ribu siklus, untuk beberapa hingga satu juta. <br><br>  Tampaknya sejuta banyak.  Tetapi selama 4 tahun tinggal di apartemen saya, saya mengonsumsi sedikit lebih dari 500 meter kubik air, itu 500 ribu liter!  Dan 500 ribu entri dalam flash.  Dan ini hanya air dingin.  Anda bisa, tentu saja, menyolder chip setiap beberapa tahun, tetapi ternyata ada chip FRAM.  Dari sudut pandang pemrograman, ini adalah EEPROM I2C yang sama, tetapi dengan sejumlah besar siklus penulisan ulang (ratusan juta).  Itu hanya sampai semuanya mencapai toko dengan chip sedemikian rupa, jadi untuk saat ini 24LC512 biasa akan bertahan. <br><br><h3>  Papan sirkuit </h3><br>  Awalnya, saya berencana untuk membayar di rumah.  Oleh karena itu, papan dirancang sebagai satu sisi.  Tetapi setelah satu jam yang panjang dengan besi laser dan topeng solder (tanpanya itu tidak aman), saya memutuskan untuk memesan papan dari Cina. <br><br><img src="https://habrastorage.org/webt/en/si/rz/ensirzhmczp3bs9n7a6a8plmzl4.png"><br><br>  Hampir sebelum memesan papan, saya menyadari bahwa selain chip memori flash pada bus I2C, Anda dapat mengambil sesuatu yang berguna, seperti tampilan.  Apa sebenarnya untuk menghasilkan itu masih menjadi pertanyaan, tetapi Anda harus berkembang biak di papan tulis.  Nah, karena saya akan memesan papan di pabrik, tidak masuk akal membatasi diri pada papan satu sisi, jadi garis pada I2C adalah satu-satunya di bagian belakang papan. <br><br>  Satu kusen besar juga dikaitkan dengan kabel satu sisi.  Karena  papan digambar di satu sisi, trek dan komponen SMD direncanakan untuk ditempatkan di satu sisi, dan komponen output, konektor dan catu daya di sisi lain.  Ketika saya menerima papan dalam sebulan, saya lupa tentang rencana awal dan membuka ritsleting semua komponen di sisi depan.  Dan hanya ketika datang untuk menyolder catu daya, ternyata plus dan minus bercerai sebaliknya.  Saya harus ke pertanian kolektif dengan jumper.  Pada gambar di atas, saya telah mengubah kabel, tetapi tanah dilempar dari satu bagian papan ke yang lain melalui output dari tombol Boot (meskipun mungkin untuk menggambar trek pada lapisan kedua). <br><br>  Ternyata begini <br><br><img src="https://habrastorage.org/webt/au/-d/cs/au-dcsvpehh9p5g9iqyob5hjslu.jpeg"><br><br><h3>  Perumahan </h3><br>  Langkah selanjutnya adalah perumahan.  Dengan printer 3D, ini bukan masalah.  Saya tidak terlalu repot - saya hanya menggambar sekotak ukuran yang tepat dan membuat guntingan di tempat yang tepat.  Penutup terpasang ke tubuh pada sekrup kecil. <br><br><img src="https://habrastorage.org/webt/qq/lu/zp/qqluzptanq4d24dsv4jdlb9uif8.png"><br><br>  Saya sudah menyebutkan bahwa tombol Boot dapat digunakan sebagai tombol untuk keperluan umum - di sini kita membawanya ke panel depan.  Untuk melakukan ini, saya menggambar "sumur" khusus di mana tombol tinggal. <br><br><img src="https://habrastorage.org/webt/dv/xg/gn/dvxggnexv-fiqy0jqtptpdk1dvy.png"><br><br>  Di dalam case ada juga tunggul di mana papan dipasang dan diperbaiki dengan sekrup M3 tunggal (tidak ada lagi ruang di papan) <br><br>  Layar dipilih ketika saya mencetak versi yang pas dari case.  Dua baris standar tidak cocok dengan kasus ini, tetapi layar OLED SSD1306 128x32 ditemukan di gimbal.  Ini kecil, tapi saya tidak harus melihatnya setiap hari - itu akan berjalan lancar. <br><br>  Memperkirakan kedua cara dan bagaimana kabel akan diletakkan darinya, saya memutuskan untuk menempelkan layar di tengah kasing.  Ergonomi, tentu saja, di bawah alas tiang - tombol di atas, tampilan di bawah.  Tetapi saya sudah mengatakan bahwa ide untuk mengacaukan tampilan sudah terlambat dan itu terlalu malas untuk mengatur ulang papan untuk memindahkan tombol. <br><br>  Perangkat selesai.  Modul tampilan ditempelkan ke nozel hot-melt <br><br><img src="https://habrastorage.org/webt/sn/qr/xf/snqrxfyyihzqwiwwwf-1yly545m.jpeg"><br><br><img src="https://habrastorage.org/webt/ow/bh/2o/owbh2oguwv4tiez2basnv11hgvw.jpeg"><br><br>  Hasil akhirnya dapat dilihat pada KDPV <br><br><h3>  Firmware </h3><br>  Mari kita beralih ke bagian perangkat lunak.  Untuk kerajinan kecil seperti itu, saya sangat suka menggunakan bahasa Python ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">micropython</a> ) - kode ini sangat kompak dan mudah dimengerti.  Untungnya, tidak perlu turun ke tingkat register untuk memeras mikrodetik - semuanya dapat dilakukan dari python. <br><br>  Tampaknya semua sederhana, tetapi tidak terlalu - beberapa fungsi independen diuraikan dalam perangkat: <br><br><ul><li>  Pengguna menekan tombol dan melihat layar </li><li>  Centang centang dan perbarui nilai dalam memori flash </li><li>  Modul memonitor sinyal WiFi dan menghubungkan kembali jika perlu </li><li>  Nah, tanpa lampu yang berkedip, Anda tidak bisa </li></ul><br>  Tidak mungkin untuk menganggap bahwa satu fungsi tidak berfungsi jika yang lain bodoh karena suatu alasan.  Saya sudah makan kaktus di proyek-proyek lain dan sekarang saya melihat gangguan dalam gaya "melewatkan satu liter lagi, karena pada saat itu tampilan diperbarui" atau "pengguna tidak dapat melakukan apa pun ketika modul terhubung ke WiFi".  Tentu saja, beberapa hal dapat dilakukan melalui interupsi, tetapi Anda dapat mengalami batasan pada durasi, bersarang panggilan, atau perubahan variabel non-atom.  Nah, kode yang melakukan segalanya dan segera dengan cepat berubah menjadi berantakan. <br><br>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek ini,</a> saya menggunakan multitasking preemptive klasik dan FreeRTOS lebih serius, tetapi dalam hal ini model <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">coroutine dan perpustakaan uasync</a> ternyata jauh lebih cocok.  Terlebih lagi, implementasi Pitutinov corutin hanyalah sebuah bom - bagi programmer, semuanya dilakukan dengan sederhana dan mudah.  Cukup tulis logika Anda sendiri, cukup beri tahu saya di tempat mana Anda dapat beralih di antara utas. <br><br>  Saya sarankan mengeksplorasi perbedaan antara crowding out dan multitasking kompetitif secara opsional.  Sekarang, mari kita beralih ke kode. <br><br><pre><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">##################################### # Counter class - implements a single water counter on specified pin ##################################### class Counter(): debounce_ms = const(25) def __init__(self, pin_num, value_storage): self._value_storage = value_storage self._value = self._value_storage.read() self._value_changed = False self._pin = Pin(pin_num, Pin.IN, Pin.PULL_UP) loop = asyncio.get_event_loop() loop.create_task(self._switchcheck()) # Thread runs forever</span></span></code> </pre> <br>  Setiap penghitung diproses oleh instance dari kelas Penghitung.  Pertama-tama, nilai awal penghitung dikurangi dari EEPROM (value_storage) - ini adalah bagaimana pemulihan dari kegagalan daya diterapkan. <br><br>  Pin diinisialisasi dengan built-in pull-up ke daya: jika saklar buluh ditutup, itu adalah nol pada saluran, jika saluran terbuka, saluran ditarik ke daya dan pengontrol membaca satu. <br><br>  Juga, tugas terpisah diluncurkan di sini, yang akan melakukan polling pin.  Setiap penghitung akan menjalankan tugasnya sendiri.  Ini kodenya <br><br><pre> <code class="python hljs"> <span class="hljs-string"><span class="hljs-string">""" Poll pin and advance value when another litre passed """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_switchcheck</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> last_checked_pin_state = self._pin.value() <span class="hljs-comment"><span class="hljs-comment"># Get initial state # Poll for a pin change while True: state = self._pin.value() if state != last_checked_pin_state: # State has changed: act on it now. last_checked_pin_state = state if state == 0: self._another_litre_passed() # Ignore further state changes until switch has settled await asyncio.sleep_ms(Counter.debounce_ms)</span></span></code> </pre> <br>  Diperlukan waktu 25ms untuk memfilter kontak yang terpental, dan pada saat yang sama mengatur seberapa sering tugas bangun (saat tugas ini sedang tidur, tugas lain bekerja).  Setiap 25ms fungsi bangun, periksa pin dan jika kontak saklar buluh ditutup, maka liter lain telah melewati konter dan ini perlu diproses. <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_another_litre_passed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self._value += <span class="hljs-number"><span class="hljs-number">1</span></span> self._value_changed = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> self._value_storage.write(self._value)</code> </pre> <br>  Memproses liter berikutnya sepele - penghitung hanya meningkat.  Nah, nilai baru akan menyenangkan untuk menulis ke flash drive. <br><br>  Untuk kemudahan penggunaan, "pengakses" disediakan. <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self._value_changed = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._value <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, value)</span></span></span><span class="hljs-function">:</span></span> self._value = value self._value_changed = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br>  Nah, sekarang kita akan mengambil keuntungan dari kesenangan python dan pustaka uasync dan membuat objek penghitung bisa ditunggu (bagaimana ini bisa diterjemahkan ke dalam bahasa Rusia? Yang bisa diharapkan?) <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__await__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self._value_changed: <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.value() __iter__ = __await__</code> </pre> <br>  Ini adalah fungsi yang nyaman yang menunggu hingga nilai penghitung diperbarui - fungsi bangun dari waktu ke waktu dan memeriksa tanda _value_changed.  Lelucon dari fungsi ini adalah bahwa kode panggilan dapat tertidur pada panggilan ke fungsi ini dan tidur sampai nilai baru diterima. <br><br><div class="spoiler">  <b class="spoiler_title">Tapi bagaimana dengan interupsi?</b> <div class="spoiler_text">  Ya, di tempat ini Anda dapat menjebak saya, mengatakan bahwa ia sendiri mengatakan tentang gangguan, tetapi sebenarnya ia mengatur jajak pendapat bodoh dari pin.  Sebenarnya, interupsi adalah hal pertama yang saya coba.  Dalam ESP8266, Anda dapat mengatur interrupt edge, dan bahkan menulis handler untuk interrupt ini dengan python.  Dalam interupsi ini, Anda dapat memperbarui nilai suatu variabel.  Mungkin, ini akan cukup jika penghitung adalah perangkat budak - yang menunggu sampai diminta untuk nilai ini. <br><br>  Sayangnya (atau untungnya?) Perangkat saya aktif, ia harus mengirim pesan menggunakan protokol MQTT dan menulis data ke EEPROM.  Dan di sini pembatasan sudah datang - Anda tidak dapat mengalokasikan memori dan menggunakan tumpukan besar dalam interupsi, yang berarti Anda bisa lupa mengirim pesan melalui jaringan.  Ada roti seperti micropython.schedule () yang memungkinkan Anda menjalankan beberapa jenis fungsi "segera", tetapi pertanyaannya adalah "apa gunanya?".  Tiba-tiba kami mengirim beberapa jenis pesan sekarang, dan di sini potongan interrupt dan merusak nilai-nilai variabel.  Atau, misalnya, nilai penghitung baru tiba dari server sementara kami masih tidak menuliskan yang lama.  Secara umum, Anda perlu pagar sinkronisasi atau keluar entah bagaimana berbeda. <br><br>  Dan dari waktu ke waktu, RuntimeError crash: jadwal stack penuh dan siapa yang tahu mengapa? <br><br>  Dengan jajak pendapat eksplisit dan uasync, dalam hal ini entah bagaimana lebih indah dan lebih dapat diandalkan. <br></div></div><br>  Saya bekerja dengan EEPROM di kelas kecil <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EEPROM</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span><span class="hljs-class">:</span></span> i2c_addr = const(<span class="hljs-number"><span class="hljs-number">80</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, i2c)</span></span></span><span class="hljs-function">:</span></span> self.i2c = i2c self.i2c_buf = bytearray(<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-comment"><span class="hljs-comment"># Avoid creation/destruction of the buffer on each call def read(self, eeprom_addr): self.i2c.readfrom_mem_into(self.i2c_addr, eeprom_addr, self.i2c_buf, addrsize=16) return ustruct.unpack_from("&lt;I", self.i2c_buf)[0] def write(self, eeprom_addr, value): ustruct.pack_into("&lt;I", self.i2c_buf, 0, value) self.i2c.writeto_mem(self.i2c_addr, eeprom_addr, self.i2c_buf, addrsize=16)</span></span></code> </pre> <br>  Dalam python, bekerja dengan byte secara langsung itu sulit, tetapi byte yang ditulis ke memori.  Saya harus memperbaiki konversi antara integer dan byte menggunakan perpustakaan ustruct. <br><br>  Agar tidak mentransfer objek I2C dan alamat sel memori setiap kali, saya membungkus semuanya dalam klasik kecil dan nyaman <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EEPROMValue</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, i2c, eeprom_addr)</span></span></span><span class="hljs-function">:</span></span> self._eeprom = EEPROM(i2c) self._eeprom_addr = eeprom_addr <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._eeprom.read(self._eeprom_addr) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, value)</span></span></span><span class="hljs-function">:</span></span> self._eeprom.write(self._eeprom_addr, value)</code> </pre> <br>  Objek I2C sendiri dibuat dengan parameter seperti itu <br><br><pre> <code class="python hljs">i2c = I2C(freq=<span class="hljs-number"><span class="hljs-number">400000</span></span>, scl=Pin(<span class="hljs-number"><span class="hljs-number">5</span></span>), sda=Pin(<span class="hljs-number"><span class="hljs-number">4</span></span>))</code> </pre> <br>  Kami mendekati hal yang paling menarik - implementasi komunikasi dengan server melalui MQTT.  Nah, protokol itu sendiri tidak perlu diimplementasikan - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">implementasi asinkron siap pakai</a> ditemukan di Internet.  Di sini kita akan menggunakannya. <br><br>  Semua yang paling menarik dikumpulkan di kelas CounterMQTTClient, yang didasarkan pada perpustakaan MQTTClient.  Mari kita mulai dari pinggiran <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">##################################### # Class handles both counters and sends their status to MQTT ##################################### class CounterMQTTClient(MQTTClient): blue_led = Pin(2, Pin.OUT, value = 1) button = Pin(0, Pin.IN) hot_counter = Counter(12, EEPROMValue(i2c, EEPROM_ADDR_HOT_VALUE)) cold_counter = Counter(13, EEPROMValue(i2c, EEPROM_ADDR_COLD_VALUE))</span></span></code> </pre> <br>  Di sini, pin bola lampu dan tombol dibuat dan dikonfigurasikan, serta objek meter air dingin dan panas. <br><br>  Dengan inisialisasi, tidak semuanya sepele <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.internet_outage = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> self.internet_outages = <span class="hljs-number"><span class="hljs-number">0</span></span> self.internet_outage_start = ticks_ms() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"config.txt"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> config_file: config[<span class="hljs-string"><span class="hljs-string">'ssid'</span></span>] = config_file.readline().rstrip() config[<span class="hljs-string"><span class="hljs-string">'wifi_pw'</span></span>] = config_file.readline().rstrip() config[<span class="hljs-string"><span class="hljs-string">'server'</span></span>] = config_file.readline().rstrip() config[<span class="hljs-string"><span class="hljs-string">'client_id'</span></span>] = config_file.readline().rstrip() self._mqtt_cold_water_theme = config_file.readline().rstrip() self._mqtt_hot_water_theme = config_file.readline().rstrip() self._mqtt_debug_water_theme = config_file.readline().rstrip() config[<span class="hljs-string"><span class="hljs-string">'subs_cb'</span></span>] = self.mqtt_msg_handler config[<span class="hljs-string"><span class="hljs-string">'wifi_coro'</span></span>] = self.wifi_connection_handler config[<span class="hljs-string"><span class="hljs-string">'connect_coro'</span></span>] = self.mqtt_connection_handler config[<span class="hljs-string"><span class="hljs-string">'clean'</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> config[<span class="hljs-string"><span class="hljs-string">'clean_init'</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> super().__init__(config) loop = asyncio.get_event_loop() loop.create_task(self._heartbeat()) loop.create_task(self._counter_coro(self.cold_counter, self._mqtt_cold_water_theme)) loop.create_task(self._counter_coro(self.hot_counter, self._mqtt_hot_water_theme)) loop.create_task(self._display_coro())</code> </pre> <br>  Untuk mengatur parameter perpustakaan mqtt_as, kamus besar pengaturan yang berbeda digunakan - config.  Sebagian besar pengaturan default sesuai dengan kita, tetapi banyak pengaturan perlu diatur secara eksplisit.  Agar tidak mendaftarkan pengaturan langsung dalam kode, saya menyimpannya di file teks config.txt.  Ini memungkinkan Anda untuk mengubah kode terlepas dari pengaturan, serta memusatkan beberapa perangkat identik dengan parameter yang berbeda. <br><br>  Blok kode terakhir menjalankan beberapa coroutine untuk melayani berbagai fungsi sistem.  Berikut ini contoh coroutine yang melayani penghitung <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_counter_coro</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, counter, topic)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Publish initial value value = counter.value() await self.publish(topic, str(value)) # Publish each new value while True: value = await counter await self.publish_msg(topic, str(value))</span></span></code> </pre> <br>  Dalam sebuah siklus, Corutin menunggu nilai penghitung baru dan segera setelah muncul, mengirim pesan menggunakan protokol MQTT.  Potongan kode pertama mengirimkan nilai awal bahkan jika air tidak mengalir melalui penghitung. <br><br>  Kelas dasar MQTTClient melayani dirinya sendiri, memulai koneksi WiFi dan menghubungkan kembali ketika koneksi terputus.  Ketika status koneksi WiFi berubah, perpustakaan memberi tahu kami dengan memanggil wifi_connection_handler <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wifi_connection_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, state)</span></span></span><span class="hljs-function">:</span></span> self.internet_outage = <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> state: self.dprint(<span class="hljs-string"><span class="hljs-string">'WiFi is up.'</span></span>) duration = ticks_diff(ticks_ms(), self.internet_outage_start) // <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> self.publish_debug_msg(<span class="hljs-string"><span class="hljs-string">'ReconnectedAfter'</span></span>, duration) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: self.internet_outages += <span class="hljs-number"><span class="hljs-number">1</span></span> self.internet_outage_start = ticks_ms() self.dprint(<span class="hljs-string"><span class="hljs-string">'WiFi is down.'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Fungsi ini secara jujur â€‹â€‹dibungkam dari contoh.  Dalam hal ini, ia mempertimbangkan jumlah pemutusan (internet_outages) dan durasinya.  Ketika koneksi dipulihkan, downtime dikirim ke server. <br><br>  Ngomong-ngomong, tidur terakhir diperlukan hanya untuk fungsi menjadi tidak sinkron - di perpustakaan itu dipanggil melalui menunggu, dan hanya fungsi dalam tubuh yang ada menunggu lain yang bisa dipanggil. <br><br>  Selain menghubungkan ke WiFi, Anda juga perlu membuat koneksi dengan broker MQTT (server).  Perpustakaan juga melakukan ini, tetapi kami diberi kesempatan untuk melakukan sesuatu yang berguna ketika koneksi dibuat. <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mqtt_connection_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, client)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> client.subscribe(self._mqtt_cold_water_theme) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> client.subscribe(self._mqtt_hot_water_theme)</code> </pre> <br>  Di sini kami berlangganan beberapa pesan - server sekarang memiliki kemampuan untuk menetapkan nilai penghitung saat ini dengan mengirim pesan yang sesuai. <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mqtt_msg_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, topic, msg)</span></span></span><span class="hljs-function">:</span></span> topicstr = str(topic, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>) self.dprint(<span class="hljs-string"><span class="hljs-string">"Received MQTT message topic={}, msg={}"</span></span>.format(topicstr, msg)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> topicstr == self._mqtt_cold_water_theme: self.cold_counter.set_value(int(msg)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> topicstr == self._mqtt_hot_water_theme: self.hot_counter.set_value(int(msg))</code> </pre> <br>  Fungsi ini memproses pesan masuk, dan tergantung pada topik (nama pesan), nilai salah satu penghitung diperbarui <br><br>  Beberapa fungsi pembantu <br><br><pre> <code class="python hljs"> <span class="hljs-comment"><span class="hljs-comment"># Publish a message if WiFi and broker is up, else discard async def publish_msg(self, topic, msg): self.dprint("Publishing message on topic {}: {}".format(topic, msg)) if not self.internet_outage: await self.publish(topic, msg) else: self.dprint("Message was not published - no internet connection")</span></span></code> </pre> <br>  Fungsi ini mengirim pesan jika koneksi dibuat.  Jika tidak ada koneksi, pesan diabaikan. <br><br>  Dan ini hanyalah fungsi praktis yang menghasilkan dan mengirim pesan debug. <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">publish_debug_msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, subtopic, msg)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> self.publish_msg(<span class="hljs-string"><span class="hljs-string">"{}/{}"</span></span>.format(self._mqtt_debug_water_theme, subtopic), str(msg))</code> </pre><br>  Begitu banyak teks, tetapi kami belum mengedipkan LED.  Di sini <br><br><pre> <code class="python hljs"> <span class="hljs-comment"><span class="hljs-comment"># Blink flash LED if WiFi down async def _heartbeat(self): while True: if self.internet_outage: self.blue_led(not self.blue_led()) # Fast blinking if no connection await asyncio.sleep_ms(200) else: self.blue_led(0) # Rare blinking when connected await asyncio.sleep_ms(50) self.blue_led(1) await asyncio.sleep_ms(5000)</span></span></code> </pre> <br>  Saya telah menyediakan 2 mode kedipan.  Jika koneksi terputus (atau sedang dibangun), maka perangkat akan berkedip cepat.  Jika koneksi tersambung, perangkat berkedip setiap 5 detik sekali.  Jika perlu, di sini Anda dapat menerapkan mode berkedip lainnya. <br><br>  Namun LED begitu memanjakan.  Kami masih melambaikan tangan ke layar. <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_display_coro</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> display = SSD1306_I2C(<span class="hljs-number"><span class="hljs-number">128</span></span>,<span class="hljs-number"><span class="hljs-number">32</span></span>, i2c) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: display.poweron() display.fill(<span class="hljs-number"><span class="hljs-number">0</span></span>) display.text(<span class="hljs-string"><span class="hljs-string">"COLD: {:.3f}"</span></span>.format(self.cold_counter.value() / <span class="hljs-number"><span class="hljs-number">1000</span></span>), <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) display.text(<span class="hljs-string"><span class="hljs-string">"HOT: {:.3f}"</span></span>.format(self.hot_counter.value() / <span class="hljs-number"><span class="hljs-number">1000</span></span>), <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>) display.show() <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">3</span></span>) display.poweroff() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> self.button(): <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep_ms(<span class="hljs-number"><span class="hljs-number">20</span></span>)</code> </pre> <br>  Inilah yang saya bicarakan - betapa sederhana dan nyamannya dengan coroutine.  Fungsi kecil ini menggambarkan SEMUA interaksi pengguna.  Corutin hanya menunggu tombol untuk menekan dan menyalakan layar selama 3 detik.  Layar menunjukkan pembacaan meter saat ini. <br><br>  Masih ada beberapa hal kecil.  Berikut adalah fungsi yang menjalankan seluruh pertanian (kembali).  Siklus utama hanya membahas pengiriman berbagai informasi debug sekali dalam satu menit.  Secara umum, saya mengutip apa adanya - terutama komentar, saya pikir, tidak perlu <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> self._connect_to_WiFi() <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> self._run_main_loop() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> Exception <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: self.dprint(<span class="hljs-string"><span class="hljs-string">'Global communication failure: '</span></span>, e) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_connect_to_WiFi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.dprint(<span class="hljs-string"><span class="hljs-string">'Connecting to WiFi and MQTT'</span></span>) sta_if = network.WLAN(network.STA_IF) sta_if.connect(config[<span class="hljs-string"><span class="hljs-string">'ssid'</span></span>], config[<span class="hljs-string"><span class="hljs-string">'wifi_pw'</span></span>]) conn = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> conn: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> self.connect() conn = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> self.dprint(<span class="hljs-string"><span class="hljs-string">'Connected!'</span></span>) self.internet_outage = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_run_main_loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Loop forever mins = 0 while True: gc.collect() # For RAM stats. mem_free = gc.mem_free() mem_alloc = gc.mem_alloc() try: await self.publish_debug_msg("Uptime", mins) await self.publish_debug_msg("Repubs", self.REPUB_COUNT) await self.publish_debug_msg("Outages", self.internet_outages) await self.publish_debug_msg("MemFree", mem_free) await self.publish_debug_msg("MemAlloc", mem_alloc) except Exception as e: self.dprint("Exception occurred: ", e) mins += 1 await asyncio.sleep(60)</span></span></code> </pre> <br>  Nah, beberapa pengaturan dan konstanta lagi untuk menyelesaikan deskripsi <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">##################################### # Constants and configuration ##################################### config['keepalive'] = 60 config['clean'] = False config['will'] = ('/ESP/Wemos/Water/LastWill', 'Goodbye cruel world!', False, 0) MQTTClient.DEBUG = True EEPROM_ADDR_HOT_VALUE = const(0) EEPROM_ADDR_COLD_VALUE = const(4)</span></span></code> </pre> <br>  Semua dimulai dari sini <br><br><pre> <code class="python hljs">client = CounterMQTTClient() loop = asyncio.get_event_loop() loop.run_until_complete(client.main())</code> </pre> <br><br><h3>  Sesuatu dengan ingatan saya telah menjadi </h3><br>  Jadi, semua kode ada di sana.  Saya mengunggah file menggunakan utilitas ampy - memungkinkan mereka untuk diunggah ke flash drive internal (yang ada di ESP-07 sendiri) dan kemudian diakses dari program sebagai file normal.  Di sana saya mengunggah mqtt_as, uasyncio, ssd1306 dan perpustakaan koleksi (digunakan di dalam mqtt_as) yang saya gunakan. <br><br>  Kami mulai dan ... Kami menerima MemoryError.  Selain itu, semakin saya mencoba memahami persis di mana memori bocor, semakin saya mengatur debug hasil cetak, semakin cepat kesalahan ini terjadi.  Sebuah gugelezh singkat membuat saya mengerti bahwa, pada prinsipnya, mikrokontroler hanya memiliki 30kb memori di mana 65kb kode (bersama dengan perpustakaan) tidak cocok dengan cara apa pun. <br><br>  Tapi ada cara.  Ternyata micropython tidak mengeksekusi kode langsung dari file .py - file ini dikompilasi terlebih dahulu.  Dan itu mengkompilasi langsung pada mikrokontroler, berubah menjadi bytecode, yang kemudian disimpan dalam memori.  Nah, agar kompiler berfungsi, Anda juga membutuhkan sejumlah RAM. <br><br>  Caranya adalah dengan menyelamatkan mikrokontroler dari kompilasi intensif sumber daya.  Anda dapat mengkompilasi file di komputer besar, dan mengisi bytecode yang sudah selesai ke dalam mikrokontroler.  Untuk melakukan ini, unduh firmware micropython dan bangun <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">utilitas mpy-cross</a> . <br><br>  Saya tidak menulis Makefile, tetapi secara manual melewati dan mengkompilasi semua file yang diperlukan (termasuk perpustakaan) seperti ini <br><br><pre> <code class="bash hljs">mpy-cross water_counter.py</code> </pre> <br>  Tetap hanya mengunggah file dengan ekstensi .mpy, tidak lupa untuk menghapus dulu .py dari sistem file perangkat. <br><br>  Saya melakukan semua pengembangan dalam program (IDE?) ESPlorer.  Ini memungkinkan Anda untuk mengunggah skrip ke mikrokontroler dan segera menjalankannya.  Dalam kasus saya, semua logika dan pembuatan semua objek terletak di file water_counter.py (.mpy).  Tetapi agar semua ini dimulai secara otomatis, di awal harus ada file lain bernama main.py.  Dan itu harus persis .py, dan bukan .mpy yang telah dikompilasi sebelumnya.  Ini adalah kontennya yang sepele <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> water_counter</code> </pre> <br>  Kami mulai - semuanya bekerja.  Tapi ada sedikit memori bebas - sekitar 1kb.  Saya masih punya rencana untuk memperluas fungsionalitas perangkat, dan kilobyte ini jelas tidak akan cukup bagi saya.  Namun ternyata ada jalan keluar untuk kasus ini. <br><br>  Ini masalahnya.  Meskipun file dikompilasi menjadi bytecode dan terletak di sistem file internal, sebenarnya mereka masih dimuat ke dalam RAM dan dieksekusi dari sana.  Tapi ternyata micropython mampu mengeksekusi bytecode langsung dari memori flash, tetapi untuk ini Anda perlu menanamkannya langsung ke dalam firmware.  Ini tidak sulit, walaupun butuh waktu yang cukup lama di netbook saya (hanya di sana saya dapat Linux). <br><br>  Algoritma adalah sebagai berikut: <br><br><ul><li>  Unduh dan pasang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ESP Open SDK</a> .  Hal ini membangun kompiler dan pustaka untuk program di bawah ESP8266.  Itu dirakit sesuai dengan instruksi pada halaman utama proyek (saya memilih pengaturan STANDALONE = ya) </li><li>  Unduh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Micropython Sorts</a> </li><li>  Jatuhkan perpustakaan yang diperlukan ke port / esp8266 / modul di dalam pohon micropython </li><li>  Kami merakit firmware sesuai dengan instruksi dalam file <a href="">ports / esp8266 / README.md</a> </li><li>  Tuangkan firmware ke dalam mikrokontroler (saya melakukan ini pada Windows dengan program ESP8266Flasher atau Python esptool) </li></ul><br>  Itu saja, sekarang 'impor ssd1306' akan menaikkan kode langsung dari firmware dan RAM tidak akan dihabiskan untuk ini.  Dengan trik ini, saya hanya mengunduh kode perpustakaan ke dalam firmware, sedangkan kode program utama dijalankan dari sistem file.  Ini memungkinkan Anda untuk dengan mudah memodifikasi program tanpa mengkompilasi ulang firmware.  Saat ini saya memiliki sekitar 8,5 kb RAM gratis.  Ini akan memungkinkan untuk menerapkan cukup banyak fungsi yang berguna berbeda di masa depan.  Nah, jika tidak ada cukup memori sama sekali, maka Anda juga bisa mendorong program utama ke dalam firmware. <br><br><h3>  Dan apa yang harus dilakukan dengan itu sekarang? </h3><br>  Ok, perangkat keras disolder, firmware ditulis, kotak dicetak, perangkat macet ke dinding dan berkedip gembira dengan bola lampu.  Tetapi sementara ini semua adalah kotak hitam (dalam arti harfiah dan kiasan) dan pengertian itu masih belum cukup.  Sudah waktunya untuk melakukan sesuatu dengan pesan MQTT yang dikirim ke server. <br><br>  "Rumah pintar" saya berputar di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sistem Majordomo</a> .  Modul MQTT berada di luar kotak, atau dapat dengan mudah diinstal dari pasar add-ons - Saya tidak lagi ingat dari mana asalnya.  Hal MQTT tidak swasembada - yang disebut  broker - server yang menerima, mengurutkan dan mengalihkan pesan MQTT ke klien.  Saya menggunakan mosquitto, yang (seperti majordomo) berjalan di netbook yang sama. <br><br>  Setelah perangkat mengirim pesan setidaknya satu kali, nilainya akan segera muncul dalam daftar. <br><br><img src="https://habrastorage.org/webt/hf/ip/db/hfipdb1coxh_lsaaz600mi-39y0.png"><br><br>  Nilai-nilai ini sekarang dapat dikaitkan dengan objek sistem, mereka dapat digunakan dalam skrip otomatisasi dan mengalami berbagai analisis - semua ini di luar ruang lingkup artikel ini.  Siapa yang tertarik dengan sistem majordomo, saya dapat merekomendasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saluran Electronics In Lens</a> - seorang teman juga membangun rumah pintar dan secara cerdik berbicara tentang pengaturan sistem. <br><br>  Saya hanya akan menampilkan beberapa grafik.  Ini adalah grafik sederhana dari nilai harian. <br><br><img src="https://habrastorage.org/webt/km/hw/xr/kmhwxruql1fk0kmykb1gpcpci_0.png"><br>  Dapat dilihat bahwa hampir tidak ada yang menggunakan air di malam hari.  Beberapa kali seseorang pergi ke toilet, dan sepertinya filter osmosis terbalik menghisap beberapa liter semalam.  Di pagi hari, konsumsi meningkat secara signifikan.  Biasanya saya menggunakan air dari ketel, tetapi kemudian saya ingin mandi dan beralih sementara ke air panas kota - ini juga terlihat jelas di grafik bagian bawah. <br><br>  Dari jadwal ini, saya mengetahui bahwa pergi ke toilet adalah 6-7 liter air, mandi - 20-30 liter, mencuci piring sekitar 20 liter, dan untuk mandi Anda membutuhkan 160 liter.  Selama sehari, keluarga saya mengkonsumsi sekitar 500-600l. <br><br>  Untuk yang paling ingin tahu, Anda dapat melihat entri untuk setiap nilai individual <br><br><img src="https://habrastorage.org/webt/8l/8i/su/8l8isu_aiaswajdeeuexytpwffi.png"><br><br>  Dari sini saya belajar bahwa dengan keran terbuka, air mengalir dengan kecepatan sekitar 1 liter dalam 5 detik. <br><br>  Tetapi dalam bentuk ini, statistik mungkin tidak nyaman untuk ditonton.  Di majordomo masih ada peluang untuk melihat grafik konsumsi berdasarkan hari, minggu dan bulan.  Misalnya, grafik konsumsi dalam kolom <br><br><img src="https://habrastorage.org/webt/m3/wa/sf/m3wasfzbvxb2tz1yhemod2ewwdy.png"><br><br>  Sejauh ini saya hanya punya data selama seminggu.  Dalam sebulan, bagan ini akan lebih indikatif - kolom terpisah akan sesuai dengan setiap hari.  Penyesuaian nilai-nilai yang saya masukkan secara manual merusak sedikit gambar (kolom terbesar).  Dan belum jelas apakah saya salah mengatur nilai pertama hampir kubus kurang, atau apakah ini bug dalam firmware dan tidak semua liter masuk ke set-off.  Butuh lebih banyak waktu. <br><br>  Masih perlu menyulap grafik sendiri, memutihkan, warna.  Mungkin saya juga akan membangun grafik konsumsi memori untuk keperluan debugging - tiba-tiba ada sesuatu yang bocor di luar sana.  Mungkin saya entah bagaimana akan menampilkan periode ketika Internet tidak tersedia.  Sementara semua ini berputar pada level ide. <br><br><h3>  Kesimpulan </h3><br>  Hari ini, apartemen saya menjadi sedikit lebih pintar.  Dengan perangkat sekecil itu, akan lebih nyaman bagi saya untuk memantau konsumsi air di rumah.  Jika sebelumnya saya marah "lagi mereka mengkonsumsi banyak air dalam sebulan", sekarang saya dapat menemukan sumber konsumsi ini. <br><br>  Akan terasa aneh bagi seseorang untuk menonton pembacaan di layar jika jaraknya satu meter dari meter itu sendiri.  Tetapi dalam waktu yang tidak terlalu lama, saya berencana untuk pindah ke apartemen lain, di mana akan ada beberapa anak tangga, dan meter itu sendiri kemungkinan besar akan terletak di pendaratan.  Jadi alat baca jarak jauh akan sangat membantu. <br><br>  Saya juga berencana untuk memperluas fungsionalitas perangkat.  Saya sudah melihat katup bermotor.  Sekarang untuk mengganti air boiler-city saya perlu mengubah 3 keran di ceruk yang tidak dapat diakses.  Akan jauh lebih mudah untuk melakukan ini dengan satu tombol dengan indikasi yang sesuai.  Yah, tentu saja, ada baiknya menerapkan perlindungan terhadap kebocoran. <br><br>  Dalam artikel tersebut saya memberi tahu versi perangkat saya berdasarkan ESP8266.  Menurut pendapat saya, saya mendapatkan versi yang sangat menarik dari firmware micropython menggunakan coroutine - sederhana dan cantik.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya mencoba menggambarkan banyak nuansa dan sekolah yang saya temui dalam kampanye. </font><font style="vertical-align: inherit;">Mungkin saya menggambarkan semuanya dengan terlalu detail, bagi saya pribadi, sebagai pembaca, lebih mudah untuk menyia-nyiakan terlalu banyak daripada kemudian memikirkan apa yang tidak terucapkan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti biasa, saya terbuka untuk kritik yang membangun. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode Sumber </font></font></a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sirkuit dan </font></font></a> <font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">Model </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">Papan </font></a></font><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kasus</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id411259/">https://habr.com/ru/post/id411259/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id411249/index.html">Bagaimana saya membuat Yandex.Transportasi saya dengan jadwal dan bus</a></li>
<li><a href="../id411251/index.html">Pengguna membenci file pemindaian Chrome di drive lokal</a></li>
<li><a href="../id411253/index.html">Penggabungan bintang-bintang neutron mengakhiri alternatif materi gelap dan energi gelap</a></li>
<li><a href="../id411255/index.html">Aplikasi terdesentralisasi untuk jutaan pengguna di Ethereum</a></li>
<li><a href="../id411257/index.html">Di AS, mereka menciptakan sistem laser yang akan menakuti musuh dengan suara</a></li>
<li><a href="../id411261/index.html">Respons getaran pada prostesis: cara baru untuk meningkatkan kontrol anggota gerak bionik</a></li>
<li><a href="../id411263/index.html">Tombol Ajaib untuk LED pada ATtiny4</a></li>
<li><a href="../id411265/index.html">Kasing Mata (Bagian 3)</a></li>
<li><a href="../id411267/index.html">Siapa yang benar-benar di belakang smartphone baru bermerek Nokia?</a></li>
<li><a href="../id411269/index.html">Tiga komponen "LOAD"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>