<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï° üë®‚Äçüé® üë®üèª‚Äç‚öïÔ∏è Una descripci√≥n general de los m√©todos de enlace de texto ü•ü üêë ü§ê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 


 Hace alg√∫n tiempo, particip√© en un proyecto para desarrollar un producto de software dise√±ado para analizar registros de pacientes y ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Una descripci√≥n general de los m√©todos de enlace de texto</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417465/"><h2 id="vvedenie">  Introduccion </h2><br><p>  Hace alg√∫n tiempo, particip√© en un proyecto para desarrollar un producto de software dise√±ado para analizar registros de pacientes y datos sobre su estado de salud provenientes de organizaciones m√©dicas para crear un registro m√©dico unificado.  Durante mucho tiempo, el equipo no pudo desarrollar un enfoque para combinar datos de pacientes.  El punto de partida fue el estudio de los c√≥digos fuente de la soluci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Open EMPI</a> (Open Enterprise Master Patient Index), que nos empuj√≥ a utilizar algoritmos de an√°lisis de similitud de cadenas.  A partir de ese momento, comenz√≥ un estudio m√°s profundo de los materiales, que hizo posible crear primero un dise√±o y luego una soluci√≥n de trabajo. </p><br><p>  Hasta ahora, en varios tipos de presentaciones, uno tiene que escuchar muchas preguntas sobre la l√≥gica del trabajo de dichos productos, de lo cual concluyo que una revisi√≥n de los m√©todos de enlace de texto ser√° de inter√©s para un amplio c√≠rculo de lectores. </p><br><p>  El material es una traducci√≥n del art√≠culo de Wikipedia " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Registro de enlaces</a> " con derechos de autor y adiciones. </p><a name="habracut"></a><br><h2 id="chto-takoe-svyazyvanie-tekstovyh-zapisey">  ¬øQu√© es el enlace de texto? </h2><br><p>  El t√©rmino <em>"</em> vinculaci√≥n de registros" describe el proceso de adjuntar registros de texto de una fuente de datos a registros de otra, siempre que describan el mismo objeto.  En inform√°tica, esto se llama <em>"mapeo de datos"</em> o <em>"problema de identidad de objeto"</em> .  Algunas veces se usan definiciones alternativas, como <em>"identificaci√≥n"</em> , <em>"enlace"</em> , <em>"detecci√≥n de duplicados"</em> , <em>"deduplicaci√≥n"</em> , <em>"registros coincidentes"</em> , <em>"identificaci√≥n de objeto"</em> , que describen el mismo concepto.  Esta abundancia terminol√≥gica ha llevado a una separaci√≥n del procesamiento de la informaci√≥n y los enfoques de estructuraci√≥n: <em>enlace de</em> <em>registros</em> y <em>enlace de datos</em> .  Aunque ambos determinan la identificaci√≥n de objetos coincidentes por diferentes conjuntos de par√°metros, el t√©rmino "vincular registros de texto" se usa com√∫nmente cuando se refiere a la <em>"esencia" de una</em> persona, mientras que "vincular datos" significa la posibilidad de vincular cualquier recurso web entre conjuntos de datos, utilizando, respectivamente, el concepto m√°s amplio de un identificador, es decir, un URI. </p><br><h2 id="zachem-eto-nuzhno">  ¬øPor qu√© se necesita esto? </h2><br><p>  Cuando se desarrollan productos de software para construir sistemas automatizados utilizados en diversos campos relacionados con el procesamiento de datos personales de una persona (atenci√≥n m√©dica, historia, estad√≠sticas, educaci√≥n, etc.), surge la tarea de identificar datos sobre temas de contabilidad provenientes de diversas fuentes. </p><br><p>  Sin embargo, cuando se recopilan descripciones de una gran cantidad de fuentes, surgen problemas que dificultan su identificaci√≥n inequ√≠voca.  Estos problemas incluyen: </p><br><ul><li>  errores tipogr√°ficos </li><li>  permutaciones de campo (por ejemplo, en el nombre); </li><li>  el uso de abreviaturas y abreviaturas; </li><li>  El uso de un formato diferente de identificadores (fechas, n√∫meros de documentos, etc.). </li><li>  distorsi√≥n fon√©tica; </li><li>  etc. </li></ul><br><p>  La calidad de los datos sin procesar afecta directamente el resultado del proceso de enlace.  Debido a estos problemas, los conjuntos de datos a menudo se transfieren al procesamiento, que, aunque describen el mismo objeto, parece que estos registros se ven diferentes.  Por lo tanto, por un lado, se eval√∫a la aplicabilidad de todos los identificadores de registros transmitidos para su uso en el proceso de identificaci√≥n y, por otro lado, los registros en s√≠ mismos se normalizan o estandarizan para llevarlos a un solo formato. </p><br><h2 id="ekskurs-v-istoriyu">  Tour de historia </h2><br><p>  La idea original de vincular notas fue presentada por Halbert L. Dunn, quien public√≥ un art√≠culo titulado "Record Linkage" en el American Journal of Public Health en 1946. </p><br><p>  M√°s tarde, en 1959, en un art√≠culo sobre Enlace autom√°tico de registros vitales en la revista Science, Howard B. Newcombe sent√≥ las bases probabil√≠sticas de la teor√≠a moderna de encuadernaci√≥n de cuerdas, que fueron desarrolladas y reforzadas en 1969 por Ivan Fellegi y Alan Santer (Alan Sunter).  Su trabajo "Una teor√≠a para la vinculaci√≥n de registros" sigue siendo la base matem√°tica de muchos algoritmos de vinculaci√≥n. </p><br><p>  El desarrollo principal de los algoritmos fue en los a√±os 90 del siglo pasado.  Luego, de varias √°reas (estad√≠stica, archivo, epidemiolog√≠a, historia y otras), nos llegaron algoritmos que a menudo se usan ahora en productos de software, como la <em>similitud (distancia) de la</em> distancia Jaro-Winkler y la distancia <em>Levenshtein</em> , sin embargo, algunas soluciones, por ejemplo, el algoritmo fon√©tico de Soundex, aparecieron mucho antes, en los a√±os 20 del siglo pasado. </p><br><h2 id="algoritmy-sravneniya-tekstovyh-zapisey">  Algoritmos de comparaci√≥n de entrada de texto </h2><br><p>  Distinguir entre algoritmos <em>deterministas</em> y <em>probabil√≠sticos</em> para comparar registros de texto.  Los algoritmos deterministas se basan en la coincidencia completa de los atributos de registro.  Los algoritmos probabil√≠sticos permiten calcular el grado de correspondencia de los atributos de registro y, en base a esto, decidir la posibilidad de su relaci√≥n. </p><br><h3 id="determinirovannye-algoritmy">  Algoritmos Deterministas </h3><br><p>  La forma m√°s f√°cil de comparar cadenas se basa en reglas claras cuando se generan enlaces entre objetos en funci√≥n del n√∫mero de coincidencias de los atributos de los conjuntos de datos.  Es decir, dos registros se corresponden entre s√≠ mediante un algoritmo determinista si todos o algunos de sus atributos son id√©nticos.  Los algoritmos deterministas son adecuados para comparar sujetos descritos por un conjunto de datos que se identifican mediante un identificador com√∫n (por ejemplo, el n√∫mero de Seguro de una cuenta personal individual en el Fondo de Pensiones - SNILS) o tienen varios identificadores representativos (fecha de nacimiento, g√©nero, etc.) en los que se puede confiar. </p><br><p>  Se pueden aplicar algoritmos deterministas cuando se transfieren conjuntos de datos claramente estructurados (estandarizados) al procesamiento. </p><br><p>  Por ejemplo, tiene el siguiente conjunto de entradas de texto: </p><br><table><thead><tr><th>  No </th><th>  SNILS </th><th>  Nombre </th><th>  Fecha de nacimiento </th><th>  G√©nero </th></tr></thead><tbody><tr><td>  A1 </td><td>  163-648-564 96 </td><td>  Zhvanetsky Mikhail </td><td>  06/03/1934 </td><td>  M </td></tr><tr><td>  A2 </td><td>  163-648-564 96 </td><td>  Zhvanetsky Mikhail </td><td>  06/03/1934 </td><td>  M </td></tr><tr><td>  A3 </td><td>  126-029-036 24 </td><td>  Ilchenko Victor </td><td>  01/02/1937 </td><td>  M </td></tr><tr><td>  A4 </td><td></td><td>  Novikova Klara </td><td>  26/12/1946 </td><td>  F </td></tr></tbody></table><br><table><thead><tr><th>  No </th><th>  SNILS </th><th>  Nombre </th><th>  Fecha de nacimiento </th><th>  G√©nero </th></tr></thead><tbody><tr><td>  B1 </td><td>  126-029-036 24 </td><td>  Ilyichenko Victor </td><td>  01/02/1937 </td><td>  M </td></tr><tr><td>  B2 </td><td></td><td>  Zhivanetsky Mikhail </td><td>  06/03/1934 </td><td>  M </td></tr><tr><td>  B3 </td><td></td><td>  Zerchaninova Klara </td><td>  26/12/1946 </td><td>  2 </td></tr></tbody></table><br><p>  Anteriormente se dijo que el algoritmo determinista m√°s simple es el uso de un identificador √∫nico, que se supone que identifica de manera √∫nica a una persona.  Por ejemplo, suponemos que todos los registros que tienen el mismo valor de identificador (SNILS) describen el mismo tema, de lo contrario son temas diferentes.  La conexi√≥n determinista en este caso generar√° los siguientes pares: A1 y A2, A3 y B1.  B2 no se asociar√° con A1 y A2, ya que el identificador no importa, aunque coincide en contenido con los registros especificados. </p><br><p>  Estas excepciones conducen a la necesidad de complementar el algoritmo determinista con nuevas reglas.  Por ejemplo, si no hay un identificador √∫nico, puede usar otros atributos como nombre, fecha de nacimiento y g√©nero.  En el ejemplo dado, esta regla adicional nuevamente no dar√° correspondencia B2 y A1 / A2, porque ahora los nombres son diferentes: hay una distorsi√≥n fon√©tica del apellido. </p><br><p>  Este problema se puede resolver utilizando los m√©todos de an√°lisis fon√©tico, pero si cambia el apellido (por ejemplo, en el caso del matrimonio), deber√° recurrir a la aplicaci√≥n de una nueva regla, por ejemplo, comparar la fecha de nacimiento o permitir diferencias en los atributos disponibles del registro (por ejemplo, g√©nero). </p><br><p>  El ejemplo ilustra claramente que el algoritmo determinista es muy sensible a la calidad de los datos, y un aumento en el n√∫mero de atributos de registro puede conducir a un aumento sustancial en el n√∫mero de reglas aplicadas, lo que complica en gran medida el uso de algoritmos deterministas. </p><br><p>  Adem√°s, el uso de algoritmos deterministas es posible si hay un conjunto de datos verificado (referencia maestra) con el que se compara la informaci√≥n entrante.  Sin embargo, en el caso de la reposici√≥n constante del directorio maestro en s√≠, puede ser necesaria una revisi√≥n completa de las relaciones existentes, lo que hace que el uso de algoritmos deterministas requiera mucho tiempo o simplemente sea imposible. </p><br><h3 id="veroyatnostnye-algoritmy">  Algoritmos Probabil√≠sticos </h3><br><p>  Los algoritmos probabil√≠sticos para vincular registros de cadenas utilizan un conjunto de atributos m√°s amplio que los deterministas, y para cada atributo se calcula un coeficiente de peso que determina la capacidad de influir en la conexi√≥n en la evaluaci√≥n final de la probabilidad de conformidad de los registros estimados.  Los registros que han acumulado un peso total por encima de un cierto umbral se consideran relacionados, los registros que han acumulado un peso total por debajo de un umbral se consideran no relacionados.  Los pares que han ganado el valor del peso total desde la mitad del rango se consideran candidatos para la vinculaci√≥n y pueden considerarse m√°s adelante (por ejemplo, por el operador), que decidir√° sobre su uni√≥n (enlace) o los dejar√° sin consolidar.  Por lo tanto, a diferencia de los algoritmos deterministas, que son un conjunto de un gran n√∫mero de reglas claras (programadas), los algoritmos probabil√≠sticos se pueden adaptar a la calidad de los datos seleccionando valores umbral y no requieren reprogramaci√≥n. </p><br><p>  Por lo tanto, los algoritmos probabil√≠sticos asignan coeficientes de peso ( <em>um</em> ) a los atributos del registro, con la ayuda de los cuales se determinar√° su correspondencia o inconsistencia entre ellos. </p><br><p>  El coeficiente u determina la probabilidad de que los identificadores de dos registros independientes coincidan aleatoriamente.  Por ejemplo, la probabilidad u del mes de nacimiento (cuando hay doce valores distribuidos uniformemente) es 1 \ 12 = 0.083.  Los identificadores con valores que no est√°n distribuidos uniformemente tendr√°n diferentes probabilidades para diferentes valores (a veces, incluidos los valores faltantes). </p><br><p>  El coeficiente m es la probabilidad de que los identificadores en los pares comparados se correspondan entre s√≠ o sean bastante similares, por ejemplo, en el caso de una probabilidad alta por el algoritmo Jaro-Winkler o baja por el algoritmo Levenshtein.  Si los atributos de los registros son completamente consistentes, este valor debe tener un valor de 1.0, pero dada la baja probabilidad de esto, el coeficiente debe evaluarse de manera diferente.  Esta evaluaci√≥n se puede hacer sobre la base del an√°lisis preliminar del conjunto de datos, por ejemplo, <em>"aprendiendo"</em> manualmente <em>el</em> algoritmo probabil√≠stico para identificar una gran cantidad de pares coincidentes y desajustados o lanzando iterativamente el algoritmo para seleccionar el valor de coeficiente m m√°s adecuado. </p><br><p>  Si la probabilidad m se define como 0.95, los coeficientes de cumplimiento / incumplimiento para el mes de nacimiento se ver√°n as√≠: </p><br><table><thead><tr><th>  M√©trica </th><th>  Compartir enlaces </th><th>  Cuota de valores, no referencias </th><th>  Frecuencia </th><th>  Peso </th></tr></thead><tbody><tr><td>  Conformidad </td><td>  m = 0,95 </td><td>  u = 0.083 </td><td>  m \ u = 11.4 </td><td>  ln (m / u) / ln (2) ‚âà 3.51 </td></tr><tr><td>  Desajuste </td><td>  1-m = 0.05 </td><td>  1-u = 0.917 </td><td>  (1-m) / (1-u) ‚âà 0.0545 </td><td>  ln ((1-m) / (1-u)) / ln (2) ‚âà -4.20 </td></tr></tbody></table><br><p>  Se deben realizar c√°lculos similares para otros identificadores de registro para determinar sus coeficientes de cumplimiento y de incumplimiento.  Luego, cada identificador de un registro se compara con el identificador correspondiente de otro registro para determinar el peso total del par: el peso del par correspondiente se agrega al resultado total con un total acumulativo, mientras que el peso del par inapropiado se resta del resultado total.  La cantidad resultante se compara con los valores de umbral identificados para determinar si emparejar o no el par analizado autom√°ticamente o transferirlo al operador para su consideraci√≥n. </p><br><h4 id="blokirovanie">  Bloqueo </h4><br><p>  La determinaci√≥n de los umbrales de cumplimiento / incumplimiento es un equilibrio entre la obtenci√≥n de una sensibilidad aceptable (la proporci√≥n de registros relacionados detectados por el algoritmo) y el valor predictivo del resultado (es decir, precisi√≥n, como una medida de registros verdaderamente coincidentes vinculados por el algoritmo).  Dado que definir umbrales puede ser una tarea muy dif√≠cil, especialmente para grandes conjuntos de datos, a menudo se usa un m√©todo conocido como <em>bloqueo</em> para aumentar la eficiencia computacional.  Se intenta realizar una comparaci√≥n entre registros para los cuales se revela una discrepancia significativa ( <em>discriminaci√≥n</em> ) en los valores de los atributos b√°sicos.  Esto conduce a un aumento en la precisi√≥n debido a una disminuci√≥n en la sensibilidad. </p><br><p>  Por ejemplo, el bloqueo basado en la codificaci√≥n fon√©tica de un apellido reduce el n√∫mero total de comparaciones necesarias y aumenta la probabilidad de que las relaciones entre los registros sean correctas, ya que los dos atributos ya son consistentes, pero podr√≠an omitir registros relacionados con la misma persona cuyo apellido cambiado (por ejemplo, como resultado del matrimonio).  El bloqueo por mes de nacimiento es un indicador m√°s estable que solo se puede ajustar si hay un error en los datos de origen, pero proporciona un beneficio m√°s modesto en valor predictivo positivo y p√©rdida de sensibilidad, ya que crea doce grupos diferentes de conjuntos de datos extremadamente grandes y no conduce a un aumento en la velocidad inform√°tica </p><br><p>  Por lo tanto, los sistemas de enlace de entrada de texto m√°s eficientes a menudo usan varias pasadas de bloqueo para agrupar datos de varias maneras a fin de preparar grupos de registros que luego se deben enviar para su an√°lisis. </p><br><h4 id="mashinnoe-obuchenie">  Aprendizaje autom√°tico </h4><br><p>  Recientemente, se han utilizado varios m√©todos de aprendizaje autom√°tico para vincular registros de texto.  En un art√≠culo de 2011, Randall Wilson demostr√≥ que el algoritmo cl√°sico de vinculaci√≥n probabil√≠stica para registros de texto es equivalente al algoritmo ingenuo de Bayes y sufre los mismos problemas por el supuesto de que las caracter√≠sticas de clasificaci√≥n son independientes.  Para aumentar la precisi√≥n del an√°lisis, el autor propone utilizar un modelo b√°sico de una red neuronal llamada perceptr√≥n de una sola capa, cuyo uso permite superar significativamente los resultados obtenidos utilizando algoritmos probabil√≠sticos tradicionales. </p><br><h2 id="foneticheskoe-kodirovanie">  Codificaci√≥n fon√©tica </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los algoritmos fon√©ticos</a> combinan dos palabras pronunciadas de manera similar con los mismos c√≥digos, lo que le permite comparar dichas palabras en funci√≥n de su similitud fon√©tica. </p><br><p>  La mayor√≠a de los algoritmos fon√©ticos est√°n dise√±ados para analizar palabras en ingl√©s, aunque recientemente algunos algoritmos se han modificado para su uso con otros idiomas, o se crearon originalmente como soluciones nacionales (por ejemplo, Caverphone). </p><br><h3 id="soundex">  Soundex </h3><br><p>  El algoritmo cl√°sico para comparar dos cadenas por su sonido es Soundex (abreviatura de √≠ndice de sonido).  Establece el mismo c√≥digo para cadenas que tienen un sonido similar en ingl√©s.  Soundex fue utilizado originalmente por la Administraci√≥n de Archivos Nacionales de EE. UU. En la d√©cada de 1930 para analizar retrospectivamente los censos de 1890 a 1920. </p><br><p>  Los autores de los algoritmos son Robert C. Russel y Margaret King Odell, quienes lo patentaron en los a√±os 20 del siglo pasado.  El algoritmo mismo gan√≥ popularidad en la segunda mitad del siglo pasado cuando se convirti√≥ en el tema de varios art√≠culos en revistas cient√≠ficas populares en los Estados Unidos y se public√≥ en la monograf√≠a de D. Knut "El arte de la programaci√≥n". </p><br><h3 id="daitch-mokotoff-soundex">  Daitch-Mokotoff Soundex </h3><br><p>  Dado que Soundex solo es adecuado para ingl√©s, algunos investigadores han intentado modificarlo.  En 1985, Gary Mokotoff y Randy Daitch propusieron una variante del algoritmo Soundex, dise√±ado para comparar los apellidos de Europa del Este (incluido el ruso) con una calidad bastante alta. </p><br><h3 id="metaphone">  Metaphone </h3><br><p>  En los a√±os 90, Lawrence Philips (Lawrence Philips) propuso una versi√≥n alternativa del algoritmo Soundex, que se llamaba Metaphone.  El nuevo algoritmo us√≥ un conjunto m√°s amplio de reglas para la pronunciaci√≥n en ingl√©s debido a que era m√°s preciso.  M√°s tarde, el algoritmo fue modificado para ser usado en otros idiomas basado en la transcripci√≥n usando letras del alfabeto latino. </p><br><h3 id="russkiy-metaphone">  Metafono ruso </h3><br><p>  En 2002, el octavo n√∫mero de la revista Programmer public√≥ un art√≠culo de Peter Kankowski que habla sobre su adaptaci√≥n de la versi√≥n en ingl√©s del algoritmo Metaphone.  Esta versi√≥n del algoritmo convierte las palabras de origen de acuerdo con las reglas y normas del idioma ruso, teniendo en cuenta el sonido fon√©tico de las vocales sin tensi√≥n y la posible "fusi√≥n" de consonantes en la pronunciaci√≥n. </p><br><h2 id="vmesto-zaklyucheniya">  En lugar de una conclusi√≥n </h2><br><p>  Como resultado de varias iteraciones, el equipo del proyecto de desarrollo de productos de software, que se mencion√≥ en la introducci√≥n, desarroll√≥ una soluci√≥n arquitect√≥nica, cuyo esquema se muestra en la figura. <br><img src="https://habrastorage.org/webt/fr/yx/dg/fryxdgd4sf1lcf1iachctg_rvqc.png"></p><br><p>  Las descripciones textuales de los pacientes se aceptan a trav√©s del servicio REST y se almacenan en el repositorio (base de datos de tarjetas) sin ning√∫n cambio.  Dado que nuestro sistema funciona con datos m√©dicos, se eligi√≥ el est√°ndar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FHIR</a> (recursos de interoperabilidad de atenci√≥n m√©dica r√°pida) para el intercambio de informaci√≥n.  La informaci√≥n sobre la tarjeta de paciente recibida se transfiere a la cola de mensajes para su posterior an√°lisis y toma de decisiones sobre el establecimiento de la comunicaci√≥n. </p><br><p>  La primera tarjeta que se procesar√° es el <em>"Analizador r√°pido" que</em> funciona con un algoritmo determinista.  Si todas las reglas del algoritmo determinista han funcionado, entonces crea un registro con un enlace a la tarjeta procesada en un almacenamiento separado (base de datos de enlaces).  El registro contiene, adem√°s del identificador de la tarjeta analizada, la fecha de establecimiento de la comunicaci√≥n y un identificador condicional que identifica al paciente identificado globalmente.  Otras tarjetas se remiten al identificador global especificado, formando as√≠ una matriz que describe a un individuo espec√≠fico. </p><br><p>  Si el algoritmo determinista no encuentra una coincidencia, la informaci√≥n de la tarjeta se transmite a trav√©s de la cola de mensajes al "Analizador completo". </p><br><p>       (  ).       .       : </p><br><p><img src="https://habrastorage.org/webt/i8/_7/-k/i8_7-km0ifcsu6llsqhmsruperg.png"></p><br><p> <strong> 1.  -</strong> <br>            ,       .          2. </p><br><p> <strong> 2.  </strong> <br>    -       ,         (). </p><br><p> <strong> 3.  </strong> <br>        ,    ,   (  )  ,      . </p><br><p> <strong> 4.   </strong> <br>     ,        .         .       ,      ,     .       ,   ,    ,         . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es417465/">https://habr.com/ru/post/es417465/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es417453/index.html">Organizaci√≥n de pasant√≠as para estudiantes: rastrillo y trucos.</a></li>
<li><a href="../es417457/index.html">Frontend Conf Moscow: entrada y salida del lado del cliente</a></li>
<li><a href="../es417459/index.html">Conoce tu JIT: m√°s cerca del auto</a></li>
<li><a href="../es417461/index.html">Ivan Tulup: as√≠ncrono en JS bajo el cap√≥</a></li>
<li><a href="../es417463/index.html">Una reuni√≥n inesperada. Cap√≠tulo 17</a></li>
<li><a href="../es417469/index.html">Cinco razones ego√≠stas para trabajar de forma reproducible</a></li>
<li><a href="../es417471/index.html">Soldadura simple MK936 SMD. Estaci√≥n de soldadura DIY para componentes SMD</a></li>
<li><a href="../es417473/index.html">Almacenamiento confiable con DRBD9 y Proxmox (Parte 1: NFS)</a></li>
<li><a href="../es417475/index.html">Codificaci√≥n de borrado Glusterfs +: cuando necesita mucho, barato y confiable</a></li>
<li><a href="../es417477/index.html">Escritorio caliente</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>