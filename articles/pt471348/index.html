<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçüç≥ ‚õπüèª ü§µüèº Aplicativos TypeScript de pilha completa üåæ üóìÔ∏è üõ§Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° Habr! Apresento a voc√™ a tradu√ß√£o do artigo "Aplicativos TypeScript de pilha completa - Parte 1: Desenvolvendo APIs de back-end com Nest.js", de A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aplicativos TypeScript de pilha completa</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471348/"><p>  Ol√° Habr!  Apresento a voc√™ a tradu√ß√£o do artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Aplicativos TypeScript de pilha completa - Parte 1: Desenvolvendo APIs de back-end com Nest.js",</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ana Ribeiro</a> . </p><br><h2 id="chast-1-razrabotka-servernogo-api-s-pomoschyu-nestjs">  Parte 1: Desenvolvendo a API do servidor usando o Nest.JS </h2><br><p>  TL; DR: esta √© uma s√©rie de artigos sobre como criar um aplicativo Web TypeScript usando Angular e Nest.JS.  Na primeira parte, escreveremos uma API de servidor simples usando o Nest.JS.  A segunda parte desta s√©rie √© dedicada ao aplicativo front-end usando Angular.  Voc√™ pode encontrar o c√≥digo final desenvolvido neste artigo neste <a href="">reposit√≥rio GitHub.</a> </p><br><h3 id="chto-takoe-nestjs-i-pochemu-imenno-angular">  O que √© o Nest.Js e por que o Angular? </h3><br><p>  Nest.js √© uma estrutura para a cria√ß√£o de aplicativos de servidor da web Node.js. </p><br><p>  Uma caracter√≠stica distintiva √© que ele resolve um problema que nenhuma outra estrutura resolve: a estrutura do projeto node.js. <a name="habracut"></a>  Se voc√™ j√° desenvolveu o node.js, sabe que pode fazer muito com um m√≥dulo (por exemplo, o middleware Express pode fazer de tudo, da autentica√ß√£o √† valida√ß√£o), o que, no final, pode levar a uma "bagun√ßa" n√£o suportada .  Como voc√™ ver√° abaixo, o nest.js nos ajudar√° com isso, fornecendo aulas especializadas em v√°rios problemas. </p><br><p>  O Nest.js √© fortemente inspirado pelo Angular.  Por exemplo <cut></cut>  ambas as plataformas usam prote√ß√µes para permitir ou impedir o acesso a algumas partes de seus aplicativos e ambas fornecem uma interface CanActivate para implementar essas prote√ß√µes.  No entanto, √© importante notar que, apesar de alguns conceitos semelhantes, ambas as estruturas s√£o independentes uma da outra.  Ou seja, neste artigo, criaremos uma API independente para nosso front-end, que pode ser usada com qualquer outra estrutura (React, Vue.JS e assim por diante). </p><br><h3 id="veb-prilozhenie-dlya-on-layn-zakazov">  Aplicativo da Web para pedidos on-line </h3><br><p>  Neste guia, criaremos um aplicativo simples no qual os usu√°rios podem fazer pedidos em um restaurante.  Ele implementar√° esta l√≥gica: </p><br><ul><li>  qualquer usu√°rio pode visualizar o menu; </li><li>  somente um usu√°rio autorizado pode adicionar mercadorias √† cesta (fazer um pedido) </li><li>  somente o administrador pode adicionar novos itens de menu. </li></ul><br><p>  Para simplificar, n√£o interagiremos com um banco de dados externo e n√£o implementaremos a funcionalidade do nosso carrinho de compras. </p><cut></cut><br><h3 id="sozdanie-faylovoy-struktury-proekta-nestjs">  Criando a estrutura de arquivos do projeto Nest.js </h3><br><p>  Para instalar o Nest.js, precisamos instalar o Node.js (v.8.9.x ou superior) e o NPM.  Baixe e instale o Node.js para o seu sistema operacional no site oficial (NPM est√° inclu√≠do).  Quando tudo estiver instalado, verifique as vers√µes: </p><br><pre><code class="bash hljs">node -v <span class="hljs-comment"><span class="hljs-comment"># v12.11.1 npm -v # 6.11.3</span></span></code> </pre> <br><p>  Existem diferentes maneiras de criar um projeto com o Nest.js.  eles podem ser encontrados na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o</a> .  Vamos usar o <code>nest-cli</code> .  Instale-o: </p><br><p> <code>npm i -g @nestjs/cli</code> </p> <br><p>  Em seguida, crie nosso projeto com um comando simples: </p><br><p> <code>nest new nest-restaurant-api</code> </p> <br><p>  no processo, o nest solicitar√° que escolha um gerenciador de pacotes: <code>npm</code> ou <code>yarn</code> </p><br><p>  Se tudo der certo, o <code>nest</code> criar√° a seguinte estrutura de arquivo: </p><br><pre> <code class="plaintext hljs">nest-restaurant-api ‚îú‚îÄ‚îÄ src ‚îÇ ‚îú‚îÄ‚îÄ app.controller.spec.ts ‚îÇ ‚îú‚îÄ‚îÄ app.controller.ts ‚îÇ ‚îú‚îÄ‚îÄ app.module.ts ‚îÇ ‚îú‚îÄ‚îÄ app.service.ts ‚îÇ ‚îî‚îÄ‚îÄ main.ts ‚îú‚îÄ‚îÄ test ‚îÇ ‚îú‚îÄ‚îÄ app.e2e-spec.ts ‚îÇ ‚îî‚îÄ‚îÄ jest-e2e.json ‚îú‚îÄ‚îÄ .gitignore ‚îú‚îÄ‚îÄ .prettierrc ‚îú‚îÄ‚îÄ nest-cli.json ‚îú‚îÄ‚îÄ package.json ‚îú‚îÄ‚îÄ package-lock.json ‚îú‚îÄ‚îÄ README.md ‚îú‚îÄ‚îÄ tsconfig.build.json ‚îú‚îÄ‚îÄ tsconfig.json ‚îî‚îÄ‚îÄ tslint.json</code> </pre> <br><p>  v√° para o diret√≥rio criado e inicie o servidor de desenvolvimento: </p><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#    cd nest-restaurant-api #   npm run start:dev</span></span></code> </pre> <br><p>  Abra um navegador e digite <code>http://localhost:3000</code> .  Na tela, veremos: <br><img src="https://habrastorage.org/webt/xl/pk/tl/xlpktlb_nkwfh6-akeba7wtnmjc.png"></p><br><p>  Como parte deste tutorial, n√£o testaremos nossa API (embora voc√™ deva escrever testes para qualquer aplicativo pronto para uso).  Dessa forma, voc√™ pode limpar o diret√≥rio de <code>test</code> e excluir o <code>src/app.controller.spec.ts</code> (que √© o teste).  Como resultado, nossa pasta de origem cont√©m os seguintes arquivos: </p><br><ul><li>  <code>src/app.controller.ts</code> e <code>src/app.module.ts</code> : esses arquivos s√£o respons√°veis ‚Äã‚Äãpor criar a mensagem <code>Hello world</code> ao longo da rota <code>/</code> .  Porque  este ponto de entrada n√£o √© importante para esta aplica√ß√£o, n√≥s os exclu√≠mos.  Em breve, voc√™ aprender√° com mais detalhes o que s√£o <strong>controladores</strong> e <strong>servi√ßos</strong> . </li><li>  <code>src/app.module.ts</code> : cont√©m uma descri√ß√£o de uma classe do tipo <strong>m√≥dulo</strong> , respons√°vel por declarar a importa√ß√£o, exporta√ß√£o de controladores e provedores para o aplicativo nest.js.  Cada aplicativo possui pelo menos um m√≥dulo, mas voc√™ pode criar mais de um m√≥dulo para aplicativos mais complexos (mais na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o</a> . Nosso aplicativo conter√° apenas um m√≥dulo </li><li>  <code>src/main.ts</code> : este √© o arquivo respons√°vel por iniciar o servidor. </li></ul><br><blockquote><cut text=""></cut>  Nota: ap√≥s remover <code>src/app.controller.ts</code> e <code>src/app.module.ts</code> voc√™ n√£o poder√° iniciar nosso aplicativo.  N√£o se preocupe, n√≥s resolveremos isso em breve. </blockquote><br><h3 id="sozdanie-tochek-vhoda-endpoints">  Criar pontos de entrada (pontos de extremidade) </h3><br><br><p>  Nossa API estar√° dispon√≠vel na rota <code>/items</code> .  Por meio desse ponto de entrada, os usu√°rios podem receber dados e os administradores gerenciam o menu.  Vamos cri√°-lo. </p><br><p>  Para fazer isso, crie um diret√≥rio chamado <code>items</code> dentro do <code>src</code> .  Todos os arquivos associados √† rota <code>/items</code> ser√£o armazenados neste novo diret√≥rio. </p><br><h4 id="sozdanie-kontrollerov">  Criando controladores </h4><br><p>  no <code>nest.js</code> , como em muitas outras estruturas, os controladores s√£o respons√°veis ‚Äã‚Äãpelo mapeamento de rotas com funcionalidade.  Para criar um controlador no <code>nest.js</code> use o decorador <code>nest.js</code> seguinte maneira: <code>@Controller(${ENDPOINT})</code> .  Al√©m disso, para mapear v√°rios m√©todos <code>HTTP</code> , como <code>GET</code> e <code>POST</code> , s√£o usados ‚Äã‚Äãos decoradores <code>@Post</code> , <code>@Delete</code> , <code>@Delete</code> etc. </p><br><p>  No nosso caso, precisamos criar um controlador que retorne os pratos dispon√≠veis no restaurante e que os administradores usar√£o para gerenciar o conte√∫do do menu.  Vamos criar um arquivo chamado <code>items.controller.tc</code> no diret√≥rio <code>src/items</code> com o seguinte conte√∫do: </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Controller } from '@nestjs/common'; @Controller('items') export class ItemsController { @Get() async findAll(): Promise&lt;string[]&gt; { return ['Pizza', 'Coke']; } @Post() async create() { return 'Not yet implemented'; } }</code> </pre> <br><p>  para disponibilizar nosso novo controlador em nosso aplicativo, registre-o no m√≥dulo: </p><br><pre> <code class="plaintext hljs"> import { Module } from '@nestjs/common'; import { ItemsController } from './items/items.controller'; @Module({ imports: [], controllers: [ItemsController], providers: [], }) export class AppModule {}</code> </pre> <br><p>  Inicie nosso aplicativo: <code>npm run start:dev</code> e abra no navegador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http: // localhost: 3000 / items</a> , se voc√™ fez tudo corretamente, veremos a resposta para a nossa solicita√ß√£o get: <code>['Pizza', 'Coke']</code> . </p><br><p>  <em>Nota do tradutor: para criar novos controladores, assim como outros elementos do <code>nest.js</code> .: servi√ßos, provedores etc., √© mais conveniente usar o comando <code>nest generate</code> do <code>nest-cli</code> .</em>  <em>Por exemplo, para criar o controlador descrito acima, voc√™ pode usar o comando <code>nest generate controller items</code> , como resultado do qual o nest criar√° <code>src/items/items.controller.tc</code> <code>src/items/items.controller.spec.tc</code> e <code>src/items/items.controller.tc</code> seguinte conte√∫do:</em> </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Controller } from '@nestjs/common'; @Controller('items') export class ItemsController {}</code> </pre> <br><p>  <em>e registre-o em <code>app.molule.tc</code></em> </p><br><h4 id="dobavlenie-servisa-service">  Adicionando um servi√ßo </h4><br><p>  Agora, ao acessar <code>/items</code> nosso aplicativo retorna a mesma matriz para cada solicita√ß√£o, que n√£o podemos alterar.  Processar e salvar dados n√£o √© da conta do controlador; para essa finalidade, os servi√ßos s√£o destinados ao nest.js <br>  Os servi√ßos no ninho s√£o <code>@Injectable</code> <br>  O nome do decorador fala por si s√≥, adicionando esse decorador √† classe o torna injet√°vel em outros componentes, como controladores. <br>  Vamos criar nosso servi√ßo.  Crie o arquivo <code>items.service.ts</code> na pasta <code>items.service.ts</code> com o seguinte conte√∫do: </p><br><pre> <code class="plaintext hljs"> import { Injectable } from '@nestjs/common'; @Injectable() export class ItemsService { private readonly items: string[] = ['Pizza', 'Coke']; findAll(): string[] { return this.items; } create(item: string) { this.items.push(item); } }</code> </pre> <br><p>  e altere o controlador <code>ItemsController</code> (declarado em <code>items.controller.ts</code> ) para usar nosso servi√ßo: </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Body, Controller } from '@nestjs/common'; import { ItemsService } from './items.service'; @Controller('items') export class ItemsController { constructor(private readonly itemsService: ItemsService) {} @Get() async findAll(): Promise&lt;string[]&gt; { return this.itemsService.findAll(); } @Post() async create(@Body() item: string) { this.itemsService.create(item); } }</code> </pre> <br><p>  Na nova vers√£o do controlador, aplicamos o decorador <code>@Body</code> ao argumento do m√©todo <code>create</code> .  Este argumento √© usado para corresponder automaticamente os dados passados ‚Äã‚Äãatrav√©s de <code>req.body ['item']</code> ao pr√≥prio argumento (nesse caso, <code>item</code> ). <br>  Al√©m disso, nosso controlador recebe uma inst√¢ncia da classe <code>ItemsService</code> , injetada atrav√©s do construtor.  Declarar <code>ItemsService</code> como <code>private readonly</code> torna uma inst√¢ncia imut√°vel e vis√≠vel apenas dentro da classe. <br>  E n√£o se esque√ßa de registrar nosso servi√ßo em <code>app.module.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { Module } from '@nestjs/common'; import { ItemsController } from './items/items.controller'; import { ItemsService } from './items/items.service'; @Module({ imports: [], controllers: [ItemsController], providers: [ItemsService], }) export class AppModule {}</code> </pre> <br><p>  Ap√≥s todas as altera√ß√µes, vamos enviar uma solicita√ß√£o HTTP POST para o menu: </p><br><pre> <code class="bash hljs"> curl -X POST -H <span class="hljs-string"><span class="hljs-string">'content-type: application/json'</span></span> -d <span class="hljs-string"><span class="hljs-string">'{"item": "Salad"}'</span></span> localhost:3000/items</code> </pre> <br><p>  Em seguida, verificaremos se novos pratos apareceram em nosso menu fazendo uma solicita√ß√£o GET (ou abrindo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http: // localhost: 3000 / itens</a> em um navegador) </p><br><pre> <code class="bash hljs"> curl localhost:3000/items</code> </pre> <br><h4 id="sozdanie-marshruta-dlya-korziny-pokupok">  Criando uma rota de carrinho de compras </h4><br><p>  Agora que temos a primeira vers√£o do ponto de entrada <code>/items</code> nossa API, vamos implementar a funcionalidade do carrinho de compras.  O processo de cria√ß√£o dessa funcionalidade n√£o √© muito diferente da API j√° criada.  Portanto, para n√£o desorganizar o manual, criaremos um componente que responde com o status OK ao acessar. </p><br><p>  Primeiro, na pasta <code>./src/shopping-cart/</code> crie o <code>shoping-cart.controller.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { Post, Controller } from '@nestjs/common'; @Controller('shopping-cart') export class ShoppingCartController { @Post() async addItem() { return 'This is a fake service :D'; } }</code> </pre> <br><p>  Registre este controlador em nosso m√≥dulo ( <code>app.module.ts</code> ): </p><br><pre> <code class="plaintext hljs"> import { Module } from '@nestjs/common'; import { ItemsController } from './items/items.controller'; import { ShoppingCartController } from './shopping-cart/shopping-cart.controller'; import { ItemsService } from './items/items.service'; @Module({ imports: [], controllers: [ItemsController, ShoppingCartController], providers: [ItemsService], }) export class AppModule {}</code> </pre> <br><p>  Para verificar esse ponto de entrada, execute o seguinte comando, depois de verificar se o aplicativo est√° em execu√ß√£o: </p><br><pre> <code class="bash hljs"> curl -X POST localhost:3000/shopping-cart</code> </pre> <br><h4 id="dobavlenie-opisaniya--interface-typescript-dlya-items">  Adicionando um TypeScript de interface para itens </h4><br><p>  Voltar ao nosso servi√ßo de <code>items</code> .  Agora, salvamos apenas o nome do prato, mas isso claramente n√£o √© suficiente e, com certeza, queremos ter mais informa√ß√µes (por exemplo, o custo do prato).  Eu acho que voc√™ concorda que armazenar esses dados como uma matriz de seq√º√™ncias de caracteres n√£o √© uma boa ideia? <br>  Para resolver esse problema, podemos criar uma matriz de objetos.  Mas como salvar a estrutura dos objetos?  Aqui a interface TypeScript nos ajudar√°, na qual definiremos a estrutura do objeto de <code>items</code> .  Crie um novo arquivo chamado <code>item.interface.ts</code> na pasta <code>src/items</code> : </p><br><pre> <code class="plaintext hljs"> export interface Items { readonly name: string; readonly price: number; }</code> </pre> <br><p>  Em seguida, <code>items.service.ts</code> arquivo <code>items.service.ts</code> : </p><br><pre> <code class="plaintext hljs">import { Injectable } from '@nestjs/common'; import { Item } from './item.interface'; @Injectable() export class ItemsService { private readonly items: Item[] = []; findAll(): Item[] { return this.items; } create(item: Item) { this.items.push(item); } }</code> </pre> <br><p>  E tamb√©m em <code>items.controller.ts</code> : </p><br><pre> <code class="plaintext hljs">import { Get, Post, Body, Controller } from '@nestjs/common'; import { ItemsService } from './items.service'; import { Item } from './item.interface'; @Controller('items') export class ItemsController { constructor(private readonly itemsService: ItemsService) {} @Get() async findAll(): Promise&lt;Item[]&gt; { return this.itemsService.findAll(); } @Post() async create(@Body() item: Item) { this.itemsService.create(item); } }</code> </pre> <br><h4 id="validaciya-vhodnyh-dannyh-v-nestjs">  Valida√ß√£o de entrada no Nest.js </h4><br><p>  Apesar de termos determinado a estrutura do objeto do <code>item</code> , nosso aplicativo n√£o retornar√° um erro se enviarmos uma solicita√ß√£o POST inv√°lida (qualquer tipo de dado n√£o definido na interface).  Por exemplo, para tal solicita√ß√£o: </p><br><pre> <code class="bash hljs"> curl -H <span class="hljs-string"><span class="hljs-string">'Content-Type: application/json'</span></span> -d <span class="hljs-string"><span class="hljs-string">'{ "name": 3, "price": "any" }'</span></span> http://localhost:3000/items</code> </pre> <br><p>  o servidor deve responder com um status de 400 (solicita√ß√£o incorreta), mas, em vez disso, nosso aplicativo responder√° com um status de 200 (OK). </p><br><p>  Para resolver esse problema, crie um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DTO (Data Transfer Object)</a> e um componente Pipe (canal). </p><br><p>  DTO √© um objeto que define como os dados devem ser transferidos entre processos.  N√≥s descrevemos o DTO no <code>src/items/create-item.dto.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { IsString, IsInt } from 'class-validator'; export class CreateItemDto { @IsString() readonly name: string; @IsInt() readonly price: number; }</code> </pre> <br><p>  Os pipes no <code>Nest.js</code> s√£o os componentes usados ‚Äã‚Äãpara a valida√ß√£o.  Para nossa API, crie um canal no qual ele verifique se os dados enviados ao m√©todo correspondem ao DTO.  Um canal pode ser usado por controladores diferentes, portanto, crie o diret√≥rio <code>src/common/</code> com o arquivo <code>validation.pipe.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { ArgumentMetadata, BadRequestException, Injectable, PipeTransform, } from '@nestjs/common'; import { validate } from 'class-validator'; import { plainToClass } from 'class-transformer'; @Injectable() export class ValidationPipe implements PipeTransform&lt;any&gt; { async transform(value, metadata: ArgumentMetadata) { const { metatype } = metadata; if (!metatype || !this.toValidate(metatype)) { return value; } const object = plainToClass(metatype, value); const errors = await validate(object); if (errors.length &gt; 0) { throw new BadRequestException('Validation failed'); } return value; } private toValidate(metatype): boolean { const types = [String, Boolean, Number, Array, Object]; return !types.find(type =&gt; metatype === type); } }</code> </pre> <br><blockquote>  Nota: Precisamos instalar dois m√≥dulos: <code>class-validator</code> <code>class-transformer</code> .  Para fazer isso, execute o <code>npm install class-validator class-transformer</code> no console e reinicie o servidor. </blockquote><p>  Adaptando <code>items.controller.ts</code> para uso com nosso novo pipe e DTO: </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Body, Controller, UsePipes } from '@nestjs/common'; import { CreateItemDto } from './create-item.dto'; import { ItemsService } from './items.service'; import { Item } from './item.interface'; import { ValidationPipe } from '../common/validation.pipe'; @Controller('items') export class ItemsController { constructor(private readonly itemsService: ItemsService) {} @Get() async findAll(): Promise&lt;Item[]&gt; { return this.itemsService.findAll(); } @Post() @UsePipes(new ValidationPipe()) async create(@Body() createItemDto: CreateItemDto) { this.itemsService.create(createItemDto); } }</code> </pre> <br><p>  Vamos verificar nosso c√≥digo novamente, agora a entrada <code>/items</code> aceita dados apenas se eles estiverem definidos no DTO.  Por exemplo: </p><br><pre> <code class="bash hljs"> curl -H <span class="hljs-string"><span class="hljs-string">'Content-Type: application/json'</span></span> -d <span class="hljs-string"><span class="hljs-string">'{ "name": "Salad", "price": 3 }'</span></span> http://localhost:3000/items</code> </pre> <br><p>  Cole dados inv√°lidos (dados que n√£o podem ser verificados no <code>ValidationPipe</code> ). Como resultado, obtemos a resposta: </p><br><pre> <code class="plaintext hljs"> {"statusCode":400,"error":"Bad Request","message":"Validation failed"}</code> </pre> <br><h5 id="sozdanie-middleware">  Criando Middleware </h5><br><p>  De acordo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">com a p√°gina de guia de in√≠cio r√°pido do Auth0</a> , a maneira recomendada de verificar o token JWT emitido pelo Auth0 √© usar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">middleware Express</a> fornecido pelo <code>express-jwt</code> .  Esse middleware automatiza grande parte do trabalho. </p><br><p>  Vamos criar um arquivo <code>authentication.middleware.ts</code> dentro do diret√≥rio <code>src / common</code> com o seguinte c√≥digo: </p><br><pre> <code class="plaintext hljs"> import { NestMiddleware } from '@nestjs/common'; import * as jwt from 'express-jwt'; import { expressJwtSecret } from 'jwks-rsa'; export class AuthenticationMiddleware implements NestMiddleware { use(req, res, next) { jwt({ secret: expressJwtSecret({ cache: true, rateLimit: true, jwksRequestsPerMinute: 5, jwksUri: 'https://${DOMAIN}/.well-known/jwks.json', }), audience: 'http://localhost:3000', issuer: 'https://${DOMAIN}/', algorithm: 'RS256', })(req, res, err =&gt; { if (err) { const status = err.status || 500; const message = err.message || 'Sorry, we were unable to process your request.'; return res.status(status).send({ message, }); } next(); }); }; }</code> </pre> <br><p>  Substitua <code>${DOMAIN}</code> pelo valor do <em>dom√≠nio</em> nas configura√ß√µes do aplicativo Auth0 </p><br><blockquote>  Nota do tradutor: em um aplicativo real, retire <code>DOMAIN</code> em uma constante e defina seu valor via <code>env</code> (ambiente virtual) </blockquote><p>  Instale as <code>jwks-rsa</code> <code>express-jwt</code> e <code>express-jwt</code> <code>jwks-rsa</code> : </p><br><pre> <code class="bash hljs"> npm install express-jwt jwks-rsa</code> </pre> <br><p>  √â necess√°rio conectar o middleware criado (manipulador) ao nosso aplicativo.  Para fazer isso, no arquivo <code>./src/app.module.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { Module, MiddlewareConsumer, RequestMethod } from '@nestjs/common'; import { AuthenticationMiddleware } from './common/authentication.middleware'; import { ItemsController } from './items/items.controller'; import { ShoppingCartController } from './shopping-cart/shopping-cart.controller'; import { ItemsService } from './items/items.service'; @Module({ imports: [], controllers: [ItemsController, ShoppingCartController], providers: [ItemsService], }) export class AppModule { public configure(consumer: MiddlewareConsumer) { consumer .apply(AuthenticationMiddleware) .forRoutes( { path: '/items', method: RequestMethod.POST }, { path: '/shopping-cart', method: RequestMethod.POST }, ); } }</code> </pre> <br><p>  O c√≥digo acima diz que as solicita√ß√µes POST para as rotas <code>/items</code> e <code>/shopping-cart</code> s√£o protegidas pelo <em>middleware Express</em> , que verifica o token de acesso na solicita√ß√£o. </p><br><p>  Reinicie o servidor de desenvolvimento ( <code>npm run start:dev</code> ) e chame a API Nest.js: </p><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#     curl -X POST http://localhost:3000/shopping-cart #      TOKEN="eyJ0eXAiO...Mh0dpeNpg" # and issue a POST request with it curl -X POST -H 'authorization: Bearer '$TOKEN http://localhost:3000/shopping-cart</span></span></code> </pre> <br><h5 id="upravlenie-rolyami-s-auth0">  Gerenciamento de fun√ß√µes com Auth0 </h5><br><p>  No momento, qualquer usu√°rio com um token verificado pode postar itens em nossa API.  No entanto, gostar√≠amos que apenas usu√°rios com direitos de administrador possam fazer isso.  Para implementar esta fun√ß√£o, usamos as <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">regras (regras) Auth0</a> . </p><br><p>  Ent√£o, v√° para o painel de controle Auth0, na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">se√ß√£o <em>Regras</em></a> .  L√°, clique no bot√£o <code>+ CREATE RULE</code> e selecione "Definir fun√ß√µes para um usu√°rio" como modelo de regra. </p><br><p><img src="https://habrastorage.org/webt/qa/bz/6m/qabz6mavaqzu_qfeh9vxn8xkn4w.png"></p><br><p>  Feito isso, obtemos um arquivo JavaScript com um modelo de regra que adiciona a fun√ß√£o de administrador a qualquer usu√°rio com email pertencente a um determinado dom√≠nio.  Vamos mudar alguns detalhes neste modelo para obter um exemplo funcional.  Para nosso aplicativo, concederemos ao administrador apenas acesso ao nosso pr√≥prio endere√ßo de email.  Tamb√©m precisaremos alterar o local para armazenar informa√ß√µes de status do administrador. </p><br><p>  No momento, essas informa√ß√µes s√£o armazenadas em um token de identifica√ß√£o (usado para fornecer informa√ß√µes sobre o usu√°rio), mas um token de acesso deve ser usado para acessar recursos na API.  O c√≥digo ap√≥s as altera√ß√µes deve ficar assim: </p><br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user, context, callback</span></span></span><span class="hljs-function">) </span></span>{ user.app_metadata = user.app_metadata || {}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (user.email &amp;&amp; user.email === <span class="hljs-string"><span class="hljs-string">'${YOUR_EMAIL}'</span></span>) { user.app_metadata.roles = [<span class="hljs-string"><span class="hljs-string">'admin'</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { user.app_metadata.roles = [<span class="hljs-string"><span class="hljs-string">'user'</span></span>]; } auth0.users .updateAppMetadata(user.user_id, user.app_metadata) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ context.accessToken[<span class="hljs-string"><span class="hljs-string">'http://localhost:3000/roles'</span></span>] = user.app_metadata.roles; callback(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, user, context); }) .catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{ callback(err); }); }</code> </pre> <br><blockquote>  Nota: substitua <code>${YOUR_EMAIL}</code> pelo seu endere√ßo de email.  √â importante observar que, como regra, quando voc√™ lida com email nas regras Auth0, √© ideal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">for√ßar a verifica√ß√£o por email</a> .  Nesse caso, isso n√£o √© necess√°rio porque usamos nosso pr√≥prio endere√ßo de email. <br><br>  Nota do tradutor: o fragmento de c√≥digo acima √© inserido no navegador na p√°gina de configura√ß√£o da regra Auth0 </blockquote><p>  Para verificar se o token passado para nossa API √© o token de administrador, precisamos criar um <em>protetor</em> Nest.js.  Na pasta <code>src/common</code> , crie o arquivo <code>admin.guard.ts</code> </p><br><pre> <code class="plaintext hljs"> import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common'; @Injectable() export class AdminGuard implements CanActivate { canActivate(context: ExecutionContext): boolean { const user = context.getArgs()[0].user['http://localhost:3000/roles'] || ''; return user.indexOf('admin') &gt; -1; } }</code> </pre> <br><p>  Agora, se repetirmos o processo de login descrito acima e usarmos o endere√ßo de email definido na regra, obteremos um novo <code>access_token</code> .  Para verificar o conte√∫do deste <code>access_token</code> , copie e cole o token no campo <code>Encoded</code> do site <code>https://jwt.io/</code> .  Veremos que a se√ß√£o de carga √∫til desse token cont√©m a seguinte matriz: </p><br><pre> <code class="plaintext hljs"> "http://localhost:3000/roles": [ "admin" ]</code> </pre> <br><p>  Se nosso token incluir realmente essas informa√ß√µes, continuaremos a integra√ß√£o com o Auth0.  Ent√£o, abra <code>items.controller.ts</code> e adicione nosso novo protetor l√°: </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Body, Controller, UsePipes, UseGuards, } from '@nestjs/common'; import { CreateItemDto } from './create-item.dto'; import { ItemsService } from './items.service'; import { Item } from './item.interface'; import { ValidationPipe } from '../common/validation.pipe'; import { AdminGuard } from '../common/admin.guard'; @Controller('items') export class ItemsController { constructor(private readonly itemsService: ItemsService) {} @Get() async findAll(): Promise&lt;Item[]&gt; { return this.itemsService.findAll(); } @Post() @UseGuards(new AdminGuard()) @UsePipes(new ValidationPipe()) async create(@Body() createItemDto: CreateItemDto) { this.itemsService.create(createItemDto); } }</code> </pre> <br><p>  Agora, com nosso novo token, podemos adicionar novos itens por meio de nossa API: </p><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#    npm run start:dev #  POST       curl -X POST -H 'Content-Type: application/json' \ -H 'authorization: Bearer '$TOKEN -d '{ "name": "Salad", "price": 3 }' http://localhost:3000/items</span></span></code> </pre> <br><blockquote>  Nota do tradutor: para verifica√ß√£o, voc√™ pode ver o que temos nos itens: <br><pre> <code class="plaintext hljs">curl -X GET http://localhost:3000/items</code> </pre> <br></blockquote><br><h4 id="itogi">  Sum√°rio </h4><br><p>  Parab√©ns!  Acabamos de criar nossa API Nest.JS e agora podemos nos concentrar no desenvolvimento da parte front-end do nosso aplicativo!  Verifique a segunda parte desta s√©rie: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aplicativos TypeScript de pilha completa - Parte 2: Desenvolvendo aplicativos angulares de front-end.</a> </p><br><blockquote>  Nota do tradutor: A tradu√ß√£o da segunda parte est√° em andamento. </blockquote><p>  Para resumir, neste artigo, usamos v√°rios recursos do Nest.js e TypeScript: m√≥dulos, controladores, servi√ßos, interfaces, pipes, middleware e guarda para criar API  Espero que voc√™ tenha uma boa experi√™ncia e esteja pronto para continuar desenvolvendo nosso aplicativo.  Se algo n√£o estiver claro para voc√™, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o oficial do nest.js.</a> √© uma boa fonte com respostas </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt471348/">https://habr.com/ru/post/pt471348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt471334/index.html">Para memorizar, mas n√£o para empinar - aprendendo ‚Äúpor cart√µes‚Äù</a></li>
<li><a href="../pt471336/index.html">Holivar. Hist√≥ria do Runet. Parte 6. Fechaduras: Lurk, Tape, 282nd e caminho chin√™s</a></li>
<li><a href="../pt471340/index.html">Drimsim vs Mate 20 Pro Round! Mas para quem?</a></li>
<li><a href="../pt471342/index.html">Stylish Avalonia</a></li>
<li><a href="../pt471344/index.html">Mais uma vez sobre o ImmutableList em Java</a></li>
<li><a href="../pt471350/index.html">Engenharia reversa de amplificadores operacionais de baixo ru√≠do de um computador anal√≥gico em 1969</a></li>
<li><a href="../pt471352/index.html">Escrevendo apresenta√ß√µes no LaTeX</a></li>
<li><a href="../pt471358/index.html">Como escrever um contrato inteligente com Python ontologia? Parte 4: API nativa</a></li>
<li><a href="../pt471360/index.html">M√©todo de duplica√ß√£o. 11 exemplos do design do ICE</a></li>
<li><a href="../pt471364/index.html">Gerenciamento automatizado de testes com o Telegram</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>