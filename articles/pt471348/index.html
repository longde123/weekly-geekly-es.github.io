<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🍳 ⛹🏻 🤵🏼 Aplicativos TypeScript de pilha completa 🌾 🗓️ 🛤️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá Habr! Apresento a você a tradução do artigo "Aplicativos TypeScript de pilha completa - Parte 1: Desenvolvendo APIs de back-end com Nest.js", de A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aplicativos TypeScript de pilha completa</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471348/"><p>  Olá Habr!  Apresento a você a tradução do artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Aplicativos TypeScript de pilha completa - Parte 1: Desenvolvendo APIs de back-end com Nest.js",</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ana Ribeiro</a> . </p><br><h2 id="chast-1-razrabotka-servernogo-api-s-pomoschyu-nestjs">  Parte 1: Desenvolvendo a API do servidor usando o Nest.JS </h2><br><p>  TL; DR: esta é uma série de artigos sobre como criar um aplicativo Web TypeScript usando Angular e Nest.JS.  Na primeira parte, escreveremos uma API de servidor simples usando o Nest.JS.  A segunda parte desta série é dedicada ao aplicativo front-end usando Angular.  Você pode encontrar o código final desenvolvido neste artigo neste <a href="">repositório GitHub.</a> </p><br><h3 id="chto-takoe-nestjs-i-pochemu-imenno-angular">  O que é o Nest.Js e por que o Angular? </h3><br><p>  Nest.js é uma estrutura para a criação de aplicativos de servidor da web Node.js. </p><br><p>  Uma característica distintiva é que ele resolve um problema que nenhuma outra estrutura resolve: a estrutura do projeto node.js. <a name="habracut"></a>  Se você já desenvolveu o node.js, sabe que pode fazer muito com um módulo (por exemplo, o middleware Express pode fazer de tudo, da autenticação à validação), o que, no final, pode levar a uma "bagunça" não suportada .  Como você verá abaixo, o nest.js nos ajudará com isso, fornecendo aulas especializadas em vários problemas. </p><br><p>  O Nest.js é fortemente inspirado pelo Angular.  Por exemplo <cut></cut>  ambas as plataformas usam proteções para permitir ou impedir o acesso a algumas partes de seus aplicativos e ambas fornecem uma interface CanActivate para implementar essas proteções.  No entanto, é importante notar que, apesar de alguns conceitos semelhantes, ambas as estruturas são independentes uma da outra.  Ou seja, neste artigo, criaremos uma API independente para nosso front-end, que pode ser usada com qualquer outra estrutura (React, Vue.JS e assim por diante). </p><br><h3 id="veb-prilozhenie-dlya-on-layn-zakazov">  Aplicativo da Web para pedidos on-line </h3><br><p>  Neste guia, criaremos um aplicativo simples no qual os usuários podem fazer pedidos em um restaurante.  Ele implementará esta lógica: </p><br><ul><li>  qualquer usuário pode visualizar o menu; </li><li>  somente um usuário autorizado pode adicionar mercadorias à cesta (fazer um pedido) </li><li>  somente o administrador pode adicionar novos itens de menu. </li></ul><br><p>  Para simplificar, não interagiremos com um banco de dados externo e não implementaremos a funcionalidade do nosso carrinho de compras. </p><cut></cut><br><h3 id="sozdanie-faylovoy-struktury-proekta-nestjs">  Criando a estrutura de arquivos do projeto Nest.js </h3><br><p>  Para instalar o Nest.js, precisamos instalar o Node.js (v.8.9.x ou superior) e o NPM.  Baixe e instale o Node.js para o seu sistema operacional no site oficial (NPM está incluído).  Quando tudo estiver instalado, verifique as versões: </p><br><pre><code class="bash hljs">node -v <span class="hljs-comment"><span class="hljs-comment"># v12.11.1 npm -v # 6.11.3</span></span></code> </pre> <br><p>  Existem diferentes maneiras de criar um projeto com o Nest.js.  eles podem ser encontrados na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação</a> .  Vamos usar o <code>nest-cli</code> .  Instale-o: </p><br><p> <code>npm i -g @nestjs/cli</code> </p> <br><p>  Em seguida, crie nosso projeto com um comando simples: </p><br><p> <code>nest new nest-restaurant-api</code> </p> <br><p>  no processo, o nest solicitará que escolha um gerenciador de pacotes: <code>npm</code> ou <code>yarn</code> </p><br><p>  Se tudo der certo, o <code>nest</code> criará a seguinte estrutura de arquivo: </p><br><pre> <code class="plaintext hljs">nest-restaurant-api ├── src │ ├── app.controller.spec.ts │ ├── app.controller.ts │ ├── app.module.ts │ ├── app.service.ts │ └── main.ts ├── test │ ├── app.e2e-spec.ts │ └── jest-e2e.json ├── .gitignore ├── .prettierrc ├── nest-cli.json ├── package.json ├── package-lock.json ├── README.md ├── tsconfig.build.json ├── tsconfig.json └── tslint.json</code> </pre> <br><p>  vá para o diretório criado e inicie o servidor de desenvolvimento: </p><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#    cd nest-restaurant-api #   npm run start:dev</span></span></code> </pre> <br><p>  Abra um navegador e digite <code>http://localhost:3000</code> .  Na tela, veremos: <br><img src="https://habrastorage.org/webt/xl/pk/tl/xlpktlb_nkwfh6-akeba7wtnmjc.png"></p><br><p>  Como parte deste tutorial, não testaremos nossa API (embora você deva escrever testes para qualquer aplicativo pronto para uso).  Dessa forma, você pode limpar o diretório de <code>test</code> e excluir o <code>src/app.controller.spec.ts</code> (que é o teste).  Como resultado, nossa pasta de origem contém os seguintes arquivos: </p><br><ul><li>  <code>src/app.controller.ts</code> e <code>src/app.module.ts</code> : esses arquivos são responsáveis ​​por criar a mensagem <code>Hello world</code> ao longo da rota <code>/</code> .  Porque  este ponto de entrada não é importante para esta aplicação, nós os excluímos.  Em breve, você aprenderá com mais detalhes o que são <strong>controladores</strong> e <strong>serviços</strong> . </li><li>  <code>src/app.module.ts</code> : contém uma descrição de uma classe do tipo <strong>módulo</strong> , responsável por declarar a importação, exportação de controladores e provedores para o aplicativo nest.js.  Cada aplicativo possui pelo menos um módulo, mas você pode criar mais de um módulo para aplicativos mais complexos (mais na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação</a> . Nosso aplicativo conterá apenas um módulo </li><li>  <code>src/main.ts</code> : este é o arquivo responsável por iniciar o servidor. </li></ul><br><blockquote><cut text=""></cut>  Nota: após remover <code>src/app.controller.ts</code> e <code>src/app.module.ts</code> você não poderá iniciar nosso aplicativo.  Não se preocupe, nós resolveremos isso em breve. </blockquote><br><h3 id="sozdanie-tochek-vhoda-endpoints">  Criar pontos de entrada (pontos de extremidade) </h3><br><br><p>  Nossa API estará disponível na rota <code>/items</code> .  Por meio desse ponto de entrada, os usuários podem receber dados e os administradores gerenciam o menu.  Vamos criá-lo. </p><br><p>  Para fazer isso, crie um diretório chamado <code>items</code> dentro do <code>src</code> .  Todos os arquivos associados à rota <code>/items</code> serão armazenados neste novo diretório. </p><br><h4 id="sozdanie-kontrollerov">  Criando controladores </h4><br><p>  no <code>nest.js</code> , como em muitas outras estruturas, os controladores são responsáveis ​​pelo mapeamento de rotas com funcionalidade.  Para criar um controlador no <code>nest.js</code> use o decorador <code>nest.js</code> seguinte maneira: <code>@Controller(${ENDPOINT})</code> .  Além disso, para mapear vários métodos <code>HTTP</code> , como <code>GET</code> e <code>POST</code> , são usados ​​os decoradores <code>@Post</code> , <code>@Delete</code> , <code>@Delete</code> etc. </p><br><p>  No nosso caso, precisamos criar um controlador que retorne os pratos disponíveis no restaurante e que os administradores usarão para gerenciar o conteúdo do menu.  Vamos criar um arquivo chamado <code>items.controller.tc</code> no diretório <code>src/items</code> com o seguinte conteúdo: </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Controller } from '@nestjs/common'; @Controller('items') export class ItemsController { @Get() async findAll(): Promise&lt;string[]&gt; { return ['Pizza', 'Coke']; } @Post() async create() { return 'Not yet implemented'; } }</code> </pre> <br><p>  para disponibilizar nosso novo controlador em nosso aplicativo, registre-o no módulo: </p><br><pre> <code class="plaintext hljs"> import { Module } from '@nestjs/common'; import { ItemsController } from './items/items.controller'; @Module({ imports: [], controllers: [ItemsController], providers: [], }) export class AppModule {}</code> </pre> <br><p>  Inicie nosso aplicativo: <code>npm run start:dev</code> e abra no navegador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http: // localhost: 3000 / items</a> , se você fez tudo corretamente, veremos a resposta para a nossa solicitação get: <code>['Pizza', 'Coke']</code> . </p><br><p>  <em>Nota do tradutor: para criar novos controladores, assim como outros elementos do <code>nest.js</code> .: serviços, provedores etc., é mais conveniente usar o comando <code>nest generate</code> do <code>nest-cli</code> .</em>  <em>Por exemplo, para criar o controlador descrito acima, você pode usar o comando <code>nest generate controller items</code> , como resultado do qual o nest criará <code>src/items/items.controller.tc</code> <code>src/items/items.controller.spec.tc</code> e <code>src/items/items.controller.tc</code> seguinte conteúdo:</em> </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Controller } from '@nestjs/common'; @Controller('items') export class ItemsController {}</code> </pre> <br><p>  <em>e registre-o em <code>app.molule.tc</code></em> </p><br><h4 id="dobavlenie-servisa-service">  Adicionando um serviço </h4><br><p>  Agora, ao acessar <code>/items</code> nosso aplicativo retorna a mesma matriz para cada solicitação, que não podemos alterar.  Processar e salvar dados não é da conta do controlador; para essa finalidade, os serviços são destinados ao nest.js <br>  Os serviços no ninho são <code>@Injectable</code> <br>  O nome do decorador fala por si só, adicionando esse decorador à classe o torna injetável em outros componentes, como controladores. <br>  Vamos criar nosso serviço.  Crie o arquivo <code>items.service.ts</code> na pasta <code>items.service.ts</code> com o seguinte conteúdo: </p><br><pre> <code class="plaintext hljs"> import { Injectable } from '@nestjs/common'; @Injectable() export class ItemsService { private readonly items: string[] = ['Pizza', 'Coke']; findAll(): string[] { return this.items; } create(item: string) { this.items.push(item); } }</code> </pre> <br><p>  e altere o controlador <code>ItemsController</code> (declarado em <code>items.controller.ts</code> ) para usar nosso serviço: </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Body, Controller } from '@nestjs/common'; import { ItemsService } from './items.service'; @Controller('items') export class ItemsController { constructor(private readonly itemsService: ItemsService) {} @Get() async findAll(): Promise&lt;string[]&gt; { return this.itemsService.findAll(); } @Post() async create(@Body() item: string) { this.itemsService.create(item); } }</code> </pre> <br><p>  Na nova versão do controlador, aplicamos o decorador <code>@Body</code> ao argumento do método <code>create</code> .  Este argumento é usado para corresponder automaticamente os dados passados ​​através de <code>req.body ['item']</code> ao próprio argumento (nesse caso, <code>item</code> ). <br>  Além disso, nosso controlador recebe uma instância da classe <code>ItemsService</code> , injetada através do construtor.  Declarar <code>ItemsService</code> como <code>private readonly</code> torna uma instância imutável e visível apenas dentro da classe. <br>  E não se esqueça de registrar nosso serviço em <code>app.module.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { Module } from '@nestjs/common'; import { ItemsController } from './items/items.controller'; import { ItemsService } from './items/items.service'; @Module({ imports: [], controllers: [ItemsController], providers: [ItemsService], }) export class AppModule {}</code> </pre> <br><p>  Após todas as alterações, vamos enviar uma solicitação HTTP POST para o menu: </p><br><pre> <code class="bash hljs"> curl -X POST -H <span class="hljs-string"><span class="hljs-string">'content-type: application/json'</span></span> -d <span class="hljs-string"><span class="hljs-string">'{"item": "Salad"}'</span></span> localhost:3000/items</code> </pre> <br><p>  Em seguida, verificaremos se novos pratos apareceram em nosso menu fazendo uma solicitação GET (ou abrindo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http: // localhost: 3000 / itens</a> em um navegador) </p><br><pre> <code class="bash hljs"> curl localhost:3000/items</code> </pre> <br><h4 id="sozdanie-marshruta-dlya-korziny-pokupok">  Criando uma rota de carrinho de compras </h4><br><p>  Agora que temos a primeira versão do ponto de entrada <code>/items</code> nossa API, vamos implementar a funcionalidade do carrinho de compras.  O processo de criação dessa funcionalidade não é muito diferente da API já criada.  Portanto, para não desorganizar o manual, criaremos um componente que responde com o status OK ao acessar. </p><br><p>  Primeiro, na pasta <code>./src/shopping-cart/</code> crie o <code>shoping-cart.controller.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { Post, Controller } from '@nestjs/common'; @Controller('shopping-cart') export class ShoppingCartController { @Post() async addItem() { return 'This is a fake service :D'; } }</code> </pre> <br><p>  Registre este controlador em nosso módulo ( <code>app.module.ts</code> ): </p><br><pre> <code class="plaintext hljs"> import { Module } from '@nestjs/common'; import { ItemsController } from './items/items.controller'; import { ShoppingCartController } from './shopping-cart/shopping-cart.controller'; import { ItemsService } from './items/items.service'; @Module({ imports: [], controllers: [ItemsController, ShoppingCartController], providers: [ItemsService], }) export class AppModule {}</code> </pre> <br><p>  Para verificar esse ponto de entrada, execute o seguinte comando, depois de verificar se o aplicativo está em execução: </p><br><pre> <code class="bash hljs"> curl -X POST localhost:3000/shopping-cart</code> </pre> <br><h4 id="dobavlenie-opisaniya--interface-typescript-dlya-items">  Adicionando um TypeScript de interface para itens </h4><br><p>  Voltar ao nosso serviço de <code>items</code> .  Agora, salvamos apenas o nome do prato, mas isso claramente não é suficiente e, com certeza, queremos ter mais informações (por exemplo, o custo do prato).  Eu acho que você concorda que armazenar esses dados como uma matriz de seqüências de caracteres não é uma boa ideia? <br>  Para resolver esse problema, podemos criar uma matriz de objetos.  Mas como salvar a estrutura dos objetos?  Aqui a interface TypeScript nos ajudará, na qual definiremos a estrutura do objeto de <code>items</code> .  Crie um novo arquivo chamado <code>item.interface.ts</code> na pasta <code>src/items</code> : </p><br><pre> <code class="plaintext hljs"> export interface Items { readonly name: string; readonly price: number; }</code> </pre> <br><p>  Em seguida, <code>items.service.ts</code> arquivo <code>items.service.ts</code> : </p><br><pre> <code class="plaintext hljs">import { Injectable } from '@nestjs/common'; import { Item } from './item.interface'; @Injectable() export class ItemsService { private readonly items: Item[] = []; findAll(): Item[] { return this.items; } create(item: Item) { this.items.push(item); } }</code> </pre> <br><p>  E também em <code>items.controller.ts</code> : </p><br><pre> <code class="plaintext hljs">import { Get, Post, Body, Controller } from '@nestjs/common'; import { ItemsService } from './items.service'; import { Item } from './item.interface'; @Controller('items') export class ItemsController { constructor(private readonly itemsService: ItemsService) {} @Get() async findAll(): Promise&lt;Item[]&gt; { return this.itemsService.findAll(); } @Post() async create(@Body() item: Item) { this.itemsService.create(item); } }</code> </pre> <br><h4 id="validaciya-vhodnyh-dannyh-v-nestjs">  Validação de entrada no Nest.js </h4><br><p>  Apesar de termos determinado a estrutura do objeto do <code>item</code> , nosso aplicativo não retornará um erro se enviarmos uma solicitação POST inválida (qualquer tipo de dado não definido na interface).  Por exemplo, para tal solicitação: </p><br><pre> <code class="bash hljs"> curl -H <span class="hljs-string"><span class="hljs-string">'Content-Type: application/json'</span></span> -d <span class="hljs-string"><span class="hljs-string">'{ "name": 3, "price": "any" }'</span></span> http://localhost:3000/items</code> </pre> <br><p>  o servidor deve responder com um status de 400 (solicitação incorreta), mas, em vez disso, nosso aplicativo responderá com um status de 200 (OK). </p><br><p>  Para resolver esse problema, crie um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DTO (Data Transfer Object)</a> e um componente Pipe (canal). </p><br><p>  DTO é um objeto que define como os dados devem ser transferidos entre processos.  Nós descrevemos o DTO no <code>src/items/create-item.dto.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { IsString, IsInt } from 'class-validator'; export class CreateItemDto { @IsString() readonly name: string; @IsInt() readonly price: number; }</code> </pre> <br><p>  Os pipes no <code>Nest.js</code> são os componentes usados ​​para a validação.  Para nossa API, crie um canal no qual ele verifique se os dados enviados ao método correspondem ao DTO.  Um canal pode ser usado por controladores diferentes, portanto, crie o diretório <code>src/common/</code> com o arquivo <code>validation.pipe.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { ArgumentMetadata, BadRequestException, Injectable, PipeTransform, } from '@nestjs/common'; import { validate } from 'class-validator'; import { plainToClass } from 'class-transformer'; @Injectable() export class ValidationPipe implements PipeTransform&lt;any&gt; { async transform(value, metadata: ArgumentMetadata) { const { metatype } = metadata; if (!metatype || !this.toValidate(metatype)) { return value; } const object = plainToClass(metatype, value); const errors = await validate(object); if (errors.length &gt; 0) { throw new BadRequestException('Validation failed'); } return value; } private toValidate(metatype): boolean { const types = [String, Boolean, Number, Array, Object]; return !types.find(type =&gt; metatype === type); } }</code> </pre> <br><blockquote>  Nota: Precisamos instalar dois módulos: <code>class-validator</code> <code>class-transformer</code> .  Para fazer isso, execute o <code>npm install class-validator class-transformer</code> no console e reinicie o servidor. </blockquote><p>  Adaptando <code>items.controller.ts</code> para uso com nosso novo pipe e DTO: </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Body, Controller, UsePipes } from '@nestjs/common'; import { CreateItemDto } from './create-item.dto'; import { ItemsService } from './items.service'; import { Item } from './item.interface'; import { ValidationPipe } from '../common/validation.pipe'; @Controller('items') export class ItemsController { constructor(private readonly itemsService: ItemsService) {} @Get() async findAll(): Promise&lt;Item[]&gt; { return this.itemsService.findAll(); } @Post() @UsePipes(new ValidationPipe()) async create(@Body() createItemDto: CreateItemDto) { this.itemsService.create(createItemDto); } }</code> </pre> <br><p>  Vamos verificar nosso código novamente, agora a entrada <code>/items</code> aceita dados apenas se eles estiverem definidos no DTO.  Por exemplo: </p><br><pre> <code class="bash hljs"> curl -H <span class="hljs-string"><span class="hljs-string">'Content-Type: application/json'</span></span> -d <span class="hljs-string"><span class="hljs-string">'{ "name": "Salad", "price": 3 }'</span></span> http://localhost:3000/items</code> </pre> <br><p>  Cole dados inválidos (dados que não podem ser verificados no <code>ValidationPipe</code> ). Como resultado, obtemos a resposta: </p><br><pre> <code class="plaintext hljs"> {"statusCode":400,"error":"Bad Request","message":"Validation failed"}</code> </pre> <br><h5 id="sozdanie-middleware">  Criando Middleware </h5><br><p>  De acordo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">com a página de guia de início rápido do Auth0</a> , a maneira recomendada de verificar o token JWT emitido pelo Auth0 é usar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">middleware Express</a> fornecido pelo <code>express-jwt</code> .  Esse middleware automatiza grande parte do trabalho. </p><br><p>  Vamos criar um arquivo <code>authentication.middleware.ts</code> dentro do diretório <code>src / common</code> com o seguinte código: </p><br><pre> <code class="plaintext hljs"> import { NestMiddleware } from '@nestjs/common'; import * as jwt from 'express-jwt'; import { expressJwtSecret } from 'jwks-rsa'; export class AuthenticationMiddleware implements NestMiddleware { use(req, res, next) { jwt({ secret: expressJwtSecret({ cache: true, rateLimit: true, jwksRequestsPerMinute: 5, jwksUri: 'https://${DOMAIN}/.well-known/jwks.json', }), audience: 'http://localhost:3000', issuer: 'https://${DOMAIN}/', algorithm: 'RS256', })(req, res, err =&gt; { if (err) { const status = err.status || 500; const message = err.message || 'Sorry, we were unable to process your request.'; return res.status(status).send({ message, }); } next(); }); }; }</code> </pre> <br><p>  Substitua <code>${DOMAIN}</code> pelo valor do <em>domínio</em> nas configurações do aplicativo Auth0 </p><br><blockquote>  Nota do tradutor: em um aplicativo real, retire <code>DOMAIN</code> em uma constante e defina seu valor via <code>env</code> (ambiente virtual) </blockquote><p>  Instale as <code>jwks-rsa</code> <code>express-jwt</code> e <code>express-jwt</code> <code>jwks-rsa</code> : </p><br><pre> <code class="bash hljs"> npm install express-jwt jwks-rsa</code> </pre> <br><p>  É necessário conectar o middleware criado (manipulador) ao nosso aplicativo.  Para fazer isso, no arquivo <code>./src/app.module.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { Module, MiddlewareConsumer, RequestMethod } from '@nestjs/common'; import { AuthenticationMiddleware } from './common/authentication.middleware'; import { ItemsController } from './items/items.controller'; import { ShoppingCartController } from './shopping-cart/shopping-cart.controller'; import { ItemsService } from './items/items.service'; @Module({ imports: [], controllers: [ItemsController, ShoppingCartController], providers: [ItemsService], }) export class AppModule { public configure(consumer: MiddlewareConsumer) { consumer .apply(AuthenticationMiddleware) .forRoutes( { path: '/items', method: RequestMethod.POST }, { path: '/shopping-cart', method: RequestMethod.POST }, ); } }</code> </pre> <br><p>  O código acima diz que as solicitações POST para as rotas <code>/items</code> e <code>/shopping-cart</code> são protegidas pelo <em>middleware Express</em> , que verifica o token de acesso na solicitação. </p><br><p>  Reinicie o servidor de desenvolvimento ( <code>npm run start:dev</code> ) e chame a API Nest.js: </p><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#     curl -X POST http://localhost:3000/shopping-cart #      TOKEN="eyJ0eXAiO...Mh0dpeNpg" # and issue a POST request with it curl -X POST -H 'authorization: Bearer '$TOKEN http://localhost:3000/shopping-cart</span></span></code> </pre> <br><h5 id="upravlenie-rolyami-s-auth0">  Gerenciamento de funções com Auth0 </h5><br><p>  No momento, qualquer usuário com um token verificado pode postar itens em nossa API.  No entanto, gostaríamos que apenas usuários com direitos de administrador possam fazer isso.  Para implementar esta função, usamos as <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">regras (regras) Auth0</a> . </p><br><p>  Então, vá para o painel de controle Auth0, na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">seção <em>Regras</em></a> .  Lá, clique no botão <code>+ CREATE RULE</code> e selecione "Definir funções para um usuário" como modelo de regra. </p><br><p><img src="https://habrastorage.org/webt/qa/bz/6m/qabz6mavaqzu_qfeh9vxn8xkn4w.png"></p><br><p>  Feito isso, obtemos um arquivo JavaScript com um modelo de regra que adiciona a função de administrador a qualquer usuário com email pertencente a um determinado domínio.  Vamos mudar alguns detalhes neste modelo para obter um exemplo funcional.  Para nosso aplicativo, concederemos ao administrador apenas acesso ao nosso próprio endereço de email.  Também precisaremos alterar o local para armazenar informações de status do administrador. </p><br><p>  No momento, essas informações são armazenadas em um token de identificação (usado para fornecer informações sobre o usuário), mas um token de acesso deve ser usado para acessar recursos na API.  O código após as alterações deve ficar assim: </p><br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user, context, callback</span></span></span><span class="hljs-function">) </span></span>{ user.app_metadata = user.app_metadata || {}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (user.email &amp;&amp; user.email === <span class="hljs-string"><span class="hljs-string">'${YOUR_EMAIL}'</span></span>) { user.app_metadata.roles = [<span class="hljs-string"><span class="hljs-string">'admin'</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { user.app_metadata.roles = [<span class="hljs-string"><span class="hljs-string">'user'</span></span>]; } auth0.users .updateAppMetadata(user.user_id, user.app_metadata) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ context.accessToken[<span class="hljs-string"><span class="hljs-string">'http://localhost:3000/roles'</span></span>] = user.app_metadata.roles; callback(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, user, context); }) .catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{ callback(err); }); }</code> </pre> <br><blockquote>  Nota: substitua <code>${YOUR_EMAIL}</code> pelo seu endereço de email.  É importante observar que, como regra, quando você lida com email nas regras Auth0, é ideal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">forçar a verificação por email</a> .  Nesse caso, isso não é necessário porque usamos nosso próprio endereço de email. <br><br>  Nota do tradutor: o fragmento de código acima é inserido no navegador na página de configuração da regra Auth0 </blockquote><p>  Para verificar se o token passado para nossa API é o token de administrador, precisamos criar um <em>protetor</em> Nest.js.  Na pasta <code>src/common</code> , crie o arquivo <code>admin.guard.ts</code> </p><br><pre> <code class="plaintext hljs"> import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common'; @Injectable() export class AdminGuard implements CanActivate { canActivate(context: ExecutionContext): boolean { const user = context.getArgs()[0].user['http://localhost:3000/roles'] || ''; return user.indexOf('admin') &gt; -1; } }</code> </pre> <br><p>  Agora, se repetirmos o processo de login descrito acima e usarmos o endereço de email definido na regra, obteremos um novo <code>access_token</code> .  Para verificar o conteúdo deste <code>access_token</code> , copie e cole o token no campo <code>Encoded</code> do site <code>https://jwt.io/</code> .  Veremos que a seção de carga útil desse token contém a seguinte matriz: </p><br><pre> <code class="plaintext hljs"> "http://localhost:3000/roles": [ "admin" ]</code> </pre> <br><p>  Se nosso token incluir realmente essas informações, continuaremos a integração com o Auth0.  Então, abra <code>items.controller.ts</code> e adicione nosso novo protetor lá: </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Body, Controller, UsePipes, UseGuards, } from '@nestjs/common'; import { CreateItemDto } from './create-item.dto'; import { ItemsService } from './items.service'; import { Item } from './item.interface'; import { ValidationPipe } from '../common/validation.pipe'; import { AdminGuard } from '../common/admin.guard'; @Controller('items') export class ItemsController { constructor(private readonly itemsService: ItemsService) {} @Get() async findAll(): Promise&lt;Item[]&gt; { return this.itemsService.findAll(); } @Post() @UseGuards(new AdminGuard()) @UsePipes(new ValidationPipe()) async create(@Body() createItemDto: CreateItemDto) { this.itemsService.create(createItemDto); } }</code> </pre> <br><p>  Agora, com nosso novo token, podemos adicionar novos itens por meio de nossa API: </p><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#    npm run start:dev #  POST       curl -X POST -H 'Content-Type: application/json' \ -H 'authorization: Bearer '$TOKEN -d '{ "name": "Salad", "price": 3 }' http://localhost:3000/items</span></span></code> </pre> <br><blockquote>  Nota do tradutor: para verificação, você pode ver o que temos nos itens: <br><pre> <code class="plaintext hljs">curl -X GET http://localhost:3000/items</code> </pre> <br></blockquote><br><h4 id="itogi">  Sumário </h4><br><p>  Parabéns!  Acabamos de criar nossa API Nest.JS e agora podemos nos concentrar no desenvolvimento da parte front-end do nosso aplicativo!  Verifique a segunda parte desta série: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aplicativos TypeScript de pilha completa - Parte 2: Desenvolvendo aplicativos angulares de front-end.</a> </p><br><blockquote>  Nota do tradutor: A tradução da segunda parte está em andamento. </blockquote><p>  Para resumir, neste artigo, usamos vários recursos do Nest.js e TypeScript: módulos, controladores, serviços, interfaces, pipes, middleware e guarda para criar API  Espero que você tenha uma boa experiência e esteja pronto para continuar desenvolvendo nosso aplicativo.  Se algo não estiver claro para você, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação oficial do nest.js.</a> é uma boa fonte com respostas </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt471348/">https://habr.com/ru/post/pt471348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt471334/index.html">Para memorizar, mas não para empinar - aprendendo “por cartões”</a></li>
<li><a href="../pt471336/index.html">Holivar. História do Runet. Parte 6. Fechaduras: Lurk, Tape, 282nd e caminho chinês</a></li>
<li><a href="../pt471340/index.html">Drimsim vs Mate 20 Pro Round! Mas para quem?</a></li>
<li><a href="../pt471342/index.html">Stylish Avalonia</a></li>
<li><a href="../pt471344/index.html">Mais uma vez sobre o ImmutableList em Java</a></li>
<li><a href="../pt471350/index.html">Engenharia reversa de amplificadores operacionais de baixo ruído de um computador analógico em 1969</a></li>
<li><a href="../pt471352/index.html">Escrevendo apresentações no LaTeX</a></li>
<li><a href="../pt471358/index.html">Como escrever um contrato inteligente com Python ontologia? Parte 4: API nativa</a></li>
<li><a href="../pt471360/index.html">Método de duplicação. 11 exemplos do design do ICE</a></li>
<li><a href="../pt471364/index.html">Gerenciamento automatizado de testes com o Telegram</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>