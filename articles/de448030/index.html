<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍭 💪🏿 👋🏻 Anzeige und Optimierung der Terminalausgabe im Web 👨🏽‍⚖️ 👨🏽‍🎨 🐺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor nicht allzu langer Zeit stieß ich auf eine recht einfache und gleichzeitig interessante Aufgabe: die Implementierung eines schreibgeschützten Term...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Anzeige und Optimierung der Terminalausgabe im Web</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448030/"><p>  Vor nicht allzu langer Zeit stieß ich auf eine recht einfache und gleichzeitig interessante Aufgabe: die Implementierung eines schreibgeschützten Terminals in einer Webanwendung.  Das Interesse an der Aufgabe wurde durch drei wichtige Aspekte geweckt: </p><br><ul><li>  Unterstützung für grundlegende <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ANSI-Escape-Sequenzen</a> </li><li>  Unterstützung für mindestens 50.000 Datenleitungen </li><li>  Daten anzeigen, sobald sie verfügbar sind. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ku/fa/rk/kufarkakkmxskpfqqokeixh_ste.png"></div><br><p>  In diesem Artikel werde ich darüber sprechen, wie es implementiert und wie es dann alles optimiert hat. </p><a name="habracut"></a><br><p>  <em>Haftungsausschluss: Ich bin kein erfahrener Webentwickler, daher scheinen Ihnen einige Dinge offensichtlich zu sein, und die Schlussfolgerungen oder Entscheidungen sind falsch.</em>  <em>Für Korrekturen und Klarstellungen bin ich dankbar.</em> </p><br><h2 id="dlya-chego-eto-zatevalos">  Warum war es an </h2><br><p>  Die ganze Aufgabe ist wie folgt: Ein Skript wird auf dem Server ausgeführt (Bash, Python usw.) und schreibt etwas in stdout.  Und diese Schlussfolgerung muss auf der Webseite angezeigt werden, sobald sie eintrifft.  Gleichzeitig sollte es wie auf dem Terminal aussehen (mit Formatierung, Cursorübertragung usw.). <br>  Ich kontrolliere das Skript selbst und seine Ausgabe in keiner Weise und zeige es in reiner Form an. </p><br><p>  Natürlich sollte sich zwischen der Weboberfläche und dem Skript ein Vermittler befinden - ein Webserver.  Und wenn nicht zu zerstreuen - ich habe bereits eine Webanwendung und einen Server und arbeite irgendwie.  Das Schema sieht ungefähr so ​​aus: <br><img src="https://habrastorage.org/webt/ww/kb/ei/wwkbei13_tv9n6w6vcw_6c4e5dm.png"></p><br><p>  Zuvor war der Server für die Verarbeitung und Formatierung verantwortlich.  Und ich wollte es aus einer Vielzahl von Gründen verbessern: </p><br><ul><li>  Doppelte Datenverarbeitung - zuerst auf dem Server analysieren, dann auf dem Client in HTML-Komponenten umwandeln </li><li>  Nicht optimaler Algorithmus aufgrund der Datenaufbereitung für den Client </li><li>  Hohe Belastung des Servers - Die Verarbeitung der Ausgabe eines einzelnen Skripts kann einen einzelnen Thread vollständig auf den Server laden </li><li>  unvollständige Unterstützung für ANSI Escape-Sequenzen </li><li>  subtile Fehler </li><li>  Der Client hat sehr schlecht mit der Anzeige von sogar 10.000 formatierten Zeilen abgeschnitten </li></ul><br><p>  Daher wurde beschlossen, die gesamte Parsing-Logik auf die Webanwendung zu übertragen und nur Streaming-Rohdaten auf den Server zu übertragen </p><br><h2 id="postanovka-zadachi">  Erklärung des Problems </h2><br><p>  Teile des Textes kommen zum Kunden.  Der Client muss sie in Komponenten zerlegen: Nur-Text, Zeilenvorschub, Wagenrücklauf und spezielle ANSI-Befehle.  Es gibt keine Garantie für die Integrität der Teile - ein Befehl oder ein Wort kann in verschiedenen Paketen enthalten sein. </p><br><p>  ANSI-Befehle können das Format des Texts (Farbe, Hintergrund, Stil), die Position des Cursors (von wo aus der nachfolgende Text angezeigt werden soll) oder das Löschen eines Teils des Bildschirms beeinflussen. <br>  Ein Beispiel dafür, wie es aussieht: <br><img src="https://habrastorage.org/webt/5u/3c/tt/5u3cttwmep44kv8c9gysh5bn9ig.png"></p><br><p>  Darüber hinaus enthält der Text möglicherweise URLs, die ebenfalls erkannt und hervorgehoben werden müssen. </p><br><h2 id="beryom-gotovuyu-biblioteku-i-">  Wir nehmen die fertige Bibliothek und ... </h2><br><p>  Ich habe verstanden, dass die korrekte und schnelle Verarbeitung aller Befehle keine leichte Aufgabe ist.  Deshalb habe ich mich entschlossen, nach einer fertigen Bibliothek zu suchen.  Und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">siehe da</a> , ich bin sofort auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">xterm.js gestoßen</a> .  Eine fertige Komponente des Terminals, die bereits vielerorts eingesetzt wird und darüber hinaus <em>"sehr schnell ist, sogar einen GPU-beschleunigten Renderer enthält"</em> .  Letzteres war für mich das Wichtigste, weil  Ich wollte endlich einen sehr schnellen Kunden bekommen. </p><br><p>  Trotz der Tatsache, dass ich gerne meine eigenen Motorräder schreibe, war ich sehr froh, dass ich nicht nur Zeit sparen, sondern auch eine Reihe nützlicher Funktionen kostenlos erhalten kann. </p><br><p>  Ich brauchte 14 Uhr, um das Terminal anzuschließen, und <strong>konnte es nicht</strong> bewältigen.  Absolut. <br>  Unterschiedliche Zeilenhöhen, krumme Auswahl, adaptive Größe des Terminals, eine sehr seltsame API, mangelnde Dokumentation ... </p><br><p>  Aber ich hatte immer noch ein wenig Inspiration und glaubte, dass ich mit diesen Problemen umgehen könnte. <br>  Bis ich meinen Test 10k Leitungen zum Terminal fütterte ... Er starb.  Und begrub mit mir die Überreste meiner Hoffnungen. </p><br><h2 id="opisanie-itogovogo-algoritma">  Beschreibung des endgültigen Algorithmus </h2><br><p>  Zunächst habe ich den in Python implementierten aktuellen Algorithmus kopiert und für Javascript angepasst (nur geschweifte Klammern und einen anderen für die Syntax entfernen). </p><br><p>  Ich kannte alle wichtigen Vor- und Nachteile des alten Algorithmus, daher musste ich nur die ineffektiven Stellen darin verbessern. </p><br><p>  Nach Überlegungen, Versuchen und Irrtümern habe ich mich für die folgende Option entschieden: Wir teilen den Algorithmus in zwei Komponenten auf: </p><br><ul><li>  Modell zum Parsen von Text und Speichern des aktuellen Status des "Terminals" </li><li>  Mapping, das das Modell in HTML übersetzt </li></ul><br><h4 id="model-struktura-i-algoritm">  Modell (Struktur und Algorithmus) </h4><br><ul><li>  Alle Zeilen werden in einem Array gespeichert (Zeilennummer = Index im Array) </li><li>  Textstile werden in einem separaten Array gespeichert. </li><li>  Die aktuelle Cursorposition wird gespeichert und kann durch Befehle geändert werden </li><li>  Der Algorithmus selbst prüft die Eingabedaten zeichenweise: <br><ul><li>  Wenn dies nur Text ist, fügen Sie ihn der aktuellen Zeile hinzu </li><li>  Wenn ein Zeilenumbruch vorliegt, erhöhen Sie den aktuellen Zeilenindex </li><li>  Wenn dies eines der Befehlszeichen ist, legen wir es in den Befehlspuffer und warten auf das nächste Zeichen </li><li>  Wenn der Befehlspuffer korrekt ist, führen Sie diesen Befehl aus, andernfalls schreiben wir diesen Puffer als Text </li></ul></li><li>  Das Modell benachrichtigt die Hörer darüber, welche Zeilen sich nach der Verarbeitung eingehender Texte geändert haben </li></ul><br><p>  In meiner Implementierung ist die Komplexität des Algorithmus O ( <em>n</em> log <em>n</em> ), wobei log <em>n</em> die Vorbereitung geänderter Zeilen für die Benachrichtigung ist (Eindeutigkeit und Sortierung).  Zum Zeitpunkt dieses Schreibens wurde mir klar, dass Sie in einem speziellen Fall log <em>n</em> entfernen können, da die Zeilen am häufigsten am Ende hinzugefügt werden. </p><br><h4 id="otobrazhenie">  Anzeige </h4><br><ul><li>  Zeigt Text als HTML-Elemente an </li><li>  Wenn sich die Zeichenfolge geändert hat, werden alle Elemente der Zeichenfolge vollständig ersetzt </li><li>  Unterbricht jede Linie basierend auf Stilen: Jedes stilisierte Segment hat ein eigenes Element </li></ul><br><p>  Mit einer solchen Struktur ist das Testen eine ziemlich einfache Aufgabe - wir übertragen den Text in das Modell (in einem einzelnen Paket oder in Teilen) und überprüfen einfach den aktuellen Status aller darin enthaltenen Linien und Stile.  Und um nur ein paar Tests anzuzeigen, weil  Die geänderten Zeilen werden immer neu gezeichnet. </p><br><p>  Ein wichtiger Vorteil ist auch eine gewisse Faulheit des Displays.  Wenn wir in einem Text dieselbe Zeile überschreiben (z. B. Fortschrittsbalken), sieht es nach der Arbeit des Modells für die Anzeige wie eine geänderte Zeile aus. </p><br><h4 id="dom-vs-canvas">  DOM gegen Leinwand </h4><br><p>  Ich möchte ein wenig darüber nachdenken, warum ich mich für das DOM entschieden habe, obwohl das Ziel die Leistung war.  Die Antwort ist einfach - Faulheit.  Für mich scheint es eine ziemlich entmutigende Aufgabe zu sein, alles in Canvas selbst zu rendern.  Unter Beibehaltung der Benutzerfreundlichkeit: Hervorheben, Kopieren, Ändern der Bildschirmgröße, Ordentliches Aussehen usw.  Das Beispiel xterm.js hat mir deutlich gezeigt, dass dies überhaupt nicht einfach ist.  Ihre Darstellung auf Leinwand war alles andere als ideal. </p><br><p>  Darüber hinaus ist das Debuggen des DOM-Baums im Browser und die Möglichkeit, Unit-Tests abzudecken, ein wichtiger Vorteil. </p><br><p>  Am Ende war mein Ziel 50.000 Zeilen, und ich wusste, dass das DOM damit umgehen musste, basierend auf der Arbeit des alten Algorithmus. </p><br><h2 id="optimizacii">  Optimierungen </h2><br><p>  Der Algorithmus war bereit, debuggt und funktionierte langsam aber sicher.  Es war Zeit, den Profiler zu öffnen und zu optimieren.  Mit Blick auf die Zukunft werde ich sagen, dass die meisten Optimierungen für mich eine Überraschung waren (wie es normalerweise der Fall ist). </p><br><p>  Die Profilerstellung wurde auf 10.000 Linien durchgeführt, von denen jede stilisierte Elemente enthielt.  Die Gesamtzahl der DOM-Elemente beträgt ca. 100.000. </p><br><p>  Es wurden keine speziellen Ansätze und Werkzeuge verwendet.  Nur Chrome Dev Tools und ein paar Starts für jede Messung.  In der Praxis unterschieden sich bei den Starts nur die absoluten Werte der Messungen (wie viele Sekunden bis zum Abschluss), nicht jedoch das prozentuale Verhältnis zwischen den Methoden.  Daher halte ich diese Technik für bedingt ausreichend. </p><br><p>  Im Folgenden möchte ich näher auf die interessantesten Verbesserungen eingehen.  Und für den Anfang eine Grafik von dem, was war: <br><img src="https://habrastorage.org/webt/me/xk/ot/mexkotdhezc4pwxhw4xczkzv9ie.png"></p><br><p>  <em>Alle Profilgrafiken wurden nach der Implementierung erstellt, indem der Code aus dem Speicher deoptimiert wurde.</em> </p><br><h4 id="stringtrim">  string.trim </h4><br><p>  Zunächst stieß ich auf eine unverständliche string.trim, die sehr viel CPU verbrauchte (es scheint mir, dass dies etwa 10-20% waren). <br><img src="https://habrastorage.org/webt/ue/nq/6b/uenq6brmlm8fxzxxjklulp7ccly.png"></p><br><p>  trim () ist die Grundfunktion der Sprache.  Warum benutzt es eine Art Bibliothek?  Und selbst wenn es sich um eine Art Polyfill handelt, warum wurde dann die neueste Version von Chrome aktiviert? </p><br><p> Ein wenig googeln und die Antwort ist gefunden: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://babeljs.io/docs/en/babel-preset-env</a> .  Standardmäßig wird Polyfill für eine relativ große Anzahl von Browsern aktiviert, und zwar in der Kompilierungsphase.  Die Lösung für mich bestand darin, <code>'targets': '&gt; 0.25%, not dead'</code> anzugeben <code>'targets': '&gt; 0.25%, not dead'</code> <br>  Aber am Ende habe ich den Trimmaufruf als unnötig gelöscht. </p><br><h4 id="vuejs">  Vue.js </h4><br><p>  Letztes Jahr habe ich die Terminalkomponente auf Vue.js übertragen.  Jetzt musste ich es wieder auf Vanille übertragen, der Grund ist im folgenden Screenshot (siehe die Anzahl der Zeilen mit Vue.js): </p><br><p><img src="https://habrastorage.org/webt/ll/oq/i8/lloqi8k2igkme2q616eooswyogg.png"></p><br><p>  Ich habe nur Wrapper, Stile und Mausverarbeitung in der Vue-Komponente belassen.  Alles, was mit dem Erstellen von DOM-Elementen zu tun hat, ging in reines JS über, das als normales Feld (das nicht vom Framework überwacht wird) mit der Vue-Komponente verbunden ist. </p><br><pre> <code class="plaintext hljs">created() { this.terminalModel = new TerminalModel(); this.terminal = new Terminal(this.terminalModel); },</code> </pre> <br><p>  Ich halte dies nicht für ein Minus oder einen Fehler in Vue.js.  Es ist nur so, dass Frameworks und Leistung selbst nicht gut zusammenpassen.  Wenn Sie Zehntausende von Objekten in ein reaktives Framework ablegen, ist es sehr schwierig, innerhalb weniger Millisekunden eine Verarbeitung zu erwarten.  Und um ehrlich zu sein, bin ich sogar überrascht, dass Vue.js ziemlich gut abgeschnitten hat. </p><br><h4 id="dobavlenie-novyh-elementov">  Neue Elemente hinzufügen </h4><br><p>  Hier ist alles einfach - wenn Sie mehrere tausend neue Elemente haben und diese der übergeordneten Komponente hinzufügen möchten, ist es keine gute Idee, appendChild auszuführen.  Der Browser muss die Verarbeitung etwas häufiger durchführen und mehr Zeit für das Rendern aufwenden.  Eine der Nebenwirkungen in meinem Fall war eine Verlangsamung des Autoscrolls  Es erzwingt eine Nachzählung aller hinzugefügten Komponenten. </p><br><p><img src="https://habrastorage.org/webt/v_/5k/uj/v_5kujs_plen-j5zoxhq0ixv9um.png"></p><br><p>  Um das Problem zu lösen, gibt es ein DocumentFragment.  Zuerst fügen wir alle Elemente hinzu und dann fügen wir es der übergeordneten Komponente hinzu.  Der Browser kümmert sich um die Inline der eingehenden Komponenten. </p><br><p>  Dieser Ansatz reduziert die Zeit, die der Browser für das Rendern und Anordnen von Elementen benötigt. <br>  Ich habe auch andere Möglichkeiten ausprobiert, um das Hinzufügen von Elementen zu beschleunigen.  Keiner von ihnen konnte etwas über das DocumentFragment hinzufügen. </p><br><h4 id="span-vs-div">  span vs div </h4><br><p>  Tatsächlich könnte dies als <code>display:inline</code> (span) vs <code>display:block</code> (div) bezeichnet werden. </p><br><p>  Anfangs hatte ich jede Zeile in der Spanne und endete mit einem Zeilenumbruch.  In Bezug auf die Leistung ist dies jedoch nicht sehr effektiv: Der Browser muss herausfinden, wo das Element beginnt und endet.  Mit display: block sind solche Berechnungen viel einfacher. </p><br><p>  Das Ersetzen durch ein Div beschleunigte das Rendern um fast das Zweifache. </p><br><p>  Leider sieht es im Fall von <code>display:block</code> schlechter aus <code>display:block</code> mehrere Textzeilen hervorzuheben: </p><br><p><img src="https://habrastorage.org/webt/dm/kj/nq/dmkjnq9up61pc-ic0jalnfi3jw8.png"></p><br><p>  Lange Zeit konnte ich mich nicht entscheiden, was besser ist - zusätzliche 2 Sekunden Rendering oder menschliche Auswahl.  Infolgedessen besiegte die Praktikabilität die Schönheit. </p><br><h4 id="master-css-10-go-urovnya">  CSS-Assistent der Stufe 10 </h4><br><p>  Weitere ~ 10% der Renderzeit wurden durch CSS- "Optimierung" abgeschnitten, mit der ich Text formatiere. </p><br><p>  Unerfahrenheit in der Webentwicklung und Verständnis der Grundlagen spielten gegen mich.  Ich dachte, je genauer die Selektoren sind, desto besser, aber speziell in meinem Fall war dies nicht der Fall. </p><br><p>  Um den Text im Terminal zu formatieren, habe ich die folgenden Selektoren verwendet: </p><br><pre> <code class="plaintext hljs">#script-panel-container .log-content &gt; div &gt; span.text_color_green,</code> </pre> <br><p>  Aber (in Chrom) ist die folgende Option etwas schneller: </p><br><pre> <code class="plaintext hljs">span.text_color_green</code> </pre> <br><p>  Ich mag diesen Selektor nicht wirklich, weil  zu global, aber die Leistung ist teurer. </p><br><h4 id="stringsplit">  string.split </h4><br><p>  Wenn Sie aufgrund eines der vorherigen Punkte ein Deja Vu haben, ist es falsch.  Diesmal geht es nicht um Polyfill, sondern um die Standardimplementierung in Chrome: </p><br><p><img src="https://habrastorage.org/webt/i8/jk/lh/i8jklht2lc0hhc9h6p1la3zuk6o.png"></p><br><p>  <em>(Ich habe string.split in defSplit eingeschlossen, damit die Funktion im Profiler angezeigt wird.)</em> </p><br><p>  1% sind Kleinigkeiten.  Aber der idealistische Radfahrer in mir wurde verfolgt.  In meinem Fall erfolgt die Aufteilung immer zeichenweise und ohne Stammgäste.  Daher habe ich eine einfache Option implementiert.  Hier ist das Ergebnis: </p><br><p><img src="https://habrastorage.org/webt/hu/fd/_r/hufd_rbij0khcfqcudcnpfkjisa.png"></p><br><div class="spoiler">  <b class="spoiler_title">fastSplit</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">function fastSplit(str, separatorChar) { if (str === '') { return ['']; } let result = []; let lastIndex = 0; for (let i = 0; i &lt; str.length; i++) { const char = str[i]; if (char === separatorChar) { const chunk = str.substr(lastIndex, i - lastIndex); lastIndex = i + 1; result.push(chunk); } } if (lastIndex &lt; str.length) { const lastChunk = str.substr(lastIndex, str.length - lastIndex); result.push(lastChunk); } return result; }</code> </pre> </div></div><br><p>  Ich glaube, dass sie mich danach ohne Interview zum Google Chrome-Team bringen müssen. </p><br><h4 id="optimizaciya-posleslovie">  Optimierung, Nachwort </h4><br><p>  Optimierung ist ein Prozess ohne Ende und etwas kann auf unbestimmte Zeit verbessert werden.  Insbesondere wenn man bedenkt, dass unterschiedliche Anwendungsfälle unterschiedliche (und widersprüchliche) Optimierungen erfordern. </p><br><p>  Für meinen Fall habe ich den Hauptanwendungsfall ausgewählt und die Betriebszeit von 15 Sekunden auf 5 Sekunden optimiert.  Daraufhin habe ich beschlossen aufzuhören. <br><img src="https://habrastorage.org/webt/ol/ri/j3/olrij3u8nfgpdrbm5-0db4vkpra.png"></p><br><p>  Es gibt noch einige Orte, die ich verbessern möchte, aber dies ist den gesammelten Erfahrungen zu verdanken. </p><br><h2 id="bonus-mutacionnoe-testirovanie">  Bonus  Mutationstests. </h2><br><p>  So kam es, dass ich in den letzten Monaten oft auf den Begriff "Mutationstests" stieß.  Und ich entschied, dass diese Aufgabe eine großartige Möglichkeit ist, dieses Biest auszuprobieren.  Besonders nachdem ich in Webstorm keine Codeabdeckung für Karma-Tests erhalten hatte. </p><br><p>  Da sowohl die Technik als auch die Bibliothek für mich neu sind, habe ich mich entschlossen, mit ein wenig Blut auszukommen: nur eine Komponente zu testen - das Modell.  In diesem Fall können Sie klar angeben, welche Datei wir testen und welche Testsuite dafür vorgesehen ist. </p><br><p>  Aber was auch immer man sagen mag, ich musste viel basteln, um eine Integration mit Karma und Webpack zu erreichen. </p><br><p>  Am Ende fing alles an und nach einer halben Stunde sah ich traurige Ergebnisse: Etwa die Hälfte der Mutanten überlebte.  Ich habe einen Teil sofort getötet, einen Teil für die Zukunft übrig (als ich die fehlenden ANSI-Befehle implementiert habe). </p><br><p>  Danach gewann die Faulheit und im Moment sind die Ergebnisse wie folgt (für 128 Tests): </p><br><pre> <code class="plaintext hljs">Ran 79.04 tests per mutant on average. ------------------|---------|----------|-----------|------------|---------| File | % score | # killed | # timeout | # survived | # error | ------------------|---------|----------|-----------|------------|---------| terminal_model.js | 73.10 | 312 | 25 | 124 | 1 | ------------------|---------|----------|-----------|------------|---------| 23:01:08 (18212) INFO Stryker Done in 26 minutes 32 seconds.</code> </pre> <br><p>  Im Allgemeinen erschien mir dieser Ansatz sehr nützlich (offensichtlich besser als die Codeabdeckung) und lustig.  Das einzig Negative ist eine furchtbar lange Zeit - 30 Minuten pro Klasse sind zu viel. </p><br><p>  Und vor allem hat mich dieser Ansatz dazu gebracht, noch einmal über eine 100% ige Abdeckung nachzudenken und darüber, ob es sich lohnt, alles mit Tests abzudecken: Jetzt ist meine Meinung bei der Beantwortung dieser Frage noch näher an „Ja“. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Leistungsoptimierung ist meiner Meinung nach ein guter Weg, um etwas Tieferes zu lernen.  Es ist auch ein gutes Training für das Gehirn.  Und es ist sehr bedauerlich, dass dies selten wirklich benötigt wird (zumindest in meinen Projekten). </p><br><p>  Und wie immer funktioniert der Ansatz „Erst Profilerstellung, dann Optimierung“ viel besser als Intuition. </p><br><h4 id="ssylki">  Referenzen </h4><br><p>  Alte Implementierung: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">terminal_formatter.py</a> </li><li>  <a href="">log_panel.vue</a> </li></ul><br><p>  Neue Implementierung: </p><br><ul><li>  <a href="">terminal_model.js</a> </li><li>  <a href="">terminal_view.js</a> </li></ul><br><p>  Leider gibt es keine Webkomponenten-Demo, sodass Sie sie einfach nicht anstoßen können.  Also entschuldige ich mich im Voraus </p><br><p>  Vielen Dank für Ihre Zeit, ich freue mich über Kommentare, Vorschläge und vernünftige Kritik! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448030/">https://habr.com/ru/post/de448030/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448016/index.html">Klinische Analyse des Urins zu Hause auf Teststreifen: Vor- und Nachteile</a></li>
<li><a href="../de448018/index.html">Digitale Veranstaltungen in Moskau vom 15. bis 21. April</a></li>
<li><a href="../de448022/index.html">200-Zeilen-Angular-Compiler</a></li>
<li><a href="../de448024/index.html">Europäische Regulierungsbehörden lehnen Cookie-Banner ab</a></li>
<li><a href="../de448026/index.html">Softwareprojekt und OOP Evolution</a></li>
<li><a href="../de448032/index.html">Mehr Roboter: Walmart stellt Tausende von Maschinen für den Betrieb in seinen Filialen vor</a></li>
<li><a href="../de448034/index.html">Suchen Sie nach Aufgaben in JIRA (einfache Sprache). Teil 1: Schnelle und einfache Suche</a></li>
<li><a href="../de448036/index.html">Import nach J. Verbindung aus der Benutzerlistendatei über die API</a></li>
<li><a href="../de448038/index.html">Neue Funktionen für Erweiterungsautoren in Visual Studio 2019 v.16.1</a></li>
<li><a href="../de448040/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 294 (vom 8. bis 14. April)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>