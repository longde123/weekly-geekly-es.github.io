<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç≠ üí™üèø üëãüèª Anzeige und Optimierung der Terminalausgabe im Web üë®üèΩ‚Äç‚öñÔ∏è üë®üèΩ‚Äçüé® üê∫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor nicht allzu langer Zeit stie√ü ich auf eine recht einfache und gleichzeitig interessante Aufgabe: die Implementierung eines schreibgesch√ºtzten Term...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Anzeige und Optimierung der Terminalausgabe im Web</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448030/"><p>  Vor nicht allzu langer Zeit stie√ü ich auf eine recht einfache und gleichzeitig interessante Aufgabe: die Implementierung eines schreibgesch√ºtzten Terminals in einer Webanwendung.  Das Interesse an der Aufgabe wurde durch drei wichtige Aspekte geweckt: </p><br><ul><li>  Unterst√ºtzung f√ºr grundlegende <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ANSI-Escape-Sequenzen</a> </li><li>  Unterst√ºtzung f√ºr mindestens 50.000 Datenleitungen </li><li>  Daten anzeigen, sobald sie verf√ºgbar sind. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ku/fa/rk/kufarkakkmxskpfqqokeixh_ste.png"></div><br><p>  In diesem Artikel werde ich dar√ºber sprechen, wie es implementiert und wie es dann alles optimiert hat. </p><a name="habracut"></a><br><p>  <em>Haftungsausschluss: Ich bin kein erfahrener Webentwickler, daher scheinen Ihnen einige Dinge offensichtlich zu sein, und die Schlussfolgerungen oder Entscheidungen sind falsch.</em>  <em>F√ºr Korrekturen und Klarstellungen bin ich dankbar.</em> </p><br><h2 id="dlya-chego-eto-zatevalos">  Warum war es an </h2><br><p>  Die ganze Aufgabe ist wie folgt: Ein Skript wird auf dem Server ausgef√ºhrt (Bash, Python usw.) und schreibt etwas in stdout.  Und diese Schlussfolgerung muss auf der Webseite angezeigt werden, sobald sie eintrifft.  Gleichzeitig sollte es wie auf dem Terminal aussehen (mit Formatierung, Cursor√ºbertragung usw.). <br>  Ich kontrolliere das Skript selbst und seine Ausgabe in keiner Weise und zeige es in reiner Form an. </p><br><p>  Nat√ºrlich sollte sich zwischen der Weboberfl√§che und dem Skript ein Vermittler befinden - ein Webserver.  Und wenn nicht zu zerstreuen - ich habe bereits eine Webanwendung und einen Server und arbeite irgendwie.  Das Schema sieht ungef√§hr so ‚Äã‚Äãaus: <br><img src="https://habrastorage.org/webt/ww/kb/ei/wwkbei13_tv9n6w6vcw_6c4e5dm.png"></p><br><p>  Zuvor war der Server f√ºr die Verarbeitung und Formatierung verantwortlich.  Und ich wollte es aus einer Vielzahl von Gr√ºnden verbessern: </p><br><ul><li>  Doppelte Datenverarbeitung - zuerst auf dem Server analysieren, dann auf dem Client in HTML-Komponenten umwandeln </li><li>  Nicht optimaler Algorithmus aufgrund der Datenaufbereitung f√ºr den Client </li><li>  Hohe Belastung des Servers - Die Verarbeitung der Ausgabe eines einzelnen Skripts kann einen einzelnen Thread vollst√§ndig auf den Server laden </li><li>  unvollst√§ndige Unterst√ºtzung f√ºr ANSI Escape-Sequenzen </li><li>  subtile Fehler </li><li>  Der Client hat sehr schlecht mit der Anzeige von sogar 10.000 formatierten Zeilen abgeschnitten </li></ul><br><p>  Daher wurde beschlossen, die gesamte Parsing-Logik auf die Webanwendung zu √ºbertragen und nur Streaming-Rohdaten auf den Server zu √ºbertragen </p><br><h2 id="postanovka-zadachi">  Erkl√§rung des Problems </h2><br><p>  Teile des Textes kommen zum Kunden.  Der Client muss sie in Komponenten zerlegen: Nur-Text, Zeilenvorschub, Wagenr√ºcklauf und spezielle ANSI-Befehle.  Es gibt keine Garantie f√ºr die Integrit√§t der Teile - ein Befehl oder ein Wort kann in verschiedenen Paketen enthalten sein. </p><br><p>  ANSI-Befehle k√∂nnen das Format des Texts (Farbe, Hintergrund, Stil), die Position des Cursors (von wo aus der nachfolgende Text angezeigt werden soll) oder das L√∂schen eines Teils des Bildschirms beeinflussen. <br>  Ein Beispiel daf√ºr, wie es aussieht: <br><img src="https://habrastorage.org/webt/5u/3c/tt/5u3cttwmep44kv8c9gysh5bn9ig.png"></p><br><p>  Dar√ºber hinaus enth√§lt der Text m√∂glicherweise URLs, die ebenfalls erkannt und hervorgehoben werden m√ºssen. </p><br><h2 id="beryom-gotovuyu-biblioteku-i-">  Wir nehmen die fertige Bibliothek und ... </h2><br><p>  Ich habe verstanden, dass die korrekte und schnelle Verarbeitung aller Befehle keine leichte Aufgabe ist.  Deshalb habe ich mich entschlossen, nach einer fertigen Bibliothek zu suchen.  Und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">siehe da</a> , ich bin sofort auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">xterm.js gesto√üen</a> .  Eine fertige Komponente des Terminals, die bereits vielerorts eingesetzt wird und dar√ºber hinaus <em>"sehr schnell ist, sogar einen GPU-beschleunigten Renderer enth√§lt"</em> .  Letzteres war f√ºr mich das Wichtigste, weil  Ich wollte endlich einen sehr schnellen Kunden bekommen. </p><br><p>  Trotz der Tatsache, dass ich gerne meine eigenen Motorr√§der schreibe, war ich sehr froh, dass ich nicht nur Zeit sparen, sondern auch eine Reihe n√ºtzlicher Funktionen kostenlos erhalten kann. </p><br><p>  Ich brauchte 14 Uhr, um das Terminal anzuschlie√üen, und <strong>konnte es nicht</strong> bew√§ltigen.  Absolut. <br>  Unterschiedliche Zeilenh√∂hen, krumme Auswahl, adaptive Gr√∂√üe des Terminals, eine sehr seltsame API, mangelnde Dokumentation ... </p><br><p>  Aber ich hatte immer noch ein wenig Inspiration und glaubte, dass ich mit diesen Problemen umgehen k√∂nnte. <br>  Bis ich meinen Test 10k Leitungen zum Terminal f√ºtterte ... Er starb.  Und begrub mit mir die √úberreste meiner Hoffnungen. </p><br><h2 id="opisanie-itogovogo-algoritma">  Beschreibung des endg√ºltigen Algorithmus </h2><br><p>  Zun√§chst habe ich den in Python implementierten aktuellen Algorithmus kopiert und f√ºr Javascript angepasst (nur geschweifte Klammern und einen anderen f√ºr die Syntax entfernen). </p><br><p>  Ich kannte alle wichtigen Vor- und Nachteile des alten Algorithmus, daher musste ich nur die ineffektiven Stellen darin verbessern. </p><br><p>  Nach √úberlegungen, Versuchen und Irrt√ºmern habe ich mich f√ºr die folgende Option entschieden: Wir teilen den Algorithmus in zwei Komponenten auf: </p><br><ul><li>  Modell zum Parsen von Text und Speichern des aktuellen Status des "Terminals" </li><li>  Mapping, das das Modell in HTML √ºbersetzt </li></ul><br><h4 id="model-struktura-i-algoritm">  Modell (Struktur und Algorithmus) </h4><br><ul><li>  Alle Zeilen werden in einem Array gespeichert (Zeilennummer = Index im Array) </li><li>  Textstile werden in einem separaten Array gespeichert. </li><li>  Die aktuelle Cursorposition wird gespeichert und kann durch Befehle ge√§ndert werden </li><li>  Der Algorithmus selbst pr√ºft die Eingabedaten zeichenweise: <br><ul><li>  Wenn dies nur Text ist, f√ºgen Sie ihn der aktuellen Zeile hinzu </li><li>  Wenn ein Zeilenumbruch vorliegt, erh√∂hen Sie den aktuellen Zeilenindex </li><li>  Wenn dies eines der Befehlszeichen ist, legen wir es in den Befehlspuffer und warten auf das n√§chste Zeichen </li><li>  Wenn der Befehlspuffer korrekt ist, f√ºhren Sie diesen Befehl aus, andernfalls schreiben wir diesen Puffer als Text </li></ul></li><li>  Das Modell benachrichtigt die H√∂rer dar√ºber, welche Zeilen sich nach der Verarbeitung eingehender Texte ge√§ndert haben </li></ul><br><p>  In meiner Implementierung ist die Komplexit√§t des Algorithmus O ( <em>n</em> log <em>n</em> ), wobei log <em>n</em> die Vorbereitung ge√§nderter Zeilen f√ºr die Benachrichtigung ist (Eindeutigkeit und Sortierung).  Zum Zeitpunkt dieses Schreibens wurde mir klar, dass Sie in einem speziellen Fall log <em>n</em> entfernen k√∂nnen, da die Zeilen am h√§ufigsten am Ende hinzugef√ºgt werden. </p><br><h4 id="otobrazhenie">  Anzeige </h4><br><ul><li>  Zeigt Text als HTML-Elemente an </li><li>  Wenn sich die Zeichenfolge ge√§ndert hat, werden alle Elemente der Zeichenfolge vollst√§ndig ersetzt </li><li>  Unterbricht jede Linie basierend auf Stilen: Jedes stilisierte Segment hat ein eigenes Element </li></ul><br><p>  Mit einer solchen Struktur ist das Testen eine ziemlich einfache Aufgabe - wir √ºbertragen den Text in das Modell (in einem einzelnen Paket oder in Teilen) und √ºberpr√ºfen einfach den aktuellen Status aller darin enthaltenen Linien und Stile.  Und um nur ein paar Tests anzuzeigen, weil  Die ge√§nderten Zeilen werden immer neu gezeichnet. </p><br><p>  Ein wichtiger Vorteil ist auch eine gewisse Faulheit des Displays.  Wenn wir in einem Text dieselbe Zeile √ºberschreiben (z. B. Fortschrittsbalken), sieht es nach der Arbeit des Modells f√ºr die Anzeige wie eine ge√§nderte Zeile aus. </p><br><h4 id="dom-vs-canvas">  DOM gegen Leinwand </h4><br><p>  Ich m√∂chte ein wenig dar√ºber nachdenken, warum ich mich f√ºr das DOM entschieden habe, obwohl das Ziel die Leistung war.  Die Antwort ist einfach - Faulheit.  F√ºr mich scheint es eine ziemlich entmutigende Aufgabe zu sein, alles in Canvas selbst zu rendern.  Unter Beibehaltung der Benutzerfreundlichkeit: Hervorheben, Kopieren, √Ñndern der Bildschirmgr√∂√üe, Ordentliches Aussehen usw.  Das Beispiel xterm.js hat mir deutlich gezeigt, dass dies √ºberhaupt nicht einfach ist.  Ihre Darstellung auf Leinwand war alles andere als ideal. </p><br><p>  Dar√ºber hinaus ist das Debuggen des DOM-Baums im Browser und die M√∂glichkeit, Unit-Tests abzudecken, ein wichtiger Vorteil. </p><br><p>  Am Ende war mein Ziel 50.000 Zeilen, und ich wusste, dass das DOM damit umgehen musste, basierend auf der Arbeit des alten Algorithmus. </p><br><h2 id="optimizacii">  Optimierungen </h2><br><p>  Der Algorithmus war bereit, debuggt und funktionierte langsam aber sicher.  Es war Zeit, den Profiler zu √∂ffnen und zu optimieren.  Mit Blick auf die Zukunft werde ich sagen, dass die meisten Optimierungen f√ºr mich eine √úberraschung waren (wie es normalerweise der Fall ist). </p><br><p>  Die Profilerstellung wurde auf 10.000 Linien durchgef√ºhrt, von denen jede stilisierte Elemente enthielt.  Die Gesamtzahl der DOM-Elemente betr√§gt ca. 100.000. </p><br><p>  Es wurden keine speziellen Ans√§tze und Werkzeuge verwendet.  Nur Chrome Dev Tools und ein paar Starts f√ºr jede Messung.  In der Praxis unterschieden sich bei den Starts nur die absoluten Werte der Messungen (wie viele Sekunden bis zum Abschluss), nicht jedoch das prozentuale Verh√§ltnis zwischen den Methoden.  Daher halte ich diese Technik f√ºr bedingt ausreichend. </p><br><p>  Im Folgenden m√∂chte ich n√§her auf die interessantesten Verbesserungen eingehen.  Und f√ºr den Anfang eine Grafik von dem, was war: <br><img src="https://habrastorage.org/webt/me/xk/ot/mexkotdhezc4pwxhw4xczkzv9ie.png"></p><br><p>  <em>Alle Profilgrafiken wurden nach der Implementierung erstellt, indem der Code aus dem Speicher deoptimiert wurde.</em> </p><br><h4 id="stringtrim">  string.trim </h4><br><p>  Zun√§chst stie√ü ich auf eine unverst√§ndliche string.trim, die sehr viel CPU verbrauchte (es scheint mir, dass dies etwa 10-20% waren). <br><img src="https://habrastorage.org/webt/ue/nq/6b/uenq6brmlm8fxzxxjklulp7ccly.png"></p><br><p>  trim () ist die Grundfunktion der Sprache.  Warum benutzt es eine Art Bibliothek?  Und selbst wenn es sich um eine Art Polyfill handelt, warum wurde dann die neueste Version von Chrome aktiviert? </p><br><p> Ein wenig googeln und die Antwort ist gefunden: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://babeljs.io/docs/en/babel-preset-env</a> .  Standardm√§√üig wird Polyfill f√ºr eine relativ gro√üe Anzahl von Browsern aktiviert, und zwar in der Kompilierungsphase.  Die L√∂sung f√ºr mich bestand darin, <code>'targets': '&gt; 0.25%, not dead'</code> anzugeben <code>'targets': '&gt; 0.25%, not dead'</code> <br>  Aber am Ende habe ich den Trimmaufruf als unn√∂tig gel√∂scht. </p><br><h4 id="vuejs">  Vue.js </h4><br><p>  Letztes Jahr habe ich die Terminalkomponente auf Vue.js √ºbertragen.  Jetzt musste ich es wieder auf Vanille √ºbertragen, der Grund ist im folgenden Screenshot (siehe die Anzahl der Zeilen mit Vue.js): </p><br><p><img src="https://habrastorage.org/webt/ll/oq/i8/lloqi8k2igkme2q616eooswyogg.png"></p><br><p>  Ich habe nur Wrapper, Stile und Mausverarbeitung in der Vue-Komponente belassen.  Alles, was mit dem Erstellen von DOM-Elementen zu tun hat, ging in reines JS √ºber, das als normales Feld (das nicht vom Framework √ºberwacht wird) mit der Vue-Komponente verbunden ist. </p><br><pre> <code class="plaintext hljs">created() { this.terminalModel = new TerminalModel(); this.terminal = new Terminal(this.terminalModel); },</code> </pre> <br><p>  Ich halte dies nicht f√ºr ein Minus oder einen Fehler in Vue.js.  Es ist nur so, dass Frameworks und Leistung selbst nicht gut zusammenpassen.  Wenn Sie Zehntausende von Objekten in ein reaktives Framework ablegen, ist es sehr schwierig, innerhalb weniger Millisekunden eine Verarbeitung zu erwarten.  Und um ehrlich zu sein, bin ich sogar √ºberrascht, dass Vue.js ziemlich gut abgeschnitten hat. </p><br><h4 id="dobavlenie-novyh-elementov">  Neue Elemente hinzuf√ºgen </h4><br><p>  Hier ist alles einfach - wenn Sie mehrere tausend neue Elemente haben und diese der √ºbergeordneten Komponente hinzuf√ºgen m√∂chten, ist es keine gute Idee, appendChild auszuf√ºhren.  Der Browser muss die Verarbeitung etwas h√§ufiger durchf√ºhren und mehr Zeit f√ºr das Rendern aufwenden.  Eine der Nebenwirkungen in meinem Fall war eine Verlangsamung des Autoscrolls  Es erzwingt eine Nachz√§hlung aller hinzugef√ºgten Komponenten. </p><br><p><img src="https://habrastorage.org/webt/v_/5k/uj/v_5kujs_plen-j5zoxhq0ixv9um.png"></p><br><p>  Um das Problem zu l√∂sen, gibt es ein DocumentFragment.  Zuerst f√ºgen wir alle Elemente hinzu und dann f√ºgen wir es der √ºbergeordneten Komponente hinzu.  Der Browser k√ºmmert sich um die Inline der eingehenden Komponenten. </p><br><p>  Dieser Ansatz reduziert die Zeit, die der Browser f√ºr das Rendern und Anordnen von Elementen ben√∂tigt. <br>  Ich habe auch andere M√∂glichkeiten ausprobiert, um das Hinzuf√ºgen von Elementen zu beschleunigen.  Keiner von ihnen konnte etwas √ºber das DocumentFragment hinzuf√ºgen. </p><br><h4 id="span-vs-div">  span vs div </h4><br><p>  Tats√§chlich k√∂nnte dies als <code>display:inline</code> (span) vs <code>display:block</code> (div) bezeichnet werden. </p><br><p>  Anfangs hatte ich jede Zeile in der Spanne und endete mit einem Zeilenumbruch.  In Bezug auf die Leistung ist dies jedoch nicht sehr effektiv: Der Browser muss herausfinden, wo das Element beginnt und endet.  Mit display: block sind solche Berechnungen viel einfacher. </p><br><p>  Das Ersetzen durch ein Div beschleunigte das Rendern um fast das Zweifache. </p><br><p>  Leider sieht es im Fall von <code>display:block</code> schlechter aus <code>display:block</code> mehrere Textzeilen hervorzuheben: </p><br><p><img src="https://habrastorage.org/webt/dm/kj/nq/dmkjnq9up61pc-ic0jalnfi3jw8.png"></p><br><p>  Lange Zeit konnte ich mich nicht entscheiden, was besser ist - zus√§tzliche 2 Sekunden Rendering oder menschliche Auswahl.  Infolgedessen besiegte die Praktikabilit√§t die Sch√∂nheit. </p><br><h4 id="master-css-10-go-urovnya">  CSS-Assistent der Stufe 10 </h4><br><p>  Weitere ~ 10% der Renderzeit wurden durch CSS- "Optimierung" abgeschnitten, mit der ich Text formatiere. </p><br><p>  Unerfahrenheit in der Webentwicklung und Verst√§ndnis der Grundlagen spielten gegen mich.  Ich dachte, je genauer die Selektoren sind, desto besser, aber speziell in meinem Fall war dies nicht der Fall. </p><br><p>  Um den Text im Terminal zu formatieren, habe ich die folgenden Selektoren verwendet: </p><br><pre> <code class="plaintext hljs">#script-panel-container .log-content &gt; div &gt; span.text_color_green,</code> </pre> <br><p>  Aber (in Chrom) ist die folgende Option etwas schneller: </p><br><pre> <code class="plaintext hljs">span.text_color_green</code> </pre> <br><p>  Ich mag diesen Selektor nicht wirklich, weil  zu global, aber die Leistung ist teurer. </p><br><h4 id="stringsplit">  string.split </h4><br><p>  Wenn Sie aufgrund eines der vorherigen Punkte ein Deja Vu haben, ist es falsch.  Diesmal geht es nicht um Polyfill, sondern um die Standardimplementierung in Chrome: </p><br><p><img src="https://habrastorage.org/webt/i8/jk/lh/i8jklht2lc0hhc9h6p1la3zuk6o.png"></p><br><p>  <em>(Ich habe string.split in defSplit eingeschlossen, damit die Funktion im Profiler angezeigt wird.)</em> </p><br><p>  1% sind Kleinigkeiten.  Aber der idealistische Radfahrer in mir wurde verfolgt.  In meinem Fall erfolgt die Aufteilung immer zeichenweise und ohne Stammg√§ste.  Daher habe ich eine einfache Option implementiert.  Hier ist das Ergebnis: </p><br><p><img src="https://habrastorage.org/webt/hu/fd/_r/hufd_rbij0khcfqcudcnpfkjisa.png"></p><br><div class="spoiler">  <b class="spoiler_title">fastSplit</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">function fastSplit(str, separatorChar) { if (str === '') { return ['']; } let result = []; let lastIndex = 0; for (let i = 0; i &lt; str.length; i++) { const char = str[i]; if (char === separatorChar) { const chunk = str.substr(lastIndex, i - lastIndex); lastIndex = i + 1; result.push(chunk); } } if (lastIndex &lt; str.length) { const lastChunk = str.substr(lastIndex, str.length - lastIndex); result.push(lastChunk); } return result; }</code> </pre> </div></div><br><p>  Ich glaube, dass sie mich danach ohne Interview zum Google Chrome-Team bringen m√ºssen. </p><br><h4 id="optimizaciya-posleslovie">  Optimierung, Nachwort </h4><br><p>  Optimierung ist ein Prozess ohne Ende und etwas kann auf unbestimmte Zeit verbessert werden.  Insbesondere wenn man bedenkt, dass unterschiedliche Anwendungsf√§lle unterschiedliche (und widerspr√ºchliche) Optimierungen erfordern. </p><br><p>  F√ºr meinen Fall habe ich den Hauptanwendungsfall ausgew√§hlt und die Betriebszeit von 15 Sekunden auf 5 Sekunden optimiert.  Daraufhin habe ich beschlossen aufzuh√∂ren. <br><img src="https://habrastorage.org/webt/ol/ri/j3/olrij3u8nfgpdrbm5-0db4vkpra.png"></p><br><p>  Es gibt noch einige Orte, die ich verbessern m√∂chte, aber dies ist den gesammelten Erfahrungen zu verdanken. </p><br><h2 id="bonus-mutacionnoe-testirovanie">  Bonus  Mutationstests. </h2><br><p>  So kam es, dass ich in den letzten Monaten oft auf den Begriff "Mutationstests" stie√ü.  Und ich entschied, dass diese Aufgabe eine gro√üartige M√∂glichkeit ist, dieses Biest auszuprobieren.  Besonders nachdem ich in Webstorm keine Codeabdeckung f√ºr Karma-Tests erhalten hatte. </p><br><p>  Da sowohl die Technik als auch die Bibliothek f√ºr mich neu sind, habe ich mich entschlossen, mit ein wenig Blut auszukommen: nur eine Komponente zu testen - das Modell.  In diesem Fall k√∂nnen Sie klar angeben, welche Datei wir testen und welche Testsuite daf√ºr vorgesehen ist. </p><br><p>  Aber was auch immer man sagen mag, ich musste viel basteln, um eine Integration mit Karma und Webpack zu erreichen. </p><br><p>  Am Ende fing alles an und nach einer halben Stunde sah ich traurige Ergebnisse: Etwa die H√§lfte der Mutanten √ºberlebte.  Ich habe einen Teil sofort get√∂tet, einen Teil f√ºr die Zukunft √ºbrig (als ich die fehlenden ANSI-Befehle implementiert habe). </p><br><p>  Danach gewann die Faulheit und im Moment sind die Ergebnisse wie folgt (f√ºr 128 Tests): </p><br><pre> <code class="plaintext hljs">Ran 79.04 tests per mutant on average. ------------------|---------|----------|-----------|------------|---------| File | % score | # killed | # timeout | # survived | # error | ------------------|---------|----------|-----------|------------|---------| terminal_model.js | 73.10 | 312 | 25 | 124 | 1 | ------------------|---------|----------|-----------|------------|---------| 23:01:08 (18212) INFO Stryker Done in 26 minutes 32 seconds.</code> </pre> <br><p>  Im Allgemeinen erschien mir dieser Ansatz sehr n√ºtzlich (offensichtlich besser als die Codeabdeckung) und lustig.  Das einzig Negative ist eine furchtbar lange Zeit - 30 Minuten pro Klasse sind zu viel. </p><br><p>  Und vor allem hat mich dieser Ansatz dazu gebracht, noch einmal √ºber eine 100% ige Abdeckung nachzudenken und dar√ºber, ob es sich lohnt, alles mit Tests abzudecken: Jetzt ist meine Meinung bei der Beantwortung dieser Frage noch n√§her an ‚ÄûJa‚Äú. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Leistungsoptimierung ist meiner Meinung nach ein guter Weg, um etwas Tieferes zu lernen.  Es ist auch ein gutes Training f√ºr das Gehirn.  Und es ist sehr bedauerlich, dass dies selten wirklich ben√∂tigt wird (zumindest in meinen Projekten). </p><br><p>  Und wie immer funktioniert der Ansatz ‚ÄûErst Profilerstellung, dann Optimierung‚Äú viel besser als Intuition. </p><br><h4 id="ssylki">  Referenzen </h4><br><p>  Alte Implementierung: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">terminal_formatter.py</a> </li><li>  <a href="">log_panel.vue</a> </li></ul><br><p>  Neue Implementierung: </p><br><ul><li>  <a href="">terminal_model.js</a> </li><li>  <a href="">terminal_view.js</a> </li></ul><br><p>  Leider gibt es keine Webkomponenten-Demo, sodass Sie sie einfach nicht ansto√üen k√∂nnen.  Also entschuldige ich mich im Voraus </p><br><p>  Vielen Dank f√ºr Ihre Zeit, ich freue mich √ºber Kommentare, Vorschl√§ge und vern√ºnftige Kritik! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448030/">https://habr.com/ru/post/de448030/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448016/index.html">Klinische Analyse des Urins zu Hause auf Teststreifen: Vor- und Nachteile</a></li>
<li><a href="../de448018/index.html">Digitale Veranstaltungen in Moskau vom 15. bis 21. April</a></li>
<li><a href="../de448022/index.html">200-Zeilen-Angular-Compiler</a></li>
<li><a href="../de448024/index.html">Europ√§ische Regulierungsbeh√∂rden lehnen Cookie-Banner ab</a></li>
<li><a href="../de448026/index.html">Softwareprojekt und OOP Evolution</a></li>
<li><a href="../de448032/index.html">Mehr Roboter: Walmart stellt Tausende von Maschinen f√ºr den Betrieb in seinen Filialen vor</a></li>
<li><a href="../de448034/index.html">Suchen Sie nach Aufgaben in JIRA (einfache Sprache). Teil 1: Schnelle und einfache Suche</a></li>
<li><a href="../de448036/index.html">Import nach J. Verbindung aus der Benutzerlistendatei √ºber die API</a></li>
<li><a href="../de448038/index.html">Neue Funktionen f√ºr Erweiterungsautoren in Visual Studio 2019 v.16.1</a></li>
<li><a href="../de448040/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 294 (vom 8. bis 14. April)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>