<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⬇️ 🖕 🗺️ Kompatibilitas biner reaktive: bagaimana kami menyediakannya 👨🏽‍🎤 🤥 🙈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai Nama saya Yuri Vlad, saya adalah pengembang Android di Badoo dan ikut serta dalam membuat perpustakaan Reaktive - Ekstensi Reaktif di Kotlin murni...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kompatibilitas biner reaktive: bagaimana kami menyediakannya</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/484712/"><p>  Hai  Nama saya Yuri Vlad, saya adalah pengembang Android di Badoo dan ikut serta dalam membuat perpustakaan <a href="https://github.com/badoo/Reaktive">Reaktive</a> - Ekstensi Reaktif di Kotlin murni. </p><br><p>  Setiap perpustakaan harus memperhatikan kompatibilitas biner jika memungkinkan.  Jika versi pustaka yang berbeda dalam dependensi tidak kompatibel, maka hasilnya akan macet di runtime.  Kami mungkin menghadapi masalah seperti itu, misalnya, ketika menambahkan dukungan <a href="https://github.com/badoo/MVICore">Reaktive</a> ke <a href="https://github.com/badoo/MVICore">MVICore</a> . </p><br><p><img src="https://habrastorage.org/webt/6w/hx/mc/6whxmcr9swxn5rtbxjeo46igkv8.jpeg"></p><br><p>  Dalam artikel ini saya akan secara singkat memberi tahu Anda apa kompatibilitas biner itu dan apa fitur-fiturnya untuk Kotlin, serta bagaimana itu didukung di JetBrains, dan sekarang di Badoo. </p><a name="habracut"></a><br><h2 id="problema-binarnoy-sovmestimosti-v-kotlin">  Masalah kompatibilitas biner Kotlin </h2><br><p> Misalkan kita memiliki perpustakaan yang luar biasa <code>com.sample:lib:1.0</code> dengan kelas ini: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>)</code> </pre> <br><p>  Berdasarkan itu, kami membuat <code>com.sample:lib-extensions:1.0</code> perpustakaan kedua. <code>com.sample:lib-extensions:1.0</code> .  Di antara dependensinya adalah <code>com.sample:lib:1.0</code> .  Misalnya, ini berisi metode pabrik untuk kelas <code>A</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: A = A(a)</code> </pre> <br><p>  Sekarang kami akan merilis versi baru dari perpustakaan kami <code>com.sample:lib:2.0</code> dengan perubahan berikut: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>)</code> </pre> <br><p>  Perubahan sepenuhnya kompatibel Kotlin, bukan?  Dengan parameter default, kita dapat terus menggunakan konstruk <code>val a = A(a)</code> , tetapi hanya jika semua dependensi sepenuhnya dikompilasi ulang.  Parameter default bukan bagian dari JVM dan diimplementasikan oleh konstruktor sintetis khusus <code>A</code> , yang berisi semua bidang kelas dalam parameter.  Dalam hal menerima dependensi dari repositori Maven, kami membuatnya sudah dirakit dan tidak dapat mengkompilasi ulang. </p><br><p>  Versi baru dari <code>com.sample:lib</code> , dan kami segera menghubungkannya ke proyek kami.  Kami ingin selalu terbarui!  Fitur baru, perbaikan baru, <del>  bug baru </del>  ! </p><br><pre> <code class="plaintext hljs">dependencies { implementation 'com.sample:lib:2.0' implementation 'com.sample:lib-extensions:1.0' }</code> </pre> <br><p>  Dan dalam hal ini, kita mengalami crash dalam runtime.  <code>createA</code> di bytecode akan mencoba memanggil konstruktor kelas <code></code> dengan satu parameter, dan sudah tidak ada yang seperti itu di bytecode.  Dari semua dependensi dengan grup dan nama yang sama, Gradle akan memilih salah satu yang memiliki versi terbaru dan memasukkannya ke dalam rakitan. </p><br><p>  Kemungkinan besar, Anda telah menemui ketidakcocokan biner dalam proyek Anda.  Secara pribadi, saya menemukan ini ketika saya memigrasi aplikasi kami ke AndroidX. </p><br><p>  Anda dapat membaca lebih lanjut tentang kompatibilitas biner dalam artikel <a href="https://habr.com/ru/post/133907/">"Kompatibilitas biner dalam contoh dan tidak hanya"</a> oleh pengguna <a href="https://habr.com/ru/users/gvsmirnov/" class="user_link">gvsmirnov</a> , <a href="https://wiki.eclipse.org/Evolving_Java-based_APIs_2">"Evolving Java-based APIs 2"</a> dari pembuat Eclipse dan dalam artikel yang baru-baru ini diterbitkan <a href="https://jakewharton.com/public-api-challenges-in-kotlin/">"Tantangan API Publik di Kotlin" oleh</a> Jake Wharton. </p><br><h2 id="sposoby-obespecheniya-binarnoy-sovmestimosti">  Cara untuk memastikan kompatibilitas biner </h2><br><p>  Tampaknya Anda hanya perlu mencoba membuat perubahan yang kompatibel.  Misalnya, tambahkan konstruktor dengan nilai default saat menambahkan bidang baru, tambahkan parameter baru ke fungsi dengan menimpa metode dengan parameter baru, dll. Tetapi selalu mudah untuk membuat kesalahan.  Oleh karena itu, berbagai alat untuk memeriksa kompatibilitas biner dari dua versi berbeda dari pustaka yang sama dibuat, seperti: </p><br><ol><li>  Pemeriksa Kepatuhan API Java </li><li>  Clirr </li><li>  Revapi </li><li>  Japicmp </li><li>  Japitools </li><li>  Jour </li><li>  Pemeriksa japi </li><li>  Sigtest </li></ol><br><p>  Mereka mengambil dua file JAR dan memberikan hasilnya: seberapa kompatibel mereka. </p><br><p>  Namun, kami sedang mengembangkan perpustakaan Kotlin, yang sejauh ini masuk akal untuk digunakan hanya dari Kotlin.  Ini berarti bahwa kita tidak selalu membutuhkan kompatibilitas 100%, misalnya, untuk kelas <code>internal</code> .  Meskipun mereka bersifat publik dalam bytecode, penggunaannya di luar kode Kotlin tidak mungkin.  Oleh karena itu, untuk menjaga kompatibilitas biner, Jetlinrlin kotlin-stdlib menggunakan <a href="https://github.com/jetBrains/kotlin/tree/master/libraries/tools/binary-compatibility-validator">pemeriksa kompatibilitas Biner</a> .  Prinsip dasarnya adalah ini: dump seluruh API publik dibuat dari file JAR dan ditulis ke file.  File ini adalah dasar (referensi) untuk semua pemeriksaan lebih lanjut, dan terlihat seperti ini: </p><br><pre> <code class="plaintext hljs">public final class kotlin/coroutines/ContinuationKt { public static final fun createCoroutine (Lkotlin/jvm/functions/Function1;Lkotlin/coroutines/Continuation;)Lkotlin/coroutines/Continuation; public static final fun createCoroutine (Lkotlin/jvm/functions/Function2;Ljava/lang/Object;Lkotlin/coroutines/Continuation;)Lkotlin/coroutines/Continuation; public static final fun startCoroutine (Lkotlin/jvm/functions/Function1;Lkotlin/coroutines/Continuation;)V public static final fun startCoroutine (Lkotlin/jvm/functions/Function2;Ljava/lang/Object;Lkotlin/coroutines/Continuation;)V }</code> </pre> <br><p>  Setelah membuat perubahan pada kode sumber, pustaka baseline dibuat ulang, dibandingkan dengan yang sekarang, dan pemeriksaan gagal jika ada perubahan pada pangkalan data yang muncul.  Perubahan ini dapat ditimpa dengan melewati <code>-Doverwrite.output=true</code> .  Kesalahan akan terjadi bahkan jika perubahan yang kompatibel biner telah terjadi.  Ini diperlukan untuk memperbarui baseline secara tepat waktu dan melihat perubahannya secara langsung dalam permintaan tarik. </p><br><h2 id="binary-compatibility-validator">  Validator kompatibilitas biner </h2><br><p>  Mari kita lihat bagaimana alat ini bekerja.  Kompatibilitas biner disediakan di tingkat JVM (bytecode) dan tidak tergantung bahasa.  Dimungkinkan untuk mengganti implementasi kelas Java dengan Kotlin- tanpa memutus kompatibilitas biner (dan sebaliknya). <br>  Pertama, Anda perlu memahami kelas apa yang ada di perpustakaan.  Kami ingat bahwa bahkan untuk fungsi dan konstanta global, kelas dibuat dengan nama file dan akhiran <code>Kt</code> , misalnya, <code>ContinuationKt</code> .  Untuk mendapatkan semua kelas, kita menggunakan kelas <code>JarFile</code> dari JDK, mendapatkan pointer ke setiap kelas dan meneruskannya ke <code>org.objectweb.asm.tree.ClassNode</code> .  Kelas ini akan memberi tahu kami visibilitas kelas, metode, bidang, dan anotasinya. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> jar = JarFile(<span class="hljs-string"><span class="hljs-string">"/path/to/lib.jar"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classStreams = jar.classEntries().map { entry -&gt; jar.getInputStream(entry) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classNodes = classStreams.map { it.use { stream -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classNode = ClassNode() ClassReader(stream).accept(classNode, ClassReader.SKIP_CODE) classNode } }</code> </pre> <br><p>  Kotlin, ketika mengkompilasi, menambahkan anotasi runtime <code>@Metadata</code> ke setiap kelas sehingga <code>kotlin-reflect</code> dapat mengembalikan tampilan kelas Kotlin sebelum dikonversi ke bytecode.  Ini terlihat seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Metadata</span></span>( mv = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>}, bv = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}, k = <span class="hljs-number"><span class="hljs-number">1</span></span>, d1 = {<span class="hljs-string"><span class="hljs-string">"\u0000 \n\u0002\u0018\u0002\n\u0002\u0010\u0000\n\u0000\n\u0002\u0010\b\n\u0002\b\u0006\n\u0002\u0010\u000b\n\u0002\b\u0003\n\u0002\u0010\u000e\n\u0000\b\u0086\b\u0018\u00002\u00020\u0001B\r\u0012\u0006\u0010\u0002\u001a\u00020\u0003¢\u0006\u0002\u0010\u0004J\t\u0010\u0007\u001a\u00020\u0003HÆ\u0003J\u0013\u0010\b\u001a\u00020\u00002\b\b\u0002\u0010\u0002\u001a\u00020\u0003HÆ\u0001J\u0013\u0010\t\u001a\u00020\n2\b\u0010\u000b\u001a\u0004\u0018\u00010\u0001HÖ\u0003J\t\u0010\f\u001a\u00020\u0003HÖ\u0001J\t\u0010\r\u001a\u00020\u000eHÖ\u0001R\u0011\u0010\u0002\u001a\u00020\u0003¢\u0006\b\n\u0000\u001a\u0004\b\u0005\u0010\u0006¨\u0006\u000f"</span></span>}, d2 = {<span class="hljs-string"><span class="hljs-string">"Lcom/sample/A;"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"(I)V"</span></span>, <span class="hljs-string"><span class="hljs-string">"getA"</span></span>, <span class="hljs-string"><span class="hljs-string">"()I"</span></span>, <span class="hljs-string"><span class="hljs-string">"component1"</span></span>, <span class="hljs-string"><span class="hljs-string">"copy"</span></span>, <span class="hljs-string"><span class="hljs-string">"equals"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"other"</span></span>, <span class="hljs-string"><span class="hljs-string">"hashCode"</span></span>, <span class="hljs-string"><span class="hljs-string">"toString"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"app_release"</span></span>} )</code> </pre> <br><p>  <code>ClassNode</code> bisa mendapatkan anotasi <code>@Metadata</code> dari <code>@Metadata</code> dan menguraikannya ke dalam <code>KotlinClassHeader</code> .  Anda harus melakukan ini secara manual, karena <code>kotlin-reflect</code> tidak tahu cara bekerja dengan ObjectWeb ASM. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ClassNode.kotlinMetadata: KotlinClassMetadata? <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> metadata = findAnnotation(<span class="hljs-string"><span class="hljs-string">"kotlin/Metadata"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) ?: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> header = with(metadata) { KotlinClassHeader( kind = <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"k"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>?, metadataVersion = (<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"mv"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> List&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;?)?.toIntArray(), bytecodeVersion = (<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"bv"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> List&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;?)?.toIntArray(), data1 = (<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"d1"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> List&lt;String&gt;?)?.toTypedArray(), data2 = (<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> List&lt;String&gt;?)?.toTypedArray(), extraString = <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"xs"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> String?, packageName = <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"pn"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> String?, extraInt = <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"xi"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>? ) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> KotlinClassMetadata.read(header) }</code> </pre> <br><p>  kotlin.Metadata diperlukan agar dapat menangani <code>internal</code> dengan benar, karena tidak ada dalam bytecode.  Perubahan ke kelas dan fungsi <code>internal</code> tidak dapat memengaruhi pengguna perpustakaan, meskipun mereka adalah API publik dalam hal bytecode. </p><br><p>  Dari kotlin.Metadata Anda dapat mencari tahu tentang <code>companion object</code> .  Bahkan jika Anda mendeklarasikannya sebagai pribadi, itu akan tetap disimpan di bidang bidang publik statis, yang berarti bahwa bidang ini termasuk dalam persyaratan kompatibilitas biner. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompositeException</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { } }</code> </pre> <br><pre> <code class="plaintext hljs">public final static Lcom/badoo/reaktive/base/exceptions/CompositeException$Companion; Companion @Ljava/lang/Deprecated;()</code> </pre> <br><p>  Dari anotasi yang diperlukan, perlu dicatat <code>@PublishedApi</code> untuk kelas dan metode yang digunakan dalam fungsi <code>inline</code> publik.  Isi fungsi tersebut tetap berada di tempat panggilannya, yang berarti bahwa kelas dan metode di dalamnya harus kompatibel dengan biner.  Saat Anda mencoba menggunakan kelas dan metode non-publik dalam fungsi-fungsi tersebut, kompiler Kotlin akan <code>@PublishedApi</code> kesalahan dan menawarkan untuk menandainya dengan penjelasan <code>@PublishedApi</code> . </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> ClassNode.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isPublishedApi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = findAnnotation(<span class="hljs-string"><span class="hljs-string">"kotlin/PublishedApi"</span></span>, includeInvisible = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) != <span class="hljs-literal"><span class="hljs-literal">null</span></span></code> </pre> <br><p>  Pohon warisan kelas dan implementasi antarmuka sangat penting untuk mendukung kompatibilitas biner.  Kami tidak dapat, misalnya, cukup menghapus beberapa antarmuka dari kelas.  Dan mendapatkan kelas induk dan antarmuka yang dapat diterapkan sangat sederhana. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> supertypes = listOf(classNode.superName) - <span class="hljs-string"><span class="hljs-string">"java/lang/Object"</span></span> + classNode.interfaces.sorted()</code> </pre> <br><p>  <code>Object</code> dihapus dari daftar, karena melacaknya tidak masuk akal. </p><br><p>  Di dalam validator ada banyak berbagai pemeriksaan tambahan khusus Kotlin: memeriksa metode default di antarmuka melalui <code>Interface$DefaultImpls</code> , mengabaikan kelas <code>$WhenMappings</code> untuk operator <code>when</code> bekerja, dan lainnya. </p><br><p>  Selanjutnya, Anda harus melalui semua <code>ClassNode</code> dan mendapatkan <code>MethodNode</code> dan <code>FieldNode</code> .  Dari tanda tangan kelas, bidang dan metode mereka, kita mendapatkan <code>ClassBinarySignature</code> , <code>FieldBinarySignature</code> dan <code>MethodBinarySignature</code> , yang dideklarasikan secara lokal di proyek.  Semua dari mereka menerapkan antarmuka <code>MemberBinarySignature</code> , dapat menentukan visibilitas publik mereka menggunakan metode <code>isEffectivelyPublic</code> dan menampilkan tanda tangan mereka dalam format yang dapat dibaca, <code>val signature: String</code> . </p><br><pre> <code class="kotlin hljs">classNodes.map { with(it) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> metadata = kotlinMetadata <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> mVisibility = visibilityMapNew[name] <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classAccess = AccessFlags(effectiveAccess and Opcodes.ACC_STATIC.inv()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> supertypes = listOf(superName) - <span class="hljs-string"><span class="hljs-string">"java/lang/Object"</span></span> + interfaces.sorted() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> memberSignatures = ( fields.map { with(it) { FieldBinarySignature(JvmFieldSignature(name, desc), isPublishedApi(), AccessFlags(access)) } } + methods.map { with(it) { MethodBinarySignature(JvmMethodSignature(name, desc), isPublishedApi(), AccessFlags(access)) } } ).filter { it.isEffectivelyPublic(classAccess, mVisibility) } ClassBinarySignature(name, superName, outerClassName, supertypes, memberSignatures, classAccess, isEffectivelyPublic(mVisibility), metadata.isFileOrMultipartFacade() || isDefaultImpls(metadata) } }</code> </pre> <br><p>  Setelah menerima daftar <code>ClassBinarySignature</code> , Anda dapat menulisnya ke file atau memori menggunakan metode <code>dump(to: Appendable)</code> dan membandingkannya dengan baseline, yang terjadi dalam tes <code>RuntimePublicAPITest</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RuntimePublicAPITest</span></span></span><span class="hljs-class"> </span></span>{ @[Rule JvmField] <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testName = TestName() <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kotlinStdlibRuntimeMerged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { snapshotAPIAndCompare(<span class="hljs-string"><span class="hljs-string">"../../stdlib/jvm/build/libs"</span></span>, <span class="hljs-string"><span class="hljs-string">"kotlin-stdlib"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">snapshotAPIAndCompare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( basePath: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, jarPattern: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, publicPackages: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; = emptyList()</span></span></span></span>, nonPublicPackages: List&lt;String&gt; = emptyList() ) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> base = File(basePath).absoluteFile.normalize() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> jarFile = getJarPath(base, jarPattern, System.getProperty(<span class="hljs-string"><span class="hljs-string">"kotlinVersion"</span></span>)) println(<span class="hljs-string"><span class="hljs-string">"Reading binary API from </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$jarFile</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> api = getBinaryAPI(JarFile(jarFile)).filterOutNonPublic(nonPublicPackages) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> target = File(<span class="hljs-string"><span class="hljs-string">"reference-public-api"</span></span>) .resolve(testName.methodName.replaceCamelCaseWithDashedLowerCase() + <span class="hljs-string"><span class="hljs-string">".txt"</span></span>) api.dumpAndCompareWith(target) }</code> </pre> <br><p>  Dengan melakukan baseline baru, kami mendapatkan perubahan dalam format yang dapat dibaca, seperti, misalnya, dalam <a href="https://github.com/badoo/Reaktive/pull/312/commits/c8985c15d24346ecfe89cb2ac84fbe7cf6cbeb3e">komit</a> ini: </p><br><pre> <code class="diff hljs"> public static final fun flattenObservable (Lcom/badoo/reaktive/single/Single;)Lcom/badoo/reaktive/observable/Observable; } + public final class com/badoo/reaktive/single/MapIterableKt { + public static final fun mapIterable (Lcom/badoo/reaktive/single/Single;Lkotlin/jvm/functions/Function1;)Lcom/badoo/reaktive/single/Single; + public static final fun mapIterableTo (Lcom/badoo/reaktive/single/Single;Lkotlin/jvm/functions/Function0;Lkotlin/jvm/functions/Function1;)Lcom/badoo/reaktive/single/Single; + } public final class com/badoo/reaktive/single/MapKt {</code> </pre> <br><h2 id="ispolzovanie-validatora-v-svoyom-proekte">  Menggunakan validator di proyek Anda </h2><br><p>  Penggunaannya sangat sederhana.  Salin <code>binary-compatibility-validator</code> ke proyek Anda dan ubah <code>build.gradle</code> dan <code>RuntimePublicAPITest</code> : </p><br><pre> <code class="kotlin hljs">plugins { id(<span class="hljs-string"><span class="hljs-string">"org.jetbrains.kotlin.jvm"</span></span>) } dependencies { implementation(Deps.asm) implementation(Deps.asm.tree) implementation(Deps.kotlinx.metadata.jvm) testImplementation(Deps.kotlin.test.junit) } tasks.named(<span class="hljs-string"><span class="hljs-string">"test"</span></span>, Test::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      ,   -     Gradle       : dependsOn( ":coroutines-interop:jvmJar", ":reaktive-annotations:jvmJar", ":reaktive:jvmJar", ":reaktive-annotations:jvmJar", ":reaktive-testing:jvmJar", ":rxjava2-interop:jar", ":rxjava3-interop:jar", ":utils:jvmJar" ) //    ,          baseline-: outputs.upToDateWhen { false } //    systemProperty("overwrite.output", findProperty("binary-compatibility-override") ?: "true") systemProperty("kotlinVersion", findProperty("reaktive_version").toString()) systemProperty("testCasesClassesDirs", sourceSets.test.get().output.classesDirs.asPath) jvmArgs("-ea") }</span></span></code> </pre> <br><p>  Dalam kasus kami, salah satu fungsi uji dari file <code>RuntimePublicAPITest</code> terlihat seperti ini: </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reaktive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { snapshotAPIAndCompare(<span class="hljs-string"><span class="hljs-string">"../../reaktive/build/libs"</span></span>, <span class="hljs-string"><span class="hljs-string">"reaktive-jvm"</span></span>) }</code> </pre> <br><p>  Sekarang untuk setiap permintaan tarik, jalankan <code>./gradlew :tools:binary-compatibility:test -Pbinary-compatibility-override=false</code> dan memaksa pengembang untuk memperbarui file baseline tepat waktu. </p><br><h2 id="lozhka-dyogtya">  Terbang di salep </h2><br><p>  Namun, pendekatan ini memiliki beberapa poin buruk. </p><br><p>  Pertama, kita harus menganalisis perubahan pada file baseline secara independen.  Tidak selalu perubahannya menyebabkan ketidakcocokan biner.  Misalnya, jika Anda menerapkan antarmuka baru, Anda mendapatkan perbedaan dalam baseline: </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- public final class com/test/A { + public final class com/test/A : Comparable {</span></span></code> </pre> <br><p>  Kedua, alat yang tidak dimaksudkan untuk ini digunakan.  Pengujian seharusnya tidak memiliki efek samping dalam bentuk penulisan beberapa file ke disk, yang selanjutnya akan digunakan oleh pengujian yang sama, dan terlebih lagi, meneruskan parameter ke sana melalui variabel lingkungan.  Alangkah baiknya jika menggunakan alat ini dalam plugin Gradle dan membuat garis dasar menggunakan tugas.  Tapi saya benar-benar tidak ingin mengubah sesuatu sendiri di validator, sehingga nantinya akan mudah untuk menarik semua perubahannya dari repositori Kotlin, karena di masa depan konstruksi baru mungkin muncul dalam bahasa yang perlu didukung. </p><br><p>  Yah dan ketiga, hanya JVM yang didukung. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Menggunakan <a href="https://github.com/jetBrains/kotlin/tree/master/libraries/tools/binary-compatibility-validator">pemeriksa kompatibilitas Biner,</a> Anda dapat mencapai kompatibilitas biner dan merespons dalam waktu terhadap perubahan dalam statusnya.  Untuk menggunakannya dalam proyek, perlu mengubah hanya dua file dan menghubungkan tes ke CI kami.  Solusi ini memiliki beberapa kelemahan, tetapi masih cukup nyaman untuk digunakan.  Sekarang Reaktive akan mencoba mempertahankan kompatibilitas biner untuk JVM dengan cara yang sama seperti yang dilakukan JetBrains untuk Perpustakaan Standar Kotlin. </p><br><p>  Terima kasih atas perhatian anda! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id484712/">https://habr.com/ru/post/id484712/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id484700/index.html">Java 14: catatan pratinjau</a></li>
<li><a href="../id484702/index.html">Alternatif Prestashop pada tahun 2020: Platform eCommerce Teratas</a></li>
<li><a href="../id484706/index.html">Berlatih dalam bekerja dengan ban khusus dari kompleks Redd</a></li>
<li><a href="../id484708/index.html">Richard Hamming "Bab tidak ada": Bagaimana kita tahu apa yang kita ketahui (versi lengkap)</a></li>
<li><a href="../id484710/index.html">Melanggar Aturan Pengumpulan Sampah Persatuan</a></li>
<li><a href="../id484716/index.html">Berhenti memanggil semuanya AI</a></li>
<li><a href="../id484718/index.html">Printer modern HP menolak untuk bekerja tanpa berlangganan tinta</a></li>
<li><a href="../id484720/index.html">Konser untuk kota dengan orkestra: siapa dan mengapa merekam suara kehidupan sehari-hari</a></li>
<li><a href="../id484722/index.html">Alat Pengembangan Ruby on Rails Yang Sesuai dengan Proyek Anda: Ruby Top on Rails untuk 2020</a></li>
<li><a href="../id484724/index.html">Berita dari dunia OpenStreetMap No. 494 (12.31.2019-06.01.2020)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>