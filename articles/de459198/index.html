<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßí üçî üåÉ Abfrageleistungsanalyse in ClickHouse. Yandex-Bericht üïô ü§µ üàπ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Was ist, wenn Ihre Datenbankabfrage nicht schnell genug ausgef√ºhrt wird? Woher wissen Sie, ob eine Abfrage Rechenressourcen optimal nutzt oder beschle...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Abfrageleistungsanalyse in ClickHouse. Yandex-Bericht</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/459198/">  Was ist, wenn Ihre Datenbankabfrage nicht schnell genug ausgef√ºhrt wird?  Woher wissen Sie, ob eine Abfrage Rechenressourcen optimal nutzt oder beschleunigt werden kann?  Bei der letzten HighLoad ++ - Konferenz in Moskau habe ich √ºber die Selbstbeobachtung der Abfrageleistung gesprochen - sowohl √ºber die Funktionen des ClickHouse-DBMS als auch √ºber die Betriebssystemfunktionen, die jeder kennen sollte. <br><br><img src="https://habrastorage.org/webt/mi/yo/wu/miyowuhgorpfpl9zih8cszids0y.jpeg"><br><br>  Jedes Mal, wenn ich eine Anfrage stelle, geht es mir nicht nur um das Ergebnis, sondern auch darum, was diese Anfrage bewirkt.  Zum Beispiel funktioniert es f√ºr eine Sekunde.  Ist es viel oder wenig?  Ich denke immer: warum nicht eine halbe Sekunde?  Dann optimiere ich etwas, beschleunige es und es funktioniert f√ºr 10 ms.  Ich bin normalerweise zufrieden.  Trotzdem versuche ich in diesem Fall einen unzufriedenen Gesichtsausdruck zu machen und frage: "Warum nicht 5 ms?"  Wie kann ich herausfinden, wie viel Zeit f√ºr die Bearbeitung der Anfrage aufgewendet wird?  Kann es prinzipiell beschleunigt werden? <br><br><a name="habracut"></a>  In der Regel ist die Verarbeitungsgeschwindigkeit von Anforderungen eine einfache Arithmetik.  Wir haben den Code geschrieben - wahrscheinlich optimal - und wir haben ein Ger√§t im System.  Ger√§te haben Spezifikationen.  Zum Beispiel die Lesegeschwindigkeit aus dem L1-Cache.  Oder die Anzahl der zuf√§lligen Lesevorg√§nge, die eine SSD ausf√ºhren kann.  Das wissen wir alle.  Wir m√ºssen diese Eigenschaften nehmen, addieren, subtrahieren, multiplizieren, dividieren und die Antwort √ºberpr√ºfen.  Dies ist jedoch im Idealfall so gut wie nie der Fall.  Fast.  Tats√§chlich passiert dies manchmal in ClickHouse. <br><br>  Ber√ºcksichtigen Sie die trivialen Fakten dar√ºber, welche Ger√§te und welche Ressourcen sich auf unseren Servern befinden. <br><br><img src="https://habrastorage.org/webt/6e/gz/us/6egzusxqlzhg81ledkch36wrld4.jpeg" width="700"><br><br>  Prozessor, Speicher, Festplatte, Netzwerk.  Ich habe diese Ressourcen speziell so angeordnet, angefangen bei den einfachsten und bequemsten f√ºr die √úberpr√ºfung und Optimierung bis hin zu den unpraktischsten und komplexesten.  Zum Beispiel f√ºhre ich eine Anfrage aus und sehe, dass mein Programm auf der CPU zu ruhen scheint.  Was bedeutet das?  Was ich dort finden werde, ist eine Art innere Schleife, eine Funktion, die am h√§ufigsten ausgef√ºhrt wird, den Code neu schreibt, neu kompiliert und einmal - mein Programm l√§uft schneller. <br><br>  Wenn Sie zu viel RAM ausgeben, ist alles etwas komplizierter.  Sie m√ºssen die Datenstruktur √ºberdenken und einige Bits dr√ºcken.  In jedem Fall starte ich mein Programm neu und es verbraucht weniger RAM.  Dies geht zwar h√§ufig zu Lasten des Prozessors. <br><br>  Wenn alles von Festplatten abh√§ngt, ist dies auch schwieriger, da ich die Datenstruktur auf der Festplatte √§ndern kann, diese Daten jedoch sp√§ter konvertieren muss.  Wenn ich eine neue Version erstelle, m√ºssen die Benutzer eine Art Datenmigration durchf√ºhren.  Es stellt sich heraus, dass die Festplatte bereits viel komplizierter ist, und es ist besser, im Voraus dar√ºber nachzudenken. <br><br>  Und das Netzwerk ... Ich mag das Netzwerk wirklich nicht, weil es oft v√∂llig unklar ist, was darin passiert, insbesondere wenn es sich um ein Netzwerk zwischen Kontinenten und Rechenzentren handelt.  Dort verlangsamt sich etwas, und es ist nicht einmal Ihr Netzwerk, nicht Ihr Server, und Sie k√∂nnen nichts tun.  Das einzige, was Sie im Voraus √ºberlegen k√∂nnen, ist, wie die Daten √ºbertragen werden und wie die Interaktion √ºber das Netzwerk minimiert werden kann. <br><br>  Es kommt vor, dass keine einzige Ressource im System verwendet wird und das Programm nur auf etwas wartet.  Tats√§chlich ist dies ein sehr h√§ufiger Fall, da unser System verteilt ist und es viele verschiedene Prozesse und Abl√§ufe geben kann und einer auf einen anderen wartet und all dies irgendwie miteinander verbunden sein muss, um dies richtig zu ber√ºcksichtigen. <br><br><img src="https://habrastorage.org/webt/vq/mk/sa/vqmksaynboi4frop2kzfcvk9q4w.jpeg" width="700"><br><br>  Am einfachsten ist es, die Ressourcennutzung mit einem numerischen Wert zu betrachten.  Zum Beispiel starten Sie einige Top, und er schreibt: Der Prozessor ist 100%.  Oder f√ºhren Sie iostat aus und er schreibt: Festplatten sind 100%.  Das reicht oft nicht aus.  Eine Person wird sehen, dass das Programm auf Festplatten ruht.  Was kann getan werden?  Sie k√∂nnen dies einfach notieren und sich ausruhen, entscheiden, dass alles, nichts optimiert werden kann.  Tats√§chlich ist jedoch jedes der Ger√§te in sich selbst ziemlich kompliziert.  Der Prozessor verf√ºgt √ºber eine Reihe von Computerger√§ten f√ºr verschiedene Arten von Vorg√§ngen.  Festplatten haben m√∂glicherweise ein RAID-Array.  Wenn es eine SSD gibt, dann gibt es in ihrem eigenen Prozessor einen eigenen Controller, was unklar macht, was.  Und ein Wert - 50% oder 100% - reicht nicht aus.  Die Grundregel: Wenn Sie feststellen, dass eine Ressource zu 100% ausgelastet ist, geben Sie nicht auf.  Oft kann man noch etwas verbessern.  Aber es passiert und umgekehrt.  Angenommen, Sie sehen, dass das Recycling 50% betr√§gt, aber nichts getan werden kann. <br><br>  Schauen wir uns das genauer an. <br><br><img src="https://habrastorage.org/webt/pa/wj/uo/pawjuoieudajqc097ysekq30wnc.jpeg" width="700"><br><br>  Die einfachste und bequemste Ressource ist der Prozessor.  Sie sehen oben, es hei√üt, dass der Prozessor 100% ist.  Es sollte jedoch beachtet werden, dass dies kein 100% iger Prozessor ist.  Das Top-Programm wei√ü nicht, was der Prozessor dort macht.  Sie schaut aus der Perspektive des OS-Planers.  Das hei√üt, jetzt l√§uft eine Art Programm-Thread auf dem Prozessor.  Der Prozessor macht etwas, und dann werden 100% angezeigt, wenn es √ºber die Zeit gemittelt wird.  Gleichzeitig macht der Prozessor etwas und es ist nicht klar, wie effektiv es ist.  Es kann eine andere Anzahl von Anweisungen pro Zyklus ausf√ºhren.  Wenn nur wenige Anweisungen vorhanden sind, kann der Prozessor selbst auf etwas warten, z. B. das Laden von Daten aus dem Speicher.  Gleichzeitig wird dasselbe oben angezeigt - 100%.  Wir warten darauf, dass der Prozessor unseren Anweisungen folgt.  Und was er drinnen macht, ist unklar. <br><br>  Schlie√ülich gibt es nur einen Rechen, wenn Sie denken, dass Ihr Programm auf dem Prozessor ruht.  Dies ist wahr, aber aus irgendeinem Grund hat der Prozessor eine niedrigere Frequenz.  Es kann viele Gr√ºnde geben: √úberhitzung, Leistungsbegrenzung.  Aus irgendeinem Grund gibt es im Rechenzentrum eine Leistungsbegrenzung, oder die Energieeinsparung kann einfach aktiviert werden.  Dann wechselt der Prozessor st√§ndig von einer h√∂heren zu einer niedrigeren Frequenz. Wenn Ihre Last jedoch instabil ist, reicht dies nicht aus und der Code wird im Durchschnitt langsamer ausgef√ºhrt.  Die aktuelle Prozessorfrequenz finden Sie im Turbostat.  In dmesg auf √úberhitzung pr√ºfen.  Wenn so etwas passieren w√ºrde, w√ºrde es sagen: ‚Äû√úberhitzung.  Frequenz runter. " <br><br>  Wenn Sie daran interessiert sind, wie viele Cache-Fehler sich darin befanden, wie viele Anweisungen pro Zyklus ausgef√ºhrt werden, verwenden Sie perf record.  Nehmen Sie ein Beispiel des Programms auf.  Weiterhin wird es m√∂glich sein, es mit perf stat oder perf report zu betrachten. <br><br><img src="https://habrastorage.org/webt/hl/4v/up/hl4vupofzsuha-s7cyxtba-po0c.jpeg" width="600"><br><br>  Umgekehrt.  Nehmen wir an, Sie schauen nach oben und der Prozessor ist zu weniger als 50% recycelt.  Angenommen, Ihr System verf√ºgt √ºber 32 virtuelle Prozessorkerne und 16 physische Kerne. Auf Intel-Prozessoren liegt dies daran, dass das Hyper-Threading doppelt so hoch ist.  Dies bedeutet jedoch nicht, dass zus√§tzliche Kerne unbrauchbar sind.  Es h√§ngt alles von der Last ab.  Angenommen, Sie haben einige gut optimierte lineare Algebraoperationen oder Sie haben Hashes f√ºr das Mining von Bitcoins.  Dann ist der Code klar, viele Anweisungen werden pro Zyklus ausgef√ºhrt, es gibt keine Cache-Fehler und auch keine Verzweigungsfehler.  Und Hyper-Threading hilft nicht.  Es ist hilfreich, wenn ein Kern auf etwas wartet, w√§hrend der andere gleichzeitig Anweisungen von einem anderen Thread ausf√ºhren kann. <br><br>  ClickHouse hat beide Situationen.  Wenn wir beispielsweise Datenaggregation (GROUP BY) oder Filterung nach Set (IN-Unterabfrage) durchf√ºhren, haben wir eine Hash-Tabelle.  Wenn die Hash-Tabelle nicht in den Prozessor-Cache passt, treten Cache-Fehler auf.  Dies kann kaum vermieden werden.  In diesem Fall hilft uns Hyper-Threading. <br><br>  Standardm√§√üig verwendet ClickHouse nur physische Prozessorkerne, ausgenommen Hyper-Threading.  Wenn Sie wissen, dass Ihre Anfrage von Hyper-Threading profitieren kann, verdoppeln Sie einfach die Anzahl der Threads: SET max threads = 32, und Ihre Anfrage wird schneller. <br><br>  Es kommt vor, dass der Prozessor perfekt genutzt wird, aber Sie sehen sich die Grafik an und sehen beispielsweise 10%.  Und Ihr Zeitplan betr√§gt zum Beispiel im schlimmsten Fall f√ºnf Minuten.  Selbst wenn es eine Sekunde ist, gibt es immer noch eine Art Durchschnittswert.  Tats√§chlich hatten Sie st√§ndig Anfragen, diese werden schnell ausgef√ºhrt, in 100 ms pro Sekunde, und das ist normal.  Weil ClickHouse versucht, die Anforderung so schnell wie m√∂glich auszuf√ºhren.  Er versucht √ºberhaupt nicht, Ihre Prozessoren vollst√§ndig und st√§ndig zu nutzen und zu √ºberhitzen. <br><br><img src="https://habrastorage.org/webt/39/ka/ei/39kaeie-ngofbbynsnlq4mum_d0.jpeg" width="700"><br><br>  Schauen wir uns das etwas genauer an, eine etwas komplizierte Option.  Es gibt eine Abfrage mit einem Ausdruck in der Unterabfrage.  Innerhalb der Unterabfrage haben wir 100 Millionen Zufallszahlen.  Und wir filtern nur nach diesem Ergebnis. <br><br>  Wir sehen so ein Bild.  √úbrigens, wer wird sagen, mit welchem ‚Äã‚ÄãWerkzeug ich dieses wundervolle Bild sehen kann?  Absolut wahr - perf.  Ich bin sehr froh, dass Sie das wissen. <br><br>  Ich √∂ffnete Perf und dachte, dass ich jetzt alles verstehe.  Ich √∂ffne die Assembler-Liste.  Dort schrieb ich, wie oft die Ausf√ºhrung des Programms auf einer bestimmten Anweisung erfolgte, dh wie oft es einen Anweisungszeiger gab.  Hier sind die Zahlen in Prozent angegeben, und es wird geschrieben, dass fast 90% der Zeit, in der der Testbefehl% edx,% edx ausgef√ºhrt wurde, vier Bytes auf Null √ºberpr√ºft wurden. <br><br>  Die Frage ist: Warum kann ein Prozessor so lange brauchen, um einfach vier Bytes mit Null zu vergleichen?  (Antworten aus dem Publikum ...) Es gibt keinen Rest der Aufteilung.  Es gibt Bitverschiebungen, dann gibt es einen crc32q-Befehl, aber als ob der Befehlszeiger niemals darauf passiert.  Und Zufallszahlengenerierung ist nicht in dieser Liste.  Es gab eine separate Funktion, die sehr gut optimiert ist und nicht langsamer wird.  Hier verlangsamt sich etwas anderes.  Die Codeausf√ºhrung stoppt bei dieser Anweisung und verbringt viel Zeit.  Leerlaufschleife?  Nein.  Warum sollte ich leere Schleifen einf√ºgen?  Wenn ich die Idle-Schleife einf√ºgen w√ºrde, w√§re dies auch in perf sichtbar.  Es gibt keine Division durch Null, es gibt einfach einen Vergleich mit Null. <br><br>  Der Prozessor hat eine Pipeline, er kann mehrere Befehle parallel ausf√ºhren.  Und wenn sich der Befehlszeiger an einer Stelle befindet, bedeutet dies √ºberhaupt nicht, dass er diesen Befehl ausf√ºhrt.  Vielleicht wartet er auf andere Anweisungen. <br><br>  Wir haben eine Hash-Tabelle, um zu √ºberpr√ºfen, ob eine bestimmte Anzahl in einem Satz vorkommt.  Dazu f√ºhren wir eine Suche im Speicher durch.  Wenn wir eine Suche im Speicher durchf√ºhren, tritt ein Cache-Fehler auf, da die Hash-Tabelle 100 Millionen Zahlen enth√§lt und nicht garantiert werden kann, dass sie in einen Cache passt.  Um den Nullpr√ºfbefehl auszuf√ºhren, sollten diese Daten bereits aus dem Speicher geladen sein.  Und wir warten, bis sie geladen sind. <br><br><img src="https://habrastorage.org/webt/w9/7b/ed/w97bediv43zlhfvat95k7qdar3k.jpeg" width="700"><br><br>  Jetzt die n√§chste Ressource, etwas komplexer - Laufwerke.  SSDs werden manchmal auch als Laufwerke bezeichnet, obwohl dies nicht ganz richtig ist.  In diesem Beispiel werden auch SSDs enthalten sein. <br><br>  Wir √∂ffnen zum Beispiel iostat, es zeigt eine Auslastung von 100%. <br><br>  Bei Konferenzen kommt es h√§ufig vor, dass der Redner auf die B√ºhne geht und mit Pathos sagt: ‚ÄûDatenbanken sto√üen immer an die Festplatte.  Aus diesem Grund haben wir eine In-Memory-Datenbank erstellt.  Sie wird nicht langsamer. "  Wenn sich eine Person Ihnen n√§hert und dies sagt, k√∂nnen Sie sie sicher senden.  Es wird einige Probleme geben - Sie sagen, ich habe es gel√∂st.  :) :) <br><br>  Angenommen, ein Programm ruht auf Datentr√§gern, die Auslastung betr√§gt 100. Dies bedeutet jedoch nat√ºrlich nicht, dass wir Datentr√§ger optimal verwenden. <br><br>  Ein typisches Beispiel ist, wenn Sie nur viel Direktzugriff haben.  Selbst wenn der Zugriff sequentiell erfolgt, lesen Sie die Datei einfach nacheinander, sie kann jedoch mehr oder weniger optimal sein. <br><br>  Sie haben beispielsweise ein RAID-Array, mehrere Ger√§te, z. B. 8 Festplatten.  Und Sie lesen nur nacheinander ohne Vorauslesen mit einer Puffergr√∂√üe von 1 MB, und die Blockgr√∂√üe in Ihrem Streifen in RAID betr√§gt ebenfalls 1 MB.  Dann wird jeder Messwert von einem Ger√§t abgerufen.  Oder, wenn nicht ausgerichtet, von zwei Ger√§ten.  Ein halbes Megabyte wird irgendwohin gehen, ein weiteres halbes Megabyte irgendwohin und so weiter - die Festplatten werden der Reihe nach verwendet: eine, dann eine andere, dann eine dritte. <br><br>  Es muss vorher gelesen werden.  Wenn Sie O_DIRECT haben, vergr√∂√üern Sie den Puffer.  Das hei√üt, die Regel lautet: 8 Festplatten, Blockgr√∂√üe 1 MB, stellen Sie die Puffergr√∂√üe auf mindestens 8 MB ein.  Dies funktioniert jedoch nur dann optimal, wenn der Messwert ausgerichtet ist.  Und wenn es nicht ausgerichtet ist, gibt es zuerst zus√§tzliche Teile, und Sie m√ºssen mehr setzen, multiplizieren Sie mit ein paar mehr. <br><br>  Oder Sie haben beispielsweise RAID 10. Mit welcher Geschwindigkeit k√∂nnen Sie von RAID 10 lesen - zum Beispiel von 8 Festplatten?  Was wird der Vorteil sein?  Vierfach, weil es einen Spiegel gibt, oder achtfach?  Tats√§chlich h√§ngt es davon ab, wie das RAID erstellt wird und mit welcher Anordnung von Bl√∂cken in Streifen. <br><br>  Wenn Sie mdadm unter Linux verwenden, k√∂nnen Sie dort Nah- und Fernlayout angeben, wobei Nah zum Schreiben und Fern zum Lesen besser ist. <br><br>  Ich empfehle immer die Verwendung eines Fernlayouts, da das Schreiben in die Analysedatenbank in der Regel zeitlich nicht so kritisch ist - auch wenn viel mehr geschrieben als gelesen wird.  Dies geschieht durch einen Hintergrundprozess.  Aber wenn Sie lesen, m√ºssen Sie es so schnell wie m√∂glich fertigstellen.  Daher ist es besser, RAID f√ºr das Lesen zu optimieren, indem Sie das Fernlayout festlegen. <br><br>  Gl√ºcklicherweise stellt mdadm Sie unter Linux standardm√§√üig auf nahezu Layout ein und Sie erhalten nur die H√§lfte der Leistung.  Es gibt viele solcher Rechen. <br><br>  Ein weiterer schrecklicher Rake ist RAID 5 oder RAID 6. Dort l√§sst sich alles durch sequentielles Lesen und Schreiben gut skalieren.  In RAID 5 ist die Multiplizit√§t "die Anzahl der Ger√§te minus eins".  Dies l√§sst sich auch bei zuf√§lligen Lesungen gut skalieren, bei zuf√§lligen Lesungen jedoch nicht.  Machen Sie eine Aufzeichnung an einem beliebigen Ort, und Sie m√ºssen Daten von allen anderen Datentr√§gern lesen, sie speichern (XOR - ca. Ed.) Und an einen anderen Ort schreiben.  Daf√ºr wird ein bestimmter Streifen-Cache verwendet, ein schrecklicher Rechen.  Unter Linux ist es standardm√§√üig so, dass Sie RAID 5 erstellen und es f√ºr Sie langsamer wird.  Und Sie werden denken, dass RAID 5 immer langsamer wird, weil dies verst√§ndlich ist.  Tats√§chlich liegt der Grund jedoch in der falschen Einrichtung. <br><br>  Ein weiteres Beispiel.  Sie lesen von einer SSD und haben sich eine gute SSD gekauft. In der Spezifikation stehen 300.000 zuf√§llige Lesevorg√§nge pro Sekunde.  Und aus irgendeinem Grund k√∂nnen Sie es nicht tun.  Und Sie denken - ja, sie liegen alle in ihren Spezifikationen, so etwas gibt es nicht.  Alle diese Messungen m√ºssen jedoch parallel und mit maximaler Parallelit√§t durchgef√ºhrt werden.  Die einzige M√∂glichkeit, dies optimal zu tun, ist die Verwendung von asynchroner E / A, die mithilfe der Systemaufrufe io_submit, io_getevents, io_setup usw. implementiert wird. <br><br>  √úbrigens, wenn Sie die Daten auf der Festplatte speichern, m√ºssen Sie sie immer komprimieren.  Ich werde ein Beispiel aus der Praxis geben.  Eine Person hat uns im ClickHouse- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Support-Chat</a> kontaktiert und gesagt: <br><br>  - ClickHouse komprimiert die Daten.  Ich sehe, es liegt auf dem Prozessor.  Ich habe sehr schnelle NVMe-SSDs, sie haben eine Lesegeschwindigkeit von mehreren Gigabyte pro Sekunde.  Ist es m√∂glich, die Komprimierung in ClickHouse irgendwie zu deaktivieren? <br>  "Nein, auf keinen Fall", sage ich.  - Sie m√ºssen die Daten komprimiert halten. <br>  - H√∂ren wir auf, es wird nur einen anderen Komprimierungsalgorithmus geben, der nichts bewirkt. <br>  - Einfach.  Geben Sie diese Buchstaben in diese Codezeile ein. <br>  "In der Tat ist alles sehr einfach", antwortete er einen Tag sp√§ter.  - Ich habe gemacht. <br>  - Wie stark hat sich die Leistung ver√§ndert? <br>  "Fehler beim Testen", schrieb er einen weiteren Tag sp√§ter.  - Es sind zu viele Daten vorhanden.  Sie passen nicht mehr auf SSDs. <br><br>  Lassen Sie uns nun sehen, wie das Lesen von der Festplatte aussehen k√∂nnte.  Wir starten dstat, es zeigt die Lesegeschwindigkeit. <br><br><div class="spoiler">  <b class="spoiler_title">Das erste Beispiel f√ºr dstat und iostat</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/tp/bv/hc/tpbvhccpx_oezqb-bl61xfhcrtq.gif"><br></div></div><br>  Hier ist die gelesene Spalte - 300 MB / s.  Wir lesen von Scheiben.  Es ist viel oder wenig - ich wei√ü es nicht. <br><br>  Jetzt starte ich iostat, um dies zu √ºberpr√ºfen.  Hier sehen Sie die Aufschl√ºsselung nach Ger√§t.  Ich habe RAID, MD2 und acht Festplatten.  Jeder von ihnen zeigt Recycling, es erreicht nicht einmal 100% (50-60%).  Das Wichtigste ist jedoch, dass ich von jeder Festplatte nur mit einer Geschwindigkeit von 20-30 MB / s lese.  Und seit meiner Kindheit erinnerte ich mich an die Regel, dass man irgendwo ab 100 MB / s von der Festplatte lesen kann.  Aus irgendeinem Grund hat sich daran immer noch nicht viel ge√§ndert. <br><br><div class="spoiler">  <b class="spoiler_title">Zweites Beispiel f√ºr dstat und iostat</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/yv/x-/wf/yvx-wf4ufaglo2ehwozvvh1mj48.gif"><br></div></div><br>  Hier ist ein weiteres Beispiel.  Lesen ist optimaler.  Ich f√ºhre dstat aus und habe eine Lesegeschwindigkeit von 1 GB / s von diesem RAID 5 von acht Laufwerken.  Was zeigt iostat?  Ja, fast 1 GB / s. <br><br>  Jetzt sind die Laufwerke endlich zu 100% geladen.  Aus irgendeinem Grund sind zwei zu 100% und der Rest zu 95%.  Wahrscheinlich sind sie noch etwas anders.  Aber mit jedem von ihnen lese ich 150 MB / s, noch cooler als es sein kann.  Was ist der Unterschied?  Im ersten Fall lese ich mit unzureichender Puffergr√∂√üe in unzureichenden St√ºcken.  Es ist einfach, ich sage dir gemeinsame Wahrheiten. <br><br>  √úbrigens, wenn Sie der Meinung sind, dass die Daten f√ºr die Analysedatenbank immer noch nicht komprimiert werden m√ºssen, d. H. Ein Bericht von der HighLoad ++ Sibirien-Konferenz ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Habrastatie basierend auf dem Bericht</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ungef√§hr</a> ).  Die Organisatoren beschlossen, die Hardcore-Berichte in Nowosibirsk zu erstellen. <br><br><img src="https://habrastorage.org/webt/pu/6k/kp/pu6kkpnztqtp_elvxpta__ya8f0.jpeg" width="700"><br><br>  Das n√§chste Beispiel ist Speicher.  Fortsetzung der gemeinsamen Wahrheiten.  Erstens, unter Linux, sehen Sie nie, welche kostenlosen Shows.  F√ºr diejenigen, die zuschauen, haben sie speziell die Website linuxatemyram.com erstellt.  Komm rein, es wird eine Erkl√§rung geben.  Sie m√ºssen sich auch nicht die Menge des virtuellen Speichers ansehen, denn was ist der Unterschied, wie viel Adressraum hat das Programm zugewiesen?  Sehen Sie sich an, wie viel physischer Speicher verwendet wird. <br><br>  Und noch ein Rechen, mit dem nicht einmal klar ist, wie man k√§mpft.  Denken Sie daran: Die Tatsache, dass Allokatoren dem System h√§ufig keinen Speicher geben m√∂chten, ist normal.  Sie haben mmap gemacht, aber munmap nicht mehr.  Der Speicher kehrt nicht zum System zur√ºck.  Das Programm denkt - ich wei√ü besser, wie ich den Speicher nutzen werde.  Ich werde es mir selbst √ºberlassen.  Weil die Systemaufrufe mmap und munmap ziemlich langsam sind.  √Ñndern des Adressraums, Leeren der TLB-Caches des Prozessors - am besten nicht.  Das Betriebssystem hat jedoch weiterhin die M√∂glichkeit, Speicher mithilfe des madvise-Systemaufrufs korrekt freizugeben.  Der Adressraum bleibt erhalten, aber der Speicher kann physisch entladen werden. <br><br>  Aktivieren Sie niemals den Austausch auf Produktionsservern mit Datenbanken.  Sie denken - es gibt nicht genug Speicher, ich werde Swap einschlie√üen.  Danach funktioniert die Anfrage nicht mehr.  Es wird endlose Zeit knacken. <br><br><img src="https://habrastorage.org/webt/mb/0d/2n/mb0d2nmqxl5zq7hu5foyae9ir40.jpeg" width="650"><br><br>  Mit einem Netzwerk zu typischen Rechen.  Wenn Sie jedes Mal eine TCP-Verbindung erstellen, dauert es einige Zeit, bis die richtige Fenstergr√∂√üe ausgew√§hlt ist, da das TCP-Protokoll nicht wei√ü, wie schnell Daten √ºbertragen werden m√ºssen.  Er passt sich dem an. <br><br>  Oder stellen Sie sich vor, Sie √ºbertragen eine Datei und haben eine gro√üe Latenz in Ihrem Netzwerk und einen anst√§ndigen Paketverlust.  Dann ist es √ºberhaupt nicht offensichtlich, ob es richtig ist, TCP zum √úbertragen von Dateien zu verwenden.  Ich denke, es ist falsch, da TCP Konsistenz garantiert.  Auf der anderen Seite k√∂nnen Sie eine H√§lfte der Datei und die andere gleichzeitig √ºbertragen.  Verwenden Sie mindestens mehrere TCP-Verbindungen oder verwenden Sie TCP √ºberhaupt nicht f√ºr die Daten√ºbertragung. ,   ,    ,  TCP    .    . <br><br>       100- ,   .     10   -,     ,   ,       .  .    . <br><br><img src="https://habrastorage.org/webt/xy/ch/_m/xych_mjdelh5uydffukjrxzbf-k.jpeg" width="800"><br><br>    ?      ‚Äî     .    ,     ,  ,  10  .    ,       . <br><br><img src="https://habrastorage.org/webt/mp/p_/bq/mpp_bqykipgfxtbiu6i8_a4xfpm.jpeg" width="400"><br><br>   : ¬´   -  ¬ª ‚Äî          .      iotop,  ,           ,   iops. <br><br>         ,     .  . <br><br><div class="spoiler"> <b class="spoiler_title">: top  </b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/8r/3l/wg/8r3lwg_u4l6bexuezkp-s3kdvno.gif"><br></div></div><br>   top  -,   ,  clickHouse-server  -  , -  .   ,   ,    Shift+H,      .    ,  ClickHouse  .   ParalInputsProc,   .  BackgrProcPool ‚Äî   merges     .   ,            . <br><br>    ?     ClickHouse,  ,     .    BackgroundProcessingPool.     15 . 16  1,  1 ‚Äî   .  16?  ,    Linux ‚Äî   ,  : ¬´16 .  ¬ª.  :) :) <br><br>        clickhouse-benchmark.        clickhouse-client.    ,    clickhouse-client,  .      -         .             . <br><br><div class="spoiler"> <b class="spoiler_title">: clickhouse-benchmark + perf top</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/bu/ol/_g/buol_gwiuvuqmnn3xxxzpkafc6g.gif"><br></div></div><br>         .  clickhouse-benchmark,  ,      ,   ,     ,           .       peft top.   peft top,       .  ,    -     -,      uniq: UniquesHashSet.  .    ,   .      ,   . <br><br>  , ,    .        ‚Äî   -.    ,  , XOR  -  .   -.        -   -.      ,              -. <br><br>     , , crc32q.         ,        ,     -   ,       -   . <br><br>     ,        ClickHouse.            , ,   .       ClickHouse. <br><br><img src="https://habrastorage.org/webt/je/ki/1x/jeki1xaabpztoth-0ixuuq5abny.jpeg" width="700"><br><br>     .  ,    ‚Äî  ,   SHOW PROCESSLIST.   .    ,  SELECT * FROM system processes.       :  , ,   .     ClickHouse top. <br><br>     ClickHouse ?       background-. Background- ‚Äî    merges.   ,  merges ,    SELECT * FROM system.merges. <br><br><div class="spoiler"> <b class="spoiler_title"> c </b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/pb/gd/b3/pbgdb3f6o8qyvh6ez81heoo82tu.gif"><br></div></div><br> ,   .  -.    .  ‚Äî  ClickHouse.       .      ,  ,  . ,       . - traf_testing.  Was ist das?   ,       ,       .   ClickHouse  . <br><br><img src="https://habrastorage.org/webt/ni/aj/ro/niajrokowxcc2bp1n2ookwy8ljy.jpeg" width="700"><br><br>  .    ,      . ,    ,  ,    ,     .   query_log.        ‚Äî      ,   -    ,  SELECT ,    -  .   query_log     ,    .   -     .    ‚Äî    ,    .     :       . <br><br> ,  ,      ‚Äî merge, inserts,   .      part_log.      ,      . <br><br><img src="https://habrastorage.org/webt/lt/vn/cp/ltvncpwym4jc0qpjpofzygrb9qs.jpeg" width="700"><br><br>   query_log   clickhouse-benchmark.   select  ,    ,      stdin  clickhouse-benchmark. <br><br>     query_log  -   ,       . <br><br><img src="https://habrastorage.org/webt/zh/pm/tt/zhpmttv4oacr3fqnvanjwhrdsdg.jpeg" width="450"><br><br>       ,  ,   .     .     SET send_logs_level = 'trace',       ,    . <br><br><div class="spoiler"> <b class="spoiler_title">:  </b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/3z/l0/g9/3zl0g92l6zqdt7gxtqogm-wt-ai.gif"><br></div></div><br> ,   .  ,     98%.   ,       .  Es ist sehr einfach.  SET send_logs_level = 'trace',  ,    .  - : merging aggregated data,   .       1% .       ,    . <br><br>        ,   ,      query_log. <br><br>  . SELECT * FROM system.query_log    .  . ,   ,     ,      query_log. .      ‚Äî  ,    ,   ,       . . <br><br><img src="https://habrastorage.org/webt/6h/em/o3/6hemo3c8u8d4qv2bwxlt-xa0x_w.jpeg" width="470"><br><br>   ClickHouse   .   ‚Äî           system.events, system.metrics  system.asynchronous_metrics. Events ‚Äî    , ,     . 100 .          ‚Äî 10 .  system.metrics ‚Äî     . ,     10 ,     10  . <br><br>  system.asynchronous_metrics     ,     .  .          ‚Äî   .  , system.asynchronous_metrics ‚Äî  ,     - . ,   . <br><br>       ,     .      SHOW PROCESSLIST       .  query_log,        . <br><br><img src="https://habrastorage.org/webt/0p/cp/1r/0pcp1rjgl8aj4w29tcnj73n5eay.jpeg" width="520"><br><br> ,   .  ,    . ,   .   ,    ,       .   ,     Linux,   .    Linux    .     ,     .  ,    .      . <br><br> , OSReadChars  OSReadBytes.  Wie unterscheiden sie sich?  ,       ,        ,     .   ,        .   ,       ,         ,   .  ,   -      ,      . <br><br><div class="spoiler"> <b class="spoiler_title">  page cache</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ft/zd/z3/ftzdz3ycxppmbghwuxu108y3rcs.gif"><br></div></div><br> ,   .    - .  ,  40    , 6,7 . . ,     ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> . , , . <br><br>      ,    1,3 ,  5  .  Warum? ,     ‚Äî      page cache.         ? <br><br><div class="spoiler"> <b class="spoiler_title"> c  </b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/hr/cj/as/hrcjasfstnujjgo-fx9ene7t1g0.gif"><br></div></div><br>     .       . ,   ,        .   .     :     3,2 ,    ‚Äî 2,5 . , ,         ,   .  Warum? -, :  read ahead.        ,       ‚Äî  ? -,         ‚Äî 4  , , 512 KB.     .    ,     .   ,  - read ahead. <br><br><img src="https://habrastorage.org/webt/dj/nb/kj/djnbkjh9mdniw34_odlupzqigfa.jpeg" width="700"><br><br>      .      .     ,     . , , ReadBytes ‚Äî  ,     .  3 ,     3 .  ,   ,    . <br><br>    ‚Äî IOWait. 87 .    7 ,  IOWait ‚Äî 87. ?  ‚Äî    .     .   ,      ,     87 .       ,  - . <br><br>    ‚Äî CPUWait.     ,  ,       ,       .  -     ‚Äî ,   .      CPU.         CPU.      - ,    .        ‚Äî ,  ,   user space.    ,     - .  Na ja, okay. <br><br>  ‚Äî  ,    Linux.         - ,    .    , ,       . <br><br><div class="spoiler"> <b class="spoiler_title">: query_thread_log</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/fq/py/tf/fqpytfrrdsz4nxr8179r4pklzkm.gif"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und jetzt das Fortgeschrittenste, was wir haben: query_thread_log. </font><font style="vertical-align: inherit;">Damit k√∂nnen Sie verstehen, wof√ºr jeder Thread der Abfrageausf√ºhrung Zeit verschwendet hat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich suche nach meiner Anfrage, w√§hle sie mit query_id aus und gebe die Metrik "Die im Benutzerraum verbrachte Prozessorzeit" an. </font><font style="vertical-align: inherit;">Hier sind unsere Streams. </font><font style="vertical-align: inherit;">F√ºr die parallele Verarbeitung der Anfrage wurden 16 Threads zugewiesen. </font><font style="vertical-align: inherit;">Jeder von ihnen verbrachte 800 ms. </font><font style="vertical-align: inherit;">Und dann wurden weitere 16 Threads f√ºr die Zusammenf√ºhrung des Zustands der Aggregatfunktionen zugewiesen, f√ºr die jeweils 0,25 s aufgewendet wurden. </font><font style="vertical-align: inherit;">Jetzt kann ich genau verstehen, was jede Anfrage Zeit gekostet hat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Videobericht zu HighLoad ++:</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ondHe_JUyW4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459198/">https://habr.com/ru/post/de459198/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459182/index.html">GitLab: Mit der Ver√∂ffentlichung von Version 12.1 h√∂ren wir auf, MySQL zu unterst√ºtzen</a></li>
<li><a href="../de459184/index.html">Grundlegende Einheitsf√§higkeiten</a></li>
<li><a href="../de459188/index.html">Debian 10 Buster und Linux 5.2 ver√∂ffentlicht</a></li>
<li><a href="../de459194/index.html">Wie wir SCSS-Freunde mit CSS-Variablen mithilfe des UI-Kit-Themas gefunden haben</a></li>
<li><a href="../de459196/index.html">Von Monolithen zu modularen Teams</a></li>
<li><a href="../de459204/index.html">10 ++ M√∂glichkeiten, mit Hardwareregistern in C ++ zu arbeiten (z. B. IAR und Cortex M)</a></li>
<li><a href="../de459206/index.html">9 Jahre in einem Monolithen bei Node.JS</a></li>
<li><a href="../de459208/index.html">Laufen mit Prothesen: Nekstgen-Simulation der menschlichen Bewegung mit Muskeln, Knochen und einem neuronalen Netzwerk</a></li>
<li><a href="../de459212/index.html">Eigenschaftsimplementierung in C ++</a></li>
<li><a href="../de459214/index.html">Fehlertoleranz im Qsan-Speicher</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>