<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙊 🏴󠁧󠁢󠁳󠁣󠁴󠁿 🥧 Unicorn Engine的第一步 🦇 👩🏽‍🔬 🎅🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在Habr上搜索“ Unicorn Engine”时，我很惊讶地发现文章中从未使用过此工具。 我将尽力填补这一空白。 让我们从基础开始，然后看一个在现实生活中使用模拟器的示例。 为了不重蹈覆辙，我决定只翻译本手册。 在开始之前，我会说我的所有评论或评论将看起来像这样 。 
 什么是独角兽引擎？ 

...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unicorn Engine的第一步</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431058/"><p> 在Habr上搜索“ Unicorn Engine”时，我很惊讶地发现文章中从未使用过此工具。 我将尽力填补这一空白。 让我们从基础开始，然后看一个在现实生活中使用模拟器的示例。 为了不重蹈覆辙，我决定只翻译<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本</a>手册。  <em>在开始之前，我会说我的所有评论或评论将看起来像这样</em> 。 </p><a name="habracut"></a><br><h1 id="chto-takoe-unicorn-engine"> 什么是独角兽引擎？ </h1><br><p>  <em>开发人员自己写</em> <del>  <em>独角兽引擎</em> </del>  <em>独角兽引擎是这样的：</em> </p><br><blockquote>  Unicorn是一个轻量级，多平台和多体系结构的处理器仿真器。 </blockquote><p> 这不是标准的模拟器。 它不会模拟整个程序或整个OS的操作。 它不支持系统命令（例如打开文件，将字符输出到控制台等）。 您将必须对内存进行标记并将数据自己加载到其中，然后只需从某个特定地址开始执行即可。 </p><br><p> 那么它有什么用呢？ </p><br><ul><li> 分析病毒时，您可以调用单个功能，而无需创建恶意进程。 </li><li> 解决周大福。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">对于起毛</a> 。 </li><li>  <a href="">gdb的插件，</a>用于预测将来的状态，例如将来的跃点或寄存器值。 </li><li> 模拟功能丰富的代码。 </li></ul><br><p> 你需要什么 </p><br><ul><li> 已安装具有Python绑定的Unicorn Engine。 </li><li> 拆装机 </li></ul><br><h1 id="primer"> 例子 </h1><br><p> 例如，以名称为<strong><em>Fibonacci的</em></strong> hxp CTF 2017进行任务。 二进制文件可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>下载。 </p><br><p> 当您启动程序时，它将开始在控制台中显示我们的标志，但是速度非常慢。 每个后续标志字节被认为越来越慢。 </p><br><pre><code class="bash hljs">The flag is: hxp{F</code> </pre> <br><p> 这意味着为了在合理的时间内获取标志，我们需要优化此应用程序的操作。 </p><br><p> 使用IDA Pro（ <em>我个人使用radare2 + Cutter</em> ），我们将代码反编译为类似C的伪代码。 尽管代码未正确反编译，但我们仍然可以从中获取有关内部发生的信息。 </p><br><div class="spoiler">  <b class="spoiler_title">反编译的代码</b> <div class="spoiler_text"><pre> <code class="cpp hljs">__int64 __<span class="hljs-function"><span class="hljs-function">fastcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__int64 a1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **a2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **a3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *v3; <span class="hljs-comment"><span class="hljs-comment">// rbp@1 int v4; // ebx@1 signed __int64 v5; // r8@2 char v6; // r9@3 __int64 v7; // r8@3 char v8; // cl@3 __int64 v9; // r9@5 int a2a; // [sp+Ch] [bp-1Ch]@3 v3 = &amp;encrypted_flag; v4 = 0; setbuf(stdout, 0LL); printf("The flag is: ", 0LL); while ( 1 ) { LODWORD(v5) = 0; do { a2a = 0; fibonacci(v4 + v5, &amp;a2a); v8 = v7; v5 = v7 + 1; } while ( v5 != 8 ); v4 += 8; if ( (unsigned __int8)(a2a &lt;&lt; v8) == v6 ) break; v3 = (char *)v3 + 1; _IO_putc((char)(v6 ^ ((_BYTE)a2a &lt;&lt; v8)), stdout); v9 = *((char *)v3 - 1); } _IO_putc(10, stdout); return 0LL; }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __<span class="hljs-function"><span class="hljs-function">fastcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fibonacci</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, _DWORD *a2)</span></span></span><span class="hljs-function"> </span></span>{ _DWORD *v2; <span class="hljs-comment"><span class="hljs-comment">// rbp@1 unsigned int v3; // er12@3 unsigned int result; // eax@3 unsigned int v5; // edx@3 unsigned int v6; // esi@3 unsigned int v7; // edx@4 v2 = a2; if ( i ) { if ( i == 1 ) { result = fibonacci(0, a2); v5 = result - ((result &gt;&gt; 1) &amp; 0x55555555); v6 = ((result - ((result &gt;&gt; 1) &amp; 0x55555555)) &gt;&gt; 2) &amp; 0x33333333; } else { v3 = fibonacci(i - 2, a2); result = v3 + fibonacci(i - 1, a2); v5 = result - ((result &gt;&gt; 1) &amp; 0x55555555); v6 = ((result - ((result &gt;&gt; 1) &amp; 0x55555555)) &gt;&gt; 2) &amp; 0x33333333; } v7 = v6 + (v5 &amp; 0x33333333) + ((v6 + (v5 &amp; 0x33333333)) &gt;&gt; 4); *v2 ^= ((BYTE1(v7) &amp; 0xF) + (v7 &amp; 0xF) + (unsigned __int8)((((v7 &gt;&gt; 8) &amp; 0xF0F0F) + (v7 &amp; 0xF0F0F0F)) &gt;&gt; 16)) &amp; 1; } else { *a2 ^= 1u; result = 1; } return result; }</span></span></code> </pre> </div></div><br><p> 这是<em>main</em>和<em>fibonacci</em>函数的汇编代码： </p><br><div class="spoiler">  <b class="spoiler_title">主要的</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">.text:0x4004E0 main proc near ; DATA XREF: start+1Do .text:0x4004E0 .text:0x4004E0 var_1C = dword ptr -1Ch .text:0x4004E0 .text:0x4004E0 push rbp .text:0x4004E1 push rbx .text:0x4004E2 xor esi, esi ; buf .text:0x4004E4 mov ebp, offset unk_4007E1 .text:0x4004E9 xor ebx, ebx .text:0x4004EB sub rsp, 18h .text:0x4004EF mov rdi, cs:stdout ; stream .text:0x4004F6 call _setbuf .text:0x4004FB mov edi, offset format ; "The flag is: " .text:0x400500 xor eax, eax .text:0x400502 call _printf .text:0x400507 mov r9d, 49h .text:0x40050D nop dword ptr [rax] .text:0x400510 .text:0x400510 loc_400510: ; CODE XREF: main+8Aj .text:0x400510 xor r8d, r8d .text:0x400513 jmp short loc_40051B .text:0x400513 ; --------------------------------------------------------------------------- .text:0x400515 align 8 .text:0x400518 .text:0x400518 loc_400518: ; CODE XREF: main+67j .text:0x400518 mov r9d, edi .text:0x40051B .text:0x40051B loc_40051B: ; CODE XREF: main+33j .text:0x40051B lea edi, [rbx+r8] .text:0x40051F lea rsi, [rsp+28h+var_1C] .text:0x400524 mov [rsp+28h+var_1C], 0 .text:0x40052C call fibonacci .text:0x400531 mov edi, [rsp+28h+var_1C] .text:0x400535 mov ecx, r8d .text:0x400538 add r8, 1 .text:0x40053C shl edi, cl .text:0x40053E mov eax, edi .text:0x400540 xor edi, r9d .text:0x400543 cmp r8, 8 .text:0x400547 jnz short loc_400518 .text:0x400549 add ebx, 8 .text:0x40054C cmp al, r9b .text:0x40054F mov rsi, cs:stdout ; fp .text:0x400556 jz short loc_400570 .text:0x400558 movsx edi, dil ; c .text:0x40055C add rbp, 1 .text:0x400560 call __IO_putc .text:0x400565 movzx r9d, byte ptr [rbp-1] .text:0x40056A jmp short loc_400510 .text:0x40056A ; --------------------------------------------------------------------------- .text:0x40056C align 10h .text:0x400570 .text:0x400570 loc_400570: ; CODE XREF: main+76j .text:0x400570 mov edi, 0Ah ; c .text:0x400575 call __IO_putc .text:0x40057A add rsp, 18h .text:0x40057E xor eax, eax .text:0x400580 pop rbx .text:0x400581 pop rbp .text:0x400582 retn .text:0x400582 main endp</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">斐波那契</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">.text:0x400670 fibonacci proc near ; CODE XREF: main+4Cp .text:0x400670 ; fibonacci+19p ... .text:0x400670 test edi, edi .text:0x400672 push r12 .text:0x400674 push rbp .text:0x400675 mov rbp, rsi .text:0x400678 push rbx .text:0x400679 jz short loc_4006F8 .text:0x40067B cmp edi, 1 .text:0x40067E mov ebx, edi .text:0x400680 jz loc_400710 .text:0x400686 lea edi, [rdi-2] .text:0x400689 call fibonacci .text:0x40068E lea edi, [rbx-1] .text:0x400691 mov r12d, eax .text:0x400694 mov rsi, rbp .text:0x400697 call fibonacci .text:0x40069C add eax, r12d .text:0x40069F mov edx, eax .text:0x4006A1 mov ebx, eax .text:0x4006A3 shr edx, 1 .text:0x4006A5 and edx, 55555555h .text:0x4006AB sub ebx, edx .text:0x4006AD mov ecx, ebx .text:0x4006AF mov edx, ebx .text:0x4006B1 shr ecx, 2 .text:0x4006B4 and ecx, 33333333h .text:0x4006BA mov esi, ecx .text:0x4006BC .text:0x4006BC loc_4006BC: ; CODE XREF: fibonacci+C2j .text:0x4006BC and edx, 33333333h .text:0x4006C2 lea ecx, [rsi+rdx] .text:0x4006C5 mov edx, ecx .text:0x4006C7 shr edx, 4 .text:0x4006CA add edx, ecx .text:0x4006CC mov esi, edx .text:0x4006CE and edx, 0F0F0F0Fh .text:0x4006D4 shr esi, 8 .text:0x4006D7 and esi, 0F0F0Fh .text:0x4006DD lea ecx, [rsi+rdx] .text:0x4006E0 mov edx, ecx .text:0x4006E2 shr edx, 10h .text:0x4006E5 add edx, ecx .text:0x4006E7 and edx, 1 .text:0x4006EA xor [rbp+0], edx .text:0x4006ED pop rbx .text:0x4006EE pop rbp .text:0x4006EF pop r12 .text:0x4006F1 retn .text:0x4006F1 ; --------------------------------------------------------------------------- .text:0x4006F2 align 8 .text:0x4006F8 .text:0x4006F8 loc_4006F8: ; CODE XREF: fibonacci+9j .text:0x4006F8 mov edx, 1 .text:0x4006FD xor [rbp+0], edx .text:0x400700 mov eax, 1 .text:0x400705 pop rbx .text:0x400706 pop rbp .text:0x400707 pop r12 .text:0x400709 retn .text:0x400709 ; --------------------------------------------------------------------------- .text:0x40070A align 10h .text:0x400710 .text:0x400710 loc_400710: ; CODE XREF: fibonacci+10j .text:0x400710 xor edi, edi .text:0x400712 call fibonacci .text:0x400717 mov edx, eax .text:0x400719 mov edi, eax .text:0x40071B shr edx, 1 .text:0x40071D and edx, 55555555h .text:0x400723 sub edi, edx .text:0x400725 mov esi, edi .text:0x400727 mov edx, edi .text:0x400729 shr esi, 2 .text:0x40072C and esi, 33333333h .text:0x400732 jmp short loc_4006BC .text:0x400732 fibonacci endp</code> </pre> </div></div><br><p> 在这个阶段，我们有很多机会来解决这个问题。 例如，我们可以使用一种编程语言来还原代码并在那里进行优化，但是恢复代码的过程是非常困难的任务，在此期间我们可能会犯错误。 好吧，然后比较代码以发现错误通常是毫无价值的。 但是，如果使用Unicorn Engine，则可以跳过代码重建的阶段，从而避免了上述问题。 当然，我们可以使用frida或为gdb编写脚本来避免这些麻烦，但这并非如此。 </p><br><p> 在开始优化之前，我们将在Unicorn Engine中运行仿真而不更改程序。 只有成功启动后，我们才能继续进行优化。 </p><br><h2 id="shag-1-da-priydet-virtualizaciya"> 步骤1：让虚拟化来 </h2><br><p> 让我们创建fibonacci.py文件并将其保存在二进制文件旁边。 </p><br><p> 让我们从导入所需的库开始： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> unicorn <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> unicorn.x86_const <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> struct</code> </pre> <br><p> 第一行加载主要的二进制和基本Unicorn常数。 第二行加载两个x86和x86_64体系结构的常量。 </p><br><p> 接下来，添加一些必要的功能： </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(name) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f.read() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">u32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> struct.unpack(<span class="hljs-string"><span class="hljs-string">"I"</span></span>, data)[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> struct.pack(<span class="hljs-string"><span class="hljs-string">"I"</span></span>, num)</code> </pre> <br><p> 在这里，我们宣布了以后将需要的功能： </p><br><ul><li>  <strong>read</strong>只是返回文件的内容， </li><li>  <strong>u32</strong>采用LE编码的4字节字符串并将其转换为int， </li><li>  <strong>p32</strong>做相反的事情-它接受一个数字并将其转换为LE编码的4字节字符串。 </li></ul><br><p> 注意：如果已安装<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pwntools</a> ，则无需创建这些功能，只需导入它们： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pwn <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> *</code> </pre> <br><p> 因此，最后，让我们开始为x86_64体系结构初始化Unicorn Engine类： </p><br><pre> <code class="python hljs">mu = Uc (UC_ARCH_X86, UC_MODE_64)</code> </pre> <br><p> 在这里，我们使用以下参数调用<strong>Uc</strong>函数： </p><br><ul><li> 第一个参数是主要架构。 常量以<strong>UC_ARCH_开头</strong> ； </li><li> 第二个参数是体系结构的规范。 常量以<strong>UC_MODE_开头</strong> 。 </li></ul><br><p> 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">备忘单中</a>找到所有常量。 </p><br><p> 如我上面所写，要使用Unicorn Engine，我们需要手动初始化虚拟内存。 对于此示例，我们需要将代码和堆栈放在内存中的某个位置。 </p><br><p> 二进制文件的基址（Base addr）从0x400000开始。 让我们将堆栈放在0x0并为其分配1024 * 1024内存。 最有可能的是，我们不需要那么多的空间，但是仍然没有伤害。 </p><br><p> 我们可以通过调用<strong>mem_map</strong>方法来标记内存。 </p><br><p> 添加这些行： </p><br><pre> <code class="python hljs">BASE = <span class="hljs-number"><span class="hljs-number">0x400000</span></span> STACK_ADDR = <span class="hljs-number"><span class="hljs-number">0x0</span></span> STACK_SIZE = <span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span> mu.mem_map(BASE, <span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>) mu.mem_map(STACK_ADDR, STACK_SIZE)</code> </pre> <br><p> 现在，我们需要以与引导加载程序相同的方式将二进制文件加载到其主地址中。 之后，我们需要将<strong>RSP</strong>设置到堆栈的末尾。 </p><br><pre> <code class="python hljs">mu.mem_write(BASE, read(<span class="hljs-string"><span class="hljs-string">"./fibonacci"</span></span>)) mu.reg_write(UC_X86_REG_RSP, STACK_ADDR + STACK_SIZE - <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p> 现在我们可以开始仿真并运行代码，但是我们需要弄清楚开始使用哪个地址以及仿真器何时停止。 </p><br><p> 从<strong>main（）</strong>获取第一个命令的地址，我们可以从0x004004e0开始仿真。 显示整个标志后，将认为结尾是对位于0x00400575的<strong>putc（“ \ n”）</strong>的调用。 </p><br><pre> <code class="plaintext hljs">.text:0x400570 mov edi, 0Ah ; c .text:0x400575 call __IO_putc</code> </pre> <br><p> 我们可以开始模拟： </p><br><pre> <code class="python hljs">mu.emu_start(<span class="hljs-number"><span class="hljs-number">0x004004e0</span></span>,<span class="hljs-number"><span class="hljs-number">0x00400575</span></span>)</code> </pre> <br><p> 现在运行脚本： </p><br><pre> <code class="bash hljs">a@x:~/Desktop/unicorn_engine_lessons$ python solve.py Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"solve.py"</span></span>, line 32, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; mu.emu_start(0x00000000004004E0, 0x0000000000400575) File <span class="hljs-string"><span class="hljs-string">"/usr/local/lib/python2.7/dist-packages/unicorn/unicorn.py"</span></span>, line 288, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> emu_start raise UcError(status) unicorn.unicorn.UcError: Invalid memory <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> (UC_ERR_READ_UNMAPPED)</code> </pre> <br><p> 糟糕，出了点问题，但我们什至都不知道。 在调用<strong>mu.emu_start</strong>之前<strong>，</strong>我们可以添加： </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hook_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mu, address, size, user_data)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">'&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x'</span></span> %(address, size)) mu.hook_add(UC_HOOK_CODE, hook_code)</code> </pre> <br><p> 此代码添加了一个钩子。 我们声明了自己的<strong>hook_code</strong>函数，模拟器在每个命令之前调用该函数。 它采用以下参数： </p><br><ul><li> 我们的<strong>Uc</strong>副本， </li><li> 指令地址 </li><li> 尺寸说明 </li><li> 用户数据（我们可以将此值与可选参数一起<strong>传递</strong>给<strong>hook_add（）</strong> ）。 <br> 现在，如果我们运行脚本，我们应该看到以下输出： <br><pre> <code class="bash hljs">a@x:~/Desktop/unicorn_engine_lessons$ python solve.py &gt;&gt;&gt; Tracing instruction at 0x4004e0, instruction size = 0x1 &gt;&gt;&gt; Tracing instruction at 0x4004e1, instruction size = 0x1 &gt;&gt;&gt; Tracing instruction at 0x4004e2, instruction size = 0x2 &gt;&gt;&gt; Tracing instruction at 0x4004e4, instruction size = 0x5 &gt;&gt;&gt; Tracing instruction at 0x4004e9, instruction size = 0x2 &gt;&gt;&gt; Tracing instruction at 0x4004eb, instruction size = 0x4 &gt;&gt;&gt; Tracing instruction at 0x4004ef, instruction size = 0x7 Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"solve.py"</span></span>, line 41, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; mu.emu_start(0x00000000004004E0, 0x0000000000400575) File <span class="hljs-string"><span class="hljs-string">"/usr/local/lib/python2.7/dist-packages/unicorn/unicorn.py"</span></span>, line 288, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> emu_start raise UcError(status) unicorn.unicorn.UcError: Invalid memory <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> (UC_ERR_READ_UNMAPPED)</code> </pre> <br><p> 在发生错误的地址，我们可以理解我们的脚本无法处理此命令： <br></p><pre> <code class="plaintext hljs">.text:0x4004EF mov rdi, cs:stdout ; stream</code> </pre> <br><p> 该指令从地址0x601038中读取数据（您可以在IDA Pro中看到它）。 这是我们未标记的<strong>.bss</strong>部分。 如果不影响程序逻辑，我的解决方案就是简单地跳过所有有问题的指令。 <br> 以下是另一个有问题的说明： <br></p><pre> <code class="plaintext hljs">.text:0x4004F6 call _setbuf</code> </pre> <br><p> 我们无法使用glibc调用任何函数，因为我们没有在内存中加载glibc。 无论如何，我们不需要此命令，因此我们也可以跳过它。 <br> 这是要跳过的命令的完整列表： <br></p><pre> <code class="plaintext hljs">.text:0x4004EF mov rdi, cs:stdout ; stream .text:0x4004F6 call _setbuf .text:0x400502 call _printf .text:0x40054F mov rsi, cs:stdout ; fp</code> </pre> <br><p> 要跳过命令，我们需要使用以下指令重写<strong>RIP</strong> ： <br></p><pre> <code class="python hljs">mu.reg_write(UC_X86_REG_RIP, address+size)</code> </pre> <br><p> 现在<strong>hook_code</strong>应该看起来像这样： </p><br><p></p><br><pre> <code class="python hljs">instructions_skip_list = [<span class="hljs-number"><span class="hljs-number">0x004004ef</span></span>,<span class="hljs-number"><span class="hljs-number">0x004004f6</span></span>,<span class="hljs-number"><span class="hljs-number">0x00400502</span></span>,<span class="hljs-number"><span class="hljs-number">0x0040054f</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hook_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mu, address, size, user_data)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">'&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x'</span></span> %(address, size)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> address <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> instructions_skip_list: mu.reg_write(UC_X86_REG_RIP, address+size)</code> </pre> <br><p> 我们还需要对在逐字节控制台中显示标志的指令执行某些操作。 </p><br><pre> <code class="plaintext hljs">.text:0x400558 movsx edi, dil ; c .text:0x40055C add rbp, 1 .text:0x400560 call __IO_putc</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">__IO_putc</a>将字节输出作为第<strong>一个参数</strong> （这是<strong>RDI</strong>寄存器）。 </p><br><p> 我们可以直接从寄存器读取数据，将数据输出到控制台，并跳过这组指令。 更新后的<strong>hook_code</strong>如下所示： </p><br><pre> <code class="python hljs">instructions_skip_list = [<span class="hljs-number"><span class="hljs-number">0x004004ef</span></span>,<span class="hljs-number"><span class="hljs-number">0x004004f6</span></span>,<span class="hljs-number"><span class="hljs-number">0x00400502</span></span>,<span class="hljs-number"><span class="hljs-number">0x0040054f</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hook_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mu, address, size, user_data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#print('&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x' %(address, size)) if address in instructions_skip_list: mu.reg_write(UC_X86_REG_RIP, address+size) elif address == 0x400560: # c = mu.reg_read(UC_X86_REG_RDI) print(chr(c),end="") mu.reg_write(UC_X86_REG_RIP, address+size)</span></span></code> </pre> <br><p> 我们可以运行，它将全部运行，但是仍然很慢。 </p><br><h1 id="shag-2-uvelichim-skorost"> 步骤2：提高速度！ </h1><br><p> 让我们考虑一下提高工作速度。 为什么这个程序这么慢？ </p><br><p> 如果查看反编译的代码，将会看到<strong>main（）</strong>多次调用<strong>fibonacci（）</strong> ，而<strong>fibonacci（）</strong>是一个递归函数。 让我们仔细看一下这个函数；它接受并返回两个参数。 第一个返回值通过<strong>RAX</strong>寄存器传递，第二个返回值通过第二个参数传递给函数的链接返回。 如果我们更深入地研究<strong>main（）</strong>和<strong>fibonacci（）</strong>之间的关系，那么我们将看到第二个参数仅采用两个可能的值：0或1。如果仍然看不到，请运行<strong>gdb</strong>并将断点放在函数的开头<strong>fibonacci（）</strong> 。 </p><br><p> 为了优化算法的操作，我们可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">动态编程</a>来记住输入参数的返回值。 自己想想，第二个参数只能采用两个可能的值，所以我们要做的就是记住 <math> </math> $内联$ 2 *最大\ _OF \ _FIRST \ _ARGUMENT $内联$  蒸 </p><br><div class="spoiler">  <b class="spoiler_title">对于那些不了解的人</b> <div class="spoiler_text"><p>  <strong>fibonacci</strong>是一个递归函数，它计算下一个值作为前两个值的和。 在每一步中，她都会更加深入。 每次她重新开始时，都按照以前的方式进行操作，再加上一种新的含义。 </p><br><p> 一个例子： <br> 假设深度= 6，则： <strong>1 1 2 3 5 8</strong> 。 <br> 现在深度= 8，则： <strong>1 1 2 3 5 8</strong> 13 21。 </p><br><p> 我们可能只记得前6个成员是<strong>1 1 2 3 5 8</strong> ，当他们要求我们计数比我们记住的更多时，我们会记住我们所记的内容，只计算缺失的内容。 </p></div></div><br><p> 一旦<strong>RIP</strong>位于<strong>fibonacci（）</strong>的开头，我们就可以获取函数参数。 我们知道一个函数在退出函数时会返回结果。 由于我们不能一次使用两个参数，因此我们需要一个堆栈来返回参数。 当输入<strong>fibonacci（）时，</strong>我们需要将参数放在堆栈上，并在退出时将其提取。 要存储计数对，我们可以使用字典。 </p><br><p> 如何处理一对值？ </p><br><ul><li> 在函数的最开始，我们可以检查该对是否在我们已经知道的结果中： <br><ul><li> 如果有的话，我们可以退还这对。 我们只需要在<strong>RAX</strong>和链接的地址（第二个参数中）中编写返回值。 我们还分配了一个<strong>RIP</strong>地址以退出该功能。 我们无法在<strong>fibonacci（）中</strong>使用<strong>RET</strong> ，因为这些调用已被钩住，因此我们将从<strong>main（）中</strong>获取一些<strong>RET</strong> ； </li><li> 如果这些值不是，那么我们只需将它们添加到堆栈中。 </li></ul></li><li> 在退出函数之前，我们可以保存返回的对。 我们知道输入参数，因为我们可以从堆栈中读取它们。 </li></ul><br><div class="spoiler">  <b class="spoiler_title">此代码在此处显示。</b> <div class="spoiler_text"><pre> <code class="python hljs">FIBONACCI_ENTRY = <span class="hljs-number"><span class="hljs-number">0x00400670</span></span> FIBONACCI_END = [ <span class="hljs-number"><span class="hljs-number">0x004006f1</span></span>, <span class="hljs-number"><span class="hljs-number">0x00400709</span></span>] instructions_skip_list = [<span class="hljs-number"><span class="hljs-number">0x004004ef</span></span>,<span class="hljs-number"><span class="hljs-number">0x004004f6</span></span>,<span class="hljs-number"><span class="hljs-number">0x00400502</span></span>,<span class="hljs-number"><span class="hljs-number">0x0040054f</span></span>] <span class="hljs-comment"><span class="hljs-comment">#     stack = [] # ,       d = {} def hook_code(mu, address, size, user_data): if address in instructions_skip_list: mu.reg_write(UC_X86_REG_RIP, address+size) #      elif address == 0x400560: c = mu.reg_read(UC_X86_REG_RDI) print(chr(c),end="") mu.reg_write(UC_X86_REG_RIP, address+size) #     ? elif address == FIBONACCI_ENTRY: #     RDI arg0 = mu.reg_read(UC_X86_REG_RDI) #    () r_rsi = mu.reg_read(UC_X86_REG_RSI) #   ,    arg1 = u32(mu.mem_read(r_rsi, 4)) # ,    ? if (arg0,arg1) in d: (ret_rax, ret_ref) = d[(arg0,arg1)] #     RAX mu.reg_write(UC_X86_REG_RAX, ret_rax) #     mu.mem_write(r_rsi, p32(ret_ref)) #  RIP  RET ,       fibonacci mu.reg_write(UC_X86_REG_RIP, 0x400582) else: #      ,      stack.append((arg0,arg1,r_rsi)) elif address in FIBONACCI_END: #     (arg0, arg1, r_rsi) = stack.pop() #     RAX ret_rax = mu.reg_read(UC_X86_REG_RAX) #  ,      ret_ref = u32(mu.mem_read(r_rsi,4)) #      d[(arg0, arg1)]=(ret_rax, ret_ref)</span></span></code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">这是整个脚本</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python # -*- coding: utf-8 -*- from __future__ import print_function from unicorn import * from unicorn.x86_const import * import struct def read(name): with open(name) as f: return f.read() def u32(data): return struct.unpack("I", data)[0] def p32(num): return struct.pack("I", num) FIBONACCI_ENTRY = 0x00400670 FIBONACCI_END = [ 0x004006f1, 0x00400709] instructions_skip_list = [0x004004ef,0x004004f6,0x00400502,0x0040054f] #     stack = [] # ,       d = {} def hook_code(mu, address, size, user_data): if address in instructions_skip_list: mu.reg_write(UC_X86_REG_RIP, address+size) #      elif address == 0x400560: c = mu.reg_read(UC_X86_REG_RDI) print(chr(c),end="") mu.reg_write(UC_X86_REG_RIP, address+size) #     ? elif address == FIBONACCI_ENTRY: #     RDI arg0 = mu.reg_read(UC_X86_REG_RDI) #    () r_rsi = mu.reg_read(UC_X86_REG_RSI) #   ,    arg1 = u32(mu.mem_read(r_rsi, 4)) # ,    ? if (arg0,arg1) in d: (ret_rax, ret_ref) = d[(arg0,arg1)] #     RAX mu.reg_write(UC_X86_REG_RAX, ret_rax) #     mu.mem_write(r_rsi, p32(ret_ref)) #  RIP  RET .     fibonacci mu.reg_write(UC_X86_REG_RIP, 0x400582) else: #      ,      stack.append((arg0,arg1,r_rsi)) elif address in FIBONACCI_END: #     (arg0, arg1, r_rsi) = stack.pop() #     RAX ret_rax = mu.reg_read(UC_X86_REG_RAX) #  ,      ret_ref = u32(mu.mem_read(r_rsi,4)) #      d[(arg0, arg1)]=(ret_rax, ret_ref) mu = Uc (UC_ARCH_X86, UC_MODE_64) BASE = 0x400000 STACK_ADDR = 0x0 STACK_SIZE = 1024*1024 mu.mem_map(BASE, 1024*1024) mu.mem_map(STACK_ADDR, STACK_SIZE) mu.mem_write(BASE, read("./fibonacci")) mu.reg_write(UC_X86_REG_RSP, STACK_ADDR + STACK_SIZE - 1) mu.hook_add(UC_HOOK_CODE, hook_code) mu.emu_start(0x004004e0, 0x00400575) print()</span></span></code> </pre></div></div><br><p>  Hooray，我们终于能够使用Unicorn Engine优化应用程序。 干得好！ </p><br><h1 id="zametka"> 笔记 </h1><br><p> 现在我决定给你一点功课。 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里您可以找到另外</a>三个任务，每个任务都有提示和完整的解决方案。 解决问题时，您可以查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">备忘单</a> 。 </p><br><p> 最烦人的问题之一是记住所需常量的名称。 如果在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">IPython中</a>使用Tab插件，这很容易处理。 安装IPython后，您可以<strong>从unicorn import UC_ARCH_</strong>编写<strong>，</strong>按Tab键，将<strong>显示</strong>以相同方式启动的所有常量。 </p><p></p><p></p><p></p></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN431058/">https://habr.com/ru/post/zh-CN431058/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN431044/index.html">检察官办公室将首次为非法阻止该网站付款</a></li>
<li><a href="../zh-CN431046/index.html">Z-index实际如何工作</a></li>
<li><a href="../zh-CN431048/index.html">事件机器守护生命周期</a></li>
<li><a href="../zh-CN431050/index.html">纯净的幻觉：水的矿化是否会影响其质量，TDS计将如何帮助我们？</a></li>
<li><a href="../zh-CN431052/index.html">前端开发日：地图，团队，两个查询</a></li>
<li><a href="../zh-CN431060/index.html">在德国通过在线身份验证和难民融资进行的德国身份证欺骗</a></li>
<li><a href="../zh-CN431064/index.html">刚性程序员宣言</a></li>
<li><a href="../zh-CN431066/index.html">DEFCON 16.我怎么能抓住你？ 让我列出方法。 第二部分</a></li>
<li><a href="../zh-CN431068/index.html">教育的艺术：老虎机的思想</a></li>
<li><a href="../zh-CN431070/index.html">原吃吗 我们正在谈论现代IT专家的饮食习惯</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>