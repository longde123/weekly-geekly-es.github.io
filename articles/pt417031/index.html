<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§úüèª ü§õüèø üë©üèæ Seguran√ßa do Mobile OAuth 2.0 üåº üèÆ üëçüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° pessoal! Sou Nikita Stupin, especialista em seguran√ßa da informa√ß√£o, Mail.Ru Mail. H√° pouco tempo, conduzi uma pesquisa de vulnerabilidade no OAut...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Seguran√ßa do Mobile OAuth 2.0</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/417031/"><img src="https://habrastorage.org/getpro/habr/post_images/205/605/cd5/205605cd5b166f65aa8085fe1606779f.jpg"><br><br>  Ol√° pessoal!  Sou Nikita Stupin, especialista em seguran√ßa da informa√ß√£o, Mail.Ru Mail.  H√° pouco tempo, conduzi uma pesquisa de vulnerabilidade no OAuth 2.0 para dispositivos m√≥veis.  Para criar um esquema OAuth 2.0 m√≥vel seguro, n√£o basta implementar o padr√£o em sua forma pura e verificar redirect_uri.  √â necess√°rio levar em considera√ß√£o as especificidades dos aplicativos m√≥veis e aplicar mecanismos de prote√ß√£o adicionais. <br><br>  Neste artigo, quero compartilhar com voc√™ conhecimentos sobre ataques ao OAuth 2.0 para celular, sobre m√©todos de prote√ß√£o e a implementa√ß√£o segura deste protocolo.  Todos os componentes de prote√ß√£o necess√°rios, discutidos abaixo, s√£o implementados no SDK mais recente para os clientes m√≥veis do Mail.Ru Mail. <br><a name="habracut"></a><br><h1>  A natureza e fun√ß√£o do OAuth 2.0 </h1><br>  OAuth 2.0 √© um protocolo de autoriza√ß√£o que descreve como √© seguro para um servi√ßo de cliente acessar recursos do usu√°rio em um provedor de servi√ßos.  Ao mesmo tempo, o OAuth 2.0 evita que o usu√°rio digite uma senha fora do provedor de servi√ßos: todo o processo √© reduzido ao clicar no bot√£o "Concordo em conceder acesso a ...". <br><br>  Um provedor em termos de OAuth 2.0 √© um servi√ßo que possui dados do usu√°rio e, com a permiss√£o do usu√°rio, fornece servi√ßos de terceiros (clientes) com acesso seguro a esses dados.  Um cliente √© um aplicativo que deseja receber dados do usu√°rio de um provedor. <br><br>  Algum tempo ap√≥s o lan√ßamento do protocolo OAuth 2.0, os desenvolvedores comuns o adaptaram para autentica√ß√£o, embora n√£o tenha sido originalmente planejado para isso.  A autentica√ß√£o muda o vetor de ataque dos dados do usu√°rio armazenados no provedor de servi√ßos para as contas de usu√°rio do servi√ßo do usu√°rio. <br><br>  N√£o foi limitado apenas √† autentica√ß√£o.  Na era dos aplicativos m√≥veis e na exalta√ß√£o da convers√£o, entrar no aplicativo com um √∫nico bot√£o se tornou muito tentador.  Os desenvolvedores colocam o OAuth 2.0 nos trilhos m√≥veis.  Naturalmente, poucas pessoas pensaram na seguran√ßa e nas especificidades dos aplicativos m√≥veis: uma e outra vez e na produ√ß√£o.  No entanto, o OAuth 2.0 geralmente n√£o funciona bem fora dos aplicativos da Web: os mesmos problemas s√£o observados nos aplicativos m√≥veis e de desktop. <br><br>  Vamos descobrir como criar um OAuth 2.0 m√≥vel seguro. <br><br><h1>  Como isso funciona? </h1><br>  Lembre-se de que em dispositivos m√≥veis, o cliente pode n√£o ser um navegador, mas um aplicativo m√≥vel sem back-end.  Portanto, enfrentamos dois grandes problemas de seguran√ßa no OAuth 2.0 para celular: <br><br><ol><li>  O cliente n√£o √© confi√°vel. </li><li>  O comportamento de um redirecionamento de um navegador para um aplicativo m√≥vel depende das configura√ß√µes e aplicativos que o usu√°rio instalou. </li></ol><br><h4>  Aplicativo m√≥vel √© um cliente p√∫blico </h4><br>  Para entender a raiz do primeiro problema, vamos ver como o OAuth 2.0 funciona no caso de intera√ß√£o servidor para servidor e, em seguida, compar√°-lo com o OAuth 2.0 no caso de intera√ß√£o cliente-servidor. <br><br>  Nos dois casos, tudo come√ßa com o fato de o cliente do servi√ßo se registrar no provedor de servi√ßos e receber <code>client_id</code> e, em alguns casos, <code>client_secret</code> .  O valor <code>client_id</code> √© p√∫blico e √© necess√°rio para identificar o servi√ßo do cliente, diferentemente do <code>client_secret</code> , cujo valor √© privado.  O processo de registro √© descrito em mais detalhes na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RFC 7591</a> . <br><br>  O diagrama abaixo mostra a opera√ß√£o do OAuth 2.0 na comunica√ß√£o entre servidores. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f06/279/e8a/f06279e8ac68f2fe664362caec6fa063.png"><br>  <i>Imagem retirada de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://tools.ietf.org/html/rfc6749#section-1.2</a></i> <br><br>  Existem tr√™s est√°gios principais do protocolo OAuth 2.0: <br><br><ol><li>  [Etapas AC] Obtenha o c√≥digo de autoriza√ß√£o (a seguir, simplesmente <code>code</code> ). </li><li>  [DE passos] Trocar <code>code</code> para <code>access_token</code> . </li><li>  Acesse o recurso usando <code>access_token</code> . </li></ol><br>  Analisaremos o recebimento do c√≥digo em mais detalhes: <br><br><ol><li>  [Etapa A] O cliente do servi√ßo redireciona o usu√°rio ao provedor de servi√ßos. </li><li>  [Etapa B] O provedor de servi√ßos solicita permiss√£o do usu√°rio para fornecer dados ao servi√ßo ao cliente (seta B para cima).  O usu√°rio fornece acesso aos dados (seta B √† direita). </li><li>  [Etapa C] O provedor de servi√ßos retorna o <code>code</code> para o navegador do usu√°rio, que redireciona o <code>code</code> o servi√ßo ao cliente. </li></ol><br>  Vamos <code>access_token</code> como <code>access_token</code> mais detalhes: <br><br><ol><li>  [Etapa D] O servidor do cliente envia uma solicita√ß√£o para <code>access_token</code> .  A solicita√ß√£o inclui: <code>code</code> , <code>client_secret</code> e <code>redirect_uri</code> . </li><li>  [Etapa E] No caso de <code>code</code> v√°lido, <code>client_secret</code> e <code>redirect_uri</code> , <code>client_secret</code> fornecido. </li></ol><br>  A solicita√ß√£o para <code>access_token</code> √© realizada de acordo com o esquema servidor para servidor; portanto, em geral, para roubar <code>client_secret</code> invasor deve invadir o servidor servidor-cliente ou o servidor do provedor de servi√ßos. <br><br>  Agora vamos ver como √© o esquema do OAuth 2.0 em um dispositivo m√≥vel sem back-end (intera√ß√£o cliente-servidor). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7cb/9fb/b7d/7cb9fbb7dcc35c74e921f18d22584254.png"><br>  <i>Imagem retirada de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://tools.ietf.org/html/rfc8252#section-4.1</a></i> <br><br>  O esquema geral √© dividido nas mesmas tr√™s etapas principais: <br><br><ol><li>  [etapas 1 a 4 da figura] Obtenha o <code>code</code> . </li><li>  [etapas 5 a 6 da figura] Troque o <code>code</code> por <code>access_token</code> . </li><li>  Acesse o recurso usando <code>access_token</code> . </li></ol><br>  No entanto, nesse caso, o aplicativo m√≥vel tamb√©m atua como um servidor, o que significa que o <code>client_secret</code> ser√° <code>client_secret</code> dentro do aplicativo.  Isso leva ao fato de que em dispositivos m√≥veis √© imposs√≠vel manter o <code>lient_secret</code> segredo de um invasor.  <code>client_secret</code> duas maneiras de <code>client_secret</code> ao aplicativo: para filtrar o tr√°fego do aplicativo para o servidor ou fazer a engenharia reversa do aplicativo.  Ambos os m√©todos s√£o f√°ceis de implementar, portanto, <code>client_secret</code> in√∫til em dispositivos m√≥veis. <br><br>  Em rela√ß√£o ao esquema cliente para servidor, voc√™ pode ter uma pergunta: "por que n√£o obter imediatamente o <code>access_token</code> ?".  Parece, por que precisamos de uma etapa extra?  Al√©m disso, existe um esquema de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">concess√£o impl√≠cita</a> no qual o cliente recebe imediatamente um <code>access_token</code> .  Embora possa ser usado em alguns casos, veremos abaixo que a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">concess√£o impl√≠cita</a> n√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√©</a> adequada para o OAuth 2.0 m√≥vel seguro. <br><br><h4>  Redirecionar em dispositivos m√≥veis </h4><br>  Em geral, para um redirecionamento de um navegador para um aplicativo em dispositivos m√≥veis, os mecanismos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Custom URI Scheme</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AppLink</a> s√£o usados.  Nenhum desses mecanismos em sua forma pura √© t√£o confi√°vel quanto um redirecionamento de navegador. <br><br>  O esquema de URI personalizado (ou link direto) √© usado da seguinte maneira: o desenvolvedor define o esquema de aplicativo antes da montagem.  O esquema pode ser arbitr√°rio, enquanto no mesmo dispositivo v√°rios aplicativos com o mesmo esquema podem ser instalados.  Tudo √© bem simples quando cada aplicativo no dispositivo corresponde a um aplicativo.  Mas e se dois aplicativos registrassem o mesmo circuito no mesmo dispositivo?  Como o sistema operacional pode determinar qual dos dois aplicativos abrir ao acessar o esquema de URI personalizado?  O Android mostrar√° uma janela com a op√ß√£o de aplicativo na qual voc√™ deseja abrir um link.  No iOS, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">comportamento n√£o est√° definido</a> , o que significa que qualquer um dos dois aplicativos pode ser aberto.  Nos dois casos, um invasor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pode interceptar c√≥digo ou access_token</a> . <br><br>  O AppLink, ao contr√°rio do Esquema URI personalizado, √© garantido para abrir o aplicativo certo, mas esse mecanismo tem v√°rias desvantagens: <br><br><ol><li>  Cada cliente de servi√ßo deve passar independentemente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no procedimento de verifica√ß√£o</a> . </li><li>  Os usu√°rios do Android podem desativar o AppLink para um aplicativo espec√≠fico nas configura√ß√µes. </li><li>  O Android abaixo de 6.0 e o iOS abaixo de 9.0 n√£o s√£o compat√≠veis com o AppLink. </li></ol><br>  As desvantagens acima do AppLink, em primeiro lugar, aumentam o limite de entrada para servi√ßos potenciais de clientes e, em segundo lugar, podem levar ao fato de que, em determinadas circunst√¢ncias, o usu√°rio n√£o trabalha com o OAuth 2.0.  Isso torna o AppLink inadequado para substituir os redirecionamentos do navegador no protocolo OAuth 2.0. <br><br><h1>  Ok, o que atacar? </h1><br>  Os problemas do OAuth 2.0 para dispositivos m√≥veis tamb√©m deram origem a ataques espec√≠ficos.  Vamos ver o que s√£o e como funcionam. <br><br><a name="1"></a><h4>  Ataque de intercepta√ß√£o de c√≥digo de autoriza√ß√£o </h4><br>  Dados iniciais: um aplicativo leg√≠timo (cliente OAuth 2.0) e um aplicativo mal-intencionado que registrou o mesmo esquema que o leg√≠timo s√£o instalados no dispositivo do usu√°rio.  A figura abaixo mostra o esquema de ataque. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a87/336/d4c/a87336d4c0d73c89a62bb448cb12d49b.png"><br>  <i>Imagem retirada de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://tools.ietf.org/html/rfc7636#section-1</a></i> <br><br>  Aqui est√° o problema: na etapa 4, o navegador retorna o <code>code</code> ao aplicativo por meio do Esquema URI personalizado, para que o <code>code</code> possa ser interceptado pelo malware (porque registrou o mesmo esquema do aplicativo leg√≠timo).  Depois disso, o malware altera o <code>code</code> para <code>access_token</code> e obt√©m acesso aos dados do usu√°rio. <br><br>  Como se proteger?  Em alguns casos, mecanismos de comunica√ß√£o entre processos podem ser usados; falaremos sobre eles abaixo.  No caso geral, voc√™ precisa aplicar um esquema chamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Proof Key for Code Exchange</a> .  Sua ess√™ncia √© refletida no diagrama abaixo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/123/67e/349/12367e3497cbbd54d007a18a678bfc0d.png"><br>  <i>Imagem retirada de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://tools.ietf.org/html/rfc7636#section-1.1</a></i> <br><br>  Nas solicita√ß√µes do cliente, existem v√°rios par√¢metros adicionais: <code>code_verifier</code> , <code>code_challenge</code> (no <code>t(code_verifier)</code> ) e <code>code_challenge_method</code> (no diagrama <code>t_m</code> ). <br><br>  <code>Code_verifier</code> √© um n√∫mero aleat√≥rio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">de pelo menos 256 bits</a> que √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">usado apenas uma vez</a> .  Ou seja, para <b>cada</b> solicita√ß√£o de <code>code</code> cliente deve gerar um novo <code>code_verifier</code> . <br><br>  <code>Code_challenge_method</code> √© o nome de uma fun√ß√£o de convers√£o, na maioria das vezes SHA-256. <br><br>  <code>Code_challenge</code> √© um <code>code_verifier</code> ao qual a convers√£o <code>code_challenge_method</code> foi <code>code_challenge_method</code> e codificada na URL Safe Base64. <br><br>  A convers√£o de <code>code_verifier</code> em <code>code_challenge</code> necess√°ria para proteger contra vetores de ataque com base na intercepta√ß√£o de <code>code_verifier</code> (por exemplo, nos logs do sistema do dispositivo) ao solicitar <code>code</code> . <br><br>  Se o dispositivo do usu√°rio <b>n√£o suportar</b> SHA-256, um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">downgrade ser√° permitido at√© que a convers√£o do code_verifier esteja ausente</a> .  Em todos os outros casos, voc√™ deve usar o SHA-256. <br><br>  O esquema funciona da seguinte maneira: <br><br><ol><li>  O cliente gera um <code>code_verifier</code> e se lembra dele. </li><li>  O cliente seleciona <code>code_challenge_method</code> e obt√©m <code>code_challenge</code> no <code>code_verifier</code> . </li><li>  [Etapa A] O cliente solicita <code>code</code> , com <code>code_challenge</code> e <code>code_challenge_method</code> adicionados √† solicita√ß√£o. </li><li>  [Etapa B] O provedor se lembra do <code>code_challenge</code> e <code>code_challenge_method</code> no servidor e retorna o <code>code</code> cliente. </li><li>  [Etapa C] O cliente solicita o <code>access_token</code> , com o <code>access_token</code> sendo adicionado √† <code>code_verifier</code> . </li><li>  O provedor recebe o <code>code_challenge</code> do <code>code_challenge</code> recebido e depois o verifica no <code>code_challenge</code> , do qual ele se lembrava. </li><li>  [Etapa D] Se os valores corresponderem, o provedor emitir√° um <code>access_token</code> cliente. </li></ol><br>  Vamos <code>code_challenge</code> por que <code>code_challenge</code> permite que <code>code_challenge</code> se proteja de um ataque de intercepta√ß√£o de c√≥digo.  Para fazer isso, passaremos pelas etapas de obten√ß√£o do <code>access_token</code> . <br><br><ol><li>  Primeiro, um aplicativo leg√≠timo solicita o <code>code</code> ( <code>code_challenge</code> e <code>code_challenge_method</code> enviados junto com a <b>solicita√ß√£o</b> ). </li><li>  O malware intercepta o <code>code</code> (mas n√£o o <code>code_challenge</code> , porque n√£o h√° <code>code_challenge</code> <b>na resposta</b> ). </li><li>  O malware solicita <code>access_token</code> (com <code>code</code> v√°lido, mas <b>sem</b> <code>code_verifier</code> v√°lido). </li><li>  O servidor percebe a incompatibilidade <code>code_challenge</code> e gera um erro. </li></ol><br>  Observe que o invasor n√£o tem a capacidade de adivinhar o <code>code_verifier</code> (aleat√≥rio 256 bits!) Ou encontre-o em algum lugar nos logs ( <code>code_verifier</code> √© transmitido uma vez). <br><br>  Se tudo isso for reduzido a uma frase, o <code>code_challenge</code> permitir√° que o provedor de servi√ßos responda √† pergunta: ‚Äúo <code>access_token</code> est√° <code>access_token</code> solicitado pelo mesmo aplicativo cliente que solicitou o <code>code</code> ou por outro?‚Äù. <br><br><h4>  CSRF do OAuth 2.0 </h4><br>  Em dispositivos m√≥veis, o OAuth 2.0 √© frequentemente usado como um mecanismo de autentica√ß√£o.  Como lembramos, a autentica√ß√£o por meio do OAuth 2.0 difere da autoriza√ß√£o, pois as vulnerabilidades do OAuth 2.0 afetam os dados do usu√°rio no lado do cliente de servi√ßo, e n√£o o provedor de servi√ßos.  Como resultado, o ataque do CSRF ao OAuth 2.0 permite que voc√™ roube a conta de outra pessoa. <br><br>  Considere um ataque de CSRF contra o OAuth 2.0 usando o exemplo do aplicativo cliente de t√°xi e do provedor provider.com.  Primeiro, um invasor faz logon no attacker@provider.com em seu dispositivo e recebe um <code>code</code> para o t√°xi.  Depois disso, o invasor interrompe o processo do OAuth 2.0 e gera um link: <br><br> <code>com.taxi.app://oauth? <br> code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4 <br></code> <br>  Em seguida, o atacante envia um link para a v√≠tima, por exemplo, sob o disfarce de uma carta ou SMS da administra√ß√£o do t√°xi.  A v√≠tima <code>access_token</code> link, um aplicativo de t√°xi √© aberto no telefone, que recebe <code>access_token</code> e, como resultado, a v√≠tima acaba na conta de t√°xi do <b>atacante</b> .  Desconhecendo a captura, a v√≠tima usa esta conta: faz viagens, insere seus dados, etc. <br><br>  Agora, um invasor pode fazer login na conta de t√°xi da v√≠tima a qualquer momento, porque est√° vinculado a <code>attacker@provider.com</code> .  O ataque CSRF no login permitiu roubar uma conta. <br><br>  Os ataques de CSRF geralmente s√£o protegidos com um token de CSRF (tamb√©m chamado de <code>state</code> ), e o OAuth 2.0 n√£o √© uma exce√ß√£o.  Como usar o token CSRF: <br><br><ol><li>  O aplicativo cliente gera e armazena o token CSRF no dispositivo m√≥vel do usu√°rio. </li><li>  O aplicativo cliente inclui o token CSRF na solicita√ß√£o de <code>code</code> . </li><li>  O servidor retorna o mesmo token CSRF na resposta junto com o c√≥digo. </li><li>  O aplicativo cliente compara o token CSRF recebido e armazenado.  Se os valores corresponderem, o processo continuar√°. </li></ol><br>  Requisitos de token CSRF: com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">exce√ß√£o de</a> pelo menos 256 bits, obtidos de uma boa fonte de sequ√™ncias pseudo-aleat√≥rias. <br><br>  Em resumo, o token CSRF permite que o aplicativo cliente responda √† pergunta: "eu estava come√ßando a obter <code>access_token</code> , ou algu√©m est√° tentando me enganar?" <br><br><h4>  Malware que finge ser um cliente leg√≠timo </h4><br>  Alguns malwares podem imitar aplicativos leg√≠timos e gerar uma tela de consentimento em seu nome (tela de consentimento √© uma tela na qual o usu√°rio v√™: "Concordo em conceder acesso a ...").  O usu√°rio desatento pode clicar em "permitir" e, como resultado, o malware obt√©m acesso aos dados do usu√°rio. <br><br>  Android e iOS fornecem mecanismos para verifica√ß√£o m√∫tua de aplicativos.  O aplicativo provedor pode verificar a legitimidade do aplicativo cliente e vice-versa. <br><br>  Infelizmente, se o mecanismo OAuth 2.0 usar um fluxo por meio de um navegador, voc√™ n√£o poder√° se defender contra esse ataque. <br><br><h4>  Outros ataques </h4><br>  Examinamos os ataques exclusivos do OAuth 2.0 para celular.  No entanto, n√£o se esque√ßa dos ataques ao OAuth 2.0 regular: falsifica√ß√£o de <code>redirect_uri</code> , intercepta√ß√£o de tr√°fego em uma conex√£o insegura etc.  Voc√™ pode ler mais sobre eles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br><h1>  O que fazer? </h1><br>  Aprendemos como o protocolo OAuth 2.0 funciona e descobrimos quais vulnerabilidades existem nas implementa√ß√µes desse protocolo em dispositivos m√≥veis.  Agora vamos montar um esquema OAuth 2.0 m√≥vel seguro de pe√ßas individuais. <br><br><h4>  Bom, ruim OAuth 2.0 </h4><br>  Vamos come√ßar com como aumentar corretamente a tela de consentimento.  Em dispositivos m√≥veis, existem duas maneiras de abrir uma p√°gina da Web a partir de um aplicativo nativo (exemplos de aplicativos nativos: Mail.Ru Mail, VK, Facebook). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ee/bd1/d02/7eebd1d02b5fa11a820fe37abbd1c552.png"><br><br>  O primeiro m√©todo √© chamado de Aba personalizada do navegador (na figura √† esquerda).  <b>Nota</b> : a guia Personalizada do navegador no Android chama-se Guia personalizada do Chrome e no iOS SafariViewController.  Na verdade, essa √© uma guia normal do navegador, exibida diretamente no aplicativo, ou seja,  N√£o h√° altern√¢ncia visual entre aplicativos. <br><br>  O segundo m√©todo √© chamado ‚Äúraise WebView‚Äù (na imagem √† direita), em rela√ß√£o ao OAuth 2.0 para dispositivos m√≥veis, considero ruim. <br><br>  O WebView √© um navegador independente para um aplicativo nativo. <br><br>  <i>Um</i> " <i>navegador</i> independente" significa que o WebView n√£o permite acesso a cookies, armazenamento, cache, hist√≥rico e outros dados dos navegadores Safari e Chrome.  O inverso tamb√©m √© verdadeiro: o Safari e o Chrome n√£o podem acessar os dados do WebView. <br><br>  ‚Äú <i>Navegador para um aplicativo nativo</i> ‚Äù significa que o aplicativo nativo que criou o WebView tem acesso <b>total</b> a cookies, armazenamento, cache, hist√≥rico e outros dados do WebView. <br><br>  Agora imagine: o usu√°rio pressiona o bot√£o "fazer login usando ..." e o WebView do aplicativo malicioso solicita seu nome de usu√°rio e senha ao provedor de servi√ßos. <br><br>  Falha ao mesmo tempo em todas as frentes: <br><br><ol><li>  O usu√°rio digita o nome de usu√°rio e a senha da conta do provedor de servi√ßos no aplicativo, o que pode facilmente roubar esses dados. </li><li>  O OAuth 2.0 foi desenvolvido originalmente para <i>n√£o inserir um nome de usu√°rio e senha</i> de um provedor de servi√ßos. </li><li>  O usu√°rio se acostuma a digitar o login e a senha em qualquer lugar, a probabilidade de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">phishing</a> aumenta. <br></li></ol><br>  Dado que todos os argumentos s√£o contra o WebView, a conclus√£o sugere-se: aumente a guia Personaliza√ß√£o do navegador para obter a tela de consentimento. <br><br>  Se algum de voc√™s tiver argumentos a favor do WebView em vez da guia Personalizada do navegador, escreva sobre isso nos coment√°rios, ficarei muito agradecido. <br><br><h4>  Esquema do Secure Mobile OAuth 2.0 </h4><br>  Usaremos o esquema de concess√£o de c√≥digo de autoriza√ß√£o porque ele nos permite adicionar um <code>code_challenge</code> e <code>code_challenge</code> proteger de um ataque de intercepta√ß√£o de c√≥digo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7cb/9fb/b7d/7cb9fbb7dcc35c74e921f18d22584254.png"><br>  <i>Imagem retirada de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://tools.ietf.org/html/rfc8252#section-4.1</a></i> <br><br>  A solicita√ß√£o de c√≥digo (etapas 1-2) ter√° a seguinte apar√™ncia: <br><br> <code>https://o2.mail.ru/code? <br> redirect_uri=com.mail.cloud.app%3A%2F%2Foauth&amp; <br> anti_csrf=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24&amp; code_challenge=ZjYxNzQ4ZjI4YjdkNWRmZjg4MWQ1N2FkZjQzNGVkODE1YTRhNjViNjJjMGY5MGJjNzdiOGEzMDU2ZjE3NGFiYw%3D%3D&amp; <br> code_challenge_method=S256&amp; <br> scope=email%2Cid&amp; <br> response_type=code&amp; <br> client_id=984a644ec3b56d32b0404777e1eb73390c <br></code> <br>  Na etapa 3, o navegador recebe uma resposta redirecionada: <br><br> <code>com.mail.cloud.app://outh? <br> code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4&amp; <br> anti_csrf=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24</code> <br> <br>  Na etapa 4, o navegador abre o esquema de URI personalizado e passa o <code>code</code> e o token CSRF para o aplicativo cliente. <br><br>  Solicita√ß√£o de <code>access_token</code> (etapa 5): <br><br> <code>https://o2.mail.ru/token? <br> code_verifier=e61748f28b7d5daf881d571df434ed815a4a65b62c0f90bc77b8a3056f174abc&amp; <br> code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4&amp; <br> client_id=984a644ec3b56d32b0404777e1eb73390c <br></code> <br>  A √∫ltima etapa retorna uma resposta com <code>access_token</code> . <br><br>  Em geral, o esquema acima √© seguro, mas tamb√©m h√° casos especiais em que o OAuth 2.0 pode ser simplificado e um pouco mais seguro. <br><br><h4>  Android IPC </h4><br>  O Android possui um mecanismo para troca de dados bidirecional entre processos: IPC (comunica√ß√£o entre processos).  O IPC √© prefer√≠vel ao esquema de URI personalizado por dois motivos: <br><br><ol><li>  Um aplicativo que abre um canal IPC pode verificar a autenticidade de um aplicativo aberto por seu certificado.  O inverso tamb√©m √© verdadeiro: um aplicativo aberto pode verificar a autenticidade do aplicativo que o abriu. </li><li>  Ao enviar uma solicita√ß√£o atrav√©s de um canal IPC, o remetente pode receber uma resposta atrav√©s do mesmo canal.  Juntamente com a verifica√ß√£o m√∫tua (item 1), isso significa que nenhum processo de terceiros pode interceptar o <code>access_token</code> . </li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/693/84d/6f6/69384d6f63788694137f8d559d6469fa.png"><br><br>  Assim, podemos usar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">concess√£o impl√≠cita</a> e simplificar bastante o esquema OAuth 2.0 para dispositivos m√≥veis.  N√£o <code>code_challenge</code> tokens <code>code_challenge</code> e CSRF.  Al√©m disso, poderemos nos proteger de malware que imita clientes leg√≠timos, a fim de roubar contas de usu√°rio. <br><br><h4>  SDK do cliente </h4><br>  Al√©m de implementar o esquema OAuth 2.0 m√≥vel seguro descrito acima, o provedor deve desenvolver um SDK para seus clientes.  Isso facilitar√° a implementa√ß√£o do OAuth 2.0 no lado do cliente e, ao mesmo tempo, reduzir√° o n√∫mero de erros e vulnerabilidades. <br><br><h1>  Tirar conclus√µes </h1><br>  Para os provedores do OAuth 2.0, compilei a "Lista de verifica√ß√£o do Secure Mobile OAuth 2.0": <br><br><ol><li>  Uma base s√≥lida √© vital.  No caso do OAuth 2.0 para dispositivos m√≥veis, a base √© o esquema ou protocolo que escolhemos implementar.  Ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">implementar seu pr√≥prio esquema OAuth 2.0,</a> √© f√°cil cometer um erro.  Outros j√° preencheram as lacunas e tiraram conclus√µes, n√£o h√° nada de errado em aprender com seus erros e fazer imediatamente uma implementa√ß√£o segura.  Em geral, o esquema OAuth 2.0 m√≥vel mais seguro √© o da se√ß√£o O que fazer? </li><li>  <code>Access_token</code> e outros dados confidenciais: em iOS - em Keychain, em Android - em Armazenamento Interno.  Esses reposit√≥rios s√£o projetados especificamente para esses fins.  Se necess√°rio, voc√™ pode usar o provedor de conte√∫do no Android, mas ele deve ser configurado com seguran√ßa. </li><li>  <code>Code</code> deve ser √∫nico, com uma vida √∫til curta. </li><li>  Para se proteger contra a intercepta√ß√£o de c√≥digo, use <code>code_challenge</code> . </li><li>  Para se proteger contra um ataque CSRF no logon, use tokens CSRF. </li><li>  N√£o use o WebView para obter a tela de consentimento, use a Aba personalizada do navegador. </li><li>  <code>Client_secret</code> <b>in√∫til</b> se n√£o estiver armazenado no back-end.  N√£o o entregue a clientes p√∫blicos. </li><li>  Use HTTPS em <b>qualquer lugar</b> , com a proibi√ß√£o de fazer o downgrade para HTTP. </li><li>  Siga as recomenda√ß√µes de criptografia (sele√ß√£o de cifra, comprimento do token etc.) <b>dos padr√µes</b> .  Voc√™ pode copiar os dados e descobrir por que isso foi feito dessa maneira, mas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">n√£o pode fazer sua criptografia</a> . </li><li>  No aplicativo cliente, verifique quem voc√™ abre para o OAuth 2.0 e, no aplicativo provedor, verifique quem abre o OAuth 2.0. </li><li>  Esteja ciente das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vulnerabilidades usuais do OAuth 2.0</a> .  O OAuth 2.0 para dispositivos m√≥veis estende e complementa o padr√£o, portanto ningu√©m cancelou a verifica√ß√£o <code>redirect_uri</code> para correspond√™ncias exatas e outras recomenda√ß√µes para o OAuth 2.0 regular. </li><li>  Certifique-se de fornecer SDKs aos clientes.  O cliente ter√° menos bugs e vulnerabilidades no c√≥digo e ser√° mais f√°cil para ele implementar o OAuth 2.0. </li></ol><br><h1>  O que ler </h1><br><ol><li>  [RFC] OAuth 2.0 para aplicativos nativos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://tools.ietf.org/html/rfc8252</a> </li><li>  Google OAuth 2.0 para aplicativos para dispositivos m√≥veis e computadores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://developers.google.com/identity/protocols/OAuth2InstalledApp</a> </li><li>  [RFC] Chave de prova para troca de c√≥digo por clientes p√∫blicos do OAuth <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://tools.ietf.org/html/rfc7636</a> </li><li>  Condi√ß√£o de corrida do OAuth 2.0 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://hackerone.com/reports/55140</a> </li><li>  [RFC] Modelo de amea√ßa do OAuth 2.0 e considera√ß√µes de seguran√ßa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://tools.ietf.org/html/rfc6819</a> </li><li>  Ataques ao OAuth 2.0 regular <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://sakurity.com/oauth</a> </li><li>  [RFC] Protocolo de registro din√¢mico de cliente OAuth 2.0 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://tools.ietf.org/html/rfc7591</a> </li></ol><br><h1>  Agradecimentos </h1><br>  Obrigado a todos que ajudaram a escrever este artigo, especialmente Sergey Belov, Andrey Sumin, Andrey Labunts ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@isciurus</a> ) e Daria Yakovleva. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt417031/">https://habr.com/ru/post/pt417031/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt417015/index.html">Entendemos o que registra e o que n√£o registra o aplicativo Burger King</a></li>
<li><a href="../pt417017/index.html">Como um experimento nuclear fracassado gerou acidentalmente astronomia de neutrinos</a></li>
<li><a href="../pt417023/index.html">Experi√™ncia do Rambler Group: como come√ßamos a controlar completamente a forma√ß√£o e o comportamento dos componentes React do front-end</a></li>
<li><a href="../pt417027/index.html">Como eu escrevi a biblioteca C ++ 11 padr√£o ou por que o impulso √© t√£o assustador? 1. Introdu√ß√£o</a></li>
<li><a href="../pt417029/index.html">Cria√ß√£o de perfil de c√≥digo com LLVM</a></li>
<li><a href="../pt417033/index.html">QIWI Kitchen em 7 de junho - v√≠deo dos discursos de nossos oradores</a></li>
<li><a href="../pt417035/index.html">UnnyWorld: post-mortem</a></li>
<li><a href="../pt417037/index.html">BEERBRAZZERS. Controle de luz. Vixen Lights 3. In√≠cio r√°pido (1/4)</a></li>
<li><a href="../pt417039/index.html">Aprenda wordpress (e mais) para renderizar players do YouTube rapidamente</a></li>
<li><a href="../pt417041/index.html">eslint-scope v3.7.2 rouba tokens do NPM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>