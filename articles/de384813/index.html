<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😝 ☀️ 👨🏾‍🌾 PPM-zu-USB-Adapter auf STM32F3Discovery oder Wir verbinden die Flugzeugmodellkonsole als HID-Joystick mit STM32Cube an den Computer 🧛🏻 ☕️ 👩🏿‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werde ich Ihnen sagen, wie:
 

- Erstellen Sie ein Projekt in STM32CubeMX und richten Sie Timer für die Erfassung externer Signale e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PPM-zu-USB-Adapter auf STM32F3Discovery oder Wir verbinden die Flugzeugmodellkonsole als HID-Joystick mit STM32Cube an den Computer</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/384813/"><img src="https://habrastorage.org/files/42a/e17/45b/42ae1745bcc442529f2839504fdf51f4.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Artikel werde ich Ihnen sagen, wie:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie ein Projekt in STM32CubeMX und richten Sie Timer für die Erfassung externer Signale ein. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dekodieren Sie ein PPM-Signal von einer Flugzeugmodellkonsole. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie ein Human Interface Device auf STM32 und schreiben Sie Ihren HID Report Descriptor. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fliegen Sie in einem Simulator auf einem Renn-Quadrocopter. </font><font style="vertical-align: inherit;">:) :)</font></font></li>
</ul><a name="habracut"></a><br>
<h3><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorwort</font></font></b></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In letzter Zeit werden FPV-Rennen auf Quadrocoptern der 250. Klasse (FPV - First Person View) immer beliebter. </font><font style="vertical-align: inherit;">Die Zahl 250 bedeutet den Abstand zwischen den Achsen der Motoren diagonal, typisch für kleine wendige Hubschrauber. </font><font style="vertical-align: inherit;">Solche Geräte basieren auf langlebigen Carbonrahmen, die Stürzen und Kollisionen standhalten. </font><font style="vertical-align: inherit;">Propeller mit einem Durchmesser von 5 bis 6 Zoll mit einer großen Stufe (Neigungswinkel der Blätter) werden für einen dynamischsten Flug auf leistungsstarke Motoren gesetzt. </font><font style="vertical-align: inherit;">Das Bild vom analogen Steuerkurs-Camcorder wird mit einer Frequenz von 5,8 GHz an den Monitor oder die Videobrille des Piloten übertragen. </font><font style="vertical-align: inherit;">Da die digitale Übertragung über WLAN eine lange Verzögerung (200-300 ms) verursacht, wird das Video immer auf einem analogen Kanal übertragen. </font><font style="vertical-align: inherit;">Um spektakuläre Clips aufzunehmen, sind Action-Kameras an Bord (GoPro, Mobius, SJcam, Xiaomi Yi usw.).</font></font><br>
<br>
<div style="text-align:center;"><img width="40%" src="https://habrastorage.org/files/727/722/0e5/7277220e5a8c4b749415d16d28091648.jpg"></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier sind einige spannende Videos über FPV-Copter:</font></font></b><div class="spoiler_text"><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://www.youtube.com/embed/NsxyV-kgfio%3Ffeature%3Doembed&amp;usg=ALkJrhjH8aiwaSmVTYGYgCaRB0ji60JarA" frameborder="0" allowfullscreen=""></iframe><br>
<iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://www.youtube.com/embed/1MBW8zoZUR4%3Ffeature%3Doembed&amp;usg=ALkJrhiD55e8SUVSufNtMUpizVJag1J69A" frameborder="0" allowfullscreen=""></iframe><br>
<iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://www.youtube.com/embed/70pusNNunMA%3Ffeature%3Doembed&amp;usg=ALkJrhgUEnjYo98UxzPfQU_8rFvVDD64Vg" frameborder="0" allowfullscreen=""></iframe></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor ich meinen Mini-Quadrocopter baute, wollte ich in einem Simulator fliegen und sehen, ob ich an FPV-Rennen interessiert wäre. Für das Training ist der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FPV FreeRider-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Simulator gut geeignet </font><font style="vertical-align: inherit;">. Es ist kostengünstig, hat eine kostenlose Demoversion und ahmt nach Ansicht erfahrener Piloten die wahre Flugmechanik sehr genau nach.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können das Flugzeug im Simulator über die Tastatur oder den Joystick steuern. Die Tastatur ist für die Steuerung schlecht geeignet, da die Tasten nur einen diskreten Wert übertragen können (die Taste wird gedrückt / nicht gedrückt) und es unmöglich ist, gleichmäßig variierende Zwischenwerte zu übertragen. Joysticks von Spielekonsolen mit analogen Sticks sind viel besser, aber sie haben einen sehr kleinen Stick, mit dem Sie das Gerät nicht genau genug steuern können. Eine ideale Option für einen Simulator ist eine Flugzeugmodellkonsole, die über einen speziellen Adapter mit einem Computer verbunden ist, dank dessen das Betriebssystem sie als Joystick betrachtet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich hatte bereits einen Quadrocopter, der für gemächliche Flüge und Fotografie zusammengestellt war, aber zu groß und schwer für Rennen. Dementsprechend gab es eine Fernbedienung - Turnigy 9X (in der ersten Abbildung). Auf der Rückseite befindet sich ein Anschluss zum Anschließen eines Adapters, an den ein PPM-Signal ausgegeben wird. Dieses Signal ist ein kurzer Impuls mit Intervallen von 1 bis 2 Millisekunden, deren Dauer der Position der Bedienelemente entspricht (mehr dazu im Abschnitt zur Decodierung).</font></font><br>
<br>
<div style="text-align:center;"><img width="33%" src="https://habrastorage.org/files/68b/cc1/4f0/68bcc14f02164d51a17401da82253df4.jpg"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich muss sagen, dass die Adapter zum Anschließen der Fernbedienung von PPM an USB schon lange freigegeben sind und mit Macht und Kraft verkauft werden. </font><font style="vertical-align: inherit;">Ein ähnlicher Adapter im Formfaktor des Flash-Laufwerks kann in China für 5 USD oder in russischen Geschäften etwas teurer gekauft werden. </font><font style="vertical-align: inherit;">Es gibt auch </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Open-Source-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adapterprojekte auf AVR-Controllern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber am späten Abend, als alle Moskauer Flugzeugmodellläden bereits geschlossen waren, kam mir sofort der akute Wunsch zu fliegen. </font><font style="vertical-align: inherit;">Ich wollte morgens nicht warten, es gab keine Zeit, die Platine mit ATmega zu vergiften und zu löten, und so entschied ich mich, einen PPM-USB-Adapter auf der STM32F3Discovery-Platine herzustellen, die lange Zeit im Leerlauf war und gerade zur Hand war.</font></font><br>
<br>
<h3><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist notwendig</font></font></b></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um einen Adapter herzustellen, benötigen Sie:</font></font><br>
<br>
<ul>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">STM32F3Discovery</a>.     STM32,     USB,   . </li>
<li>  c - 3,5     ( Turnigy)   BLS-,   ,   ( Discovery).</li>
<li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">STM32CubeMX</a>. </li>
<li>IDE    ARM.   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Keil uVision 5</a>.          32 ,      .</li>
<li> Turnigy 9X     PPM-.       FlySky FS-i6.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Discovery-Debug-Boards sind ziemlich teuer. </font><font style="vertical-align: inherit;">Der beschriebene F3 kostet ungefähr 20 US-Dollar und seine Funktionen sind für ein so einfaches Projekt überflüssig. </font><font style="vertical-align: inherit;">Ich habe es benutzt, weil dies zum Zeitpunkt des Schreibens das einzige Board mit Hardware-USB war, das ich zu Hause gefunden habe. </font><font style="vertical-align: inherit;">Für diejenigen, die es noch nicht gekauft haben, kann ich Ihnen raten, auf Miniaturkarten mit dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">STM32F103C8T6-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Controller </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">von AliExpress für 3 US-Dollar</font></a><font style="vertical-align: inherit;"> und dem ST-Link-Programmierer von dort </font><font style="vertical-align: inherit;">zu achten </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Der Prozess unterscheidet sich nicht von dem im Artikel beschriebenen. </font><font style="vertical-align: inherit;">Wenn zu Beginn kein anderer Regler ausgewählt werden muss, weisen Sie auf das Vorhandensein eines Quarzresonators hin und verwenden Sie eine etwas andere Pinbelegung.</font></font><br>
<br>
<div style="text-align:center;"><img width="30%" src="https://habrastorage.org/files/cf1/88d/0a1/cf188d0a1da94acfb233350ff94830ae.jpg"></div><br>
<br>
<a name="cube"></a><h3><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen eines Projekts in STM32CubeMX</font></font></b></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
STM32Cube ist ein Paket, das von STMicroelectronics entwickelt wurde, um STM32-Geräteentwicklern das Leben zu erleichtern. Es besteht aus dem CubeMX-Grafikdienstprogramm, HAL-Treibern und Middleware-Komponenten. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CubeMX</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist ein Tool zum Erstellen von Projekten und Initialisieren von Peripheriegeräten. Wählen Sie einfach die Steuerung aus, aktivieren Sie die Kontrollkästchen für die erforderlichen Module, wählen Sie die erforderlichen Modi im Menü aus und geben Sie die gewünschten Werte in mehrere Felder ein. CubeMX generiert das Projekt und verbindet die erforderlichen Bibliotheken damit. Der Entwickler des Geräts schreibt nur die Logik der Anwendung. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HAL-Fahrer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Hardware Abstraction Layer) sind eine API für die Arbeit mit Modulen und Peripheriegeräten des Mikrocontrollers. Mit HAL können Sie die oberste Ebene der vom Entwickler erstellten Anwendung von der Arbeit mit Registern trennen und den Programmcode zwischen den STM32-Controller-Familien so portabel wie möglich gestalten. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu den Middlewares</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder Zwischenkomponenten gehören das FreeRTOS-Betriebssystem, eine Bibliothek zum Arbeiten mit dem Dateisystem, USB-Bibliotheken, TCP / IP usw.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es scheint, dass es jetzt möglich ist, "mit der Maus zu programmieren", anstatt manuell Bits in Register zu schreiben. </font><font style="vertical-align: inherit;">Einfachheit und Bequemlichkeit heben jedoch nicht die Tatsache auf, dass Sie die Dokumentation studieren müssen, insbesondere in Fällen, in denen Sie die maximale Geschwindigkeit, den minimalen Stromverbrauch oder die Verwendung von Peripheriegeräten in nicht standardmäßigen Modi reduzieren müssen. </font><font style="vertical-align: inherit;">STM32Cube deckt noch nicht 100% aller Funktionen des Mikrocontrollers ab, nähert sich jedoch diesem. </font><font style="vertical-align: inherit;">STMicroelectronics aktualisiert Cube von Zeit zu Zeit, erweitert Funktionen und behebt Fehler. </font><font style="vertical-align: inherit;">Wenn Sie Cube bereits installiert haben, überprüfen Sie daher, ob es sich um die neueste Version handelt.</font></font><br>
<br>
<h5><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grundeinstellungen</font></font></b></h5><br>
<div style="text-align:center;"><img src="https://habrastorage.org/files/acf/6b2/4fc/acf6b24fc6c449f58c2be3b9ce9d1c1e.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Arbeit mit dem Projekt beginnt mit der Wahl des Controllers. Starten Sie STM32CubeMX und klicken Sie auf </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neues Projekt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Auf der Registerkarte </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MCU-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Auswahl können Sie den gewünschten Controller aus den Filtern auswählen. Da wir ein fertiges Debug-Board haben, </font><font style="vertical-align: inherit;">finden wir </font><font style="vertical-align: inherit;">auf der Registerkarte </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Board Selector </font></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">STM32F3Discovery</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Nach Auswahl einer Karte wird ein Bild des Controllers mit hervorgehobenen und signierten Pins angezeigt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im oberen Teil des Fensters befinden sich vier große Registerkarten: </font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pinbelegung</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - zum Konfigurieren der Pin-Funktionen und zum Voreinstellen von Modulen. Wir sind gerade dabei. </font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uhrenkonfiguration</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Uhreinstellung, PLL, Teiler. </font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konfiguration</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Detailliertere Konfiguration von Peripheriegeräten und Middleware.</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stromverbrauchsrechner</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Berechnung des vom Mikrocontroller verbrauchten Stroms. </font></font><br>
<br>
<img src="https://habrastorage.org/files/d02/a54/3a7/d02a543a7fe148d99d67ae83ad6a8fc9.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im linken Menü auf der Registerkarte </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pinbelegung</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> können </font><i><font style="vertical-align: inherit;">Sie</font></i><font style="vertical-align: inherit;"> die gewünschten Peripheriegeräte verwenden und </font><font style="vertical-align: inherit;">auf der </font><i><font style="vertical-align: inherit;">Steuerschaltung</font></i><font style="vertical-align: inherit;"> eine Funktion für einen der Ausgänge des Mikrocontrollers auswählen. Einige Elemente auf der linken Seite sind Warnsymbole. Dies bedeutet, dass die Module (in diesem Fall ADC, DAC, OPAMP2, RTC) jetzt unvollständig verwendet werden können, da einige ihrer Ausgänge bereits von anderen Funktionen belegt sind.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Konfigurierte Pins werden in der Steuerschaltung grün hervorgehoben. </font><font style="vertical-align: inherit;">Da wir uns nicht für einen nackten Controller ohne Umreifung entschieden haben, sondern für eine vorgefertigte F3-Discovery-Debugging-Karte, sind einige der Ausgänge bereits konfiguriert, z. B. ist eine blaue Taste an PA0 und LEDs an PE8 ... 15 angeschlossen. </font><font style="vertical-align: inherit;">Die Pins, an die einige externe Geräte in Discovery angeschlossen sind, werden orange hervorgehoben, aber die Peripheriemodule für sie wurden noch nicht konfiguriert. </font><font style="vertical-align: inherit;">Wie Sie sehen können, sind dies Pins für USB, Quarzresonatoren, SPI und I2C für Gyroskop und Kompass, DP und DM für USB. </font><font style="vertical-align: inherit;">Graue Schlussfolgerungen werden derzeit nicht verwendet, keine davon können wir für unsere Zwecke anwenden.</font></font><br>
<br>
<h5><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eingangsauswahl</font></font></b></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden die Dauer der Impulse erfassen, daher muss der Eingang mit einem der Kanäle eines beliebigen Timers verbunden sein. </font><font style="vertical-align: inherit;">Außerdem beträgt der Signalpegel bei Turnigy 9X nicht 3,3 V wie die Versorgungsspannung des STM32, sondern 5 V. </font><font style="vertical-align: inherit;">Wir sind zu faul, um den Spannungsteiler zu löten, daher müssen Sie einen Eingang wählen, der 5 V standhält (diese Eingänge werden als 5 V-tolerant bezeichnet). </font><font style="vertical-align: inherit;">Geeignete Pins finden Sie im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datenblatt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu STM32F303VCT6 im Abschnitt </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pinbelegung und Pinbeschreibung</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Es gibt viele Timer im STM32F3, die über fast alle Pins verteilt sind. </font><font style="vertical-align: inherit;">Eine bequeme Option ist PC6. </font><font style="vertical-align: inherit;">Es kann 5 Volt standhalten und befindet sich in der unteren linken Ecke der Platine neben GND. </font><font style="vertical-align: inherit;">Weisen Sie diesem Pin den 1. Kanal des 3. Timers TIM3_CH1 zu.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/files/eb7/4b2/67e/eb74b267e70140b9842408158de617e8.png"></div><br>
<br>
<h5><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uhreinstellung</font></font></b></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit der USB funktioniert, muss der Mikrocontroller mit einer sehr stabilen Frequenz getaktet werden, weshalb fast alle USB-Geräte über Quarzresonatoren verfügen. Die Frequenzstabilität des eingebauten RC-Generators reicht für USB nicht aus. Aber auf dem STM32F3 Discovery Board waren Entwickler aus irgendeinem Grund gierig und haben keinen Quarz eingesetzt. Wenn Sie jedoch die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schaltung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sorgfältig untersuchen </font><font style="vertical-align: inherit;">, können Sie feststellen, dass das </font><i><font style="vertical-align: inherit;">MCO-</font></i><font style="vertical-align: inherit;"> Signal </font><font style="vertical-align: inherit;">an den Eingang </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PF0-OSC_IN angeschlossen ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , an den der Quarz angeschlossen werden soll </font><font style="vertical-align: inherit;">. Es kommt vom ST-Link-Programmierer auf derselben Platine, auf der sich Quarz befindet. Das </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Benutzerhandbuch</font></a><font style="vertical-align: inherit;"> für F3 Discovery (UM1570) im Abschnitt </font><i><font style="vertical-align: inherit;">OSC Clock</font></i><font style="vertical-align: inherit;"> besagt, dass 8 MHz an diese Leitung </font><font style="vertical-align: inherit;">gesendet </font><font style="vertical-align: inherit;">werden.</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br>
<img width="30%" src="https://habrastorage.org/files/b5c/234/80f/b5c23480ffca498d8e52e6fef4c0892f.png"><img width="65%" src="https://habrastorage.org/files/c00/160/fb8/c00160fb809b4c7190390d8a8ccd3ac6.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Somit wird der Mikrocontroller von einer externen Quelle getaktet. Dieser Modus wird als Bypass bezeichnet. </font><i><font style="vertical-align: inherit;">Wählen Sie</font></i><font style="vertical-align: inherit;"> im Peripherie-Einstellungsmenü im Abschnitt </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RCC</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zum Takten der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hochgeschwindigkeitsuhr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Option BYPASS-Taktquelle aus</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/files/934/7e5/17e/9347e517e21540a88c922d35d881c009.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor wir zu einer detaillierteren Uhreinstellung übergehen, stellen wir im Peripheriemenü fest, dass der Mikrocontroller als USB-Gerät fungiert. </font></font><br>
<br>
<img src="https://habrastorage.org/files/597/c20/ddb/597c20ddbe2e4c2898c90db97110e454.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt können Sie zur nächsten großen Registerkarte wechseln - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uhrenkonfiguration</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Hier sehen wir ein riesiges Diagramm, das zeigt, welche Taktsignale im Mikrocontroller vorhanden sind, woher sie kommen, wie sie sich verzweigen, multiplizieren und teilen. In gelb habe ich die Parameter hervorgehoben, die beachtet werden sollten. </font></font><br>
<br>
<img src="https://habrastorage.org/files/1a5/9a8/596/1a59a8596d434c1f8d09ee5e8335adee.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Überprüfen Sie die Eingangsfrequenz</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Eingangsfrequenz</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> beträgt 8 MHz. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir stellen den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PLL Source Mux-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schalter </font><font style="vertical-align: inherit;">auf </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HSE</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (High Speed ​​External), um von einer externen Quelle anstatt von einer internen Quelle zu takten. </font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PLL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Phase Lock Loop oder PLL - Phase Locked Loop dient dazu, die externe Frequenz mehrmals zu multiplizieren. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie den PLLMul-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Multiplikator </font><font style="vertical-align: inherit;">auf 9. Dann erreichen wir die maximal mögliche Frequenz für den STM32F303 - 72 MHz. </font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der System Clock Mux</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> muss sich in der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PLLCLK-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Position befinden, </font><i><font style="vertical-align: inherit;">damit</font></i><font style="vertical-align: inherit;"> die Taktfrequenz mit der PLL multipliziert wird. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für das USB-Modul werden 48 MHz benötigt. Stellen Sie daher einen 1,5-Teiler vor USB. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Achten Sie auf die Frequenz</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der APB1-Timer taktet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf der linken Seite der Schaltung. </font><font style="vertical-align: inherit;">Es geht an die Timer und ist für uns in Zukunft nützlich. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn eine Frequenz falsch konfiguriert ist, den maximal möglichen Wert überschreitet oder sich die Schalter in einer ungültigen Position befinden, hebt CubeMX diese Stelle rot hervor.</font></font><br>
<br>
<h5><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Timer-Einstellung</font></font></b></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Pulsdauer zu messen, starten wir den TIM3-Timer im Input Capture-Modus. Im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referenzhandbuch</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> finden Sie im Abschnitt </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Allzweck-Timer (TIM2 / TIM3 / TIM4)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ein Diagramm, das die Funktionsweise von Timern veranschaulicht. Mit Farben habe ich die im Input Capture-Modus verwendeten Signale und Register hervorgehoben. </font></font><br>
<br>
<img src="https://habrastorage.org/files/e76/54c/ea5/e7654cea52cb46c891e5a73e91068b71.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das grün hervorgehobene Taktsignal tritt kontinuierlich in das CNT-Zählerregister ein und erhöht seinen Wert bei jedem Taktzyklus um 1. Im </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prescaler PSC-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teiler kann die </font><font style="vertical-align: inherit;">Taktfrequenz für eine langsamere Zählung abnehmen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein </font><font style="vertical-align: inherit;">externes Signal wird </font><font style="vertical-align: inherit;">in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TIMx_CH1 eingegeben</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kantendetektor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es erkennt Flanken des Eingangssignals - Übergänge von 0 nach 1 oder von 1 nach 0. Bei der Registrierung einer Front werden zwei gelb hervorgehobene Befehle ausgegeben: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
- Ein Befehl zum Schreiben des Werts des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CNT-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zählers </font><font style="vertical-align: inherit;">in das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Register Register Capture / Compare 1 (CCR1)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und Aufruf des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CC1I-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Interrupts </font><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
- Ein Befehl für den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Slave-Modus-Controller</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mit dem der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CNT-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wert </font><font style="vertical-align: inherit;">auf 0 zurückgesetzt wird und der Countdown erneut startet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist eine Illustration des Prozesses in einer Zeitleiste:</font></font><br>
<br>
<img width="50%" src="https://habrastorage.org/files/3b5/80b/ab0/3b580bab0b894981b8d28eadd9f444b2.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn ein Interrupt auftritt, führen wir Aktionen mit dem erfassten Wert aus. Wenn die Eingangsimpulse zu oft auftreten und die im Interrupt-Handler auftretenden Aktionen zu lang sind, kann der Wert von CCR1 überschrieben werden, bevor der vorherige gelesen wird. In diesem Fall müssen Sie das Overcapture-Flag aktivieren oder DMA (Direct Memory Access) anwenden, wenn die Daten von CCR1 das vorbereitete Array automatisch in den Speicher füllen. In unserem Fall hat der kürzeste Impuls eine Dauer von 1 Millisekunde, und der Interrupt-Handler ist einfach und kurz. Machen Sie sich also keine Sorgen über das Überschreiben. </font><i><font style="vertical-align: inherit;">Kehren Sie zur</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Registerkarte </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pinbelegung zurück</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und stellen Sie den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TIM3-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Timer </font><font style="vertical-align: inherit;">im Menü </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peripheriegeräte</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ein </font><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/files/437/703/50b/43770350badf4efcb4d02a11ea2f9db0.png"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Slave-Modus: Reset-Modus</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- bedeutet, dass in einem bestimmten Fall der Timer auf 0 zurückgesetzt wird. </font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Triggerquelle: TI1FP1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Das Ereignis, das zum Zurücksetzen und Starten des Timers verwendet wird, ist die vom TI1-Eingang erfasste Signalflanke. </font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ClockSource: Interne Uhr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Der Timer wird vom internen Generator des Mikrocontrollers getaktet. </font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kanal 1: Input Capture Direct-Modus</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Erfassungsintervalle vom 1. Kanal im CCR1-Register. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf der nächsten großen Registerkarte " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konfiguration" nehmen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir </font><font style="vertical-align: inherit;">zusätzliche Timer-Einstellungen vor.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/files/db8/b67/8d8/db8b678d8f7846c9af081a0bfdb0d7b1.png"></div><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/files/63b/6ac/c06/63b6acc06716451399d01566635d2f87.png"></div><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prescaler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist ein Timer-Teiler. Wenn es 0 ist, wird die Frequenz direkt vom Taktbus APB Takt - 72 MHz genommen. Wenn der Vorteiler 1 ist, wird die Frequenz durch 2 geteilt und wird zu 36 MHz. Stellen Sie den Divisor auf 71 ein, so dass die Frequenz durch 72 geteilt wird. Dann beträgt die Timerfrequenz 1 MHz und die Intervalle werden mit einer Auflösung von 1 Mikrosekunde gemessen. </font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zähler Perioden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - stellen Sie </font><font style="vertical-align: inherit;">den maximal möglichen 16-Bit - </font><font style="vertical-align: inherit;">Wert 0xFFFF. Die Periode ist wichtig für die Erzeugung von Zeitschlitzen, beispielsweise für PWM. Die Periode ist jedoch für die Erfassung von Signalen nicht wichtig, wir werden bekannt geben, dass sie für alle Eingangsimpulse groß ist. </font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Polaritätsauswahl: Fallende</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flanke - Timer-Werte werden an der fallenden Flanke des Eingangssignals erfasst. </font><i><font style="vertical-align: inherit;">Setzen Sie auf der</font></i></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Registerkarte </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVIC-Einstellungen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine Morgendämmerung</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Globaler TIM3-Interrupt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sodass Ereignisse, die sich auf den 3. Timer beziehen, einen Interrupt erzeugen.</font></font><br>
<br>
<h5><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">USB-Geräte-Setup</font></font></b></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben bereits festgestellt, dass der Controller ein USB-Gerät sein wird. </font><font style="vertical-align: inherit;">Da der Joystick zur Klasse der HID-Geräte gehört </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wählen </font><i><font style="vertical-align: inherit;">Sie im Menü Middlewares -&gt; USB_DEVICE die Option </font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Class For FS IP: Human Interface Device Class (HID)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Anschließend verbindet CubeMX Bibliotheken für das HID-Gerät mit dem Projekt. </font></font><br>
<br>
<img src="https://habrastorage.org/files/3fe/080/472/3fe0804729bd4b2f995c5f32a9173d47.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gehen wir zu den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">USB_DEVICE-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Einstellungen </font><font style="vertical-align: inherit;">auf der Registerkarte </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konfiguration</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im Abschnitt </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Middlewares</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/files/574/ba7/dde/574ba7dde3794ce4911f955e628f7ce7.png"></div><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hersteller-ID</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Produkt-ID</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sind zwei 16-Bit-Kennungen, die für jedes Modell eines USB-Geräts eindeutig sind. VID entspricht dem Gerätehersteller, und jeder Hersteller weist PID zu, basierend auf seinen eigenen Überlegungen. Ich konnte die offizielle Liste von VID und PID nicht finden, sondern nur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von Enthusiasten unterstützte </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Identifikatorbasis</font></a><font style="vertical-align: inherit;"> . Um Ihre eigene Vendor ID zu erhalten, müssen Sie das USB Implementers Forum auf </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usb.org besuchen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und ein paar tausend Dollar bezahlen. Kleine Unternehmen oder Open-Source-Entwickler, die sich ihre VID nicht leisten können, können einen USB-Chip-Hersteller anfordern und offiziell ein VID / PID-Paar für ihr Projekt erhalten. Ein solcher Service wird beispielsweise von FTDI oder Silicon Laboratories angeboten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie zwei Geräte mit derselben VID / PID verbinden, jedoch von einem anderen Typ (z. B. eines ist ein HID-Gerät und das andere ist Massenspeicher), versucht das Betriebssystem, denselben Treiber für sie und mindestens eines davon zu installieren wird nicht funktionieren. Aus diesem Grund müssen VID / PID-Paare für verschiedene Gerätemodelle eindeutig sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da wir kein Gerät für uns selbst herstellen, werden wir es nicht verkaufen und vertreiben. Wir werden die VID 0x0483, die STMicroelectronics entspricht, verlassen und unsere eigene PID entwickeln. Standardmäßig bietet CubeMX die PID 0x5710 für das HID-Gerät an. Ersetzen Sie es beispielsweise durch 0x57FF. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ersetzen Sie die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Produktzeichenfolge</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> durch den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">STM32 PPM-USB-Adapter</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dieser Name wird in der Liste der Geräte in der Windows-Systemsteuerung angezeigt. Wir werden die Seriennummer (S \ N) noch nicht ändern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Windows erkennt, dass es ein Gerät mit einer Kombination aus VID, PID und S \ N erkennt, die es zuvor noch nicht gesehen hat, installiert das System den entsprechenden Treiber dafür. Wenn die Kombination aus VID, PID und S \ N bereits verwendet wurde, ersetzt Windows automatisch den zuvor verwendeten Treiber. Sie können dies beispielsweise sehen, wenn Sie das Flash-Laufwerk an USB anschließen. Das erste Anschließen und Installieren dauert einige Zeit. Bei nachfolgenden Verbindungen beginnt das Laufwerk fast sofort zu arbeiten. Wenn Sie jedoch eine andere Instanz des Flash-Laufwerks desselben Modells mit einer anderen Seriennummer anschließen, installiert das System einen neuen Treiber dafür, obwohl es dieselbe VID und PID hat.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde erklären, warum dies wichtig ist. </font><font style="vertical-align: inherit;">Wenn Sie auf Ihrem STM32 eine USB-Maus mit Ihrer VID, PID und S \ N erstellt, diese an den Computer angeschlossen und dann einen USB-Joystick erstellt haben, ohne die VID, PID und S \ N zu ändern, erkennt Windows das neue Gerät als eine Maus, die bereits vorhanden ist wird im System verwendet und installiert den Joystick-Treiber nicht. </font><font style="vertical-align: inherit;">Dementsprechend funktioniert der Joystick nicht. </font><font style="vertical-align: inherit;">Wenn Sie den Typ Ihres Geräts ändern möchten und die VID / PID unverändert lassen möchten, müssen Sie daher die Seriennummer ändern.</font></font><br>
<br>
<h5><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projektgenerierung für IDE</font></font></b></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die letzten Einstellungen, die Sie vornehmen müssen, sind die Einstellungen für die Projektgenerierung. Dies geschieht über </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projekt -&gt; Einstellungen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... Dort legen wir den Namen, den Zielordner und die gewünschte IDE fest, unter der CubeMX das Projekt erstellt. Ich wählte </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MDK-ARM V5</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , weil ich Keil uVision verwende 5. Auf dem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code Generator</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Registerkarte </font><font style="vertical-align: inherit;">können Sie das überprüfen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kopieren Sie </font><font style="vertical-align: inherit;">nur die erforderlichen Bibliotheksdateien</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Checkbox , </font><font style="vertical-align: inherit;">um </font><font style="vertical-align: inherit;">das Projekt nicht mit unnötigen Dateien zu vollstopfen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Klicken Sie auf die Schaltfläche </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projekt -&gt; Code generieren</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . CubeMX erstellt ein Projekt mit Code, der in Keil uVision geöffnet und ohne zusätzliche Einstellungen kompiliert und geflasht werden kann. In der Datei </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.c</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in der Funktion </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main (void)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wurden bereits Funktionen zum Initialisieren von Uhr, Anschlüssen, Timer und USB eingefügt. In ihnen werden die Mikrocontrollermodule gemäß den in CubeMX festgelegten Modi konfiguriert. </font></font><br>
<br>
<img src="https://habrastorage.org/files/fb6/a32/393/fb6a323933734c7cb3ac4e11550d7420.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Code finden sich häufig Konstruktionen dieser Art:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* USER CODE BEGIN 0 */</span><font></font>
(...)<font></font>
<span class="hljs-comment">/* USER CODE END 0 */</span><font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wird davon ausgegangen, dass der Benutzer seinen Code in diese Abschnitte einbettet. Wenn die Option </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benutzercode beim erneuten Generieren</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> beibehalten in den CubeMX-Projekteinstellungen aktiviert ist </font><font style="vertical-align: inherit;">, wird der zwischen diesen Zeilen eingeschlossene Code während der sekundären Generierung eines vorhandenen Projekts nicht überschrieben. Leider werden nur von CubeMX erstellte Abschnitte gespeichert. </font><font style="vertical-align: inherit;">Vom Benutzer erstellte </font><font style="vertical-align: inherit;">Abschnitte </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ * USER CODE * /</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gehen verloren. Wenn Sie nach dem Schreiben des Codes in die IDE zu CubeMX zurückkehren und das Projekt mit den neuen Einstellungen erneut generieren möchten, empfehle ich daher, eine Sicherungskopie des Projekts zu erstellen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den Firmware-Einstellungen in uVision ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flash -&gt; Flash-Tools konfigurieren</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) empfehle ich Ihnen, die Option </font><i><font style="vertical-align: inherit;">Nach Flash</font></i><font style="vertical-align: inherit;"> zurücksetzen </font><font style="vertical-align: inherit;">zu aktivieren</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so dass der Mikrocontroller sofort nach dem Blinken startet. </font><font style="vertical-align: inherit;">Standardmäßig ist es deaktiviert und nach jedem Blinken müssen Sie die Reset-Taste auf der Karte drücken.</font></font><br>
<br>
<img src="https://habrastorage.org/files/1e1/a3d/20d/1e1a3d20dd994c1787f8a8758fcd200e.png"><br>
<br>
<a name="ppm"></a><h3><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PPM-Decodierung</font></font></b></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PPM - Pulse Position Modulation - eine in der Flugzeugmodellelektronik weit verbreitete Methode zur Codierung übertragener Signale. </font><font style="vertical-align: inherit;">Es ist eine Folge von Impulsen, deren Zeitintervalle den übertragenen Zahlenwerten entsprechen.</font></font><br>
<br>
<div style="text-align:center;"><img width="80%" src="https://habrastorage.org/files/905/3ec/257/9053ec2573f8438b9a3053f2ef408739.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gemäß diesem Protokoll sendet die Konsole Informationen an das sendende Funkmodul, das auf der Rückseite in die Konsole eingesetzt wird. Viele Empfänger, die an Bord des Copters platziert sind, können Steuersignale für den Flugregler über PPM übertragen. Darüber hinaus verfügt fast jede Konsole über Anschlüsse zum Anschließen einer zweiten Konsole im Trainer-Student-Modus und zum Anschließen der Konsole an einen Simulator, der normalerweise auch PPM verwendet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir schreiben ein Signal vom Simulatorausgang von Turnigy 9X mit einem Logikanalysator:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/files/53e/da5/319/53eda5319a6d45b59ee6e265de445992.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jede Sequenz codiert den aktuellen Status der Steuerelemente auf der Fernbedienung. Normalerweise entsprechen die ersten vier Werte (auch Kanäle genannt) der Position der Analogsticks und die nachfolgenden der Position der Kippschalter oder Potentiometer. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die minimale Position der Steuerung entspricht dem Intervall 1000 μs, das Maximum - 2000 μs, die durchschnittliche Position - 1500 μs. Impulsstöße oder Rahmen werden durch wesentlich längere Intervalle getrennt und folgen mit einer Periode von 20–25 ms. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns das Signal genauer an:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/files/703/86d/84e/70386d84efe24577a958767f8c5b7ae9.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen können, befinden sich drei Stöcke in der neutralen Position (1, 3, 4) und einer in der extremen Position (2). </font><font style="vertical-align: inherit;">Drei Kippschalter sind ausgeschaltet (5, 6, 7) und der letzte ist eingeschaltet (8). </font><font style="vertical-align: inherit;">Der als Adapter fungierende Mikrocontroller muss eine solche Sequenz erfassen, die Werte einem Array hinzufügen und als Befehl vom Joystick über USB senden. </font><font style="vertical-align: inherit;">Schreiben wir einen Pulssequenzdecoder.</font></font><br>
<br>
<h5><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterbrechung erfassen</font></font></b></h5><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starten Sie</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
nach der Initialisierung in </font><i><font style="vertical-align: inherit;">main.c</font></i><font style="vertical-align: inherit;"> vor der main </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">while-Schleife</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> den TIM3-Timer im Input Capture-Erfassungsmodus von Kanal 1 aus, und generieren Sie Erfassungsunterbrechungen. </font><font style="vertical-align: inherit;">Verwenden Sie dazu die entsprechende Funktion von HAL:</font></font><br>
<br>
<pre><code class="cpp hljs">HAL_TIM_IC_Start_IT(&amp;htim3, TIM_CHANNEL_1);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">htim3</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Struktur </font><font style="vertical-align: inherit;">in deklarierten </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.c</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist die TIM3 timer - </font><font style="vertical-align: inherit;">Handler, der alle Variablen enthält Strukturen und mit dem Zeitgeber verbunden ist </font><font style="vertical-align: inherit;">: Parameter für die </font><font style="vertical-align: inherit;">Initialisierung, Zeiger auf alle Zeitgeberregister (Zählerwert, Teiler, alle Einstellungen, Interrupt - </font><font style="vertical-align: inherit;">Flags), Zeiger auf einem Handler-DMA, der mit diesem Timer usw. funktioniert Der Entwickler muss nicht suchen, welche Bits in welchem ​​Register für was verantwortlich sind, und diese manuell setzen und zurücksetzen. Es reicht aus, den Handler an die HAL-Funktion zu übergeben. HAL-Bibliotheken erledigen den Rest selbst. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Prinzipien der HAL-Struktur werden ausführlicher im Dokument </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Beschreibung der STM32F3xx-HAL-Treiber beschrieben</font></a><font style="vertical-align: inherit;"> .</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(UM1786). Es ist zu beachten, dass die HAL-Bibliotheken selbst gut dokumentiert sind. Um zu verstehen, wie die HAL für den Timer funktioniert und wie sie verwendet wird, können Sie die Kommentare in den </font><i><font style="vertical-align: inherit;">Dateien </font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stm32f3xx_hal_tim.h</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stm32f3xx_hal_tim.c</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lesen </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für jeden Interrupt, den der TIM3-Timer generiert, wird der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TIM3_IRQHandler-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Handler </font><i><font style="vertical-align: inherit;">aufgerufen</font></i><font style="vertical-align: inherit;"> . Es befindet sich in der Datei </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stm32f3xx_it.c. </font></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daraufhin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird der </font><font style="vertical-align: inherit;">für alle Timer standardmäßige </font><i><font style="vertical-align: inherit;">HAL_TIM_IRQHandler-</font></i><font style="vertical-align: inherit;"> Handler </font><i><font style="vertical-align: inherit;">aufgerufen</font></i><font style="vertical-align: inherit;"> und ein Zeiger auf die htim3-Struktur an ihn übergeben.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TIM3_IRQHandler</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><font></font><span class="hljs-function">
</span>{<font></font>
  <span class="hljs-comment">/* USER CODE BEGIN TIM3_IRQn 0 */</span><font></font>
<font></font>
  <span class="hljs-comment">/* USER CODE END TIM3_IRQn 0 */</span><font></font>
  HAL_TIM_IRQHandler(&amp;htim3);<font></font>
  <span class="hljs-comment">/* USER CODE BEGIN TIM3_IRQn 1 */</span><font></font>
<font></font>
  <span class="hljs-comment">/* USER CODE END TIM3_IRQn 1 */</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir in die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HAL_TIM_IRQHandler-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Datei </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stm32f3xx_hal_tim.c schauen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sehen wir einen riesigen Handler, der die Interrupt-Flags auf Timer überprüft, eine Rückruffunktion verursacht und das Flag nach der Ausführung löscht. </font><font style="vertical-align: inherit;">Wenn ein Erfassungsereignis </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auftritt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ruft es die Funktion </font><i><font style="vertical-align: inherit;">HAL_TIM_IC_CaptureCallback auf</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Es sieht aus wie das:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">__weak <span class="hljs-keyword">void</span> <span class="hljs-title">HAL_TIM_IC_CaptureCallback</span><span class="hljs-params">(TIM_HandleTypeDef *htim)</span></span><font></font><span class="hljs-function">
</span>{<font></font>
<span class="hljs-comment">/* NOTE : This function Should not be modified, when the callback is needed, the __HAL_TIM_IC_CaptureCallback could be implemented in the user file</span><font></font><span class="hljs-comment">
*/</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies bedeutet, dass wir diese Funktion in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.c überschreiben können</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Fügen Sie daher </font><font style="vertical-align: inherit;">diesen Rückruf </font><font style="vertical-align: inherit;">vor der Funktion </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int main (void) ein</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HAL_TIM_IC_CaptureCallback</span><span class="hljs-params">(TIM_HandleTypeDef *htim)</span></span><font></font><span class="hljs-function">
</span>{<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich würde gerne sehen, wie der Interrupt ausgeführt wird. </font><font style="vertical-align: inherit;">Fügen Sie dazu ein kurzes Ein- und Ausschalten einer der Schlussfolgerungen hinzu:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HAL_TIM_IC_CaptureCallback</span><span class="hljs-params">(TIM_HandleTypeDef *htim)</span></span><font></font><span class="hljs-function">
</span>{<font></font>
  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_8, GPIO_PIN_SET);<font></font>
  __nop();__nop();__nop();__nop();__nop();__nop();<font></font>
  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_8, GPIO_PIN_RESET);<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der PE8-Pin wurde bereits als Ausgang initialisiert. </font><font style="vertical-align: inherit;">Zwischen dem Ein- und Ausschalten werden </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__nop () -</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anweisungen eingefügt </font><font style="vertical-align: inherit;">, die eine Verzögerung von 1 Taktzyklus bilden. </font><font style="vertical-align: inherit;">Dies geschieht, damit mein chinesischer 8-Dollar-Logikanalysator, der mit 24 MHz arbeitet, keinen zu kurzen Impuls von einem 72-MHz-Mikrocontroller verpasst. </font><font style="vertical-align: inherit;">Kompilieren Sie nun das Projekt </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projekt -&gt; Ziel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erstellen </font><font style="vertical-align: inherit;">und fragen Sie den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flash-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Controller </font><i><font style="vertical-align: inherit;">-&gt; Download</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wir werden das PPM von der Fernbedienung an PC6 anschließen und sehen, was mit dem Analysegerät auf PC6 und PE8 passiert.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/files/abf/64c/e2c/abf64ce2c6874057933df9edb58dff8f.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rückruf wird wirklich im richtigen Moment aufgerufen - direkt nachdem das Eingangssignal von 1 auf 0 übergegangen ist. Also wurde alles richtig gemacht.</font></font><br>
<br>
<h5><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erfassen und verarbeiten Sie erfasste Daten</font></font></b></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden den Rückruf so bearbeiten, dass jeder erfasste Wert </font><font style="vertical-align: inherit;">unverändert </font><font style="vertical-align: inherit;">zum </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erfassten_Wert-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Puffer hinzugefügt wird </font><font style="vertical-align: inherit;">. Wenn der Timer einen sehr großen Wert erfasst (mehr als 5000 μs), bedeutet dies, dass eine Pause aufgezeichnet wurde, das Paket vollständig empfangen wurde und verarbeitet werden kann. Die verarbeiteten Werte werden dem Array </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rc_data</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit 5 Elementen </font><font style="vertical-align: inherit;">hinzugefügt </font><font style="vertical-align: inherit;">. In den ersten vier werden die Steuerknüppelpositionen auf den Bereich [0; 1000], im fünften werden einzelne Bits gemäß den Kippschaltern gesetzt, die als Drücken von Tasten auf dem Gamepad interpretiert werden.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">uint16_t</span> captured_value[<span class="hljs-number">8</span>] = {<span class="hljs-number">0</span>};<font></font>
<span class="hljs-keyword">uint16_t</span> rc_data[<span class="hljs-number">5</span>] = {<span class="hljs-number">0</span>};<font></font>
<span class="hljs-keyword">uint8_t</span> pointer = <span class="hljs-number">0</span>;<font></font>
<span class="hljs-keyword">uint8_t</span> data_ready = <span class="hljs-number">0</span>;<font></font>
<font></font>
...<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HAL_TIM_IC_CaptureCallback</span><span class="hljs-params">(TIM_HandleTypeDef *htim)</span></span><font></font><span class="hljs-function">
</span>{<font></font>
    <span class="hljs-keyword">uint8_t</span> i;<font></font>
    <span class="hljs-keyword">uint16_t</span> temp;<font></font>
    <span class="hljs-comment">//     </span><font></font>
    temp = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);<font></font>
    <span class="hljs-comment">//    , ,  </span><font></font>
    <span class="hljs-keyword">if</span> ((temp &gt; <span class="hljs-number">5000</span>) &amp;&amp; (!data_ready))<font></font>
    {<font></font>
        pointer = <span class="hljs-number">0</span>;<font></font>
        <span class="hljs-comment">//        [0;1000]</span><font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (captured_value[i] &lt; <span class="hljs-number">1000</span>)<font></font>
                captured_value[i] = <span class="hljs-number">1000</span>;<font></font>
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (captured_value[i] &gt; <span class="hljs-number">2000</span>)<font></font>
                captured_value[i] = <span class="hljs-number">2000</span>;<font></font>
            rc_data[i] = captured_value[i]<span class="hljs-number">-1000</span>;<font></font>
        };<font></font>
        <span class="hljs-comment">//     </span><font></font>
        rc_data[<span class="hljs-number">4</span>] = <span class="hljs-number">0</span>;<font></font>
        <span class="hljs-keyword">if</span> (captured_value[<span class="hljs-number">4</span>] &gt; <span class="hljs-number">1500</span>)<font></font>
            rc_data[<span class="hljs-number">4</span>] |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>);<font></font>
        <span class="hljs-keyword">if</span> (captured_value[<span class="hljs-number">5</span>] &gt; <span class="hljs-number">1500</span>)<font></font>
            rc_data[<span class="hljs-number">4</span>] |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>);<font></font>
        <span class="hljs-keyword">if</span> (captured_value[<span class="hljs-number">6</span>] &gt; <span class="hljs-number">1500</span>)<font></font>
            rc_data[<span class="hljs-number">4</span>] |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">6</span>);<font></font>
        <span class="hljs-keyword">if</span> (captured_value[<span class="hljs-number">7</span>] &gt; <span class="hljs-number">1500</span>)<font></font>
            rc_data[<span class="hljs-number">4</span>] |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">7</span>);<font></font>
        data_ready = <span class="hljs-number">1</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">else</span> <span class="hljs-comment">//      </span><font></font>
    {<font></font>
        captured_value[pointer] = temp;<font></font>
        pointer++;<font></font>
    };<font></font>
    <span class="hljs-keyword">if</span> (pointer == <span class="hljs-number">8</span>) <span class="hljs-comment">//   </span><font></font>
        pointer = <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie mich erklären, warum ich die den Schaltflächen entsprechenden Bits nicht in den unteren 4 Bits, sondern in den fünften bis achten Bits platziert habe. Im Simulator soll ein Gamepad von der Xbox angeschlossen werden, auf dem die Tasten LB, RB, Start und Back verwendet werden. Die Nummern 5 bis 8. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Hauptschleife wird das Flag data_ready kontinuierlich gedreht, wodurch Daten an den Computer gesendet werden.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<font></font>
{<font></font>
  <span class="hljs-keyword">if</span> (data_ready)<font></font>
  {<font></font>
    <span class="hljs-comment">//      </span><font></font>
    data_ready = <span class="hljs-number">0</span>;<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um zu überprüfen, wie dies funktioniert, schließen Sie die Fernbedienung an, kompilieren und flashen Sie sie erneut und starten Sie dann das Debuggen von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debug -&gt; Debug-Sitzung starten / stoppen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Öffnen Sie das Fenster zum Verfolgen von Variablen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ansicht -&gt; Windows </font></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">überwachen </font></i><i><font style="vertical-align: inherit;">-&gt; 1 </font></i><i><font style="vertical-align: inherit;">überwachen</font></i><font style="vertical-align: inherit;"> und fügen </font><i><font style="vertical-align: inherit;">Sie dort den </font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erfassten </font></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wert</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und die </font><i><font style="vertical-align: inherit;">rc_data hinzu</font></i><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir starten das Debuggen mit dem Befehl </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debug -&gt; Ausführen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und in Echtzeit, ohne auch nur Haltepunkte hinzuzufügen, werden wir sehen, wie sich die Zahlen nach den Bewegungen der Sticks ändern.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/files/5cf/7da/c9c/5cf7dac9c152498e89ea3948a8549efb.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Nächstes müssen Sie Daten in Form eines Joystick-Befehls an den Computer senden.</font></font><br>
<br>
<h3><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konfigurieren Sie das HID-Gerät und erstellen Sie den HID-Berichtsdeskriptor</font></font></b></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
USB HID (Human Interface Device) ist eine Klasse von Geräten für die Mensch-Computer-Interaktion. Dazu gehören Tastaturen, Mäuse, Joysticks, Gamepads und Touchpanels. Der Hauptvorteil von HID-Geräten besteht darin, dass sie in keinem Betriebssystem spezielle Treiber benötigen: Windows, OS X, Android und sogar iOS (über den USB-Lightning-Adapter). Eine ausführliche Beschreibung finden Sie im Dokument </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geräteklassendefinition für HID</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Das Wichtigste, was wir wissen müssen, um einen PPM-USB-Adapter zu erstellen, ist, was </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HID Report</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HID Report Descriptor sind</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das HID-Gerät sendet Bytepakete in einem vordefinierten Format an den Computer. Jedes dieser Pakete ist ein HID-Bericht. Das Gerät informiert den Computer über das Datenformat, wenn es eine Verbindung herstellt, und sendet einen HID-Berichtsdeskriptor, eine Paketbeschreibung, die angibt, wie viele Bytes das Paket enthält und welchen Zweck jedes Byte und Bit im Paket hat. Beispielsweise besteht der HID-Bericht einer einfachen Maus aus vier Bytes: Das erste Byte enthält Informationen zu den gedrückten Tasten, das zweite und dritte Byte enthalten die relative Bewegung des Cursors entlang X und Y und das vierte Byte enthält die Drehung des Scrollrads. Der Berichtsdeskriptor wird im Gerätesteuerungsspeicher als Array von Bytes gespeichert.</font></font><br>
<br>
<div style="text-align:center;"><img width="35%" src="https://habrastorage.org/files/22f/dd2/aa6/22fdd2aa67154365a6f89f6a2f7f2798.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor ich einen Deskriptor erstelle, möchte ich mich separat mit der Terminologie befassen. In der englischsprachigen Umgebung sind zwei Begriffe üblich - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Joystick</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gamepad</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Das Wort </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Joystick wird</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> normalerweise als Manipulator bezeichnet, der mit einer Hand gehalten und in verschiedene Richtungen geneigt wird. Das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gamepad</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist ein Gerät mit Tasten und Stöcken, das mit zwei Händen gehalten wird. Russisch sprechende Benutzer nennen den Joystick normalerweise sowohl diesen als auch einen anderen. In der Beschreibung des HID-Geräts gibt es einen Unterschied zwischen dem Joystick und dem Gamepad. Die Flugzeugmodellkonsole ähnelt in ihrem funktionalen Zweck eher einem Gamepad, daher werde ich in Zukunft manchmal den Begriff „Gamepad“ verwenden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben ein Projekt erstellt, das angibt, dass das Gerät als Human Interface Device fungiert. </font><font style="vertical-align: inherit;">Dies bedeutet, dass eine USB-HID-Bibliothek mit dem Projekt verbunden ist und bereits ein Geräte-Deskriptor generiert wurde. </font><font style="vertical-align: inherit;">Es befindet sich in der Datei </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usbd_hid.c</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , beschreibt </font><font style="vertical-align: inherit;">den </font><i><font style="vertical-align: inherit;">Mausbericht</font></i><font style="vertical-align: inherit;"> und sieht folgendermaßen aus:</font></font><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HID_Mouse_Report_Descriptor</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs">__ALIGN_BEGIN <span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> HID_MOUSE_ReportDesc[HID_MOUSE_REPORT_DESC_SIZE]  __ALIGN_END =<font></font>
{<font></font>
  <span class="hljs-number">0x05</span>,   <span class="hljs-number">0x01</span>,<font></font>
  <span class="hljs-number">0x09</span>,   <span class="hljs-number">0x02</span>,<font></font>
  <span class="hljs-number">0xA1</span>,   <span class="hljs-number">0x01</span>,<font></font>
  <span class="hljs-number">0x09</span>,   <span class="hljs-number">0x01</span>,<font></font>
<font></font>
  <span class="hljs-number">0xA1</span>,   <span class="hljs-number">0x00</span>,<font></font>
  <span class="hljs-number">0x05</span>,   <span class="hljs-number">0x09</span>,<font></font>
  <span class="hljs-number">0x19</span>,   <span class="hljs-number">0x01</span>,<font></font>
  <span class="hljs-number">0x29</span>,   <span class="hljs-number">0x03</span>,<font></font>
<font></font>
  <span class="hljs-number">0x15</span>,   <span class="hljs-number">0x00</span>,<font></font>
  <span class="hljs-number">0x25</span>,   <span class="hljs-number">0x01</span>,<font></font>
  <span class="hljs-number">0x95</span>,   <span class="hljs-number">0x03</span>,<font></font>
  <span class="hljs-number">0x75</span>,   <span class="hljs-number">0x01</span>,<font></font>
<font></font>
  <span class="hljs-number">0x81</span>,   <span class="hljs-number">0x02</span>,<font></font>
  <span class="hljs-number">0x95</span>,   <span class="hljs-number">0x01</span>,<font></font>
  <span class="hljs-number">0x75</span>,   <span class="hljs-number">0x05</span>,<font></font>
  <span class="hljs-number">0x81</span>,   <span class="hljs-number">0x01</span>,<font></font>
<font></font>
  <span class="hljs-number">0x05</span>,   <span class="hljs-number">0x01</span>,<font></font>
  <span class="hljs-number">0x09</span>,   <span class="hljs-number">0x30</span>,<font></font>
  <span class="hljs-number">0x09</span>,   <span class="hljs-number">0x31</span>,<font></font>
  <span class="hljs-number">0x09</span>,   <span class="hljs-number">0x38</span>,<font></font>
<font></font>
  <span class="hljs-number">0x15</span>,   <span class="hljs-number">0x81</span>,<font></font>
  <span class="hljs-number">0x25</span>,   <span class="hljs-number">0x7F</span>,<font></font>
  <span class="hljs-number">0x75</span>,   <span class="hljs-number">0x08</span>,<font></font>
  <span class="hljs-number">0x95</span>,   <span class="hljs-number">0x03</span>,<font></font>
<font></font>
  <span class="hljs-number">0x81</span>,   <span class="hljs-number">0x06</span>,<font></font>
  <span class="hljs-number">0xC0</span>,   <span class="hljs-number">0x09</span>,<font></font>
  <span class="hljs-number">0x3c</span>,   <span class="hljs-number">0x05</span>,<font></font>
  <span class="hljs-number">0xff</span>,   <span class="hljs-number">0x09</span>,<font></font>
<font></font>
  <span class="hljs-number">0x01</span>,   <span class="hljs-number">0x15</span>,<font></font>
  <span class="hljs-number">0x00</span>,   <span class="hljs-number">0x25</span>,<font></font>
  <span class="hljs-number">0x01</span>,   <span class="hljs-number">0x75</span>,<font></font>
  <span class="hljs-number">0x01</span>,   <span class="hljs-number">0x95</span>,<font></font>
<font></font>
  <span class="hljs-number">0x02</span>,   <span class="hljs-number">0xb1</span>,<font></font>
  <span class="hljs-number">0x22</span>,   <span class="hljs-number">0x75</span>,<font></font>
  <span class="hljs-number">0x06</span>,   <span class="hljs-number">0x95</span>,<font></font>
  <span class="hljs-number">0x01</span>,   <span class="hljs-number">0xb1</span>,<font></font>
<font></font>
  <span class="hljs-number">0x01</span>,   <span class="hljs-number">0xc0</span><font></font>
};<font></font>
</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das manuelle Erstellen des HID-Berichtsdeskriptors ist äußerst zeitaufwändig. </font><font style="vertical-align: inherit;">Um die Aufgabe zu erleichtern, gibt es ein Tool namens </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HID Descriptor Tool</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (DT). </font><font style="vertical-align: inherit;">Dieses Programm kann einen Deskriptor für Ihr Gerät erstellen. </font><font style="vertical-align: inherit;">Im Archiv finden Sie einige Beispiele für Deskriptoren für verschiedene Geräte.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/files/a3c/6fd/07c/a3c6fd07c997415ab94ba603edda628d.png"></div><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist ein</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sehr guter Artikel über das Erstellen eines eigenen HID-Deskriptors für Maus und Tastatur (auf Englisch). Ich werde Ihnen auf Russisch sagen, wie man einen Griff für ein Gamepad macht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der von der Konsole gesendete HID-Bericht muss vier 16-Bit-Werte für zwei Achsen von Analogsticks und 16 Ein-Bit-Werte für Tasten enthalten. Insgesamt 10 Bytes. Das in DT erstellte Handle sieht folgendermaßen aus:</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-number">0x05</span>, <span class="hljs-number">0x01</span>,                    <span class="hljs-comment">// USAGE_PAGE (Generic Desktop)</span><font></font>
    <span class="hljs-number">0x09</span>, <span class="hljs-number">0x05</span>,                    <span class="hljs-comment">// USAGE (Game Pad)</span><font></font>
    <span class="hljs-number">0xa1</span>, <span class="hljs-number">0x01</span>,                    <span class="hljs-comment">// COLLECTION (Application)</span><font></font>
    <span class="hljs-number">0x09</span>, <span class="hljs-number">0x01</span>,                    <span class="hljs-comment">//   USAGE (Pointer)</span><font></font>
    <span class="hljs-number">0xa1</span>, <span class="hljs-number">0x00</span>,                    <span class="hljs-comment">//   COLLECTION (Physical)</span><font></font>
    <span class="hljs-number">0x09</span>, <span class="hljs-number">0x30</span>,                    <span class="hljs-comment">//     USAGE (X)</span><font></font>
    <span class="hljs-number">0x09</span>, <span class="hljs-number">0x31</span>,                    <span class="hljs-comment">//     USAGE (Y)</span><font></font>
    <span class="hljs-number">0x15</span>, <span class="hljs-number">0x00</span>,                    <span class="hljs-comment">//     LOGICAL_MINIMUM (0)</span><font></font>
    <span class="hljs-number">0x26</span>, <span class="hljs-number">0xe8</span>, <span class="hljs-number">0x03</span>,              <span class="hljs-comment">//     LOGICAL_MAXIMUM (1000)</span><font></font>
    <span class="hljs-number">0x75</span>, <span class="hljs-number">0x10</span>,                    <span class="hljs-comment">//     REPORT_SIZE (16)</span><font></font>
    <span class="hljs-number">0x95</span>, <span class="hljs-number">0x02</span>,                    <span class="hljs-comment">//     REPORT_COUNT (2)</span><font></font>
    <span class="hljs-number">0x81</span>, <span class="hljs-number">0x02</span>,                    <span class="hljs-comment">//     INPUT (Data,Var,Abs)</span><font></font>
    <span class="hljs-number">0xc0</span>,                          <span class="hljs-comment">//   END_COLLECTION</span><font></font>
    <span class="hljs-number">0xa1</span>, <span class="hljs-number">0x00</span>,                    <span class="hljs-comment">//   COLLECTION (Physical)</span><font></font>
    <span class="hljs-number">0x09</span>, <span class="hljs-number">0x33</span>,                    <span class="hljs-comment">//     USAGE (Rx)</span><font></font>
    <span class="hljs-number">0x09</span>, <span class="hljs-number">0x34</span>,                    <span class="hljs-comment">//     USAGE (Ry)</span><font></font>
    <span class="hljs-number">0x15</span>, <span class="hljs-number">0x00</span>,                    <span class="hljs-comment">//     LOGICAL_MINIMUM (0)</span><font></font>
    <span class="hljs-number">0x26</span>, <span class="hljs-number">0xe8</span>, <span class="hljs-number">0x03</span>,              <span class="hljs-comment">//     LOGICAL_MAXIMUM (1000)</span><font></font>
    <span class="hljs-number">0x75</span>, <span class="hljs-number">0x10</span>,                    <span class="hljs-comment">//     REPORT_SIZE (16)</span><font></font>
    <span class="hljs-number">0x95</span>, <span class="hljs-number">0x02</span>,                    <span class="hljs-comment">//     REPORT_COUNT (2)</span><font></font>
    <span class="hljs-number">0x81</span>, <span class="hljs-number">0x02</span>,                    <span class="hljs-comment">//     INPUT (Data,Var,Abs)</span><font></font>
    <span class="hljs-number">0xc0</span>,                          <span class="hljs-comment">//   END_COLLECTION</span><font></font>
    <span class="hljs-number">0x05</span>, <span class="hljs-number">0x09</span>,                    <span class="hljs-comment">//   USAGE_PAGE (Button)</span><font></font>
    <span class="hljs-number">0x19</span>, <span class="hljs-number">0x01</span>,                    <span class="hljs-comment">//   USAGE_MINIMUM (Button 1)</span><font></font>
    <span class="hljs-number">0x29</span>, <span class="hljs-number">0x10</span>,                    <span class="hljs-comment">//   USAGE_MAXIMUM (Button 16)</span><font></font>
    <span class="hljs-number">0x15</span>, <span class="hljs-number">0x00</span>,                    <span class="hljs-comment">//   LOGICAL_MINIMUM (0)</span><font></font>
    <span class="hljs-number">0x25</span>, <span class="hljs-number">0x01</span>,                    <span class="hljs-comment">//   LOGICAL_MAXIMUM (1)</span><font></font>
    <span class="hljs-number">0x75</span>, <span class="hljs-number">0x01</span>,                    <span class="hljs-comment">//   REPORT_SIZE (1)</span><font></font>
    <span class="hljs-number">0x95</span>, <span class="hljs-number">0x10</span>,                    <span class="hljs-comment">//   REPORT_COUNT (16)</span><font></font>
    <span class="hljs-number">0x81</span>, <span class="hljs-number">0x02</span>,                    <span class="hljs-comment">//   INPUT (Data,Var,Abs)</span><font></font>
    <span class="hljs-number">0xc0</span>                           <span class="hljs-comment">// END_COLLECTION</span><font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es sieht nicht weniger einschüchternd aus als ein Mausdeskriptor. </font><font style="vertical-align: inherit;">Wenn Sie jedoch verstehen, was jede Zeile bedeutet, ist alles verständlich und logisch. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
USAGE zeigt, wie das System Daten interpretieren soll, die weiter gehen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt viele Verwendungsarten, sie sind in Gruppen sortiert - Verwendungsseiten. </font><font style="vertical-align: inherit;">Um eine bestimmte Verwendung auszuwählen, müssen Sie daher zunächst auf die entsprechende USAGE_PAGE verweisen. </font><font style="vertical-align: inherit;">Informationen zur Verwendung finden Sie im Dokument </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versteckte Verwendungstabellen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ganz am Anfang des Deskriptors geben wir an, dass der Joystick beschrieben wird:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">USAGE_PAGE (generischer Desktop) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
USAGE (Game Pad)</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
COLLECTION kombiniert mehrere verwandte Datensätze. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die physische Sammlung wird für Daten verwendet, die sich auf einen bestimmten geometrischen Punkt beziehen, z. B. einen analogen Stick. </font><font style="vertical-align: inherit;">Die Anwendungssammlung wird verwendet, um verschiedene Funktionen in einem Gerät zu kombinieren. </font><font style="vertical-align: inherit;">Beispielsweise kann eine Tastatur mit einem integrierten Trackpad zwei Anwendungssammlungen haben. </font><font style="vertical-align: inherit;">Wir beschreiben nur den Joystick, was bedeutet, dass die Sammlung eine sein wird:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COLLECTION (Anwendung) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
END_COLLECTION</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Danach müssen Sie angeben, dass die Elemente, die die Koordinaten übertragen, beschrieben werden. </font><font style="vertical-align: inherit;">Der Verwendungszeiger beschreibt Mäuse, Joysticks, Gamepads und Digitalisierer:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VERWENDUNG (Zeiger)</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Folgenden finden Sie Beschreibungen von analogen Sticks, die in einer Sammlung zusammengefasst sind:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SAMMLUNG (physisch)</font></font><br>
 <blockquote>USAGE (X)<br>
 USAGE (Y)<br>
 LOGICAL_MINIMUM (0)<br>
 LOGICAL_MAXIMUM (1000)<br>
 REPORT_SIZE (16)<br>
 REPORT_COUNT (2)<br>
 INPUT (Data,Var,Abs)</blockquote>END_COLLECTION</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
USAGE gibt hier an, dass die Abweichungswerte entlang der beiden Achsen X und Y </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
verwendet werden </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">LOGICAL_MINIMUM und LOGICAL_MAXIMUM geben an, inwieweit der übertragene Wert variieren kann. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
REPORT_COUNT und REPORT_SIZE legen jeweils fest, wie viele Zahlen und welche Größe übertragen werden sollen, nämlich zwei 16-Bit-Zahlen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
INPUT (Data, Var, Abs) bedeutet, dass die Daten vom Gerät zum Computer gelangen und sich ändern können. Die Werte in unserem Fall sind absolut. Beispielsweise kommen relative Werte von der Maus, um den Cursor zu bewegen. Manchmal werden Daten als Const beschrieben, nicht als Var. Dies ist notwendig, um nicht signifikante Bits zu übertragen. Beispielsweise werden in einem Mausbericht mit drei Schaltflächen 3 Bit Var für Schaltflächen und 5 Bit Const übertragen, um die Übertragungsgröße auf ein Byte zu ergänzen.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen können, sind die Beschreibungen der X- und Y-Achse zusammengefasst. </font><font style="vertical-align: inherit;">Sie haben die gleiche Größe, die gleichen Grenzen. </font><font style="vertical-align: inherit;">Der gleiche analoge Stick könnte wie folgt beschrieben werden, wobei jede Achse einzeln beschrieben wird. </font><font style="vertical-align: inherit;">Ein solcher Deskriptor funktioniert ähnlich wie der vorherige:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SAMMLUNG (physisch)</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VERWENDUNG (X) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 LOGICAL_MINIMUM (0) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 LOGICAL_MAXIMUM (1000) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 REPORT_SIZE (16) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 REPORT_COUNT (1) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 EINGABE (Daten, Var, Abs)</font></font></blockquote><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VERWENDUNG (Y) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 LOGICAL_MINIMUM (0) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 LOGICAL_MAXIMUM (1000) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 REPORT_SIZE (16) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 REPORT_COUNT (1) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 EINGABE (Daten, Var, Abs)</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">END_COLLECTION</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem ersten Stick wird der zweite analoge Stick beschrieben. </font><font style="vertical-align: inherit;">Seine Achsen haben eine andere Verwendung, so dass Sie sie vom ersten Stick unterscheiden können - Rx und Ry:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SAMMLUNG (physisch)</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VERWENDUNG (Rx) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 VERWENDUNG (Ry) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 LOGICAL_MINIMUM (0) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 LOGICAL_MAXIMUM (1000) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 REPORT_SIZE (16) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 REPORT_COUNT (2) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 EINGABE (Daten, Var, Abs)</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">END_COLLECTION</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun müssen Sie einige Schaltflächen des Gamepads beschreiben. </font><font style="vertical-align: inherit;">Dies kann wie folgt erfolgen:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">USAGE_PAGE (Schaltfläche) USAGE (Schaltfläche </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1) </font><font style="vertical-align: inherit;">USAGE (Schaltfläche </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2) </font><font style="vertical-align: inherit;">USAGE (Schaltfläche </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
USAGE (Schaltfläche 16)</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die umständliche Aufzeichnung von Schaltflächen desselben Typs kann mithilfe des Verwendungsbereichs reduziert werden:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">USAGE_PAGE (Schaltfläche) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
USAGE_MINIMUM (Schaltfläche 1) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
USAGE_MAXIMUM (Schaltfläche 16)</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die von den Tasten übertragenen Daten sind 16 Einzelbitwerte, die von 0 bis 1 variieren:</font></font><br>
<blockquote>LOGICAL_MINIMUM (0)<br>
LOGICAL_MAXIMUM (1)<br>
REPORT_SIZE (1)<br>
REPORT_COUNT (16)<br>
INPUT (Data,Var,Abs)</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Reihenfolge der Zeilen im Deskriptor ist nicht streng. Beispielsweise können Logical_Minimum und Logical_Maximum vor der Verwendung (Schaltfläche) geschrieben oder die Zeilen Report_Size und Report_Count ausgetauscht werden. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist wichtig, dass der Eingabebefehl alle erforderlichen Parameter für die Datenübertragung enthält (Verwendung, Minimum, Maximum, Größe, Anzahl). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Deskriptor gebildet wird, kann er mit dem Befehl </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deskriptor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> analysieren </font><font style="vertical-align: inherit;">auf Fehler </font><font style="vertical-align: inherit;">überprüft </font><font style="vertical-align: inherit;">werden. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn alles in Ordnung ist, exportieren Sie es mit der Erweiterung h. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ersetzen Sie in der</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Datei </font><i><font style="vertical-align: inherit;">usbd_hid.c</font></i><font style="vertical-align: inherit;"> den Deskriptor durch einen neuen und passen Sie in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usbd_hid.h die</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Größe des Deskriptors </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HID_MOUSE_REPORT_DESC_SIZE</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von 74 auf 61 an. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berichte werden mit dem Flag </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data_ready</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gesendet </font><font style="vertical-align: inherit;">. Dafür zu</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.c wird</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Header-Datei </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usbd_hid.h einschließen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und in der Hauptschleife die Funktion zum Senden von Berichten aufrufen. </font><font style="vertical-align: inherit;">Das Array </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rc_data</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist vom Typ uint16, daher muss der Zeiger darauf in einen 8-Bit-Typ umgewandelt werden und die Größe 10 anstelle von 5 übergeben.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"usbd_hid.h"</span></span><font></font>
...<font></font>
<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<font></font>
{<font></font>
  <span class="hljs-keyword">if</span> (data_ready)<font></font>
  {<font></font>
    USBD_HID_SendReport(&amp;hUsbDeviceFS, (<span class="hljs-keyword">uint8_t</span>*)rc_data, <span class="hljs-number">10</span>);<font></font>
    data_ready = <span class="hljs-number">0</span>;<font></font>
  };<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir kompilieren das Projekt und flashen es erneut.</font></font><br>
<br>
<h3><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anschluss und Verwendung</font></font></b></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schließen Sie das USB-Kabel vom ST-LINK-USB-Anschluss wieder an den USER-USB-Anschluss an. </font><font style="vertical-align: inherit;">Windows erkennt das neue Gerät und installiert den Treiber automatisch. </font><font style="vertical-align: inherit;">Gehen wir zur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Systemsteuerung -&gt; Geräte und Drucker</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und sehen unser STM32 USB-PPM-Adaptergerät mit einem Gamepad-Symbol.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/files/1ee/5ad/846/1ee5ad84654545dfbcec807073ef8207.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den Geräteparametern können Sie sehen, wie sich das Kreuz um das Feld bewegt und wie sich die Spalten bewegen, nachdem die Sticks bewegt wurden, und die Schaltflächensymbole leuchten am Kippschalter auf. </font><font style="vertical-align: inherit;">Eine Kalibrierung ist nicht erforderlich, da die Minimal- und Maximalwerte bereits im Deskriptor festgelegt wurden.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/files/52c/4b0/9db/52c4b09db3074871b917aa74b3375de6.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Starten von FPV FreeRider sehen wir, wie sich die Sticks auf dem Hauptbildschirm des gezeichneten virtuellen Gamepads gemäß unserer Fernbedienung bewegen. </font><font style="vertical-align: inherit;">Wenn die Achsen aus irgendeinem Grund nicht richtig zugewiesen sind, können Sie sie im Abschnitt </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Controller kalibrieren</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> neu konfigurieren </font><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit den Kippschaltern, die den Tasten auf der Fernbedienung entsprechen, können Sie den Flugmodus (akrobatisch / stabilisiert) wechseln, die Kameraansicht (vom Brett / vom Boden aus) wechseln, einen Flug von Anfang an starten oder das Rennen für eine Weile einschalten.</font></font><br>
<br>
<div style="text-align:center;"><img width="70%" src="https://habrastorage.org/files/153/bc2/3a8/153bc23a87bd4fedad1dd9b04c2aae22.png"></div><br>
<br>
<h3><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geflogen!</font></font></b></h3><br>
<iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://www.youtube.com/embed/ilMeTba4EOE%3Ffeature%3Doembed&amp;usg=ALkJrhh0TgSByuvnQrzwl9k1JrvfT0mT4Q" frameborder="0" allowfullscreen=""></iframe><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf dem Video - das Ergebnis mehrerer Tage meines Trainings. Während ich mit Auto-Leveling fliege und nicht im akrobatischen Modus, wie es alle Meister des FPV-Rennsports tun. Wenn Sie im Akro-Modus die Sticks loslassen, kehrt der Copter nicht automatisch in die horizontale Position zurück, sondern fliegt im gleichen Winkel weiter, in dem er geflogen ist. Das Verwalten im Akro-Modus ist viel schwieriger, aber Sie können eine höhere Geschwindigkeit und Manövrierfähigkeit erreichen, Umwälzungen in der Luft vornehmen und sogar verkehrt herum fliegen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zu den </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Charpu-Meistern</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich bin noch sehr weit weg, aber ich trainiere weiter und ich kann mit Sicherheit sagen, dass mich die Idee eines Renn-Mini-Copter noch mehr interessiert hat. </font><font style="vertical-align: inherit;">Und bald werde ich definitiv mit dem Bau und den Flügen nicht mehr im Simulator beschäftigt sein, sondern in der harten Realität, mit echten Abstürzen, kaputten Propellern, kaputten Motoren und ausgebrannten Batterien. </font><font style="vertical-align: inherit;">Aber das ist ein Thema für andere Artikel :)</font></font><br>
<br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Projekt für Keil uVision 5 und STM32CubeMX ist auf </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de384813/">https://habr.com/ru/post/de384813/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de384801/index.html">Letzter Tag in Pompeji: Italienische Wissenschaftler haben die Überreste der Opfer der Katastrophe gescannt</a></li>
<li><a href="../de384803/index.html">Paul Graham: Ideen für ein Bio-Startup</a></li>
<li><a href="../de384805/index.html">IFixit-Spezialisten reißen AppleTV ab und Apple deinstalliert die iFixit-App aus dem AppStore</a></li>
<li><a href="../de384809/index.html">Papier oder "Nummer"? Beides: Überprüfung des NeoLAB Convergence Neo Smartpen N2 Smart Pen</a></li>
<li><a href="../de384811/index.html">Gutachten: Halbleitermaterialien in der Elektronik</a></li>
<li><a href="../de384815/index.html">Telefone für Kindersicherheit und elterlichen Frieden: bb-mobile Nachrichten</a></li>
<li><a href="../de384817/index.html">Tausende von Apollo-Fotos wurden auf Flickr hochgeladen</a></li>
<li><a href="../de384819/index.html">Вместо того, чтобы «не быть злом» «Google» теперь «делает правильные вещи»</a></li>
<li><a href="../de384821/index.html">Der Student stellte einen Handschuh vor, mit dem Menschen mit Sprachstörungen kommunizieren können</a></li>
<li><a href="../de384823/index.html">Nicht standardisierte Möglichkeiten zur Förderung von Handyspielen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>