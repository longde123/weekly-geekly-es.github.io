<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèõÔ∏è ‚ÜóÔ∏è üë≤üèæ Pedal to the floor: crea otro manipulador de pies para PC üôÉ ‚úñÔ∏è üöµüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hace apenas un mes, me encontr√© con este art√≠culo, que habla sobre pedalear a Vim. Un poco m√°s tarde, despu√©s de mi largo estudio de tres minutos, des...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pedal to the floor: crea otro manipulador de pies para PC</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462263/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/y3/4b/ju/y34bjuvl5jcdfxml6kgtlpgkdy4.png"></div><br>  Hace apenas un mes, me encontr√© con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> art√≠culo, que habla sobre pedalear a Vim.  Un poco m√°s tarde, despu√©s de mi largo estudio de tres minutos, descubr√≠ que este tema ya no es nuevo y bastante popular.  Yo mismo uso Vim solo en caso de emergencia (si tengo que trabajar en la consola, prefiero Nano), pero puede hacer lo mismo para otras aplicaciones. <br><a name="habracut"></a><br>  Inicialmente, quer√≠a hacer un peque√±o art√≠culo, pero obtuve un tutorial completo sobre c√≥mo crear este dispositivo con escritura de c√≥digo paso a paso y una explicaci√≥n de qu√© y c√≥mo.  Para no inflar el art√≠culo, debajo de los spoilers habr√° diversa informaci√≥n que parec√≠a interesante y digna de la atenci√≥n de los reci√©n llegados a Arduino, los usuarios avanzados y especialmente apresurados pueden no perder el tiempo en eso.  El c√≥digo fuente completo tambi√©n se presenta al final del art√≠culo. <br><br><h2>  ¬øPor qu√© lo necesito? </h2><br>  Si no tiene dudas sobre la necesidad y la utilidad de este dispositivo, puede omitir este elemento.  Por lo dem√°s, primero me gustar√≠a hablar sobre los requisitos previos para crear este dispositivo. <br><br>  En todo momento, los programadores y dise√±adores han intentado crear una interfaz conveniente y f√°cil de usar para que el usuario pueda trabajar con la aplicaci√≥n usando el mouse y el teclado sin problemas innecesarios, entonces, ¬øpor qu√© necesitamos otro manipulador?  Bueno, echemos un vistazo a la historia, o m√°s bien, a principios del siglo XVIII, cuando se invent√≥ un instrumento musical como el piano.  Como saben, esta palabra se traduce literalmente como "alto y silencioso", pero pocas personas piensan que un maestro italiano inteligente recibi√≥ tal instrumento, en realidad "aprovechando" el clavec√≠n que exist√≠a en ese momento, lo que hizo posible controlar en cierta medida el volumen del sonido, sin quitando las manos de las llaves. <br><br>  Hay muchos ejemplos  El autom√≥vil tiene pedales para no tirar el volante si necesita agregar gasolina.  El kit de bater√≠a tambi√©n tiene pedales para tocar el bombo y los platillos.  ¬øY qu√© pueden dar los pedales al usar una computadora?  Bueno, por ejemplo, puede configurar alguna combinaci√≥n de teclas de acceso r√°pido, o incluso agregar una tecla que no est√° all√≠, como activar y desactivar el sonido.  Los pedales pueden ayudar si sus manos est√°n ocupadas: toco la guitarra yo mismo y, a veces, para el acompa√±amiento, ser√≠a muy conveniente para m√≠ rodar el respaldo sin tratar de alcanzar constantemente el teclado.  Y finalmente, los controladores pueden dar posibilidades completamente inhumanas en los juegos: ser√≠a genial construir toda tu base en una estrategia con un solo clic o destruir enemigos a una velocidad de una docena de latidos por segundo en tiradores, ¬øverdad? <br><br>  En general, espero haberte convencido, lo que significa que es hora de comenzar directamente con el desarrollo en s√≠. <br><br><h2>  Recursos requeridos </h2><br><ul><li>  <b>En realidad, los pedales.</b>  Algunas dificultades surgieron inmediatamente debido al hecho de que no pod√≠a pensar en un nombre para tal pedal.  Solo sab√≠a que tales cosas se usan en m√°quinas de coser.  En general, a pedido del <b>pedal el√©ctrico,</b> a√∫n pude encontrar lo que necesitaba en Aliexpress, y sin pensarlo dos veces, ped√≠ 3 piezas. <br></li><li>  <b>Controlador</b>  La pedalera debe emular el teclado y, posiblemente, el mouse para poder conectarse a una PC sin controladores innecesarios.  Para esto, la placa Arduino Pro Micro es perfecta, que, aunque no tiene algunas conclusiones, est√° hecha lo m√°s compacta posible.  Vamos al mismo Aliexpress y compramos la versi√≥n china de este milagro. <br></li><li>  <b>Alambres</b>  Para colocar 3 pedales debajo de la mesa, necesita al menos un cable de cuatro hilos con una longitud de al menos un metro.  Aqu√≠, creo, no deber√≠an surgir problemas. <br></li><li>  <b>LED RGB y bot√≥n.</b>  El primero es necesario para indicar los modos, y el segundo es cambiarlos. <br></li><li>  Bueno, por supuesto, necesitamos un IDE Arduino, un soldador y brazos rectos. <br></li></ul><br><h2>  Diagrama del dispositivo </h2><br>  Incluso antes de que llegaran los paquetes, comenc√© a crear un diagrama de dispositivo.  Aunque esto se dice mucho, ya que solo tuve que conectar los pedales, el diodo y el bot√≥n.  Result√≥ de alguna manera as√≠: <br><br><img src="https://habrastorage.org/webt/7m/o8/yw/7mo8ywvzsfwlefxt7f-4ijqtejm.jpeg"><br><br>  Para los pedales, decid√≠ asignar 4 puertos PB1-PB4 a la vez, es decir, dos para la pierna izquierda y dos para la pierna derecha, aunque hasta ahora solo tengo 3 pedales. Adem√°s, todos est√°n en el mismo grupo y est√°n ubicados en un solo lugar.  Debajo del LED, tom√© las salidas PD0, PD1 y PD4, debajo del bot√≥n - PD7. <br>  En este caso, no necesitamos resistencias pull-up, si usa las que est√°n integradas en el controlador.  Sin embargo, cuando presione un bot√≥n o pedal, la entrada ser√° baja, y cuando se suelte, ser√° alta, es decir, las prensas se invertir√°n, y no debe olvidarse de esto. <br><br><h2>  Escritura de c√≥digo </h2><br>  Esta etapa fue la m√°s dif√≠cil: debido a un par de errores en los punteros, borr√© el gestor de arranque varias veces y, como resultado, casi fall√© la placa a nivel de software.  A continuaci√≥n se describen en detalle todas las etapas de la creaci√≥n del firmware, para aquellos que solo quieren obtener un c√≥digo de trabajo, ser√° al final del art√≠culo. <br><br><h3>  Preparaci√≥n </h3><br>  Primero necesitamos entender qu√© es el pedal en t√©rminos del programa.  Decid√≠ hacer posible configurar los pedales de uno de los dos modos: en tiempo real y disparador.  Al mismo tiempo, cada pedal tiene dos programas: el primero se realiza cuando el pedal se mantiene en tiempo real o con presiones extra√±as en el modo de disparo, el segundo es cuando el pedal se suelta en tiempo real o cuando los pedales se presionan de manera uniforme en el modo de disparo.  El pedal tambi√©n tiene un puerto, un estado y dos variables: las posiciones actuales en los programas 1 y 2. Obtuve esta estructura: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> port; <span class="hljs-comment"><span class="hljs-comment">//   char state; //  ,   char oldState; //  ,   char pos1; //  1 char pos2; //  2 unsigned char type; //0 ‚Äî   , 1 ‚Äî  ; unsigned char act1[16]; // 1 unsigned char act2[16]; // 2 };</span></span></code> </pre> <br>  Arduino tiene bastante memoria y tambi√©n es de 8 bits, por lo que es mejor intentar usar char en lugar de int cuando sea posible. <br><br>  Tambi√©n necesitamos la biblioteca de teclado est√°ndar para funcionar como teclado. <br><br><h3>  Procesamiento de clics </h3><br>  Ahora necesitamos hacer un int√©rprete que lea los datos de la matriz y los env√≠e en forma de pulsaciones de teclas a la m√°quina, as√≠ como seleccionar varios valores para varios comandos internos.  Abrimos la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">p√°gina</a> con los c√≥digos clave y vemos qu√© y c√≥mo podemos hacer clic.  No profundic√© y estudi√© todo tipo de est√°ndares de teclado, ya que la informaci√≥n aqu√≠ me pareci√≥ suficiente para tal proyecto.  La primera mitad est√° reservada para caracteres ASCII est√°ndar (aunque algunos de ellos no se pueden imprimir o no se usan), la segunda mitad es para varias teclas modificadoras.  Incluso hay c√≥digos separados para las teclas izquierda y derecha, lo cual es muy agradable, pero no vi ning√∫n c√≥digo especial para los n√∫meros del nampad, aunque, hasta donde yo s√©, se perciben de una manera especial en el sistema que los n√∫meros ordinarios.  Quiz√°s sus c√≥digos est√°n en alg√∫n lugar en los "agujeros", entre los rangos, pero ahora no se trata de eso.  Entonces, el c√≥digo m√°s grande es la tecla arriba: 218, lo que significa que el rango 219-255 puede considerarse libre, bueno, o al menos no hay teclas importantes. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pedalAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//255  ,     if (pedal1-&gt;type == 255) return; //     unsigned char *prg; //     char *pos; if (pedal1-&gt;type) { //       int current; if ((current = digitalRead(ports[num])) != oldState[num]) { if (!current) state[num] = !state[num]; oldState[num] = current; } if (!state[num]) { //act1 pos2[num] = 0; pos = &amp;(pos1[num]); prg = pedal1-&gt;act1; } else { //act2 pos1[num] = 0; pos = &amp;(pos2[num]); prg = pedal1-&gt;act2; } } else { //        if (!digitalRead(ports[num])) { //act1 pos2[num] = 0; pos = &amp;(pos1[num]); prg = pedal1-&gt;act1; } else { //act2 pos1[num] = 0; pos = &amp;(pos2[num]); prg = pedal1-&gt;act2; } } while (1) { if (prg[*pos] == 254) { // ,   *pos Keyboard.press(prg[++*pos]); } else if (prg[*pos] == 253) { // ,   *pos Keyboard.release(prg[++*pos]); } else if (prg[*pos] == 252) { //" ",    ++*pos; return; } else if (prg[*pos] == 251) { //       *pos+1 *pos = prg[*pos + 1]; return; } else if (prg[*pos] == 255 || prg[*pos] == 0) { // ,   return; } else { //   Keyboard.write(prg[*pos]); } //       ,     if (++*pos&gt;=16) pos = 0; } }</span></span></code> </pre><br>  Creo que incluso una persona que no tenga el m√°s alto nivel de conocimiento de C no tendr√° preguntas sobre lo que est√° sucediendo aqu√≠.  Primero, la funci√≥n selecciona el pedal deseado y determina, dependiendo del modo y la condici√≥n del pedal, qu√© programa se debe realizar.  Al leer cada elemento de la matriz, si no es un car√°cter de control, se llama a la funci√≥n Keyboard.write (), que emula al presionar y soltar una tecla.  Los caracteres de control se procesan por separado y son necesarios para sujetar las combinaciones de teclas y navegar por el programa. <br><br><div class="spoiler">  <b class="spoiler_title">Algunas caracter√≠sticas del modo teclado</b> <div class="spoiler_text">  Keyboard.write () tiene algunos matices simples, pero no obvios para principiantes, basados ‚Äã‚Äãen el hecho de que enviamos datos no en forma cruda, sino como pulsaciones de teclas.  En primer lugar, por extra√±o que parezca, sin controladores adicionales, la computadora solo puede aceptar caracteres del teclado que est√°n en el teclado, lo que significa que no podremos enviar ning√∫n 0x03 (se√±al de interrupci√≥n) o 0x1B (comienzo de la secuencia ESCAPE).  En segundo lugar, podemos ajustar las letras may√∫sculas tal como est√°n en la tabla ASCII, pero la m√°quina obtendr√° la combinaci√≥n de teclas May√∫s + &lt;letra min√∫scula&gt;.  Esto puede convertirse en un problema si tenemos CapsLock habilitado y recibiremos "inesperadamente" letras peque√±as en lugar de letras grandes y viceversa.  En tercer lugar, no podemos usar el idioma ruso, as√≠ como en cualquier otro idioma.  Esto sucede nuevamente debido a cosas tan molestas como <b>los c√≥digos clave</b> .  Aunque Keyboard.write () lo acepta como argumento, el c√≥digo USB a√∫n env√≠a el c√≥digo correspondiente a la clave en la que est√° en el dise√±o est√°ndar en ingl√©s, y si intentamos enviar el alfabeto cir√≠lico, no sabremos qu√©.  Por lo tanto, si queremos saludar a nuestros amigos de habla rusa a trav√©s de Arduino, entonces en el c√≥digo debemos escribir "Ghbdtn", y luego enviarlo, despu√©s de seleccionar el dise√±o en ruso.  Tal "saludo" funcionar√° en el dise√±o ucraniano, pero en b√∫lgaro, a pesar del hecho de que tambi√©n hay un alfabeto cir√≠lico, no saldr√° nada de √©l, ya que las letras est√°n en lugares completamente diferentes.  (Una vez escuch√© la opini√≥n de que para muchos desarrolladores estadounidenses e ingleses es incomprensible que alguien incluso necesite usar varios dise√±os, pero tambi√©n cambiarlos). <br></div></div><br>  Entonces, tenemos un int√©rprete y una comprensi√≥n aproximada de c√≥mo nuestra pedalera interact√∫a con una computadora.  Ahora necesitamos llevar todo esto al estado de firmware completo y verificar el rendimiento en un pedal.  Si crea una instancia del pedal y llama c√≠clicamente pedalAction (), en teor√≠a ejecutaremos el programa especificado en la estructura. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal1</span></span></span><span class="hljs-class"> = {</span></span><span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Hello, world!\0"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ pinMode(<span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">//2 - INPUT_PULLUP,        Keyboard.begin(); } void loop() { pedalAction(); }</span></span></code> </pre><br>  Por cierto, nunca se olvide de los terminadores nulos en estos "programas" si su longitud es menor que el tama√±o de la matriz y si no son c√≠clicos, porque Arduino no solo intentar√° interpretar los datos que no se especifican, sino que tambi√©n los enviar√° a la m√°quina con gran velocidad, y eso es lo mismo que darle un teclado a un mono. <br><br><h3>  Un pedal es bueno y dos son mejores. </h3><br>  Ahora es el momento de tratar el procesamiento de se√±ales de varios pedales, as√≠ como agregar modos de conmutaci√≥n.  Al comienzo del art√≠culo, se asignaron 4 puertos para pedales, cada uno de los cuales debe poder trabajar en siete modos.  ¬øPor qu√© 7?  Porque sin usar PWM, nuestro LED puede dar solo 7 colores y el octavo apagado.  Esta cantidad es suficiente para el usuario promedio, pero en casos extremos se puede aumentar f√°cilmente.  Por lo tanto, almacenaremos los pedales en una matriz bidimensional de 7 x 4. Para no obstruir la memoria, los valores comunes a varias estructuras, como el n√∫mero de puerto, se pueden extraer en matrices separadas.  Como resultado, obtenemos algo como esto: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> type; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> act1[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> act2[<span class="hljs-number"><span class="hljs-number">16</span></span>]; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedals</span></span></span><span class="hljs-class">[7][4] = {</span></span> { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-string"><span class="hljs-string">"Hello, world!\0"</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} }, { { <span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}}, {<span class="hljs-number"><span class="hljs-number">255</span></span>, {<span class="hljs-number"><span class="hljs-number">255</span></span>}, {<span class="hljs-number"><span class="hljs-number">255</span></span>}} } }; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ports[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> pos1[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> pos2[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> state[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> oldState[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> mode = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  char curPedal = 0; //  </span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">La magia del n√∫mero 255.</b> <div class="spoiler_text">  Probablemente not√≥ que en el art√≠culo aparece a menudo el n√∫mero 255, donde ser√≠a m√°s l√≥gico poner 0. Mirando hacia el futuro, dir√© que esto es necesario para la comodidad de almacenar pedales en EEPROM, ya que desde la f√°brica cada una de sus celdas no contiene 0, pero solo 255, lo que significa que este n√∫mero ser√° mucho m√°s conveniente de usar para indicar variables indefinidas que 0, de modo que no sobrescriba la memoria cada vez. <br></div></div><br>  Es importante para nosotros conocer solo el tipo de pedal y dos programas, por lo que los dejaremos solo directamente en la estructura, dejaremos que la automatizaci√≥n haga el resto.  Los m√©todos de preparaci√≥n y bucle ahora se ver√°n as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ pinMode(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); pinMode(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); pinMode(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); pinMode(<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i : ports) pinMode(i, <span class="hljs-number"><span class="hljs-number">2</span></span>); Keyboard.begin(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">6</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> current; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((current = digitalRead(modeButton)) != last) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++mode &gt;= <span class="hljs-number"><span class="hljs-number">7</span></span>) mode = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (pedals[mode][<span class="hljs-number"><span class="hljs-number">0</span></span>].type == <span class="hljs-number"><span class="hljs-number">255</span></span> &amp;&amp; pedals[mode][<span class="hljs-number"><span class="hljs-number">1</span></span>].type == <span class="hljs-number"><span class="hljs-number">255</span></span> &amp;&amp; pedals[mode][<span class="hljs-number"><span class="hljs-number">2</span></span>].type == <span class="hljs-number"><span class="hljs-number">255</span></span> &amp;&amp; pedals[mode][<span class="hljs-number"><span class="hljs-number">3</span></span>].type == <span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++mode &gt;= <span class="hljs-number"><span class="hljs-number">7</span></span>) { mode = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } last = current; digitalWrite(<span class="hljs-number"><span class="hljs-number">2</span></span>, (mode + <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0b001</span></span>); digitalWrite(<span class="hljs-number"><span class="hljs-number">3</span></span>, (mode + <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0b010</span></span>); digitalWrite(<span class="hljs-number"><span class="hljs-number">4</span></span>, (mode + <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0b100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { pos1[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; pos2[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; state[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; oldState[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } delay(<span class="hljs-number"><span class="hljs-number">50</span></span>); } curPedal = i; pedalAction } } }</code> </pre><br>  El controlador considerar√° el modo no utilizado si no se declara un solo pedal en √©l (modo = 255), lo que significa que cuando lo golpea, pasar√° inmediatamente al siguiente, pero el primer modo siempre existir√°.  Al cambiar el modo, todos los valores en las matrices se anulan, ya que no es necesario guardarlos para cada modo (¬øverdad?), Y luego el bucle omite todos los pedales y llama a pedalAction por ellos. <br><br>  Adem√°s, al comienzo del m√©todo pedalAction (), debe agregar la siguiente l√≠nea para que comprenda con qu√© estructuras tratar: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal1</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedals</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mode</span></span></span><span class="hljs-class">][</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">curPedal</span></span></span><span class="hljs-class">];</span></span></code> </pre><br>  La estructura existente del pedal1 se puede eliminar como innecesaria. <br><br>  Todo esto tambi√©n funciona bastante bien, sin embargo, encontr√© un problema: algunos programas no tienen tiempo para recibir clics a la velocidad con la que Arduino los env√≠a.  La soluci√≥n m√°s obvia es agregar la capacidad de establecer demoras entre acciones cuando sea necesario.  Solo cuando nos sentamos a escribir programas para microcontroladores, todos los chips, como el subprocesamiento m√∫ltiple de hardware, permanecieron en alg√∫n lugar, en computadoras de alto nivel, cuando agregamos un retraso, todo el programa se detiene hasta que el controlador cuenta el n√∫mero correcto de ciclos.  Como no tenemos subprocesos m√∫ltiples, tendremos que crearlo. <br><br><h3>  Dif√≠cil de decir que s√≠ f√°cil de hacer </h3><br>  No invent√© una bicicleta, pero tom√© la biblioteca ArduinoThread terminada.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aqu√≠</a> puedes leer un poco sobre c√≥mo funciona y descargarlo.  Puede descargar la biblioteca desde el propio IDE de Arduino.  En resumen, le permite realizar peri√≥dicamente una funci√≥n con un cierto intervalo, mientras que no le permite entrar en un bucle infinito si la ejecuci√≥n lleva m√°s tiempo que el intervalo.  Lo que necesitas  Cree otra matriz con hilos para cada pedal: <br><br><pre> <code class="cpp hljs">Thread pedalThreads[<span class="hljs-number"><span class="hljs-number">6</span></span>] = {Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>), Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>), Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>), Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>), Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>), Thread(pedalAction, <span class="hljs-number"><span class="hljs-number">10</span></span>)};</code> </pre><br>  Ahora tenemos 6 hilos virtuales id√©nticos, pero al mismo tiempo son objetos diferentes. <br><br>  Reescribamos el ciclo de derivaci√≥n del pedal para que funcione con la nueva funcionalidad: <br><br><pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pedalThreads[i].shouldRun()) { curPedal = i; pedalThreads[i].run(); } } ...</code> </pre><br>  Ahora el valor 252 en la matriz del programa, que corresponde a "no hacer nada", dar√° un retraso de 10 milisegundos (aunque en realidad un poco m√°s, ya que la ejecuci√≥n del c√≥digo tambi√©n lleva tiempo).  Agregar algunas l√≠neas al int√©rprete permitir√° establecer el retraso en varios de estos "cuantos", gastando solo 2 bytes de la matriz: <br><br><pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wait[num]) { wait[num]--; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prg[*pos] == <span class="hljs-number"><span class="hljs-number">250</span></span>) { wait[num] = prg[++*pos]; } ...</code> </pre><br>  A diferencia de otros comandos, esta instrucci√≥n debe agregarse exactamente al comienzo del int√©rprete, es decir, inmediatamente despu√©s de "while (1) {", ya que el retraso debe procesarse antes de que el int√©rprete contin√∫e leyendo el programa.  La matriz de espera debe declararse de la misma manera que se hizo con puertos, estado, etc.  y tambi√©n restablece sus celdas cuando cambia el modo, para que el retraso no pase a otro programa. <br><br>  Ahora, con la posibilidad de establecer el retraso en 2.55 segundos, no deber√≠an surgir problemas con la definici√≥n de teclas por programas. <br><br><h3>  Programaci√≥n sobre la marcha </h3><br>  En principio, aqu√≠ ser√≠a posible terminar con el c√≥digo y comenzar a ensamblar el dispositivo, pero en este caso, si alguien de repente quiere reprogramar los pedales, tendr√° que abrir el IDE de Arduino, editar el c√≥digo y volver a cargar el firmware.  Naturalmente, esta opci√≥n no es la mejor, as√≠ que decid√≠ agregar la capacidad de cambiar el programa desde el puerto serie Arduino y almacenar los programas en EEPROM.  Para trabajar con memoria no vol√°til, debe conectar la biblioteca est√°ndar EEPROM.h.  El c√≥digo del modo de programaci√≥n es el siguiente: <br><br><pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!digitalRead(modeButton)) { <span class="hljs-comment"><span class="hljs-comment">//  Serial.begin(9600); while (!Serial) { PORTD = 0b00000000 + (PORTD &amp; 0b11101100); delay(250); PORTD = 0b00010000 + (PORTD &amp; 0b11101100); delay(250); } Serial.println(F("***Programming mode***")); Serial.println(F("Write the command as &lt;m&gt; &lt;p&gt; &lt;c&gt;")); Serial.println(F("m - number of mode, one digit")); Serial.println(F("p - number of pedal, one digit")); Serial.println(F("c - command, it can be:")); Serial.println(F("\tr - read pedal info")); Serial.println(F("\tw - enter to writing mode and change pedal programm")); Serial.println(F("\te - erase pedal programm and delete it")); Serial.println(F("There are up to 7 modes and 6 pedals per mode can be configured")); Serial.println(F("Mode will be incative if there is no pedal configured in it")); while (1) { while (Serial.available()) { Serial.read(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(""); Serial.println(F("Enter command")); while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); delay(3); if (Serial.available() == 3) { int curMode = Serial.read() - 48; int curPedal = Serial.read() - 48; char cmd = Serial.read(); if (curMode &gt; 6 || curMode &lt; 0) { Serial.print(F("Mode must be in 0-6. You entered ")); Serial.println(curMode); continue; } if (curPedal &gt; 3 || curPedal &lt; 0) { Serial.print(F("Pedal must be in 0-3. You entered ")); Serial.println(curPedal); continue; } Serial.println(); if (cmd == 'r') { int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); Serial.print("type: "); int curAddress = beginAddress; Serial.println(EEPROM[curAddress++]); Serial.print("act1: "); for (int i = curAddress ; i &lt; curAddress + (sizeof(struct pedal) - 1) / 2; i++) { Serial.print(EEPROM[i]); Serial.print("\t"); } Serial.println(); curAddress = beginAddress + 1 + (sizeof(struct pedal) - 1) / 2; Serial.print("act2: "); for (int i = curAddress ; i &lt; curAddress + (sizeof(struct pedal) - 1) / 2; i++) { Serial.print(EEPROM[i]); Serial.print("\t"); } Serial.println(); } else if (cmd == 'w') { Serial.println(F("Enter type:")); PORTD = 0b00000001 + (PORTD &amp; 0b11101100); while (!Serial.available()); int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); int curAddress = beginAddress; PORTD = 0b00000010 + (PORTD &amp; 0b11101100); EEPROM[curAddress++] = (char)Serial.parseInt(); PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Enter act1 in DEC divided by space:")); while (Serial.available()) { Serial.read(); delay(1); } while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); while (Serial.available()) { EEPROM[curAddress++] = (char)Serial.parseInt(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); curAddress = beginAddress + 1 + (sizeof(struct pedal) - 1) / 2; Serial.println(F("Enter act2 in DEC divided by space:")); while (Serial.available()) { Serial.read(); delay(1); } while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); while (Serial.available()) { EEPROM[curAddress++] = (char)Serial.parseInt(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Finished, don't forget to verify written data!")); } else if (cmd == 'e') { int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); Serial.println(F("Disabling pedal...")); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); EEPROM[beginAddress] = 255; PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Pedal disabled")); } } else { Serial.println(F("Incorrect command, please read help above")); } }; } ...</span></span></code> </pre><br>  Lo que hace este c√≥digo se explica por la ayuda que contiene: se ingresa un n√∫mero de espacio para el n√∫mero de modo, el n√∫mero de pedal y un comando, de los cuales hay 3: leer, escribir y <s>ejecutar la</s> eliminaci√≥n de <s>un</s> programa.  Todos los datos en los pedales se almacenan uno tras otro en una secuencia de 33 bytes, es decir, el tipo de pedal y dos programas, y que ocupamos 7 * 4 * 33 = 924 de 1024 bytes de EEPROM.  Descart√© la opci√≥n de usar el tama√±o din√°mico de los pedales en la memoria, porque en este caso, al reprogramar un pedal, tendr√° que sobrescribir casi todas las celdas, y hay un n√∫mero finito de ciclos de reescritura, por lo que recomendamos hacer esto lo menos posible. <br><br><div class="spoiler">  <b class="spoiler_title">Caracter√≠sticas del trabajo con EEPROM</b> <div class="spoiler_text">  Tambi√©n me gustar√≠a llamar la atenci√≥n sobre las l√≠neas del formulario: <br><pre> <code class="cpp hljs"> PORTD = <span class="hljs-number"><span class="hljs-number">0b00000010</span></span> + (PORTD &amp; <span class="hljs-number"><span class="hljs-number">0b11101100</span></span>); ... PORTD = <span class="hljs-number"><span class="hljs-number">0b00000001</span></span> + (PORTD &amp; <span class="hljs-number"><span class="hljs-number">0b11101100</span></span>);</code> </pre><br>  Gracias a esta biblioteca, desde el punto de vista del programador, la memoria no vol√°til es una matriz de caracteres ordinaria, pero, como "arduino", debemos entender que escribir en ROM es una operaci√≥n muy dif√≠cil, que tarda aproximadamente ~ 3 segundos desde el controlador, y es aconsejable no interrumpir esto proceso  Este dise√±o hace que el diodo brille rojo durante tales operaciones, y luego devuelve el color verde "seguro". <br></div></div><br>  En el modo de grabaci√≥n de programa, la entrada se realiza directamente por los valores de bytes en el sistema de n√∫meros decimales con un espacio.  Resulta bastante grave, pero no tiene que escribir un analizador complejo.  Adem√°s, la reprogramaci√≥n no ocurre con tanta frecuencia, y en estos casos es bastante posible mirar en la tabla ASCII. <br><br>  Con la preservaci√≥n de las estructuras resueltas, ahora necesitamos extraer de alguna manera nuestros datos de all√≠ y convertirlos a la vista "pedal": <br><br><pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">7</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; j++) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedal</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pedals</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class">][</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">j</span></span></span><span class="hljs-class">];</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginAddress = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct pedal) * (i * <span class="hljs-number"><span class="hljs-number">6</span></span> + j); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> curAddress = beginAddress; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> type = EEPROM[curAddress++]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == <span class="hljs-number"><span class="hljs-number">0</span></span> || type == <span class="hljs-number"><span class="hljs-number">1</span></span>) { p-&gt;type = type; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span> ; k &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; k++) { p-&gt;act1[k] = EEPROM[curAddress++]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span> ; k &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; k++) { p-&gt;act2[k] = EEPROM[curAddress++]; } } } } ...</code> </pre><br>  Aqu√≠ tampoco sucede nada sobrenatural: el controlador lee los datos de la memoria y llena las estructuras existentes con √©l. <br><br>  La ventaja de programar a trav√©s de UART es que nuevamente no necesitamos controladores especiales, por lo que puede configurar el comportamiento del manipulador incluso desde el tel√©fono. <br><br><h2>  Demostraci√≥n </h2><br><iframe width="560" height="315" src="https://www.youtube.com/embed/pkjtRLlNZnU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  C√≥digo fuente completo </h2><br><div class="spoiler">  <b class="spoiler_title">El esta aqui</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Keyboard.h&gt; #include &lt;Thread.h&gt; #include &lt;EEPROM.h&gt; #define modeButton 6 struct pedal { unsigned char type; //0 ‚Äî   , 1 ‚Äî  , 255 ‚Äî    unsigned char act1[16]; unsigned char act2[16]; }; struct pedal pedals[7][4] = { { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} }, { { 255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}}, {255, {255}, {255}} } }; char ports[4] = {8, 16, 15, 14}; char pos1[4] = {0, 0, 0, 0}; char pos2[4] = {0, 0, 0, 0}; char state[4] = {0, 0, 0, 0}; char oldState[4] = {0, 0, 0, 0}; char wait[4] = {0, 0, 0, 0}; void pedalAction(); char mode = 0; char curPedal; Thread pedalThreads[6] = {Thread(pedalAction, 10), Thread(pedalAction, 10), Thread(pedalAction, 10), Thread(pedalAction, 10), Thread(pedalAction, 10), Thread(pedalAction, 10)}; void setup() { pinMode(2, 1); pinMode(3, 1); pinMode(4, 1); pinMode(modeButton, 2); if (!digitalRead(modeButton)) { //  Serial.begin(9600); while (!Serial) { PORTD = 0b00000000 + (PORTD &amp; 0b11101100); delay(250); PORTD = 0b00010000 + (PORTD &amp; 0b11101100); delay(250); } Serial.println(F("***Programming mode***")); Serial.println(F("Write the command as &lt;m&gt; &lt;p&gt; &lt;c&gt;")); Serial.println(F("m - number of mode, one digit")); Serial.println(F("p - number of pedal, one digit")); Serial.println(F("c - command, it can be:")); Serial.println(F("\tr - read pedal info")); Serial.println(F("\tw - enter to writing mode and change pedal programm")); Serial.println(F("\te - erase pedal programm and delete it")); Serial.println(F("There are up to 7 modes and 6 pedals per mode can be configured")); Serial.println(F("Mode will be incative if there is no pedal configured in it")); while (1) { while (Serial.available()) { Serial.read(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(""); Serial.println(F("Enter command")); while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); delay(3); if (Serial.available() == 3) { int curMode = Serial.read() - 48; int curPedal = Serial.read() - 48; char cmd = Serial.read(); if (curMode &gt; 6 || curMode &lt; 0) { Serial.print(F("Mode must be in 0-6. You entered ")); Serial.println(curMode); continue; } if (curPedal &gt; 3 || curPedal &lt; 0) { Serial.print(F("Pedal must be in 0-3. You entered ")); Serial.println(curPedal); continue; } Serial.println(); if (cmd == 'r') { int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); Serial.print("type: "); int curAddress = beginAddress; Serial.println(EEPROM[curAddress++]); Serial.print("act1: "); for (int i = curAddress ; i &lt; curAddress + (sizeof(struct pedal) - 1) / 2; i++) { Serial.print(EEPROM[i]); Serial.print("\t"); } Serial.println(); curAddress = beginAddress + 1 + (sizeof(struct pedal) - 1) / 2; Serial.print("act2: "); for (int i = curAddress ; i &lt; curAddress + (sizeof(struct pedal) - 1) / 2; i++) { Serial.print(EEPROM[i]); Serial.print("\t"); } Serial.println(); } else if (cmd == 'w') { Serial.println(F("Enter type:")); PORTD = 0b00000001 + (PORTD &amp; 0b11101100); while (!Serial.available()); int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); int curAddress = beginAddress; PORTD = 0b00000010 + (PORTD &amp; 0b11101100); EEPROM[curAddress++] = (char)Serial.parseInt(); PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Enter act1 in DEC divided by space:")); while (Serial.available()) { Serial.read(); delay(1); } while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); while (Serial.available()) { EEPROM[curAddress++] = (char)Serial.parseInt(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); curAddress = beginAddress + 1 + (sizeof(struct pedal) - 1) / 2; Serial.println(F("Enter act2 in DEC divided by space:")); while (Serial.available()) { Serial.read(); delay(1); } while (!Serial.available()); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); while (Serial.available()) { EEPROM[curAddress++] = (char)Serial.parseInt(); delay(1); } PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Finished, don't forget to verify written data!")); } else if (cmd == 'e') { int beginAddress = sizeof(struct pedal) * (curMode * 6 + curPedal); Serial.println(F("Disabling pedal...")); PORTD = 0b00000010 + (PORTD &amp; 0b11101100); EEPROM[beginAddress] = 255; PORTD = 0b00000001 + (PORTD &amp; 0b11101100); Serial.println(F("Pedal disabled")); } } else { Serial.println(F("Incorrect command, please read help above")); } }; } for (int i : ports) pinMode(i, 2); pinMode(17, 1); for (int i = 0; i &lt; 7; i++) { for (int j = 0; j &lt; 4; j++) { struct pedal *p = &amp;pedals[i][j]; int beginAddress = sizeof(struct pedal) * (i * 6 + j); int curAddress = beginAddress; unsigned char type = EEPROM[curAddress++]; if (type == 0 || type == 1) { p-&gt;type = type; for (int k = 0 ; k &lt; 16; k++) { p-&gt;act1[k] = EEPROM[curAddress++]; } for (int k = 0 ; k &lt; 16; k++) { p-&gt;act2[k] = EEPROM[curAddress++]; } } } } Keyboard.begin(); } int last = 0; void loop() { int current; if ((current = digitalRead(modeButton)) != last) { if (!current) { if (++mode &gt;= 7) mode = 0; while (pedals[mode][0].type == 255 &amp;&amp; pedals[mode][1].type == 255 &amp;&amp; pedals[mode][2].type == 255 &amp;&amp; pedals[mode][3].type == 255) if (++mode &gt;= 7) { mode = 0; break; } } last = current; digitalWrite(2, (mode + 1) &amp; 0b001); digitalWrite(3, (mode + 1) &amp; 0b010); digitalWrite(4, (mode + 1) &amp; 0b100); for (int i = 0; i &lt; 4; i++) { pos1[i] = 0; pos2[i] = 0; state[i] = 0; oldState[i] = 0; wait[i] = 0; } delay(50); } for (int i = 0; i &lt; 4; i++) { if (pedalThreads[i].shouldRun()) { curPedal = i; pedalThreads[i].run(); } } } void pedalAction() { struct pedal *pedal1 = &amp;pedals[mode][curPedal]; if (pedal1-&gt;type == 255) return; unsigned char *prg; char *pos; if (pedal1-&gt;type) { int current; if ((current = digitalRead(ports[curPedal])) != oldState[curPedal]) { if (!current) state[curPedal] = !state[curPedal]; oldState[curPedal] = current; } if (!state[curPedal]) { //act1 pos2[curPedal] = 0; pos = &amp;(pos1[curPedal]); prg = pedal1-&gt;act1; } else { //act2 pos1[curPedal] = 0; pos = &amp;(pos2[curPedal]); prg = pedal1-&gt;act2; } } else { if (!digitalRead(ports[curPedal])) { //act1 pos2[curPedal] = 0; pos = &amp;(pos1[curPedal]); prg = pedal1-&gt;act1; } else { //act2 pos1[curPedal] = 0; pos = &amp;(pos2[curPedal]); prg = pedal1-&gt;act2; } } while (1) { if (wait[curPedal]) { wait[curPedal]--; return; } else if (prg[*pos] == 250) { wait[curPedal] = prg[++*pos]; } else if (prg[*pos] == 254) { // ,   *pos Keyboard.press(prg[++*pos]); } else if (prg[*pos] == 253) { // ,   *pos Keyboard.release(prg[++*pos]); } else if (prg[*pos] == 252) { delay(10); //" ",    ++*pos; return; } else if (prg[*pos] == 251) { //       *pos+1 *pos = prg[*pos + 1]; return; } else if (prg[*pos] == 255 || prg[*pos] == 0) { // ,   return; } else { //   Keyboard.write(prg[*pos]); } //       ,     if (++*pos &gt;= 16) pos = 0; } }</span></span></span></span></code> </pre><br></div></div><br><h2>  Ep√≠logo </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque inicialmente hice una pedalera para la posibilidad de desplazar la grabaci√≥n mientras tocaba la guitarra, sin embargo, personalmente me pareci√≥ conveniente usar los pedales en tareas normales, lo principal es acostumbrarme un poco a un manipulador tan inusual. </font><font style="vertical-align: inherit;">Y aqu√≠ hay otro problema: sin los pedales favoritos, trabajar por el contrario se vuelve m√°s dif√≠cil, ya que hay que recordar qu√©, d√≥nde y por qu√© presionar. </font><font style="vertical-align: inherit;">Si los pedales todav√≠a se pueden usar y conectar a la oficina, entonces correr en las aulas del instituto ya es m√°s dif√≠cil. </font><font style="vertical-align: inherit;">Por lo tanto, usar este dispositivo para algo que no sea su prop√≥sito original es bajo su propio riesgo y riesgo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pedalero montado:</font></font><br><br><img src="https://habrastorage.org/webt/rw/p9/-v/rwp9-vaul_zvd9awymeb1qexlqi.jpeg"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/462263/">https://habr.com/ru/post/462263/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../462245/index.html">auto git bisect como un ejemplo del kernel de Linux</a></li>
<li><a href="../462251/index.html">¬øEs el modo inc√≥gnito en el navegador una ficci√≥n?</a></li>
<li><a href="../462253/index.html">Los primeros experimentos que utilizan el protocolo de transmisi√≥n en el ejemplo de comunicaci√≥n de CPU y procesador en el FPGA Redd</a></li>
<li><a href="../462257/index.html">Kafka en Kubernetes, ¬øest√° bien?</a></li>
<li><a href="../462259/index.html">Hacer un controlador para una casa inteligente</a></li>
<li><a href="../462265/index.html">Python y cubos</a></li>
<li><a href="../462267/index.html">Conozca el analizador est√°tico PVS-Studio para Java</a></li>
<li><a href="../462269/index.html">John Romero to Doom: 80s Game Dev</a></li>
<li><a href="../462271/index.html">C√≥digo de bloqueo en iOS: c√≥mo Apple cambi√≥ de defensa en defensa a proteger una sola frontera</a></li>
<li><a href="../462273/index.html">Administre el soporte de su computadora port√°til con digispark</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>