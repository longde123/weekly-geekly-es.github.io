<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👈🏾 👩🏽‍🚒 🧖🏼 Et encore une fois, CAPTCHA ou nginx sait aussi broder 🐋 🀄️ 👩🏼‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Présentation 


 Je suis allé ici à Habr et j'ai trouvé dans les brouillons un article non publié sur le captcha, je voulais le formaliser et le publi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Et encore une fois, CAPTCHA ou nginx sait aussi broder</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485804/"><h2>  Présentation </h2><br><p>  Je suis allé ici à Habr et j'ai trouvé dans les brouillons un <a href="https://postgres.men/web/nginx/nginx-fast-captcha/">article</a> non publié sur le captcha, je voulais le formaliser et le publier, mais j'ai décidé d'écrire un nouvel article en changeant légèrement le mécanisme et les outils utilisés.  À mon avis, il sera utile de lire un vieil article, ce ne sera pas pire. </p><br><p>  L'objectif principal de la rédaction d'un nouvel article n'est même pas de montrer un autre mécanisme de travail, combien montrer les capacités de nginx dont ils oublient parfois complètement, le considérant comme un serveur proxy banal. </p><a name="habracut"></a><br><h2>  Les conditions </h2><br><p>  Pour empêcher les bots de télécharger des fichiers, un test «captcha» est utilisé. </p><br><p>  Lors de la formation d'un formulaire pour un saut de fichier, une image avec un code et certaines distorsions est créée pour compliquer sa reconnaissance automatique.  Il y a également un stockage pour fixer une paire clé + code pour vérification. </p><br><p>  Lors de la confirmation du formulaire de téléchargement du fichier et de vérification du captcha pour la correspondance du code, le fichier est remis à l'utilisateur ou un lien unique unique vers le fichier est généré.  L'unicité du lien est également contrôlée par le backend.  La paire clé + code est également supprimée pour empêcher sa réutilisation. </p><br><p>  Il existe un proxy qui redirige toutes les demandes vers le backend. </p><br><h2>  Les problèmes </h2><br><p> La génération d'images complexes est une opération assez gourmande en ressources, et étant donné que tous les codes affichés ne sont pas utilisés.  Il est nécessaire de créer un certain mécanisme pour mettre en cache les images inutilisées afin de pouvoir les afficher aux autres utilisateurs. </p><br><p>  Le code et la clé sont vérifiés par le backend, mais il y a des difficultés à transférer de gros fichiers via le backend, les liens uniques nécessitent également une vérification au niveau du backend, je veux me débarrasser de la charge supplémentaire sur eux. </p><br><h2>  Solution </h2><br><h3>  Sélectionnez la fonctionnalité </h3><br><p>  En fait, le captcha lui-même se compose d'une image et d'une certaine clé qui correspond au code dans l'image qui est stockée sur le backend.  L'image n'est pas très grande, et nous la traduisons en Base64 et donnons soit un morceau de forme: </p><br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"data:image/png;base64,{{ IMAGE CODE BASE64 }}"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"hidden"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"key"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{{ KEY }}"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Ou JSON: </p><br><pre> <code class="json hljs">{ ... <span class="hljs-attr"><span class="hljs-attr">"data"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"image"</span></span>: <span class="hljs-string"><span class="hljs-string">"data:image/png;base64,{{ IMAGE CODE BASE64 }}"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"key"</span></span>: <span class="hljs-string"><span class="hljs-string">"{{ KEY }}"</span></span> } }</code> </pre> <br><p>  Si nous avons un morceau du formulaire en cours de formation, nous pouvons utiliser <a href="http_ssi_module.html">SSI</a> pour l'insérer dans le corps de la page, pour cela, nous activons le mode correspondant dans la configuration nginx sur le proxy: </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">ssi</span></span> <span class="hljs-literal"><span class="hljs-literal">on</span></span>;</code> </pre> <br><p>  Et dans le code de la page du formulaire, nous insérons: </p><br><pre> <code class="xml hljs">... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">form</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">action</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"download"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">method</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"get"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">...</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-comment"><span class="hljs-comment">&lt;!--#include virtual="/x/captcha/generate"--&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">form</span></span></span><span class="hljs-tag">&gt;</span></span> ...</code> </pre><br><p>  Ainsi, nous avons attribué la fonctionnalité de mappage du captcha dans un <i>emplacement</i> ou des méthodes séparés.  Vous pouvez maintenant effectuer la mise en cache. </p><br><blockquote>  Oui, le mécanisme <i>Server Side Include (SSI)</i> est presque oublié, mais le module nginx pour lui est plus vivant que tous les vivants et fonctionne très rapidement.  Et au fait, si proxy_pass_cache <i>met en cache la</i> page entière, le résultat de <i>include virtual</i> ne sera pas mis en cache, mais sera exécuté chaque fois qu'il sera demandé.  Cela vous permet de rendre l'insertion dynamique. </blockquote><br><h3>  CAPTCHA CAPTCHA </h3><br><p>  Pour implémenter la mise en cache, nous avons besoin de quelque chose d'assez aléatoire et contrôlé par le nombre d'options, la variable <i>$ request_id</i> convient à ce rôle - elle est assez aléatoire et hexadécimale, c'est-à-dire qu'en choisissant une certaine partie de cette variable, vous pouvez limiter le nombre d'éléments de cache à 16 ^ n, où n - le nombre de caractères que nous devons prendre dans la variable.  Donc: </p><br><p>  Déterminez la zone de cache: </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_path</span></span> /cache/nginx/captcha levels=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span> keys_zone=captcha:<span class="hljs-number"><span class="hljs-number">10m</span></span> max_size=<span class="hljs-number"><span class="hljs-number">128m</span></span>;</code> </pre> <br><p>  Il est important de déterminer quelle valeur de n nous choisissons, respectivement, les paramètres en dépendent: </p><br><ul><li>  niveaux = 1: 2 </li><li>  max_size = 128m </li><li>  keys_zone = captcha: 10m </li></ul><br><p>  C'était donc suffisant pour tout, mais il n'y avait rien de superflu.  Ensuite, nous déterminons la clé de cache: </p><br><pre> <code class="nginx hljs"><span class="hljs-section"><span class="hljs-section">server</span></span> { ... <span class="hljs-attribute"><span class="hljs-attribute">set</span></span> <span class="hljs-variable"><span class="hljs-variable">$captcha_salt</span></span> <span class="hljs-string"><span class="hljs-string">'salt'</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> ( <span class="hljs-variable"><span class="hljs-variable">$request_id</span></span> <span class="hljs-regexp"><span class="hljs-regexp">~* "(\w</span></span>{4})$" ) { <span class="hljs-attribute"><span class="hljs-attribute">set</span></span> <span class="hljs-variable"><span class="hljs-variable">$cache_key</span></span> <span class="hljs-variable"><span class="hljs-variable">$1</span></span>; } ...</code> </pre> <br><p>  La <i>variable $ captcha_salt nous</i> est toujours utile, mais maintenant elle protège contre les intersections de clés possibles.  J'ai choisi n comme 4, ce qui signifie 16 ^ 4 emplacements de cache, avec 2 <i>Ko</i> en moyenne alloués à chaque emplacement de la taille totale du cache ( <i>max_size = 128m</i> ), ce qui devrait être suffisant, sinon vous devez augmenter la taille maximale. </p><br><p>  Faire l' <i>emplacement</i> approprié </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /x/captcha/generate { <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache</span></span> captcha; <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_key</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$captcha_salt</span></span></span><span class="hljs-string">:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$cache_key</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_valid</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">365d</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_valid</span></span> any <span class="hljs-number"><span class="hljs-number">0s</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-string"><span class="hljs-string">"captcha.service.domain.my"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://captcha_upstream/?cache_key=<span class="hljs-variable"><span class="hljs-variable">$cache_key</span></span>; }</code> </pre> <br><p>  Les «bonnes» réponses backend seront mises en cache presque pour toujours, le reste ne sera pas mis en cache.  Et oui, vous pouvez immédiatement mettre en évidence la fonctionnalité de travailler avec captcha dans un service distinct. </p><br><blockquote>  Soit dit en passant, un mécanisme similaire peut être utilisé pour générer une pseudo-dynamique lorsque l'utilisateur appuie sur F5 et chaque fois qu'une nouvelle «image» aléatoire lui est montrée.  Dans ce cas, le backend n'est pratiquement pas chargé. </blockquote><br><p>  Nous devons également réinitialiser le cache correspondant lors de la vérification du formulaire, de sorte que le backend, entre autres, doit donner la valeur <i>cache_key</i> pour le renvoyer au formulaire en tant que champ <i>masqué</i> .  Malheureusement, la directive <i>proxy_cache_purge</i> n'est disponible que dans la version commerciale.  Peu importe, il existe un module <a href="https://github.com/FRiCKLE/ngx_cache_purge">cache_purge</a> tiers, qui peut être légèrement plus simple, mais suffisant pour nous.  Donc, <i>emplacement</i> pour vider le cache: </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /x/captcha/cache/purge { internal; <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_purge</span></span> captcha <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$captcha_salt</span></span></span><span class="hljs-string">:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$arg_cache_key</span></span></span><span class="hljs-string">"</span></span>; }</code> </pre> <br><p>  Il a la directive <i>interne</i> , car nous n'allons pas l'utiliser publiquement.  Et pour appeler cet <i>emplacement,</i> nous utiliserons la directive <i>miroir</i> du module <a href="http_mirror_module.html">http_mirror_module</a> : </p><br><p>  Autrement dit, nous faisons une demande parallèle pour réinitialiser le cache par la clé de la variable <i>$ arg_cache_key</i> , qui est transmise sous la forme.  Ensuite, il suffit de transmettre la requête par proxy à notre backend où le reste du traitement est effectué. </p><br><h3>  La voie épineuse de l'optimisation </h3><br><p>  Ici, en fait, je voulais développer un sujet: comment séparer la vérification du code captcha et le retour du fichier.  Comment empêcher le cache d'être effacé avec des requêtes incorrectes.  Ensuite pour optimiser de plus en plus, mais tout se résume au fait qu'en général on n'a plus besoin du backend ... du tout ... car on a déjà tout. </p><br><p>  La tâche qui restait avec le serveur en termes de vérification du captcha était en fait de vérifier la clé + le code et de supprimer cette paire du référentiel.  La vérification de la clé + du code peut être une simple comparaison du montant md5 avec la clé.  Pour cela, un module nous suffit: <a href="http_secure_link_module.html">http_secure_link_module</a> .  Autrement dit, la clé peut être représentée sous la forme d'une formule: </p><br> <code>key = md5_baseurl( salt + code )</code> <br> <p>  Dans le même temps, la liaison à l'emplacement de cache (clé de cache) ne nous fera pas de mal, nous l'ajoutons: </p><br> <code>key = md5_baseurl( salt + code + cache_key )</code> <br> <p>  Nous avons Salt - c'est la variable <i>$ captcha_salt</i> (donc c'est utile), mais garder le sel à deux endroits sur le backend et le proxy est mauvais, alors faisons ceci: </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /x/captcha/salt { <span class="hljs-section"><span class="hljs-section">allow</span></span> {{ <span class="hljs-attribute"><span class="hljs-attribute">captcha</span></span> backend IPs }}; <span class="hljs-attribute"><span class="hljs-attribute">deny</span></span> all; <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$captcha_salt</span></span></span><span class="hljs-string">"</span></span>; }</code> </pre> <br><p>  Et laissez le backend aller au proxy pour le sel. </p><br><p>  La question demeure avec le référentiel, où nous stockons une paire clé + code qui doit être nettoyée.  Pour ce faire, le mécanisme de mise en cache que nous avons déjà implémenté nous convient.  La seule chose est que nous ne traitons pas le résultat <i>cache_purge</i> de <i>quelque façon que ce soit</i> , mais simplement en miroir de la demande, mais cela est réparable.  Et oui, cela justifie l'utilisation d'une clé de cache lors de la création d'une clé captcha. </p><br><h3>  Vérification du code </h3><br><p>  Réécrire les téléchargements de fichiers d' <i>emplacement</i> : </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /download { <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-variable"><span class="hljs-variable">$host</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Context download; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-File-Name <span class="hljs-variable"><span class="hljs-variable">$arg_filename</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Key <span class="hljs-variable"><span class="hljs-variable">$arg_key</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Code <span class="hljs-variable"><span class="hljs-variable">$arg_code</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Cache-Key <span class="hljs-variable"><span class="hljs-variable">$arg_cache_key</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://127.0.0.1/x/captcha/check; <span class="hljs-attribute"><span class="hljs-attribute">proxy_intercept_errors</span></span> <span class="hljs-literal"><span class="hljs-literal">on</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">error_page</span></span> <span class="hljs-number"><span class="hljs-number">403</span></span> <span class="hljs-number"><span class="hljs-number">404</span></span> = /download/fail; }</code> </pre> <br><p>  Je passe les paramètres requis avec des en-têtes.  C'est facultatif, mais c'est plus pratique pour moi.  Nous procurons le traitement à l'emplacement local du chèque captcha.  De plus, <i>context = download</i> est passé, de sorte que dans le gestionnaire, nous pourrions produire l'un ou l'autre résultat en fonction de celui-ci.  Dans ce cas, le gestionnaire peut nous retourner soit: </p><br><ul><li>  403 - erreur de vérification de code.  En fait, par conséquent, <i>proxy_intercept_errors</i> est <i>activé</i> et l'emplacement est déclaré pour la redirection en cas d'erreur; </li><li>  404 - erreur de nettoyage du cache.  Le module <i>cache_purge</i> s'il n'y a rien dans le cache avec une telle clé retourne 404; </li><li>  200 + <i>Accel-Redirect</i> - sur l' <i>emplacement du</i> téléchargement <i>du</i> fichier, au cas où la vérification du captcha se serait bien passée.  Dans notre cas, ce sera <i>X-Accel-Redirect: / store / file</i> </li></ul><br><blockquote>  Si <i>error_page</i> pouvait gérer les codes <i>2XX</i> , alors on pouvait le faire seul.  Sinon, vous devez utiliser le mécanisme <i>Accel-Redirect</i> .  Si vous le souhaitez, vous pouvez séparer les gestionnaires d'erreurs 403 et 404; </blockquote><br><p>  Faire une simple erreur de <i>localisation</i> : </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /download/fail { internal; <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-string"><span class="hljs-string">"FAIL DOWNLOAD"</span></span>; }</code> </pre> <br><p>  Vous pouvez retourner n'importe quoi à cet endroit, selon vos besoins. </p><br><p>  Nous faisons l'emplacement du téléchargement du fichier: </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /store/file { internal; <span class="hljs-attribute"><span class="hljs-attribute">add_header</span></span> Content-Disposition <span class="hljs-string"><span class="hljs-string">"attachment; filename=\"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$arg_filename</span></span></span><span class="hljs-string">\""</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">alias</span></span> /spool/tmp/; <span class="hljs-attribute"><span class="hljs-attribute">try_files</span></span> <span class="hljs-variable"><span class="hljs-variable">$arg_filename</span></span> =<span class="hljs-number"><span class="hljs-number">404</span></span>; }</code> </pre> <br><p>  Tout d'abord, il est important qu'il soit <i>interne</i> - cela signifie que vous ne pourrez pas télécharger le fichier directement via celui-ci, uniquement par redirection.  Il peut également être modifié en fonction des besoins et ne pas donner le fichier local, mais pour proxy la demande pour le service de stockage de fichiers. </p><br><p>  L' <i>emplacement</i> suivant que nous avons pour la vérification du captcha: </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /x/captcha/check { <span class="hljs-attribute"><span class="hljs-attribute">allow</span></span> <span class="hljs-number"><span class="hljs-number">127.0.0.1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">deny</span></span> all; <span class="hljs-attribute"><span class="hljs-attribute">secure_link_md5</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$captcha_salt</span></span></span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_x_code</span></span></span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_x_cache_key</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">secure_link</span></span> <span class="hljs-variable"><span class="hljs-variable">$http_x_key</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (<span class="hljs-variable"><span class="hljs-variable">$secure_link</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span>) { <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> <span class="hljs-number"><span class="hljs-number">403</span></span> <span class="hljs-string"><span class="hljs-string">"FAIL CHECK CODE"</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-variable"><span class="hljs-variable">$host</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://127.0.0.1/x/captcha/purge; }</code> </pre> <br><p>  Il a 2 blocs: vérification du code et procuration supplémentaire pour vider le cache.  De plus, si la vérification du code n'a pas réussi, renvoyez immédiatement 403 (le texte est sans importance, car il n'est plus utilisé). </p><br><p>  La procuration à <i>/ x / captcha / purge</i> renverra 2 options de réponse: </p><br><ul><li>  200 + <i>Accel-Redirect</i> - lors du vidage réussi du cache.  La redirection sera vers <i>X-Accel-Redirect: / x / captcha / check / ok</i> ; </li><li>  404 - s'il n'y avait rien à nettoyer.  Ce résultat sera transmis ci-dessus à <i>/ download</i> et y sera traité <i>error_page</i> ; </li></ul><br><p>  Un gestionnaire distinct pour la réponse positive de <i>/ x / captcha / purge</i> est créé car nous devons d'abord atteindre un niveau de proxy plus élevé, et non entre <i>/ download</i> et <i>/ x / captcha / check</i> .  Deuxièmement, il serait bon de donner votre réponse positive concernant le contexte. </p><br><p>  Commençons par un gestionnaire de réponse positive: </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /x/captcha/check/ok { internal; <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> ( <span class="hljs-variable"><span class="hljs-variable">$http_x_context</span></span> = <span class="hljs-string"><span class="hljs-string">'download'</span></span> ) { <span class="hljs-attribute"><span class="hljs-attribute">add_header</span></span> X-Accel-Redirect <span class="hljs-string"><span class="hljs-string">"/store/file?filename=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_x_file_name</span></span></span><span class="hljs-string">"</span></span>; } ... <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-string"><span class="hljs-string">"OK"</span></span>; }</code> </pre> <br><p>  En fait, en fonction de la valeur de la variable <i>$ http_x_context</i> (en <i>-</i> tête <i>X-Context</i> ), nous pouvons déterminer quelle <i>Accel-Redirect</i> va répondre avec <i>/ x / captcha / check</i> .  Cela signifie que vous pouvez utiliser ce mécanisme à d'autres endroits que le téléchargement du fichier. </p><br><p>  Vider le cache est assez simple: </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /x/captcha/purge { <span class="hljs-attribute"><span class="hljs-attribute">allow</span></span> <span class="hljs-number"><span class="hljs-number">127.0.0.1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">deny</span></span> all; <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_purge</span></span> captcha <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_x_cache_key</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">add_header</span></span> X-Accel-Redirect <span class="hljs-string"><span class="hljs-string">"/x/captcha/check/ok"</span></span>; }</code> </pre> <br><p>  En général, c'est tout, à la fin, nous avons obtenu la configuration nginx suivante: </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_path</span></span> /cache/nginx/captcha levels=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span> keys_zone=captcha:<span class="hljs-number"><span class="hljs-number">10m</span></span> max_size=<span class="hljs-number"><span class="hljs-number">128m</span></span>; <span class="hljs-section"><span class="hljs-section">server</span></span> { ... <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /download { <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-variable"><span class="hljs-variable">$host</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Context download; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-File-Name <span class="hljs-variable"><span class="hljs-variable">$arg_filename</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Key <span class="hljs-variable"><span class="hljs-variable">$arg_key</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Code <span class="hljs-variable"><span class="hljs-variable">$arg_code</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Cache-Key <span class="hljs-variable"><span class="hljs-variable">$arg_cache_key</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://127.0.0.1/x/captcha/check; <span class="hljs-attribute"><span class="hljs-attribute">proxy_intercept_errors</span></span> <span class="hljs-literal"><span class="hljs-literal">on</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">error_page</span></span> <span class="hljs-number"><span class="hljs-number">403</span></span> <span class="hljs-number"><span class="hljs-number">404</span></span> = /download/fail; } <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /download/fail { internal; <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-string"><span class="hljs-string">"FAIL DOWNLOAD"</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /store/file { internal; <span class="hljs-attribute"><span class="hljs-attribute">add_header</span></span> Content-Disposition <span class="hljs-string"><span class="hljs-string">"attachment; filename=\"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$arg_filename</span></span></span><span class="hljs-string">\""</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">alias</span></span> /spool/tmp/; <span class="hljs-attribute"><span class="hljs-attribute">try_files</span></span> <span class="hljs-variable"><span class="hljs-variable">$arg_filename</span></span> =<span class="hljs-number"><span class="hljs-number">404</span></span>; } ... <span class="hljs-attribute"><span class="hljs-attribute">set</span></span> <span class="hljs-variable"><span class="hljs-variable">$captcha_salt</span></span> <span class="hljs-string"><span class="hljs-string">'salt'</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> ( <span class="hljs-variable"><span class="hljs-variable">$request_id</span></span> <span class="hljs-regexp"><span class="hljs-regexp">~* "(\w</span></span>{4})$" ) { <span class="hljs-attribute"><span class="hljs-attribute">set</span></span> <span class="hljs-variable"><span class="hljs-variable">$cache_key</span></span> <span class="hljs-variable"><span class="hljs-variable">$1</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /x/captcha/generate { <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache</span></span> captcha; <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_key</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$captcha_salt</span></span></span><span class="hljs-string">:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$cache_key</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_valid</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">365d</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_valid</span></span> any <span class="hljs-number"><span class="hljs-number">0s</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-string"><span class="hljs-string">"captcha.service.domain.my"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://captcha_upstream/?cache_key=<span class="hljs-variable"><span class="hljs-variable">$cache_key</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /x/captcha/salt { <span class="hljs-section"><span class="hljs-section">allow</span></span> {{ <span class="hljs-attribute"><span class="hljs-attribute">captcha</span></span> backend IPs }}; <span class="hljs-attribute"><span class="hljs-attribute">deny</span></span> all; <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$captcha_salt</span></span></span><span class="hljs-string">"</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /x/captcha/check { <span class="hljs-attribute"><span class="hljs-attribute">allow</span></span> <span class="hljs-number"><span class="hljs-number">127.0.0.1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">deny</span></span> all; <span class="hljs-attribute"><span class="hljs-attribute">secure_link_md5</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$captcha_salt</span></span></span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_x_code</span></span></span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_x_cache_key</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">secure_link</span></span> <span class="hljs-variable"><span class="hljs-variable">$http_x_key</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (<span class="hljs-variable"><span class="hljs-variable">$secure_link</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span>) { <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> <span class="hljs-number"><span class="hljs-number">403</span></span> <span class="hljs-string"><span class="hljs-string">"FAIL CHECK CODE"</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-variable"><span class="hljs-variable">$host</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://127.0.0.1/x/captcha/purge; } <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /x/captcha/check/ok { internal; <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> ( <span class="hljs-variable"><span class="hljs-variable">$http_x_context</span></span> = <span class="hljs-string"><span class="hljs-string">'download'</span></span> ) { <span class="hljs-attribute"><span class="hljs-attribute">add_header</span></span> X-Accel-Redirect <span class="hljs-string"><span class="hljs-string">"/store/file?filename=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_x_file_name</span></span></span><span class="hljs-string">"</span></span>; } ... <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-string"><span class="hljs-string">"OK"</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /x/captcha/purge { <span class="hljs-attribute"><span class="hljs-attribute">allow</span></span> <span class="hljs-number"><span class="hljs-number">127.0.0.1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">deny</span></span> all; <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_purge</span></span> captcha <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_x_cache_key</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">add_header</span></span> X-Accel-Redirect <span class="hljs-string"><span class="hljs-string">"/x/captcha/check/ok"</span></span>; } }</code> </pre> <br><p>  À quoi devez-vous faire attention: <br></p><ul><li>  Accel-Redirect ne fonctionne que lorsque l'état de la réponse est 2XX.  Certes, hélas, rien n'a été écrit à ce sujet nulle part, et les adhérents de nginx ne sont pas d'accord; </li><li>  Les <i>emplacements</i> privés proches <i>permettent</i> soit <i>127.0.0.1;</i>  <i>nier tout;</i>  soit <i>interne;</i>  , selon que nous arrivons à cet <i>emplacement</i> via <i>proxy_pass</i> ou via <i>Accel-Redirect</i> ; </li><li>  Tous les <i>emplacements</i> associés au captcha sont mis en évidence dans <i>/ x / capcha / ... de</i> sorte qu'il serait possible de former un microservice; </li></ul><br><p>  Pour plus de clarté, j'ai également dessiné un schéma du travail: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/245/8bc/6c8/2458bc6c8defdbbf6f6f0bcfccb0f05a.png" alt="image"><br><h2>  Résumé </h2><br><p>  Par conséquent, à partir du backend, nous n'avons qu'à générer directement l'image et le code pour celle-ci.  Nginx peut facilement gérer le reste.  Bien sûr, ce sont des opérations logiques relativement simples, mais néanmoins, cela accélérera considérablement le travail et réduira la charge sur le backend.  Et en fait, nous n'avons utilisé aucun mécanisme inhabituel, mais seulement: </p><br><ul><li>  proxy_cache; </li><li>  Accel-Redirect </li><li>  page_erreur; </li><li>  secure_link </li><li>  cache_purge; </li></ul><br><p>  Le reste est la construction correcte de chaînes logiques. </p><br><p>  Nous avons également supprimé le référentiel backend temporaire pour les codes et les liens à usage unique.  Cependant, ils ont fait un élément obligatoire du système nginx, augmentant son poids fonctionnel. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr485804/">https://habr.com/ru/post/fr485804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr485786/index.html">Devoirs arithmétiques</a></li>
<li><a href="../fr485790/index.html">Entretiens: attentes vs réalité</a></li>
<li><a href="../fr485792/index.html">Ivan Lilekvist et Kim Dotkom, une grande interview: l'histoire de Megaupload, l'extradition vers les États-Unis, la liberté, le bitcoin. 2e partie</a></li>
<li><a href="../fr485796/index.html">Résoudre l'insoluble</a></li>
<li><a href="../fr485800/index.html">Numérisation vs Automatisation</a></li>
<li><a href="../fr485806/index.html">Coronavirus: du SRAS à 2019-nCoV</a></li>
<li><a href="../fr485810/index.html">Crochets Elixir au moment de la compilation</a></li>
<li><a href="../fr485812/index.html">7 étapes d'évolution des tests dans une entreprise</a></li>
<li><a href="../fr485820/index.html">Personne très attaquée: découvrez qui est la principale cible des cybercriminels dans votre entreprise.</a></li>
<li><a href="../fr485824/index.html">Comment faire un bot qui transforme une photo en bande dessinée. Troisième partie. Modèle d'hébergement gratuit sans serveur + GPU</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>