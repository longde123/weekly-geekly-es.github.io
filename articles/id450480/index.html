<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©â€ğŸ‘¦ ğŸ’´ ğŸ‘¨ğŸ¿â€ğŸŒ¾ Bagaimana komputasi kuantum dapat memengaruhi pengembangan perangkat lunak ğŸ”© ğŸš´ğŸ¾ ğŸ§—ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! 

 Selama sekitar enam bulan terakhir, penerbit telah secara aktif bekerja pada topik komputasi kuantum dan penerapan praktisnya. Untuk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana komputasi kuantum dapat memengaruhi pengembangan perangkat lunak</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/450480/">  Halo semuanya! <br><br>  Selama sekitar enam bulan terakhir, penerbit telah secara aktif bekerja pada topik komputasi kuantum dan penerapan praktisnya.  Untuk waktu yang lama tidak mungkin menemukan artikel yang layak untuk diterjemahkan pada topik yang menarik ini, sampai artikel seperti itu muncul di blog Oracle.  Publikasi ini akan berfungsi sebagai pengantar yang sangat baik untuk perangkat lunak, perangkat keras, dan masalah ilmu alam murni dari paradigma baru ini, jadi membaca adalah suatu keharusan. <br><br><img src="https://habrastorage.org/webt/it/bt/rt/itbtrtg_wcsimf8fhliumzzyigu.jpeg"><br><a name="habracut"></a><br>  Selama beberapa bulan dan tahun terakhir, minat dalam komputasi kuantum telah tumbuh secara signifikan.  Bahan-bahan baru terus muncul dari lembaga penelitian, perusahaan atau organisasi pemerintah, menceritakan tentang pencapaian terobosan di bidang ini.  Pada saat yang sama, artikel dengan basis teknis yang lebih lemah membahas konsekuensi potensial dari komputasi kuantum, dan perkiraan berkisar dari meretas sebagian besar teknik enkripsi modern hingga janji untuk menyembuhkan semua penyakit dan menyelesaikan pekerjaan dalam menciptakan AI yang lengkap.  Namun, tidak semua harapan ini sama realistisnya. <br><br>  Jika Anda seorang programmer yang sadar, maka Anda mungkin bertanya-tanya di mana garis antara fakta dan fiksi dalam perhitungan ini, dan bagaimana komputasi kuantum akan mempengaruhi pengembangan perangkat lunak di masa depan. <br><br>  Secara alami, bertahun-tahun tetap sebelum penciptaan perangkat keras yang berfungsi untuk komputasi kuantum.  Namun, prinsip umum paradigma ini sudah dipahami hari ini, ada abstraksi yang memungkinkan pengembang untuk membuat aplikasi di mana kemungkinan komputasi kuantum direalisasikan menggunakan simulator. <br><br><h4>  Apakah komputasi kuantum direduksi menjadi gain CPU lain? </h4><br>  Pengembangan perangkat lunak tradisional menggunakan komputer klasik melibatkan penerjemahan bahasa pemrograman tingkat tinggi (misalnya, Java) ke dalam operasi yang dilakukan pada sejumlah besar transistor (perangkat keras). <br><br>  Pada Gambar 1, proses ini disusun dalam bentuk paling sederhana: Kode sumber Java dikompilasi ke dalam kode byte platform-independen, yang, pada gilirannya, diterjemahkan ke dalam kode mesin platform-spesifik.  Kode mesin menggunakan sejumlah operasi (gerbang) sederhana yang dilakukan dalam memori.  Komponen perangkat keras utama yang digunakan untuk tujuan ini adalah transistor yang terkenal. <br><br><img src="https://habrastorage.org/webt/8c/-6/go/8c-6goi59u27wzyytc0zvgv3ero.png"><br><br>  <i>Fig.</i>  <i>1. Penerjemahan bahasa pemrograman tingkat tinggi ke dalam operasi yang dilakukan pada transistor</i> . <br><br>  Peningkatan produktivitas yang dicapai dalam beberapa tahun terakhir telah dicapai terutama karena peningkatan teknologi perangkat keras.  Ukuran transistor tunggal telah menurun secara drastis, dan semakin banyak transistor yang dapat Anda letakkan di setiap milimeter persegi, semakin banyak memori dan daya pemrosesan yang dimiliki komputer. <br><br>  Komputasi kuantum adalah teknologi yang mengganggu, karena di sini unit komputasi paling sederhana bukanlah transistor klasik, tetapi qubit, yang akan kita bicarakan di bawah ini. <br><br>  Intinya tidak hanya dalam perbedaan elemen-elemen utama ini, tetapi juga dalam perangkat katup yang berbeda.  Jadi, tumpukan dengan ara.  1 dalam komputasi kuantum tidak berlaku. <br><br><h4>  Akankah komputasi kuantum memecah seluruh tumpukan di atas hingga ke tingkat Java? </h4><br>  Singkatnya - "tidak juga."  Para ilmuwan secara bertahap setuju bahwa komputer kuantum akan sangat baik untuk memecahkan masalah tertentu, sementara masalah lainnya akan lebih dipecahkan secara rasional menggunakan komputer tradisional.  Kedengarannya familiar, bukan?  Situasi serupa diamati ketika membandingkan GPU dan CPU.  Sementara transistor juga digunakan dalam GPU, mereka pada prinsipnya berbeda dari CPU. Namun, banyak aplikasi yang ditulis dalam bahasa tingkat tinggi menggunakan kemampuan CPU dan GPU di bawah tenda.  GPU sangat baik untuk pemrosesan vektor, dan di banyak aplikasi dan pustaka, pekerjaan CPU dan GPU dibedakan. <br><br>  Misalnya, ini persis situasi ketika menggunakan JavaFX atau Deeplearning4j.  Jika Anda menulis aplikasi antarmuka pengguna menggunakan JavaFX, Anda hanya bekerja dengan kode Java (mungkin juga FXML untuk mendeklarasikan antarmuka pengguna).  Ketika adegan JavaFX perlu ditampilkan di layar, implementasi JavaFX internal menggunakan shader dan tekstur untuk ini, langsung menghubungi driver GPU tingkat rendah, seperti yang ditunjukkan pada Gambar 2. Oleh karena itu, Anda tidak perlu khawatir tentang bagian mana dari kode yang lebih baik disesuaikan untuk bekerja dengan CPU dan yang mana dengan GPU. <br><br><img src="https://habrastorage.org/webt/lo/ni/um/loniumkhuuzidq5syb6z_pimfqe.png"><br><br>  <i>Fig.</i>  <i>2. JavaFX mendelegasikan pekerjaan GPU dan CPU.</i> <br><br>  Seperti yang ditunjukkan pada gambar.  2, kode implementasi JavaFX mendelegasikan pekerjaan dengan meneruskannya ke GPU dan CPU.  Meskipun operasi ini disembunyikan dari pengembang (tidak disediakan melalui API), pengetahuan tertentu tentang GPU sering berguna ketika Anda perlu mengembangkan aplikasi JavaFX yang lebih kuat. <br><br>  Saat menggunakan Deeplearning4j, situasi serupa terjadi.  Deeplearning4j memiliki sejumlah implementasi untuk melakukan operasi vektor dan matriks yang diperlukan, dan beberapa di antaranya menggunakan GPU.  Namun, tidak masalah bagi Anda sebagai pengembang akhir yang kapasitas kode Anda akan digunakan - CPU atau GPU. <br><br>  Tampaknya komputer kuantum akan melakukan pekerjaan yang sangat baik untuk menyelesaikan masalah yang, sebagai suatu peraturan, meningkat secara eksponensial ketika volume masalah bertambah dan, oleh karena itu, hampir tidak dapat dipecahkan atau hampir tidak dapat dipecahkan menggunakan komputer klasik.  Secara khusus, para ahli berbicara tentang perwujudan hibrida: aplikasi end-to-end khas berisi kode klasik yang berjalan pada CPU, tetapi mungkin juga mengandung kode kuantum. <br><br><h4>  Bagaimana sistem mengeksekusi kode kuantum? </h4><br>  Saat ini, perangkat keras untuk komputer kuantum masih sangat eksperimental.  Sementara perusahaan besar dan, mungkin, beberapa negara terlibat dalam pengembangan prototipe, teknologi seperti itu tidak tersedia secara luas.  Tetapi, ketika muncul, bentuknya mungkin berbeda: <br><br><ul><li>  Sebuah prosesor kuantum dapat diintegrasikan dengan CPU dalam sistem. </li><li>  Masalah kuantum dapat didelegasikan ke sistem cloud kuantum. </li></ul><br>  Meskipun masih ada ketidakpastian besar tentang latar belakang praktis dari keputusan semacam itu, kami semakin sepakat tentang bagaimana seharusnya kode kuantum.  Pada level terendah haruslah batu bata berikut: <i>qubit</i> dan <i>gerbang kuantum</i> .  Berdasarkan mereka, Anda dapat membuat <i>simulator kuantum</i> yang menerapkan perilaku yang diharapkan. <br><br>  Oleh karena itu, simulator kuantum adalah alat yang ideal untuk pengembangan semacam itu. <br>  Hasil yang mereka berikan harus hampir sama dengan yang akan diperoleh pada peralatan nyata komputer kuantum - tetapi simulator bekerja lebih lambat, karena efek kuantum yang mempercepat peralatan kuantum harus disimulasikan menggunakan perangkat lunak tradisional. <br><br><h4>  Apa blok bangunan dasar komputasi kuantum? </h4><br>  Seringkali penting untuk membandingkan perhitungan klasik dengan perhitungan kuantum.  Dalam komputasi klasik, kami memiliki bit dan gerbang. <br><br>  Sedikit mengandung sedikit informasi, dan nilainya mungkin 0 atau 1. <br>  Katup bekerja pada satu atau lebih bit dan dapat beroperasi pada mereka.  Sebagai contoh, katup NOT, ditunjukkan pada Gambar 3, membalikkan nilai bit.  Jika inputnya 0, maka output dari gerbang NOT akan menjadi 1 dan sebaliknya. <br><br><img src="https://habrastorage.org/webt/si/3q/o9/si3qo9r_ri2pwgthjqdboizvbni.png"><br><br>  <i>Fig.</i>  <i>3. BUKAN katup</i> <br><br>  Dalam komputasi kuantum, kami memiliki bit dan gerbang yang setara.  Setara kuantum bit adalah qubit.  Nilai qubit bisa sama dengan 0 atau 1, seperti bit klasik, namun, itu juga bisa disebut superposisi.  Ini adalah konsep yang kompleks, di mana qubit dapat secara bersamaan berada di kedua negara: 0 dan 1. <br><br>  Ketika qubit dalam superposisi, nilainya adalah kombinasi linear dari status 0 dan 1. Ini dapat ditulis seperti yang ditunjukkan pada Gambar.  4: <br><br><img src="https://habrastorage.org/webt/gw/oy/o1/gwoyo19gwbizhzgmnxcix5z7kja.jpeg"><br><br>  <i>Fig.</i>  <i>4. Kesetaraan di mana qubit berada di superposisi.</i> <br><br>  Catatan: qubit sering ditulis dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">notasi braket</a> , di mana nama variabel ditempatkan di antara karakter "|"  dan "&gt;". <br><br>  Ekspresi pada Gambar.  4 melaporkan bahwa qubit x berada dalam superposisi status | 0&gt; dan | 1&gt;.  Ini tidak berarti bahwa ia dalam keadaan | 0&gt; ATAU dalam keadaan | 1&gt;;  ini berarti bahwa keadaannya saat ini tidak diketahui oleh kita. <br><br>  Faktanya, itu ada di kedua negara pada saat yang bersamaan, dan dalam bentuk ini dapat dimanipulasi.  Namun, ketika kita mengukur qubit, itu akan berada dalam satu keadaan, baik | 0&gt; atau | 1&gt;.  Ada batasan lain dalam ungkapan di atas: a ^ 2 + b ^ 2 = 1. <br>  Nilai a dan b adalah probabilistik: ada probabilitas a ^ 2 bahwa, ketika kita mengukur qubit | x&gt;, itu akan berisi nilai | 0&gt;, dan probabilitas b ^ 2 bahwa qubit yang diukur akan berisi nilai | 1&gt;. <br><br>  Ada faktor pembatas penting yang memutus kegembiraan komputasi kuantum: setelah qubit diukur, semua informasi tentang superposisi potensial tempat ia berada hilang.  Nilai qubit bisa 0 atau 1. <br><br>  Dalam perhitungan, qubit dalam superposisi dapat sesuai dengan 0 dan 1 pada saat yang sama (dengan probabilitas berbeda).  Jika kita memiliki dua qubit, maka mereka dapat digunakan untuk mewakili empat negara (00, 01, 10, dan 11), sekali lagi, dengan probabilitas yang berbeda.  Di sini kita sampai pada esensi kekuatan komputer kuantum.  Memiliki delapan bit klasik, Anda dapat mewakili tepat satu angka dalam rentang dari 0 hingga 255. Nilai dari masing-masing delapan bit adalah 0 atau 1. Memiliki delapan qubit, Anda dapat secara bersamaan mewakili semua angka dari 0 hingga 255. <br><br><h4>  Apa gunanya superposisi jika Anda hanya bisa mengukur satu negara? </h4><br>  Seringkali hasil dari algoritma ini sederhana (ya atau tidak), tetapi untuk sampai pada itu, banyak komputasi paralel diperlukan.  Memegang qubit dalam posisi superposisi selama perhitungan, Anda dapat segera mempertimbangkan berbagai opsi.  Tanpa memenuhi keputusan untuk setiap kombinasi individu, komputer kuantum dapat menghitung semua opsi dalam satu langkah. <br>  Kemudian, dalam banyak algoritma kuantum, tahap penting berikutnya dimulai: untuk menghubungkan hasil algoritma dengan pengukuran yang memberikan hasil yang bermakna.  Seringkali, gangguan diperhitungkan: hasil yang menarik secara struktural ditumpukkan satu sama lain, sementara yang tidak menarik membatalkan satu sama lain (gangguan destruktif). <br><br><h4>  Bagaimana seseorang bisa "mengubah" qubit menjadi kondisi superposisi? </h4><br>  Sama seperti gerbang klasik memanipulasi bit, gerbang kuantum memanipulasi qubit.  Beberapa gerbang kuantum menyerupai yang klasik;  misalnya, gerbang Pauli-X mentransfer qubit dari state a | 0&gt; + b | 1&gt; ke state b | 0 |  + a | 1&gt;, yang mirip dengan prinsip gerbang NOT klasik.  Memang, ketika a = 1 dan b = 0, qubit awalnya dalam keadaan | 0&gt;.  Setelah aksi katup Pauli-X, qubit ini akan masuk ke status | 1&gt;, seperti yang ditunjukkan pada Gambar.  5. <br><br><img src="https://habrastorage.org/webt/vi/jd/np/vijdnpok8ttp8wrxzxlzkrpfv3y.png"><br><br>  <i>Fig.</i>  <i>5. Hasil menggunakan katup Pauli-X.</i> <br><br>  Dalam konteks ini, katup Hadamard sangat menarik.  Ini menempatkan qubit di negara | 0&gt;: 1 / sqrt (2) * (| 0&gt; + | 1&gt;) ke dalam superposisi, seperti yang ditunjukkan pada Gambar.  6. <br><br><img src="https://habrastorage.org/webt/ms/oe/rs/msoers9oh3on6umailvyiwom8lg.png"><br><br>  <i>Fig.</i>  <i>6. Hasil penerapan katup Hadamard.</i> <br><br>  Setelah kami menerapkan katup Hadamard ke qubit dan mengukur qubit, ada kemungkinan 50% bahwa nilai qubit akan menjadi 0 dan 50% bahwa nilai qubit akan menjadi 1. Sampai qubit diukur, ia tetap dalam status superposisi . <br><br><h4>  Bagaimana ini semua mungkin? </h4><br>  Jika Anda benar-benar tertarik pada jawaban untuk pertanyaan ini, Anda harus mempelajari fisika kuantum secara terperinci.  Tetapi, untungnya, seluruh dasar teori dari fenomena ini tidak perlu dipahami.  Sementara fenomena superposisi mungkin tampak tidak dapat dipahami, penting untuk menekankan bahwa sifat-sifat inilah yang menjadi ciri khas partikel elementer di alam.  Oleh karena itu, komputasi kuantum jauh lebih dekat dengan dasar-dasar realitas fisik daripada yang terlihat pada pandangan pertama. <br><br><h4>  Haruskah saya menunggu beberapa tahun, dan kemudian melihat lebih dekat pada komputasi kuantum? </h4><br>  Tidak.  Dalam hal ini, Anda akan terlambat.  Secara teori dimungkinkan untuk terlebih dahulu mengembangkan perangkat keras, dan kemudian melanjutkan ke studi tingkat perangkat lunak dan melihat apa yang dapat dicapai dengannya.  Namun, semua konsep sudah lebih atau kurang jelas, dan sudah dimungkinkan untuk menulis simulator kuantum dalam bahasa populer, termasuk Java, C #, Python dan lain-lain. <br>  Kemudian simulator ini dapat digunakan untuk bekerja pada algoritma kuantum.  Meskipun, algoritma ini tidak akan memberikan peningkatan kinerja yang dapat dicapai dengan bantuan mereka ketika bekerja pada peralatan kuantum nyata, mereka harus secara fungsional sepenuhnya lengkap. <br><br>  Jadi, jika Anda sedang mengembangkan algoritma kuantum, maka Anda punya waktu untuk memperbaikinya, dan Anda bisa memulainya ketika peralatan kuantum muncul dalam akses. <br><br>  Algoritma kuantum memerlukan pendekatan intelektual yang berbeda dari yang klasik.  Ilmuwan terkemuka mulai mengembangkan algoritma kuantum kembali pada abad terakhir, dan sekarang semakin banyak artikel yang diterbitkan menggambarkan algoritma seperti itu, termasuk yang untuk perkalian bilangan bulat, pencarian daftar, pekerjaan optimasi jalur, dan banyak lagi. <br><br>  Ada alasan lain mengapa mungkin layak melakukan komputasi kuantum saat ini.  Refactoring sistem perangkat lunak di perusahaan besar modern bukanlah salah satu dari hal-hal yang dapat dilakukan dalam semalam.  Namun, salah satu area di mana komputasi kuantum akan membuat revolusi nyata adalah enkripsi;  setelah semua, itu semua didasarkan pada teori bahwa pada komputer klasik praktis tidak mungkin untuk menguraikan bilangan bulat besar menjadi faktor prima. <br><br>  Meskipun mungkin dibutuhkan bertahun-tahun sebelum komputer kuantum menjadi cukup besar untuk dengan mudah menyelesaikan masalah faktorisasi bilangan bulat, pengembang tahu bahwa perlu bertahun-tahun untuk mengubah sistem dan memperkenalkan teknologi baru yang lebih aman ke dalamnya. <br><br><h4>  Bagaimana saya bisa belajar bekerja dengan algoritma kuantum di Jawa? </h4><br>  Anda dapat mengunduh dan menguasai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Strange</a> , simulator komputer kuantum open source di Jawa.  Strange memungkinkan Anda untuk mensimulasikan algoritma kuantum dengan membuat serangkaian qubit dan menerapkan beberapa gerbang kuantum kepada mereka. <br><br>  Sebagai contoh sederhana, mari kita buat dua qubit, q [0] dan q [1], sehingga awalnya keduanya dalam keadaan 0. Kemudian kita menerapkan dua gerbang sederhana untuk masing-masing qubit, sehingga secara grafis operasi ini sesuai dengan gambar.  7. <br><br>  Qubit pertama akan pertama-tama pergi ke katup Pauli-X, dan kemudian ke katup Hadamard.  Katup Pauli-X akan menerjemahkannya dari keadaan | 0 &amp; gt ke | 1 &amp; gt, dan katup Hadamard akan menerjemahkannya menjadi superposisi dengan probabilitas yang sama | 0 &amp; gt dan | 1 &amp; gt.  Oleh karena itu, jika kita menyelesaikan seluruh urutan 1000 kali dan mengukur qubit pertama 1000 kali pada akhir siklus ini, maka rata-rata kita dapat berharap bahwa dalam 500 kasus ia akan memiliki nilai 0 dan dalam 500 kasus ia akan memiliki nilai 1. <br><br>  Qubit kedua bahkan lebih sederhana.  Kita mulai dengan gerbang Identity, yang tidak mengubah perilaku qubit, dan kemudian meneruskannya ke gerbang Pauli-X, mengubah nilainya dari 0 menjadi 1. <br><br><img src="https://habrastorage.org/webt/wk/5t/ok/wk5tokshympqnwkvw8bj6ia6jys.png"><br><br>  <i>Fig.</i>  <i>7. Contoh algoritma kuantum yang dapat disimulasikan menggunakan Strange.</i> <br><br>  Untuk memastikan alasan kami benar, Anda dapat membuat program kuantum sederhana menggunakan Strange. <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ Program p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Program(<span class="hljs-number"><span class="hljs-number">2</span></span>); Step s = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Step(); s.addGate(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X(<span class="hljs-number"><span class="hljs-number">0</span></span>)); p.addStep(s); Step t = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Step(); t.addGate(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Hadamard(<span class="hljs-number"><span class="hljs-number">0</span></span>)); t.addGate(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X(<span class="hljs-number"><span class="hljs-number">1</span></span>)); p.addStep(t); SimpleQuantumExecutionEnvironment sqee = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleQuantumExecutionEnvironment(); Result res = sqee.runProgram(p); Qubit[] qubits = res.getQubits(); Arrays.asList(qubits).forEach(q -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"qubit with probability on 1 = "</span></span>+q.getProbability()+<span class="hljs-string"><span class="hljs-string">", measured it gives "</span></span>+ q.measure())); }</code> </pre> <br>  Dalam aplikasi ini, program kuantum dengan dua qubit dibuat: <br><br><pre> <code class="java hljs"> Program p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Program(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  Sebagai bagian dari program ini, kami melewati dua tahap.  Pada langkah pertama, terapkan katup Pauli-X ke q [0].  Kami tidak menerapkan katup ke q [1], dan dengan demikian menyiratkan bahwa itu akan bekerja dengan katup Identitas.  Tambahkan langkah ini ke program: <br><br><pre> <code class="java hljs"> Step s = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Step(); s.addGate(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X(<span class="hljs-number"><span class="hljs-number">0</span></span>)); p.addStep(s);</code> </pre> <br>  Kemudian kita menuju ke tahap kedua, di mana kita menerapkan katup Hadamard ke q [0] dan katup Pauli-X ke q [1];  tambahkan langkah ini ke program: <br><br><pre> <code class="java hljs"> Step t = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Step(); t.addGate(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Hadamard(<span class="hljs-number"><span class="hljs-number">0</span></span>)); t.addGate(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X(<span class="hljs-number"><span class="hljs-number">1</span></span>)); p.addStep(t);</code> </pre> <br>  Jadi, program kami sudah siap.  Sekarang mari kita lakukan.  Simulator kuantum dibangun ke Strange, namun, Strange juga dapat menggunakan layanan cloud untuk menjalankan program di beberapa jenis cloud, misalnya, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Oracle Cloud</a> . <br><br>  Dalam contoh berikut, kami menggunakan simulator bawaan yang sederhana, menjalankan program dan mendapatkan qubit yang dihasilkan: <br><br><pre> <code class="java hljs"> SimpleQuantumExecutionEnvironment sqee = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleQuantumExecutionEnvironment(); Result res = sqee.runProgram(p); Qubit[] qubits = res.getQubits();</code> </pre> <br>  Sebelum kami mengukur qubit (dan kehilangan semua informasi), kami menampilkan probabilitas.  Sekarang ukur qubit dan lihat nilainya: <br><br><pre> <code class="java hljs">Arrays.asList(qubits).forEach(q -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"qubit with probability on 1 = "</span></span>+q.getProbability()+<span class="hljs-string"><span class="hljs-string">", measured it gives "</span></span>+ q.measure()));</code> </pre> <br>  Menjalankan aplikasi ini, kami mendapatkan output berikut: <br><br> <code>qubit with probability on 1 = 0.50, measured it gives 1 <br> qubit with probability on 1 = 1, measured it gives 1</code> <br>  Harap dicatat: untuk qubit pertama, nilai 0 juga dapat diukur, seperti yang kami harapkan. <br>  Jika Anda menjalankan program ini berkali-kali, maka nilai qubit pertama rata-rata adalah 0 dalam setengah kasus dan 1 dalam setengah kasus. <br><br><h4>  Apakah hanya itu yang perlu Anda ketahui tentang komputasi kuantum? </h4><br>  Tentu saja tidak.  Di sini kami tidak menyentuh sejumlah konsep penting, khususnya, kami tidak membahas <i>seluk</i> - <i>beluk</i> yang memastikan interaksi antara dua qubit, bahkan jika secara fisik mereka sangat jauh satu sama lain.  Kami tidak berbicara tentang algoritma kuantum yang paling terkenal, di antaranya algoritma Shore, yang memungkinkan penguraian bilangan menjadi faktor utama.  Kami juga mengabaikan sejumlah fakta matematika dan fisik, khususnya, tidak memperhitungkan bahwa dalam superposisi | x&gt; = a | 0&gt; + b | 1&gt;, kedua angka, a dan b, dapat menjadi kompleks. <br><br>  Namun, tujuan utama dari artikel ini adalah untuk memberi Anda kesan komputasi kuantum dan untuk memahami bagaimana mereka masuk ke masa depan pengembangan perangkat lunak. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id450480/">https://habr.com/ru/post/id450480/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id450468/index.html">Membuat game itu tidak sulit. Melihat kembali proyek ponsel kecil di Unity3D</a></li>
<li><a href="../id450472/index.html">Bagaimana cara membuat peta jalan yang sempurna?</a></li>
<li><a href="../id450474/index.html">Pengenalan python</a></li>
<li><a href="../id450476/index.html">Bagaimana kami mendaftarkan perusahaan di UE</a></li>
<li><a href="../id450478/index.html">Saat ini, banyak add-on populer untuk Firefox telah berhenti berfungsi karena masalah sertifikat.</a></li>
<li><a href="../id450484/index.html">Kinerja Animasi Situs Web</a></li>
<li><a href="../id450486/index.html">9. Periksa Titik Memulai R80.20. Kontrol Aplikasi & Penyaringan URL</a></li>
<li><a href="../id450488/index.html">Aplikasi Android Chock Norris Facts di Kotlin</a></li>
<li><a href="../id450490/index.html">Kesepakatan $ 6,9 miliar: mengapa pengembang GPU membeli produsen peralatan jaringan</a></li>
<li><a href="../id450492/index.html">Pekerjaan sosial dan desain terbuka. Pendahuluan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>