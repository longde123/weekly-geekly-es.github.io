<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👧 ⚖️ 🧚🏽 dentang dan IDE: sebuah cerita tentang persahabatan dan persahabatan 👩🏿‍🎓 🏳️‍🌈 👩🏽‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagi saya, itu dimulai enam setengah tahun yang lalu, ketika, dengan kehendak takdir, saya ditarik ke dalam satu proyek tertutup. Proyek siapa - janga...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>dentang dan IDE: sebuah cerita tentang persahabatan dan persahabatan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419009/"><p><img src="https://habrastorage.org/webt/yi/u_/xb/yiu_xbaeyduzvwqklgpu5xujgvo.png" align="left">  Bagi saya, itu dimulai enam setengah tahun yang lalu, ketika, dengan kehendak takdir, saya ditarik ke dalam satu proyek tertutup.  Proyek siapa - jangan tanya, saya tidak akan memberi tahu.  Saya hanya bisa mengatakan bahwa idenya sederhana seperti menyapu: menanamkan front-end dentang dalam IDE.  Yah, seperti yang baru-baru ini dilakukan di QtCreator, di CLion (dalam arti tertentu), dll. Dentang waktu itu adalah bintang yang sedang naik daun, banyak yang berjalan lamban di sekitar kemungkinan akhirnya menggunakan parser C ++ yang lengkap hampir gratis.  Dan idenya, bisa dikatakan, secara harfiah ada di udara (dan autocomplet dari kode yang dibangun ke dalam dentang API adalah seperti yang disiratkan oleh Be), Anda hanya harus mengambil dan melakukannya.  Tapi, seperti yang dikatakan Boromir, "Kamu tidak bisa menerimanya, dan ...".  Jadi itu terjadi dalam kasus ini.  Untuk detail - Selamat datang di bawah kucing. </p><a name="habracut"></a><br><h2 id="snachala-o-horoshem">  Pertama tentang yang baik </h2><br><p>  Manfaat menggunakan dentang sebagai parser bawaan di IDE C ++, tentu saja, adalah.  Pada akhirnya, fungsi IDE tidak terbatas hanya untuk mengedit file.  Ini adalah basis data karakter, dan tugas navigasi, dan dependensi, dan banyak lagi.  Dan di sini kompiler lengkap mengarahkan setinggi-tingginya, karena untuk mengalahkan semua kekuatan preprosesor dan templat dalam parser yang ditulis sendiri yang relatif sederhana adalah tugas yang tidak sepele.  Karena Anda biasanya harus membuat banyak kompromi, yang jelas mempengaruhi kualitas parsing kode.  Siapa yang peduli - dapat melihat, katakan, pada parser bawaan QtCeator di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Qt Creator C ++ parser</a> </p><br><p>  Di tempat yang sama, dalam kode sumber QtCreator, Anda dapat melihat bahwa di atas tidak semua yang diperlukan oleh IDE dari parser.  Selain itu, Anda membutuhkan setidaknya: </p><br><ul><li>  penyorotan sintaksis (leksikal dan semantik) </li><li>  segala macam petunjuk "on the fly" dengan tampilan informasi pada simbol </li><li>  petunjuk tentang apa yang salah dengan kode dan cara memperbaikinya / menambahnya </li><li>  Penyelesaian Kode dalam berbagai konteks </li><li>  refactoring paling beragam </li></ul><br><p>  Oleh karena itu, pada manfaat yang tercantum sebelumnya (benar-benar serius!), Nilai plus berakhir dan rasa sakit dimulai.  Untuk lebih memahami rasa sakit ini, pertama-tama Anda dapat melihat laporan oleh Anastasia Kazakova ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">anastasiak2512</a> ) tentang apa yang sebenarnya diperlukan dari parser kode yang ada di dalam IDE: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/4giOynD7Emg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="sut-problemy">  Inti dari masalah </h2><br><p>  Tapi itu sederhana, meskipun mungkin tidak jelas pada pandangan pertama.  Singkatnya, maka: dentang adalah <em>kompiler</em> .  Dan merujuk pada kode sebagai <em>kompiler</em> .  Dan dipertajam oleh fakta bahwa kode yang diberikan kepadanya sudah selesai, dan bukan tulisan rintisan file yang sekarang terbuka di editor IDE.  Compiler tidak menyukai bit file, seperti konstruksi yang tidak lengkap, pengidentifikasi yang ditulis secara tidak benar, <strong>retrun</strong> alih-alih <strong>kembali,</strong> dan kesenangan lain yang dapat muncul di sini dan sekarang di editor.  Tentu saja, sebelum dikompilasi, semua ini akan dibersihkan, diperbaiki, disatukan.  Tetapi di sini dan sekarang, di dalam editor, itu adalah apa adanya.  Dan dalam bentuk inilah parser yang dibangun ke dalam IDE sampai ke meja setiap 5-10 detik.  Dan jika versi yang ditulis sendiri dengan sempurna "memahami" bahwa itu berurusan dengan produk setengah jadi, maka dentang - tidak.  Dan sangat terkejut.  Apa yang terjadi sebagai akibat kejutan seperti itu bergantung pada "pada", seperti yang mereka katakan. </p><br><p>  Untungnya, dentang cukup toleran terhadap kesalahan kode.  Namun demikian, mungkin ada kejutan - tiba-tiba menghilang lampu latar, kurva lengkapi-otomatis, diagnostik aneh.  Anda harus siap untuk semua ini.  Selain itu, dentang tidak omnivora.  Dia berhak untuk tidak menerima apa pun di header kompiler, yang di sini dan sekarang digunakan untuk membangun proyek.  Fitur intrinsik yang rumit, ekstensi non-standar, dan lainnya, um ..., semua ini dapat menyebabkan kesalahan penguraian di tempat yang paling tidak terduga.  Dan, tentu saja, kinerja.  Mengedit file tata bahasa di Boost.Spirit atau mengerjakan proyek berbasis llvm akan menyenangkan.  Tapi, tentang semuanya lebih detail. </p><br><h2 id="kod-polufabrikat">  Kode Pracetak </h2><br><p>  Jadi, katakanlah Anda memulai proyek baru.  Lingkungan Anda menghasilkan blank default untuk main.cpp, dan di dalamnya Anda menulis: </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; int main() { foo(10) }</span></span></span></span></code> </pre> <br><p>  Kode, dari sudut pandang C ++, terus terang, tidak valid.  Tidak ada definisi fungsi foo (...) dalam file, garis tidak selesai, dll. Tapi ... Anda baru saja mulai.  Kode ini memiliki hak untuk jenis ini.  Bagaimana kode ini memahami IDE dengan parser yang ditulis sendiri (dalam hal ini CLion)? </p><br><p><img src="https://habrastorage.org/webt/us/8y/ni/us8yni2bzf5zpm6epgx_uh7m4bs.png"></p><br><p>  Dan jika Anda mengklik bola lampu, maka Anda dapat melihat ini: </p><br><p><img src="https://habrastorage.org/webt/p2/ej/h4/p2ejh4woiuojsq19oq90rmozhrm.png"></p><br><p>  IDE semacam itu, mengetahui sesuatu, um, lebih banyak tentang apa yang terjadi, menawarkan opsi yang sangat diharapkan: untuk membuat fungsi dari konteks penggunaan.  Tawaran yang bagus, saya pikir.  Bagaimana IDE berbasis dentang berperilaku (dalam hal ini, Qt Creator 4.7)? </p><br><p><img src="https://habrastorage.org/webt/ql/pa/hj/qlpahj0vu5of_my6s1ymrelsa3o.png"></p><br><p>  Dan apa yang diusulkan untuk memperbaiki situasi?  Tapi tidak ada apa-apa!  Hanya ganti nama standar! </p><br><p><img src="https://habrastorage.org/webt/kk/0m/pt/kk0mptuuwnufqjugzumnoisnyms.png"></p><br><p>  Alasan untuk perilaku ini sangat sederhana: untuk dentang, teks ini lengkap (dan tidak bisa apa pun).  Dan dia membangun AST berdasarkan asumsi ini.  Dan kemudian semuanya sederhana: dentang melihat pengidentifikasi yang sebelumnya tidak ditentukan.  Ini adalah teks dalam C ++ (bukan dalam C).  Tidak ada asumsi yang dibuat tentang sifat pengidentifikasi - tidak ditentukan, sehingga sepotong kode tidak valid.  Dan di AST untuk baris ini tidak ada yang muncul.  Dia tidak ada di sana.  Dan apa yang tidak ada di AST tidak mungkin dianalisis.  Ini memalukan, menyebalkan, oke. </p><br><p>  Parser yang dibangun ke dalam IDE berasal dari beberapa asumsi lain.  Dia <em>tahu</em> bahwa kode itu belum selesai.  Bahwa programmer sekarang sedang sibuk berpikir dan jari-jari di belakangnya tidak punya waktu.  Oleh karena itu, tidak semua pengidentifikasi dapat didefinisikan.  Kode seperti itu, tentu saja, tidak benar dari sudut pandang standar kualitas kompiler yang tinggi, tetapi parser tahu apa yang dapat dilakukan dengan kode tersebut dan menawarkan opsi.  Pilihan yang cukup masuk akal. </p><br><p>  Setidaknya hingga versi 3.7 (inklusif), masalah serupa terjadi dalam kode ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; class Temp { public: int i; }; template&lt;typename T&gt; class Foo { public: int Bar(Temp tmp) { Tpl(tmp); } private: template&lt;typename U&gt; void Tpl(U val) { Foo&lt;U&gt; tmp(val); tmp. } int member; }; int main() { return 0; }</span></span></span></span></code> </pre> <br><p>  Di dalam metode kelas template, autocomplet berbasis dentang tidak berfungsi.  Sejauh yang saya ketahui, alasannya ada pada parsing templat dua lintasan.  Autocomplete di dentang dipicu pada pass pertama, ketika informasi tentang jenis yang sebenarnya digunakan mungkin tidak cukup.  Di dentang 5.0 (dinilai oleh Catatan Rilis), ini diperbaiki. </p><br><p>  Dengan satu atau lain cara, situasi di mana kompiler tidak dapat membangun AST yang benar (atau menarik kesimpulan yang benar dari konteks) dalam kode yang diedit mungkin.  Dan dalam hal ini, IDE tidak akan "melihat" bagian teks yang sesuai dan tidak akan dapat membantu programmer dengan cara apa pun.  Yang tentu saja tidak bagus.  Kemampuan untuk bekerja secara efektif dengan kode yang salah adalah apa yang dibutuhkan parser dalam IDE, dan apa yang tidak dibutuhkan oleh kompiler biasa sama sekali.  Oleh karena itu, parser dalam IDE dapat menggunakan banyak heuristik, yang bagi kompiler tidak hanya tidak berguna, tetapi juga berbahaya.  Dan untuk mengimplementasikan dua mode operasi di dalamnya - yah, Anda masih perlu meyakinkan pengembang. </p><br><h2 id="eta-rol---rugatelnaya">  "Peran ini kasar!" </h2><br><p>  IDE programmer biasanya satu (well, two), tetapi ada banyak proyek dan toolchains.  Dan, tentu saja, saya tidak ingin melakukan gerakan ekstra untuk beralih dari toolchain ke toolchain, dari proyek ke proyek.  Satu atau dua klik, dan konfigurasi bangunan berubah dari Debug ke Rilis, dan kompiler dari MSVC ke MinGW.  Tetapi parser kode dalam IDE tetap sama.  Dan dia harus, bersama dengan sistem build, beralih dari satu konfigurasi ke konfigurasi lain, dari satu toolchain ke yang lain.  Toolchain bisa menjadi semacam eksotis, atau salib.  Dan tugas parser di sini adalah terus mengurai kode dengan benar.  Jika memungkinkan dengan kesalahan minimal. </p><br><p>  dentang cukup omnivora.  Dapat dipaksa untuk menerima ekstensi kompiler dari Microsoft, kompiler gcc.  Ini dapat melewati opsi dalam format kompiler ini, dan dentang bahkan akan memahaminya.  Tetapi semua ini tidak menjamin bahwa dentang akan menerima tajuk dari jeroan ayam itik yang dikumpulkan dari tangki gcc.  Setiap __builtin_intrinsic_xxx dapat menjadi penghalang baginya.  Atau bahasa mengkonstruksi bahwa versi clang saat ini di IDE tidak mendukung.  Kemungkinan besar, ini tidak akan mempengaruhi kualitas konstruksi AST untuk file yang saat ini diedit.  Tetapi membangun basis karakter global atau menyimpan tajuk yang sudah dikompilasi dapat dihancurkan.  Dan ini bisa menjadi masalah serius.  Masalah yang sama mungkin berubah menjadi kode yang serupa tidak di header dari toolchains atau pihak ketiga, tetapi di header atau kode sumber proyek.  Omong-omong, semua ini adalah alasan yang cukup signifikan untuk secara eksplisit memberi tahu sistem build (dan IDE) tentang file header mana untuk proyek Anda yang "asing".  Itu bisa membuat hidup lebih mudah. </p><br><p>  Sekali lagi, IDE awalnya dirancang untuk digunakan dengan berbagai kompiler, pengaturan, toolchains, dan banyak lagi.  Dirancang untuk berurusan dengan kode, beberapa elemen yang tidak didukung.  Siklus rilis IDE (tidak semua :)) lebih pendek dari pada kompiler, oleh karena itu, ada potensi untuk lebih cepat menarik fitur baru dan menanggapi masalah yang ditemukan.  Dalam dunia kompiler, semuanya sedikit berbeda: siklus rilis setidaknya satu tahun, masalah kompatibilitas lintas-kompiler diselesaikan dengan kompilasi bersyarat dan diteruskan ke pundak pengembang.  Kompiler tidak harus bersifat universal dan omnivora - kompleksitasnya sudah tinggi.  dentang tidak terkecuali. </p><br><h2 id="borba-za-skorost">  Perjuangan untuk kecepatan </h2><br><p>  Bagian dari waktu yang dihabiskan di IDE, ketika programmer tidak duduk di debugger, dia mengedit teks.  Dan keinginan alaminya di sini adalah untuk membuatnya nyaman (jika tidak mengapa sebuah IDE? Dapatkah saya bertahan dengan notepad!) Kenyamanan, khususnya, melibatkan kecepatan reaksi editor yang tinggi terhadap perubahan teks dan menekan tombol cepat.  Seperti yang dicatat Anastasia dengan benar dalam laporannya, jika lima detik setelah menekan Ctrl + Spasi lingkungan tidak merespons dengan tampilan menu atau daftar pelengkapan otomatis, ini mengerikan (serius, coba sendiri).  Dalam angka, ini berarti bahwa parser yang tertanam dalam IDE memiliki sekitar satu detik untuk mengevaluasi perubahan dalam file dan membangun kembali AST, dan satu setengah atau dua untuk menawarkan pengembang pilihan yang peka konteks.  Kedua  Yah, mungkin dua.  Selain itu, perilaku yang diharapkan adalah jika pengembang mengubah nama panggilan .h, dan kemudian beralih ke .cpp-shnik, maka perubahan yang dilakukan akan "terlihat".  File-file ini, di sini, dibuka di jendela tetangga.  Dan sekarang perhitungannya sederhana.  Jika dentang, diluncurkan dari baris perintah, dapat mengatasi kode sumber dalam waktu sekitar sepuluh hingga dua puluh detik, lalu di mana alasan untuk percaya bahwa ketika diluncurkan dari IDE, kode itu akan mengatasi kode sumber lebih cepat dan masuk ke dalam satu atau dua detik?  Artinya, itu akan bekerja urutan besarnya lebih cepat?  Secara umum, ini bisa selesai, tetapi saya tidak akan. </p><br><p>  Sekitar sepuluh hingga dua puluh detik ke sumbernya, tentu saja, saya melebih-lebihkan.  Meskipun, jika beberapa API berat dimasukkan di sana atau, katakanlah, boost.spirit dengan Hana di ready, dan kemudian semua ini secara aktif digunakan dalam teks, maka 10-20 detik masih merupakan nilai yang baik.  Tetapi bahkan jika AST siap beberapa detik setelah tiga atau empat setelah peluncuran parser built-in - itu sudah lama.  Asalkan peluncuran tersebut harus seperti biasa (untuk mempertahankan model kode dan indeks dalam keadaan yang konsisten, sorot, cepat, dll.), Serta sesuai permintaan - penyelesaian kode juga merupakan peluncuran kompiler.  Apakah mungkin untuk mengurangi waktu ini?  Sayangnya, dalam hal menggunakan dentang sebagai pengurai, tidak ada banyak kemungkinan.  Alasan: ini adalah alat pihak ketiga di mana ( <em>idealnya</em> ) perubahan tidak dapat dilakukan.  Yaitu, menggali kode dentang dengan perftool, mengoptimalkan, menyederhanakan beberapa cabang - fitur ini tidak tersedia dan Anda harus melakukan dengan apa yang disediakan API eksternal (dalam kasus menggunakan libclang, itu juga cukup sempit). </p><br><p>  Yang pertama, jelas, dan, pada kenyataannya, satu-satunya solusi adalah menggunakan header yang dikompilasi yang dihasilkan secara dinamis.  Dengan implementasi yang memadai, solusinya adalah pembunuh.  Meningkatkan kecepatan kompilasi setidaknya kali.  Esensinya sederhana: lingkungan mengumpulkan semua header pihak ketiga (atau header di luar root proyek) ke dalam file .h tunggal, membuat pch dari file ini, dan kemudian secara implisit menyertakan pch ini di setiap sumber.  Tentu saja, efek samping yang jelas muncul: dalam kode sumber ( <em>pada tahap pengeditan</em> ), simbol dapat dilihat yang tidak termasuk di dalamnya.  Tapi ini adalah biaya untuk kecepatan.  Saya harus memilih.  Dan semuanya akan baik-baik saja, jika bukan karena satu masalah kecil: dentang masih kompiler.  Dan, sebagai kompiler, dia tidak suka kesalahan dalam kode.  Dan jika tiba-tiba (tiba-tiba! - lihat bagian sebelumnya) ada kesalahan dalam header, maka file .pch tidak dibuat.  Setidaknya sampai versi 3.7.  Apakah ada yang berubah dalam hal ini sejak itu?  Saya tidak tahu, ada kecurigaan bahwa tidak.  Sayangnya, tidak ada lagi kesempatan untuk memeriksa. </p><br><p>  Pilihan alternatif, sayangnya, tidak tersedia untuk alasan yang sama: dentang adalah kompiler dan "dalam dirinya sendiri".  Campur tangan aktif dalam proses pembuatan AST, entah bagaimana membuatnya menggabungkan AST dari bagian yang berbeda, mempertahankan basis simbol eksternal dan te dan te - sayangnya, semua fitur ini tidak tersedia.  Hanya API eksternal, hanya hardcore dan pengaturan yang tersedia melalui opsi kompilasi.  Dan kemudian analisis AST yang dihasilkan.  Jika Anda menggunakan versi C ++ - API, maka lebih banyak peluang tersedia.  Misalnya, Anda dapat bermain-main dengan FrontendActions kustom, membuat pengaturan yang lebih baik untuk opsi kompilasi, dll. Tetapi dalam kasus ini, poin utama tidak akan berubah - teks yang diedit (atau diindeks) akan dikompilasi secara independen dari yang lain dan sepenuhnya.  Itu saja.  Intinya. </p><br><p>  Mungkin (mungkin!) Suatu hari akan ada garpu dentang hulu yang dirancang khusus untuk digunakan sebagai bagian dari IDE.  Mungkin  Tetapi untuk sekarang, semuanya seperti apa adanya.  Katakanlah integrasi tim Qt Creator (ke tahap "terakhir") dengan libclang memakan waktu tujuh tahun.  Saya mencoba QtC 4.7 dengan mesin berbasis libclang - Saya akui, saya pribadi suka versi lama (pada versi yang ditulis sendiri) lebih sederhana karena berfungsi lebih baik pada case saya: ia meminta dan menyoroti, dan yang lainnya.  Saya tidak akan melakukan estimasi berapa jam manusia yang mereka habiskan untuk integrasi ini, tetapi saya berani menyarankan bahwa selama waktu ini akan mungkin untuk menyelesaikan parser saya sendiri.  Sejauh yang saya tahu (dengan indikasi tidak langsung), tim yang bekerja pada CLion terlihat hati-hati menuju integrasi dengan libclang / clang ++.  Tetapi ini semua murni asumsi pribadi.  Integrasi pada tingkat Protokol Server Bahasa adalah pilihan yang menarik, tetapi khusus untuk kasus C ++, saya cenderung menganggap ini lebih sebagai paliatif karena alasan yang tercantum di atas.  Ini hanya mentransfer masalah dari satu tingkat abstraksi ke tingkat lain.  Tapi mungkin saya salah untuk LSP - masa depan.  Ayo lihat.  Tapi bagaimanapun, kehidupan pengembang IDE modern untuk C ++ penuh dengan petualangan - dengan dentang sebagai backend, atau tanpa itu. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id419009/">https://habr.com/ru/post/id419009/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418999/index.html">[Pengumuman, Peter] JUG.ru bertemu dengan Andrei Belyaev dan Alexei Stukalov - Troll menekan CUBA: FAQ</a></li>
<li><a href="../id419001/index.html">5 "keterampilan super" diperlukan untuk pekerjaan di masa depan</a></li>
<li><a href="../id419003/index.html">Intisari Blockchain</a></li>
<li><a href="../id419005/index.html">Wisata ke gardu 220/110/20</a></li>
<li><a href="../id419007/index.html">Tekstur untuk intro 64k: bagaimana hal itu dilakukan hari ini</a></li>
<li><a href="../id419011/index.html">Jinja2 di dunia C ++, bagian dua. Rendering</a></li>
<li><a href="../id419013/index.html">Atribusi berbasis corong untuk bisnis SaaS B2B - karena kami mempertimbangkan nilai semua upaya pemasaran</a></li>
<li><a href="../id419017/index.html">Apa yang Baru di ConstraintLayout 1.1</a></li>
<li><a href="../id419019/index.html">AlterEgo: perangkat yang dapat membaca (beberapa) pikiran</a></li>
<li><a href="../id419021/index.html">Jenis-jenis utama pencetakan dan fitur-fiturnya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>