<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóëÔ∏è üåÇ üë≤üèª Erros ao trabalhar com o teclado do sistema üë¥üèæ üçù üßòüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Interagindo com o aplicativo, em algum momento ativamos o teclado do sistema para digitar uma mensagem ou preencher os campos obrigat√≥rios. Voc√™ j√° en...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erros ao trabalhar com o teclado do sistema</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/462515/">  <em>Interagindo com o aplicativo, em algum momento ativamos o teclado do sistema para digitar uma mensagem ou preencher os campos obrigat√≥rios.</em>  <em>Voc√™ j√° encontrou situa√ß√µes em que o teclado √© exibido, mas n√£o h√° campo para inserir uma mensagem ou vice-versa - o teclado est√° l√°, onde inserir texto n√£o √© vis√≠vel?</em>  <em>Os erros podem estar relacionados a problemas em um aplicativo espec√≠fico, bem como a defici√™ncias gerais do teclado do sistema.</em> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>Konstantin Mordan</em></a> <em>, desenvolvedor de iOS do Mail.ru, viu tudo em seu trabalho: depois de analisar os m√©todos de controle de teclado no iOS, ele decidiu compartilhar os principais bugs e abordagens que ele usava para detect√°-los e corrigi-los.</em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fb/wc/xg/fbwcxgdtopdtlj8_u7rkj1vnmne.jpeg" width="400"></div><br><br>  <i>Cuidado: por baixo do corte, colocamos muitos gifs para demonstrar claramente os erros.</i>  <i>Voc√™ encontrar√° ainda mais exemplos no relat√≥rio de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">v√≠deo</a> do Konstantin no AppsConf.</i> <br><a name="habracut"></a><br><h1>  Implementando uma Chamada de Teclado do Sistema </h1><br>  Vamos come√ßar entendendo como implementar uma chamada de teclado em geral. <br><br>  Imagine que voc√™ esteja desenvolvendo um aplicativo cuja tarefa √© montar Aika (um personagem de South Park) em um canadense inteiro usando o teclado.  Quando voc√™ pressiona Aiku no est√¥mago, o teclado sai, elevando assim as pernas do nosso her√≥i na cabe√ßa. <br><br>  Para implementar a tarefa, voc√™ pode usar <i>InputAccessoryView</i> ou processar notifica√ß√µes do sistema. <br><br><h2>  InputAccessoryView </h2><br>  Vamos olhar para a primeira op√ß√£o. <br><br>  No ViewController, crie uma View que suba junto com o teclado e forne√ßa um quadro.  √â importante que essa visualiza√ß√£o n√£o seja adicionada como uma subvis√£o.  Em seguida, substitu√≠mos as propriedades <em>canBecomeFirstResponder</em> e retornamos true.  Depois de redefinirmos a propriedade <em>UIResponder</em> - <em>inputAccessoryView</em> e colocar a View l√°.  Para fechar o teclado, adicione <em>tapGesture</em> e, em seu manipulador, <em>redefina o firstResponder da</em> View que criamos. <br><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tummyView: <span class="hljs-type"><span class="hljs-type">UIView</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> frame = <span class="hljs-type"><span class="hljs-type">CGRect</span></span>(x: x, y: y, width: width, height: height) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> v = <span class="hljs-type"><span class="hljs-type">TummyView</span></span>(frame: frame) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> canBecomeFirstResponder: <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> input <span class="hljs-type"><span class="hljs-type">AccessoryView</span></span>: <span class="hljs-type"><span class="hljs-type">UIView?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tummyView } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tapHandler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> { tummyView.resignFirstResponder ( ) } }</code> </pre> <br>  A tarefa √© conclu√≠da e o pr√≥prio sistema processa as altera√ß√µes de estado do teclado, mostra e eleva a Visualiza√ß√£o, que depende dela. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ew/mu/nd/ewmundnnrpbdgjgwvk_frx4qv6o.gif" width="200"></div><br><br><h2>  Processamento de notifica√ß√£o do sistema </h2><br>  No caso de processar notifica√ß√µes, teremos que processar as notifica√ß√µes dos seguintes grupos: <br><br><ul><li>  quando o teclado ser√° / foi mostrado: keyboardWillShowNotification, keyboardDidShowNotification; </li><li>  quando o teclado ficar√° / estava oculto: keyboardWillHideNotification, keyboardDidHideNotification; </li><li>  quando o quadro do teclado ser√° / foi alterado: keyboardWilChangeFrameNotification, keyboardDidChangeFrameNotification. </li></ul><br>  Para implementar nosso caso, vamos usar <em>keyboardWilChangeFrameNotification</em> , pois essa notifica√ß√£o √© enviada quando o teclado √© mostrado e quando est√° oculto. <br><br>  Criamos um <em>keyboardTracker,</em> nele assinamos para receber uma notifica√ß√£o <em>keyboardWillChangeFrame</em> e, no manipulador, obtemos o quadro do teclado, convertemos do sistema de coordenadas da tela para o sistema de coordenadas da janela, calculamos a altura do teclado e alteramos o valor Y da tela, que deve ser aumentada pelo teclado para esta altura. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyboardTracker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enable</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> { notificationCenter.add0observer(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, seletor: #selector( keyboardWillChangeFrame), name: <span class="hljs-type"><span class="hljs-type">UIResponder</span></span>.keyboardWillChangeFrameNotification, object: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyboardWillChangeFrame</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notification: NSNotification)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> screenCoordinatedKeyboardFrame = (userInfo [ <span class="hljs-type"><span class="hljs-type">UIResponder</span></span>.keyboardFrameEndUserInfoKey ] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">NSValue</span></span> ) .cgRectValue <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> keyboardFrame = window.convert ( screenCoordinatedKeyboardFrame, from: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> windowHeight = window.frame.height <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> keyboardHeight = windowHeight - keyboardFrame.minY delegate.keyboardWillChange ( keyboardHeight ) } }</code> </pre> <br>  Com isso, nossa tarefa est√° conclu√≠da, o teclado sobe, coletando Ike no canadense. <br><br>  Como podemos ver, a implementa√ß√£o do trabalho com o teclado √© bastante f√°cil nos dois casos, para que todos sejam livres para escolher o m√©todo apropriado por conta pr√≥pria.  Em nosso projeto, fizemos uma escolha a favor das notifica√ß√µes, para que mais exemplos e percep√ß√µes sejam associados ao processamento das notifica√ß√µes. <br><br><h2>  Procurando por bugs </h2><br>  Se a maneira de chamar o teclado √© t√£o simples, de onde v√™m os erros?  Obviamente, se o aplicativo reproduzir apenas o script para abrir e fechar o teclado, n√£o haver√° problemas.  Mas se voc√™ alterar o curso normal das coisas, lembre-se de que n√£o apenas nosso aplicativo pode usar o teclado, mas tamb√©m outros, e o usu√°rio tamb√©m pode alternar entre eles, ent√£o surpresas n√£o podem ser evitadas. <br><br>  Vejamos um exemplo.  Para fazer isso, use nosso aplicativo com Ike: abra o teclado, mude para o Notes, imprima algo e volte ao aplicativo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zm/nr/4n/zmnr4nm4u8tph3bf86jkr05ix5k.gif" width="200"></div><br><br>  Que problemas j√° s√£o vis√≠veis?  Em primeiro lugar, n√£o h√° teclado no App Switcher, embora quando voc√™ minimizasse o aplicativo e, em vez dele, outro conte√∫do estivesse vis√≠vel.  Em segundo lugar, quando voc√™ retorna ao aplicativo, o teclado ainda n√£o est√° l√° e as pernas de Ike caem na tela. <br><br>  Vejamos os motivos desse comportamento.  Como todos lembramos no diagrama do ciclo de vida do aplicativo, a transi√ß√£o de um aplicativo de um estado ativo para um estado inativo primeiro em primeiro plano e depois em segundo plano leva tempo. <br><br>  E o ciclo de vida do teclado?  No iOS, para cada unidade de tempo, o teclado pode pertencer a apenas um dos aplicativos em execu√ß√£o, mas as notifica√ß√µes sobre altera√ß√µes no status do teclado s√£o recebidas por todos os aplicativos assinados neles. <br><br>  Ao alternar de um aplicativo para outro, o sistema redefine seu firstResponder, que atua como um gatilho para ocultar o teclado.  O sistema envia uma notifica√ß√£o keyboardWillHide primeiro para que o teclado desapare√ßa e, em seguida, keyboardDidHideNotification.  A notifica√ß√£o voa para o segundo aplicativo.  No novo aplicativo, abrimos o teclado: o sistema envia keyboardWillShowNotification para o teclado aparecer e, em seguida, envia o keyboardDidShowNotification - uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">demonstra√ß√£o</a> , com as fases do ciclo. <br><br><img src="https://habrastorage.org/webt/gk/th/5c/gkth5chvrkyewmvhdrpc7eito9q.jpeg"><br><br>  Se voc√™ olhar um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">trecho do relat√≥rio</a> (das 8:39), ver√° o momento em que, ap√≥s ocultar o teclado, o sistema envia keyboardDidHideNotification para colocar o primeiro aplicativo em um estado inativo.  Quando voc√™ alterna para o aplicativo esportivo e inicia o teclado, o sistema envia keyboardWillShowNotification.  Mas como o processo de altern√¢ncia e in√≠cio √© r√°pido e o tempo de transi√ß√£o entre as fases do ciclo de vida pode ser mais longo, a notifica√ß√£o recebida processar√° n√£o apenas o aplicativo de esportes, mas tamb√©m o aplicativo de cerveja, que ainda n√£o conseguiu ir ao fundo. <br><br>  Tendo descoberto os motivos, vamos agora encontrar uma solu√ß√£o para o problema com o Ike. <br><br><h3>  M√° decis√£o </h3><br>  A primeira coisa que vem √† mente √© a id√©ia de cancelar a inscri√ß√£o / assinar notifica√ß√µes ao minimizar / maximizar um aplicativo por meio da ativa√ß√£o / desativa√ß√£o do KeyboardTracker. <br><br>  Para cancelar a inscri√ß√£o, usamos o m√©todo applicationWillResignActive ou um manipulador de notifica√ß√£o semelhante do sistema; para assinar, usamos applicationDidBecomeActive, mas para n√£o perder nada, tamb√©m notificaremos o m√©todo applicationWillEnterForeground, que √© chamado quando o aplicativo entra em primeiro plano, mas ainda n√£o se torna ativo. <br><br>  Quando voc√™ inicia o teclado no aplicativo, provavelmente tudo ter√° √™xito, mas com testes mais complexos, por exemplo, abrindo o teclado e tentando gravar a discagem por voz, a solu√ß√£o n√£o funcionar√°. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dy/0b/_e/dy0b_eiomhqtkuqimnsdew_es-c.gif" width="200"></div><br><br>  O que aconteceu  Depois de clicar no bot√£o de discagem de mensagem de voz, o aplicativo firstResponder foi redefinido, o teclado foi fechado, o m√©todo applicationWillResignActive foi chamado e cancelamos a inscri√ß√£o.  Depois de fechar o alerta, o sistema restaurou o estado do aplicativo, mas antes do m√©todo applicationWillEnterForeground e, especialmente, o applicationDidBecomeActive, foi chamado. <br><br><h3>  Boa decis√£o </h3><br>  Outra solu√ß√£o √© o uso de um caldo de prote√ß√£o (Bool). <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wasTummyViewFirstResponderBeforeApp0idEnterBackground <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">willResignActive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notification: NSNotification)</span></span></span></span> { wasTextFieldFirstResponderBeforeAppDidEnterBackground = tummyView.isFirstResponder } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">willEnterForeground</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notification: NSNotification)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> wasTextFieldFirstResponderBeforeAppDidEnterBackground { <span class="hljs-type"><span class="hljs-type">UIView</span></span>.performWithourAnimation { tummyView.becomeFirstResponder ( ) } } }</code> </pre> <br>  Lembramos se o teclado foi aberto antes do t√≥pico, como o aplicativo deixou de estar ativo e, no m√©todo applicationWillEnterForeground, restauramos o estado anterior.  A √∫nica coisa que resta a corrigir √© o buraco no alternador de aplicativos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jc/sl/oc/jcsloczny6akuricp8x0bzwvbxo.jpeg" width="400"></div><br><br><h2>  alternador de aplicativos </h2><br>  O alternador de aplicativos exibe instant√¢neos de aplicativos que o sistema faz depois que o aplicativo entra em segundo plano.  A captura de tela mostra que o instant√¢neo de nosso aplicativo foi feito no momento em que o teclado j√° est√° sendo usado por outro aplicativo.  Isso n√£o √© cr√≠tico, mas s√£o necess√°rios apenas alguns cliques para corrigi-lo. <br><br><h3>  Boa solu√ß√£o </h3><br>  A solu√ß√£o pode ser emprestada de aplicativos banc√°rios que aprenderam a ocultar dados confidenciais e tamb√©m ler na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Apple</a> . <br><br>  Voc√™ pode ocultar os dados no m√©todo applicationDidEnterBackground, desfocar e mostrar a tela inicial e, no m√©todo applicationWillEnterForeground, retornar √† hierarquia de exibi√ß√£o usual. <br><br>  Essa op√ß√£o n√£o √© adequada para n√≥s, porque quando o m√©todo applicationDidEnterBackground √© chamado, nosso aplicativo n√£o tem mais um teclado. <br><br><h3>  Boa decis√£o </h3><br>  Usaremos os m√©todos familiares willResignActive, willEnterForeground e didBecomeActive. <br><br>  Embora nosso aplicativo ainda tenha um teclado, voc√™ precisar√° criar seu pr√≥prio instant√¢neo do aplicativo no m√©todo willResignActive e coloc√°-lo na hierarquia. <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">willResignActive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notificaton: NSNotification)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> keyWindow = <span class="hljs-type"><span class="hljs-type">UIApplication</span></span>.shared.keyWindow imageView = <span class="hljs-type"><span class="hljs-type">UIImageView</span></span>( frame: keyWindow.bounds) imageView.image = snapshot ( ) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lastSubview = keyWindow.subviews.last lastSubview( imageView) }</code> </pre> <br>  Nos m√©todos willEnterForeground e didBecomeActive, restauramos a hierarquia de visualiza√ß√µes e exclu√≠mos nosso instant√¢neo. <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">willEnterForeground</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notification: NSNotification)</span></span></span></span> { imageView.removeFromSuperview( ) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didBecomeActive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notification: NSNotification)</span></span></span></span> { imageView.removeFromSuperview( ) }</code> </pre> <br>  Como resultado, corrigimos os dois casos: no alternador de aplicativos, uma imagem bonita e o teclado n√£o saltam mais ao alternar.  Parece que essas coisas n√£o s√£o t√£o importantes, mas, para o desenvolvimento do produto, esses pontos s√£o extremamente importantes. <br><br><h2>  M√°s not√≠cias </h2><br>  Nossa solu√ß√£o bem-sucedida para o problema de Ike dizia respeito ao caso em que o teclado foi aberto antes de minimizar o aplicativo.  Se a troca ocorrer sem expandir o teclado, novamente veremos que as pernas do nosso Ike ca√≠ram abaixo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zm/nr/4n/zmnr4nm4u8tph3bf86jkr05ix5k.gif" width="200"></div><br><br>  Isso n√£o √© apenas um problema para o nosso aplicativo, esse comportamento tamb√©m √© observado no Facebook, que funciona com notifica√ß√µes, e at√© no iMessage, que usa inputAccessoryView para controlar o teclado.  Isso ocorre porque, antes de mudar para o segundo plano, os aplicativos conseguem processar as notifica√ß√µes de teclado de outras pessoas. <br><br><h2>  demitir interativamente o teclado </h2><br>  Adicione alguma funcionalidade ao nosso aplicativo com o Ike, ensinando o programa a ocultar interativamente o teclado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/g6/cy/1g/g6cy1gparlfmqc0abfaz7rd_rr0.gif" width="200"></div><br><br><h3>  M√° decis√£o </h3><br>  Uma maneira de fazer essa funcionalidade √© alterar o quadro da visualiza√ß√£o do teclado.  Criamos panGestureRecognizer, em seu manipulador calculamos o novo valor da coordenada Y do teclado, dependendo da posi√ß√£o do nosso dedo, localizamos a visualiza√ß√£o do teclado e a atualizamos com o valor da coordenada Y. <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">panGestureHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> yPosition: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> = value keyboardView( )?.frame.origin.y = yPosition }</code> </pre> <br>  O teclado √© exibido em uma janela separada; portanto, voc√™ precisa percorrer toda a matriz de janelas no aplicativo, verificar cada elemento da matriz se √© uma janela do teclado e, se for o caso, obter uma visualiza√ß√£o mostrando o teclado. <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyboardView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIView?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> windows = <span class="hljs-type"><span class="hljs-type">UIApplication</span></span>.shared.windows <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> view = windows.first { (window) -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> keyboardView( fromWindow: window) != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> view }</code> </pre> <br>  Infelizmente, esta solu√ß√£o n√£o funcionar√° normalmente no iPhone X e superior, pois quando voc√™ move o dedo, voc√™ pode tocar levemente no indicador inferior, respons√°vel por minimizar o aplicativo.  Depois disso, a oculta√ß√£o interativa para de funcionar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/eg/-o/iv/eg-oiv8yrssufcejelvxqj4ksrq.gif" width="200"></div><br><br>  O problema est√° na matriz de janelas. <br><br><img src="https://habrastorage.org/webt/vc/u6/9o/vcu69oekot0zgl31iikyy_0refo.jpeg" width="600"><br><br>  Ap√≥s o gesto, o sistema cria uma nova janela do teclado em cima da existente.  √â impens√°vel, mas √© verdade.  Como resultado, a matriz cont√©m duas janelas de teclado com as mesmas coordenadas, mas a primeira est√° oculta. <br><br><img src="https://habrastorage.org/webt/pp/0v/ha/pp0vhay6ionyekifnsg-9jvnpzg.jpeg"><br><br>  Acontece que, iterando sobre o conjunto de janelas, encontramos o primeiro que satisfaz as condi√ß√µes e come√ßamos a trabalhar com ele, apesar de estar oculto. <br><br>  Como isso √© corrigido?  Transformando uma matriz de janelas. <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">panGeastureHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> yPosition: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> = <span class="hljs-number"><span class="hljs-number">0.0</span></span> keyboardView( )?.frame.origin.y = yPosition } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyboardView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIView?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> windows = <span class="hljs-type"><span class="hljs-type">UIApplication</span></span>.shared.windows.reversed( ) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> view = windows.first { (window) -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> keyboardView( fromWindow: window) != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> view }</code> </pre> <br><h2>  Recursos do teclado no iPad </h2><br>  O teclado do iPad tem um estado desencaixado, al√©m do estado habitual.  O usu√°rio pode mov√™-lo pela tela, dividi-lo em duas partes e at√© iniciar o aplicativo no modo slide over (em cima do outro).  Obviamente, √© importante que em todos esses modos o teclado funcione sem erros. <br><br>  Vamos verificar o nosso Hayke. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/y1/4x/l5/y14xl5geuyxmkubopbkabplwbz4.gif"></div><br><br>  Infelizmente, este n√£o √© o caso agora.  Depois que o usu√°rio come√ßa a mover o teclado pela tela, as pernas de Ike voam acima da cabe√ßa e aparecem no lugar somente ap√≥s a pr√≥xima abertura do teclado.  Vamos tentar consert√°-lo em um estojo com um teclado dividido. <br><br><h3>  Raz√µes </h3><br>  Vamos come√ßar analisando as notifica√ß√µes.  Depois de clicar no bot√£o de divis√£o, obtemos dois grupos de notifica√ß√µes - keyboardWillChangeFrameNotification, keyboardWillHideNotification, keyboardDidChangeFrameNotification, keyboardDidHideNotification.  A diferen√ßa entre os grupos est√° apenas nas coordenadas do teclado. <br><br>  Quando clicamos no bot√£o de divis√£o, o teclado diminui e o primeiro grupo de notifica√ß√µes chega.  Quando o teclado se dividiu e subiu - recebemos um segundo pacote de notifica√ß√µes. <br><br>  O importante √© que recebamos notifica√ß√µes de que o teclado desapareceu, mas n√£o o que √© exibido.  A prop√≥sito, esse √© outro fator a favor do uso de keyboardWillChangeFrameNotification. <br><br>  Por que, ent√£o, as pernas de Ike voam para longe assim que come√ßamos a mover o teclado pela tela? <br><br>  Nesse momento, o sistema nos envia uma keyboardWillChangeFrameNotification, mas as coordenadas que existem existem (0,0, 0,0, 0,0, 0,0), pois o sistema n√£o sabe em que ponto o teclado estar√° ap√≥s a conclus√£o do movimento. <br><br>  Se voc√™ substituir zeros no c√≥digo atual que lida com a altera√ß√£o do quadro do teclado, a altura do teclado √© igual √† altura da janela.  Essa √© a raz√£o pela qual as pernas de Ike voam para fora da tela. <br><br><h3>  Boa decis√£o </h3><br>  Para resolver nosso problema, primeiro aprenderemos a entender quando o teclado estiver no modo desencaixado e o usu√°rio poder√° mov√™-lo pela tela. <br><br>  Para fazer isso, basta comparar a altura da janela e o teclado maxY.  Se forem iguais, o teclado em seu estado normal, se maxY for menor que a altura da janela, o usu√°rio mover√° o teclado.  Como resultado, o seguinte c√≥digo aparece no keyboardTracker: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyboardTracker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> { notificationCenter.addObserver( <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, selector:#selector( keyboardWillChangeFrame), name:<span class="hljs-type"><span class="hljs-type">UIResponder</span></span>.keyboardWillChangeFrameNotification, object:<span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyboardWillChangeFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notification: NSNotification)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> screenCoordinatedKeyboardFrame = (userInfo[<span class="hljs-type"><span class="hljs-type">UIResponder</span></span>.keyboardFrameEndUserInfoKey] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">NSValue</span></span>).cgRectValue <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> leyboardFrame = window.convert ( screenCoordinatedKeyboardFrame, from: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> windowHeight = window.frame.height <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> keyboardHeight = windowHeight - keyboardFrame.minY <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> isKeyboardUnlocked = isIPad ( ) &amp;&amp; keyboardFrame/maxY &lt; windowHeight <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isKeyboardUnlocked { keyboardHeight = <span class="hljs-number"><span class="hljs-number">0.0</span></span> } delegate.keyboardWillChange ( keyboardHeight) } }</code> </pre> <br>  Definimos a altura como zero e, agora, com o movimento do teclado, as pernas de Ike se abaixam e s√£o fixadas l√°. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tx/uv/u_/txuvu_-lhk01nhlzbcyfxc8g3k4.gif" width="400"></div><br><br>  O √∫nico mal-entendido restante √© o fato de que, ao dividir o teclado, as pernas de Ike n√£o caem imediatamente.  Como consertar isso? <br><br>  Ensinaremos o keyboardTracker a trabalhar n√£o apenas com keyboardWillChangeFrameNotification, mas tamb√©m com keyboardDidChangeFrame.  Voc√™ n√£o precisa escrever um novo c√≥digo; basta verificar se este √© um iPad para n√£o fazer c√°lculos desnecess√°rios. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyboardTracker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyboardDidChangeFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notification: NSNotification)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isIPad ( ) == <span class="hljs-literal"><span class="hljs-literal">false</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }</code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jd/-n/nv/jd-nnvrctruwlczh4ytw2ckfllu.gif" width="400"></div><br><br><h2>  Como detectar bugs? </h2><br><h3>  Registro abundante </h3><br>  Em nosso projeto, os logs s√£o gravados no seguinte formato: entre colchetes, o nome do m√≥dulo e do subm√≥dulo ao qual o log pertence e, em seguida, o texto do pr√≥prio log.  Por exemplo, assim: <br> <code>[keyboard][tracker] keyboardWillChangeFrame: calculated height - 437.9</code> <br> <br>  No c√≥digo, tem a seguinte apar√™ncia - um criador de logs √© criado com uma etiqueta de n√≠vel superior e transmitido ao rastreador.  Dentro do rastreador, um criador de logs com um tag de segundo n√≠vel, usado para o registro dentro da classe, √© desmembrado do criador de logs. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyboardTracker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(with logger: <span class="hljs-type"><span class="hljs-type">Logger</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.trackerLogger = logger.dequeue(withTag: <span class="hljs-string"><span class="hljs-string">"[tracker]"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyboardWillChangeFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(notification: NSNotification)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> height = <span class="hljs-number"><span class="hljs-number">0.0</span></span> trackerLogger.debug(<span class="hljs-string"><span class="hljs-string">"\(#function): calculated height - \(height)"</span></span>) } }</code> </pre> <br>  Ent√£o, prometi todo o keyboardTracker, o que √© bom.  Se os testadores encontrarem problemas, peguei o arquivo de log e procurei exatamente onde os quadros n√£o se encaixavam.  Isso levou muito tempo, portanto, al√©m do log, outros m√©todos come√ßaram a ser aplicados. <br><br><h3>  C√£o de guarda </h3><br>  Em nosso projeto, o Watchdog √© usado para otimizar o fluxo da interface do usu√°rio.  Isso foi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dito por Dmitry Kurkin em um dos √∫ltimos AppsConf</a> . <br><br>  Um c√£o de guarda √© um processo ou segmento que <strong>observa</strong> outro processo ou segmento.  Esse mecanismo permite monitorar o status do teclado e as visualiza√ß√µes que dependem dele e relatar problemas. <br><br>  Para implementar essa funcionalidade, criamos um timer que, uma vez por segundo, verifica o local correto da vista com as pernas de Hayk ou registra-o se houver erro. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Watchdog</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> timer: <span class="hljs-type"><span class="hljs-type">Timer?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> { timer = <span class="hljs-type"><span class="hljs-type">Timer</span></span> ( timeInterval: <span class="hljs-number"><span class="hljs-number">1.0</span></span>, repeats: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, block: { ( timer ) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.woof ( ) } ) } }</code> </pre> <br>  A prop√≥sito, voc√™ pode registrar n√£o apenas os resultados finais, mas tamb√©m c√°lculos intermedi√°rios. <br><br>  Como resultado, o registro abundante + Watchdog forneceu dados precisos sobre o problema, o estado do teclado e reduziu o tempo para corrigir bugs, mas pouco ajudou os usu√°rios beta que tiveram que suportar erros at√© o pr√≥ximo lan√ßamento. <br><br>  Mas e se o c√£o de guarda puder ser treinado n√£o apenas para encontrar problemas, mas tamb√©m para corrigi-los? <br><br>  No c√≥digo em que o watchdog conclui que as coordenadas da exibi√ß√£o n√£o convergem, adicionamos o m√©todo fixTummyPosition e automaticamente colocamos as coordenadas no lugar. <br><br>  Nesta op√ß√£o, muitas informa√ß√µes √∫teis s√£o acumuladas nos meus logs e os usu√°rios nem percebem problemas visuais.  Parece √≥timo, mas agora n√£o consigo encontrar nenhum problema com o teclado. <br><br>  Isso ajuda a adicionar ao m√©todo watchdog a capacidade de gerar um cache de teste quando um erro √© detectado.  Obviamente, esse c√≥digo √© adicionado na configura√ß√£o do remout. <br><br>  Agora, ap√≥s o pr√≥ximo lan√ßamento, voc√™ pode ativar a gera√ß√£o de falhas de teste e, se um usu√°rio tiver problemas com o teclado, o aplicativo falhar√° e, gra√ßas aos logs coletados, poder√° corrigir os erros. <br><br><h3>  Dashboard </h3><br>  O √∫ltimo truque que introduzimos √© o envio de estat√≠sticas no momento em que o wahtchdog registrou as estat√≠sticas.  Com base nos dados obtidos, plotamos o n√∫mero de erros detectados e ap√≥s a primeira itera√ß√£o, o n√∫mero de opera√ß√µes foi reduzido em quatro vezes.  Obviamente, n√£o foi poss√≠vel reduzir os problemas a zero, mas as principais reclama√ß√µes dos usu√°rios cessaram. <br><br><blockquote>  Na pr√≥xima semana, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Saint AppsConf</a> ser√° realizado em S√£o Petersburgo, onde voc√™ poder√° fazer perguntas n√£o apenas √† Konstantin, mas tamb√©m a in√∫meros oradores da faixa iOS. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt462515/">https://habr.com/ru/post/pt462515/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt462505/index.html">N√£o me engane com sua programa√ß√£o funcional</a></li>
<li><a href="../pt462507/index.html">Quando o correio √© entregue: combatendo a perda de notifica√ß√µes por push no iOS</a></li>
<li><a href="../pt462509/index.html">Product Fest - confer√™ncia de gerenciamento de produtos de TI √† qual voc√™ deseja ir</a></li>
<li><a href="../pt462511/index.html">Google Play Instant√¢neo. Refatora√ß√£o ao longo da vida</a></li>
<li><a href="../pt462513/index.html">Realoca√ß√£o: prepara√ß√£o, sele√ß√£o, desenvolvimento do territ√≥rio</a></li>
<li><a href="../pt462519/index.html">O livro "Microsservi√ßos. Padr√µes de desenvolvimento e refatora√ß√£o ¬ª</a></li>
<li><a href="../pt462523/index.html">Servidor de autoriza√ß√£o de dois fatores LinOTP</a></li>
<li><a href="../pt462525/index.html">3CX lan√ßa novos softphones SIP para iOS e Android com criptografia de voz de ponta a ponta</a></li>
<li><a href="../pt462527/index.html">Como uma rede neural SincNet aloca freq√º√™ncias significativas no som por meio da propaga√ß√£o traseira</a></li>
<li><a href="../pt462529/index.html">A id√©ia da esta√ß√£o lunar da NASA √© ruim e boa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>