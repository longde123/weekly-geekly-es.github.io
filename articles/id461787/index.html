<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¶ ğŸ”‹ ğŸ‚ğŸ¼ Tampilan teks Android ğŸ§™ğŸ¾ ğŸ•´ğŸ¼ ğŸµ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Menampilkan informasi tekstual mungkin merupakan bagian paling dasar dan penting dari banyak aplikasi Android. Artikel ini akan berbicara tentang Text...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tampilan teks Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redmadrobot/blog/461787/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/mc/2_/_o/mc2__o7rq1m6ex9alol6ivz5vey.png"></div><br><p>  Menampilkan informasi tekstual mungkin merupakan bagian paling dasar dan penting dari banyak aplikasi Android.  Artikel ini akan berbicara tentang TextView.  Setiap pengembang, dimulai dengan "Hello World," terus-menerus dihadapkan dengan elemen antarmuka pengguna ini.  Dari waktu ke waktu, ketika bekerja dengan teks, Anda harus berpikir tentang mengimplementasikan berbagai solusi desain atau meningkatkan kinerja saat merender layar. </p><br><p>  Saya akan berbicara tentang perangkat TextView dan beberapa seluk-beluk bekerja dengannya.  Kiat utama diambil dari laporan Google I / O sebelumnya. </p><a name="habracut"></a><br><h1 id="textview-pod-kapotom">  TextView di bawah tenda </h1><br><p>  Untuk rendering teks di Android, seluruh tumpukan perpustakaan yang berbeda digunakan di bawah tenda.  Mereka dapat dibagi menjadi dua bagian utama - kode java dan kode asli: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hb/p0/gg/hbp0ggycnpeisn8v8hwyqkkmvfq.png" width="800"></div><br><p>  Kode Java pada dasarnya adalah bagian dari SDK Android yang tersedia untuk pengembang aplikasi, dan fitur-fitur baru darinya dapat porting ke pustaka dukungan. </p><br><p>  Inti TextView sendiri ditulis dalam C ++, yang membatasi porting ke pustaka pendukung fitur baru yang diimplementasikan di sana dari versi baru sistem operasi.  Inti adalah pustaka berikut: </p><br><ul><li>  Minikin digunakan untuk mengukur panjang teks, jeda baris dan kata-kata berdasarkan suku kata. </li><li>  ICU menyediakan dukungan Unicode. </li><li>  HarfBuzz menemukan untuk karakter Unicode elemen grafis yang sesuai (mesin terbang) dalam font. </li><li>  FreeType membuat bitmap dari mesin terbang. </li><li>  Skia adalah mesin untuk menggambar grafik 2D. </li></ul><br><h2 id="izmerenie-dliny-teksta-i-perenos-strok">  Mengukur panjang teks dan jeda baris </h2><br><p>  Jika Anda meneruskan baris ke perpustakaan Minikin, yang digunakan di dalam TextView, maka hal pertama yang menentukan adalah mesin terbang mana yang terdiri dari baris: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qt/1o/uk/qt1ouktu4gn9x0wncbgiy2a7qkg.png" width="800"></div><br>
<p> Seperti yang dapat Anda lihat dari contoh ini, mencocokkan karakter Unicode dengan mesin terbang tidak akan selalu satu ke satu: di sini 3 karakter sekaligus akan sesuai dengan satu mesin terbang ffi.  Selain itu, perlu memperhatikan bahwa mesin terbang yang diperlukan dapat ditemukan di berbagai font sistem. </p><br><p>  Menemukan mesin terbang hanya dalam font sistem dapat menyebabkan kesulitan, terutama jika ikon atau emoji ditampilkan melalui karakter, dan seharusnya menggabungkan karakter dari font yang berbeda dalam satu baris.  Oleh karena itu, dimulai dengan <strong>Android Q (29)</strong> , menjadi mungkin untuk membuat daftar font Anda sendiri yang datang dengan aplikasi.  Daftar ini akan digunakan untuk mencari mesin terbang: </p><br><pre> <code class="kotlin hljs">textView.typeface = TypeFace.CustomFallbackBuilder( FontFamily.Builder( Font.Builder(assets, â€œlato.ttfâ€).build() ).build() ).addCustomFallback( FontFamily.Builder( Font.Builder(assets, â€œkosugi.ttfâ€).build() ).build() ).build()</code> </pre> <br><p>  Sekarang, menggunakan <code>CustomFallbackBuilder</code> ketika mencocokkan karakter dengan mesin terbang, SDK akan <code>CustomFallbackBuilder</code> ke kelompok font yang ditentukan secara berurutan, dan jika tidak dapat ditemukan, pencarian akan melanjutkan dalam font sistem (dan melalui metode <code>setSystemFallback()</code> Anda dapat menentukan keluarga font sistem yang disukai).  <code>CustomFallbackBuilder</code> memiliki batasan jumlah keluarga font - Anda dapat menambahkan tidak lebih dari 64 font. </p><br><p>  Perpustakaan Minikin membagi string menjadi kata-kata dan mengukur kata-kata individual.  Untuk mempercepat pekerjaan, dimulai dengan <strong>Lollipop (21)</strong> , digunakan cache kata-kata <abbr title="paling baru digunakan">LRU</abbr> sistem.  Cache semacam itu memberikan peningkatan kinerja yang sangat besar: panggilan ke <code>Paint.measureText()</code> untuk kata yang di-cache akan membutuhkan rata-rata 3% dari waktu pertama kali menghitung ukurannya. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d2/f1/om/d2f1omfjlqmmfqalip3whmes-1o.png" width="800"></div><br><p>  Jika teks tidak sesuai dengan lebar yang ditentukan, Minikin mengatur jeda baris dan kata-kata dalam teks.  Dimulai dengan <strong>Marshmallow (23),</strong> Anda dapat mengontrol perilakunya dengan menentukan atribut khusus <code>breakStrategy</code> dan <code>breakStrategy</code> untuk TextView. </p><br><p>  Dengan nilai <code>breakStrategy=simple</code> perpustakaan hanya akan mengatur tanda hubung secara berurutan, melewati teks: segera setelah baris berhenti sesuai, tanda hubung diletakkan sebelum kata terakhir. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/im/lc/cr/imlccruuhjr59qzrtpwjmrf6hhk.png" width="600"></div><br><p>  Dalam nilai <code>balanced</code> pustaka akan mencoba membuat garis putus sehingga garis selaras lebar. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/v5/ys/kc/v5yskcuiwypdyponmrdqep7zaq8.png" width="600"></div><br><p>  <code>high_quality</code> memiliki perilaku yang hampir sama dengan <code>balanced</code> , dengan pengecualian beberapa perbedaan (salah satunya: pada garis kedua dari belakang, tanda hubung dapat tidak hanya kata-kata yang terpisah, tetapi juga kata-kata oleh suku kata). </p><br><p>  Atribut <code>hyphenationFrequency</code> memungkinkan <code>hyphenationFrequency</code> untuk mengontrol strategi untuk pembungkus kata dengan suku kata.  Nilai <code>none</code> akan melakukan hyphenation otomatis, <code>normal</code> akan membuat frekuensi hyphenation kecil, dan <code>full</code> , karenanya, akan menggunakan jumlah kata maksimum. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ng/cr/hs/ngcrhsphklaxxe842klpnx8mhnw.png" width="600"></div><br><p>  Kinerja rendering teks tergantung pada flag yang dipilih (diukur pada <strong>Android P (28)</strong> ): </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tx/5r/33/tx5r339s93s1nq6go8hieqhv6fq.png" width="600"></div><br><p>  Mengingat hit kinerja yang cukup kuat, pengembang Google, mulai dengan versi <strong>Q (29)</strong> dan <strong>AppCompat 1.1.0</strong> , memutuskan untuk mematikan tanda hubung secara default.  Jika pembungkus kata penting dalam aplikasi, sekarang Anda harus mengaktifkannya secara eksplisit. </p><br><p>  Saat menggunakan bungkus kata, orang harus mempertimbangkan bahwa bahasa yang dipilih saat ini dalam sistem operasi akan mempengaruhi operasi perpustakaan.  Bergantung pada bahasanya, sistem akan memilih kamus khusus dengan aturan transfer. </p><br><h1 id="stili-teksta">  Gaya teks </h1><br><p>  Ada beberapa cara mendesain teks di Android: </p><br><ul><li>  <strong>Gaya tunggal</strong> yang berlaku untuk seluruh elemen TextView. </li><li>  <strong>Multi-gaya (multi style)</strong> - beberapa gaya sekaligus, yang dapat diterapkan ke teks, di tingkat paragraf atau karakter individu.  Ada beberapa cara untuk melakukan ini: <br><ul><li>  menggambar teks di atas kanvas </li><li>  tag html </li><li>  elemen markup khusus - rentang </li></ul></li></ul><br><p>  Gaya tunggal menyiratkan penggunaan gaya XML atau atribut XML di markup TextView.  Dalam hal ini, sistem akan menerapkan nilai dari sumber daya dalam urutan berikut: TextAppearance, theme (Theme), style default (style default), style dari aplikasi, dan prioritas tertinggi adalah nilai dari atribut View. </p><br><p>  Menggunakan sumber daya adalah solusi yang cukup sederhana, tetapi, sayangnya, itu tidak memungkinkan Anda untuk menerapkan gaya ke bagian teks. </p><br><p>  Tag HTML adalah solusi sederhana lain yang menyediakan fitur seperti membuat setiap kata menjadi tebal, miring, atau bahkan menyorot daftar dengan titik-titik dalam teks.  Semua yang dibutuhkan pengembang adalah melakukan panggilan ke metode <code>Html.fromHtml()</code> , yang akan mengubah teks yang ditandai menjadi teks yang ditandai oleh rentang.  Tetapi solusi ini memiliki kemampuan terbatas, karena hanya mengenali sebagian dari tag html dan tidak mendukung gaya CSS. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> text = <span class="hljs-string"><span class="hljs-string">"My text &lt;ul&gt;&lt;li&gt;bullet one&lt;/li&gt;&lt;li&gt;bullet two&lt;/li&gt;&lt;/ul&gt;"</span></span> myTextView.text = Html.fromHtml(text)</code> </pre> <br><p>  Berbagai metode penataan TextView dapat dikombinasikan, tetapi perlu diingat prioritas metode tertentu, yang akan memengaruhi hasil akhir: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zm/hr/hl/zmhrhluqvvcv77s1b85gkxbtcww.png" width="400"></div><br><p>  Cara lain - menggambar teks pada kanvas - memberi pengembang kendali penuh atas output teks: misalnya, Anda dapat menggambar teks di sepanjang garis lengkung.  Tetapi solusi seperti itu, tergantung pada persyaratan, bisa sangat sulit untuk diterapkan dan berada di luar cakupan artikel ini. </p><br><h1 id="spans">  Rentang </h1><br><p>  TextView menggunakan rentang untuk menyempurnakan gaya.  Menggunakan bentang, Anda dapat mengubah warna rentang karakter, menjadikan bagian teks sebagai tautan, mengubah ukuran teks, menggambar titik di depan paragraf, dll. </p><br><p>  Kategori rentang berikut dapat dibedakan: </p><br><ul><li>  <strong>Rentang karakter</strong> - diterapkan pada level karakter string. <br><ul><li>  <strong>Penampilan memengaruhi</strong> - jangan ubah ukuran teks. </li><li>  <strong>Metrik yang mempengaruhi</strong> - mengubah ukuran teks. </li></ul></li><li>  <strong>Rentang paragraf</strong> - diterapkan di tingkat paragraf. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zy/os/x2/zyosx2ovroe15y3bd94qridaaou.png"></div><br><p>  Kerangka kerja Android memiliki antarmuka dan kelas abstrak dengan metode yang disebut selama <code>onMeasure()</code> dan rendering dari TextView, metode ini memberikan akses bentang ke objek tingkat lebih rendah seperti <code>TextPaint</code> dan <code>Canvas</code> .  Menggunakan span, kerangka kerja Android memeriksa antarmuka mana yang diimplementasikan objek ini untuk memanggil metode yang diperlukan. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fv/do/er/fvdoerpx8zxykjxvt9ru4kigica.png" width="600"></div><br><p>  Kerangka kerja android mendefinisikan sekitar 20+ rentang, jadi sebelum Anda membuatnya, lebih baik untuk memeriksa apakah SDK cocok. </p><br><h3 id="appearance-vs-metric-affecting-spans">  Tampilan vs metrik mempengaruhi bentang </h3><br><p>  Kategori pertama rentang mempengaruhi bagaimana karakter dalam string akan terlihat: warna karakter, warna latar belakang, karakter yang digarisbawahi atau dicoret, dll.  <code>UpdateAppearance</code> ini menerapkan antarmuka <code>UpdateAppearance</code> dan mewarisi dari kelas <code>CharacterStyle</code> , yang menyediakan akses ke objek <code>TextPaint</code> . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/or/8f/zl/or8fzltp5mvoyhvdey8tz1uoqhg.png"></div><br><p>  Metrik yang mempengaruhi rentang mempengaruhi ukuran teks dan tata letak, oleh karena itu, penggunaan rentang seperti itu tidak hanya memerlukan menggambar ulang TextView, tetapi juga panggilan <code>onMeasure()</code> / <code>onLayout()</code> .  <code>MetricAffectingSpan</code> ini biasanya diwarisi dari kelas <code>MetricAffectingSpan</code> , yang diwarisi dari <code>CharacterStyle</code> disebutkan di atas. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_h/hs/hd/_hhshd0pcadvdievngojmtsqzlu.png"></div><br><h2 id="character-vs-paragraph-affecting-spans">  Karakter vs paragraf yang mempengaruhi rentang </h2><br><p>  Rentang paragraf memengaruhi seluruh blok teks: ia dapat mengubah perataan, lekukan, atau bahkan menyisipkan titik di awal paragraf.  Rentang seperti itu harus diwarisi dari kelas <code>ParagraphStyle</code> dan disisipkan ke dalam teks persis dari awal paragraf hingga akhirnya.  Jika rentang tidak benar, maka rentang tidak akan berfungsi. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/76/_n/uj/76_nujhr8rrwz-mne8bgq8p2pfu.png"></div><br><p>  Di Android, paragraf dianggap sebagai bagian dari teks yang dipisahkan oleh baris baru ( <code>\n</code> ). </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/s1/p1/kq/s1p1kq9esdaakdpwh_rkxdvdygw.png"></div><br><h2 id="napisanie-svoih-spanov">  Menulis Rentang Anda </h2><br><p>  Saat menulis rentang Anda sendiri, Anda perlu memutuskan rentang apa yang akan memengaruhi untuk memilih kelas yang akan diwarisi: </p><br><ul><li>  Mempengaruhi teks pada level karakter -&gt; <code>CharacterStyle</code> </li><li>  Mempengaruhi teks di tingkat paragraf -&gt; <code>ParagraphStyle</code> </li><li>  Mempengaruhi tampilan teks â†’ <code>UpdateAppearance</code> </li><li>  Mempengaruhi ukuran teks - <code>UpdateLayout</code> </li></ul><br><p>  Berikut adalah contoh rentang untuk mengubah font: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomTypefaceSpan</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> font: Typeface?) : MetricAffectingSpan() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateMeasureState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(textPaint: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TextPaint</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = update(textPaint) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateDrawState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(textPaint: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TextPaint</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = update(textPaint) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(textPaint: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TextPaint</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { textPaint.apply { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> old = typeface <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> oldStyle = old?.style ?: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> font = Typeface.create(font, oldStyle) typeface = font <span class="hljs-comment"><span class="hljs-comment">//    } } }</span></span></code> </pre> <br><p>  Bayangkan kita ingin membuat rentang kita sendiri untuk menyoroti blok kode, untuk ini kita akan mengedit rentang kita sebelumnya - setelah mengatur font, kita akan menambahkan perubahan dalam warna latar belakang teks: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodeBlockSpan</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> font: Typeface?) : MetricAffectingSpan() { â€¦ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(textPaint: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TextPaint</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { textPaint.apply { <span class="hljs-comment"><span class="hljs-comment">//    â€¦ bgColor = lightGray //    } } }</span></span></code> </pre> <br><p>  Terapkan rentang ke teks: </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//    span spannable.setSpan(CodeBlockSpan(typeface), ...)</span></span></code> </pre> <br><p>  Tetapi Anda bisa mendapatkan hasil yang persis sama dengan menggabungkan dua rentang: ambil <code>CustomTypefaceSpan</code> dan <code>BackgroundColorSpan</code> sebelumnya dari kerangka Android: </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//    spannable.setSpan(BackgroundColorSpan(lightGray), ...) //   spannable.setSpan(CustomTypefaceSpan(typeface), ...)</span></span></code> </pre> <br><p>  Dua solusi ini akan memiliki perbedaan.  Faktanya adalah rentang yang ditulis sendiri tidak dapat mengimplementasikan antarmuka <code>Parcelable</code> , tidak seperti yang sistem. </p><br><p>  Saat mentransmisikan saluran bergaya melalui Intent atau clipboard jika rentang markup yang ditulis sendiri tidak akan disimpan.  Saat menggunakan bentang dari framework, markup akan tetap ada. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/is/nw/uu/isnwuux9cosllp6h0kgawifcepo.png" width="600"></div><br><h2 id="ispolzovanie-spanov-v-tekste">  Menggunakan bentang dalam teks </h2><br><p>  Ada dua antarmuka untuk teks bergaya dalam kerangka: <code>Spannable</code> dan <code>Spannable</code> (masing-masing dengan markup tidak berubah dan bisa berubah, masing-masing) dan tiga implementasi: <code>SpannedString</code> (teks tidak berubah), <code>SpannableString</code> (teks tidak berubah) dan <code>SpannableStringBuilder</code> (teks dapat diubah). </p><br><div class="scrollable-table"><table><thead><tr><th></th><th>  Teks yang bisa diubah </th><th>  Markup variabel </th></tr></thead><tbody><tr><td>  String yang <strong>terentang</strong> </td><td>  tidak </td><td>  tidak </td></tr><tr><td>  String yang dapat <strong>dipentang</strong> </td><td>  tidak </td><td>  iya </td></tr><tr><td>  Pembangun <strong>Spannablestring</strong> </td><td>  iya </td><td>  iya </td></tr></tbody></table></div><br><p>  <code>SpannableStringBuilder</code> , misalnya, digunakan di dalam <code>EditText</code> yang perlu mengubah teks. </p><br><p>  Anda dapat menambahkan rentang baru ke garis menggunakan metode: </p><br><p> <code>setSpan(Object what, int start, int end, int flags)</code> </p> <br><p>  Rentang dilewatkan melalui parameter pertama, kemudian rentang indeks dalam teks ditunjukkan.  Dan parameter terakhir dapat dikontrol, apa yang akan menjadi perilaku rentang ketika memasukkan teks baru: apakah rentang akan menyebar ke teks yang dimasukkan pada titik awal atau akhir (jika Anda memasukkan teks baru di tengah, rentang akan secara otomatis berlaku untuk itu, terlepas dari nilai bendera) . </p><br><p>  Kelas-kelas yang tercantum di atas berbeda tidak hanya secara semantik, tetapi juga dalam bagaimana mereka diatur secara internal: <code>SpannedString</code> dan <code>SpannableString</code> menggunakan array untuk menyimpan rentang, dan <code>SpannableStringBuilder</code> menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pohon interval</a> . </p><br><p>  Jika Anda melakukan tes untuk kecepatan rendering teks tergantung pada jumlah bentang, Anda akan mendapatkan hasil berikut: ketika menggunakan hingga ~ 250 bentang berturut-turut, <code>SpannableString</code> dan <code>SpannableStringBuilder</code> bekerja pada kecepatan yang sama, tetapi jika elemen markup menjadi lebih dari 250, maka <code>SpannableString</code> dimulai kalah.  Jadi, jika tugasnya adalah menerapkan gaya ke beberapa teks, maka ketika memilih kelas, seseorang harus dipandu oleh persyaratan semantik: apakah garis dan gaya akan bisa berubah.  Tetapi jika markup membutuhkan lebih dari 250 rentang, maka Anda harus selalu memberikan <code>SpannableStringBuilder</code> untuk <code>SpannableStringBuilder</code> . </p><br><h2 id="proverka-na-nalichie-spana-v-tekste">  Periksa rentang dalam teks </h2><br><p>  Tugas muncul secara berkala untuk memeriksa apakah garis yang direntang memiliki rentang tertentu.  Dan di Stackoverflow Anda dapat menemukan kode ini: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasSpan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(spanned: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Spanned</span></span></span></span><span class="hljs-function"><span class="hljs-params">, clazz: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Class</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> spans: Array&lt;<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> T&gt; = spanned.getSpans(<span class="hljs-number"><span class="hljs-number">0</span></span>, spanned.length, clazz) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> spans.isNotEmpty() }</code> </pre> <br><p>  Solusi seperti itu akan berhasil, tetapi tidak efisien: Anda harus memeriksa semua bentang, memeriksa apakah masing-masing milik tipe yang diteruskan, mengumpulkan hasilnya ke dalam array, dan pada akhirnya hanya memeriksa bahwa array tidak kosong. </p><br><p>  Solusi yang lebih efektif adalah dengan menggunakan metode <code>nextSpanTransition()</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasSpan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(spanned: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Spanned</span></span></span></span><span class="hljs-function"><span class="hljs-params">, clazz: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Class</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> limit = spanned.length <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> spanned.nextSpanTransition(<span class="hljs-number"><span class="hljs-number">0</span></span>, limit, clazz) &lt; limit }</code> </pre> <br><h2 id="razmetka-teksta-v-razlichnyh-yazykovyh-resursah">  Markup teks dalam berbagai sumber daya bahasa </h2><br><p>  Tugas semacam itu dapat muncul ketika Anda ingin menyorot kata tertentu dengan bantuan markup di berbagai sumber daya string.  Misalnya, kita perlu menyorot kata <em>"teks"</em> dalam versi bahasa Inggris dan <em>"texto"</em> dalam bahasa Spanyol: </p><br><pre> <code class="xml hljs"><span class="hljs-comment"><span class="hljs-comment">&lt;!-- values-en/strings.xml --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"title"</span></span></span><span class="hljs-tag">&gt;</span></span>Best practices for text in Android<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- values-es/strings.xml --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">â€titleâ€</span></span></span><span class="hljs-tag">&gt;</span></span>Texto en Android: mejores prÃ¡cticas<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Jika Anda membutuhkan sesuatu yang sederhana, misalnya, untuk menyorot kata dalam huruf tebal, maka Anda dapat menggunakan tag html biasa ( <code>&lt;b&gt;</code> ).  Di UI, Anda hanya perlu mengatur sumber string di TextView: </p><br><pre> <code class="kotlin hljs">textView.setText(R.string.title)</code> </pre> <br><p>  Tetapi jika Anda membutuhkan sesuatu yang lebih kompleks, misalnya mengubah font, maka html tidak dapat lagi digunakan.  Solusinya adalah dengan menggunakan <code>&lt;annotation&gt;</code> .  Tag ini memungkinkan Anda untuk menentukan pasangan nilai kunci apa pun dalam file xml.  Saat kami menarik string dari sumber, tag ini secara otomatis dikonversi ke rentang <code>Annotation</code> , disusun dalam teks dengan kunci dan nilai yang sesuai.  Setelah itu, Anda dapat menguraikan daftar anotasi dalam teks dan menerapkan rentang yang diperlukan. </p><br><p>  Misalkan kita perlu mengubah font menggunakan <code>CustomTypefaceSpan</code> . </p><br><p>  Tambahkan tag dan tentukan kunci <em>"font"</em> untuknya dan nilai - jenis font yang ingin kita gunakan adalah <em>"title_emphasis"</em> : <br></p><pre> <code class="xml hljs"><span class="hljs-comment"><span class="hljs-comment">&lt;!-- values-en/strings.xml --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"title"</span></span></span><span class="hljs-tag">&gt;</span></span>Best practices for <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">annotation</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">font</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">â€title_emphasisâ€</span></span></span><span class="hljs-tag">&gt;</span></span>text<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">annotation</span></span></span><span class="hljs-tag">&gt;</span></span> in Android<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- values-es/strings.xml --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">â€titleâ€</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">annotation</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">font</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">â€title_emphasisâ€</span></span></span><span class="hljs-tag">&gt;</span></span>Texto<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">annotation</span></span></span><span class="hljs-tag">&gt;</span></span> en Android: mejores prÃ¡cticas<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Tarik string dari sumber, temukan anotasi dengan tombol <em>â€œfontâ€</em> dan atur rentang: </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//      SpannedString,     span' val titleText = getText(R.string.title) as SpannedString //    val annotations = titleText.getSpans(0, titleText.length, Annotation::class.java) //     SpannableString //      val spannableString = SpannableString(titleText) //     for (annotation in annotations) { //     "font" if (annotation.key == "font") { val fontName = annotation.value //   ,     if (fontName == "title_emphasis") { val typeface = getFontCompat(R.font.permanent_marker) //  span    ,    spannableString.setSpan( CustomTypefaceSpan(typeface), titleText.getSpanStart(annotation), titleText.getSpanEnd(annotation), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE ) } } } styledText.text = spannableString</span></span></code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yq/62/mm/yq62mmgvajffkxkzk3qntsnxhw4.png" width="600"></div><br><p>  Disebutkan di atas bahwa bentang dari luar kerangka Android tidak dapat mengimplementasikan <code>Parcelable</code> dan dikirim melalui Intent.  Tetapi ini tidak berlaku untuk anotasi yang mengimplementasikan <code>Parcelable</code> .  Jadi Anda bisa melewatkan string beranotasi melalui Intent dan mengurai dengan cara yang persis sama dengan mengatur rentang Anda. </p><br><h1 id="kak-tekst-raspolagaetsya-v-textview">  Bagaimana teks ditempatkan di TextView </h1><br><p>  TextView tidak hanya dapat menampilkan teks, tetapi juga gambar.  Anda juga dapat mengatur berbagai indentasi di depan teks.  Di bawah tenda, ini berfungsi agar TextView membuat kelas anak, Layout, yang bertanggung jawab langsung untuk menampilkan teks.  Ini adalah kelas abstrak yang memiliki tiga implementasi, biasanya Anda tidak harus bekerja secara langsung dengannya kecuali Anda menulis kontrol sendiri: </p><br><ul><li>  <strong>BoringLayout</strong> digunakan untuk teks sederhana, tidak mendukung <strong>jeda</strong> baris, RTL, dan hal-hal lain, tetapi ini adalah yang paling ringan.  TextView menggunakannya jika teks memenuhi semua batasan. </li><li>  <strong>StaticLayout</strong> digunakan dalam TextView untuk kasus lain. </li><li>  <strong>DynamicLayout</strong> digunakan untuk teks yang bisa diubah dalam EditText. </li></ul><br><p>  Layout memiliki banyak metode yang memungkinkan Anda mengetahui berbagai parameter teks yang ditampilkan: koordinat garis, garis dasar, koordinat awal dan akhir teks dalam garis, dll.  (perincian lebih lanjut dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> ) </p><br><p>  Metode seperti itu bisa sangat berguna.  Misalnya, beberapa pengembang dihadapkan dengan tugas mengekstraksi bagian teks ke dalam persegi panjang bulat, dan berusaha menemukan solusinya melalui bentang yang tidak berlaku dalam menyelesaikan masalah ini. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8b/-2/df/8b-2df4-wo4ghk8tkwss6l48bfy.png" width="300"></div><br><p>  Tetapi metode kelas Layout bisa menyelamatkan.  Berikut adalah contoh solusi: </p><br><p>  Menggunakan anotasi, kami memilih kata-kata yang harus dilingkari dalam persegi panjang. </p><br><p>  Kemudian buat 4 sumber daya yang dapat digambar untuk semua kasus pembungkus teks, yang harus dilampirkan dalam persegi panjang: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/q4/ry/oj/q4ryojq_lsj3sdyyehvprallpl8.png" width="600"></div><br><p>  Selanjutnya, kami menemukan penjelasan yang kami butuhkan dalam teks, seperti dijelaskan di atas.  Sekarang kita memiliki indeks awal dan akhir anotasi tersebut.  Melalui metode Tata Letak, Anda dapat mengetahui jumlah baris tempat teks beranotasi dimulai, dan di mana ia berakhir: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> startLine = layout.getLineForOffset(spanStartIndex) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> endLine = layout.getLineForOffset(spanEndIndex)</code> </pre> <br><p>  Selanjutnya, Anda harus menggambar satu atau lebih persegi panjang.  Pertimbangkan kasus sederhana ketika bagian beranotasi dari teks muncul pada satu baris, maka kita hanya perlu satu persegi panjang dengan empat sudut bulat.  Tentukan koordinatnya dan gambar: </p><br><pre> <code class="kotlin hljs">... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (startLine == endLine) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lineTop = layout.getLineTop(startLine) <span class="hljs-comment"><span class="hljs-comment">//    val lineBottom = layout.getLineBottom(startLine) //    val startCoor = layout.getPrimaryHorizontal(spanStartIndex).toInt() //    val endCoor = layout.getPrimaryHorizontal(spanEndIndex).toInt() //    //   drawable.setBounds(startCoor, lineTop, endCoor, lineBottom) drawable.draw(canvas) ...</span></span></code> </pre><br><p>  Seperti yang dapat Anda lihat dari contoh ini, Layout menyimpan banyak informasi berguna pada teks yang ditampilkan, yang dapat membantu dalam pelaksanaan berbagai tugas yang tidak standar. </p><br><h1 id="proizvoditelnost-textview">  Kinerja TextView </h1><br><p>  TextView, seperti halnya View, melewati tiga fase saat ditampilkan: <code>onMeasure()</code> , <code>onLayout()</code> dan <code>onDraw()</code> .  Pada saat yang sama, <code>onMeasure()</code> membutuhkan waktu paling banyak, tidak seperti dua metode lainnya: saat ini, kelas Layout dibuat kembali dan ukuran teks dihitung.  Jadi mengubah ukuran teks (misalnya, mengubah font) memerlukan banyak pekerjaan.  Mengubah warna teks akan lebih ringan karena hanya membutuhkan memanggil <code>onDraw()</code> .  Seperti disebutkan di atas, sistem memiliki kata cache global dengan ukuran yang dihitung.  Jika kata tersebut sudah ada dalam cache, maka memanggil <code>onMeasure()</code> untuk itu akan membutuhkan 11-16% dari waktu yang diperlukan untuk perhitungan lengkap. </p><br><h2 id="uskorenie-pokaza-teksta">  Akselerasi teks </h2><br><p>  Pada 2015, pengembang Instagram mempercepat tampilan komentar pada foto menggunakan cache global.  Idenya adalah untuk menggambar teks sebelum ditampilkan di layar, sehingga "menghangatkan" cache sistem.  Ketika tiba saatnya untuk menampilkan teks, pengguna melihatnya lebih cepat, karena teks sudah diukur dan berada di cache. </p><br><p>  Dimulai dengan <strong>Android P (28)</strong> , pengembang Google telah menambahkan ke API kemampuan untuk melakukan fase mengukur ukuran teks terlebih dahulu di utas latar belakang - <code>PrecomputedText</code> (dan backport untuk API dimulai dengan <strong>Android I (14)</strong> - <code>PrecomputedTextCompat</code> ).  Menggunakan API baru, 90% pekerjaan akan dilakukan di utas latar belakang. </p><br><p>  Contoh: </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// UI thread val params: PrecomputedText.Params = textView.getTextMetricsParams() val ref = WeakReference(textView) executor.execute { // background thread val text = PrecomputedText.create("Hello", params) val textView = ref.get() textView?.post { // UI thread val textView = ref.get() textView?.text = text } }</span></span></code> </pre> <br><h2 id="pokaz-bolshogo-teksta">  Tampilkan teks besar </h2><br><p>  Jika Anda perlu menampilkan teks besar, maka jangan segera mentransfernya ke TextView.  Jika tidak, aplikasi mungkin berhenti bekerja dengan lancar atau benar-benar membeku, karena itu akan melakukan banyak pekerjaan pada utas utama untuk menunjukkan teks besar bahwa pengguna bahkan tidak dapat menggulir hingga akhir.  Solusinya adalah dengan membagi teks menjadi beberapa bagian (mis. Paragraf) dan menampilkan masing-masing bagian dalam RecyclerView.  Untuk speedup yang lebih besar, Anda dapat menghitung sebelum ukuran blok teks menggunakan PrecomputedText. </p><br><p>  Untuk memfasilitasi pemasangan PrecomputedText di RecyclerView, pengembang Google membuat metode khusus untuk <code>PrecomputedTextCompat.getTextFuture()</code> dan <code>AppCompatTextView.setTextFuture()</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBindViewHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vh: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ViewHolder</span></span></span></span><span class="hljs-function"><span class="hljs-params">, position: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = getData(position) vh.textView.setTextSize(...) vh.textView.setFontVariationSettings(...) <span class="hljs-comment"><span class="hljs-comment">//    val future = PrecomputedTextCompat.getTextFuture( data.text, vh.textView.getTextMetricsParamsCompat(), myExecutor ) //  future  TextView,      onMeasure() vh.textView.setTextFuture(future) }</span></span></code> </pre> <br><p>   RecyclerView      ,     ,              ,     . </p><br><p>  ,     <code>getTextFuture()</code>     (,   ),     ,   ,    <code>getTextFuture()</code> ,     ,    TextView. </p><br><h2 id="chto-nuzhno-znat-kogda-ustanavlivaesh-tekst-v-textview">   ,     TextView </h2><br><p>    <code>TextView.setText()</code>       : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == SPANNABLE || movementMethod != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { text = spannableFactory.newSpannable(spannable) <span class="hljs-comment"><span class="hljs-comment">//  } else { text = new SpannedString(spannable) //  }</span></span></code> </pre> <br><p>       span'  TextView,       <code>setText()</code> ,      . </p><br><p>    ,      .  TextView    ,  -,   .    ,      .    ,    ,     TextView   <code>spannableFactory</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MySpannableFactory</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Spannable.Factory</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newSpannable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(source: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CharSequence</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Spannable { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> source <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? Spannable ?: <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.newSpannable(source) } } textView.spannableFactory = MySpannableFactory()</code> </pre> <br><p>         <code>textView.setText(spannable, BufferType.SPANNABLE)</code> ,      . </p><br><p>  Google         span'  RecyclerView,      . </p><br><p>      TextView,     span,        <code>setText()</code> .      TextView      span. TextView   spannable-    span',  : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> spannable = textView.getText() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Spannable <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> span = CustomTypefaceSpan(span) spannable.setSpan(span, ...)</code> </pre> <br><p>      span,      TextView,         TextView .       ,   <code>invalidate()</code> ,    â€“ <code>requestLayout()</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> spannable = textView.getText() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Spannable <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> span = CustomTypefaceSpan(span) spannable.setSpan(span, ...) span.setTypeface(anotherTypeface) textView.requestLayout() <span class="hljs-comment"><span class="hljs-comment">// re-measure and re-draw // or textView.invalidate() // re-draw</span></span></code> </pre> <br><h2 id="ispolzovanie-autolink">  autoLink </h2><br><p>  TextView     .         <code>autoLink</code> .   <code>autoLink=â€webâ€</code> TextView          URL          <code>URLSpan</code> .   ,     SDK   <code>setText()</code> : </p><br><pre> <code class="java hljs">spannable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpannableString(string); Matcher m = pattern.matcher(text); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (...) { <span class="hljs-comment"><span class="hljs-comment">//      String utl = â€¦ URLSpan span = new URLSpan(url); spannable.setSpan(span, ...); }</span></span></code> </pre> <br><p>      UI ,     <code>autoLink=â€webâ€</code>   RecyclerView.          .        <code>LinkifyCompat</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,       background thread val spannable = SpannableString(string) LinkifyCompat.addLinks(spannable, Linkify.WEB_URLS) //   RecyclerView override fun onBindViewHolder(holder: ViewHolder, position: Int) { holder.textView.setText(spannable, BufferType.SPANNABLE) // ... }</span></span></code> </pre> <br><p>  <code>autoLink</code>      <code>map</code> â€“    (      <code>all</code> ).       .   ,        WebView,      !    SDK   <code>Linkify.gatherMapLinks()</code>    ,      : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((address = WebView.findAddress(string)) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { ... }</code> </pre> <br><p>   WebView  TODO   SDK: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAddress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String addr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Rewrite this in Java so it is not needed to start up chromium // Could also be deprecated return getFactory().getStatics().findAddress(addr); }</span></span></code> </pre> <br><p>     ?     Smart Linkify,       <strong>Android P (28)</strong> ,          ,      .    : </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// UI thread val text: Spannable = â€¦ val request = TextLinks.Request.Builder(text) val ref = WeakReference(textView) executor.execute { // background thread TextClassifier.generateLinks(request).apply(text) val textView = ref.get() textView?.post { // UI thread val textView = ref.get() textView?.text = text } }</span></span></code> </pre> <br><p>    Linkify,      .        toolbar   ,     Google . </p><br><p>  Smart Linkify    :  ,    . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9t/nc/qb/9tncqbkanp8avsnmisd-ax0z7ae.gif" width="300"></div><br><h1 id="magnifier"> Magnifier </h1><br><p>   <strong>Android P (28)</strong> ,     â€“ Magnifier,       .           . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fi/nn/or/finnor2svtuttfn1v-lxwkblgwm.gif" width="400"></div><br><p>      TextView, EditText  WebView,            :  API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> . </p><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p>          Android   ,   , : </p><br><ul><li>         </li><li>    </li><li>   ,   TextView (, EditText) </li></ul><br><p>  -     ,      Google I/O'19 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">â€œBest Practices for Using Text in Androidâ€</a> . </p><br><a name="links"></a><br><h1 id="poleznye-ssylki">  Tautan yang bermanfaat </h1><br><h2 id="stati">  </h2><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Florina Muntenescu. "Spantastic text styling with Spans"</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Florina Muntenescu. "Underspanding spans"</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Florina Muntenescu. "Styling internationalized text in Android"</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Instagram Engineering. "Improving Comment Rendering on Android"</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Daniel Lee. "Text rendering on Android"</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mariusz DÄ…browski. "What is new in Android P â€” PrecomputedText"</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Chet Haase. "RecyclerView Prefetch"</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Chris Craik. "Prefetch Text Layout in RecyclerView"</a> </li></ul><br><h2 id="doklady">  Laporan </h2><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Best practices for text on Android (Google I/O '18)</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Use Android Text Like a Pro (Android Dev Summit '18)</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Best Practices for Using Text in Android (Google I/O'19)</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461787/">https://habr.com/ru/post/id461787/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461773/index.html">Airtest IDE - cara baru dalam pengujian otomatisasi game mobile?</a></li>
<li><a href="../id461775/index.html">3 kasus untuk menggunakan Seledri dalam aplikasi Django</a></li>
<li><a href="../id461779/index.html">80% dari data perusahaan Anda tidak tersedia untuk Anda. Apa yang harus dilakukan?</a></li>
<li><a href="../id461781/index.html">"Ycombinator Startup School 2019." Video tiga minggu pertama</a></li>
<li><a href="../id461785/index.html">Kerugian RISC-V</a></li>
<li><a href="../id461793/index.html">Ivan Ponomarev tentang Kafka Streams API di pertemuan jug.msk.ru</a></li>
<li><a href="../id461797/index.html">Kisah-kisah pelayanan. Posting sembrono tentang pekerjaan serius</a></li>
<li><a href="../id461801/index.html">DisplayPort-LVDS</a></li>
<li><a href="../id461803/index.html">Data Version Control (DVC): versi data dan reproduksibilitas percobaan</a></li>
<li><a href="../id461805/index.html">Aplikasi Integrasi Monte Carlo dalam Rendering</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>