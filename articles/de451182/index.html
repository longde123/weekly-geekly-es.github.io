<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍❤️‍👩 🕵🏼 🚯 Wie Größen von C-Arrays Teil der binären Schnittstelle der Bibliothek wurden 😧 👃🏾 🧑🏾‍🤝‍🧑🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mit den meisten C-Compilern können Sie auf ein extern Array mit undefinierten Grenzen zugreifen, zum Beispiel: 



 extern int external_array[]; int a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie Größen von C-Arrays Teil der binären Schnittstelle der Bibliothek wurden</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451182/"> Mit den meisten C-Compilern können Sie auf ein <code>extern</code> Array mit undefinierten Grenzen zugreifen, zum Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_array[]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array_get</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> external_array[index]; }</code> </pre> <br>  Die Definition von external_array befindet sich möglicherweise in einer anderen Übersetzungseinheit und sieht folgendermaßen aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_array[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> };</code> </pre> <br>  Die Frage ist, was passiert, wenn sich diese separate Definition folgendermaßen ändert: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_array[<span class="hljs-number"><span class="hljs-number">4</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> };</code> </pre> <br>  Oder so: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_array[<span class="hljs-number"><span class="hljs-number">2</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> };</code> </pre> <a name="habracut"></a><br>  Wird die binäre Schnittstelle beibehalten (vorausgesetzt, es gibt einen Mechanismus, mit dem die Anwendung die Größe des Arrays zur Laufzeit bestimmen kann)? <br><br>  Seltsamerweise verletzt bei vielen Architekturen das <i>Erhöhen der Größe des Arrays</i> die Kompatibilität der binären Schnittstelle (ABI).  Das Reduzieren der Größe des Arrays kann auch Kompatibilitätsprobleme verursachen.  In diesem Artikel werden wir uns die ABI-Kompatibilität genauer ansehen und erklären, wie Probleme vermieden werden können. <br><br><h1>  Links im Datenbereich der ausführbaren Datei </h1><br>  Um zu verstehen, wie die Größe des Arrays Teil der binären Schnittstelle wird, müssen wir zuerst die Links im Datenabschnitt der ausführbaren Datei untersuchen.  Natürlich hängen die Details von der spezifischen Architektur ab, und hier konzentrieren wir uns auf die x86-64-Architektur. <br><br>  Die x86-64-Architektur unterstützt die Adressierung relativ zum Programmzähler, <code>array_get</code> Zugriff auf die globale <code>array_get</code> kann, wie in der <code>array_get</code> gezeigten Funktion <code>array_get</code> , in einem einzigen <code>movl</code> Befehl kompiliert werden: <br><br><pre> <code class="cpp hljs">array_get: <span class="hljs-function"><span class="hljs-function">movl </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">external_array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(,%rdi,</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">4</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">, %eax ret</span></span></code> </pre> <br>  Daraus erstellt der Assembler eine Objektdatei, in der die Anweisung als <code>R_X86_64_32S</code> markiert <code>R_X86_64_32S</code> . <br><br><pre> <code class="plaintext hljs">0000000000000000 : 0: mov 0x0(,%rdi,4),%eax 3: R_X86_64_32S external_array 7: retq</code> </pre> <br>  Diese Verschiebung teilt dem Linker ( <code>ld</code> ) mit, wie die entsprechende Position der Variablen <code>external_array</code> während der Verknüpfung beim Erstellen der ausführbaren Datei gefüllt werden soll. <br><br>  Dies hat zwei wichtige Konsequenzen. <br><br><ul><li>  Da der Offset der Variablen zur Erstellungszeit bestimmt wird, gibt es zur Laufzeit keinen Overhead, um ihn zu bestimmen.  Der einzige Preis ist der Zugriff auf den Speicher selbst. <br></li><li>  Um den Versatz zu bestimmen, müssen Sie die Größe aller variablen Daten kennen.  Andernfalls wäre es unmöglich, das Format des Datenabschnitts während des Layouts zu berechnen. </li></ul><br>  Bei C-Implementierungen, die auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Executable und Link Format (ELF) ausgerichtet sind</a> , wie in GNU / Linux, enthalten Verweise auf <code>extern</code> Variablen keine Objektgrößen.  Im Beispiel <code>array_get</code> Größe des Objekts selbst dem Compiler unbekannt.  Tatsächlich sieht die gesamte Assembler-Datei folgendermaßen aus (wobei nur die <code>-fno-asynchronous-unwind-tables</code> aus <code>-fno-asynchronous-unwind-tables</code> , die technisch für die psABI-Konformität erforderlich sind): <br><br><pre> <code class="plaintext hljs"> .file "get.c" .text .p2align 4,,15 .globl array_get .type array_get, @function array_get: movl external_array(,%rdi,4), %eax ret .size array_get, .-array_get .ident "GCC: (GNU) 8.3.1 20190223 (Red Hat 8.3.1-2)" .section .note.GNU-stack,"",@progbits</code> </pre> <br>  In dieser Assembler-Datei gibt es keine <code>movl</code> für <code>external_array</code> : Die einzige Zeichenreferenz befindet sich in der Zeile mit der Anweisung <code>movl</code> , und die einzigen numerischen Daten in der Anweisung sind die Größe des Array-Elements (impliziert durch <code>movl</code> multipliziert mit 4). <br><br>  Wenn ELF Größen für undefinierte Variablen benötigt, ist es sogar unmöglich, die Funktion <code>array_get</code> zu kompilieren. <br><br>  Wie erhält der Linker die tatsächliche Zeichengröße?  Er sieht sich die Definition des Symbols an und verwendet die dort gefundenen Größeninformationen.  Auf diese Weise kann der Compiler das Layout des Datenabschnitts berechnen und die Datenbewegungen mit den entsprechenden Offsets füllen. <br><br><h1>  Gemeinsame ELF-Objekte </h1><br>  Bei C-Implementierungen für ELF muss der Programmierer dem Quellcode kein Markup hinzufügen, um anzugeben, ob sich die Funktion oder Variable im aktuellen Objekt (möglicherweise der Bibliothek oder der ausführbaren Hauptdatei) oder in einem anderen Objekt befindet.  Der Linker und der Dynamic Loader kümmern sich darum. <br><br>  Gleichzeitig bestand der Wunsch nach ausführbaren Dateien, die Leistung nicht durch Ändern des Kompilierungsmodells zu verringern.  Dies bedeutet, dass beim Kompilieren des Quellcodes für das Hauptprogramm ( <code>-fPIC</code> ohne <code>-fPIC</code> und in diesem speziellen Fall ohne <code>-fPIE</code> ) die Funktion <code>array_get</code> in <i>genau dieselbe</i> <code>array_get</code> kompiliert wird <i>,</i> bevor dynamische gemeinsam genutzte Objekte eingeführt werden.  Darüber hinaus spielt es keine Rolle, ob die Variable <code>external_array</code> in der grundlegendsten ausführbaren Datei definiert ist oder ob ein freigegebenes Objekt zur Laufzeit separat geladen wird.  Die vom Compiler erstellten Anweisungen sind in beiden Fällen gleich. <br><br>  Wie ist das möglich?  Gemeinsame ELF-Objekte sind schließlich positionsunabhängig.  Sie werden zur Laufzeit an <i>unvorhersehbaren, zufälligen Adressen</i> geladen.  Der Compiler generiert jedoch eine Maschinencodesequenz, bei der diese Variablen an einem <i>festen Versatz liegen müssen, der während der Verknüpfung berechnet wird</i> , lange bevor das Programm startet. <br><br>  Tatsache ist, dass nur ein geladenes Objekt (die ausführbare Hauptdatei) diese festen Offsets verwendet.  Alle anderen Objekte (der dynamische Loader selbst, die C-Laufzeitbibliothek und alle anderen vom Programm verwendeten Bibliotheken) werden kompiliert und als vollständig positionsunabhängige Objekte (PICs) kompiliert.  Für solche Objekte lädt der Compiler die tatsächliche Adresse jeder Variablen aus der globalen Offset-Tabelle (GOT).  Wir können diesen Kreisverkehr sehen, wenn wir das Beispiel <code>-fPIC</code> mit <code>-fPIC</code> , was zu einem solchen Assemblycode führt: <br><br><pre> <code class="plaintext hljs">array_get: movq external_array@GOTPCREL(%rip), %rax movl (%rax,%rdi,4), %eax ret</code> </pre> <br>  Infolgedessen ist die Adresse der Variablen <code>external_array</code> nicht mehr fest codiert und kann zur Laufzeit durch entsprechende Initialisierung des GOT-Datensatzes geändert werden.  Dies bedeutet, dass sich die Definition von <code>external_array</code> zur Laufzeit im selben gemeinsam genutzten Objekt, einem anderen gemeinsam genutzten Objekt oder im Hauptprogramm befinden kann.  Der dynamische Lader findet die geeignete Definition basierend auf den ELF-Zeichensuchregeln und ordnet die undefinierte Symbolreferenz seiner Definition zu, indem er den GOT-Datensatz auf seine tatsächliche Adresse aktualisiert. <br><br>  Wir kehren zum ursprünglichen Beispiel zurück, in dem sich die Funktion <code>array_get</code> im Hauptprogramm befindet, sodass die Adresse der Variablen direkt angegeben wird.  Die im Linker implementierte Schlüsselidee besteht darin, dass das Hauptprogramm eine Variablendefinition <code>external_array</code> bereitstellt, <i>selbst wenn diese zur Laufzeit tatsächlich in einem gemeinsamen Objekt definiert ist</i> .  Anstatt die anfängliche Definition der Variablen im gemeinsam genutzten Objekt anzugeben, wählt der dynamische Lader eine <i>Kopie der</i> Variablen im Datenabschnitt der ausführbaren Datei aus. <br><br>  Dies hat zwei wichtige Konsequenzen.  Denken Sie zunächst daran, dass <code>external_array</code> wie folgt definiert ist: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_array[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> };</code> </pre> <br>  Hier gibt es einen Initialisierer, der auf die Definition in der ausführbaren Hauptdatei angewendet werden sollte.  Zu diesem Zweck wird in der ausführbaren Hauptdatei ein Link zum Kopierort des Symbols platziert.  Der <code>readelf -rW</code> zeigt an, dass <code>R_X86_64_COPY</code> . <br><br><pre>  Der Umzugsabschnitt '.rela.dyn' am Offset 0x408 enthält 3 Einträge:
     Offset Info Type Symbol Wert Symbol Name + Addend
 0000000000403ff0 0000000100000006 R_X86_64_GLOB_DAT 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0
 0000000000403ff8 0000000200000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0
 0000000000404020 0000000300000005 R_X86_64_COPY 0000000000404020 external_array + 0 </pre><br>  Wie bei anderen Bewegungen wird die Kopierbewegung vom dynamischen Lader ausgeführt.  Es enthält eine einfache, bitweise Kopieroperation.  Das Ziel der Kopie wird durch den Verschiebungsversatz bestimmt (im Beispiel <code>0000000000404020</code> ).  Die Quelle wird zur Laufzeit anhand des Symbolnamens ( <code>external_array</code> ) und seines Werts ermittelt.  Beim Erstellen einer Kopie überprüft der dynamische Lader auch die Größe des Zeichens, um die Anzahl der zu kopierenden Bytes zu ermitteln.  Um dies zu ermöglichen, wird das Symbol <code>external_array</code> automatisch als bestimmtes Symbol aus der ausführbaren Datei exportiert, damit es zur Laufzeit für den dynamischen Loader sichtbar ist.  Die dynamische Symboltabelle ( <code>.dynsym</code> ) spiegelt dies wider, wie der <code>readelf -sW</code> : <br><br><pre>  Die Symboltabelle '.dynsym' enthält 4 Einträge:
    Num: Wert Größe Typ Bind Vis Ndx Name
      0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 
      1: 0000000000000000 0 FUNC GLOBAL DEFAULT UND __libc_start_main@GLIBC_2.2.5 (2)
      2: 0000000000000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__
      3: 0000000000404020 12 OBJECT GLOBAL DEFAULT 22 external_array </pre><br>  Woher kommen die Informationen über die Größe des Objekts (in diesem Beispiel 12 Byte)?  Der Linker öffnet alle gängigen Objekte, sucht nach ihrer Definition und nimmt Informationen über die Größe entgegen.  Auf diese Weise kann der Linker nach wie vor das Layout des Datenabschnitts berechnen, sodass feste Offsets verwendet werden können.  Auch hier ist die Größe der Definition in der ausführbaren Hauptdatei festgelegt und kann zur Laufzeit nicht geändert werden. <br><br>  Der dynamische Linker leitet auch symbolische Links in freigegebenen Objekten an die verschobene Kopie in der ausführbaren Hauptdatei um.  Dies stellt sicher, dass im gesamten Programm nur eine Kopie der Variablen vorhanden ist, wie es die Semantik von C erfordert. Andernfalls werden Aktualisierungen der ausführbaren Hauptdatei für dynamische freigegebene Objekte nicht sichtbar, wenn sich die Variable nach der Initialisierung ändert. <br><br><h1>  Auswirkungen auf die Binärkompatibilität </h1><br>  Was passiert, wenn wir die Definition von <code>external_array</code> in einem gemeinsam genutzten Objekt ändern, ohne das Hauptprogramm zu verknüpfen (oder neu zu kompilieren)?  Ziehen Sie zunächst in Betracht <i>,</i> ein Array-Element <i>hinzuzufügen</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_array[<span class="hljs-number"><span class="hljs-number">4</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> };</code> </pre> <br>  Dadurch wird zur Laufzeit eine Warnung vom dynamischen Lader generiert: <br><br> <code>main-program: Symbol `external_array' has different size in shared object, consider re-linking</code> <br> <br>  Das Hauptprogramm enthält weiterhin eine <code>external_array</code> Definition mit Platz für nur 12 Bytes.  Dies bedeutet, dass die Kopie unvollständig ist: Nur die ersten drei Elemente des Arrays werden kopiert.  Daher ist der Zugriff auf das Array-Element <code>extern_array[3]</code> nicht definiert.  Dieser Ansatz betrifft nicht nur das Hauptprogramm, sondern auch den gesamten Code im Prozess, da alle Verweise auf <code>extern_array</code> auf die Definition im Hauptprogramm umgeleitet wurden.  Dies umfasst ein generisches Objekt, das eine <code>extern_array</code> Definition <code>extern_array</code> .  Er ist wahrscheinlich nicht bereit, sich einer Situation zu stellen, in der ein Array-Element in seiner eigenen Definition verschwunden ist. <br><br>  Wie wäre es, in die entgegengesetzte Richtung zu wechseln und ein Element zu entfernen? <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_array[<span class="hljs-number"><span class="hljs-number">2</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> };</code> </pre> <br>  Wenn das Programm den Zugriff auf das Array-Element <code>extern_array[2]</code> vermeidet, weil es die reduzierte Länge des Arrays irgendwie erkennt, funktioniert dies.  Nach dem Array befindet sich nicht verwendeter Speicher, der das Programm jedoch nicht beschädigt. <br><br>  Dies bedeutet, dass wir die folgende Regel erhalten: <br><br><ul><li>  Das Hinzufügen von Elementen zu einer globalen Array-Variablen verletzt die Binärkompatibilität. <br></li><li>  Das Entfernen von Elementen kann die Kompatibilität beeinträchtigen, wenn es keinen Mechanismus gibt, der den Zugriff auf gelöschte Elemente verhindert. </li></ul><br>  Leider sieht die Warnung des dynamischen Laders harmloser aus als sie tatsächlich ist, und für entfernte Elemente gibt es überhaupt keine Warnung. <br><br><h1>  So vermeiden Sie diese Situation </h1><br>  Das Erkennen von ABI-Änderungen ist mit Tools wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">libabigail</a> ziemlich einfach. <br><br>  Der einfachste Weg, diese Situation zu vermeiden, besteht darin, eine Funktion zu implementieren, die die Adresse des Arrays zurückgibt: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> local_array[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_external_array</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> local_array; }</code> </pre> <br>  Wenn die Definition des Arrays aufgrund der Art und Weise, wie es in der Bibliothek verwendet wird, nicht statisch gemacht werden kann, können wir stattdessen seine Sichtbarkeit verbergen und auch seinen Export verhindern und daher das Kürzungsproblem vermeiden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> local_array[<span class="hljs-number"><span class="hljs-number">3</span></span>] __attribute__ ((visibility (<span class="hljs-string"><span class="hljs-string">"hidden"</span></span>))) = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> };</code> </pre> <br>  Alles ist viel komplizierter, wenn die Array-Variable aus Gründen der Abwärtskompatibilität exportiert wird.  Da das Array aus der Bibliothek abgeschnitten ist, kann das alte Hauptprogramm mit einer kürzeren Array-Definition keinen Zugriff auf das vollständige Array für den neuen Client-Code gewähren, wenn es mit demselben globalen Array verwendet wird.  Stattdessen kann die Zugriffsfunktion ein separates (statisches oder verstecktes) Array oder möglicherweise ein separates Array für hinzugefügte Elemente am Ende verwenden.  Der Nachteil ist, dass es nicht möglich ist, alles in einem kontinuierlichen Array zu speichern, wenn die Arrayvariable aus Gründen der Abwärtskompatibilität exportiert wird.  Das Design der sekundären Schnittstelle sollte dies widerspiegeln. <br><br>  Mit der Versionskontrolle von Zeichen können Sie mehrere Versionen mit unterschiedlichen Größen exportieren, ohne die Größe in einer bestimmten Version zu ändern.  Bei Verwendung dieses Modells verwenden neue verwandte Programme immer die neueste Version, vermutlich mit der größten Größe.  Da die Version und Größe des Symbols gleichzeitig vom Link-Editor festgelegt werden, sind sie immer konsistent.  Die GNU C-Bibliothek verwendet diesen Ansatz für die historischen Variablen <code>sys_errlist</code> und <code>sys_siglist</code> .  Dies liefert jedoch immer noch kein einziges kontinuierliches Array. <br><br>  Alles in allem ist eine Accessor-Funktion (wie die <code>get_external_array</code> Funktion <code>get_external_array</code> oben) der beste Ansatz, um dieses ABI-Kompatibilitätsproblem zu vermeiden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de451182/">https://habr.com/ru/post/de451182/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de451172/index.html">Julia: Funktionen und Strukturen als Funktionen</a></li>
<li><a href="../de451174/index.html">Anpassung von Programmen für ZX Spectrum an TR-DOS mit modernen Mitteln. Teil 1</a></li>
<li><a href="../de451176/index.html">Nachrichten aus der Welt von OpenStreetMap Nr. 458 (23.04.2019 - 09.04.2019)</a></li>
<li><a href="../de451178/index.html">Crew Dragon Parachute Landing Crash Test</a></li>
<li><a href="../de451180/index.html">PCB ersetzt zwei Linearmotoren</a></li>
<li><a href="../de451184/index.html">Blue Origin Blue Moon-Projekt: Menschen auf dem Mond bis 2024</a></li>
<li><a href="../de451186/index.html">LINSTOR-Repository und seine Integration in OpenNebula</a></li>
<li><a href="../de451188/index.html">Sberbank oder hin und zurück</a></li>
<li><a href="../de451196/index.html">Trennung von Kunden- und Freiberuflerprofilen</a></li>
<li><a href="../de451198/index.html">Die Rolle von Augmented Reality und Virtual Reality in der NBA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>