<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕸️ 👆 🕴🏼 DPKI：通过区块链解决集中式PKI的缺点 🤟🏾 ⏏️ 🚴🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="数字证书是最常用的辅助工具之一，可帮助保护公共网络中的数据。 但是，该技术的主要缺点也是众所周知的：用户被迫隐含地信任颁发数字证书的证书颁发机构。 ENCRY的技术和创新总监Andrey Chmora建议采用一种新的方法来构建公用密钥基础结构（PKI），以消除使用分布式分类帐（区块链）技术的现有弊端...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DPKI：通过区块链解决集中式PKI的缺点</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/encry/blog/461731/"><img src="https://habrastorage.org/webt/nz/th/oe/nzthoe936pglmrwozahcz-kwqjk.jpeg"><br><br> 数字证书是最常用的辅助工具之一，可帮助保护公共网络中的数据。 但是，该技术的主要缺点也是众所周知的：用户被迫隐含地信任颁发数字证书的证书颁发机构。  ENCRY的技术和创新总监Andrey Chmora建议采用一种新的方法来构建<b>公用密钥基础结构（PKI），</b>以消除使用分布式分类帐（区块链）技术的现有弊端。 <br> 让我们从基础开始。 <br><a name="habracut"></a><br>  <i>如果您已经知道现有公钥基础结构的基本知识及其主要缺点，请随时滚动至我们建议更改的描述。</i> <br><br><div class="spoiler">  <b class="spoiler_title">什么是数字签名和数字证书？</b> <div class="spoiler_text">  Internet上的交互始终包括数据交换。 因此，我们所有人都希望在此类交换过程中保持数据安全。 但是什么是安全性？ 最受欢迎的安全服务是机密性，完整性和真实性。 如今，它们基于非对称密码学，也称为公钥密码学。 <br><br> 首先，这些方法要求交互的实体必须具有两个专用的密钥对：公共密钥和私有密钥。 这些密钥对提供上述安全功能。 <br><br> 但是如何实现信息的私密交换？ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/95/g0/ar/95g0arsxoegtxcwsd8b9cr9lvra.png" alt="图片"></div><br>  <i>图1.使用公共密钥加密的加密数据传输</i> <br><br> 在发送任何数据之前，发送者使用接收者的公共密钥加密（加密）公共数据，然后接收者使用私钥对解密加密的数据。 <br><br> 如何实现发送信息的完整性和真实性？ 可以使用其他机制解决此问题。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ig/2k/da/ig2kdawntfyggluw1gzwvoajfa4.png" alt="图片"></div><br>  <i>图2.数字签名/验证</i> <br><br> 尽管未加密公共数据，但它包含加密哈希函数值，即输入数据序列的加密“压缩”图像。 这种散列的结果称为“摘要”，并使用发送方的私钥（“身份验证器”）进行加密。 摘要加密的结果是一个数字签名，该数字签名与未加密的文本一起发送到接收者（“验证者”）。 接收者使用验证者的公共密钥解密数字签名，然后将其与验证者根据获得的公共数据计算出的加密哈希函数值进行比较。 如果它们匹配，则所接收的数据是完全真实的，完整的并且没有攻击者可能进行的任何修改。 <br><br> 处理个人数据和支付信息的大多数资源（例如银行，保险公司，航空承运人，支付系统以及税务服务和其他政府门户网站）广泛使用非对称密码术。 <br><br> 数字证书如何在这里提供帮助？ 这很简单。 这两个过程都包含公钥，它们起着非常重要的作用，因此，我们必须始终检查它们是否属于发送者（或需要验证签名的身份验证者）或接收者而不是攻击者。 这就是数字证书可以帮助确保公钥的真实性和完整性的地方。 <br><br>  <i>注意：公钥的真实性和完整性通过与公开数据完全相同的方式进行验证，即使用数字签名（DS）。</i> </div></div><br><div class="spoiler">  <b class="spoiler_title">谁颁发数字证书？</b> <div class="spoiler_text">数字证书由受信任的证书颁发机构（CA）颁发和维护。 发出请求的实体要求CA颁发证书，在注册中心（RC）中注册，然后在CA中接收其证书。  CA保证证书中的公钥属于为其颁发证书的实体。 <br><br> 如果您不验证公共密钥的真实性，那么攻击者将能够用自己的密钥替换已传输/存储的密钥。 更换密钥后，攻击者将能够解密发送者转移到接收者的所有内容，甚至可以自行决定修改公共数据。 <br><br> 数字证书始终与非对称密码一起使用。  SSL证书是最受欢迎的数字证书之一，用于通过HTTPS进行安全通信。  SSL证书由各个司法管辖区的数百家公司颁发。 核心市场份额分布在五到十个最大的受信任证书颁发机构中：IdenTrust，Comodo，GoDaddy，GlobalSign，DigiCert，CERTUM，Actalis，Secom和Trustwave。 <br><br>  CA和RC是PKI组件，还包括： <br><br><ul><li>  <b>公共字典：</b>一个公共数据库，可为数字证书提供可靠的存储 </li><li>  <b>吊销证书列表：</b>一个公共数据库，可为吊销的公用密钥的数字证书提供可靠的存储（例如，由于私钥被泄露） <br> 基础设施实体可以自己访问此数据库，也可以使用专门的在线认证状态协议（OCSP），从而简化了验证过程。 </li><li>  <b>证书用户：</b>根据与CA的用户协议提供服务的PKI实体，并根据<b>证书中的</b>公钥验证数字签名和/或加密数据 </li><li>  <b>订户：</b>由CA提供服务的PKI实体，持有证书中的私钥和成对的公钥，并已与CA达成订户协议。 订户也可以是证书的用户。 </li></ul><br> 因此，公钥基础结构的受信任实体（包括CA，RC和Public Dictionary）负责： <br><br><ol><li> 验证提出要求的实体 </li><li> 分析公钥证书 </li><li> 为提出请求的经过身份验证的实体颁发公共密钥证书 </li><li> 更改公钥证书的状态 </li><li> 提供有关公钥证书当前状态的信息。 </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">PKI的缺点是什么？</b> <div class="spoiler_text">  PKI的根本缺点是依赖受信任的实体。  <b>用户被迫盲目地信任CA和RC。</b> 但是，这种盲目信任是危险的。 <br><br> 在过去的十年中，基础架构漏洞引起了几起重大丑闻。 <br><br>  2010年，使用来自RealTek和JMicron的被盗数字证书签名的恶意软件Stuxnet开始在Internet上传播。 <br><br>  2017年，谷歌指责赛门铁克发行了大量伪造的证书。  <i>当时，赛门铁克是已颁发证书数量最大的CA之一。</i>  <i>自Google Chrome版本70起，Google已于2017年12月1日停止支持该公司及其关联公司GeoTrust和Thawte颁发的所有证书。</i> <br><br> 这些CA受到破坏，结果，CA本身以及用户和订户受到了影响。 此外，对基础架构的信心也受到了影响。 另外，由于政治冲突，可能会禁止数字证书，从而影响许多资源。 因此，俄罗斯当局在2016年考虑建立国家认证中心来为Runet网站颁发SSL证书。 在当前情况下， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">俄罗斯政府门户使用</a>美国公司Comodo或Thawte（赛门铁克的子公司）颁发的数字证书。 <br><br> 还有另一个问题： <b>如何最初对用户进行身份验证？</b> 如何识别已向CA请求数字证书的匿名用户？ 如今，它通常是根据基础结构功能随意制作的。 一些信息来自公共数据库（例如，有关请求证书的法人实体）或银行和邮局，个人可以通过其身份证和其他文件进行识别。 <br><br> 基于虚假凭证的模拟是基本问题之一。 而且，不幸的是，由于信息和理论方面的原因，甚至可能没有完整的解决方案：没有可靠的信息，就无法验证实体的真实性。 通常，验证过程需要一组证明提出请求的实体的身份的文档。 尽管有很多验证方法，但没有一种可以保证文件的真实性。 因此，也不能确定发出请求的实体的真实性。 <br></div></div><br><div class="spoiler">  <b class="spoiler_title">如何消除这些弊端？</b> <div class="spoiler_text"> 由于当前的PKI问题主要是由集中引起的，因此很明显，分散可以帮助消除其中的至少一些问题。 <br><br> 去中心化不依赖任何受信任的实体，因为去中心<b>化公钥基础结构（DPKI）的</b>创建将使CA和RC都变得不必要。 让我们拒绝数字证书概念，而是使用分布式分类帐存储有关公钥的信息。 在我们的案例中，分类帐是一个线性数据库，由单个记录（块）组成，并使用区块链技术进行连接。 让我们用术语“通知”代替术语“数字证书”。 <br><br> 在拟议的DPKI中，通知的接收，验证和撤销是这样的： <br><br><ol><li> 发出请求的每个实体都通过填写注册表来自行申请通知，然后进行交易，并将其存储在专用池中。 </li><li> 有关公钥的信息以及所有者的详细信息和其他元数据都存储在分布式分类帐中，而不是存储在由CA在集中式PKI中颁发的数字证书中。 </li><li> 然后，通过DPKI用户社区而不是RC的共同努力对发出请求的实体进行身份验证。 </li><li> 仅此类通知的所有者可以更改公钥的状态。 </li><li> 每个人都可以访问分布式分类帐并检查公钥的当前状态。 </li></ol><br>  <i>注意：乍一看，对发出请求的实体的身份验证似乎不可靠。</i>  <i>但是，重要的是要记住，当今所有数字服务用户都在不断扩大数字足迹。</i>  <i>公开可用的工具包括法律实体的数字数据库，地图，数字化的地形图像，社交媒体等。</i>  <i>它们已被记者和执法机构成功用于调查。</i>  <i>典型的例子之一包括Bellingcat调查和联合小组JIT，该联合小组调查了马来西亚波音飞机失事。</i> </div></div><br> 那么，去中心化的公共密钥基础架构将如何在实践中起作用？ 让我们深入研究我们<b>在2018年获得专利</b>的技术，并考虑我们的最佳专业知识。 <br><br> 假设有一个拥有一组公共密钥的个人，其中每个密钥都是存储在分类帐中的一种交易。 如何验证所有这些密钥确实属于没有CA的给定所有者？ 为了解决此任务，我们可以创建一个空交易来存储有关所有者及其电子钱包的信息（从中扣除将交易添加到分类账的佣金）。 空事务是一种“锚”，用于挂接下一个事务以及有关公钥的数据。 这种类型的每个事务都包含一个专门的数据结构，称为“通知”。 <br><br>  <i>通知是功能字段的结构化数据集，用于存储有关所有者公钥的信息，并通过将其添加到分布式分类帐中的相关记录之一来确保该密钥的持久性。</i> <br><br> 下一个明显的问题是如何形成空交易？ 像所有后续事务一样，空事务是六个数据字段的集合。 为了形成空交易，我们使用电子钱包的公钥/私钥对。 当用户创建其钱包时，将创建此公钥/私钥对，从该钱包中扣除用于向分类账添加空交易以及用于后续通知操作的佣金。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qw/gu/2d/qwgu2dihzkrkduvq7qz8gcplyve.jpeg" alt="图片"></div><br>  <i>图3.创建一个空事务</i> <br><br>  <i>图3</i>显示了如何使用SHA256哈希函数然后使用RIPEMD160哈希函数形成电子钱包公钥摘要。 此处，RIPEMD160负责表示摘要大小最大为160位的数据。 这非常重要，因为分类帐是昂贵的数据库。 公钥本身包含在第五个字段中。 第一个字段包含将给定交易链接到上一个交易的数据。 在空事务中，与所有其他事务不同，此字段为空。 第二个字段包含用于验证交易连接性的数据。 为了简洁起见，我们将第一和第二字段中的数据分别称为“绑定”和“验证”。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/py/4m/c8/py4mc8voonsndcqfs-xp1krttrw.jpeg" alt="图片"></div><br>  <i>图4.事务绑定和验证</i> <br><br> 可以使用迭代哈希来形成这些字段中的数据，如上面的<i>图4</i>所示，用于绑定第二和第三事务。 <br> 前五个字段中的数据通过使用电子钱包私钥生成的DS进行身份验证。 就是这样-现在可以将事务添加到池中，然后在成功验证后（ <i>如图5</i>所示）添加到分类帐中。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/f9/tt/uk/f9ttukcb_mprsdby_dsafwpnwow.jpeg" alt="图片"></div><br>  <i>图5.空交易的验证</i> <br><br> 现在，此事务可用于“预备”下一个事务。 让我们看一下<i>图6</i> ，看看如何形成所有非空事务。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0c/ul/ks/0culksjzrhy0nx1dylr_scysrpu.jpeg" alt="图片"></div><br>  <i>图6.创建一个非空事务</i> <br><br> 您可能会注意到的第一件事是大量的公钥/私钥对。 除了已经熟悉的电子钱包公钥/私钥对，我们还使用普通和服务密钥对。 <br><br> 普通的公共密钥是这里最重要的部分。 该密钥用于周围世界的各种过程和过程中（例如银行业务和其他交易，单据流等）。 例如，来自普通公用/专用密钥对的专用密钥可用于为各种文档（例如付款单）创建DS，而公用密钥可用于随后执行这些校验的DS验证订单。 <br><br> 服务公钥/私钥对发布给已注册的DPKI实体。 该公钥/私钥对的名称清楚地反映了其目的。 请注意，服务密钥不用于生成/验证空交易。 <br><br> 为了清楚起见，让我们完善这些键的用途： <br><br><ol><li> 电子钱包密钥用于生成和/或验证空交易和任何非空交易。 电子钱包的私钥只有拥有同样普通公钥集的电子钱包所有者才知道。 </li><li> 普通公用密钥的目的与在中央PKI中为其颁发证书的公用密钥的目的相同。 </li><li> 服务公钥/私钥对属于DPKI。 为注册实体颁发私钥，并将其用于创建所有非空交易的DS。 在将交易添加到分类账之前，使用公钥来验证交易的DS。 </li></ol><br> 因此，我们有两组密钥。 第一组包括仅在DPKI中有效的服务密钥和电子钱包密钥。 第二组包括可以根据给定应用领域用于各种目的的普通密钥。 同时，DPKI确保普通公用密钥的完整性和真实性。 <br><br>  <i>注意：服务公钥/私钥对可能会公开给各个DPKI实体。</i>  <i>在某些情况下，所有实体的配对可能相同。</i>  <i>这就是为什么为每个非空交易形成签名需要两个私钥，其中一个是电子钱包密钥：只有拥有同样普通公共密钥集的电子钱包所有者才知道此密钥。</i>  <i>所有这些键都有特定的用途。</i>  <i>例如，由于签名也是使用服务私钥形成的，因此我们始终可以证明给定的交易已由注册的DPKI实体包括在分类帐中。</i>  <i>另外，由于所有者为每笔交易付费，因此可以防止任何DOS攻击和其他欺诈活动。</i> <br><br> 跟随空交易的所有交易的形成方式类似：使用两个哈希函数SHA256和RIPEMD160处理公钥（来自普通密钥对，而不是电子钱包的空交易密钥）。 这就是第三字段中数据的形成方式。 第四个字段包含其他信息（例如，有关当前状态，有效期，时间戳，密码算法的ID等的信息）。 第五个字段包含来自服务公用/专用密钥对的公用密钥。 此密钥已复制，因为它将用于验证DS。 让我们证明这种方法是必要的。 <br><br> 每个事务都包含在池中，并存储在那里直到处​​理。 但是，将事务保存在池中是有风险的，因为可以伪造事务数据。 所有者使用DS验证交易数据。 在交易字段之一中明确指定用于验证此DS的公钥，然后将其包含在分类帐中。 交易的处理方式可能使攻击者可以自行决定修改数据，使用自己的私钥进行验证，然后为交易中的DS直接验证指定相应的公钥。 如果仅使用DS来确保真实性和完整性，则可能不会注意到这种伪造。 但是，使用提供归档和持久性存储信息的附加机制扩展DS将有助于检测这种伪造。 我们要做的就是在分类帐中包含所有者的真实公钥。 让我们看看它是如何工作的。 <br><br> 假设攻击者试图伪造交易数据。 就键和DS而言，以下选项是可能的： <br><br><ol><li> 攻击者将自己的公钥放置在事务中，同时保持所有者的DS不变。 </li><li> 攻击者使用自己的私钥来形成新的DS，同时保持所有者的公钥不变。 </li><li> 攻击者使用自己的私钥构成新的DS，并将相应的公钥放入事务中。 </li></ol><br> 很明显，选项1和2没有用，因为DS的验证将始终检测到这种伪造。 唯一有意义的选项是选项3：如果攻击者使用自己的私钥创建了DS，则他们将被迫在交易中保存相应的公钥，并且此密钥将不同于所有者的公钥。 这是攻击者强制执行其伪造数据的唯一方法。 <br><br> 假设所有者具有固定的公钥/私钥对。 假设在事务中指定了公钥时，使用该对中的私钥通过DS对数据进行了身份验证。 还假设此公钥先前已包含在分类帐中，并且已经过全面认证。 然后，可以通过交易中的公钥与分类账中的公钥不匹配的事实来揭示伪造。 <br><br>  <b>让我们总结一下。</b> 在处理所有者的第一笔交易中的数据时，我们必须验证分类帐中包含的公共密钥。 为此，我们可以从分类账中读取密钥，然后将该密钥与安全范围内（相对无懈可击的区域）内所有者的真实公钥进行匹配。 如果放置的密钥经过验证并且完全持久，那么通过将其与分类账中的密钥进行匹配，也可以轻松地验证来自下一个交易的密钥。 换句话说，分类帐中的密钥用作参考。 所有者的所有其他交易将类似地处理。 <br><br> 每个交易都通过DS进行身份验证，在这里我们需要两个私钥：服务私钥和电子钱包的私钥。 基于这两个私钥，我们可以确保目标安全级别，因为服务私钥可以为其他用户所知，而电子钱包的私钥仅对普通密钥对的所有者是已知的。 我们将这种两键签名称为“合并的” DS。 <br><br> 使用两个公用密钥验证非空交易：电子钱包的密钥和服务密钥。  <i>（图7）</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5a/eh/tv/5aehtv6rf4sgqjp3jpclgc4chzs.jpeg" alt="图片"></div><br>  <i>图7.验证非空事务</i> <br><br> 验证过程包括两个基本步骤：第一步包括验证电子钱包公钥摘要，而第二步则是验证使用两个私钥形成的交易“合并” DS（即e-钱包的密钥和服务密钥）。 当DS被认证时，相应的交易经过额外的验证后将包括在分类帐中。 <br><br> 但是，出现以下问题：如何验证给定交易是否属于从空交易开始的特定交易链？ 为此，我们将验证过程更新了又一步-连接验证。 此步骤需要到目前为止尚未使用的前两个字段中的数据。 <br><br> 假设我们需要验证<i>事务＃2</i>是否真的跟在<i>事务＃3之后</i> 。 为此，我们可以使用组合的哈希方法来计算第三，第四和第五字段中数据的哈希函数值。 我们可以将来自<i>事务＃3</i>的第一个字段的数据与先前为<i>事务＃2</i>的第三，第四和第五个字段中的数据计算的组合哈希函数值进行合并。 然后使用两个哈希函数：SHA256和RIPEMD160处理所有这些值。 如果结果值与<i>事务＃2</i>的第二个字段中的数据匹配，则验证成功通过并证明连通性。 下图更详细地显示了这一点。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6n/ui/df/6nuidfi_wipspjla7qjztkojqzk.jpeg" alt="图片"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a7/e42/a2e/1a7e42a2ecbb13b06697ef8d98cfca15.jpg" alt="图片"></div><br>  <i>图8，图9.绑定验证，第二和第三笔交易示例</i> <br><br> 通常，在分类帐中形成并包括一个通知如下所示。 下图清楚显示了组成通知链的工作流程： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ql/ij/gs/qlijgsepx78xyecvyzyvryoui4i.jpeg" alt="图片"></div><br>  <i>图10.事务结构和处理</i> <br><br> 在本文中，我们将不深入探讨细节，而是回到对公用密钥分散式基础结构概念的讨论。 <br><br> 因此，由于发出请求的实体发送了注册通知的请求，该通知存储在分类帐中而不是在CA数据库中，因此DPKI的核心体系结构如下： <br><ol><li> 有效通知的分类帐（LVN） </li><li> 撤回通知的分类帐（LWN） </li><li> 暂停通知的分类帐（LSN）。 </li></ol><br><br> 有关公共密钥的信息作为哈希函数值存储在LVN / LWN / LSN中。 还要注意，当将有关普通公钥的状态信息（取款，挂起等）添加到密码的第四个字段中时，它可以是不同的分类帐或不同的链，甚至可以是作为单个分类帐一部分的单个链。数据结构作为相应的代码值。 根据各种优化标准，DPKI的体系结构实现有很多选择，例如将公钥长期存储在内存中的成本等。 <br><br> 因此，与集中式解决方案相比，DPKI可以具有相同甚至更低的架构复杂度。 <br><br> 因此，这里的主要问题是<b>哪种分类帐更适合实施该技术？</b> <br><br> 分类账的核心要求是能够形成任何类型的交易。 真实分类账最著名的例子是比特币。 但是，为比特币实现上述技术可能会遇到某些困难：现有脚本语言的局限性，缺少处理任意数据集的必要机制以及生成任意类型交易的方法等。 <br><br> 我们在ENCRY试图解决上述问题并开发了一个分类帐，我们认为该分类帐具有以下几个重要优点： <br><br><ul><li>  <b>支持几种交易类型：</b>在此分类帐中，您既可以交换资产（即进行金融交易），也可以形成任意结构的交易 </li><li> 欢迎开发人员使用<b>专有的编程语言PrismLang</b> ，该<b>语言</b>在解决各种技术问题方面非常灵活 </li><li> 用于<b>处理任意数据集</b>的已实现机制<b>。</b> </li></ul><br> 简而言之，应完成以下步骤： <br><br><ol><li> 发出请求的实体在DPKI中注册并获得电子钱包。 电子钱包的地址是应用于电子钱包公钥的哈希函数的值。 电子钱包的私钥仅由发出请求的实体知道 </li><li> 注册后，实体就可以访问服务私钥 </li><li> 实体形成一个空交易，然后使用电子钱包的私钥验证其DS </li><li> 形成非空交易时，实体必须使用两个私钥来验证其DS：电子钱包的密钥和服务密钥 </li><li> 实体将交易发送到池中 </li><li>  ENCRY网络节点从池中读取事务，然后验证事务的DS和连接 </li><li> 如果DS有效且证明了连通性，则节点将准备要添加到分类账的交易。 </li></ol><br><br> 在这里，分类帐用作分布式数据库，用于存储有关有效，撤回和暂停通知的信息。 <br><br>  <b>当然，分散化不是万能的解决方案。</b> 主要用户身份验证的核心问题仍然存在：当提出请求的实体当前由CA验证时，DPKI建议将该验证委托给社区成员并从财务上激励他们。 基于公共资源的验证技术是众所周知的。 这种验证的效率也已在实践中得到证明：贝林猫（Bellingcat）进行的几项引人注目的调查就是很好的例子。 <br><br> 但是总的来说，我们非常确定DPKI能够消除集中式PKI的许多（即使不是全部）缺点。 <br><br>  <b>随时订阅我们在Habr上的博客</b> ，我们将在此讨论我们的进一步研究和发展，并关注我们的<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Twitter，</a></b>以随时关注有关ENCRY项目的更多新闻。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN461731/">https://habr.com/ru/post/zh-CN461731/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN461721/index.html">新的聚类分析方法</a></li>
<li><a href="../zh-CN461723/index.html">了解Golang中的Context包</a></li>
<li><a href="../zh-CN461725/index.html">DataGrip 2019.2：连接管理，数据搜索，导航过滤</a></li>
<li><a href="../zh-CN461727/index.html">思科小型企业解决方案：好的网络并不一定要付出高昂的代价</a></li>
<li><a href="../zh-CN461729/index.html">使用越狱来提取数据：风险和后果</a></li>
<li><a href="../zh-CN461733/index.html">学习英语：9种美式习语</a></li>
<li><a href="../zh-CN461735/index.html">FFmpeg DXVA2硬件解码实践</a></li>
<li><a href="../zh-CN461737/index.html">我们使用JavaScript + VS代码收集现代TDD的环境</a></li>
<li><a href="../zh-CN461739/index.html">后端联合4：奥克罗什卡。 突发事件</a></li>
<li><a href="../zh-CN461741/index.html">R中类别数据的层次聚类</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>