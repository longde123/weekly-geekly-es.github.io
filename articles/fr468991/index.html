<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëµüèº üóª üï¥üèæ Personnages de sprites modulaires et leur animation ‚ñ™Ô∏è ‚õëÔ∏è ‚èØÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ce billet de blog est enti√®rement consacr√© √† mon syst√®me d'animation de personnages, il est rempli de conseils utiles et d'extraits de code. 

 Au cou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Personnages de sprites modulaires et leur animation</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468991/"> Ce billet de blog est enti√®rement consacr√© √† mon syst√®me d'animation de personnages, il est rempli de conseils utiles et d'extraits de code. <br><br>  Au cours des deux derniers mois, j'ai cr√©√© jusqu'√† 9 nouvelles actions de joueurs (des choses amusantes comme bloquer avec un bouclier, esquiver un saut et des armes), 17 nouveaux objets portables, 3 ensembles d'armures (plaque, soie et cuir) et 6 types de coiffures.  J'ai √©galement fini de cr√©er tous les outils et automatisations, donc tout est d√©j√† utilis√© dans le jeu.  Dans l'article, je dirai comment j'ai r√©ussi! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ef/52a/188/2ef52a1887cdbe639fd35d9df414c38d.gif"></div><br>  <i>J'esp√®re que ces informations sont utiles et prouvent qu'il n'est pas n√©cessaire d'√™tre un g√©nie pour cr√©er ind√©pendamment de tels outils / automatisation.</i> <br><br><h2>  Br√®ve description </h2><br>  Au d√©part, je voulais v√©rifier s'il √©tait possible de combiner des sprites superpos√©s avec des animateurs synchronis√©s pour cr√©er un personnage modulaire avec des coiffures, des √©quipements et des objets portables rempla√ßables.  Est-il possible de combiner une animation pixel dessin√©e √† la main avec un personnage vraiment personnalisable. <br><br>  Bien s√ªr, ces fonctions sont activement utilis√©es dans les jeux 3D et 2D avec des sprites pr√©-rendus ou dans les jeux 2D avec une animation squelettique, mais pour autant que je sache, il n'y a pas beaucoup de jeux qui combinent une animation cr√©√©e manuellement et des personnages modulaires (g√©n√©ralement parce que le processus s'av√®re √™tre trop monotone). <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/412/7a9/d23/4127a9d23d4d84e28671deee781495cb.gif"></div><br>  <i>J'ai d√©terr√© cet ancien GIF de mon premier mois avec Unity.</i>  <i>En fait, ce sprite modulaire a √©t√© l'une de mes premi√®res exp√©riences dans le d√©veloppement de jeux!</i> <br><br>  J'ai cr√©√© un prototype en utilisant le syst√®me d'animation Unity, puis ajout√© une chemise, une paire de pantalons, une coiffure et trois articles pour tester le concept.  Cela a n√©cessit√© 26 animations distinctes. <br><br>  √Ä ce moment-l√†, j'ai cr√©√© toute mon animation dans Photoshop et je n'ai pas pris la peine d'automatiser le processus, donc c'√©tait tr√®s ennuyeux.  Puis j'ai pens√©: "Donc, l'id√©e de base a fonctionn√©, plus tard j'ajouterai de nouvelles animations et de nouveaux √©quipements."  Il s'est av√©r√© que ¬´plus tard¬ª, c'est quelques ann√©es plus tard. <br><br>  En mars de cette ann√©e, j'ai dessin√© la conception d'une grande quantit√© d'armure (voir mon article pr√©c√©dent) et j'ai remarqu√© comment ce processus peut √™tre rendu plus pratique.  J'ai continu√© de reporter l'impl√©mentation, car m√™me avec l'automatisation, j'√©tais nerveux que rien ne fonctionnerait. <br><br>  Je m'attendais √† devoir abandonner la personnalisation du personnage et cr√©er le seul personnage principal, comme dans la plupart des jeux avec animation manuelle.  Mais j'avais un plan d'action, et il √©tait temps de v√©rifier si je pouvais vaincre ce monstre! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/88b/030/c5a/88b030c5a82c6cd801f7ce4d8b08ff6d.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddd/55f/12c/ddd55f12cb35e4fa22093cdddecd63d4.gif" width="500"></div><br>  <i>Spoiler: Il</i> est <i>av√©r√© formidable.</i>  <i>Ci-dessous, je vais r√©v√©ler mes *** secrets ***</i> <br><br><h2>  Syst√®me de sprite modulaire </h2><br><h4>  I. Connaissez vos limites </h4><br>  J'ai pass√© beaucoup d'art pr√©-test et de surveillance du temps pour comprendre combien il peut prendre un tel travail, et si oui ou non accessible pour moi un m√™me niveau de qualit√©. <br><br>  J'ai not√© toutes mes id√©es d'animation, les ai rassembl√©es dans une feuille de calcul et les ai organis√©es selon divers crit√®res, tels que l'utilit√©, la beaut√© et l'utilisation r√©p√©t√©e.  √Ä ma grande surprise, la toute premi√®re de cette liste a √©t√© l'animation en fonte de l'objet (potions, bombes, couteaux, haches, balle). <br><br>  J'ai trouv√© une partition num√©rique pour chaque animation et j'ai tout abandonn√© avec de mauvaises performances.  Je initialement pr√©vu pour cr√©er un 6 ensembles d'armure, mais vite rendu compte qu'il √©tait trop, et jet√© les trois types. <br><br>  L'aspect du suivi du temps s'est av√©r√© tr√®s important, et je recommande fortement de l'utiliser pour r√©pondre √† des questions telles que: "Combien d'ennemis puis-je me permettre de cr√©er dans le jeu?"  Apr√®s quelques essais, j'ai pu extrapoler une √©valuation assez pr√©cise.  Avec des travaux suppl√©mentaires sur les animations, j'ai continu√© √† suivre le temps et √† r√©viser mes attentes. <br><br>  <i>Je vais partager mon exemplaire du magazine pour les deux derniers mois.</i>  <i>Veuillez noter que ce temps s'ajoute √† mon travail habituel, o√π je passe 30 heures par semaine:</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://docs.google.com/spreadsheets/d/1Nbr7lujZTB4pWMsuedVcgBYS6n5V-rHrk1PxeGxr6Ck/edit?usp=sharing</a> <br><br><h4>  II.  Changer la palette pour un avenir meilleur </h4><br>  En utilisant judicieusement les couleurs de la conception de l'image-objet, vous pouvez dessiner une image-objet et cr√©er de nombreuses variations diff√©rentes en changeant la palette.  Vous pouvez modifier non seulement la couleur, mais aussi de cr√©er diff√©rents activer et d√©sactiver les √©l√©ments (par exemple, remplacer des couleurs sur la transparence). <br><br>  Chaque jeu d'armure a 3 variations, et le m√©lange de parties sup√©rieure et inf√©rieure, vous pouvez obtenir beaucoup de combinaisons.  J'ai l'intention de mettre en ≈ìuvre un syst√®me dans lequel vous pouvez collecter un ensemble d'armures pour l'apparence du personnage et un autre pour ses caract√©ristiques (comme dans Terraria). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/873/80c/0b9/87380c0b99d150828af05b1a0cf33ef6.gif"></div><br>  <i>Ce faisant, j'ai √©t√© agr√©ablement surpris par les curieuses combinaisons d√©couvertes.</i>  <i>Si vous connectez le dessus de la plaque avec un fond en soie, vous pouvez obtenir quelque chose dans le style d'un mage de guerre.</i> <br><br>  Il est pr√©f√©rable de modifier les palettes en utilisant les couleurs codant la valeur dans l'image-objet afin de pouvoir les prendre plus tard pour trouver la vraie couleur dans la palette.  Je sais que je simplifie un peu, alors voici une vid√©o pour commencer: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/u4Iz5AJa31Q" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Je ne vais pas tout expliquer en d√©tail, mais je vais plut√¥t parler des moyens de mettre en ≈ìuvre cette technique dans Unity, et de leurs avantages et inconv√©nients. <br><br><h4>  1. Rechercher la texture de chaque palette </h4><br>  C'est la meilleure strat√©gie pour cr√©er des variations d'ennemis, d'arri√®re-plans et de tout ce dont beaucoup de sprites ont la m√™me palette / mati√®re.  Diff√©rents mat√©riaux ne peuvent pas √™tre regroup√©s en lots, m√™me s'ils utilisent le m√™me sprite / atlas.  Travailler avec des textures est assez p√©nible, mais vous pouvez changer de palette en temps r√©el en rempla√ßant les mat√©riaux √† l'aide de SpriteRenderer.sharedMaterial.SetTexture ou MaterialPropertyBlock si vous avez besoin de palettes diff√©rentes pour chaque instance du mat√©riau.  Voici un exemple de fonction de fragment de shader: <br><br><pre><code class="cpp hljs">sampler2D _MainTex; sampler2D _PaletteTex; float4 _PaletteTex_TexelSize; <span class="hljs-function"><span class="hljs-function">half4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v2f input)</span></span></span><span class="hljs-function"> : SV_TARGET </span></span>{ half4 lookup = tex2D(_MainTex, input.uv); half4 color = tex2D(_PaletteTex, half2(lookup.r * (_PaletteTex_TexelSize.x / <span class="hljs-number"><span class="hljs-number">0.00390625f</span></span>), <span class="hljs-number"><span class="hljs-number">0.5</span></span>)); color.a *= lookup.a; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> color * input.color; }</code> </pre> <br><h4>  2. Tableau de couleurs </h4><br>  J'ai d√©cid√© de prendre cette d√©cision parce que je devais remplacer les palettes √† chaque fois que l'apparence du personnage change (par exemple, lors de la mise en place d'objets) et cr√©er des palettes dynamiquement (pour afficher les couleurs de cheveux et de peau choisies par le joueur).  Il me semblait que lors de l'ex√©cution et dans l'√©diteur √† cet effet est beaucoup plus facile de travailler avec des tableaux. <br><br>  Code: <br><br><pre> <code class="cpp hljs">sampler2D _MainTex; half4 _Colors[<span class="hljs-number"><span class="hljs-number">32</span></span>]; <span class="hljs-function"><span class="hljs-function">half4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v2f input)</span></span></span><span class="hljs-function"> : SV_TARGET </span></span>{ half4 lookup = tex2D(_MainTex, input.uv); half4 color = _Colors[round(lookup.r * <span class="hljs-number"><span class="hljs-number">255</span></span>)]; color.a *= lookup.a; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> color * input.color; }</code> ); <code class="cpp hljs">sampler2D _MainTex; half4 _Colors[<span class="hljs-number"><span class="hljs-number">32</span></span>]; <span class="hljs-function"><span class="hljs-function">half4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v2f input)</span></span></span><span class="hljs-function"> : SV_TARGET </span></span>{ half4 lookup = tex2D(_MainTex, input.uv); half4 color = _Colors[round(lookup.r * <span class="hljs-number"><span class="hljs-number">255</span></span>)]; color.a *= lookup.a; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> color * input.color; }</code> </pre> <br>  J'ai pr√©sent√© mes palettes comme un type ScriptableObject et utilis√© l'outil MonoBehaviour pour les modifier.  Ayant longtemps travaill√© sur l'√©dition de palettes dans le processus de cr√©ation d'animations dans Aseprite, j'ai r√©alis√© de quels outils j'avais besoin et j'ai √©crit ces scripts en cons√©quence.  Si vous souhaitez √©crire votre propre outil pour √©diter des palettes, voici quelques fonctions que je recommande vivement d'impl√©menter: <br><br>  - Mise √† jour des palettes sur divers mat√©riaux lors de l'√©dition des couleurs pour afficher les changements en temps r√©el. <br><br>  - Attribuer des noms et changer l'ordre des couleurs dans la palette (utilisez le champ pour stocker l'index des couleurs, pas son ordre dans le tableau). <br><br>  - S√©lectionnez et modifiez plusieurs couleurs √† la fois.  (Astuce: vous pouvez copier et coller les champs Couleur dans Unity: il suffit de cliquer sur une couleur, de copier, de cliquer sur une autre couleur, de coller - maintenant ce sont les m√™mes!) <br><br>  - Appliquer la couleur de superposition √† toute la palette <br><br>  - Palette d'enregistrement en texture <br><br><h4>  3. Recherche de texture uniforme pour toutes les palettes </h4><br>  Si vous souhaitez passer des palettes √† la vol√©e, mais en m√™me temps, vous avez besoin d'un traitement par lots pour r√©duire le nombre d'appels de tirage, vous pouvez utiliser cette technique.  Il peut √™tre utile pour les plates-formes mobiles, mais son utilisation est assez peu pratique. <br><br>  Tout d'abord, vous devrez regrouper toutes les palettes dans une grande texture.  Ensuite, vous utilisez la couleur sp√©cifi√©e dans le composant SpriteRenderer (couleur vertex AKA) pour d√©terminer la ligne √† lire de la texture de la palette dans le shader.  Autrement dit, la palette de ce sprite est contr√¥l√©e via SpriteRenderer.color.  couleur sommet - c'est la seule SpriteRenderer de propri√©t√©, qui peut √™tre modifi√© sans perturber batchinga (en supposant que tous les mat√©riaux sont les m√™mes). <br><br>  Dans la plupart des cas, il est pr√©f√©rable d'utiliser le canal alpha pour contr√¥ler l'index, car vous n'aurez probablement pas besoin d'un tas de sprites avec une transparence diff√©rente. <br><br>  Code: <br><br><pre> <code class="cpp hljs">sampler2D _MainTex; sampler2D _PaletteTex; float4 _PaletteTex_TexelSize; <span class="hljs-function"><span class="hljs-function">half4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v2f input)</span></span></span><span class="hljs-function"> : SV_TARGET </span></span>{ half4 lookup = tex2D(_MainTex, input.uv); half2 paletteUV = half2( lookup.r * _(PaletteTex_TexelSize.x / <span class="hljs-number"><span class="hljs-number">0.00390625f</span></span>), input.color.a * _(PaletteTex_TexelSize.y / <span class="hljs-number"><span class="hljs-number">0.00390625f</span></span>) ) half4 color = tex2D(_PaletteTex, paletteUV); color.a *= lookup.a; color.rgb *= input.color.rgb; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> color; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/47c/f90/895/47cf908951a0ba9f8f65a57711a5c85c.gif"></div><br>  <i>Les merveilles du remplacement des palettes et des couches de sprite.</i>  <i>Tant de combinaisons.</i> <br><br><h4>  III.  Automatisez tout et utilisez les bons outils. </h4><br>  Pour impl√©menter cette fonction, l'automatisation √©tait absolument n√©cessaire, car en cons√©quence j'ai obtenu environ 300 animations et des milliers de sprites. <br><br>  Ma premi√®re √©tape a √©t√© de cr√©er un exportateur pour Aseprite afin de g√©rer mon sch√©ma de couche de sprite fou en utilisant une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">interface de ligne de commande</a> pratique.  Il est juste un script perl, qui contourne toutes les couches et les √©tiquettes dans mon dossier et l'image de Aseprite dans un certains noms de structure des r√©pertoires et fichiers, afin que je puisse les lire plus tard. <br><br>  Ensuite, je l'ai √©crit √† l'unit√© importateur.  Aseprite affiche un fichier JSON pratique avec des donn√©es d'image, vous pouvez donc cr√©er des ressources d'animation par programmation.  Traitement Aseprite JSON et √©crire ce type de donn√©es se sont r√©v√©l√©es √™tre assez fastidieux, donc je les amener ici.  Vous pouvez facilement les charger dans Unity en utilisant JsonUtility.FromJson &lt;AespriteData&gt;, n'oubliez pas d'ex√©cuter Aseprite avec l'option --format 'json-array'. <br><br>  Code: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">System.Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> AespriteData { [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Size { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> h; } [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Position { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> h; } [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Frame { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> filename; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Position frame; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> rotated; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> trimmed; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Position spriteSourceSize; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Size sourceSize; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> duration; } [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Metadata { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> app; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> version; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> format; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Size size; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> scale; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Frame[] frames; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Metadata meta; }</code> du <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">System.Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> AespriteData { [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Size { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> h; } [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Position { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> h; } [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Frame { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> filename; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Position frame; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> rotated; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> trimmed; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Position spriteSourceSize; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Size sourceSize; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> duration; } [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Metadata { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> app; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> version; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> format; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Size size; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> scale; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Frame[] frames; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Metadata meta; }</code> </pre> <br>  C√¥t√© Unity, j'ai eu de s√©rieux probl√®mes √† deux endroits: charger / d√©couper une feuille de sprite et cr√©er un clip d'animation.  Un exemple clair m'aiderait beaucoup, alors voici un extrait de code de mon importateur pour que vous ne souffriez pas autant: <br><br>  Code: <br><br><pre> <code class="cs hljs">TextureImporter textureImporter = AssetImporter.GetAtPath(spritePath) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> TextureImporter; textureImporter.spriteImportMode = SpriteImportMode.Multiple; SpriteMetaData[] spriteMetaData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpriteMetaData[aespriteData.frames.Length]; <span class="hljs-comment"><span class="hljs-comment">// Slice the spritesheet according to the aesprite data. for (int i = 0; i &lt; aespriteData.frames.Length; i++) { AespriteData.Position spritePosition = aespriteData.frames[i].frame; spriteMetaData[i].name = aespriteData.frames[i].filename; spriteMetaData[i].rect = new Rect(spritePosition.x, spritePosition.y, spritePosition.w, spritePosition.h); spriteMetaData[i].alignment = (int)SpriteAlignment.Custom; // Same as "Pivot" in Sprite Editor. spriteMetaData[i].pivot = new Vector2(0.5f, 0f); // Same as "Custom Pivot" in Sprite Editor. Ignored if alignment isn't "Custom". } textureImporter.spritesheet = spriteMetaData; AssetDatabase.ImportAsset(spritePath, ImportAssetOptions.ForceUpdate); Object[] assets = AssetDatabase.LoadAllAssetsAtPath(spritePath); // The first element in this array is actually a Texture2D (ie the sheet itself). for (int i = 1; i &lt; assets.Length; i++) { sprites[i - 1] = assets[i] as Sprite; } // Create the animation. AnimationClip clip = new AnimationClip(); clip.frameRate = 40f; float frameLength = 1f / clip.frameRate; ObjectReferenceKeyframe[] keyframes = new ObjectReferenceKeyframe[aespriteData.frames.Length + 1]; // One extra keyframe is required at the end to express the last frame's duration. float time = 0f; for (int i = 0; i &lt; keyframes.Length; i++) { bool lastFrame = i == keyframes.Length - 1; ObjectReferenceKeyframe keyframe = new ObjectReferenceKeyframe(); keyframe.value = sprites[lastFrame ? i - 1 : i]; keyframe.time = time - (lastFrame ? frameLength : 0f); keyframes[i] = keyframe; time += lastFrame ? 0f : aespriteData.frames[i].duration / 1000f; } EditorCurveBinding binding = new EditorCurveBinding(); binding.type = typeof(SpriteRenderer); binding.path = ""; binding.propertyName = "m_Sprite"; AnimationUtility.SetObjectReferenceCurve(clip, binding, keyframes); AssetDatabase.CreateAsset(clip, "Assets/Animation/" + name + ".anim"); AssetDatabase.SaveAssets();</span></span></code> Sprite Editor. <code class="cs hljs">TextureImporter textureImporter = AssetImporter.GetAtPath(spritePath) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> TextureImporter; textureImporter.spriteImportMode = SpriteImportMode.Multiple; SpriteMetaData[] spriteMetaData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpriteMetaData[aespriteData.frames.Length]; <span class="hljs-comment"><span class="hljs-comment">// Slice the spritesheet according to the aesprite data. for (int i = 0; i &lt; aespriteData.frames.Length; i++) { AespriteData.Position spritePosition = aespriteData.frames[i].frame; spriteMetaData[i].name = aespriteData.frames[i].filename; spriteMetaData[i].rect = new Rect(spritePosition.x, spritePosition.y, spritePosition.w, spritePosition.h); spriteMetaData[i].alignment = (int)SpriteAlignment.Custom; // Same as "Pivot" in Sprite Editor. spriteMetaData[i].pivot = new Vector2(0.5f, 0f); // Same as "Custom Pivot" in Sprite Editor. Ignored if alignment isn't "Custom". } textureImporter.spritesheet = spriteMetaData; AssetDatabase.ImportAsset(spritePath, ImportAssetOptions.ForceUpdate); Object[] assets = AssetDatabase.LoadAllAssetsAtPath(spritePath); // The first element in this array is actually a Texture2D (ie the sheet itself). for (int i = 1; i &lt; assets.Length; i++) { sprites[i - 1] = assets[i] as Sprite; } // Create the animation. AnimationClip clip = new AnimationClip(); clip.frameRate = 40f; float frameLength = 1f / clip.frameRate; ObjectReferenceKeyframe[] keyframes = new ObjectReferenceKeyframe[aespriteData.frames.Length + 1]; // One extra keyframe is required at the end to express the last frame's duration. float time = 0f; for (int i = 0; i &lt; keyframes.Length; i++) { bool lastFrame = i == keyframes.Length - 1; ObjectReferenceKeyframe keyframe = new ObjectReferenceKeyframe(); keyframe.value = sprites[lastFrame ? i - 1 : i]; keyframe.time = time - (lastFrame ? frameLength : 0f); keyframes[i] = keyframe; time += lastFrame ? 0f : aespriteData.frames[i].duration / 1000f; } EditorCurveBinding binding = new EditorCurveBinding(); binding.type = typeof(SpriteRenderer); binding.path = ""; binding.propertyName = "m_Sprite"; AnimationUtility.SetObjectReferenceCurve(clip, binding, keyframes); AssetDatabase.CreateAsset(clip, "Assets/Animation/" + name + ".anim"); AssetDatabase.SaveAssets();</span></span></code> l' <code class="cs hljs">TextureImporter textureImporter = AssetImporter.GetAtPath(spritePath) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> TextureImporter; textureImporter.spriteImportMode = SpriteImportMode.Multiple; SpriteMetaData[] spriteMetaData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpriteMetaData[aespriteData.frames.Length]; <span class="hljs-comment"><span class="hljs-comment">// Slice the spritesheet according to the aesprite data. for (int i = 0; i &lt; aespriteData.frames.Length; i++) { AespriteData.Position spritePosition = aespriteData.frames[i].frame; spriteMetaData[i].name = aespriteData.frames[i].filename; spriteMetaData[i].rect = new Rect(spritePosition.x, spritePosition.y, spritePosition.w, spritePosition.h); spriteMetaData[i].alignment = (int)SpriteAlignment.Custom; // Same as "Pivot" in Sprite Editor. spriteMetaData[i].pivot = new Vector2(0.5f, 0f); // Same as "Custom Pivot" in Sprite Editor. Ignored if alignment isn't "Custom". } textureImporter.spritesheet = spriteMetaData; AssetDatabase.ImportAsset(spritePath, ImportAssetOptions.ForceUpdate); Object[] assets = AssetDatabase.LoadAllAssetsAtPath(spritePath); // The first element in this array is actually a Texture2D (ie the sheet itself). for (int i = 1; i &lt; assets.Length; i++) { sprites[i - 1] = assets[i] as Sprite; } // Create the animation. AnimationClip clip = new AnimationClip(); clip.frameRate = 40f; float frameLength = 1f / clip.frameRate; ObjectReferenceKeyframe[] keyframes = new ObjectReferenceKeyframe[aespriteData.frames.Length + 1]; // One extra keyframe is required at the end to express the last frame's duration. float time = 0f; for (int i = 0; i &lt; keyframes.Length; i++) { bool lastFrame = i == keyframes.Length - 1; ObjectReferenceKeyframe keyframe = new ObjectReferenceKeyframe(); keyframe.value = sprites[lastFrame ? i - 1 : i]; keyframe.time = time - (lastFrame ? frameLength : 0f); keyframes[i] = keyframe; time += lastFrame ? 0f : aespriteData.frames[i].duration / 1000f; } EditorCurveBinding binding = new EditorCurveBinding(); binding.type = typeof(SpriteRenderer); binding.path = ""; binding.propertyName = "m_Sprite"; AnimationUtility.SetObjectReferenceCurve(clip, binding, keyframes); AssetDatabase.CreateAsset(clip, "Assets/Animation/" + name + ".anim"); AssetDatabase.SaveAssets();</span></span></code> sur <code class="cs hljs">TextureImporter textureImporter = AssetImporter.GetAtPath(spritePath) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> TextureImporter; textureImporter.spriteImportMode = SpriteImportMode.Multiple; SpriteMetaData[] spriteMetaData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpriteMetaData[aespriteData.frames.Length]; <span class="hljs-comment"><span class="hljs-comment">// Slice the spritesheet according to the aesprite data. for (int i = 0; i &lt; aespriteData.frames.Length; i++) { AespriteData.Position spritePosition = aespriteData.frames[i].frame; spriteMetaData[i].name = aespriteData.frames[i].filename; spriteMetaData[i].rect = new Rect(spritePosition.x, spritePosition.y, spritePosition.w, spritePosition.h); spriteMetaData[i].alignment = (int)SpriteAlignment.Custom; // Same as "Pivot" in Sprite Editor. spriteMetaData[i].pivot = new Vector2(0.5f, 0f); // Same as "Custom Pivot" in Sprite Editor. Ignored if alignment isn't "Custom". } textureImporter.spritesheet = spriteMetaData; AssetDatabase.ImportAsset(spritePath, ImportAssetOptions.ForceUpdate); Object[] assets = AssetDatabase.LoadAllAssetsAtPath(spritePath); // The first element in this array is actually a Texture2D (ie the sheet itself). for (int i = 1; i &lt; assets.Length; i++) { sprites[i - 1] = assets[i] as Sprite; } // Create the animation. AnimationClip clip = new AnimationClip(); clip.frameRate = 40f; float frameLength = 1f / clip.frameRate; ObjectReferenceKeyframe[] keyframes = new ObjectReferenceKeyframe[aespriteData.frames.Length + 1]; // One extra keyframe is required at the end to express the last frame's duration. float time = 0f; for (int i = 0; i &lt; keyframes.Length; i++) { bool lastFrame = i == keyframes.Length - 1; ObjectReferenceKeyframe keyframe = new ObjectReferenceKeyframe(); keyframe.value = sprites[lastFrame ? i - 1 : i]; keyframe.time = time - (lastFrame ? frameLength : 0f); keyframes[i] = keyframe; time += lastFrame ? 0f : aespriteData.frames[i].duration / 1000f; } EditorCurveBinding binding = new EditorCurveBinding(); binding.type = typeof(SpriteRenderer); binding.path = ""; binding.propertyName = "m_Sprite"; AnimationUtility.SetObjectReferenceCurve(clip, binding, keyframes); AssetDatabase.CreateAsset(clip, "Assets/Animation/" + name + ".anim"); AssetDatabase.SaveAssets();</span></span></code> . <code class="cs hljs">TextureImporter textureImporter = AssetImporter.GetAtPath(spritePath) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> TextureImporter; textureImporter.spriteImportMode = SpriteImportMode.Multiple; SpriteMetaData[] spriteMetaData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpriteMetaData[aespriteData.frames.Length]; <span class="hljs-comment"><span class="hljs-comment">// Slice the spritesheet according to the aesprite data. for (int i = 0; i &lt; aespriteData.frames.Length; i++) { AespriteData.Position spritePosition = aespriteData.frames[i].frame; spriteMetaData[i].name = aespriteData.frames[i].filename; spriteMetaData[i].rect = new Rect(spritePosition.x, spritePosition.y, spritePosition.w, spritePosition.h); spriteMetaData[i].alignment = (int)SpriteAlignment.Custom; // Same as "Pivot" in Sprite Editor. spriteMetaData[i].pivot = new Vector2(0.5f, 0f); // Same as "Custom Pivot" in Sprite Editor. Ignored if alignment isn't "Custom". } textureImporter.spritesheet = spriteMetaData; AssetDatabase.ImportAsset(spritePath, ImportAssetOptions.ForceUpdate); Object[] assets = AssetDatabase.LoadAllAssetsAtPath(spritePath); // The first element in this array is actually a Texture2D (ie the sheet itself). for (int i = 1; i &lt; assets.Length; i++) { sprites[i - 1] = assets[i] as Sprite; } // Create the animation. AnimationClip clip = new AnimationClip(); clip.frameRate = 40f; float frameLength = 1f / clip.frameRate; ObjectReferenceKeyframe[] keyframes = new ObjectReferenceKeyframe[aespriteData.frames.Length + 1]; // One extra keyframe is required at the end to express the last frame's duration. float time = 0f; for (int i = 0; i &lt; keyframes.Length; i++) { bool lastFrame = i == keyframes.Length - 1; ObjectReferenceKeyframe keyframe = new ObjectReferenceKeyframe(); keyframe.value = sprites[lastFrame ? i - 1 : i]; keyframe.time = time - (lastFrame ? frameLength : 0f); keyframes[i] = keyframe; time += lastFrame ? 0f : aespriteData.frames[i].duration / 1000f; } EditorCurveBinding binding = new EditorCurveBinding(); binding.type = typeof(SpriteRenderer); binding.path = ""; binding.propertyName = "m_Sprite"; AnimationUtility.SetObjectReferenceCurve(clip, binding, keyframes); AssetDatabase.CreateAsset(clip, "Assets/Animation/" + name + ".anim"); AssetDatabase.SaveAssets();</span></span></code> </pre> <br>  Si vous ne l‚Äôavez pas encore fait, croyez-moi, il est tr√®s facile de commencer √† cr√©er vos propres outils.  L'astuce la plus simple consiste √† placer un GameObject dans la sc√®ne avec le MonoBehaviour attach√©, qui a l'attribut [ExecuteInEditMode].  Ajoutez un bouton et vous √™tes pr√™t pour la bataille!  N'oubliez pas que vos outils personnels n'ont pas besoin d'√™tre beaux, ils peuvent √™tre purement utilitaires. <br><br>  Code: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">ExecuteInEditMode</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyCoolTool</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> button; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (button) { button = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; DoThing(); } } }</code> √† <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">ExecuteInEditMode</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyCoolTool</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> button; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (button) { button = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; DoThing(); } } }</code> </pre> <br>  Lorsque vous travaillez avec des images-objets, il est assez facile d'automatiser des t√¢ches standard (par exemple, cr√©er des textures de palette ou remplacer des couleurs par lots dans plusieurs fichiers d'images-objets).  Voici un exemple dont apprendre √† changer leurs sprites. <br><br>  Code: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = <span class="hljs-string"><span class="hljs-string">"Assets/Whatever/Sprite.png"</span></span>; Texture2D texture = AssetDatabase.LoadAssetAtPath&lt;Texture2D&gt;(path); TextureImporter textureImporter = AssetImporter.GetAtPath(path) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> TextureImporter; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!textureImporter.isReadable) { textureImporter.isReadable = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; AssetDatabase.ImportAsset(path, ImportAssetOptions.ForceUpdate); } Color[] pixels = texture.GetPixels(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, texture.width, texture.height); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; pixels.Length; i++) { <span class="hljs-comment"><span class="hljs-comment">// Do something with the pixels, eg replace one color with another. } texture.SetPixels(pixels); texture.Apply(); textureImporter.isReadable = false; // Make sure textures are marked as un-readable when you're done. There's a performance cost to using readable textures in your project that you should avoid unless you plan to change a sprite at runtime. byte[] bytes = ImageConversion.EncodeToPNG(texture); File.WriteAllBytes(Application.dataPath + path.Substring(6), bytes); AssetDatabase.ImportAsset(path, ImportAssetOptions.ForceUpdate);</span></span></code> Sprite.png"; <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = <span class="hljs-string"><span class="hljs-string">"Assets/Whatever/Sprite.png"</span></span>; Texture2D texture = AssetDatabase.LoadAssetAtPath&lt;Texture2D&gt;(path); TextureImporter textureImporter = AssetImporter.GetAtPath(path) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> TextureImporter; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!textureImporter.isReadable) { textureImporter.isReadable = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; AssetDatabase.ImportAsset(path, ImportAssetOptions.ForceUpdate); } Color[] pixels = texture.GetPixels(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, texture.width, texture.height); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; pixels.Length; i++) { <span class="hljs-comment"><span class="hljs-comment">// Do something with the pixels, eg replace one color with another. } texture.SetPixels(pixels); texture.Apply(); textureImporter.isReadable = false; // Make sure textures are marked as un-readable when you're done. There's a performance cost to using readable textures in your project that you should avoid unless you plan to change a sprite at runtime. byte[] bytes = ImageConversion.EncodeToPNG(texture); File.WriteAllBytes(Application.dataPath + path.Substring(6), bytes); AssetDatabase.ImportAsset(path, ImportAssetOptions.ForceUpdate);</span></span></code> </pre> <br><h4>  Comment j'ai d√©pass√© les opportunit√©s Mecanim: Plainte </h4><br>  Au fil du temps, le prototype de syst√®me de sprite modulaire que j'ai cr√©√© √† l'aide de Mecanim est devenu le plus gros probl√®me lors de la mise √† niveau d'Unity, car l'API changeait constamment et √©tait mal document√©e.  Dans le cas d'une machine √† √©tats simple, il serait sage de pouvoir interroger le statut de chaque clip ou de modifier les clips au moment de l'ex√©cution.  Mais non!  Pour des raisons de productivit√© L'unit√© fait cuire des clips dans leurs √©tats et nous oblige √† utiliser pour leurs quarts de travail du syst√®me de remplacements maladroit. <br><br>  Mecanim lui-m√™me n'est pas un si mauvais syst√®me, mais il me semble qu'il ne parvient pas √† r√©aliser sa principale caract√©ristique d√©clar√©e - la simplicit√©.  L'id√©e des d√©veloppeurs √©tait de remplacer ce qui semblait compliqu√© et douloureux (script) par quelque chose de simple (machine √† √©tats visuels).  Cependant: <br><br>  - Toute machine √† √©tats finis non triviale se transforme rapidement en un r√©seau sauvage de n≈ìuds et de connexions, dont la logique est dispers√©e sur diff√©rentes couches. <br><br>  - Les cas d'utilisation simples sont entrav√©s par des exigences syst√®me g√©n√©ralis√©es.  Pour jouer une ou deux animations, vous devez cr√©er un nouveau contr√¥leur et affecter des √©tats / transitions.  Bien s√ªr, il y a un gaspillage excessif de ressources. <br><br>  - C'est dr√¥le qu'en cons√©quence, vous devez encore √©crire du code, car pour que la machine d'√©tat fasse quelque chose d'int√©ressant, vous avez besoin d'un script qui appelle Animator.SetBool et des m√©thodes similaires. <br><br>  - Pour une utilisation multiple de la machine d'√©tat avec d'autres clips, vous devez la dupliquer et remplacer les clips manuellement.  √Ä l'avenir, vous devrez apporter des modifications √† plusieurs endroits. <br><br>  - Si vous souhaitez modifier ce qui est dans un √©tat au moment de l'ex√©cution, vous rencontrez des probl√®mes.  La solution est soit une mauvaise API, soit un graphe fou avec un n≈ìud pour chaque animation possible. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/8VgQ5PpTqjc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>L'histoire de la fa√ßon dont les d√©veloppeurs Firewatch sont entr√©s dans l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">enfer des scripts visuels</a> .</i>  <i>Le plus dr√¥le, c'est que lorsque le locuteur montre les exemples les plus simples, ils ont toujours l'air fous.</i>  <i>Les spectateurs g√©missent litt√©ralement √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">12:41</a> .</i>  <i>Ajoutez les √©normes co√ªts de maintenance, et vous comprendrez pourquoi je ne fortement pas comme ce syst√®me.</i> <br><br>  Beaucoup de ces probl√®mes ne sont m√™me pas la faute des d√©veloppeurs Mecanim, mais simplement le r√©sultat naturel d'id√©es incompatibles: vous ne pouvez pas cr√©er un syst√®me commun et en m√™me temps simple, et la description de la logique √† l'aide d'images est plus difficile que de simples mots / symboles (quelqu'un se souvient-il des organigrammes UML?) .  J'ai rappel√© un fragment du rapport de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Zack McClendon √† Practice NYC 2018</a> , et si vous avez le temps, je vous recommande de regarder l'int√©gralit√© de la vid√©o! <br><br>  Cependant, je l'ai compris.  Les scripts visuels sont toujours censur√©s par des nerds agressifs "√©crivez votre propre moteur" qui ne comprennent pas les besoins de l'artiste.  De plus, on ne peut nier que la plupart du code ressemble √† un jargon technique incompr√©hensible. <br><br>  Si vous √™tes d√©j√† un petit programmeur et faites des jeux avec des sprites, alors vous devrez peut-√™tre r√©fl√©chir √† deux fois.  Quand j'ai commenc√©, j'√©tais s√ªr que je ne pourrais jamais √©crire quelque chose li√© au moteur mieux que les d√©veloppeurs Unity. <br><br>  Et tu sais quoi?  Il s'est av√©r√© que l'animateur de sprite n'est qu'un script qui change le sprite apr√®s un nombre de secondes sp√©cifi√©.  Quoi qu'il en soit, je devais encore √©crire le mien.  Depuis lors, j'ai ajout√© des √©v√©nements d'animation et d'autres fonctions √† mon projet sp√©cifique, mais la version de base que j'ai √©crite en une demi-journ√©e couvre 90% de mes besoins.  Il ne comprend que 120 lignes et peut √™tre t√©l√©charg√© gratuitement √† partir d'ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://pastebin.com/m9Lfmd94</a> .  Merci d'avoir lu mon article.  A tr√®s bient√¥t! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr468991/">https://habr.com/ru/post/fr468991/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr468967/index.html">"Technologie" d'obtention d'√©quations de dynamique de TAU. Et pourquoi l‚Äôidentification du syst√®me est nul, et les r√®gles de la ¬´physique honn√™te¬ª</a></li>
<li><a href="../fr468969/index.html">Cr√©ez des utilisateurs Google √† partir de PowerShell via l'API</a></li>
<li><a href="../fr468971/index.html">√âcriture en Java pour Nintendo DS</a></li>
<li><a href="../fr468973/index.html">R√©seau de neurones pour classer les images satellites √† l'aide de Tensorflow en Python</a></li>
<li><a href="../fr468989/index.html">March√© de l'UEBA meurt - Longue vie √† l'UEBA</a></li>
<li><a href="../fr468993/index.html">Oculus Quest se connecte √† un PC et voit les mains</a></li>
<li><a href="../fr468995/index.html">Politique d'ouverture: comment les utilisateurs influencent le projet</a></li>
<li><a href="../fr468997/index.html">Le mentorat - un incontournable ou un bon bonus?</a></li>
<li><a href="../fr468999/index.html">Quels pays ont l'Internet le plus ¬´lent¬ª et qui corrige la situation dans les r√©gions difficiles d'acc√®s</a></li>
<li><a href="../fr469001/index.html">Comment faire cuire la bouillie √† partir de microservices</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>