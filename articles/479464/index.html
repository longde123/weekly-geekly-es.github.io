<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-143967986-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-143967986-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçüî¨ üë©üèΩ‚Äçü§ù‚Äçüë®üèº üêì Pipes & Filters. Example application and implementation using Spring üéΩ üö¥üèº üëµüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article will discuss the use of the Pipes & Filters pattern. 


 First, we will analyze an example of a function, which we will rewrite later usi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pipes & Filters. Example application and implementation using Spring</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479464/"><p>  This article will discuss the use of the Pipes &amp; Filters pattern. </p><br><p> First, we will analyze an example of a function, which we will rewrite later using the above-mentioned pattern.  Changes in the code will occur gradually and each time we will create a workable version until we dwell on the solution using DI (in this Spring example). </p><br><p>  Thus, we will create several solutions, providing the opportunity to use any. <br>  In the end, we compare the initial and final implementations, look at examples of application in real projects and summarize. </p><a name="habracut"></a><br><h2 id="zadacha">  Task </h2><br><p>  Suppose we have a bunch of clothes that we get from drying and which we now need to move to the closet.  It turns out that the data (clothes) come from a separate service and the task is to provide this data to the client in the right form (in a closet from which he can get clothes). </p><br><p>  In most cases, you cannot use the received data in the form in which it arrives to us.  This data needs to be checked, transformed, sorted, etc. <br>  Suppose a customer demands that clothes should be ironed if they are mint. </p><br><p> Then for the first time we create a <code>Modifier</code> , in which we prescribe the changes: </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modifier</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;&gt; modify(List&lt;&gt; ){ (); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (List&lt;&gt; ) { .stream() .filter(::) .forEach(o -&gt; { <span class="hljs-comment"><span class="hljs-comment">// }); } }</span></span></code> </pre> <br><p>  At this stage, everything is simple and clear.  Let's write a test that checks that all wrinkled clothes have been ironed. </p><br><p>  But over time, new requirements appear and every time the functionality of the <code>Modifier</code> class expands: </p><br><ul><li>  Do not put dirty laundry in the closet. </li><li>  Shirts, jackets and trousers should hang on the shoulders. </li><li>  Leaky socks need to be sewn up first </li><li>  ... </li></ul><br><p>  The sequence of changes is also important.  For example, you can not first hang clothes on their shoulders, and then iron. </p><br><p>  Thus, at some point, <code>Modifier</code> can take the following form: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modifier</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Predicate&lt;&gt; ___ = ((Predicate&lt;&gt;).class::isInstance) .or(.class::isInstance) .or(.class::isInstance) ; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;&gt; modify(List&lt;&gt; ){ (); (); (); (); <span class="hljs-comment"><span class="hljs-comment">//   return ; } private void (List&lt;&gt; ) { .stream() .filter(.class::isInstance) .map(.class::cast) .filter(::) .forEach(o -&gt; { // }); } private void (List&lt;&gt; ) { .stream() .filter(___) .forEach(o -&gt; { //   }); } private void (List&lt;&gt; ) { .removeIf(::); } private void (List&lt;&gt; ) { .stream() .filter(::) .forEach(o -&gt; { // }); } //  }</span></span></code> </pre> <br><p>  Correspondingly, the tests have become more complicated, which now must at least check each step individually. </p><br><p>  And when a new requirement arrives, looking at the code, we decide that the time has come for Refactoring. </p><br><h2 id="refactoring">  Refactoring </h2><br><p>  The first thing that catches your eye is the frequent busting of all the clothes.  So the first step, we move everything in one cycle, and also transfer the cleanliness check to the beginning of the cycle: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modifier</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Predicate&lt;&gt; ___ = ((Predicate&lt;&gt;).class::isInstance) .or(.class::isInstance) .or(.class::isInstance) ; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;&gt; modify(List&lt;&gt; ){ List&lt;&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o : ){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(o.()){ <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } result.add(o); (o); (o); (o); <span class="hljs-comment"><span class="hljs-comment">//   } return result; } private void ( ) { if( instanceof ){ // ()  } } private void ( ) { if(___.test()){ //   } } private void ( ) { if(.()){ // } } //  }</span></span></code> </pre> <br><p>  Now, the processing time for clothes is reduced, but the code is still too long for one class and for the body of the cycle.  Let's try to shorten the body of the cycle first. </p><br><ul><li><p>  After checking for cleanliness, you can make all the calls in a separate <code>modify( )</code> method <code>modify( )</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;&gt; modify(List&lt;&gt; ){ List&lt;&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o : ){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(o.()){ <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } result.add(o); modify(o); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">modify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( o)</span></span></span><span class="hljs-function"> </span></span>{ (o); (o); (o); <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre> <br></li><li><p>  You can combine all the calls into one <code>Consumer</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Consumer&lt;&gt; modification = ((Consumer&lt;&gt;) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::) .andThen(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::) .andThen(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::); <span class="hljs-comment"><span class="hljs-comment">//   public List&lt;&gt; modify(List&lt;&gt; ){ return .stream() .filter(o -&gt; !o.()) .peek(modification) .collect(Collectors.toList()); }</span></span></code> </pre> <br><blockquote>  Blunt: peek <br>  I used peek for short.  Sonar will say that such a code should not be done, because  Javadoc tells peek that the method exists primarily for debug.  But if you rewrite it on map: .map (o -&gt; {modification.accept (o); return o;}), then IDEA will say that it is better to use peek </blockquote><br></li></ul><br><blockquote>  Stumbling: Consumer <br>  An example with Consumer (and subsequent with Function) is given to show the capabilities of the language. </blockquote><p>  Now the body of the cycle has become shorter, but so far the class itself is still too large and contains too much information (knowledge of all steps). </p><br><p>  Let's try to solve this problem using already established programming patterns.  In this case, we will use <code>Pipes &amp; Filters</code> . </p><br><h2 id="pipes--filters">  Pipes &amp; filters </h2><br><p>  <a href="https://docs.microsoft.com/ru-ru/azure/architecture/patterns/pipes-and-filters">The channel and filter template</a> <a href="https://medium.com/nuances-of-programming/%25D0%25BA%25D1%2580%25D0%25B0%25D1%2582%25D0%25BA%25D0%25B8%25D0%25B9-%25D0%25BE%25D0%25B1%25D0%25B7%25D0%25BE%25D1%2580-10-%25D0%25BF%25D0%25BE%25D0%25BF%25D1%2583%25D0%25BB%25D1%258F%25D1%2580%25D0%25BD%25D1%258B%25D1%2585-%25D0%25B0%25D1%2580%25D1%2585%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25BD%25D1%258B%25D1%2585-%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD%25D0%25BE%25D0%25B2-%25D0%25BF%25D1%2580%25D0%25B8%25D0%25BB%25D0%25BE%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B9-81647be5c46f">describes an approach</a> in which incoming data goes through several processing steps. </p><br><p>  Let's try to apply this approach to our code. </p><br><h3 id="shag-1">  Step 1 </h3><br><p>  In fact, our code is already close to this pattern.  The data obtained go through several independent steps.  So far, each method is a filter, and <code>modify</code> itself describes the channel, first filtering out all dirty clothes. </p><br><p>  Now we will transfer each step to a separate class and see what we get: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modifier</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span>  ; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span>  ; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span>  ; <span class="hljs-comment"><span class="hljs-comment">//  public Modifier( ,  ,   //  ) { this. = ; this. = ; this. = ; //  } public List&lt;&gt; modify(List&lt;&gt; ) { return .stream() .filter(o -&gt; !o.()) .peek(o -&gt; { .(o); .(o); .(o); //  }) .collect(Collectors.toList()); } }</span></span></code> </pre> <br><p>  Thus, we placed the code in separate classes, simplifying the tests for individual transformations (and creating the possibility of reusing steps).  The order of the calls determines the sequence of steps. </p><br><p>  But the class itself still knows all the individual steps, controls the order and thus has a huge list of dependencies.  In addition to adding a new step, we will be forced to not only write a new class, but also add it to <code>Modfier</code> . </p><br><h3 id="shag-2">  Step 2 </h3><br><p>  Simplify the code using Spring. <br>  First, create an interface for each individual step: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modification</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">modify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>; }</code> </pre><br><p>  <code>Modifier</code> itself will now be much shorter: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modifier</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;Modification&gt; steps; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Modifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Modification&gt; steps)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.steps = steps; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;&gt; modify(List&lt;&gt; ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> .stream() .filter(o -&gt; !o.()) .peek(o -&gt; { steps.forEach(m -&gt; m.modify(o)); }) .collect(Collectors.toList()); } }</code> </pre> <br><p>  Now, to add a new step, you just need to write a new class that implements the <code>Modification</code> interface and put <code>@Component</code> above it.  Spring will find it and add it to the list. </p><br><p>  <code>Modifer</code> itself <code>Modifer</code> not know anything about the individual steps, which creates a ‚Äúweak connection‚Äù between the components. </p><br><p>  The only difficulty is to set the sequence.  To do this, Spring has an <code>@Order</code> annotation into which you can pass an int value.  The list is sorted in ascending order. <br>  Thus, it may happen that by adding a new step in the middle of the list, you will have to change the sorting values ‚Äã‚Äãfor existing steps. </p><br><blockquote>  Spring could have been dispensed with if all known implementations were manually passed to the Modifier constructor.  This will help solve the sorting problem, but again complicate the addition of new steps. </blockquote><br><h3 id="shag-3">  Step 3 </h3><br><p>  Now we pass the test for cleanliness in a separate step.  To do this, we rewrite our interface so that it always returns a value: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modification</span></span></span><span class="hljs-class"> </span></span>{  modify( ); }</code> </pre> <br><p>  Check for cleanliness: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-meta"><span class="hljs-meta">@Order</span></span>(Ordered.HIGHEST_PRECEDENCE) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CleanFilter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modification</span></span></span><span class="hljs-class"> </span></span>{  modify( ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(.()){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ; } }</code> </pre> <br><p>  <code>Modifier.modify</code> : </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;&gt; modify(List&lt;&gt; ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> .stream() .map(o -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> modified = o; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> step : steps){ modified = step.modify(o); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(modified == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> modified; }) .filter(Objects::nonNull) .collect(Collectors.toList()); }</code> </pre> <br><p>  In this version, <code>Modifier</code> does not have any data information.  He simply passes them on to every known step and collects the results. </p><br><p>  If one of the steps returns null, then processing for this garment is interrupted. </p><br><p>  A similar principle is used in Spring for HandlerInterceptors.  Before and after the controller call, all appropriate Interceptors for this URL are called.  At the same time, it returns true or false in the preHandle method to indicate whether processing and calling subsequent Interceptors can continue </p><br><h3 id="shag-n">  Step n </h3><br><p>  The next step is to add the <code>matches</code> method to the <code>Modification</code> interface, in which the steps to a separate attribute of the clothes are checked: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modification</span></span></span><span class="hljs-class"> </span></span>{  modify( ); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matches</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;} }</code> </pre> <br><p>  Due to this, you can slightly simplify the logic in <code>modify</code> methods by moving the checks for classes and properties into a separate method. </p><br><p>  A similar approach is used in the Spring (Request) Filter, but the main difference is that each Filter is a wrapper around the next and explicitly calls FilterChain.doFilter to continue processing. </p><br><h2 id="itogo">  Total </h2><br><p>  The end result is very different from the initial version.  Comparing them, we can draw the following conclusions: </p><br><ul><li>  The implementation based on Pipes &amp; Filters simplifies the <code>Modifier</code> class itself. </li><li>  Better distributed responsibilities and ‚Äúweak‚Äù connections between components. </li><li>  Easier to test individual steps. </li><li>  Easier to add and remove steps. </li><li>  A little harder to test a whole chain of filters.  We need IntegrationTests already. </li><li>  More classes </li></ul><br><p>  Ultimately, a more convenient and flexible option than the original. </p><br><p>  In addition, you can simply parallelize data processing using the same parallelStream. </p><br><h3 id="chto-ne-reshaet-dannyy-primer">  What this example does not solve </h3><br><ol><li>  The description of the pattern says that individual filters can be reused by creating another filter chain (channel). <br><ul><li>  On the one hand, this is easy to do using <code>@Qualifier</code> . </li><li>  On the other hand, setting a different order with <code>@Order</code> will fail. </li></ul></li><li>  For more complex examples, you will have to use several chains, use nested chains, and still change the existing implementation. <br><ul><li>  So for example, the task: "for each sock, look for a pair and put them into one instance of &lt;? Extends Clothing&gt;" will not fit well into the described implementation, because  Now, for each toe, you have to sort through all the linen and change the initial data list. </li><li>  To solve this, you can write a new interface that accepts and returns a List &lt;Clothing&gt; and transfers it to a new chain.  But you need to be careful with the sequence of calls of the chains themselves, if the socks can be sewn only by hotel. </li></ul></li></ol><br><h2 id="spasibo-za-vnimanie">  Thanks for attention </h2></div></div><p>Source: <a href="https://habr.com/ru/post/479464/">https://habr.com/ru/post/479464/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../479450/index.html">AppCode 2019.3: works faster, understands Swift better, knows about Mac Catalyst, conveniently displays assembly messages</a></li>
<li><a href="../479452/index.html">How the Domain Name System Developed: The ARPANET Era</a></li>
<li><a href="../479458/index.html">Beauty or practicality in the server room</a></li>
<li><a href="../479460/index.html">A Guide to Flying Cars</a></li>
<li><a href="../479462/index.html">Serialization in C ++</a></li>
<li><a href="../479466/index.html">Habraiting 2019: statistics and ranking of the best articles for 2019</a></li>
<li><a href="../479468/index.html">Edge of Honesty and John Doe</a></li>
<li><a href="../479474/index.html">Why is self-organization of teams so important in Scrum and why there cannot be managers in it</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter54458986 = new Ya.Metrika({
                  id:54458986,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/54458986" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-143967986-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=IU0EG0jaqnehka2lu5TyzAcchrZXI4Yb1QXKQvJxpqE&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>