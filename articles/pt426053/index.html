<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôè üçå üì≠ Cache do manipulador de eventos e melhoria no desempenho do aplicativo React üë≤ ‚¨õÔ∏è üåµ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoje publicamos uma tradu√ß√£o do material, cujo autor, depois de analisar os recursos do trabalho com objetos em JavaScript, oferece aos desenvolvedore...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cache do manipulador de eventos e melhoria no desempenho do aplicativo React</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/426053/">  Hoje publicamos uma tradu√ß√£o do material, cujo autor, depois de analisar os recursos do trabalho com objetos em JavaScript, oferece aos desenvolvedores do React uma metodologia para acelerar aplicativos.  Em particular, estamos falando do fato de que uma vari√°vel, que, como dizem, "recebe um objeto", e que geralmente √© chamada simplesmente "objeto", na verdade, n√£o armazena o objeto em si, mas um link para ele.  As fun√ß√µes em JavaScript tamb√©m s√£o objetos, portanto, o que foi dito acima √© verdadeiro para elas.  Tendo isso em mente, o design de componentes do React e a an√°lise cr√≠tica de seu c√≥digo podem melhorar seus mecanismos internos e melhorar o desempenho do aplicativo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/54f/6b5/80a/54f6b580affe2d9741da8207f93b4746.png"></div><br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Recursos de trabalho com objetos em JavaScript</font> </h2><br>  Se voc√™ cria algumas fun√ß√µes que parecem exatamente iguais e tenta compar√°-las, acontece que elas, do ponto de vista do sistema, s√£o diferentes.  Para verificar isso, voc√™ pode executar o seguinte c√≥digo: <br><br><pre><code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> functionOne = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">'Hello world!'</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> functionTwo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">'Hello world!'</span></span>); }; functionOne === functionTwo; <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  Agora vamos tentar atribuir uma vari√°vel a uma fun√ß√£o existente que j√° est√° atribu√≠da a outra vari√°vel e comparar essas duas vari√°veis: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> functionThree = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">'Hello world!'</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> functionFour = functionThree; functionThree === functionFour; <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br>  Como voc√™ pode ver, com essa abordagem, o operador de igualdade estrita retorna <code>true</code> . <br>  Objetos naturalmente se comportam da mesma maneira: <br><br><pre> <code class="hljs julia"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object3 = object1; object1 === object2; // <span class="hljs-literal"><span class="hljs-literal">false</span></span> object1 === object3; // <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br>  Aqui estamos falando sobre JavaScript, mas se voc√™ tiver experi√™ncia em desenvolvimento em outros idiomas, poder√° estar familiarizado com o conceito de ponteiros.  No c√≥digo acima, toda vez que um objeto √© criado, uma parte da mem√≥ria do sistema √© alocada para ele.  Quando usamos um comando do formul√°rio <code>object1 = {}</code> , isso leva ao preenchimento com alguns dados de uma parte da mem√≥ria alocada especificamente para o <code>object1</code> . <br><br>  √â bem poss√≠vel imaginar o <code>object1</code> como o endere√ßo no qual as estruturas de dados relacionadas ao objeto est√£o localizadas na mem√≥ria.  A execu√ß√£o do comando <code>object2 = {}</code> leva √† aloca√ß√£o de outra √°rea de mem√≥ria, projetada especificamente para o <code>object2</code> .  <code>obect1</code> e <code>object2</code> na mesma √°rea de mem√≥ria?  N√£o, cada um deles tem seu pr√≥prio enredo.  √â por isso que, quando tentamos comparar <code>object1</code> e <code>object2</code> ficamos <code>false</code> .  Esses objetos podem ter uma estrutura id√™ntica, mas os endere√ßos na mem√≥ria em que est√£o localizados diferem e s√£o os endere√ßos que s√£o verificados durante a compara√ß√£o. <br><br>  Executando o comando <code>object3 = object1</code> , escrevemos o endere√ßo do <code>object1</code> na constante <code>object3</code> .  Este n√£o √© um novo objeto.  Essa constante recebe o endere√ßo de um objeto existente.  Voc√™ pode verificar isso: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = { x: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object3 = object1; object3.x = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; object1.x; <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  Neste exemplo, um objeto √© criado na mem√≥ria e seu endere√ßo √© gravado na constante <code>object1</code> .  Em seguida, o mesmo endere√ßo √© gravado na constante <code>object3</code> .  Alterar o <code>object3</code> altera o objeto na mem√≥ria.  Isso significa que, ao acessar um objeto usando qualquer outra refer√™ncia a ele, por exemplo, aquele armazenado no <code>object1</code> , j√° trabalharemos com sua vers√£o modificada. <br><br><h2>  <font color="#3AC1EF">Fun√ß√µes, objetos e rea√ß√£o</font> </h2><br>  O mal-entendido do mecanismo acima por desenvolvedores iniciantes geralmente leva a erros e, talvez, a considera√ß√£o dos recursos do trabalho com objetos seja digna de um artigo separado.  No entanto, nosso t√≥pico hoje √© o desempenho dos aplicativos React.  Nesta √°rea, erros podem ser cometidos mesmo por desenvolvedores razoavelmente experientes que simplesmente n√£o prestam aten√ß√£o em como os aplicativos React s√£o afetados pelo fato de que vari√°veis ‚Äã‚Äãe constantes JavaScript n√£o s√£o armazenadas nos pr√≥prios objetos, mas apenas vinculam a eles. <br><br>  O que isso tem a ver com o React?  O React possui mecanismos inteligentes para economizar recursos do sistema que visam melhorar o desempenho do aplicativo: se as propriedades e o estado do componente n√£o mudarem, o que a fun√ß√£o <code>render</code> n√£o mudar√°.  Obviamente, se o componente permanecer o mesmo, ele n√£o precisar√° ser renderizado novamente.  Se nada mudar, a fun√ß√£o de <code>render</code> retornar√° a mesma de antes, portanto, n√£o h√° necessidade de execut√°-la.  Este mecanismo faz reagir r√°pido.  Algo √© exibido apenas quando necess√°rio. <br><br>  O React verifica a igualdade e as propriedades e o estado dos componentes usando os recursos JavaScript padr√£o, ou seja, simplesmente os compara usando o operador <code>==</code> .  O React n√£o realiza uma compara√ß√£o ‚Äúrasa‚Äù ou ‚Äúprofunda‚Äù de objetos para determinar sua igualdade.  Uma compara√ß√£o superficial √© um conceito usado para descrever uma compara√ß√£o de cada par de valores-chave de um objeto, em oposi√ß√£o a uma compara√ß√£o na qual apenas os endere√ßos dos objetos na mem√≥ria s√£o comparados (refer√™ncias a eles).  A compara√ß√£o ‚Äúprofunda‚Äù de objetos vai ainda mais longe e, se os valores das propriedades comparadas dos objetos tamb√©m forem objetos, eles tamb√©m comparam os pares de valores-chave desses objetos.  Este processo √© repetido para todos os objetos aninhados em outros objetos.  React n√£o faz nada desse tipo, apenas verificando a igualdade de links. <br><br>  Se, por exemplo, voc√™ alterar a propriedade de um componente representado por um objeto do formato <code>{ x: 1 }</code> para outro objeto com a mesma apar√™ncia, o React renderizar√° novamente o componente, pois esses objetos est√£o em diferentes √°reas da mem√≥ria.  Se voc√™ se lembrar do exemplo acima, ao alterar as propriedades de um componente de <code>object1</code> para <code>object3</code> , o React n√£o renderizar√° novamente esse componente, pois as constantes <code>object1</code> e <code>object3</code> referem ao mesmo objeto. <br><br>  O trabalho com fun√ß√µes em JavaScript √© organizado exatamente da mesma maneira.  Se o React encontrar os mesmos recursos cujos endere√ßos s√£o diferentes, ele ser√° renderizado novamente.  Se a ‚Äúnova fun√ß√£o‚Äù for apenas um link para uma fun√ß√£o que j√° foi usada, n√£o haver√° nova renderiza√ß√£o. <br><br><h2>  <font color="#3AC1EF">Um problema t√≠pico ao trabalhar com componentes</font> </h2><br>  Aqui est√° um dos cen√°rios de trabalho com componentes, que, infelizmente, me ocorre constantemente ao verificar o c√≥digo de outra pessoa: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ get instructions() {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.do) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Click</span></span> the button: ';   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Do</span></span> <span class="hljs-type"><span class="hljs-type">NOT</span></span> click the button: '; } render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (     &lt;div&gt;       {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.instructions}       &lt;<span class="hljs-type"><span class="hljs-type">Button</span></span> onClick={() =&gt; alert('!')} /&gt;     &lt;/div&gt;   ); } }</code> </pre> <br>  Antes de n√≥s √© um componente muito simples.  √â um bot√£o, quando clicado, uma notifica√ß√£o √© exibida.  Ao lado do bot√£o, s√£o exibidas instru√ß√µes para seu uso, informando ao usu√°rio se ele deve pressionar esse bot√£o.  Controle qual instru√ß√£o ser√° exibida definindo a propriedade <code>do</code> ( <code>do={true}</code> ou <code>do={false}</code> ) <code>SomeComponent</code> . <br><br>  Sempre que o componente <code>SomeComponent</code> √© renderizado novamente (quando o valor da propriedade do √© alterado de <code>true</code> para <code>false</code> e vice-versa), o elemento <code>Button</code> tamb√©m √© renderizado.  O manipulador <code>onClick</code> , embora seja sempre o mesmo, √© recriado toda vez que a fun√ß√£o de <code>render</code> √© chamada.  Como resultado, verifica-se que cada vez que o componente √© exibido na mem√≥ria, uma nova fun√ß√£o √© criada, uma vez que sua cria√ß√£o √© realizada na fun√ß√£o de <code>render</code> , um link para o novo endere√ßo na mem√≥ria √© passado para <code>&lt;Button /&gt;</code> e o componente <code>Button</code> tamb√©m √© renderizado novamente, apesar do fato de que em nada mudou. <br><br>  Vamos falar sobre como corrigi-lo. <br><br><h2>  <font color="#3AC1EF">Resolu√ß√£o de problemas</font> </h2><br>  Se a fun√ß√£o for independente do componente ( <code>this</code> contexto), voc√™ poder√° defini-la fora do componente.  Todas as inst√¢ncias do componente usar√£o a mesma refer√™ncia de fun√ß√£o, pois em todos os casos ser√° a mesma fun√ß√£o.  Aqui est√° o que parece: <br><br><pre> <code class="hljs scala">const createAlertBox = () =&gt; alert('!'); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ get instructions() {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.do) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Click</span></span> the button: ';   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Do</span></span> <span class="hljs-type"><span class="hljs-type">NOT</span></span> click the button: '; } render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (     &lt;div&gt;       {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.instructions}       &lt;<span class="hljs-type"><span class="hljs-type">Button</span></span> onClick={createAlertBox} /&gt;     &lt;/div&gt;   ); } }</code> </pre> <br>  Diferente do exemplo anterior, <code>createAlertBox</code> , com cada chamada a <code>render</code> , conter√° o mesmo link para a mesma √°rea na mem√≥ria.  Como resultado, <code>Button</code> sa√≠da repetida <code>Button</code> n√£o ser√° executada. <br><br>  Embora o componente <code>Button</code> seja pequeno e renderizado rapidamente, o problema acima associado √† declara√ß√£o interna de fun√ß√µes tamb√©m pode ser encontrado em componentes grandes e complexos que levam muito tempo para renderizar.  Isso pode desacelerar significativamente o aplicativo React.  Nesse sentido, faz sentido seguir a recomenda√ß√£o, segundo a qual essas fun√ß√µes nunca devem ser declaradas dentro do m√©todo <code>render</code> . <br><br>  Se a fun√ß√£o depende do componente, ou seja, ela n√£o pode ser definida fora dela, o m√©todo do componente pode ser passado como um manipulador de eventos: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ createAlertBox = () =&gt; {   alert(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.message); }; get instructions() {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.do) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Click</span></span> the button: ';   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Do</span></span> <span class="hljs-type"><span class="hljs-type">NOT</span></span> click the button: '; } render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (     &lt;div&gt;       {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.instructions}       &lt;<span class="hljs-type"><span class="hljs-type">Button</span></span> onClick={<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.createAlertBox} /&gt;     &lt;/div&gt;   ); } }</code> </pre> <br>  Nesse caso, em cada inst√¢ncia de <code>SomeComponent</code> quando voc√™ clica no bot√£o, v√°rias mensagens ser√£o exibidas.  O manipulador de eventos do elemento <code>Button</code> deve ser exclusivo para <code>SomeComponent</code> .  Ao passar o m√©todo <code>cteateAlertBox</code> , n√£o importa se <code>SomeComponent</code> renderizado novamente.  N√£o importa se a propriedade da <code>message</code> foi alterada.  O endere√ßo da fun√ß√£o <code>createAlertBox</code> n√£o muda, o que significa que o elemento <code>Button</code> n√£o deve ser renderizado novamente.  Gra√ßas a isso, voc√™ pode economizar recursos do sistema e melhorar a velocidade de renderiza√ß√£o do aplicativo. <br><br>  Tudo isso √© bom.  Mas e se as fun√ß√µes forem din√¢micas? <br><br><h2>  <font color="#3AC1EF">Resolvendo um problema mais complexo</font> </h2><br>  <i>O autor deste material pede que voc√™ preste aten√ß√£o ao fato de que ele preparou os exemplos nesta se√ß√£o, levando em considera√ß√£o a primeira coisa que lhe veio √† mente, adequada para ilustrar a reutiliza√ß√£o de fun√ß√µes.</i>  <i>Esses exemplos t√™m como objetivo ajudar o leitor a entender a ess√™ncia da id√©ia.</i>  <i>Embora esta se√ß√£o seja recomendada para leitura para entender a ess√™ncia do que est√° acontecendo, o autor recomenda prestar aten√ß√£o aos coment√°rios no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo original</a> , pois alguns leitores sugeriram vers√µes melhores dos mecanismos discutidos aqui, que levam em considera√ß√£o os recursos de invalida√ß√£o de cache e mecanismos de gerenciamento de mem√≥ria incorporados no React.</i> <br><br>  Portanto, √© extremamente comum que em um componente existam muitos manipuladores de eventos din√¢micos exclusivos, por exemplo, algo semelhante pode ser visto no c√≥digo, onde o m√©todo de matriz de <code>map</code> √© usado no m√©todo de <code>render</code> : <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (     &lt;ul&gt;       {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.list.map(listItem =&gt;         &lt;li key={listItem.text}&gt;           &lt;<span class="hljs-type"><span class="hljs-type">Button</span></span> onClick={() =&gt; alert(listItem.text)} /&gt;         &lt;/li&gt;       )}     &lt;/ul&gt;   ); } }</code> </pre> <br>  Aqui, um n√∫mero diferente de bot√µes ser√° exibido e um n√∫mero diferente de manipuladores de eventos ser√° criado, cada um dos quais representado por uma fun√ß√£o exclusiva e, antecipadamente, ao criar <code>SomeComponent</code> , n√£o se sabe quais ser√£o essas fun√ß√µes.  Como resolver este quebra-cabe√ßa? <br><br>  Aqui, a memoriza√ß√£o nos ajudar√°, ou, mais simplesmente, em cache.  Para cada valor exclusivo, crie uma fun√ß√£o e coloque-a no cache.  Se esse valor exclusivo ocorrer novamente, ser√° suficiente retirar do cache a fun√ß√£o correspondente a ele, que foi colocada anteriormente no cache. <br><br>  Veja como √© a implementa√ß√£o dessa ideia: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    SomeComponent        //   . clickHandlers = {}; //       //    . getClickHandler(key) {   //       ,  .   if (!Object.prototype.hasOwnProperty.call(this.clickHandlers, key)) {     this.clickHandlers[key] = () =&gt; alert(key);   }   return this.clickHandlers[key]; } render() {   return (     &lt;ul&gt;       {this.props.list.map(listItem =&gt;         &lt;li key={listItem.text}&gt;           &lt;Button onClick={this.getClickHandler(listItem.text)} /&gt;         &lt;/li&gt;       )}     &lt;/ul&gt;   ); } }</span></span></code> </pre> <br>  Cada elemento da matriz √© processado pelo m√©todo <code>getClickHandler</code> .  Este m√©todo, na primeira vez em que √© chamado com um determinado valor, criar√° uma fun√ß√£o exclusiva para esse valor, colocar√° no cache e retornar√°.  Todas as chamadas subseq√ºentes a esse m√©todo, passando o mesmo valor para ele, far√£o com que ele simplesmente retorne um link para a fun√ß√£o do cache. <br><br>  Como resultado, a nova renderiza√ß√£o de <code>SomeComponent</code> n√£o renderiza novamente o <code>Button</code> .  Da mesma forma, adicionar elementos √† propriedade <code>list</code> criar√° dinamicamente manipuladores de eventos para cada bot√£o. <br><br>  Voc√™ precisar√° ser criativo na cria√ß√£o de identificadores exclusivos para manipuladores, se eles forem definidos por mais de uma vari√°vel, mas isso n√£o √© muito mais complicado do que a cria√ß√£o usual de uma propriedade de <code>key</code> exclusiva para cada objeto JSX obtido como resultado do m√©todo <code>map</code> . <br><br>  Aqui, gostaria de avisar sobre poss√≠veis problemas ao usar √≠ndices de matriz como identificadores.  O fato √© que, com essa abordagem, √© poss√≠vel encontrar erros se a ordem dos elementos na matriz for alterada ou se alguns de seus elementos forem exclu√≠dos.  Portanto, por exemplo, se no in√≠cio uma matriz semelhante se parecia com <code>[ 'soda', 'pizza' ]</code> e depois se transformou em <code>[ 'pizza' ]</code> , e voc√™ armazenou em cache manipuladores de eventos usando um comando do formul√°rio <code>listeners[0] = () =&gt; alert('soda')</code> , voc√™ descobrir√° que quando o usu√°rio clicar no bot√£o ao qual o manipulador com o identificador 0 est√° atribu√≠do e que, de acordo com o conte√∫do da matriz <code>[ 'pizza' ]</code> , deve exibir uma mensagem de <code>pizza</code> , uma mensagem de <code>soda</code> ser√° exibida.  Pelo mesmo motivo, n√£o √© recomend√°vel usar √≠ndices de matriz como propriedades principais. <br><br><h2>  <font color="#3AC1EF">Sum√°rio</font> </h2><br>  Neste artigo, examinamos os recursos dos mecanismos internos do JavaScript, considerando que voc√™ pode acelerar a renderiza√ß√£o dos aplicativos React.  Esperamos que as id√©ias apresentadas aqui sejam √∫teis. <br><br>  <b>Caros leitores!</b>  Se voc√™ conhece alguma maneira interessante de otimizar os aplicativos React, compartilhe-os. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt426053/">https://habr.com/ru/post/pt426053/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt426039/index.html">Lan√ßamento de emerg√™ncia "Soyuz MS-10" (equipe resgatada, transmitida)</a></li>
<li><a href="../pt426041/index.html">Solu√ß√£o simb√≥lica de equa√ß√µes diferenciais lineares e sistemas pelo m√©todo de transforma√ß√£o de Laplace usando SymPy</a></li>
<li><a href="../pt426045/index.html">Exce√ß√µes especiais no .NET e como prepar√°-las</a></li>
<li><a href="../pt426047/index.html">10 √≥timos livros para iniciantes em ingl√™s</a></li>
<li><a href="../pt426051/index.html">Melhorando as habilidades de depura√ß√£o de software - algumas dicas</a></li>
<li><a href="../pt426055/index.html">TensorFlow.js e clmtrackr.js: rastreando a dire√ß√£o do olhar do usu√°rio no navegador</a></li>
<li><a href="../pt426059/index.html">Tutu PHP Meetup # 2: V√≠deo de discursos</a></li>
<li><a href="../pt426061/index.html">Microsoft junta-se √† Open Invention Network e concede 60.000 licen√ßas</a></li>
<li><a href="../pt426063/index.html">Inova√ß√µes de matriz de n√≠vel b√°sico HPE MSA: matriz flash mais acess√≠vel e rica integra√ß√£o de solu√ß√µes</a></li>
<li><a href="../pt426065/index.html">Smart TV, que determina o canal mais interessante ou uma solu√ß√£o incomum de Sudoku para conte√∫do de v√≠deo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>