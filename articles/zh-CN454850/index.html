<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕑 👏🏿 🐅 单一算法的发展 🗯️ 🧑🏼‍🤝‍🧑🏻 👑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="前段时间，我的同事要我帮助他解决一个问题。 我为他解决了这个问题，但除此之外，在我看来，解决这个问题可以解释几种编程算法和技术。 并且还显示了算法执行时间从25秒加速到40 ms。 
 问题陈述 


 对于个人项目，我的同事需要一种算法，以找到给定视频的五十个最相似的视频。 可以通过匹配暴露标签的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>单一算法的发展</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454850/"><p>前段时间，我的同事要我帮助他解决一个问题。 我为他解决了这个问题，但除此之外，在我看来，解决这个问题可以解释几种编程算法和技术。 并且还显示了算法执行时间从25秒加速到40 ms。 </p><a name="habracut"></a><br><h1 id="postanovka-zadachi"> 问题陈述 </h1><br><p> 对于个人项目，我的同事需要一种算法，以找到给定视频的五十个最相似的视频。 可以通过匹配暴露标签的数量来估计相似性。 视频匹配的标签越多，它们越相似。 由此我们可以立即得出以下结论： </p><br><ul><li> 视频下的所有标签可以合并为一组； </li><li> 这样的群组绝对不会比视频本身多； </li><li> 如果该视频与某个标签组中的另一视频相似，则该视频与该组中的其他视频同样相似； </li></ul><br><p> 事实证明，仅使用标签组就足够了。 在第一个版本中，一位同事决定将标签存储在标签表中：每个视频都有一个指向标签组ID的链接，并且组本身是一系列布尔值，它们指示是否设置了相应的标签。 在C＃中，标记组如下所示： </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TagsGroup</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[] InnerTags { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } }</code> </pre> <br><p> 一位同事建议，在该网站上，他的视频不超过一百万个，各种标签不超过4000个，对于一个全面的帐户，您可以取4096 = 2 ^ 12。 <br> 然后， <code>TagsGroup</code>类可以这样表示： </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TagsGroup</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TagsGroupLength = <span class="hljs-number"><span class="hljs-number">4096</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[] InnerTags { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TagsGroup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] innerTags</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags.Length != TagsGroupLength) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); } InnerTags = innerTags; } }</code> </pre> <br><p> 现在，您需要检查两组标签的相似性。 在当前条件下，这将变成对两组标签的<code>InnerTags</code>数组的相应元素中的true的简单检查： </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a.InnerTags[i] &amp;&amp; a.InnerTags[i] == b.InnerTags[i]) result++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p> 现在仅需计算所需标签组与每个现有组的相似度并选择五十个最相似的标签组。 我为确保样品稳定性设定了另一个条件，即 在最终样本中，将有五十个标签组的<code>MeasureSimilarity</code>给出最高结果，而具有相同<code>MeasureSimilarity</code>标签组的索引将相对于那些在原始现有组中<code>MeasureSimilarity</code>较低索引的标签组具有较低的索引。 可以在以下位置找到更多详细信息： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//ru.wikipedia.org/wiki/Sustainable_Sort</a> 。 <br> 为了解决这个问题，我决定制作<code>SimilarTagsCalculator</code>类<code>SimilarTagsCalculator</code> ，这是它的代码： </p><br><div class="spoiler">  <b class="spoiler_title">相似标签</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SimilarTagsCalculator</span></span> { TagsGroup[] Groups { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SimilarTagsCalculator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup[] groups</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (groups == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(groups)); Groups = groups; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TagsGroup[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFiftyMostSimilarGroups</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> resultLength = <span class="hljs-number"><span class="hljs-number">50</span></span>; <span class="hljs-comment"><span class="hljs-comment">//,          var list = new List&lt;TagsSimilarityInfo&gt;(resultLength); //      for (int groupIndex = 0; groupIndex &lt; Groups.Length; groupIndex++) { TagsGroup tagsGroup = Groups[groupIndex]; //      int similarityValue = TagsGroup.MeasureSimilarity(value, tagsGroup); // -  TagsSimilarityInfo newInfo = new TagsSimilarityInfo(groupIndex, similarityValue); //    ,     , if (list.Count == resultLength &amp;&amp; list[resultLength - 1].CompareTo(newInfo) == -1) { continue; //     } //   ,    -  int index = ~list.BinarySearch(newInfo); list.Insert(index, newInfo); // if (list.Count &gt; resultLength) { //    , //   , ..    list.RemoveAt(resultLength); } } // -   TagsGroup[] result = new TagsGroup[resultLength]; for (int i = 0; i &lt; resultLength; i++) { result[i] = Groups[list[i].Index]; } return result; } }</span></span></code> </pre> </div></div><br><p> 和<code>TagsSimilarityInfo</code>结构： </p><br><div class="spoiler">  <b class="spoiler_title">标签相似信息</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> TagsSimilarityInfo : IComparable&lt;TagsSimilarityInfo&gt;, IComparable { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Index { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Similarity { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TagsSimilarityInfo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> similarity</span></span></span><span class="hljs-function">)</span></span> { Index = index; Similarity = similarity; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsSimilarityInfo other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Index == other.Index &amp;&amp; Similarity == other.Similarity; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> obj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> TagsSimilarityInfo other &amp;&amp; Equals(other); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHashCode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">unchecked</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (Index * <span class="hljs-number"><span class="hljs-number">397</span></span>) ^ Similarity; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareTo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsSimilarityInfo other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> similarityComparison = other.Similarity.CompareTo(Similarity); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> similarityComparison != <span class="hljs-number"><span class="hljs-number">0</span></span> ? similarityComparison : Index.CompareTo(other.Index); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareTo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> obj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ReferenceEquals(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, obj)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> TagsSimilarityInfo other ? CompareTo(other) : <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-string"><span class="hljs-string">$"Object must be of type </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">nameof</span></span></span></span><span class="hljs-string"><span class="hljs-subst">(TagsSimilarityInfo)}</span></span></span><span class="hljs-string">"</span></span>); } }</code> </pre> </div></div><br><p> 我为此算法准备了三个基准： </p><br><ul><li> 完全随机的基准，即 组中已设置标签的数量是随机的，我们将与之比较的标签组也是随机的； </li><li> 组中设置的标签数量在增加，我们将与设置所有标签的组进行比较。 事实证明，最后一些标签组应该是最合适的。 </li><li> 与上述相同，但公开标签的数量正在减少。 前50组标签最合适； </li></ul><br><p> 以下是一百万个小组的基准测试结果： </p><br><p>  BenchmarkDotNet = v0.11.5，操作系统= Windows 10.0.17134.765（1803 / April 2018Update / Redstone4） <br> 英特尔酷睿i7-6700 CPU 3.40GHz（Skylake），1个CPU，8个逻辑和4个物理核心 <br> 频率= 3328126 Hz，分辨率= 300.4694 ns，计时器= TSC <br>  .NET Core SDK = 3.0.100-preview5-011568 <br>  [主机]：.NET Core 3.0.0-preview5-27626-15（CoreCLR 4.6.27622.75，CoreFX 4.700.19.22408），64位RyuJIT </p><br><div class="scrollable-table"><table><thead><tr><th> 方法 </th><th> 均值 </th><th> 失误 </th><th> 标准差 </th><th> 已分配 </th></tr></thead><tbody><tr><td> 随机测试 </td><td>  25.054秒 </td><td>  0.1786秒 </td><td>  0.1670秒 </td><td>  1.53 KB </td></tr><tr><td> 上升测试 </td><td>  4.180秒 </td><td>  0.0174秒 </td><td>  0.0162 s </td><td>  1.53 KB </td></tr><tr><td> 后代测试 </td><td>  4.147秒 </td><td>  0.0118秒 </td><td>  0.0104秒 </td><td>  1.53 KB </td></tr></tbody></table></div><br><p> 执行时间的跨度很大，除了25秒是很长的时间，我的同事不同意等待那么长时间。 因此，让我们进行优化。 现在，有三个主要方面可以加快程序的速度： </p><br><ul><li>  <code>MeasureSimilarity</code>方法； </li><li>  <code>GetFiftyMostSimilarGroups</code>循环主体中的一种算法; </li><li>  <code>GetFiftyMostSimilarGroups</code>的循环本身； </li></ul><br><p> 我们将依次考虑三个方向。 </p><br><h1 id="predskazanie-vetvleniy"> 分支预测 </h1><br><p> 首先，考虑<code>MeasureSimilarity</code>方法。 </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a.InnerTags[i] &amp;&amp; a.InnerTags[i] == b.InnerTags[i]) result++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p> 在以前的基准测试中，随机测试和任何顺序测试之间的运行时差异都很大。 顺序测试的标签组是根据以下原理创建的： </p><br><ul><li> 将所需数量的组分为多个包。 数据包数量-组中标签的最大数量； </li><li> 对于第i个数据包中的每个组，都设置了第一个i标签； </li></ul><br><p> 事实证明，这些测试中的每组标签都由​​暴露和未暴露标签的两个连续部分组成。  <code>MeasureSimilarity</code>具有处理器<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">分支预测</a>在当前条件下具有显著作用的所有先决条件。 要检查这一点，只需编写一个基准，比较随机数据和顺序数据的MeasureSimilarity运行时： </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSimilaritySum</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup[] tagsGroups</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (TagsGroup tagsGroup <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tagsGroups) { result += TagsGroup.MeasureSimilarity(tagsGroup, etalon); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sorted</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GetSimilaritySum(sortedGroups); [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Unsorted</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GetSimilaritySum(unsortedGroups);</code> </pre> <br><div class="scrollable-table"><table><thead><tr><th> 方法 </th><th> 均值 </th><th> 失误 </th><th> 标准差 </th></tr></thead><tbody><tr><td> 已排序 </td><td>  3.704秒 </td><td>  0.0411秒 </td><td>  0.0364秒 </td></tr><tr><td> 未分类 </td><td>  8.211秒 </td><td>  0.0381秒 </td><td>  0.0338秒 </td></tr></tbody></table></div><br><p> 测试了100万个标签组，但首先在每个组中进行<code>Sorted</code> ，然后有几个暴露的标签，然后是未暴露的标签，在未分类的中，相同数量的暴露标签被随机散布在整个组中。 <br>  5秒的间隔令人印象深刻，需要做一些事情。 为了摆脱分支预测的影响并总体上加快该方法的速度，您需要摆脱分支本身。  <code>MeasureSimilarity</code>只有一个分支-检查是否将相应标签设置为两组。 让我们估计一下在哪种情况下该条件为真，为此，我们将制作一个表以显示该条件的真相： </p><br><div class="scrollable-table"><table><thead><tr><th>  a.InnerTags [i] </th><th>  b.InnerTags [i] </th><th> 结果 </th></tr></thead><tbody><tr><td> 错误的 </td><td> 错误的 </td><td> 错误的 </td></tr><tr><td> 错误的 </td><td> 是的 </td><td> 错误的 </td></tr><tr><td> 是的 </td><td> 错误的 </td><td> 错误的 </td></tr><tr><td> 是的 </td><td> 是的 </td><td> 是的 </td></tr></tbody></table></div><br><p> 真值表与逻辑“与”完全重合，即 当且仅当两个标签都为true时，结果才为true，则条件可以简化为： <code>if (a.InnerTags[i] &amp;&amp; b.InnerTags[i])</code> 。 但是，这种情况仍然存在。 在下一步中，我们将确保始终执行对结果的加法操作，为此，我们将重写循环主体，如下所示： </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = a.InnerTags[i] &amp;&amp; b.InnerTags[i] ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>; result += t;</code> </pre> <br><p> 我们仍然没有摆脱这种情况，实际上甚至使方法变慢了。 但是现在很明显的是，如果将<code>InnerTags</code>的类型从bool更改为字节（1表示true，0表示false），那么您可以摆脱三元运算符中的条件。 然后， <code>TagsGroup</code>类将如下所示： </p><br><div class="spoiler">  <b class="spoiler_title">标签组</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TagsGroup</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TagsGroupLength = <span class="hljs-number"><span class="hljs-number">4096</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] InnerTags { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; result += t; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TagsGroup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] innerTags</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags.Length != TagsGroupLength) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); } InnerTags = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[TagsGroupLength]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength; i++) { InnerTags[i] = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) (innerTags[i] ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>); } } }</code> </pre> </div></div><br><p> 以下是更新后的<code>MeasureSimilarity</code>的基准测试结果： </p><br><div class="scrollable-table"><table><thead><tr><th> 方法 </th><th> 均值 </th><th> 失误 </th><th> 标准差 </th></tr></thead><tbody><tr><td> 已排序 </td><td>  3.180秒 </td><td>  0.0118秒 </td><td>  0.0111秒 </td></tr><tr><td> 未分类 </td><td>  3.236秒 </td><td>  0.0622秒 </td><td>  0.0764秒 </td></tr></tbody></table></div><br><div class="spoiler">  <b class="spoiler_title">原为：</b> <div class="spoiler_text"><div class="scrollable-table"><table><thead><tr><th> 方法 </th><th> 均值 </th><th> 失误 </th><th> 标准差 </th></tr></thead><tbody><tr><td> 已排序 </td><td>  3.704秒 </td><td>  0.0411秒 </td><td>  0.0364秒 </td></tr><tr><td> 未分类 </td><td>  8.211秒 </td><td>  0.0381秒 </td><td>  0.0338秒 </td></tr></tbody></table></div></div></div><br><p> 但对于更新后的主要标记： </p><br><div class="scrollable-table"><table><thead><tr><th> 方法 </th><th> 均值 </th><th> 失误 </th><th> 标准差 </th><th> 已分配 </th></tr></thead><tbody><tr><td> 随机测试 </td><td>  3.219秒 </td><td>  0.0492秒 </td><td>  0.0436秒 </td><td>  1.53 KB </td></tr><tr><td> 上升测试 </td><td>  3.223秒 </td><td>  0.0117秒 </td><td>  0.0110秒 </td><td>  1.53 KB </td></tr><tr><td> 后代测试 </td><td>  3.422秒 </td><td>  0.0697秒 </td><td>  0.0999秒 </td><td>  1.53 KB </td></tr></tbody></table></div><br><div class="spoiler">  <b class="spoiler_title">原为：</b> <div class="spoiler_text"><div class="scrollable-table"><table><thead><tr><th> 方法 </th><th> 均值 </th><th> 失误 </th><th> 标准差 </th><th> 已分配 </th></tr></thead><tbody><tr><td> 随机测试 </td><td>  25.054秒 </td><td>  0.1786秒 </td><td>  0.1670秒 </td><td>  1.53 KB </td></tr><tr><td> 上升测试 </td><td>  4.180秒 </td><td>  0.0174秒 </td><td>  0.0162 s </td><td>  1.53 KB </td></tr><tr><td> 后代测试 </td><td>  4.147秒 </td><td>  0.0118秒 </td><td>  0.0104秒 </td><td>  1.53 KB </td></tr></tbody></table></div></div></div><br><p> 我认为这已经很棒。 对于那些确信所有加速仅是因为布尔类型被替换为字节才发生的那些人，我为这样的循环体启动了一个基准： </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t == <span class="hljs-number"><span class="hljs-number">1</span></span>) result += t;</code> </pre> <br><p> 结果如下： </p><br><div class="scrollable-table"><table><thead><tr><th> 方法 </th><th> 均值 </th><th> 失误 </th><th> 标准差 </th></tr></thead><tbody><tr><td> 已排序 </td><td>  3.760秒 </td><td>  0.0746秒 </td><td>  0.1541秒 </td></tr><tr><td> 未分类 </td><td>  8.628秒 </td><td>  0.1699秒 </td><td>  0.2382秒 </td></tr></tbody></table></div><br><h1 id="upakovyvanie-dannyh"> 数据打包 </h1><br><p> 每个组都有许多标签，并且不能以任何方式减少其数量。 另外，必须比较具有相同索引的标签，并且不检查所有标签就不能给出最终答案。 因此，无论如何，我们将不得不遍历整个标签组。 能够以某种方式并行化此任务非常好，这样就可以在一个条件操作中处理多个标签。 您可以通过真正的并行化来做到这一点，也可以通过特殊的数据打包来实现，我们将使用它们。 现在，每个标签表示1或0。在结果中，仅对“ AND”运算<code>result</code>结果进行累加。 但是，相同的逻辑运算不仅可以应用于单位数字。  C＃允许您做到这一点而不会出现任何问题（最多64位数字）（您可以通过<code>BitArray</code>进行更多操作，但事实并非如此）。 如果我们将两组标签表示为一组64位数字，并设置了相应的位，则可以对每组这样的64位数字执行“与”运算。 目前尚不清楚该如何处理结果。 让我们再次看一下循环的主体： </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; result += t;</code> </pre> <br><p> 每当t == 1时结果增加1，而当t == 0时结果不变。结果将等于<code>a.InnerTags[i] &amp; b.InnerTags[i]</code>的结果等于1的次数。 因此，可以将<code>a.InnerTags[i] &amp; b.InnerTags[i]</code>所有结果保存在某个数组中，并且在结果中仅写入该数组中的单元数。 当对多于n位的数字执行AND操作时，将得到n位的结果，仅知道n中设置了多少位就足够了。 数字中设置的位数不变，这意味着您可以计算这些数字。 计算64位没有意义，因为 我们不会找到太多的RAM。 对于32位，您已经可以在现代计算机上找到空间，但这仍然很多。  16位以下的内存并不难找到，但计算会相对较长。 作为折衷方案，让我们计算8位数字： </p><br><div class="spoiler">  <b class="spoiler_title">GenerateCountOfSettedBits</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] CountOfSettedBits = GenerateCountOfSettedBits(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateCountOfSettedBits</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  result   i      i- . byte[] result = new byte[256]; //  ,      i   , //        int[] b = new int[8]; //     for (int i = 1; i &lt; 256; i++) { //       int settedBitsCount = 0; //,       int m = 1; //   for (int j = 0; j &lt; 8; j++) { //     b[j] += m; //  ,       2. m = b[j] &gt;&gt; 1; //        b[j] = b[j] &amp; 1; //,        settedBitsCount += b[j]; } result[i] = (byte) settedBitsCount; //   } return result; }</span></span></code> </pre> </div></div><br><p> 现在，TagsGroup构造函数如下所示： </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> BucketSize = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TagsGroup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] innerTags</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags.Length != TagsGroupLength) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    InnerTags = new byte[TagsGroupLength / BucketSize]; //   for (int i = 0; i &lt; TagsGroupLength / BucketSize; i++) { //     for (int j = 0; j &lt; BucketSize; j++, index++) { //    2,      InnerTags[i] &lt;&lt;= 1; //    InnerTags[i] += (byte) (innerTags[index] ? 1 : 0); } } }</span></span></code> </pre> <br><p>  <code>MeasureSimilarity</code>开始看起来像这样： </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength / BucketSize; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; result += CountOfSettedBits[t]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p> 您可以运行大型基准测试，并确保一切都更好： </p><br><div class="scrollable-table"><table><thead><tr><th> 方法 </th><th> 均值 </th><th> 失误 </th><th> 标准差 </th><th> 已分配 </th></tr></thead><tbody><tr><td> 随机测试 </td><td>  560.5毫秒 </td><td>  8.285毫秒 </td><td>  7.344毫秒 </td><td>  1.53 KB </td></tr><tr><td> 上升测试 </td><td>  570.1毫秒 </td><td>  4.108毫秒 </td><td>  3.431毫秒 </td><td>  1.53 KB </td></tr><tr><td> 后代测试 </td><td>  608.1毫秒 </td><td>  5.691毫秒 </td><td>  5.324毫秒 </td><td>  1.53 KB </td></tr></tbody></table></div><br><p> 是否可以使<code>MeasureSimilarity</code>方法更快？ 当然可以！ 为此，足以认识到通用寄存器现在大多数都是64位，并且我们在其中驱动了8位数据。 为此，请增加将原始标签打包到的数据包大小，将其增加到64位，然后重写必要的方法： </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> BucketSize = <span class="hljs-number"><span class="hljs-number">64</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span>[] InnerTags { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength / BucketSize; i++) { <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; BucketSize / <span class="hljs-number"><span class="hljs-number">8</span></span>; j++) { result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p> 结果是： </p><br><div class="scrollable-table"><table><thead><tr><th> 方法 </th><th> 均值 </th><th> 失误 </th><th> 标准差 </th><th> 已分配 </th></tr></thead><tbody><tr><td> 随机测试 </td><td>  533.3毫秒 </td><td>  4.802毫秒 </td><td>  4.492毫秒 </td><td>  1.53 KB </td></tr><tr><td> 上升测试 </td><td>  550.9毫秒 </td><td>  5.435毫秒 </td><td>  5.084毫秒 </td><td>  1.53 KB </td></tr><tr><td> 后代测试 </td><td>  567.6毫秒 </td><td>  3.879毫秒 </td><td>  3.439毫秒 </td><td>  1.53 KB </td></tr></tbody></table></div><br><p> 然后，您可以展开内部循环： </p><br><div class="spoiler">  <b class="spoiler_title">度量相似度</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength / BucketSize; i++) { <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><div class="scrollable-table"><table><thead><tr><th> 方法 </th><th> 均值 </th><th> 失误 </th><th> 标准差 </th><th> 已分配 </th></tr></thead><tbody><tr><td> 随机测试 </td><td>  370.5毫秒 </td><td>  2.802毫秒 </td><td>  2.484毫秒 </td><td>  1.53 KB </td></tr><tr><td> 上升测试 </td><td>  395.8毫秒 </td><td>  2.682毫秒 </td><td>  2.509毫秒 </td><td>  1.53 KB </td></tr><tr><td> 后代测试 </td><td>  419.5毫秒 </td><td>  3.352毫秒 </td><td>  2.971毫秒 </td><td>  1.53 KB </td></tr></tbody></table></div><br><p> 它更快吗？ 是的 如果您使用.NET Core 3.0的创新功能。 尽管此版本仍在预览中，但是从一开始就存在一些内部函数的实现。 英特尔内部指南具有内部<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>_mm_popcnt_u64</code></a> 。 如前所述：“ <em>对无符号64位整数a中设置为1的位数进行计数，并在dst中返回该计数。</em> ”。 这正是我们正在努力实现的目标！ 在.NET Core 3.0 Preview 5中，此内在函数在<code>System.Runtime.Intrinsics.X86.Popcnt.X64.PopCount</code>实现（如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">a-tk</a>注释中正确指出的那样，在使用内在函数之前，您必须验证处理器是否支持它们。在这种情况下，请检查<code>System.Runtime.Intrinsics.X86.Popcnt.X64.IsSupported</code>状况<code>System.Runtime.Intrinsics.X86.Popcnt.X64.IsSupported</code> ）。 使用它， <code>MeasureSimilarity</code>方法的代码将如下所示： </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength / BucketSize; i++) { <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; result += (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) System.Runtime.Intrinsics.X86.Popcnt.X64.PopCount(t); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p> 和执行时间： </p><br><div class="scrollable-table"><table><thead><tr><th> 方法 </th><th> 均值 </th><th> 失误 </th><th> 标准差 </th><th> 已分配 </th></tr></thead><tbody><tr><td> 随机测试 </td><td>  59.33毫秒 </td><td>  1.148毫秒 </td><td>  0.9585毫秒 </td><td>  1.53 KB </td></tr><tr><td> 上升测试 </td><td>  74.87毫秒 </td><td>  1.479毫秒 </td><td>  1.9748毫秒 </td><td>  1.53 KB </td></tr><tr><td> 后代测试 </td><td>  119.46毫秒 </td><td>  2.321毫秒 </td><td>  2.8509毫秒 </td><td>  1.53 KB </td></tr></tbody></table></div><br><p> 令人印象深刻。 <br> 我不知道可以显着提高<code>MeasureSimilarity</code>的方式，同时又不会极大地损害可读性。 我认为您可以结束这种方法。 </p><br><h1 id="struktury-dannyh"> 资料结构 </h1><br><p> 现在，我们将在<code>GetFiftyMostSimilarGroups</code>方法中<code>GetFiftyMostSimilarGroups</code>循环的<code>GetFiftyMostSimilarGroups</code> ： </p><br><div class="spoiler">  <b class="spoiler_title">GetFiftyMostSimilarGroups</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TagsGroup[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFiftyMostSimilarGroups</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> resultLength = <span class="hljs-number"><span class="hljs-number">50</span></span>; List&lt;TagsSimilarityInfo&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;TagsSimilarityInfo&gt;(<span class="hljs-number"><span class="hljs-number">50</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> groupIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; groupIndex &lt; Groups.Length; groupIndex++) { TagsGroup tagsGroup = Groups[groupIndex]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> similarityValue = TagsGroup.MeasureSimilarity(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, tagsGroup); TagsSimilarityInfo newInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TagsSimilarityInfo(groupIndex, similarityValue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list.Count == resultLength &amp;&amp; list[resultLength - <span class="hljs-number"><span class="hljs-number">1</span></span>].CompareTo(newInfo) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = ~list.BinarySearch(newInfo); list.Insert(index, newInfo); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list.Count &gt; resultLength) { list.RemoveAt(resultLength); } } TagsGroup[] result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TagsGroup[resultLength]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; resultLength; i++) { result[i] = Groups[list[i].Index]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><p> 让我简要回顾一下这里发生的事情： </p><br><ul><li> 在列表中，如果比较<code>TagsSimilarityInfo</code> ，则会存储五十个最合适的标签组的排序列表，实际上是从较小到较大。 </li><li> 在保留排序的同时将有问题的新组插入列表中； </li><li> 如果列表中有50个以上的元素，则删除最不相似的组（其信息对象将是最大的，并且将在<code>list</code> ）； </li></ul><br><p> 即 事实证明，我们需要非常快速地找到集合中最大的元素，能够快速插入和删除。 为了解决这些问题，有特殊的数据结构。 首先想到的是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一堆</a> 。 她的插入在O（log N）中执行，在O（1）中获得最大值，在O（log N）中删除一个元素。 唯一的问题是增加的元素不能修改堆而不能对其进行修改。  BCL中没有二进制堆，所以我自己写了它： </p><br><div class="spoiler">  <b class="spoiler_title">二进制堆</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BinaryHeap</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt;:<span class="hljs-title"><span class="hljs-title">IEnumerable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; <span class="hljs-title"><span class="hljs-title">where</span></span> <span class="hljs-title"><span class="hljs-title">T</span></span> : <span class="hljs-title"><span class="hljs-title">IComparable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> List&lt;T&gt; innerList; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BinaryHeap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> capacity</span></span></span><span class="hljs-function">)</span></span> { innerList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;T&gt;(capacity); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Count =&gt; innerList.Count; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T Max =&gt; innerList[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { innerList.Add(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> parent = (i - <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; innerList[parent].CompareTo(innerList[i]) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { Swap(i, parent); i = parent; parent = (i - <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Swap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { T temp = innerList[a]; innerList[a] = innerList[b]; innerList[b] = temp; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Heapify</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> leftChild = (i &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) | <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rightChild = (i + <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> largestChild = i; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftChild &lt; Count &amp;&amp; innerList[leftChild].CompareTo(innerList[largestChild]) == <span class="hljs-number"><span class="hljs-number">1</span></span>) { largestChild = leftChild; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightChild &lt; Count &amp;&amp; innerList[rightChild].CompareTo(innerList[largestChild]) == <span class="hljs-number"><span class="hljs-number">1</span></span>) { largestChild = rightChild; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (largestChild == i) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } Swap(i, largestChild); i = largestChild; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveMax</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { innerList[<span class="hljs-number"><span class="hljs-number">0</span></span>] = innerList[Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; innerList.RemoveAt(Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); Heapify(<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEnumerator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> innerList.GetEnumerator(); } IEnumerator IEnumerable.GetEnumerator() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((IEnumerable) innerList).GetEnumerator(); } }</code> </pre> </div></div><br><p>  <code>GetFiftyMostSimilarGroups</code>方法的相应实现可以在本文的源代码中找到（下面的链接）。 <br> 除了堆之外，可能还会出现<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">二叉搜索树</a> 。 平衡的二叉搜索树可以为O（log N）提供插入，为O（log N）提供最大值，为O（log N）除去元素。 这种结构的优点是可以按升序进行迭代，此外，BCL中的红黑搜索树是在SortedSet内部实现的（在大型框架中，获得最大值比.netcore 3.0中要慢得多，并且要分配内存）。 可以在本文的源代码中找到SortedSet的<code>GetFiftyMostSimilarGroups</code>的实现。 <br> 所有三个<code>GetFiftyMostSimilarGroups</code>实现的基准结果： </p><br><div class="scrollable-table"><table><thead><tr><th> 方法 </th><th> 排序算法 </th><th> 均值 </th><th> 已分配 </th></tr></thead><tbody><tr><td> 随机测试 </td><td> 清单 </td><td>  60.06毫秒 </td><td>  1704乙 </td></tr><tr><td> 随机测试 </td><td> 排序集 </td><td>  65.46毫秒 </td><td>  24384 B </td></tr><tr><td> 随机测试 </td><td> 堆 </td><td>  60.55毫秒 </td><td>  2912乙 </td></tr><tr><td> 上升测试 </td><td> 清单 </td><td>  75.42毫秒 </td><td>  1704乙 </td></tr><tr><td> 上升测试 </td><td> 排序集 </td><td>  161.12毫秒 </td><td>  9833424 B </td></tr><tr><td> 上升测试 </td><td> 堆 </td><td>  86.87毫秒 </td><td>  2912乙 </td></tr><tr><td> 后代测试 </td><td> 清单 </td><td>  119.23毫秒 </td><td>  880乙 </td></tr><tr><td> 后代测试 </td><td> 排序集 </td><td>  125.03毫秒 </td><td>  3024乙 </td></tr><tr><td> 后代测试 </td><td> 堆 </td><td>  118.62毫秒 </td><td>  2088乙 </td></tr></tbody></table></div><br><p> 带有叶子的原始实现几乎在任何时候都赢了，当然在内存中也赢了。 发生这种情况的原因是，对于具有工作表的算法，对于搜索，插入操作以O（log N）执行，对于插入操作，几乎以O（1）执行操作，因为 复制这么少的元素很快就发生了，获得O（1）的最大值，同时也删除O（1）的元素，因为 在.net中，从工作表中删除最后一个元素的方法是，将一个空值写入最后一个元素（在.net核心中，没有任何内容写入结构）。 如果要求不给出50个，而是说1000个最相似的组，那么很可能，带有工作表的算法将不起作用。 实际上，所有这些都是一些推测性的推理，因为 您仍然可以调整每种算法。 </p><br><h1 id="mnogopotochnost"> 多线程 </h1><br><p> 现在剩下的工作就是尝试改善<code>GetFiftyMostSimilarGroups</code>的循环本身。 只想到多线程。 想法是将整个组列表分成几个包。 在每个程序包中，找到50个最相似的标签组，然后在其中找到最后50个最相似的标签组。 <br>  <code>GetFiftyMostSimilarGroups</code>的多线程版本如下所示： </p><br><div class="spoiler">  <b class="spoiler_title">GetFiftyMostSimilarGroupsMultiThread</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TagsGroup[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFiftyMostSimilarGroupsMultiThread</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> resultLength = <span class="hljs-number"><span class="hljs-number">50</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ,     const int threadsCount = 4; //   int bucketSize = Groups.Length / threadsCount; var tasks = new Task&lt;List&lt;TagsSimilarityInfo&gt;&gt;[threadsCount]; for (int i = 0; i &lt; threadsCount; i++) { int leftIndex = i * bucketSize; //    int rightIndex = (i + 1) * bucketSize; //    //    tasks[i] = Task&lt;List&lt;TagsSimilarityInfo&gt;&gt;.Factory.StartNew(() =&gt; GetFiftyMostSimilarGroupsMultiThreadCore(value, leftIndex, rightIndex)); } Task.WaitAll(tasks); //    var taskResults = new List&lt;TagsSimilarityInfo&gt;[threadsCount]; for (int i = 0; i &lt; threadsCount; i++) { taskResults[i] = tasks[i].Result; } //      return MergeTaskResults(resultLength, threadsCount, taskResults); }</span></span></code> </pre> </div></div><br><p>  <code>GetFiftyMostSimilarGroupsMultiThreadCore</code>       <code>GetFiftyMostSimilarGroups</code> : </p><br><div class="spoiler"> <b class="spoiler_title">GetFiftyMostSimilarGroupsMultiThreadCore</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">List&lt;TagsSimilarityInfo&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFiftyMostSimilarGroupsMultiThreadCore</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> leftIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rightIndex</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> resultLength = <span class="hljs-number"><span class="hljs-number">50</span></span>; List&lt;TagsSimilarityInfo&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;TagsSimilarityInfo&gt;(resultLength); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> groupIndex = leftIndex; groupIndex &lt; rightIndex; groupIndex++) { TagsGroup tagsGroup = Groups[groupIndex]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> similarityValue = TagsGroup.MeasureSimilarity(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, tagsGroup); TagsSimilarityInfo newInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TagsSimilarityInfo(groupIndex, similarityValue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list.Count == resultLength &amp;&amp; list[resultLength - <span class="hljs-number"><span class="hljs-number">1</span></span>].CompareTo(newInfo) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = ~list.BinarySearch(newInfo); list.Insert(index, newInfo); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list.Count &gt; resultLength) { list.RemoveAt(resultLength); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list; }</code> </pre> </div></div><br><p>     <code>MergeTaskResults</code> .   -    taskResults    . ,  ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> .     ,  <code>threadsCount</code> ,     :         ,     ,    ,    : </p><br><div class="spoiler"> <b class="spoiler_title">MergeTaskResults</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">TagsGroup[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MergeTaskResults</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> resultLength, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> threadsCount, List&lt;TagsSimilarityInfo&gt;[] taskResults</span></span></span><span class="hljs-function">)</span></span> { TagsGroup[] result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TagsGroup[resultLength]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] indices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[threadsCount]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; resultLength; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; TagsSimilarityInfo currentBest = taskResults[minIndex][indices[minIndex]]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; threadsCount; j++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> current = taskResults[j][indices[j]]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.CompareTo(currentBest) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { minIndex = j; currentBest = taskResults[minIndex][indices[minIndex]]; } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> groupIndex = currentBest.Index; result[i] = Groups[groupIndex]; indices[minIndex]++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><ul><li>  <code>indices</code>      <code>taskResults</code> ; </li><li> <code>minIndex</code> —   <code>taskResults</code> ,         ; </li><li> <code>currentBest</code> — -      ; </li><li> <code>current</code> — -    ; </li></ul><br><p>    : </p><br><div class="scrollable-table"><table><thead><tr><th> Method </th><th> Mean </th><th> Error </th><th> StdDev </th><th> Allocated </th></tr></thead><tbody><tr><td> RandomTest </td><td> 28.76 ms </td><td> 0.5677 ms </td><td> 1.414 ms </td><td> 1.4 KB </td></tr><tr><td> AscendantTest </td><td> 32.36 ms </td><td> 0.8930 ms </td><td> 2.591 ms </td><td> 1.4 KB </td></tr><tr><td> DescendantTest </td><td> 41.36 ms </td><td> 0.8908 ms </td><td> 2.626 ms </td><td> 1.4 KB </td></tr></tbody></table></div><br><div class="spoiler"> <b class="spoiler_title">     :</b> <div class="spoiler_text"><div class="scrollable-table"><table><thead><tr><th> Method </th><th> Mean </th><th> Error </th><th> StdDev </th><th> Allocated </th></tr></thead><tbody><tr><td> RandomTest </td><td> 25054 ms </td><td> 1786 ms </td><td> 1670 ms </td><td> 1.53 KB </td></tr><tr><td> AscendantTest </td><td> 4180 ms </td><td> 174 ms </td><td> 162 ms </td><td> 1.53 KB </td></tr><tr><td> DescendantTest </td><td> 4147 ms </td><td> 118 ms </td><td> 104 ms </td><td> 1.53 KB </td></tr></tbody></table></div></div></div><br><p>            .   .    ,    ,       4  50. , ,   . </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">    </a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN454850/">https://habr.com/ru/post/zh-CN454850/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN454830/index.html">成功的产品经理的三项关键素质：亚历山大·别利亚耶夫（Alexander Belyaev）</a></li>
<li><a href="../zh-CN454832/index.html">为什么每周工作四天是一个坏故事</a></li>
<li><a href="../zh-CN454834/index.html">低动力的触摸打字研究的真正术语</a></li>
<li><a href="../zh-CN454840/index.html">带着妻子和抵押贷款小心地搬到荷兰。 第2部分：准备文件和移动</a></li>
<li><a href="../zh-CN454844/index.html">Odigest：本周的设计师感兴趣</a></li>
<li><a href="../zh-CN454856/index.html">我们分析非浏览器软件中的SSL / TLS证书验证漏洞</a></li>
<li><a href="../zh-CN454860/index.html">让我们帮助QueryProvider处理插值字符串</a></li>
<li><a href="../zh-CN454864/index.html">各个公司的发展过程如何</a></li>
<li><a href="../zh-CN454868/index.html">在没有Emscripten的WebAssembly中编译C</a></li>
<li><a href="../zh-CN454872/index.html">太空入侵者：现在为512字节（汇编程序x86）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>