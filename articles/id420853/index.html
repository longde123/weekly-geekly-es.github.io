<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥚 🗺️ 💇🏿 Memenuhi Windows Pseudo Console (ConPTY) 💆 🕹️ 🚛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel yang diterbitkan 2 Agustus 2018 

 Ini adalah artikel kedua tentang baris perintah Windows, di mana kita akan membahas infrastruktur baru dan ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memenuhi Windows Pseudo Console (ConPTY)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420853/">  <font color="gray">Artikel yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diterbitkan</a> 2 Agustus 2018</font> <br><br>  Ini adalah artikel kedua tentang baris perintah Windows, di mana kita akan membahas infrastruktur baru dan antarmuka pemrograman dari pseudo-console Windows, yaitu, Windows Pseudo Console (ConPTY): mengapa kita mengembangkannya, mengapa diperlukan, bagaimana cara kerjanya, cara menggunakannya, dan banyak lagi. <br><br>  Dalam artikel terakhir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">“Warisan kuburan masa lalu.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Masalah baris perintah Windows ”</a> kami berbicara tentang prasyarat untuk munculnya terminal dan evolusi baris perintah di Windows, dan juga mulai mempelajari struktur internal Windows Console dan infrastruktur Windows Command-Line.  Kami juga membahas banyak kelebihan dan kekurangan utama dari konsol Windows. <br><br>  Salah satu kelemahannya adalah bahwa Windows berusaha untuk menjadi "berguna," tetapi itu mengganggu pengembang alternatif dan pihak ketiga, pengembang layanan, dll.  Saat membuat konsol atau layanan, pengembang perlu memiliki akses ke saluran komunikasi di mana terminal / layanan mereka bertukar data dengan aplikasi baris perintah, atau menyediakan akses ke sana.  Dalam dunia * NIX, ini bukan masalah karena * NIX menyediakan infrastruktur pseudo-terminal (PTY) yang membuatnya mudah untuk membuat saluran komunikasi untuk konsol atau layanan.  Tetapi di Windows itu bukan ... <br><br>  <i><b>... sampai sekarang!</b></i> <br><a name="habracut"></a><br><h1>  Dari TTY ke PTY </h1><br>  Sebelum menceritakan secara rinci tentang pengembangan kami, mari kita kembali sebentar ke pengembangan terminal. <br><br><h2>  Awalnya adalah TTY </h2><br>  Seperti dibahas dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya</a> , pada hari-hari awal komputasi, pengguna mengendalikan komputer menggunakan teletype elektromekanis (TTYs) yang terhubung ke komputer melalui beberapa jenis saluran komunikasi serial (biasanya melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">loop arus 20 mA</a> ). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f7b/e47/7fa/f7be477fac4e46cc71e70df23b26bef6.jpg"><br>  <font color="gray"><i>Ken Thompson dan Dennis Ritchie (berdiri) mengerjakan teletype DEC PDP-11 (pesan tanpa layar elektronik)</i></font> <br><br><h3>  Distribusi Terminal </h3><br>  Teletype digantikan oleh terminal komputer dengan layar elektronik (biasanya layar CRT).  Biasanya, terminal adalah perangkat yang sangat sederhana (karena itu istilah "terminal bisu"), hanya berisi barang elektronik dan daya pemrosesan yang diperlukan untuk tugas-tugas berikut: <br><br><ol><li>  Penerimaan input teks dari keyboard. </li><li>  Buffer teks yang dimasukkan pada satu baris (termasuk pengeditan lokal sebelum mengirim). </li><li>  Mengirim / menerima teks pada saluran serial (biasanya melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">antarmuka RS-232 yang</a> ada di mana <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">-</a> mana). </li><li>  Tampilan teks yang diterima pada tampilan terminal. </li></ol><br>  Terlepas dari kesederhanaannya (atau mungkin berkat itu), terminal dengan cepat menjadi sarana utama untuk mengelola minicomputer, mainframe dan server: sebagian besar operator entri data, operator komputer, administrator sistem, ilmuwan, peneliti, pengembang perangkat lunak, dan tokoh industri yang bekerja pada terminal DEC, IBM, Wyse dan banyak lainnya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/929/e3f/fd0/929e3ffd0e281600c9ef115f61b8b23a.jpg"><br>  <i><font color="gray">Laksamana Grace Hopper di kantornya dengan terminal DEC VT220 di mejanya</font></i> <br><br><h3>  Distribusi terminal perangkat lunak </h3><br>  Sejak pertengahan 1980-an, alih-alih terminal khusus, komputer tujuan umum secara bertahap mulai digunakan, yang telah menjadi lebih terjangkau, populer dan kuat.  Banyak PC awal dan komputer lain dari tahun 80-an memiliki aplikasi terminal yang membuka koneksi RS-232 ke PC dan bertukar data dengan siapa saja di ujung koneksi yang lain. <br><br>  Ketika komputer serba guna menjadi lebih canggih, sebuah antarmuka pengguna grafis (GUI) dan dunia baru aplikasi bersamaan, termasuk aplikasi terminal, muncul. <br><br>  Tetapi ada masalah: bagaimana aplikasi terminal berinteraksi dengan aplikasi command-line lain yang berjalan pada mesin yang sama?  Dan bagaimana cara menghubungkan kabel serial secara fisik antara dua aplikasi yang berjalan di komputer yang sama? <br><br><h2>  Penampilan Terminal Pseudo (PTY) </h2><br>  Di dunia * NIX, masalahnya diselesaikan dengan memperkenalkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terminal semu (PTY)</a> . <br><br>  PTY mengemulasi peralatan telekomunikasi serial di komputer dengan memaparkan perangkat pseudo master dan slave (“master” dan “slave”): aplikasi terminal terhubung ke perangkat pseudo master, dan aplikasi baris perintah (misalnya, cangkang seperti cmd, PowerShell dan bash) terhubung ke perangkat pseudo-slave.  Ketika klien terminal mentransmisikan teks dan / atau perintah kontrol (disandikan sebagai teks) ke perangkat master semu, teks diterjemahkan ke budak yang terkait dengannya.  Teks dari aplikasi dikirim ke perangkat pseudo-budak, kemudian kembali ke master dan, dengan demikian, ke terminal.  Data selalu dikirim / diterima secara tidak sinkron. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a42/2ba/b58/a422bab5816acdd43dd7b1c562d65caf.png"><br>  <i><font color="gray">Aplikasi Terminal Pseudo / Shell</font></i> <br><br>  Penting untuk dicatat bahwa perangkat pseudo "slave" mengemulasi perilaku terminal fisik dan mengubah karakter perintah menjadi sinyal POSIX.  Misalnya, jika pengguna memasukkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CTRL + C</a> ke terminal, maka nilai ASCII untuk CTRL + C (0x03) dikirim melalui master.  Ketika diterima pada perangkat pseudo-slave, nilai 0x03 dihapus dari aliran input dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sinyal SIGINT</a> dihasilkan. <br><br>  Infrastruktur PTY tersebut banyak digunakan oleh aplikasi terminal * NIX, manajer panel teks (mis. Layar, tmux), dll.  Aplikasi ini memanggil <code>openpty()</code> , yang mengembalikan sepasang deskriptor file (fd) untuk master dan slave PTY.  Kemudian aplikasi dapat memotong / mengeksekusi aplikasi command-line child (misalnya, bash), yang menggunakan slave fd untuk mendengarkan dan mengembalikan teks ke terminal yang terhubung. <br><br>  Mekanisme ini memungkinkan aplikasi terminal untuk "berbicara" secara langsung dengan aplikasi baris perintah yang berjalan secara lokal, seperti terminal yang akan berbicara dengan komputer jarak jauh melalui koneksi serial / jaringan. <br><br><h2>  Apa, tidak ada konsol pseudo-konsol Windows? </h2><br>  Seperti yang kita bahas dalam artikel sebelumnya, sementara konsol Windows secara konseptual mirip dengan terminal * NIX tradisional, ia berbeda dalam beberapa cara utama, terutama pada tingkat terendah, yang dapat menyebabkan masalah bagi pengembang aplikasi baris perintah Windows, terminal / konsol pihak ketiga dan server aplikasi: <br><br><ol><li>  <b>Tidak ada infrastruktur PTY di Windows</b> : ketika pengguna meluncurkan aplikasi baris perintah (misalnya, Cmd, PowerShell, wsl, ipconfig, dll.), Windows itu sendiri "menghubungkan" instance baru atau yang ada dari konsol ke aplikasi. </li><li>  <b>Windows mengganggu konsol pihak ketiga dan aplikasi server</b> : Windows (saat ini) tidak memberikan terminal cara untuk menyediakan saluran komunikasi di mana mereka ingin berinteraksi dengan aplikasi baris perintah.  Terminal pihak ketiga harus membuat konsol dari layar, mengirim data yang dimasukkan pengguna di sana dan memo output dengan menggambar ulang pada tampilan konsol pihak ketiga sendiri! </li><li>  <b>Hanya Windows yang memiliki API Konsol</b> : Aplikasi baris perintah Windows mengandalkan Win32 Consol API, yang mengurangi portabilitas kode, karena semua platform lain mendukung teks / VT, bukan API. </li><li>  <b>Akses jarak jauh non-standar</b> : ketergantungan aplikasi baris perintah pada Consol API menyulitkan interaksi dan skrip akses jarak jauh. </li></ol><br><h2>  Apa yang harus dilakukan </h2><br>  Banyak, <b>banyak</b> pengembang sering meminta mekanisme mirip PTY di Windows, terutama yang bekerja dengan ConEmu / Cmder, Console2 / ConsoleZ, Hyper, VSCode, Visual Studio, WSL, Docker, dan alat OpenSSH. <br><br>  Bahkan Peter Bright, editor teknologi Ars Technica, meminta saya untuk menerapkan mekanisme PTY beberapa hari kemudian ketika saya mulai bekerja di tim Konsol: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2dd/799/ebf/2dd799ebf0c14f418ae7d68d9a26acaa.png"><br><br>  Dan baru-baru ini lagi: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4d1/c1e/c00/4d1c1ec00ffe5ad5e6f019d1a33198c8.png"><br><br>  Akhirnya kami berhasil: <b>kami membuat pseudo-console untuk Windows</b> : <br><br><h1>  Selamat datang di Windows Pseudo Console (ConPTY) </h1><br>  Sejak pembentukan Tim Konsol sekitar empat tahun lalu, grup ini telah terlibat dalam perombakan konsol Windows dan mekanisme internal dari baris perintah.  Pada saat yang sama, kami secara teratur dan hati-hati mempertimbangkan masalah yang dijelaskan di atas dan banyak masalah dan masalah terkait lainnya.  Namun infrastruktur dan kode belum siap untuk memungkinkan rilis pseudo-console ... hingga sekarang! <br><br>  Infrastruktur pseudo-console (ConPTY) Windows baru, API, dan beberapa perubahan terkait lainnya akan menghilangkan / mengurangi seluruh kelas masalah ... <b>tanpa merusak kompatibilitas dengan aplikasi baris perintah yang ada</b> ! <br><br><blockquote>  Win32 ConPTY API baru (dokumentasi resmi akan segera diterbitkan) sekarang tersedia di build insider terbaru dari Windows 10 dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Windows 10 Insider Preview SDK yang sesuai</a> .  Mereka akan muncul dalam rilis besar berikutnya Windows 10 (di suatu tempat di musim gugur / musim dingin 2018). </blockquote><br><h2>  Arsitektur Konsol / Konversi </h2><br>  Untuk memahami ConPTY, Anda perlu mempelajari arsitektur konsol Windows, atau lebih tepatnya ... ConHost! <br><br>  Penting untuk dipahami bahwa meskipun ConHost mengimplementasikan semua yang Anda lihat dan ketahui sebagai aplikasi Windows Console, ConHost juga mengandung dan mengimplementasikan sebagian besar infrastruktur baris perintah Windows!  Mulai sekarang, <b>ConHost menjadi "simpul konsol" nyata</b> , mendukung semua aplikasi baris perintah dan / atau aplikasi GUI yang berinteraksi dengan aplikasi baris perintah! <br><br>  <b>Bagaimana?</b>  <b>Mengapa</b>  <b>Apa?</b>  Mari kita lihat lebih dekat. <br><br>  Berikut ini adalah tampilan tingkat tinggi dari arsitektur konsol internal / ConHost: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/331/1bd/54d/3311bd54dbe80dc699ff243a4812b58a.png"><br><br>  Dibandingkan dengan arsitektur dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya</a> , ConHost sekarang berisi beberapa modul tambahan untuk pemrosesan VT dan modul ConPTY baru yang mengimplementasikan API terbuka: <br><br><ul><li>  <b>ConPTY API</b> : Win32 ConPTY APIs baru menyediakan mekanisme yang mirip dengan model POSIX PTY, tetapi dalam pembiasan Windows. </li><li>  <b>Interaktivitas VT</b> : menerima teks input dalam pengkodean UTF-8, mengubah setiap karakter teks yang ditampilkan menjadi catatan <code>INPUT_RECORD</code> sesuai dan menyimpannya dalam buffer input.  Itu juga memproses urutan melarikan diri, seperti 0x03 (CTRL + C), mengubahnya menjadi <code>KEY_EVENT_RECORDS</code> , yang menghasilkan tindakan melarikan diri yang sesuai. </li><li>  <b>VT Renderer</b> : Menghasilkan urutan VT yang diperlukan untuk memindahkan kursor dan merender teks dan gaya di bidang buffer output yang telah berubah dari frame sebelumnya. </li></ul><br>  OK, tapi apa artinya itu? <br><br><h2>  Bagaimana cara kerja aplikasi baris perintah Windows? </h2><br>  Untuk lebih memahami dampak dari infrastruktur ConPTY yang baru, mari kita lihat bagaimana konsol Windows dan aplikasi command-line sejauh ini berfungsi. <br><br>  Setiap kali pengguna meluncurkan aplikasi baris perintah seperti Cmd, PowerShell atau ssh, Windows menciptakan proses Win32 baru di mana ia memuat biner aplikasi yang dapat dieksekusi dan setiap dependensi (sumber daya atau perpustakaan). <br><br>  Proses yang baru dibuat biasanya mewarisi stdin dan deskriptor stdout dari induknya.  Jika proses induk adalah proses Windows GUI, maka deskriptor stdin dan stdout hilang, sehingga Windows akan menggunakan dan melampirkan aplikasi baru ke instance konsol baru.  Komunikasi antara aplikasi baris perintah dan konsolnya dikirimkan melalui ConDrv. <br><br>  Sebagai contoh, jika Anda menjalankan dari instance PowerShell tanpa hak yang lebih tinggi, proses aplikasi baru akan mewarisi stdin / stdout deskriptor induk dan, oleh karena itu, menerima data input dan output output ke konsol yang sama dengan induk. <br><br><blockquote>  Di sini kita perlu membuat reservasi, karena dalam beberapa kasus aplikasi baris perintah diluncurkan terpasang ke instance <i>baru</i> konsol, terutama untuk alasan keamanan, tetapi deskripsi di atas biasanya benar. </blockquote><br>  Pada akhirnya, ketika aplikasi command-line / shell dijalankan, Windows menghubungkannya ke instance konsol (ConHost.exe) melalui ConDrv: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc3/4c8/d37/fc34c8d37f6f31c843422193bd5d01a6.png"><br><br><h2>  Bagaimana cara kerja ConHost? </h2><br>  Setiap kali aplikasi baris perintah dijalankan, Windows menghubungkan aplikasi ke instance baru atau yang sudah ada dari ConHost.  Aplikasi dan instance konsolnya terhubung melalui driver konsol mode-kernel (ConDrv), yang mengirim / menerima pesan IOCTL yang berisi permintaan panggilan API serial dan / atau data teks. <br><br>  Secara historis, seperti yang dinyatakan dalam artikel sebelumnya, pekerjaan ConHost relatif sederhana saat ini: <br><br><ul><li>  Pengguna menghasilkan input dari keyboard / mouse / pena / touchpad, yang dikonversi menjadi <code>KEY_EVENT_RECORD</code> atau <code>MOUSE_EVENT_RECORD</code> dan disimpan dalam buffer input. </li><li>  Buffer input dikosongkan satu catatan pada satu waktu, melakukan tindakan input yang diminta, seperti menampilkan teks pada layar, memindahkan kursor, menyalin / menempelkan teks, dll.  Banyak dari tindakan ini mengubah isi buffer output.  Area yang diubah ini direkam oleh engine status ConHost. </li><li>  Di setiap frame, konsol menampilkan area yang berubah dari buffer output. </li></ul><br>  Saat aplikasi baris perintah memanggil Windows Console API, panggilan API diserialisasi ke dalam pesan IOCTL dan dikirim melalui driver ConDrv.  Kemudian mengirimkan pesan IOCTL ke konsol terlampir, yang menerjemahkan dan mengeksekusi panggilan API yang diminta.  Nilai-nilai yang dikembalikan / keluaran diserialisasi kembali ke pesan IOCTL dan dikirim kembali ke aplikasi melalui ConDrv. <br><br><h2>  ConHost: Berkontribusi ke Masa Lalu untuk Masa Depan </h2><br>  Microsoft berupaya untuk menjaga kompatibilitas ke belakang dengan aplikasi dan alat yang ada bila memungkinkan.  Khusus untuk baris perintah.  Faktanya, Windows 10 versi 32-bit masih dapat menjalankan banyak / sebagian besar aplikasi Win16 dan executable! <br><br>  Seperti disebutkan di atas, salah satu peran utama ConHost adalah menyediakan layanan untuk aplikasi baris perintahnya, terutama aplikasi lawas yang menjalankan dan mengandalkan API konsol Win32.  Sekarang ConHost menawarkan layanan baru: <br><br><ul><li>  Infrastruktur mirip PTY yang mulus untuk komunikasi dengan konsol dan terminal modern </li><li>  Memutakhirkan aplikasi warisan / perintah tradisional <br><ul><li>  Menerima dan mengonversi teks / VT UTF-8 untuk memasukkan rekaman (seolah-olah dimasukkan oleh pengguna) </li><li>  API Konsol memanggil aplikasi yang dihosting, memperbarui buffer outputnya sesuai </li><li>  Menampilkan area yang dimodifikasi dari buffer output dalam pengkodean UTF-8, teks / VT </li></ul></li></ul><br>  Berikut ini adalah contoh bagaimana aplikasi konsol modern berkomunikasi dengan aplikasi baris perintah melalui ConPTY ConHost. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d72/7db/35e/d727db35e65b2e0eec45d0d535b4de83.png"><br><br>  Dalam model baru ini: <br><br><ol><li>  Konsol: <br><ol><li>  Membuat saluran komunikasi sendiri </li><li>  Memanggil ConPTY API untuk membuat ConPTY, memaksa Windows untuk menjalankan instance ConHost yang terhubung ke ujung saluran lainnya </li><li>  Membuat instance aplikasi baris perintah (mis. PowerShell) yang terhubung ke ConHost, seperti biasa </li></ol></li><li>  Conhost: <br><ol><li>  Membaca teks UTF-8 / VT pada input dan mengubahnya menjadi catatan <code>INPUT_RECORD</code> , yang dikirim ke aplikasi baris perintah </li><li>  Lakukan panggilan API dari aplikasi baris perintah yang dapat mengubah konten buffer output </li><li>  Menampilkan perubahan buffer output dalam pengkodean UTF-8 (teks / VT) dan mengirim teks yang diterima ke konsolnya </li></ol></li><li>  Aplikasi baris perintah: <br><ol><li>  Ini berfungsi seperti biasa, membaca input dan memanggil API Konsol, tidak tahu bahwa ConPTY ConHost menerjemahkan input dan output dari / ke UTF-8! </li></ol></li></ol><br>  Momen terakhir itu penting!  Ketika aplikasi baris perintah yang lama menggunakan panggilan ke API Konsol seperti <code>WriteConsoleOutput(...)</code> , teks yang ditentukan ditulis ke buffer output ConHost yang sesuai.  Secara berkala, ConHost menampilkan area yang berubah dari buffer output sebagai teks / VT, yang dikirim melalui stdout kembali ke konsol. <br><br>  Pada akhirnya, bahkan aplikasi baris perintah tradisional dari luar "berbicara" teks / VT <b>tanpa perubahan apa pun</b> ! <br><br>  Menggunakan infrastruktur ConPTY yang baru, konsol pihak ketiga sekarang dapat secara langsung berinteraksi dengan aplikasi baris perintah modern dan tradisional dan menukar semuanya dalam teks / VT. <br><br><h2>  Secara jarak jauh berinteraksi dengan aplikasi baris perintah Windows </h2><br>  Mekanisme yang dijelaskan di atas berfungsi dengan baik di satu komputer, tetapi juga membantu ketika berinteraksi, misalnya, dengan contoh PowerShell di komputer Windows jarak jauh atau dalam wadah. <br><br>  Ada masalah saat memulai aplikasi baris perintah dari jarak jauh (mis. Pada komputer, server, atau wadah jarak jauh).  Faktanya adalah bahwa aplikasi baris perintah pada mesin jarak jauh berkomunikasi dengan instance ConHost lokal, karena pesan IOCTL tidak dirancang untuk ditransmisikan melalui jaringan.  Bagaimana cara mentransfer input dari konsol lokal ke mesin jarak jauh dan bagaimana cara mendapatkan output dari aplikasi yang berjalan di sana?  Selain itu, apa yang harus dilakukan dengan mesin Mac dan Linux, di mana ada terminal tetapi tidak ada konsol yang kompatibel dengan Windows? <br><br>  Jadi, untuk mengontrol mesin Windows dari jarak jauh, kita membutuhkan semacam perantara komunikasi yang dapat secara transparan membuat serialisasi data melalui jaringan, mengatur masa pakai instance aplikasi, dll. <br><br>  Mungkin sesuatu seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ssh</a> ? <br><br>  Untungnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OpenSSH</a> baru <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">-</a> baru ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">porting ke Windows</a> dan ditambahkan sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">opsi tambahan untuk Windows 10</a> .  PowerShell Core juga menggunakan ssh sebagai salah satu protokol <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">remoting PowerShell Core Remoting yang</a> didukung.  Dan bagi mereka yang menjalankan Windows PowerShell, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">remoting Windows PowerShell Remoting</a> masih merupakan opsi yang dapat diterima. <br><br>  Mari kita lihat bagaimana <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OpenSSH untuk Windows sekarang</a> memungkinkan Anda untuk mengontrol <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi Windows</a> dan perintah-perintah dari jarak jauh: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/30e/7fc/eeb/30e7fceebcbcea167c2d50d448c975a4.png"><br><br>  OpenSSH saat ini mencakup beberapa komplikasi yang tidak diinginkan: <br><br><ol><li>  Pengguna: <br><ol><li>  Mulai klien ssh, dan Windows menghubungkan instance konsol seperti biasa </li><li>  Masukkan teks ke konsol, yang mengirim penekanan tombol ke klien ssh </li></ol></li><li>  klien ssh: <br><ol><li>  Membaca input sebagai byte data teks </li><li>  Mengirim data teks melalui jaringan ke layanan mendengarkan sshd </li></ol></li><li>  Layanan sshd melewati beberapa tahap: <br><ol><li>  Meluncurkan shell default (misalnya, Cmd), yang memaksa Windows untuk membuat dan menghubungkan instance konsol baru </li><li>  Menemukan dan menghubungkan ke konsol instance CDM </li><li>  Memindahkan konsol dari layar (dan / atau menyembunyikannya) </li><li>  Mengirim input yang diterima dari ssh client ke konsol dari layar sebagai input </li></ol></li><li>  Contoh cmd berfungsi seperti biasa: <br><ol><li>  Mengumpulkan input dari layanan sshd </li><li>  Apakah berhasil </li><li>  Memanggil API Konsol untuk merender / gaya teks, memindahkan kursor, dll. </li></ol></li><li>  Konsol [off-screen] terlampir: <br><ol><li>  Lakukan panggilan API dengan memperbarui buffer output. </li></ol></li><li>  Layanan sshd: <br><ol><li>  Memotong buffer output konsol luar layar, menemukan perbedaannya, menyandikannya ke dalam teks / VT dan mengirimkan kembali ... </li></ol></li><li>  Klien ssh yang mengirim teks ... </li><li>  Konsol yang menampilkan teks </li></ol><br>  <b>Menyenangkan bukan?</b>  <b>Tidak semuanya!</b>  Dalam situasi ini, banyak yang bisa serba salah, terutama dalam proses mensimulasikan dan mengirim input pengguna dan membilas buffer output dari konsol di luar layar.  Hal ini menyebabkan ketidakstabilan, kerusakan, kerusakan data, konsumsi energi yang berlebihan, dll.  Selain itu, tidak semua aplikasi melakukan pekerjaan menghapus tidak hanya teks itu sendiri, tetapi juga propertinya, itulah sebabnya pemformatan dan warna hilang! <br><br><h3>  Pekerjaan jarak jauh menggunakan ConHost dan ConPTY modern </h3><br>  <b>Tentunya kita dapat memperbaiki situasi?</b>  Ya, tentu saja kita bisa - mari kita buat beberapa perubahan arsitektur dan terapkan ConPTY baru kita: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e8/677/f1d/5e8677f1da3a8abcf2951f4e539c6470.png"><br><br>  Diagram menunjukkan bahwa rangkaian telah berubah sebagai berikut: <br><br><ol><li>  Pengguna: <br><ol><li>  Mulai klien ssh, dan Windows menghubungkan instance konsol seperti biasa </li><li>  Masukkan teks ke konsol, yang mengirim penekanan tombol ke klien ssh </li></ol></li><li>  klien ssh: <br><ol><li>  Membaca input sebagai byte data teks </li><li>  Mengirim data teks melalui jaringan ke layanan mendengarkan sshd </li></ol></li><li>  Layanan sshd: <br><ol><li>  Membuat saluran stdin / stdout </li><li>  Memanggil API ConPTY untuk memulai ConPTY </li><li>  Mulai instance Cmd yang terhubung ke ujung ConPTY lainnya.  Windows memulai dan memasang instance baru dari ConHost </li></ol></li><li>  Contoh cmd berfungsi seperti biasa: <br><ol><li>  Mengumpulkan input dari layanan sshd </li><li>  Apakah berhasil </li><li>  Memanggil API Konsol untuk merender / gaya teks, memindahkan kursor, dll. </li></ol></li><li>  Instance ConPTY ConHost: <br><ol><li>  Lakukan panggilan API dengan memperbarui buffer output. </li><li>  Menampilkan wilayah yang berubah dari buffer output sebagai teks / VT berkode UTF-8, yang dikirim kembali ke konsol / terminal melalui ssh </li></ol></li></ol><br>  Pendekatan ini menggunakan ConPTY jelas lebih bersih dan sederhana untuk layanan sshd.  Panggilan ke Windows Console API dibuat seluruhnya dalam contoh ConHost dari aplikasi baris perintah, yang mengubah semua perubahan yang terlihat menjadi teks / VT.  Siapa pun yang terhubung ke ConHost, ia tidak perlu tahu bahwa aplikasi di sana memanggil API Konsol, dan tidak menghasilkan teks / VT! <br><br>  Setuju bahwa mekanisme remoting ConPTY baru ini mengarah pada arsitektur yang elegan, konsisten, dan sederhana.  Dikombinasikan dengan fitur-fitur canggih yang tertanam dalam ConHost, dukungan untuk aplikasi yang lebih lama dan menampilkan perubahan dari aplikasi yang memanggil konsol konsol API sebagai teks / VT, infrastruktur ConHost dan ConPTY baru membantu kita memindahkan masa lalu ke masa depan. <br><br><h1>  API KONPTI dan cara menggunakannya </h1><br><blockquote>  API ConPTY tersedia dalam versi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SDK Windows 10 Insider Preview saat ini</a> . </blockquote><br>  Sekarang, saya yakin Anda tidak sabar untuk melihat beberapa kode;) <br><br>  Lihatlah deklarasi API: <br><br><pre> <code class="hljs pgsql">// Creates a "Pseudo Console" (ConPTY). HRESULT WINAPI CreatePseudoConsole( _In_ COORD size, // ConPty Dimensions _In_ HANDLE hInput, // ConPty <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> _In_ HANDLE hOutput, // ConPty Output _In_ DWORD dwFlags, // ConPty Flags _Out_ HPCON* phPC); // ConPty Reference // Resizes the given ConPTY <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the specified size, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> characters. HRESULT WINAPI ResizePseudoConsole(_In_ HPCON hPC, _In_ COORD size); // Closes the ConPTY <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> associated handles. Client applications attached // <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the ConPTY will <span class="hljs-keyword"><span class="hljs-keyword">also</span></span> terminated. <span class="hljs-type"><span class="hljs-type">VOID</span></span> WINAPI ClosePseudoConsole(_In_ HPCON hPC);</code> </pre> <br>  API ConPTY di atas pada dasarnya memaparkan tiga fungsi baru untuk digunakan: <br><br><ul><li> <b><code>CreatePseudoConsole(size, hInput, hOutput, dwFlags, phPC)</code></b> <br> <ul><li>  Membuat pty dengan dimensi di kolom <code>w</code> dan garis <code>h</code> , menggunakan saluran yang dibuat oleh pemanggil: <br><ul><li>  <code>size</code> : lebar dan tinggi (dalam karakter) dari buffer ConPTY </li><li>  <code>hInput</code> : untuk menulis data input ke PTY sebagai urutan teks / VT dalam pengkodean UTF-8 </li><li>  <code>hOutput</code> : untuk membaca output dari PTY sebagai urutan teks / VT dalam pengkodean UTF-8 </li><li>  <code>dwFlags</code> : Nilai yang memungkinkan: <br><ul><li>  PSEUDOCONSOLE_INHERIT_CURSOR: ConPTY yang dibuat akan mencoba mewarisi posisi kursor dari aplikasi terminal induk </li></ul></li><li>  <code>phPC</code> : handle konsol untuk dihasilkan oleh ConPty </li></ul></li><li>  <b>Pengembalian</b> : sukses / gagal.  Jika berhasil, phPC berisi pegangan ke ConPty baru </li></ul><br> <b><code>ResizePseudoConsole(hPC, size)</code></b> <br> <ul><li>  Mengubah ukuran buffer ConPTY internal untuk menampilkan lebar dan tinggi tertentu </li></ul><br> <b><code>ClosePseudoConsole (hPC)</code></b> <br> <ul><li>  ConPTY    .  ,   ConPTY,  ,        ,   </li></ul><br><h2>  ConPTY API </h2><br>       ConPTY API           ConPTY. <br><br><blockquote> :      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  GitHub</a> </blockquote><br><pre> <code class="hljs ruby"> /<span class="hljs-regexp"><span class="hljs-regexp">/ Note: Most error checking removed for brevity. /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Initializes the specified startup info struct with the required properties and /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ updates its thread attribute list with the specified ConPTY handle HRESULT InitializeStartupInfoAttachedToConPTY(STARTUPINFOEX* siEx, HPCON hPC) { HRESULT hr = E_UNEXPECTED; size_t size; siEx-&gt;StartupInfo.cb = sizeof(STARTUPINFOEX); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Create the appropriately sized thread attribute list InitializeProcThreadAttributeList(NULL, 1, 0, &amp;size); std::unique_ptr&lt;BYTE[]&gt; attrList = std::make_unique&lt;BYTE[]&gt;(size); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Set startup info's attribute list &amp; initialize it siEx-&gt;lpAttributeList = reinterpret_cast&lt;PPROC_THREAD_ATTRIBUTE_LIST&gt;( attrList.get()); bool fSuccess = InitializeProcThreadAttributeList( siEx-&gt;lpAttributeList, 1, 0, (PSIZE_T)&amp;size); if (fSuccess) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Set thread attribute list's Pseudo Console to the specified ConPTY fSuccess = UpdateProcThreadAttribute( lpAttributeList, 0, PROC_THREAD_ATTRIBUTE_PSEUDOCONSOLE, hPC, sizeof(HPCON), NULL, NULL); return fSuccess ? S_OK : HRESULT_FROM_WIN32(GetLastError()); } else { hr = HRESULT_FROM_WIN32(GetLastError()); } return hr; } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... HANDLE hOut, hIn; HANDLE outPipeOurSide, inPipeOurSide; HANDLE outPipePseudoConsoleSide, inPipePseudoConsoleSide; HPCON hPC = 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Create the in/out</span></span> <span class="hljs-symbol"><span class="hljs-symbol">pipes:</span></span> CreatePipe(&amp;inPipePseudoConsoleSide, &amp;inPipeOurSide, NULL, <span class="hljs-number"><span class="hljs-number">0</span></span>); CreatePipe(&amp;outPipeOurSide, &amp;outPipePseudoConsoleSide, NULL, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Create the Pseudo Console, using the pipes CreatePseudoConsole( {<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>}, inPipePseudoConsoleSide, outPipePseudoConsoleSide, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;hPC); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Prepare the StartupInfoEx structure attached to the ConPTY. STARTUPINFOEX siEx{}; InitializeStartupInfoAttachedToConPTY(&amp;siEx, hPC); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Create the client application, using startup info containing ConPTY info wchar_t* commandline = L<span class="hljs-string"><span class="hljs-string">"c:\\windows\\system32\\cmd.exe"</span></span>; PROCESS_INFORMATION piClient{}; fSuccess = CreateProcessW( nullptr, commandline, nullptr, nullptr, TRUE, EXTENDED_STARTUPINFO_PRESENT, nullptr, nullptr, &amp;siEx-&gt;StartupInfo, &amp;piClient); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ...</code> </pre> <br>  cmd.exe    ConPTY,  <code>CreatePseudoConsole()</code> .       ConPTY     /  Cmd.      <code>ResizePseudoConsole()</code> ,   —   <code>ClosePseudoConsole()</code> . <br><br><h3>    </h3><br>     ConPTY  : <br><br><pre> <code class="hljs pgsql">// <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> "echo Hello, World!", press enter <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> have cmd process the command, // <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> an up arrow (<span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> the previous command), <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> enter again <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">execute</span></span>. std::string helloWorld = "echo Hello, World!\n\x1b[A\n"; DWORD dwWritten; WriteFile(hIn, helloWorld.c_str(), (DWORD)helloWorld.length(), &amp;dwWritten, nullptr);</code> </pre> <br><h3>    </h3><br>   ,    ConPTY: <br><br><pre> <code class="hljs pgsql">// Suppose <span class="hljs-keyword"><span class="hljs-keyword">some</span></span> other async callback triggered us <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> resize. // This <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> will <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> the Terminal <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> the size we received. HRESULT hr = ResizePseudoConsole(hPC, {<span class="hljs-number"><span class="hljs-number">120</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>});</code> </pre> <br><h3>   </h3><br>     ConPTY: <br><br><pre> <code class="hljs lisp">ClosePseudoConsole(<span class="hljs-name"><span class="hljs-name">hPC</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br> :  ConPTY   ConHost    . <br><br><h1>   ! </h1><br>  ConPTY API — ,       ,     Windows   …   <i></i> ! <br><br>     ConPTY API   Microsoft,        Microsoft ( Windows  Linux (WSL),  Windows Containers, VSCode, Visual Studio  .),      ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@ConEmuMaximus5</a> —    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ConEmu</a>  Windows. <br><br> <b>    </b> ,        ConPTY API. <br><br><h2>     </h2><br>       ,        : ConHost     .           Console API.     ,          ,    . <br><br>   ,      VT, ,    —  . <br><br>   ,     <b></b>    Windows,      /VT   UTF-8    Console API:  «  VT»     ,      Console API (, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> 16M RGB True Color</a> ). <br><br><h2>   / </h2><br>       /     ,             ConPTY API:         ,  ,    ,   ,   . <br><br><blockquote>     VSCode      ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub #45693</a> )   ,     Windows. </blockquote><br><h2>  ConPTY API </h2><br>  ConPTY API     Windows 10 / 2018 . <br><br>      Windows, ,    ,     ConPTY.     Win32 API,     API    Runtime Dynamic Linking   <code>LoadLibrary()</code>  <code>GetProcAddress()</code> . <br><br>    Windows  ConPTY,        API ConPTY.  ,     ,    . <br><br><h1> ,    ? </h1><br>    …   !  ,       , <b></b> !  : D <br><br>       ,   , <i></i>    ,   <i></i>  .   —            ,          Windows  ,   . <br><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a> .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> Windows Console  GitHub</a> .    , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">    </a> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id420853/">https://habr.com/ru/post/id420853/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id420837/index.html">Menguji array RAID perangkat lunak untuk perangkat NVMe menggunakan metodologi SNIA</a></li>
<li><a href="../id420841/index.html">Perbaikan terbaru pra-rumah sakit atau "Hei Sombong! Di mana kesalahan saya? "</a></li>
<li><a href="../id420843/index.html">7 September, Yekaterinburg - pertemuan untuk pengembang .NET</a></li>
<li><a href="../id420845/index.html">Penjinakan keras kepala dengan menggunakan kruk: lubang adaptor Wi-Fi WF2190 (Realtek8812AU Wireless LAN 802.11ac USB)</a></li>
<li><a href="../id420847/index.html">Pengantar Pemrograman Shader untuk Tata Letak</a></li>
<li><a href="../id420857/index.html">Roaming Wi-Fi mulus: teori dalam praktik</a></li>
<li><a href="../id420859/index.html">Untuk pertanyaan Wirth dan rantai</a></li>
<li><a href="../id420861/index.html">Bersiap untuk C ++ 20. Studi Kasus Nyata Coroutines TS</a></li>
<li><a href="../id420863/index.html">Saat kami melakukan smartphone Rusia pertama, melanjutkan</a></li>
<li><a href="../id420865/index.html">Prinsip tindakan paling tidak. Bagian 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>