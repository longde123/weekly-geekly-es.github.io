<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛀🏻 👈🏿 😔 Escenario MVC + vs controladores gordos 👦 👩🏻‍🚀 👨🏾‍🤝‍👨🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Escenario MVC + vs. controladores gruesos 


 Los marcos PHP modernos (Symphony, Laravel, en adelante en todas partes) muestran de manera convincente ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escenario MVC + vs controladores gordos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424595/"><h1 id="mvc--scenario-protiv-tolstyh-kontrollerov">  Escenario MVC + vs. controladores gruesos </h1><br><p> Los marcos PHP modernos (Symphony, Laravel, en adelante en todas partes) muestran de manera convincente que implementar el patrón Modelo-Vista-Controlador no es tan simple.  Todas las implementaciones por alguna razón son propensas a Fat Controllers ( <code>fat controllers</code> ), condenados por todos, y los desarrolladores, y los propios frameworks. </p><br><p>  ¿Por qué es eso así?  ¿Y hay alguna forma de manejar esto?  Vamos a hacerlo bien. </p><a name="habracut"></a><br><h2 id="terminologiya">  Terminología </h2><br><ul><li>  Modelo - modelo (modelador de datos solicitados) </li><li>  Ver - ver (decorador de datos modelo) </li><li>  Controlador - controlador (coordinador de vista de modelo según lo solicitado) </li><li>  Plantilla - plantilla de presentación </li><li>  Renderizado: renderizado (formación, diseño de la imagen de presentación) </li><li>  Renderer - renderizador (modelador, diseñador de la imagen de presentación) </li></ul><br><h2 id="tolstyy-kontroller">  Controlador grueso </h2><br><p>  Aquí hay un controlador de grasa típico: </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** *   *      ID */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actionUserHello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($userId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//         ( ) $user = UserModel::find($userId); //       -   $name = $user-&gt;firstName.' '.$user-&gt;lastName; //         $view = new View('hello', ['name' =&gt; $name]); //  ( )     return $view-&gt;render(); } }</span></span></code> </pre> <br><p>  Que vemos  ¡Vemos vinagreta!  En el controlador, todo lo posible es mixto, ¡tanto el modelo como la presentación y, de hecho, el controlador mismo! </p><br><p>  Vemos los nombres del modelo y la plantilla firmemente conectados al controlador.  Esto no es un zumbido.  Vemos manipulaciones con los datos del modelo en el controlador: la formación de un nombre completo a partir del nombre y apellido.  Y esto no es un zumbido. </p><br><p>  Y una cosa más: no vemos este ejemplo explícitamente, pero es implícito.  A saber: ¡solo hay una forma de renderizar (formación de imagen)!  Solo uno: ¡según la plantilla en el archivo php!  ¿Y si quiero pdf?  ¿Y si no quiero en un archivo, sino en una línea php?  Tenía diseños con diseños elaborados en cientos de pequeñas plantillas.  Tuve que soltar el renderizador de plantillas de cadena yo mismo.  No me sobrecalentamiento, por supuesto, pero el asunto es en principio. </p><br><p>  Breve resumen: </p><br><blockquote>  Los marcos modernos tienen fallas comunes en la implementación de MVC para todos: <br><ol><li>  Interpretación estrecha de MVC-view (Ver) <strong><em>solo</em></strong> como <em>"Ver con una plantilla en un archivo PHP" en</em> lugar de <em>"Ver con cualquier renderizador"</em> . </li><li>  Interpretación estrecha del modelo MVC <strong><em>solo</em></strong> como "Dominio del modelo de base de datos" en lugar de <em>"Cualquier compilador de datos para presentación"</em> . </li><li>  Provocan el uso de los llamados <em>"controladores gruesos" que</em> contienen toda la lógica al mismo tiempo: negocios, presentación e interacción.  Esto destruye por completo el objetivo principal de MVC: la división de responsabilidades entre los componentes de la tríada. </li></ol><br></blockquote><p>  Para abordar estas deficiencias, sería bueno echar un vistazo más de cerca a los componentes de MVC. </p><br><h2 id="predstavlenie---eto-renderer">  La vista es un renderizador </h2><br><p>  Echa un vistazo al primer inconveniente: </p><br><blockquote><ol><li>  Interpretación estrecha de MVC-view (Ver) <strong><em>solo</em></strong> como <em>"Ver con una plantilla en un archivo PHP" en</em> lugar de <em>"Ver con cualquier renderizador"</em> . </li></ol><br></blockquote><p>  Aquí, todo es bastante simple: la solución al problema ya está indicada en la declaración del problema.  Solo tenemos que decir que cualquier renderizador puede usar la vista.  Para implementar esto, simplemente agregue la nueva propiedad de <code>renderer</code> a la clase View: </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $template, $data, $renderer; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__costruct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($template, $data, $renderer = NULL)</span></span></span><span class="hljs-function"> </span></span>{} }</code> </pre> <br><p>  Por lo tanto, hemos definido una nueva propiedad de <code>renderer</code> para la vista.  En el caso más general, el valor de esta propiedad puede ser cualquier función <code>callable</code> que forme una imagen de los datos transferidos mediante la plantilla transmitida. </p><br><p>  La mayoría de las aplicaciones usan solo un renderizador, e incluso si usan varias, se prefiere una de ellas.  Por lo tanto, el argumento del <code>renderer</code> se define como opcional, suponiendo que haya algún renderizador predeterminado. </p><br><p>  Es simple?  Simple  En realidad no es tan simple.  El hecho es que la <code>View</code> que está en MVC no es exactamente la <code>View</code> que está en los marcos.  La <code>View</code> que está en el marco no puede vivir sin una plantilla.  Pero la <code>View</code> , que en MVC, por alguna razón, no sabe nada sobre estas mismas plantillas.  Por qué  Sí, porque para MVC <code>View</code> , este es <em>cualquier convertidor de datos del modelo en una imagen</em> , y no solo un motor de plantillas.  Cuando escribimos algo como esto en el controlador de solicitudes: </p><br><pre> <code class="php hljs">$name = <span class="hljs-string"><span class="hljs-string">' '</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hello, {$name}!"</span></span>;</code> </pre> <br><p>  o incluso: </p><br><pre> <code class="php hljs">$return json_encode($name); <span class="hljs-comment"><span class="hljs-comment">// Ajax response</span></span></code> </pre> <br><p>  entonces realmente definimos la <code>View</code> que está en MVC, ¡sin tocar ninguna <code>View</code> que esté en los marcos! </p><br><p>  Pero ahora todo es realmente simple: esas <code>View</code> , que en los marcos, este es un subconjunto de esas <code>View</code> , que están en MVC.  Además, un subconjunto muy estrecho, es decir, es solo un motor de plantillas basado en archivos PHP. </p><br><p>  Resumen: es el <code></code> , es decir  cualquier decorador de una imagen de datos es la <code>View</code> que está en MVC.  Y esas <code>View</code> , que están en los marcos, son solo una especie de <code></code> . </p><br><h2 id="model-domena--model-predstavleniya-viewmodel--domainmodel">  Modelo de dominio / Modelo de vista (ViewModel / DomainModel) </h2><br><p>  Ahora mira el segundo inconveniente: </p><br><blockquote><ol><li>  Interpretación estrecha del modelo MVC <strong><em>solo</em></strong> como "Dominio del modelo de base de datos" en lugar de <em>"Cualquier compilador de datos para presentación"</em> . </li></ol><br></blockquote><p>  Es obvio para todos que el modelo MVC es una cosa compleja que consta de otras piezas.  La comunidad acuerda descomponer el modelo en dos componentes: un modelo de dominio (DomainModel) y un modelo de presentación (ViewModel). </p><br><p>  Un modelo de dominio es lo que se almacena en las bases de datos, es decir.  Datos del modelo normalizado.  Escriba, 'nombre' y 'apellido' en diferentes campos.  Los marcos están ocupados con esta parte particular del modelo simplemente porque el almacenamiento de datos es su propio universo, bien estudiado. </p><br><p>  Sin embargo, una aplicación necesita datos agregados en lugar de datos normalizados.  Los datos del dominio deben compilarse en imágenes como: "¡Hola, Ivan!", "¡Querido Ivan Petrov!", O incluso "¡Para Ivan <strong>a</strong> Petrov <strong>a</strong> !".  Estos datos convertidos se refieren a otro modelo: modelo de presentación.  Por lo tanto, es esta parte del modelo la que aún ignoran los marcos modernos.  Se ignora porque no hay acuerdo sobre cómo tratarlo.  Y si los marcos no proporcionan una solución, los programadores siguen el camino más simple: lanzan el modelo de vista al controlador.  ¡Y obtienen los odiados pero inevitables controladores de grasa! </p><br><p>  Total: para implementar MVC, debe implementar un modelo de vista.  No hay otras opciones.  Dado que las representaciones y sus datos pueden ser cualquiera, declaramos que tenemos un problema. </p><br><h2 id="scenariy-protiv-tolstyh-kontrollerov">  Escenario vs. Controladores de grasa </h2><br><p>  Hay un último inconveniente de los marcos: </p><br><blockquote><ol><li>  Provocan el uso de los llamados <em>"controladores gruesos" que</em> contienen toda la lógica al mismo tiempo: negocios, presentación e interacción.  Esto destruye por completo el objetivo principal de MVC: la división de responsabilidades entre los componentes de la tríada. </li></ol><br></blockquote><p>  Aquí llegamos a los conceptos básicos de MVC.  Seamos claros.  Entonces, MVC asume la siguiente distribución de responsabilidades entre los componentes de la tríada: </p><br><ul><li>  El controlador es la <em>lógica de interacción</em> , es decir.  interacciones tanto con el mundo exterior (solicitud - respuesta) como con el interno (Modelo - Presentación), </li><li>  El modelo es <em>la lógica de negocios</em> , es decir.  generar datos para una solicitud específica, </li><li>  La representación es la <em>lógica de la representación</em> , es decir.  Decoración de los datos generados por el Modelo. </li></ul><br><p>  Adelante  Dos niveles de responsabilidades son claramente visibles: </p><br><ul><li>  El nivel organizacional es el controlador, </li><li>  El nivel ejecutivo es Modelo y Representación. </li></ul><br><p>  En términos simples, el controlador dirige, el arado Modelo y Vista.  Esto es si de una manera simple.  ¿Y si no de una manera simple, sino más específicamente?  ¿Cómo se dirige exactamente el controlador?  ¿Y cómo aran exactamente el Modelo y la Vista? </p><br><p>  El controlador dirige así: </p><br><ul><li>  Recibe una solicitud de una aplicación, </li><li>  Decide qué modelo y qué vista usar para esta solicitud, </li><li>  Llama al modelo seleccionado y recibe datos de él, </li><li>  Invoca la Vista seleccionada con los datos recibidos del Modelo, </li><li>  Devuelve los datos decorados por la Vista a la aplicación. </li></ul><br><p>  Algo asi.  Lo esencial en este esquema es que el Modelo y la Representación resultan ser enlaces en la cadena de ejecución de consultas.  Además, mediante enlaces sucesivos: primero, el Modelo convierte la solicitud en algunos datos, luego la Vista convierte estos datos del Modelo en una respuesta decorada según sea necesario para una solicitud específica.  Al igual que una solicitud humanoide está decorada visualmente con templatizadores, una solicitud de Android está decorada con codificadores JSON. </p><br><p>  Ahora tratemos de descubrir cómo exactamente aran los artistas: modelo y presentación.  Dijimos anteriormente que hay consenso sobre la descomposición del Modelo en dos subcomponentes: Modelo de Dominio y Modelo de Presentación.  Esto significa que puede haber más artistas, no dos, sino tres.  En lugar de una cadena de ejecución </p><br><blockquote>  <code></code> &gt;&gt; <code></code> </blockquote><p>  bien puede haber una cadena </p><br><blockquote>  <code> </code> <code> </code> &gt;&gt; <code></code> <code> </code> &gt;&gt; <code></code> </blockquote><p>  La pregunta se plantea: ¿por qué solo dos o tres?  ¿Y si necesitas más?  La respuesta natural es, por el amor de Dios, ¡toma todo lo que necesites! </p><br><p>  Otros artistas útiles son inmediatamente visibles: validadores, redirectores, varios renderizadores y, en general, todo lo que es impredecible, pero agradable. </p><br><p>  Recapitulemos: </p><br><blockquote><ul><li>  El nivel ejecutivo MVC ( <code></code> - <code></code> ) se puede implementar como una cadena de enlaces, donde cada enlace convierte la salida del enlace anterior en la entrada para el siguiente. </li><li>  La entrada del primer enlace es la solicitud de la aplicación. </li><li>  La salida del último enlace es la respuesta de la aplicación a la solicitud. </li></ul><br></blockquote><p>  Llamé a esta cadena <code>Scenario</code> , pero para los eslabones de la cadena aún no he decidido el nombre.  Las opciones actuales son una escena (como parte de un script), un filtro (como convertidor de datos), una acción de script.  En términos generales, el nombre del enlace no es tan importante, hay algo más significativo. </p><br><p>  Las consecuencias de la aparición del escenario son significativas.  A saber: el escenario asumió la responsabilidad principal del controlador: determinar el modelo y la presentación necesarios para la solicitud y lanzarlos.  Por lo tanto, el controlador solo tiene dos responsabilidades: interactuar con el mundo exterior (solicitud-respuesta) y ejecutar el script.  Y esto es bueno en el sentido de que todos los componentes de la tríada MVC se descomponen secuencialmente y se vuelven más específicos y manejables.  Y sigue siendo bueno en otro aspecto: el controlador MVCS se convierte en una clase inmutable puramente interna y, por lo tanto, incluso en principio, no puede engordar. </p><br><p>  El uso de escenarios conduce a otra variación del patrón MVC; llamé a esta variación <strong><code>MVCS</code></strong> - <code>Model-View-Controller-Scenario</code> . </p><br><p>  Y un par de líneas más sobre la descomposición de MVC.  Los marcos modernos, donde todas las funciones típicas se descomponen al límite, naturalmente, le quitaron a la parte conceptual MVC de las responsabilidades para interactuar con el mundo exterior.  Por lo tanto, las clases especialmente entrenadas como <code>HTTP </code> y el <code></code> participan en el procesamiento de la solicitud del usuario.  Como resultado, el Controlador no recibe la solicitud inicial del usuario, sino una <code></code> refinada, y esto permite aislar al controlador de los detalles de la solicitud.  Del mismo modo, se realiza un aislamiento de los detalles de la respuesta HTTP, lo que permite que el módulo MVC defina su propio tipo de respuesta.  Además, los marcos implementaron completamente los dos componentes de MVC: el modelo de dominio y la plantilla de presentación, sin embargo, ya lo discutimos.  Estoy todo esto en el hecho de que el refinamiento y la concreción de MVC es continuo y continuo, y esto es emocionante. </p><br><h2 id="primer-ispolzovaniya-mvcs">  Ejemplo de MVCS </h2><br><p>  Ahora veamos cómo se puede implementar el ejemplo de <em>Fat Cortroller</em> al comienzo de este artículo en MVCS. </p><br><p>  Comenzamos creando un controlador MVCS: </p><br><pre> <code class="php hljs">$mvcs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MvcsController();</code> </pre> <br><p>  El controlador MVCS recibe una solicitud de un enrutador externo.  Deje que el enrutador convierta el URI del formulario 'usuario / hola / XXX' en tales parámetros de acción y solicitud: </p><br><pre> <code class="php hljs">$requestAction = <span class="hljs-string"><span class="hljs-string">'user/hello'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   $requestParams = ['XXX']; //   -  </span></span></code> </pre> <br><p>  Teniendo en cuenta que el controlador MVCS acepta scripts en lugar de URI, debemos asignar algunos scripts a la acción de la solicitud.  Esto se hace mejor en el contenedor MVCS: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//   MVCS  URI  $mvcs-&gt;set('scenarios', [ 'user/hello' =&gt; 'UserModel &gt; UserViewModel &gt; view, hello', ..., ]);</span></span></code> </pre> <br><p>  Echemos un vistazo más de cerca a este escenario.  Esta es una cadena de tres convertidores de datos separados por un '&gt;': </p><br><ul><li>  'UserModel' es el nombre del modelo de dominio 'Usuario', la entrada del modelo serán los parámetros de solicitud, la salida serán los datos reales del modelo, </li><li>  'UserViewModel' es el nombre del modelo de vista que convierte los datos del dominio en datos de vista, </li><li>  'view, hello' es la 'plantilla' de la vista del sistema para una plantilla PHP llamada 'hello'. </li></ul><br><p>  Ahora solo necesitamos agregar dos transformadores involucrados en el script como una función de cierre al contenedor MVCS: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//   UserModel $mvcs-&gt;set('UserModel', function($id) { $users = [ 1 =&gt; ['first' =&gt; '', 'last' =&gt; ''], 2 =&gt; ['first' =&gt; '', 'last' =&gt; ''], ]; return isset($users[$id]) ? $users[$id] : NULL; }); //   UserViewModel $mvcs-&gt;set('UserViewModel', function($user) { //    PHP  : 'echo "Hello, $name!"'; return ['name' =&gt; $user['first'].' '.$user['last']]; });</span></span></code> </pre> <br><p>  ¡Y eso es todo!  Para cada solicitud, es necesario determinar el guión correspondiente y todas sus escenas (excepto las del sistema, como 'vista').  Y nada mas. </p><br><p>  Y ahora estamos listos para probar MVCS para diferentes solicitudes: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//        $scenarios = $mvcs-&gt;get('scenarios'); $scenario = $scenarios[$requestAction]; //      ... //   'user/hello/1'  ' '   'hello' $requestParams = ['1']; $response = $mvcs-&gt;play($scenario, $requestParams); //   'user/hello/2'  ' '   'hello' $requestParams = ['2']; $response = $mvcs-&gt;play($scenario, $requestParams);</span></span></code> </pre> <br><blockquote>  <em>La implementación de PHP MVCS está alojada en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github.com</a> .</em> <br>  <em>Este ejemplo está en el directorio MVCS de <code>example</code> .</em> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es424595/">https://habr.com/ru/post/es424595/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es424585/index.html">CryEngine 5.5 lanzado por Crytek</a></li>
<li><a href="../es424587/index.html">Resumen del libro "Ventas a grandes empresas"</a></li>
<li><a href="../es424589/index.html">Cómo inscribirse en un programa de doctorado de aprendizaje automático</a></li>
<li><a href="../es424591/index.html">No hay ideal: cómo busqué un lenguaje de programación para mí</a></li>
<li><a href="../es424593/index.html">C ++ 11 y manejo de eventos</a></li>
<li><a href="../es424597/index.html">Entrevista con el orador de la Conferencia de RubyRussia, Marcus Schirp</a></li>
<li><a href="../es424599/index.html">Debe elegir qué software necesita: escrito a tiempo o de alta calidad</a></li>
<li><a href="../es424601/index.html">Arquitectura de la información en Internet parte 1</a></li>
<li><a href="../es424603/index.html">El libro "¿Por qué nos equivocamos? Trampas de pensamiento en acción ". Extractos Parte 1</a></li>
<li><a href="../es424605/index.html">Fondos de Zuckerberg: colaboración + tecnología + ciencia abierta</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>