<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõÄüèª üëàüèø üòî Escenario MVC + vs controladores gordos üë¶ üë©üèª‚ÄçüöÄ üë®üèæ‚Äçü§ù‚Äçüë®üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Escenario MVC + vs. controladores gruesos 


 Los marcos PHP modernos (Symphony, Laravel, en adelante en todas partes) muestran de manera convincente ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escenario MVC + vs controladores gordos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424595/"><h1 id="mvc--scenario-protiv-tolstyh-kontrollerov">  Escenario MVC + vs. controladores gruesos </h1><br><p> Los marcos PHP modernos (Symphony, Laravel, en adelante en todas partes) muestran de manera convincente que implementar el patr√≥n Modelo-Vista-Controlador no es tan simple.  Todas las implementaciones por alguna raz√≥n son propensas a Fat Controllers ( <code>fat controllers</code> ), condenados por todos, y los desarrolladores, y los propios frameworks. </p><br><p>  ¬øPor qu√© es eso as√≠?  ¬øY hay alguna forma de manejar esto?  Vamos a hacerlo bien. </p><a name="habracut"></a><br><h2 id="terminologiya">  Terminolog√≠a </h2><br><ul><li>  Modelo - modelo (modelador de datos solicitados) </li><li>  Ver - ver (decorador de datos modelo) </li><li>  Controlador - controlador (coordinador de vista de modelo seg√∫n lo solicitado) </li><li>  Plantilla - plantilla de presentaci√≥n </li><li>  Renderizado: renderizado (formaci√≥n, dise√±o de la imagen de presentaci√≥n) </li><li>  Renderer - renderizador (modelador, dise√±ador de la imagen de presentaci√≥n) </li></ul><br><h2 id="tolstyy-kontroller">  Controlador grueso </h2><br><p>  Aqu√≠ hay un controlador de grasa t√≠pico: </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** *   *      ID */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actionUserHello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($userId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//         ( ) $user = UserModel::find($userId); //       -   $name = $user-&gt;firstName.' '.$user-&gt;lastName; //         $view = new View('hello', ['name' =&gt; $name]); //  ( )     return $view-&gt;render(); } }</span></span></code> </pre> <br><p>  Que vemos  ¬°Vemos vinagreta!  En el controlador, todo lo posible es mixto, ¬°tanto el modelo como la presentaci√≥n y, de hecho, el controlador mismo! </p><br><p>  Vemos los nombres del modelo y la plantilla firmemente conectados al controlador.  Esto no es un zumbido.  Vemos manipulaciones con los datos del modelo en el controlador: la formaci√≥n de un nombre completo a partir del nombre y apellido.  Y esto no es un zumbido. </p><br><p>  Y una cosa m√°s: no vemos este ejemplo expl√≠citamente, pero es impl√≠cito.  A saber: ¬°solo hay una forma de renderizar (formaci√≥n de imagen)!  Solo uno: ¬°seg√∫n la plantilla en el archivo php!  ¬øY si quiero pdf?  ¬øY si no quiero en un archivo, sino en una l√≠nea php?  Ten√≠a dise√±os con dise√±os elaborados en cientos de peque√±as plantillas.  Tuve que soltar el renderizador de plantillas de cadena yo mismo.  No me sobrecalentamiento, por supuesto, pero el asunto es en principio. </p><br><p>  Breve resumen: </p><br><blockquote>  Los marcos modernos tienen fallas comunes en la implementaci√≥n de MVC para todos: <br><ol><li>  Interpretaci√≥n estrecha de MVC-view (Ver) <strong><em>solo</em></strong> como <em>"Ver con una plantilla en un archivo PHP" en</em> lugar de <em>"Ver con cualquier renderizador"</em> . </li><li>  Interpretaci√≥n estrecha del modelo MVC <strong><em>solo</em></strong> como "Dominio del modelo de base de datos" en lugar de <em>"Cualquier compilador de datos para presentaci√≥n"</em> . </li><li>  Provocan el uso de los llamados <em>"controladores gruesos" que</em> contienen toda la l√≥gica al mismo tiempo: negocios, presentaci√≥n e interacci√≥n.  Esto destruye por completo el objetivo principal de MVC: la divisi√≥n de responsabilidades entre los componentes de la tr√≠ada. </li></ol><br></blockquote><p>  Para abordar estas deficiencias, ser√≠a bueno echar un vistazo m√°s de cerca a los componentes de MVC. </p><br><h2 id="predstavlenie---eto-renderer">  La vista es un renderizador </h2><br><p>  Echa un vistazo al primer inconveniente: </p><br><blockquote><ol><li>  Interpretaci√≥n estrecha de MVC-view (Ver) <strong><em>solo</em></strong> como <em>"Ver con una plantilla en un archivo PHP" en</em> lugar de <em>"Ver con cualquier renderizador"</em> . </li></ol><br></blockquote><p>  Aqu√≠, todo es bastante simple: la soluci√≥n al problema ya est√° indicada en la declaraci√≥n del problema.  Solo tenemos que decir que cualquier renderizador puede usar la vista.  Para implementar esto, simplemente agregue la nueva propiedad de <code>renderer</code> a la clase View: </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $template, $data, $renderer; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__costruct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($template, $data, $renderer = NULL)</span></span></span><span class="hljs-function"> </span></span>{} }</code> </pre> <br><p>  Por lo tanto, hemos definido una nueva propiedad de <code>renderer</code> para la vista.  En el caso m√°s general, el valor de esta propiedad puede ser cualquier funci√≥n <code>callable</code> que forme una imagen de los datos transferidos mediante la plantilla transmitida. </p><br><p>  La mayor√≠a de las aplicaciones usan solo un renderizador, e incluso si usan varias, se prefiere una de ellas.  Por lo tanto, el argumento del <code>renderer</code> se define como opcional, suponiendo que haya alg√∫n renderizador predeterminado. </p><br><p>  Es simple?  Simple  En realidad no es tan simple.  El hecho es que la <code>View</code> que est√° en MVC no es exactamente la <code>View</code> que est√° en los marcos.  La <code>View</code> que est√° en el marco no puede vivir sin una plantilla.  Pero la <code>View</code> , que en MVC, por alguna raz√≥n, no sabe nada sobre estas mismas plantillas.  Por qu√©  S√≠, porque para MVC <code>View</code> , este es <em>cualquier convertidor de datos del modelo en una imagen</em> , y no solo un motor de plantillas.  Cuando escribimos algo como esto en el controlador de solicitudes: </p><br><pre> <code class="php hljs">$name = <span class="hljs-string"><span class="hljs-string">' '</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hello, {$name}!"</span></span>;</code> </pre> <br><p>  o incluso: </p><br><pre> <code class="php hljs">$return json_encode($name); <span class="hljs-comment"><span class="hljs-comment">// Ajax response</span></span></code> </pre> <br><p>  entonces realmente definimos la <code>View</code> que est√° en MVC, ¬°sin tocar ninguna <code>View</code> que est√© en los marcos! </p><br><p>  Pero ahora todo es realmente simple: esas <code>View</code> , que en los marcos, este es un subconjunto de esas <code>View</code> , que est√°n en MVC.  Adem√°s, un subconjunto muy estrecho, es decir, es solo un motor de plantillas basado en archivos PHP. </p><br><p>  Resumen: es el <code></code> , es decir  cualquier decorador de una imagen de datos es la <code>View</code> que est√° en MVC.  Y esas <code>View</code> , que est√°n en los marcos, son solo una especie de <code></code> . </p><br><h2 id="model-domena--model-predstavleniya-viewmodel--domainmodel">  Modelo de dominio / Modelo de vista (ViewModel / DomainModel) </h2><br><p>  Ahora mira el segundo inconveniente: </p><br><blockquote><ol><li>  Interpretaci√≥n estrecha del modelo MVC <strong><em>solo</em></strong> como "Dominio del modelo de base de datos" en lugar de <em>"Cualquier compilador de datos para presentaci√≥n"</em> . </li></ol><br></blockquote><p>  Es obvio para todos que el modelo MVC es una cosa compleja que consta de otras piezas.  La comunidad acuerda descomponer el modelo en dos componentes: un modelo de dominio (DomainModel) y un modelo de presentaci√≥n (ViewModel). </p><br><p>  Un modelo de dominio es lo que se almacena en las bases de datos, es decir.  Datos del modelo normalizado.  Escriba, 'nombre' y 'apellido' en diferentes campos.  Los marcos est√°n ocupados con esta parte particular del modelo simplemente porque el almacenamiento de datos es su propio universo, bien estudiado. </p><br><p>  Sin embargo, una aplicaci√≥n necesita datos agregados en lugar de datos normalizados.  Los datos del dominio deben compilarse en im√°genes como: "¬°Hola, Ivan!", "¬°Querido Ivan Petrov!", O incluso "¬°Para Ivan <strong>a</strong> Petrov <strong>a</strong> !".  Estos datos convertidos se refieren a otro modelo: modelo de presentaci√≥n.  Por lo tanto, es esta parte del modelo la que a√∫n ignoran los marcos modernos.  Se ignora porque no hay acuerdo sobre c√≥mo tratarlo.  Y si los marcos no proporcionan una soluci√≥n, los programadores siguen el camino m√°s simple: lanzan el modelo de vista al controlador.  ¬°Y obtienen los odiados pero inevitables controladores de grasa! </p><br><p>  Total: para implementar MVC, debe implementar un modelo de vista.  No hay otras opciones.  Dado que las representaciones y sus datos pueden ser cualquiera, declaramos que tenemos un problema. </p><br><h2 id="scenariy-protiv-tolstyh-kontrollerov">  Escenario vs. Controladores de grasa </h2><br><p>  Hay un √∫ltimo inconveniente de los marcos: </p><br><blockquote><ol><li>  Provocan el uso de los llamados <em>"controladores gruesos" que</em> contienen toda la l√≥gica al mismo tiempo: negocios, presentaci√≥n e interacci√≥n.  Esto destruye por completo el objetivo principal de MVC: la divisi√≥n de responsabilidades entre los componentes de la tr√≠ada. </li></ol><br></blockquote><p>  Aqu√≠ llegamos a los conceptos b√°sicos de MVC.  Seamos claros.  Entonces, MVC asume la siguiente distribuci√≥n de responsabilidades entre los componentes de la tr√≠ada: </p><br><ul><li>  El controlador es la <em>l√≥gica de interacci√≥n</em> , es decir.  interacciones tanto con el mundo exterior (solicitud - respuesta) como con el interno (Modelo - Presentaci√≥n), </li><li>  El modelo es <em>la l√≥gica de negocios</em> , es decir.  generar datos para una solicitud espec√≠fica, </li><li>  La representaci√≥n es la <em>l√≥gica de la representaci√≥n</em> , es decir.  Decoraci√≥n de los datos generados por el Modelo. </li></ul><br><p>  Adelante  Dos niveles de responsabilidades son claramente visibles: </p><br><ul><li>  El nivel organizacional es el controlador, </li><li>  El nivel ejecutivo es Modelo y Representaci√≥n. </li></ul><br><p>  En t√©rminos simples, el controlador dirige, el arado Modelo y Vista.  Esto es si de una manera simple.  ¬øY si no de una manera simple, sino m√°s espec√≠ficamente?  ¬øC√≥mo se dirige exactamente el controlador?  ¬øY c√≥mo aran exactamente el Modelo y la Vista? </p><br><p>  El controlador dirige as√≠: </p><br><ul><li>  Recibe una solicitud de una aplicaci√≥n, </li><li>  Decide qu√© modelo y qu√© vista usar para esta solicitud, </li><li>  Llama al modelo seleccionado y recibe datos de √©l, </li><li>  Invoca la Vista seleccionada con los datos recibidos del Modelo, </li><li>  Devuelve los datos decorados por la Vista a la aplicaci√≥n. </li></ul><br><p>  Algo asi.  Lo esencial en este esquema es que el Modelo y la Representaci√≥n resultan ser enlaces en la cadena de ejecuci√≥n de consultas.  Adem√°s, mediante enlaces sucesivos: primero, el Modelo convierte la solicitud en algunos datos, luego la Vista convierte estos datos del Modelo en una respuesta decorada seg√∫n sea necesario para una solicitud espec√≠fica.  Al igual que una solicitud humanoide est√° decorada visualmente con templatizadores, una solicitud de Android est√° decorada con codificadores JSON. </p><br><p>  Ahora tratemos de descubrir c√≥mo exactamente aran los artistas: modelo y presentaci√≥n.  Dijimos anteriormente que hay consenso sobre la descomposici√≥n del Modelo en dos subcomponentes: Modelo de Dominio y Modelo de Presentaci√≥n.  Esto significa que puede haber m√°s artistas, no dos, sino tres.  En lugar de una cadena de ejecuci√≥n </p><br><blockquote>  <code></code> &gt;&gt; <code></code> </blockquote><p>  bien puede haber una cadena </p><br><blockquote>  <code> </code> <code> </code> &gt;&gt; <code></code> <code> </code> &gt;&gt; <code></code> </blockquote><p>  La pregunta se plantea: ¬øpor qu√© solo dos o tres?  ¬øY si necesitas m√°s?  La respuesta natural es, por el amor de Dios, ¬°toma todo lo que necesites! </p><br><p>  Otros artistas √∫tiles son inmediatamente visibles: validadores, redirectores, varios renderizadores y, en general, todo lo que es impredecible, pero agradable. </p><br><p>  Recapitulemos: </p><br><blockquote><ul><li>  El nivel ejecutivo MVC ( <code></code> - <code></code> ) se puede implementar como una cadena de enlaces, donde cada enlace convierte la salida del enlace anterior en la entrada para el siguiente. </li><li>  La entrada del primer enlace es la solicitud de la aplicaci√≥n. </li><li>  La salida del √∫ltimo enlace es la respuesta de la aplicaci√≥n a la solicitud. </li></ul><br></blockquote><p>  Llam√© a esta cadena <code>Scenario</code> , pero para los eslabones de la cadena a√∫n no he decidido el nombre.  Las opciones actuales son una escena (como parte de un script), un filtro (como convertidor de datos), una acci√≥n de script.  En t√©rminos generales, el nombre del enlace no es tan importante, hay algo m√°s significativo. </p><br><p>  Las consecuencias de la aparici√≥n del escenario son significativas.  A saber: el escenario asumi√≥ la responsabilidad principal del controlador: determinar el modelo y la presentaci√≥n necesarios para la solicitud y lanzarlos.  Por lo tanto, el controlador solo tiene dos responsabilidades: interactuar con el mundo exterior (solicitud-respuesta) y ejecutar el script.  Y esto es bueno en el sentido de que todos los componentes de la tr√≠ada MVC se descomponen secuencialmente y se vuelven m√°s espec√≠ficos y manejables.  Y sigue siendo bueno en otro aspecto: el controlador MVCS se convierte en una clase inmutable puramente interna y, por lo tanto, incluso en principio, no puede engordar. </p><br><p>  El uso de escenarios conduce a otra variaci√≥n del patr√≥n MVC; llam√© a esta variaci√≥n <strong><code>MVCS</code></strong> - <code>Model-View-Controller-Scenario</code> . </p><br><p>  Y un par de l√≠neas m√°s sobre la descomposici√≥n de MVC.  Los marcos modernos, donde todas las funciones t√≠picas se descomponen al l√≠mite, naturalmente, le quitaron a la parte conceptual MVC de las responsabilidades para interactuar con el mundo exterior.  Por lo tanto, las clases especialmente entrenadas como <code>HTTP </code> y el <code></code> participan en el procesamiento de la solicitud del usuario.  Como resultado, el Controlador no recibe la solicitud inicial del usuario, sino una <code></code> refinada, y esto permite aislar al controlador de los detalles de la solicitud.  Del mismo modo, se realiza un aislamiento de los detalles de la respuesta HTTP, lo que permite que el m√≥dulo MVC defina su propio tipo de respuesta.  Adem√°s, los marcos implementaron completamente los dos componentes de MVC: el modelo de dominio y la plantilla de presentaci√≥n, sin embargo, ya lo discutimos.  Estoy todo esto en el hecho de que el refinamiento y la concreci√≥n de MVC es continuo y continuo, y esto es emocionante. </p><br><h2 id="primer-ispolzovaniya-mvcs">  Ejemplo de MVCS </h2><br><p>  Ahora veamos c√≥mo se puede implementar el ejemplo de <em>Fat Cortroller</em> al comienzo de este art√≠culo en MVCS. </p><br><p>  Comenzamos creando un controlador MVCS: </p><br><pre> <code class="php hljs">$mvcs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MvcsController();</code> </pre> <br><p>  El controlador MVCS recibe una solicitud de un enrutador externo.  Deje que el enrutador convierta el URI del formulario 'usuario / hola / XXX' en tales par√°metros de acci√≥n y solicitud: </p><br><pre> <code class="php hljs">$requestAction = <span class="hljs-string"><span class="hljs-string">'user/hello'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   $requestParams = ['XXX']; //   -  </span></span></code> </pre> <br><p>  Teniendo en cuenta que el controlador MVCS acepta scripts en lugar de URI, debemos asignar algunos scripts a la acci√≥n de la solicitud.  Esto se hace mejor en el contenedor MVCS: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//   MVCS  URI  $mvcs-&gt;set('scenarios', [ 'user/hello' =&gt; 'UserModel &gt; UserViewModel &gt; view, hello', ..., ]);</span></span></code> </pre> <br><p>  Echemos un vistazo m√°s de cerca a este escenario.  Esta es una cadena de tres convertidores de datos separados por un '&gt;': </p><br><ul><li>  'UserModel' es el nombre del modelo de dominio 'Usuario', la entrada del modelo ser√°n los par√°metros de solicitud, la salida ser√°n los datos reales del modelo, </li><li>  'UserViewModel' es el nombre del modelo de vista que convierte los datos del dominio en datos de vista, </li><li>  'view, hello' es la 'plantilla' de la vista del sistema para una plantilla PHP llamada 'hello'. </li></ul><br><p>  Ahora solo necesitamos agregar dos transformadores involucrados en el script como una funci√≥n de cierre al contenedor MVCS: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//   UserModel $mvcs-&gt;set('UserModel', function($id) { $users = [ 1 =&gt; ['first' =&gt; '', 'last' =&gt; ''], 2 =&gt; ['first' =&gt; '', 'last' =&gt; ''], ]; return isset($users[$id]) ? $users[$id] : NULL; }); //   UserViewModel $mvcs-&gt;set('UserViewModel', function($user) { //    PHP  : 'echo "Hello, $name!"'; return ['name' =&gt; $user['first'].' '.$user['last']]; });</span></span></code> </pre> <br><p>  ¬°Y eso es todo!  Para cada solicitud, es necesario determinar el gui√≥n correspondiente y todas sus escenas (excepto las del sistema, como 'vista').  Y nada mas. </p><br><p>  Y ahora estamos listos para probar MVCS para diferentes solicitudes: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//        $scenarios = $mvcs-&gt;get('scenarios'); $scenario = $scenarios[$requestAction]; //      ... //   'user/hello/1'  ' '   'hello' $requestParams = ['1']; $response = $mvcs-&gt;play($scenario, $requestParams); //   'user/hello/2'  ' '   'hello' $requestParams = ['2']; $response = $mvcs-&gt;play($scenario, $requestParams);</span></span></code> </pre> <br><blockquote>  <em>La implementaci√≥n de PHP MVCS est√° alojada en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github.com</a> .</em> <br>  <em>Este ejemplo est√° en el directorio MVCS de <code>example</code> .</em> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es424595/">https://habr.com/ru/post/es424595/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es424585/index.html">CryEngine 5.5 lanzado por Crytek</a></li>
<li><a href="../es424587/index.html">Resumen del libro "Ventas a grandes empresas"</a></li>
<li><a href="../es424589/index.html">C√≥mo inscribirse en un programa de doctorado de aprendizaje autom√°tico</a></li>
<li><a href="../es424591/index.html">No hay ideal: c√≥mo busqu√© un lenguaje de programaci√≥n para m√≠</a></li>
<li><a href="../es424593/index.html">C ++ 11 y manejo de eventos</a></li>
<li><a href="../es424597/index.html">Entrevista con el orador de la Conferencia de RubyRussia, Marcus Schirp</a></li>
<li><a href="../es424599/index.html">Debe elegir qu√© software necesita: escrito a tiempo o de alta calidad</a></li>
<li><a href="../es424601/index.html">Arquitectura de la informaci√≥n en Internet parte 1</a></li>
<li><a href="../es424603/index.html">El libro "¬øPor qu√© nos equivocamos? Trampas de pensamiento en acci√≥n ". Extractos Parte 1</a></li>
<li><a href="../es424605/index.html">Fondos de Zuckerberg: colaboraci√≥n + tecnolog√≠a + ciencia abierta</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>