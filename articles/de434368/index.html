<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚§¥Ô∏è „ÄΩÔ∏è üë®‚Äçüåæ Maschinelles Lernen zum Auffinden von Fehlern im Code: Wie ich bei JetBrains Research interniert habe üí≥ ‚õëÔ∏è üìã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="K√ºrzlich haben wir dar√ºber gesprochen, wie man ein Praktikum bei Google bekommt. Neben Google versuchen sich unsere Sch√ºler bei JetBrains, Yandex, Acr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Maschinelles Lernen zum Auffinden von Fehlern im Code: Wie ich bei JetBrains Research interniert habe</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hsespb/blog/434368/">  K√ºrzlich haben wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dar√ºber gesprochen,</a> wie man ein Praktikum bei Google bekommt.  Neben Google versuchen sich unsere Sch√ºler bei JetBrains, Yandex, Acronis und anderen Unternehmen. <br><br>  In diesem Artikel werde ich meine Praktikumserfahrung bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JetBrains Research</a> teilen, √ºber die Aufgaben sprechen, die sie dort l√∂sen, und dar√ºber nachdenken, wie maschinelles Lernen nach Fehlern im Programmcode suchen kann. <br><br><img src="https://habrastorage.org/webt/gf/xa/bh/gfxabh9xemshdpmkrr48vind45a.jpeg"><br><a name="habracut"></a><br><h2>  √úber mich </h2><br>  Mein Name ist Yegor Bogomolov, ich bin ein Student des 4. Studienjahres des HSE-Grundstudiums in Angewandter Mathematik und Informatik in St. Petersburg.  In den ersten drei Jahren habe ich wie meine Klassenkameraden an der Akademischen Universit√§t studiert und seit September sind wir mit der gesamten Abteilung an die Higher School of Economics gewechselt. <br><br>  Nach dem 2. Jahr habe ich ein Sommerpraktikum bei Google Z√ºrich absolviert.  Dort habe ich drei Monate im Android Calendar-Team gearbeitet, die meiste Zeit Frontend'om und ein bisschen UX-Recherche.  Der interessanteste Teil meiner Arbeit war die Untersuchung, wie Kalenderschnittstellen in Zukunft aussehen k√∂nnten.  Es stellte sich als angenehm heraus, dass fast die gesamte Arbeit, die ich am Ende des Praktikums geleistet habe, in der Hauptversion der Bewerbung landete.  Das Thema Praktika bei Google wurde jedoch in einem fr√ºheren Beitrag sehr gut behandelt. Ich werde daher dar√ºber sprechen, was ich diesen Sommer gemacht habe. <br><br><h2>  Was ist JB Research? </h2><br>  JetBrains Research besteht aus einer Reihe von Labors, die in verschiedenen Bereichen arbeiten: Programmiersprachen, angewandte Mathematik, maschinelles Lernen, Robotik und andere.  In jedem Bereich gibt es mehrere wissenschaftliche Gruppen.  Aufgrund meiner Anleitung bin ich am besten mit den Aktivit√§ten von Gruppen im Bereich des maschinellen Lernens vertraut.  Jeder von ihnen veranstaltet w√∂chentliche Seminare, in denen Gruppenmitglieder oder geladene G√§ste √ºber ihre Arbeit oder interessante Artikel auf ihrem Gebiet sprechen.  Viele Studenten der HSE kommen zu diesen Seminaren, wenn sie vom Hauptgeb√§ude des HSE-Campus in St. Petersburg √ºber die Stra√üe gehen. <br><br>  In unserem Bachelor-Studiengang besch√§ftigen wir uns notwendigerweise mit Forschungsarbeiten (F &amp; E) und pr√§sentieren die Forschungsergebnisse zweimal im Jahr.  Oft entwickelt sich diese Arbeit allm√§hlich zu Sommerpraktika.  Dies geschah auch mit meiner Forschungsarbeit: Diesen Sommer habe ich bei meinem Forschungsleiter Timofey Bryksin ein Praktikum im Labor ‚ÄûMethoden des maschinellen Lernens in der Softwareentwicklung‚Äú absolviert.  Zu den Aufgaben, an denen in diesem Labor gearbeitet wird, geh√∂ren Vorschl√§ge f√ºr die automatische Umgestaltung, die Analyse des Codestils f√ºr Programmierer, die Code-Vervollst√§ndigung und die Suche nach Fehlern im Programmcode. <br><br>  Mein Praktikum dauerte zwei Monate (Juli und August), und im Herbst besch√§ftigte ich mich weiterhin mit zugewiesenen Aufgaben im Rahmen der Forschung.  Ich habe in verschiedenen Bereichen gearbeitet, von denen meiner Meinung nach die automatische Suche nach Fehlern im Code am interessantesten war, und ich m√∂chte dar√ºber sprechen.  Ausgangspunkt war <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Artikel von Michael Pradel</a> . <br><br><h2>  Automatische Fehlersuche </h2><br><h3>  Wie werden Fehler jetzt gesucht? </h3><br>  Warum nach Fehlern suchen, ist mehr oder weniger klar.  Mal sehen, wie es ihnen jetzt geht.  Moderne Fehlerdetektoren basieren haupts√§chlich auf statischer Code-Analyse.  Suchen Sie f√ºr jeden Fehlertyp nach zuvor festgestellten Mustern, anhand derer er bestimmt werden kann.  Um die Anzahl der falsch positiven Ergebnisse zu verringern, werden Heuristiken erfunden, die f√ºr jeden Einzelfall erfunden werden.  Muster k√∂nnen sowohl in einem durch Code erstellten abstrakten Syntaxbaum (AST) als auch in Diagrammen eines Kontrollflusses oder von Daten gesucht werden. <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) || x &gt; MAX) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = bar(x); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br><img src="https://habrastorage.org/webt/76/8t/wn/768twn22o7j83mwak6x-n9kw5d4.png"><br><br>  Der Code und der darauf erstellte Baum. <br><br>  Betrachten Sie ein Beispiel, um zu verstehen, wie dies funktioniert.  Die Art von Fehlern kann die Verwendung von = anstelle von == in C ++ sein.  Schauen wir uns den folgenden Code an: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = <span class="hljs-number"><span class="hljs-number">0</span></span>; ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value = <span class="hljs-number"><span class="hljs-number">1</span></span>) { ... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ‚Ä¶ }</code> </pre><br>  Es gab einen Fehler im bedingten Ausdruck, w√§hrend das erste = bei der Zuordnung des Werts zur Variablen korrekt ist.  Das Muster stammt von hier: Wenn die Zuweisung innerhalb der Bedingung in if verwendet wird, ist dies ein potenzieller Fehler.  Wenn Sie in AST nach einem solchen Muster suchen, k√∂nnen wir den Fehler erkennen und korrigieren. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = <span class="hljs-number"><span class="hljs-number">0</span></span>; ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == <span class="hljs-number"><span class="hljs-number">1</span></span>) { ... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ‚Ä¶ }</code> </pre><br>  In einem allgemeineren Fall k√∂nnen wir den Fehler nicht so einfach beschreiben.  Angenommen, wir m√∂chten die richtige Reihenfolge der Operanden bestimmen.  Schauen Sie sich noch einmal die Codefragmente an: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; n; i++) { a[i] = a[<span class="hljs-number"><span class="hljs-number">1</span></span> - i] + a[i - <span class="hljs-number"><span class="hljs-number">2</span></span>]; }</code> </pre><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bitReverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> - i; }</code> </pre><br>  Im ersten Fall war die Verwendung von 1-i fehlerhaft, und im zweiten Fall war sie v√∂llig korrekt, was aus dem Kontext hervorgeht.  Aber wie soll man es in Form eines Musters beschreiben?  Mit der Komplikation der Art der Fehler m√ºssen wir einen gr√∂√üeren Codeabschnitt ber√ºcksichtigen und immer mehr Einzelf√§lle analysieren. <br><br>  Das letzte motivierende Beispiel: N√ºtzliche Informationen sind auch in den Namen von Methoden und Variablen enthalten.  Es ist noch schwieriger, sich durch einige manuell festgelegte Bedingungen auszudr√ºcken. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSquare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDim, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> yDim)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">3</span></span>, y = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s = getSquare(y, x);</code> </pre><br>  Eine Person versteht, dass die Argumente im Funktionsaufruf h√∂chstwahrscheinlich verwechselt sind, weil wir verstehen, dass x eher xDim als yDim √§hnelt.  Aber wie soll man das dem Detektor melden?  Sie k√∂nnen eine Art Heuristik der Form "Der Variablenname ist das Pr√§fix des Argumentnamens" hinzuf√ºgen. Nehmen Sie jedoch an, dass x h√§ufiger eine Breite als eine H√∂he ist, also nicht mehr ausdr√ºcken. <br><br>  Fazit: Das Problem des modernen Ansatzes zum Auffinden von Fehlern besteht darin, dass viel Arbeit mit Ihren H√§nden erledigt werden muss: Um Muster zu bestimmen, f√ºgen Sie Heuristiken hinzu. Aus diesem Grund wird das Hinzuf√ºgen von Unterst√ºtzung f√ºr einen neuen Fehlertyp im Detektor zeitaufw√§ndig.  Dar√ºber hinaus ist es schwierig, einen wichtigen Teil der Informationen zu verwenden, die der Entwickler im Code hinterlassen hat: die Namen von Variablen und Methoden. <br><br><h3>  Wie kann maschinelles Lernen helfen? </h3><br>  Wie Sie vielleicht bemerkt haben, sind in vielen Beispielen Fehler f√ºr Menschen sichtbar, aber formal schwer zu beschreiben.  In solchen Situationen k√∂nnen maschinelle Lernmethoden oft helfen.  H√∂ren wir auf, in einem Funktionsaufruf nach neu angeordneten Argumenten zu suchen, und verstehen, was wir brauchen, um sie mithilfe von maschinellem Lernen zu suchen: <br><br><ol><li>  Eine gro√üe Anzahl von Beispielcode ohne Fehler </li><li>  Eine gro√üe Menge an Code mit Fehlern eines bestimmten Typs </li><li>  Methode zur Vektorisierung von Codefragmenten </li><li>  Das Modell, das wir lehren werden, um zwischen Code mit und ohne Fehler zu unterscheiden </li></ol><br>  Wir k√∂nnen hoffen, dass in den meisten √∂ffentlich zug√§nglichen Codes die Argumente in den Funktionsaufrufen in der richtigen Reihenfolge sind.  Daher k√∂nnen Sie f√ºr Beispielcode ohne Fehler einen gro√üen Datensatz verwenden.  Im Fall des Autors des Originalartikels war es JS 150K (150.000 Dateien in Javascript), in unserem Fall ein √§hnlicher Datensatz f√ºr Python. <br><br>  Das Finden von Code mit Fehlern ist viel schwieriger.  Aber wir k√∂nnen nicht nach Fehlern anderer suchen, sondern sie selbst machen!  F√ºr die Art der Fehler m√ºssen Sie eine Funktion angeben, die sie gem√§√ü dem richtigen Code besch√§digt.  In unserem Fall ordnen Sie die Argumente im Funktionsaufruf neu an. <br><br><h3>  Wie vektorisiere ich den Code? </h3><br>  Mit viel gutem und schlechtem Code sind wir fast bereit, etwas zu lehren.  Vorher m√ºssen wir noch die Frage beantworten: Wie werden Codefragmente dargestellt? <br><br>  Ein Funktionsaufruf kann als Tupel aus dem Namen einer Methode, dem Namen ihrer Methode, den Namen und Typen von Argumenten dargestellt werden, die an Variablen √ºbergeben werden.  Wenn wir lernen, wie man einzelne Token vektorisiert (Namen von Variablen und Methoden, alle im Code enthaltenen ‚ÄûW√∂rter‚Äú), k√∂nnen wir die Verkettung von Vektoren von Token von Interesse f√ºr uns nehmen und den gew√ºnschten Vektor f√ºr das Fragment erhalten. <br><br>  Um Token zu vektorisieren, schauen wir uns an, wie W√∂rter in gew√∂hnlichen Texten vektorisieren.  Eine der erfolgreichsten und beliebtesten M√∂glichkeiten ist das 2013 vorgeschlagene word2vec. <br><br><img src="https://habrastorage.org/webt/kj/0o/pp/kj0opp-scftpuqr16t5c9fj1uv0.png"><br><br>  Es funktioniert wie folgt: Wir bringen dem Netzwerk bei, andere W√∂rter, die in Texten daneben erscheinen, durch Worte vorherzusagen.  Das Netzwerk sieht gleichzeitig aus wie eine Eingabeebene von der Gr√∂√üe eines W√∂rterbuchs, eine verborgene Ebene von der Gr√∂√üe der Vektorisierung, die wir erhalten m√∂chten, und eine Ausgabeschicht, die ebenfalls die Gr√∂√üe eines W√∂rterbuchs hat.  W√§hrend des Trainings werden die Netzwerke mit einem Eingabeeinheitenvektor mit einer Einheit anstelle des betreffenden Wortes (Fuchs) gespeist, und an der Ausgabe m√∂chten wir W√∂rter erhalten, die innerhalb des Fensters um dieses Wort auftreten (schnell, braun, springt, √ºber).  In diesem Fall √ºbersetzt das Netzwerk zuerst alle W√∂rter in einen Vektor auf einer verborgenen Ebene und macht dann eine Vorhersage. <br><br>  Die resultierenden Vektoren f√ºr einzelne W√∂rter haben gute Eigenschaften.  Beispielsweise sind Wortvektoren mit einer √§hnlichen Bedeutung nahe beieinander, und die Summe und Differenz der Vektoren sind die Addition und Differenz der "Bedeutungen" der W√∂rter. <br><br>  Um eine √§hnliche Vektorisierung von Token im Code vorzunehmen, m√ºssen Sie die vorhergesagte Umgebung irgendwie festlegen.  Dies k√∂nnen Informationen von AST sein: Arten von Scheitelpunkten, angetroffene Token, Position in einem Baum. <br><br>  Nachdem Sie eine Vektorisierung erhalten haben, k√∂nnen Sie sehen, welche Token einander √§hnlich sind.  Berechnen Sie dazu den Kosinusabstand zwischen ihnen.  Als Ergebnis werden die folgenden benachbarten Vektoren f√ºr Javascript erhalten (Zahl ist der Kosinusabstand): <br><br><img src="https://habrastorage.org/webt/lf/q0/4q/lfq04qjp4fcygqjikgy0zq9av8y.png"><br><br>  Die am Anfang hinzugef√ºgte ID und LIT geben an, ob das Token ein Bezeichner (Name einer Variablen, Methode) oder ein Literal (Konstante) ist.  Es ist ersichtlich, dass die N√§he sinnvoll ist. <br><br><h3>  Klassifikator Training </h3><br>  Nachdem Sie eine Vektorisierung f√ºr einzelne Token erhalten haben, ist es ganz einfach, eine Ansicht f√ºr einen Code mit einem potenziellen Fehler zu erhalten: Es handelt sich um eine Verkettung von Vektoren, die f√ºr die Klassifizierung von Token wichtig sind.  Ein zweischichtiges Perzeptron wird in Codeteilen mit ReLU als Aktivierungsfunktion und Dropout trainiert, um eine √úberanpassung zu reduzieren.  Das Lernen konvergiert schnell, das resultierende Modell ist klein und kann Vorhersagen f√ºr Hunderte von Beispielen pro Sekunde treffen.  Auf diese Weise k√∂nnen Sie es in Echtzeit verwenden, was sp√§ter erl√§utert wird. <br><br><h3>  Ergebnisse </h3><br>  Die Qualit√§tsbewertung des resultierenden Klassifikators wurde in zwei Teile unterteilt: Bewertung einer gro√üen Anzahl k√ºnstlich erzeugter Beispiele und manuelle √úberpr√ºfung einer kleinen Anzahl (50 f√ºr jeden Detektor) von Beispielen mit der h√∂chsten vorhergesagten Wahrscheinlichkeit.  Die Ergebnisse f√ºr die drei Detektoren (neu angeordnete Argumente, die Richtigkeit des bin√§ren Operators und des bin√§ren Operanden) waren wie folgt: <br><br><img src="https://habrastorage.org/webt/n9/f5/sm/n9f5smfdvj55bw3qeb-l_y9jub0.png"><br><br>  Einige der vorhergesagten Fehler w√§ren mit klassischen Suchmethoden schwer zu finden.  Ein Beispiel mit neu angeordneten res und err in einem Aufruf von p.done: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> (); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( promises === <span class="hljs-literal"><span class="hljs-literal">null</span></span> || promises . length === <span class="hljs-number"><span class="hljs-number">0</span></span>) { p. done (error , result ) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { promises [<span class="hljs-number"><span class="hljs-number">0</span></span>](error, result).then( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res, err</span></span></span><span class="hljs-function">) </span></span>{ p.done(res, err); }); }</code> </pre><br>  Es gab auch Beispiele, bei denen kein Fehler auftrat, die Variablen jedoch umbenannt werden sollten, um die Person, die versucht, den Code herauszufinden, nicht irrezuf√ºhren.  Zum Beispiel scheint das Hinzuf√ºgen von Breite und jeder keine gute Idee zu sein, obwohl sich herausstellte, dass dies kein Fehler ist: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cw = cs[i].width + each;</code> </pre><br><h3>  Python-Portierung </h3><br>  Ich war daran beteiligt, Michael Pradels Arbeit von js auf Python zu portieren und dann ein Plug-In f√ºr PyCharm zu erstellen, das Inspektionen basierend auf der oben beschriebenen Methode implementiert.  Wir haben den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Python 150K-</a> Datensatz verwendet (150.000 Python-Dateien auf GitHub verf√ºgbar). <br><br>  Zun√§chst stellte sich heraus, dass es in Python mehr verschiedene Token als in Javascript gibt.  F√ºr js machten die 10.000 beliebtesten Token mehr als 90% aller angetroffenen Token aus, w√§hrend f√ºr Python etwa 40.000 verwendet werden mussten. Dies f√ºhrte zu einer Vergr√∂√üerung der Token in Vektoren, was die Portierung auf das Plugin schwierig machte. <br><br>  Zweitens, nachdem ich f√ºr Python eine Suche nach falschen Argumenten in Funktionsaufrufen implementiert und die Ergebnisse manuell betrachtet hatte, erhielt ich eine Fehlerrate von mehr als 90%, was im Widerspruch zu den Ergebnissen f√ºr js stand.  Nachdem ich die Gr√ºnde verstanden hatte, stellte sich heraus, dass in Javascript mehr Funktionen in derselben Datei deklariert wurden wie ihre Aufrufe.  Nach dem Beispiel des Autors des Artikels habe ich zun√§chst die Deklaration von Funktionen aus anderen Dateien nicht zugelassen, was zu schlechten Ergebnissen f√ºhrte. <br><br>  Gegen Ende August habe ich die Implementierung f√ºr Python abgeschlossen und die Basis f√ºr das Plugin geschrieben.  Das Plugin wird weiterentwickelt, jetzt ist die Studentin Anastasia Tuchina aus unserem Labor damit besch√§ftigt. <br><br>  Die Schritte zum Testen der Funktionsweise des Plugins finden Sie im Repository-Wiki. <br><br>  Links auf Github: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository mit Python-Implementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository mit Plugin</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de434368/">https://habr.com/ru/post/de434368/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de434356/index.html">Python Stiller mit E-Mail</a></li>
<li><a href="../de434358/index.html">Importsubstitution von Betriebssystemen. Wie sehe ich ein inl√§ndisches Betriebssystem?</a></li>
<li><a href="../de434360/index.html">Erkl√§rtes Gespr√§ch √ºber asynchrone Programmierung in Javascript</a></li>
<li><a href="../de434362/index.html">NICHT f√ºr 2019 prognostiziert</a></li>
<li><a href="../de434364/index.html">Hangfire Queue-Unterst√ºtzung</a></li>
<li><a href="../de434370/index.html">Ein weiterer Schatteneroberer in Phaser oder die Verwendung von Fahrr√§dern</a></li>
<li><a href="../de434374/index.html">RBAC in Kubernetes √ºberpr√ºfen</a></li>
<li><a href="../de434380/index.html">Grundlagen der Abh√§ngigkeitsinjektion</a></li>
<li><a href="../de434382/index.html">Portierung von Alpine Linux auf RISC-V</a></li>
<li><a href="../de434384/index.html">Auf die Verantwortung der Darsteller</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>