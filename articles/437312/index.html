<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÖ üí† üêøÔ∏è Implementaci√≥n de una recarga en caliente de c√≥digo C ++ en Linux y macOS: profundizando üåÆ ü¶Ö ‚ñ´Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="* Enlace a la biblioteca y video de demostraci√≥n al final del art√≠culo. Para entender lo que est√° sucediendo y qui√©nes son todas estas personas, recom...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementaci√≥n de una recarga en caliente de c√≥digo C ++ en Linux y macOS: profundizando</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437312/"><p><img src="https://habrastorage.org/webt/cz/hn/wz/czhnwzufandjpr6jf5cwj1j3p48.png"></p><br><p>  * Enlace a la biblioteca y video de demostraci√≥n al final del art√≠culo.  Para entender lo que est√° sucediendo y qui√©nes son todas estas personas, recomiendo leer el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo anterior</a> . </p><br><p>  En el √∫ltimo art√≠culo, nos familiarizamos con un enfoque que permite una recarga en caliente del c√≥digo c ++.  El "c√≥digo" en este caso son funciones, datos y su trabajo coordinado entre s√≠.  No hay problemas especiales con las funciones, redirigimos el flujo de ejecuci√≥n de la funci√≥n anterior a la nueva, y todo funciona.  El problema surge con los datos (variables est√°ticas y globales), es decir, con la estrategia de su sincronizaci√≥n en el c√≥digo antiguo y nuevo.  En la primera implementaci√≥n, esta estrategia fue muy torpe: simplemente copiamos los valores de todas las variables est√°ticas del c√≥digo antiguo al nuevo, de modo que el nuevo c√≥digo, refiri√©ndose a las nuevas variables, funciona con los valores del c√≥digo anterior.  Por supuesto, esto es incorrecto, y hoy trataremos de corregir esta falla resolviendo simult√°neamente una serie de problemas peque√±os pero interesantes. </p><br><p>  El art√≠culo omite detalles sobre el trabajo mec√°nico, como la lectura de personajes y reubicaciones de archivos elf y mach-o.  El √©nfasis est√° en los puntos sutiles que encontr√© en el proceso de implementaci√≥n, y que pueden ser √∫tiles para alguien que, como yo recientemente, est√° buscando respuestas. </p><a name="habracut"></a><br><h3 id="sut">  Esencia </h3><br><p>  Imaginemos que tenemos una clase (ejemplos sint√©ticos, no busquen significado en ellos, solo el c√≥digo es importante): </p><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Entity.hpp class Entity { public: Entity(const std::string&amp; description); ~Entity(); void printDescription(); static int getLivingEntitiesCount(); private: static int m_livingEntitiesCount; std::string m_description; }; // Entity.cpp int Entity::m_livingEntitiesCount = 0; Entity::Entity(const std::string&amp; description) : m_description(description) { m_livingEntitiesCount++; } Entity::~Entity() { m_livingEntitiesCount--; } int Entity::getLivingEntitiesCount() { return m_livingEntitiesCount; } void Entity::printDesctiption() { std::cout &lt;&lt; m_description &lt;&lt; std::endl; }</span></span></code> </pre> <br><p>  Nada especial sino una variable est√°tica.  Ahora imagine que queremos cambiar el m√©todo <code>printDescription()</code> a: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Entity::printDescription() { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"DESCRIPTION: "</span></span> &lt;&lt; m_description &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br><p>  ¬øQu√© sucede despu√©s de recargar el c√≥digo?  Adem√°s de los m√©todos de la clase <code>Entity</code> , la variable est√°tica <code>m_livingEntitiesCount</code> tambi√©n <code>m_livingEntitiesCount</code> a la biblioteca con el nuevo c√≥digo.  No pasar√° nada malo si simplemente copiamos el valor de esta variable del c√≥digo antiguo al nuevo y continuamos usando la nueva variable, olvidando la anterior, porque todos los m√©todos que usan esta variable directamente est√°n en la biblioteca con el nuevo c√≥digo. </p><br><p>  C ++ es muy flexible y rico.  Y aunque la elegancia de resolver algunos problemas en c ++ bordea el c√≥digo maloliente, me encanta este lenguaje.  Por ejemplo, imagine que su proyecto no usa rtti.  Al mismo tiempo, debe tener una implementaci√≥n de la clase <code>Any</code> con una interfaz de tipo seguro: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Any</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Any</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp;&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } };</code> </pre> <br><p>  No entraremos en detalles sobre la implementaci√≥n de esta clase.  Lo importante para nosotros es que para la implementaci√≥n necesitamos alg√∫n tipo de mecanismo para el mapeo inequ√≠voco del tipo (entidad de tiempo de compilaci√≥n) en el valor de una variable, por ejemplo, <code>uint64_t</code> (entidad de tiempo de ejecuci√≥n), es decir, "enumerar" tipos.  Cuando utilizamos rtti, tenemos a nuestra disposici√≥n cosas como <code>type_info</code> y, m√°s adecuado para nosotros, <code>type_index</code> .  Pero no tenemos rtti.  En este caso, un truco bastante com√∫n (¬øo una soluci√≥n elegante?) ¬øEs esta funci√≥n: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> typeId() { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> someVar; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>&gt;(&amp;someVar); }</code> </pre> <br><p>  Entonces la implementaci√≥n de la clase <code>Any</code> se ver√° as√≠: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Any</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Any</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp;&amp; value)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_typeId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(typeId&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::decay&lt;T&gt;::type&gt;())</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// copy or move value somewhere {} template &lt;typename T&gt; bool is() const { return m_typeId == typeId&lt;std::decay&lt;T&gt;::type&gt;(); } template &lt;typename T&gt; T&amp; as() { ... } private: uint64_t m_typeId = 0; };</span></span></span></span></code> </pre> <br><p>  Para cada tipo, la funci√≥n se instanciar√° exactamente 1 vez, respectivamente, cada versi√≥n de la funci√≥n tendr√° su propia variable est√°tica, obviamente con su propia direcci√≥n √∫nica.  ¬øQu√© sucede cuando recargamos el c√≥digo usando esta funci√≥n?  Las llamadas a la versi√≥n anterior de la funci√≥n ser√°n redirigidas a la nueva.  La nueva tendr√° su propia variable est√°tica ya inicializada (copiamos el valor y la variable de protecci√≥n).  Pero no nos interesa el significado, solo usamos la direcci√≥n.  Y la direcci√≥n de la nueva variable ser√° diferente.  Por lo tanto, los datos se volvieron inconsistentes: en las instancias ya creadas de la clase <code>Any</code> , la direcci√≥n de la antigua variable est√°tica se almacenar√°, y el m√©todo <code>is()</code> comparar√° con la direcci√≥n de la nueva, y "este <code>Any</code> ya no ser√° el mismo <code>Any</code> " ¬©. </p><br><h3 id="plan">  Plan </h3><br><p>  Para resolver este problema, necesita algo m√°s inteligente que simplemente copiar.  Despu√©s de pasar un par de noches en Google, leer la documentaci√≥n, los c√≥digos fuente y la API del sistema, se me ocurri√≥ el siguiente plan: </p><br><ol><li>  Despu√©s de construir el nuevo c√≥digo, pasamos por las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">reubicaciones</a> . </li><li>  De estas reubicaciones obtenemos todos los lugares en el c√≥digo que usan variables est√°ticas (y a veces globales). </li><li>  En lugar de direcciones a nuevas versiones de variables, sustituimos las direcciones de versiones antiguas en el lugar de reubicaci√≥n. </li></ol><br><p>  En este caso, no habr√° enlaces a datos nuevos, toda la aplicaci√≥n continuar√° funcionando con versiones antiguas de variables hasta la direcci√≥n.  Eso deber√≠a funcionar.  Esto no puede dejar de funcionar. </p><br><h3 id="relokacii">  Reubicaciones </h3><br><p>  Cuando el compilador genera c√≥digo de m√°quina, inserta varios bytes suficientes para escribir la direcci√≥n real de la variable o funci√≥n en este lugar en cada lugar donde se llama la funci√≥n o se carga la direcci√≥n de la variable, y tambi√©n genera una reubicaci√≥n.  No puede registrar de inmediato la direcci√≥n real, porque en este momento no conoce esta direcci√≥n.  Las funciones y variables despu√©s del enlace pueden estar en diferentes secciones, en diferentes lugares de secciones, en las secciones finales se pueden cargar en diferentes direcciones en tiempo de ejecuci√≥n. </p><br><p>  La reubicaci√≥n contiene informaci√≥n: </p><br><ul><li>  ¬øQu√© direcci√≥n necesita para escribir la direcci√≥n de la funci√≥n o variable? </li><li>  La direcci√≥n de qu√© funci√≥n o variable escribir </li><li>  La f√≥rmula por la cual se debe calcular esta direcci√≥n </li><li>  ¬øCu√°ntos bytes est√°n reservados para esta direcci√≥n? </li></ul><br><p>  En diferentes sistemas operativos, las reubicaciones se representan de manera diferente, pero al final todas funcionan con el mismo principio.  Por ejemplo, en elf (Linux), las reubicaciones se ubican en secciones especiales <code>.rela</code> (en la versi√≥n de 32 bits, esto es <code>.rel</code> ), que se refieren a la secci√≥n con la direcci√≥n que debe corregirse (por ejemplo, <code>.rela.text</code> , la secci√≥n en la que se ubican las reubicaciones, aplicado a la secci√≥n <code>.text</code> ), y cada entrada almacena informaci√≥n sobre el s√≠mbolo cuya direcci√≥n desea insertar en el sitio de reubicaci√≥n.  En mach-o (macOS), lo opuesto es el caso; no hay una secci√≥n separada para reubicaciones; en cambio, cada secci√≥n contiene un puntero a una tabla de reubicaciones que debe aplicarse a esta secci√≥n, y cada registro en esta tabla tiene una referencia a un s√≠mbolo relacional. <br>  Por ejemplo, para dicho c√≥digo (con la opci√≥n <code>-fPIC</code> ): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> globalVariable = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">veryUsefulFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> functionLocalVariable = <span class="hljs-number"><span class="hljs-number">0</span></span>; functionLocalVariable++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> globalVariable + functionLocalVariable; }</code> </pre> <br><p>  el compilador crear√° una secci√≥n con reubicaciones en Linux: </p><br><pre> <code class="plaintext hljs">Relocation section '.rela.text' at offset 0x1a0 contains 4 entries: Offset Info Type Symbol's Value Symbol's Name + Addend 0000000000000007 0000000600000009 R_X86_64_GOTPCREL 0000000000000000 globalVariable - 4 000000000000000d 0000000400000002 R_X86_64_PC32 0000000000000000 .bss - 4 0000000000000016 0000000400000002 R_X86_64_PC32 0000000000000000 .bss - 4 000000000000001e 0000000400000002 R_X86_64_PC32 0000000000000000 .bss - 4</code> </pre> <br><p>  y tal tabla de reubicaci√≥n en macOS: </p><br><pre> <code class="plaintext hljs">RELOCATION RECORDS FOR [__text]: 000000000000001b X86_64_RELOC_SIGNED __ZZ18veryUsefulFunctionvE21functionLocalVariable 0000000000000015 X86_64_RELOC_SIGNED _globalVariable 000000000000000f X86_64_RELOC_SIGNED __ZZ18veryUsefulFunctionvE21functionLocalVariable 0000000000000006 X86_64_RELOC_SIGNED __ZZ18veryUsefulFunctionvE21functionLocalVariable</code> </pre> <br><p>  Y aqu√≠ est√° la funci√≥n <code>veryUsefulFunction()</code> (en Linux): </p><br><pre> <code class="plaintext hljs">0000000000000000 &lt;_Z18veryUsefulFunctionv&gt;: 0: 55 push rbp 1: 48 89 e5 mov rbp,rsp 4: 48 8b 05 00 00 00 00 mov rax,QWORD PTR [rip+0x0] b: 8b 0d 00 00 00 00 mov ecx,DWORD PTR [rip+0x0] 11: 83 c1 01 add ecx,0x1 14: 89 0d 00 00 00 00 mov DWORD PTR [rip+0x0],ecx 1a: 8b 08 mov ecx,DWORD PTR [rax] 1c: 03 0d 00 00 00 00 add ecx,DWORD PTR [rip+0x0] 22: 89 c8 mov eax,ecx 24: 5d pop rbp 25: c3 ret</code> </pre> <br><p>  y luego, despu√©s de vincular el objeto a la biblioteca din√°mica: </p><br><pre> <code class="plaintext hljs">00000000000010e0 &lt;_Z18veryUsefulFunctionv&gt;: 10e0: 55 push rbp 10e1: 48 89 e5 mov rbp,rsp 10e4: 48 8b 05 05 21 00 00 mov rax,QWORD PTR [rip+0x2105] 10eb: 8b 0d 13 2f 00 00 mov ecx,DWORD PTR [rip+0x2f13] 10f1: 83 c1 01 add ecx,0x1 10f4: 89 0d 0a 2f 00 00 mov DWORD PTR [rip+0x2f0a],ecx 10fa: 8b 08 mov ecx,DWORD PTR [rax] 10fc: 03 0d 02 2f 00 00 add ecx,DWORD PTR [rip+0x2f02] 1102: 89 c8 mov eax,ecx 1104: 5d pop rbp 1105: c3 ret</code> </pre> <br><p>  Hay 4 lugares en los que 4 bytes est√°n reservados para la direcci√≥n de variables reales. </p><br><p>  En diferentes sistemas, el conjunto de posibles reubicaciones es suyo.  En Linux en x86-64, hasta <a href="">40 tipos de reubicaciones</a> .  Solo hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">9 de</a> ellos en macOS en x86-64.  Todos los tipos de reubicaciones se pueden dividir condicionalmente en 2 grupos: </p><br><ol><li>  Reubicaciones en tiempo de enlace: reubicaciones utilizadas en el proceso de vincular archivos de objetos a un archivo ejecutable o biblioteca din√°mica </li><li>  Reubicaciones de tiempo de carga: reubicaciones aplicadas en el momento en que la biblioteca din√°mica se carga en la memoria del proceso </li></ol><br><p>  El segundo grupo incluye reubicaciones de funciones y variables exportadas.  Cuando se carga una biblioteca din√°mica en la memoria del proceso, para todas las reubicaciones din√°micas (incluidas las reubicaciones de variables globales), el vinculador busca la definici√≥n de s√≠mbolos en todas las bibliotecas ya cargadas, incluido el propio programa, y ‚Äã‚Äãla direcci√≥n del primer s√≠mbolo adecuado se usa para la reubicaci√≥n.  Por lo tanto, no es necesario hacer nada con estas reubicaciones; el vinculador encontrar√° la variable de nuestra aplicaci√≥n, ya que entrar√° en su lista de bibliotecas y programas cargados anteriormente, y sustituir√° su direcci√≥n en el nuevo c√≥digo, ignorando la nueva versi√≥n de esta variable. </p><br><p>  Hay un punto sutil asociado con macOS y su vinculador din√°mico.  MacOS implementa el llamado mecanismo de espacio de nombres de dos niveles.  Si es grosero, al cargar una biblioteca din√°mica, el vinculador primero buscar√° caracteres en esta biblioteca y, si no lo encuentra, buscar√° en otros.  Esto se hace con fines de rendimiento, para que las reubicaciones se resuelvan r√°pidamente, lo que, en general, es l√≥gico.  Pero esto rompe nuestro flujo con respecto a las variables globales.  Afortunadamente, en ld en macOS hay un indicador especial: <code>-flat_namespace</code> , y si construye una biblioteca con este indicador, el algoritmo de b√∫squeda de caracteres ser√° id√©ntico al de Linux. </p><br><p>  El primer grupo incluye reubicaciones de variables est√°ticas, exactamente lo que necesitamos.  El √∫nico problema es que estas reubicaciones no est√°n en la biblioteca compilada, ya que el vinculador ya las resolvi√≥.  Por lo tanto, los leeremos de los archivos de objetos desde los cuales se ensambl√≥ la biblioteca. <br>  Los posibles tipos de reubicaciones tambi√©n est√°n limitados por si el c√≥digo ensamblado depende de la posici√≥n o no.  Dado que recopilamos nuestro c√≥digo en modo PIC (c√≥digo independiente de la posici√≥n), las reubicaciones se usan solo de forma relativa.  Las reubicaciones totales que nos interesan son: </p><br><ul><li>  Reubicaciones desde la secci√≥n <code>.rela.text</code> en Linux y las reubicaciones a las que hace referencia la secci√≥n <code>__text</code> en macOS, y </li><li>  Que usa caracteres de las secciones <code>.data</code> y <code>.bss</code> en Linux y <code>__data</code> , <code>__bss</code> y <code>__common</code> en macOS, y </li><li>  Las reubicaciones son de tipo <code>R_X86_64_PC32</code> y <code>R_X86_64_PC64</code> en Linux y <code>X86_64_RELOC_SIGNED</code> , <code>X86_64_RELOC_SIGNED_1</code> , <code>X86_64_RELOC_SIGNED_2</code> y <code>X86_64_RELOC_SIGNED_4</code> en macOS </li></ul><br><p>  El punto sutil asociado con la secci√≥n <code>__common</code> .  Linux tambi√©n tiene una secci√≥n similar <code>*COM*</code> .  Las variables globales pueden caer en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta secci√≥n</a> .  Pero, aunque prob√© y compil√© un mont√≥n de fragmentos de c√≥digo, en Linux, las reubicaciones de caracteres de las secciones <code>*COM*</code> siempre fueron din√°micas, como las variables globales regulares.  Al mismo tiempo, en macOS, tales caracteres a veces se reubicaban durante la vinculaci√≥n si la funci√≥n y el car√°cter est√°n en el mismo archivo.  Por lo tanto, en macOS tiene sentido considerar esta secci√≥n al leer caracteres y reubicaciones. </p><br><p>  Bueno, ahora tenemos un conjunto de todas las reubicaciones que necesitamos, ¬øqu√© hacer con ellas?  La l√≥gica aqu√≠ es simple.  Cuando el vinculador vincula la biblioteca, escribe la direcci√≥n del s√≠mbolo calculado por una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">determinada f√≥rmula</a> en la direcci√≥n de reubicaci√≥n.  Para nuestras reubicaciones en ambas plataformas, esta f√≥rmula contiene la direcci√≥n del s√≠mbolo como un t√©rmino.  Por lo tanto, la direcci√≥n calculada ya registrada en el cuerpo de funciones tiene la forma: </p><br><pre> <code class="plaintext hljs">resultAddr = newVarAddr + addend - relocAddr</code> </pre> <br><p>  Al mismo tiempo, conocemos las direcciones de ambas versiones de variables: antiguas, que ya est√°n en la aplicaci√≥n y nuevas.  Nos queda cambiarlo de acuerdo con la f√≥rmula: </p><br><pre> <code class="plaintext hljs">resultAddr = resultAddr - newVarAddr + oldVarAddr</code> </pre> <br><p>  y escr√≠balo a la direcci√≥n de reubicaci√≥n.  Despu√©s de eso, todas las funciones en el nuevo c√≥digo usar√°n las versiones existentes de las variables, y las nuevas variables simplemente mentir√°n y no har√°n nada.  Lo que necesitas!  Pero hay un punto sutil. </p><br><h3 id="zagruzka-biblioteki-s-novym-kodom">  Descargando la biblioteca con el nuevo c√≥digo </h3><br><p>  Cuando el sistema carga una biblioteca din√°mica en la memoria del proceso, es libre de colocarla en cualquier lugar del espacio de direcciones virtuales.  En Ubuntu 18.04, mi aplicaci√≥n se carga en <code>0x00400000</code> y nuestras bibliotecas din√°micas inmediatamente despu√©s de <code>ld-2.27.so</code> en direcciones en el √°rea <code>0x7fd3829bd000</code> .  La distancia entre las direcciones de descarga del programa y la biblioteca es mucho mayor que el n√∫mero que cabr√≠a en el entero de 32 bits con signo.  Y en las reubicaciones en tiempo de enlace, solo 4 bytes est√°n reservados para direcciones de caracteres de destino. </p><br><p>  Despu√©s de fumar la documentaci√≥n para compiladores y enlazadores, decid√≠ probar la opci√≥n <code>-mcmodel=large</code> .  Obliga al compilador a generar c√≥digo sin suposiciones sobre la distancia entre los caracteres, por lo que se supone que todas las direcciones son de 64 bits.  Pero esta opci√≥n no es <code>-mcmodel=large</code> PIC, como si <code>-mcmodel=large</code> no se puede usar con <code>-fPIC</code> , al menos en macOS.  Todav√≠a no entiendo cu√°l es el problema, tal vez en macOS no hay reubicaciones adecuadas para esta situaci√≥n. </p><br><p>  En la biblioteca bajo Windows, este problema se resuelve de la siguiente manera.  Las manos asignan un trozo de memoria virtual cerca de la ubicaci√≥n de descarga de la aplicaci√≥n, suficiente para acomodar las secciones necesarias de la biblioteca.  Luego, las secciones se cargan con las manos, los derechos necesarios se establecen en las p√°ginas de memoria con las secciones correspondientes, todas las reubicaciones se descomprimen con las manos y todo lo dem√°s se repara.  Soy vago  Realmente no quer√≠a hacer todo este trabajo con reubicaciones de tiempo de carga, especialmente en Linux.  ¬øY por qu√© lo que un enlazador din√°mico ya sabe hacer?  Despu√©s de todo, las personas que lo escribieron saben mucho m√°s que yo. </p><br><p>  Afortunadamente, la documentaci√≥n encontr√≥ las opciones necesarias para indicar d√≥nde descargar nuestra biblioteca din√°mica: </p><br><ul><li>  Apple ld: <code>-image_base 0xADDRESS</code> </li><li>  LLVM lld: <code>--image-base=0xADDRESS</code> </li><li>  GNU ld: <code>-Ttext-segment=0xADDRESS</code> </li></ul><br><p>  Estas opciones deben pasarse al vinculador al momento de vincular la biblioteca din√°mica.  Hay 2 dificultades. <br>  El primero est√° relacionado con GNU ld.  Para que estas opciones funcionen, debe: </p><br><ul><li>  En el momento de cargar la biblioteca, el √°rea en la que queremos cargar era libre </li><li>  La direcci√≥n especificada en la opci√≥n debe ser un m√∫ltiplo del tama√±o de la p√°gina (en Linux x86-64 y macOS es <code>0x1000</code> ) </li><li>  Al menos en Linux, la direcci√≥n especificada en la opci√≥n debe ser un m√∫ltiplo de la alineaci√≥n del segmento <code>PT_LOAD</code> </li></ul><br><p>  Es decir, si el vinculador establece la alineaci√≥n en <code>0x10000000</code> , entonces esta biblioteca no se puede cargar en la direcci√≥n <code>0x10001000</code> , aunque la direcci√≥n est√© alineada con el tama√±o de la p√°gina.  Si no se cumple una de estas condiciones, la biblioteca se cargar√° "como de costumbre".  Tengo GNU ld 2.30 en mi sistema y, a diferencia de LLVM lld, establece de manera predeterminada la alineaci√≥n del segmento <code>0x20000</code> en <code>0x20000</code> , que est√° muy fuera de la imagen.  Para evitar esto, adem√°s de la <code>-Ttext-segment=...</code> , especifique <code>-z max-page-size=0x1000</code> .  Pas√© un d√≠a hasta que me di cuenta de por qu√© la biblioteca no se carga donde necesito. </p><br><p>  La segunda dificultad: la direcci√≥n de descarga debe conocerse en la etapa de vinculaci√≥n de la biblioteca.  No es muy dif√≠cil de organizar.  En Linux, es suficiente analizar el pseudoarchivo <code>/proc/&lt;pid&gt;/maps</code> , encontrar la pieza desocupada m√°s cercana al programa, en la que se ajustar√° la biblioteca, y usar la direcci√≥n del comienzo de esta pieza al vincular.  El tama√±o de la biblioteca futura se puede estimar de manera aproximada observando los tama√±os de los archivos de objetos, o analiz√°ndolos y calculando los tama√±os de todas las secciones.  Al final, no necesitamos un n√∫mero exacto, sino un tama√±o aproximado con un margen. </p><br><p>  MacOS no tiene <code>/proc/*</code> ; en cambio, se sugiere que use la utilidad <code>vmmap</code> .  La salida del <code>vmmap -interleaved &lt;pid&gt;</code> contiene la misma informaci√≥n que <code>proc/&lt;pid&gt;/maps</code> .  Pero aqu√≠ surge otra dificultad.  Si una aplicaci√≥n crea un proceso secundario que ejecuta este comando, y el identificador del proceso actual se especifica como <code>&lt;pid&gt;</code> , el programa se bloquear√°.  Seg√∫n tengo entendido, <code>vmmap</code> detiene el proceso para leer sus asignaciones de memoria y, aparentemente, si este es el proceso de llamada, entonces algo sale mal.  En este caso, debe especificar el indicador adicional <code>-forkCorpse</code> para que <code>vmmap</code> cree un proceso hijo vac√≠o de nuestro proceso, elimine el mapeo y elim√≠nelo, sin interrumpir el programa. </p><br><p>  Eso es b√°sicamente todo lo que necesitamos saber. </p><br><h3 id="sobiraem-vse-vmeste">  Poniendo todo junto </h3><br><p>  Con estas modificaciones, el algoritmo de recarga de c√≥digo final se ve as√≠: </p><br><ol><li>  Compila el nuevo c√≥digo en archivos de objetos </li><li>  Para archivos de objetos, estimamos el tama√±o de la futura biblioteca </li><li>  Lectura de archivos de objetos de reubicaci√≥n </li><li>  Estamos buscando una pieza de memoria virtual gratuita junto a la aplicaci√≥n. </li><li>  Construimos una biblioteca din√°mica con las opciones necesarias, <code>dlopen</code> trav√©s de <code>dlopen</code> </li><li>  C√≥digo de parche seg√∫n reubicaciones en tiempo de enlace </li><li>  Funci√≥n de parche </li><li>  Copie las variables est√°ticas que no participaron en el paso 6 </li></ol><br><p>  Solo las variables de protecci√≥n de las variables est√°ticas entran en el paso 8, por lo que pueden copiarse de forma segura (preservando as√≠ la "inicializaci√≥n" de las variables est√°ticas mismas). </p><br><h3 id="zaklyuchenie">  Conclusi√≥n </h3><br><p>  Como se trata exclusivamente de una herramienta de desarrollo, no est√° destinada a ninguna producci√≥n, lo peor que puede suceder si la pr√≥xima biblioteca con nuevo c√≥digo no cabe en la memoria o se carga accidentalmente en una direcci√≥n diferente es reiniciar la aplicaci√≥n depurada.  Al ejecutar pruebas, 31 bibliotecas con c√≥digo actualizado se cargan en la memoria a su vez. </p><br><p>  Para completar, faltan 3 piezas m√°s pesadas en la implementaci√≥n: </p><br><ol><li>  Ahora la biblioteca con el nuevo c√≥digo se carga en la memoria al lado del programa, aunque el c√≥digo de otra biblioteca din√°mica que se ha cargado mucho puede entrar en ella.  Para solucionarlo, debe realizar un seguimiento de la propiedad de las unidades de traducci√≥n a una u otra biblioteca y programa, y ‚Äã‚Äãdividir la biblioteca con el nuevo c√≥digo si es necesario. </li><li>  La recarga de c√≥digo en una aplicaci√≥n multiproceso a√∫n no es confiable (con certeza, solo puede volver a cargar el c√≥digo que se ejecuta en el mismo hilo que la biblioteca runloop).  Para la fijaci√≥n, es necesario mover parte de la implementaci√≥n a un programa separado, y este programa, antes de parchear, debe detener el proceso con todos los hilos, parchearlo y volverlo a trabajar.  No s√© c√≥mo hacer esto sin un programa externo. </li><li>  Prevenci√≥n del bloqueo accidental de la aplicaci√≥n despu√©s de la recarga del c√≥digo.  Despu√©s de corregir el c√≥digo, puede desreferenciar accidentalmente el puntero no v√°lido en el nuevo c√≥digo, despu√©s de lo cual deber√° reiniciar la aplicaci√≥n.  Nada mal, pero a√∫n as√≠.  Suena como magia negra, todav√≠a estoy en el pensamiento. </li></ol><br><p>  Pero ya la implementaci√≥n actual comenz√≥ a beneficiarme personalmente, es suficiente para usar en mi trabajo principal.  Cuesta un poco acostumbrarse, pero el vuelo es normal. <br>  Si llego a estos tres puntos y encuentro en su implementaci√≥n una cantidad suficiente de cosas interesantes, definitivamente lo compartir√©. </p><br><h3 id="demo">  Demo </h3><br><p>  Dado que la implementaci√≥n le permite agregar nuevas unidades de transmisi√≥n sobre la marcha, decid√≠ grabar un video corto en el que escribo un simple juego obsceno desde cero sobre una nave espacial que ara las extensiones del universo y dispara asteroides cuadrados.  Trat√© de no escribir en el estilo de "todo en un archivo", pero, si es posible, organizando todo en los estantes, generando as√≠ muchos archivos peque√±os (por lo tanto, salieron tantos garabatos).  Por supuesto, el marco se utiliza para dibujar, entradas, ventanas y otras cosas, pero el c√≥digo del juego en s√≠ fue escrito desde cero. <br>  La caracter√≠stica principal: solo ejecut√© la aplicaci√≥n 3 veces: al principio, cuando solo ten√≠a una escena vac√≠a, y 2 veces despu√©s de la ca√≠da debido a mi negligencia.  Todo el juego se vierte gradualmente en el proceso de escribir c√≥digo.  Tiempo real: unos 40 minutos.  En general, de nada. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/5xfgViYchqg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Como siempre, estar√© encantado de cualquier cr√≠tica, ¬°gracias! </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Enlace a la implementaci√≥n</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/437312/">https://habr.com/ru/post/437312/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../437300/index.html">10 habilidades y conocimientos necesarios para un desarrollador principiante de iOS</a></li>
<li><a href="../437304/index.html">C√≥mo comprar papas si eres dalt√≥nico</a></li>
<li><a href="../437306/index.html">Habilidades no obvias requeridas por el gerente de producto</a></li>
<li><a href="../437308/index.html">Ciclo de lecciones de SDL 2.0: Lecci√≥n 4 - Manejo de eventos</a></li>
<li><a href="../437310/index.html">CSS Gradient Borders</a></li>
<li><a href="../437314/index.html">Enigma italiano: m√°quinas criptogr√°ficas OMI</a></li>
<li><a href="../437316/index.html">El Internet Development Institute ha nombrado sitios que pueden estar desconectados de RuNet desde el 1 de febrero</a></li>
<li><a href="../437318/index.html">Migraci√≥n perfecta (casi) entre las principales versiones de PostgreSQL utilizando replicaci√≥n l√≥gica</a></li>
<li><a href="../437320/index.html">√çndice de desarrollo de la esfera medi√°tica 2018: estancamiento de la televisi√≥n, mayor confianza en los medios informales</a></li>
<li><a href="../437322/index.html">El estado participa en BigDate</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>