<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💃🏼 🎼 🗯️ NL2API: إنشاء واجهات اللغة الطبيعية لواجهة برمجة تطبيقات الويب ☦️ 🤳🏻 🛠️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="مرحبا يا هبر! في الآونة الأخيرة ، تحدثنا لفترة وجيزة عن واجهات اللغة الطبيعية. حسنا ، اليوم لم نقم بإيجاز. تحت القطع ستجد قصة كاملة عن إنشاء NL2API لو...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>NL2API: إنشاء واجهات اللغة الطبيعية لواجهة برمجة تطبيقات الويب</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/418559/" style=";text-align:right;direction:rtl">  مرحبا يا هبر!  في الآونة الأخيرة ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تحدثنا لفترة وجيزة</a> عن واجهات اللغة الطبيعية.  حسنا ، اليوم لم نقم بإيجاز.  تحت القطع ستجد قصة كاملة عن إنشاء NL2API لواجهة برمجة تطبيقات الويب.  لقد جرب زملاؤنا من قسم الأبحاث نهجًا فريدًا لجمع بيانات التدريب الخاصة بالإطار.  انضم الآن! <br><br><img src="https://habrastorage.org/webt/ry/bd/kj/rybdkjnazdjarwxlrggugof4pja.jpeg"><a name="habracut"></a><br><br><h2 style=";text-align:right;direction:rtl">  شرح </h2><br>  مع تطور الإنترنت نحو بنية موجهة للخدمة ، تزداد أهمية واجهات البرامج (API) كطريقة لتوفير الوصول إلى البيانات والخدمات والأجهزة.  نحن نعمل على قضية إنشاء واجهة لغة طبيعية لواجهة برمجة التطبيقات (NL2API) ، مع التركيز على خدمات الويب.  تتمتع حلول NL2API بالعديد من الفوائد المحتملة ، على سبيل المثال ، مما يساعد على تبسيط دمج خدمات الويب في المساعدين الافتراضيين. <br><br>  نحن نقدم أول منصة شاملة (إطار عمل) تسمح لك بإنشاء NL2API لواجهة برمجة تطبيقات ويب معينة.  المهمة الرئيسية هي جمع البيانات للتدريب ، أي أزواج "أمر NL - استدعاء API" ، مما يسمح لـ NL2API بدراسة دلالات كلا الأمرين NL الذين ليس لديهم تنسيق محدد بدقة ومكالمات API رسمية.  نحن نقدم نهجنا الفريد الخاص بجمع بيانات التدريب لـ NL2API باستخدام التعهيد الجماعي - جذب العديد من العاملين عن بعد لإنشاء فرق NL مختلفة.  نحن نحسن عملية التعهيد الجماعي نفسه من أجل تقليل التكاليف. <br><br>  على وجه الخصوص ، نقدم نموذجًا احتماليًا هرميًا جديدًا بشكل أساسي سيساعدنا على توزيع الميزانية من أجل التعهيد الجماعي ، بشكل رئيسي بين مكالمات API ذات القيمة العالية لتعلم NL2API.  نطبق إطار عملنا على واجهات برمجة التطبيقات الحقيقية ونوضح أنه يسمح لك بجمع بيانات تدريب عالية الجودة بأقل تكلفة ، بالإضافة إلى إنشاء NL2API عالي الأداء من البداية.  نثبت أيضًا أن نموذج التعهيد الجماعي لدينا يحسن كفاءة هذه العملية ، أي أن بيانات التدريب التي تم جمعها في إطارها توفر أداء NL2API أعلى ، والذي يتجاوز بشكل كبير خط الأساس. <br><br><h2 style=";text-align:right;direction:rtl">  مقدمة </h2><br>  تلعب واجهات برمجة التطبيقات (APIs) دورًا متزايد الأهمية في كل من العالمين الافتراضي والمادي ، وذلك بفضل تطوير تقنيات مثل العمارة الموجهة نحو الخدمة (SOA) والحوسبة السحابية وإنترنت الأشياء (IoT).  على سبيل المثال ، توفر خدمات الويب المستضافة في السحابة (الطقس والرياضة والتمويل ، وما إلى ذلك) من خلال واجهة برمجة تطبيقات الويب البيانات والخدمات للمستخدمين النهائيين ، وتمكن أجهزة إنترنت الأشياء أجهزة الشبكة الأخرى من استخدام وظائفها. <br><br><img src="https://habrastorage.org/webt/tc/kd/fb/tckdfbxc1i4zg4km413wnducl_4.png"><br>  <i>الشكل 1. تم تجميع أزواج "أمر NL (يسار) ومكالمة API (يمين)"</i> <i><br></i>  <i>إطار عملنا والمقارنة مع IFTTT.</i>  <i>GET-Messages و GET-Events هما واجهتا برمجة تطبيقات ويب للعثور على رسائل البريد الإلكتروني وأحداث التقويم ، على التوالي.</i>  <i>يمكن استدعاء API بمعلمات مختلفة.</i>  <i>نحن نركز على مكالمات API ذات المعلمات الكاملة ، بينما يقتصر IFTTT على واجهات برمجة التطبيقات ذات المعلمات البسيطة.</i> <br><br>  عادةً ، يتم استخدام واجهات برمجة التطبيقات في مجموعة متنوعة من البرامج: تطبيقات سطح المكتب ومواقع الويب وتطبيقات الجوال.  كما أنها تخدم المستخدمين من خلال واجهة مستخدم رسومية (GUI).  قدمت واجهة المستخدم الرسومية مساهمة كبيرة في تعميم أجهزة الكمبيوتر ، ولكن مع تطور تكنولوجيا الكمبيوتر ، تتجلى قيودها العديدة بشكل متزايد.  من ناحية ، عندما تصبح الأجهزة أصغر حجمًا وأكثر قدرة على الحركة وأكثر ذكاءً ، تتزايد باستمرار متطلبات العرض الرسومي على الشاشة ، على سبيل المثال ، فيما يتعلق بالأجهزة المحمولة أو الأجهزة المتصلة بإنترنت الأشياء. <br><br>  من ناحية أخرى ، يجب على المستخدمين التكيف مع مختلف واجهات المستخدم الرسومية المتخصصة لمختلف الخدمات والأجهزة.  مع زيادة عدد الخدمات والأجهزة المتاحة ، تزداد أيضًا تكلفة التدريب وتكييف المستخدم.  تُظهر واجهات اللغة الطبيعية (NLIs) ، مثل المساعد الافتراضي لـ Apple Siri و Microsoft Cortana ، والتي تسمى أيضًا واجهات المحادثة أو واجهات الحوار (CUIs) ، إمكانات كبيرة كأداة ذكية واحدة لمجموعة واسعة من خدمات الخادم والأجهزة. <br><br>  في هذا البحث ، نعتبر مشكلة إنشاء واجهة لغة طبيعية لواجهة برمجة التطبيقات (NL2API).  ولكن ، على عكس المساعدين الافتراضيين ، هذه ليست أهدافًا غير هادفة للأغراض العامة ، <br>  نحن نعمل على تطوير مناهج لإنشاء NLIs لواجهات برمجة تطبيقات ويب معينة ، مثل واجهات برمجة تطبيقات خدمات الويب مثل خدمة ESPN1 للرياضات المتعددة.  يمكن لمثل هذه NL2API حل مشكلة قابلية التوسع في NLI ذات الأغراض العامة من خلال تمكين التنمية الموزعة.  تعتمد فائدة المساعد الافتراضي بشكل كبير على اتساع قدراته ، أي على عدد الخدمات التي يدعمها. <br><br>  ومع ذلك ، فإن دمج خدمات الويب في مساعد افتراضي واحد في كل مرة هو عمل شاق للغاية.  إذا كان لدى مزودي خدمة الويب الفرديين طريقة غير مكلفة لإنشاء NLIs لواجهات برمجة التطبيقات الخاصة بهم ، فسيتم تخفيض تكاليف التكامل بشكل كبير.  لن يضطر المساعد الافتراضي إلى معالجة واجهات مختلفة لخدمات الويب المختلفة.  سيكون كافياً بالنسبة له ببساطة أن يدمج NL2APIs الفردية ، التي تحقق التوحيد بفضل اللغة الطبيعية.  من ناحية أخرى ، يمكن لـ NL2API أيضًا تبسيط اكتشاف خدمات الويب وتوصيات البرمجة وأنظمة المساعدة لواجهات برمجة التطبيقات ، مما يلغي الحاجة إلى تذكر العدد الكبير من واجهات برمجة تطبيقات الويب المتاحة ونحوها. <br><br>  <b>مثال 1.</b> يظهر مثالان في الشكل 1. يمكن استدعاء API بمعلمات مختلفة.  في حالة واجهة برمجة تطبيقات بحث البريد الإلكتروني ، يمكن للمستخدمين تصفية البريد الإلكتروني حسب خصائص معينة أو البحث عن رسائل البريد الإلكتروني حسب الكلمات الرئيسية.  تتمثل المهمة الرئيسية لـ NL2API في تعيين أوامر NL لمكالمات API المقابلة. <br><br>  <b>التحدي.</b>  يعد جمع بيانات التدريب أحد أهم المهام المرتبطة بالبحث في تطوير واجهات NLI وتطبيقها العملي.  تستخدم NLI بيانات تدريب محكومة ، والتي في حالة NL2API تتكون من أزواج من "أمر NL - استدعاء API" لدراسة الدلالات وتعيين أوامر NL بشكل لا لبس فيه للتمثيلات الرسمية ذات الصلة.  اللغة الطبيعية مرنة للغاية ، لذلك يمكن للمستخدمين وصف مكالمة API بطرق مختلفة نحويًا ، أي أن إعادة الصياغة تحدث. <br><br>  ضع في اعتبارك المثال الثاني في الشكل 1. يمكن للمستخدمين إعادة صياغة هذا السؤال على النحو التالي: "أين سيعقد الاجتماع التالي" أو "البحث عن مكان للاجتماع التالي".  لذلك ، من المهم للغاية جمع بيانات تدريب كافية بحيث يعترف النظام بمثل هذه الخيارات.  تلتزم المؤسسات غير الربحية القائمة عادةً بمبدأ "أفضل ما يمكن" في جمع البيانات.  على سبيل المثال ، تستخدم أقرب مقارناتنا لمنهجتنا لمقارنة أوامر NL بمكالمات API مفهوم IF-This-Then-That (IFTTT) - "إذا كان الأمر كذلك ، ثم" (الشكل 1).  تأتي بيانات التدريب مباشرة من موقع IFTTT الإلكتروني. <br><br>  ومع ذلك ، إذا كانت واجهة برمجة التطبيقات غير مدعومة أو غير مدعومة بالكامل ، فلا توجد طريقة لإصلاح الموقف.  بالإضافة إلى ذلك ، فإن بيانات التدريب التي تم جمعها بهذه الطريقة لا تنطبق على دعم الأوامر المتقدمة مع العديد من المعلمات.  على سبيل المثال ، قمنا بتحليل سجلات مكالمات Microsoft API مجهولة الهوية للبحث عن رسائل البريد الإلكتروني للشهر ووجدنا أن حوالي 90٪ منهم يستخدمون معلمتين أو ثلاث (نفس الكمية تقريبًا) ، وهذه المعلمات متنوعة تمامًا.  لذلك ، نسعى جاهدين لتوفير الدعم الكامل لمعلمات واجهة برمجة التطبيقات وتنفيذ أوامر NL المتقدمة.  لا تزال مشكلة نشر عملية نشطة وقابلة للتخصيص لجمع بيانات التدريب لواجهة برمجة تطبيقات معينة في الوقت الحالي بدون حل. <br><br>  لقد تم حل مشكلات استخدام NLI مع تمثيلات رسمية أخرى ، مثل قواعد البيانات العلائقية وقواعد المعرفة وجداول الويب ، بشكل جيد جدًا ، في حين لم يتم إيلاء أي اهتمام تقريبًا لتطوير NLI لواجهات برمجة تطبيقات الويب.  نحن نقدم أول منصة شاملة (إطار عمل) تسمح لك بإنشاء NL2API لواجهة برمجة تطبيقات ويب معينة من البداية.  في تنفيذ واجهة برمجة تطبيقات الويب ، يتضمن إطار عملنا ثلاث مراحل: (1) عرض تقديمي.  يحتوي تنسيق HTTP web API الأصلي على الكثير من البيانات الزائدة ، وبالتالي تشتيت الانتباه من وجهة نظر NLI. <br><br>  نقترح استخدام تمثيل دلالية وسيط لواجهة برمجة تطبيقات الويب ، حتى لا يتم تحميل NLI بالمعلومات غير الضرورية.  (2) مجموعة من بيانات التدريب.  نحن نقدم نهجًا جديدًا للحصول على بيانات تدريب محكومة استنادًا إلى التعهيد الجماعي.  (3) NL2API.  نقدم أيضًا نموذجين NL2API: نموذج استخراج مستند إلى اللغة ونموذج شبكة عصبية متكررة (Seq2Seq). <br><br>  إحدى النتائج الفنية الرئيسية لهذا العمل هي نهج جديد بشكل أساسي لجمع نشط لبيانات التدريب لـ NL2API استنادًا إلى الاستعانة بمصادر خارجية - نحن نستخدم المديرين التنفيذيين عن بُعد للتعليق على مكالمات API عند مقارنتها بأوامر NL.  يتيح لك هذا تحقيق ثلاثة أهداف تصميم من خلال توفير: (1) قابلية التخصيص.  يجب أن تكون قادرًا على تحديد المعلمات التي تستخدمها واجهة برمجة التطبيقات ومقدار بيانات التدريب التي يجب جمعها.  (2) منخفضة التكلفة.  إن خدمات عمال التعهيد الجماعي هي أرخص من خدمات المتخصصين المتخصصين ، وهذا هو السبب في أنه يجب توظيفهم.  (3) جودة عالية.  لا ينبغي تخفيض جودة بيانات التدريب. <br><br>  عند تصميم هذا النهج ، تنشأ مشكلتان رئيسيتان.  أولاً ، إن مكالمات واجهة برمجة التطبيقات ذات المعلمات المتقدمة ، كما هو الحال في الشكل 1 ، غير مفهومة للمستخدم العادي ، لذلك تحتاج إلى تحديد كيفية صياغة مشكلة التعليقات التوضيحية بحيث يمكن للموظفين التعهيد الجماعي بسهولة التعامل معها.  نبدأ بتطوير تمثيل دلالية وسيط لواجهة برمجة تطبيقات الويب (انظر القسم 2.2) ، مما يسمح لنا بإنشاء مكالمات API بسلاسة بالمعلمات المطلوبة. <br><br>  ثم نفكر في القواعد الخاصة بتحويل كل مكالمة API تلقائيًا إلى أمر NL أساسي ، والذي يمكن أن يكون مرهقًا إلى حد ما ، ولكنه سيكون واضحًا لموظف التعهيد الجماعي (انظر القسم 3.1).  سيتعين على فناني الأداء فقط إعادة صياغة الفريق الأساسي لجعله يبدو أكثر طبيعية.  يسمح لك هذا النهج بمنع العديد من الأخطاء في جمع بيانات التدريب ، نظرًا لأن مهمة إعادة الصياغة أبسط بكثير وأكثر قابلية للفهم بالنسبة لموظف التعهيد الجماعي. <br><br>  ثانيًا ، تحتاج إلى فهم كيفية تحديد وتعليق مكالمات API فقط ذات القيمة الحقيقية لتعلم NL2API.  يؤدي "الانفجار التجميعي" الذي ينشأ أثناء وضع المعلمات إلى حقيقة أن عدد المكالمات حتى لوحدة API واحدة يمكن أن يكون كبيرًا جدًا.  ليس من المنطقي وضع تعليق على جميع المكالمات.  نحن نقدم نموذجًا احتماليًا هرميًا جديدًا بشكل أساسي لتنفيذ عملية التعهيد الجماعي (انظر القسم 3.2).  عن طريق القياس مع نمذجة اللغة لغرض الحصول على المعلومات ، نفترض أن أوامر NL يتم إنشاؤها بناءً على استدعاءات API المقابلة ، لذلك يجب استخدام نموذج اللغة لكل استدعاء API لتسجيل هذه العملية "التوليدية". <br><br>  يعتمد نموذجنا على الطبيعة التركيبية لمكالمات API أو التمثيلات الرسمية للبنية الدلالية ككل.  على مستوى بديهي ، إذا كانت مكالمة API تتكون من مكالمات أبسط (على سبيل المثال ، "رسائل البريد الإلكتروني غير المقروءة حول مرشح للحصول على درجة علمية" = "رسائل البريد الإلكتروني غير المقروءة" + "رسائل البريد الإلكتروني لمرشح للحصول على درجة علمية" ، يمكننا إنشاؤها نموذج اللغة من مكالمات واجهة برمجة التطبيقات البسيطة حتى بدون تعليق توضيحي ، لذلك ، من خلال التعليق على عدد صغير من مكالمات واجهة برمجة التطبيقات ، يمكننا حساب نموذج اللغة لأي شخص آخر. <br><br>  بالطبع ، نماذج اللغة المحسوبة بعيدة عن المثالية ، وإلا كنا قد حللنا بالفعل مشكلة إنشاء NL2API.  ومع ذلك ، فإن هذا الاستقراء لنموذج اللغة لمكالمات واجهة برمجة التطبيقات (API) غير المرخصة يمنحنا عرضًا شاملاً للمساحة الكاملة لمكالمات واجهة برمجة التطبيقات ، بالإضافة إلى تفاعل اللغة الطبيعية ومكالمات واجهة برمجة التطبيقات ، مما يسمح لنا بتحسين عملية التعهيد الجماعي.  في القسم 3.3 ، قمنا بوصف خوارزمية للتعليق الانتقائي على مكالمات API للمساعدة في جعل مكالمات API أكثر تميزًا ، أي لضمان أقصى اختلاف بين نماذج لغتها. <br><br>  نطبق إطار عملنا على اثنين من واجهات برمجة التطبيقات المنشورة من حزمة Microsoft Graph API2.  نوضح أنه يمكن جمع بيانات تدريب عالية الجودة بأقل تكلفة إذا تم استخدام النهج المقترح 3.  نظهر أيضًا أن نهجنا يحسن التعهيد الجماعي.  بتكاليف مماثلة ، نجمع بيانات تدريب أفضل ، تتجاوز بشكل كبير خط الأساس.  نتيجة لذلك ، توفر حلولنا NL2API دقة أعلى. <br><br>  بشكل عام ، تشمل مساهمتنا الرئيسية ثلاثة جوانب: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  كنا من أول من درس مشاكل NL2API واقترح إطار عمل شامل لإنشاء NL2API من الصفر. </li><li style=";text-align:right;direction:rtl">  لقد اقترحنا نهجًا فريدًا لجمع بيانات التدريب باستخدام التعهيد الجماعي ونموذج احتمالي هرمي جديد بشكل أساسي لتحسين هذه العملية. </li><li style=";text-align:right;direction:rtl">  لقد طبقنا إطار عملنا على واجهات برمجة تطبيقات الويب الحقيقية وأثبتنا أنه يمكن إنشاء حل NL2API فعال بما فيه الكفاية من الصفر. </li></ul><br><img src="https://habrastorage.org/webt/t4/fs/vl/t4fsvlxndjmziwbvzjh2rwqut2c.png"><br>  <i>الجدول 1. معاملات الاستعلام OData.</i> <br><br><h2 style=";text-align:right;direction:rtl">  الديباجة </h2><br><h4 style=";text-align:right;direction:rtl">  RESTful API </h4><br>  في الآونة الأخيرة ، أصبحت واجهات برمجة تطبيقات الويب التي تتوافق مع النمط المعماري REST ، أي RESTful API ، أكثر شيوعًا بسبب بساطتها.  تُستخدم واجهات برمجة التطبيقات RESTful أيضًا على الهواتف الذكية وأجهزة إنترنت الأشياء.  تعمل واجهات برمجة التطبيقات المريحة مع الموارد التي يتم تناولها عبر معرفات الموارد المنتظمة (URIs) وتوفر إمكانية الوصول إلى هذه الموارد لمجموعة كبيرة من العملاء باستخدام أوامر HTTP بسيطة: GET و PUT و POST وما إلى ذلك. وسنعمل بشكل أساسي مع RESTful API ، ولكن يمكن استخدام الطرق الأساسية وواجهات برمجة التطبيقات الأخرى. <br><br>  على سبيل المثال ، خذ بروتوكول Open Data Protocol (OData) الشهير لواجهة برمجة التطبيقات RESTful وواجهة برمجة التطبيقات للويب من حزمة Microsoft Graph API (الشكل 1) ، والتي يتم استخدامها ، على التوالي ، للبحث عن رسائل البريد الإلكتروني وأحداث تقويم المستخدم.  الموارد الموجودة في OData هي كيانات ، يرتبط كل منها بقائمة خصائص.  على سبيل المثال ، يحتوي كيان الرسائل - بريد إلكتروني - على خصائص مثل الموضوع (الموضوع) ، من (من) ، isRead (قراءة) ، و dateDateTime (تاريخ ووقت الاستلام) ، إلخ. <br><br>  بالإضافة إلى ذلك ، تحدد OData مجموعة من معلمات الاستعلام ، مما يسمح لك بإجراء عمليات معالجة متقدمة على الموارد.  على سبيل المثال ، تسمح لك المعلمة FILTER بالبحث عن رسائل البريد الإلكتروني من مرسل معين أو الرسائل المستلمة في تاريخ معين.  يتم تقديم معلمات الطلب التي سنستخدمها في الجدول 1. نحن نسمي كل تركيبة من أمر HTTP والكيان (أو مجموعة الكيانات) كواجهة برمجة تطبيقات ، على سبيل المثال ، GET-Messages - للبحث عن رسائل البريد الإلكتروني.  أي طلب ذي معلمات ، على سبيل المثال ، FILTER (isRead = False) ، يسمى معلمة ، واستدعاء API هو API يحتوي على قائمة من المعلمات. <br><br><h4 style=";text-align:right;direction:rtl">  NL2API </h4><br>  تتمثل المهمة الرئيسية لـ NLI في مقارنة عبارة (أمر بلغة طبيعية) مع تمثيل رسمي معين ، على سبيل المثال ، الأشكال المنطقية أو استعلامات SPARQL لقواعد المعرفة أو واجهات برمجة تطبيقات الويب في حالتنا.  عندما يكون من الضروري التركيز على رسم الخرائط الدلالية دون تشتيت الانتباه بالتفاصيل غير ذات الصلة ، عادة ما يتم استخدام التمثيل الوسيط الوسطي حتى لا تعمل مباشرة مع الهدف.  على سبيل المثال ، يتم استخدام القواعد الفئوية التوافقية على نطاق واسع في إنشاء NLIs لقواعد البيانات وقواعد المعرفة.  إن اتباع نهج مماثل في التجريد مهم أيضًا بالنسبة لـ NL2API.  يمكن للعديد من التفاصيل ، بما في ذلك اصطلاحات عناوين URL ورؤوس HTTP ورموز الاستجابة ، "تشتيت" NL2API من حل المشكلة الرئيسية - رسم الخرائط الدلالية. <br><br>  لذلك ، نقوم بإنشاء عرض وسيط لواجهات برمجة التطبيقات RESTful (الشكل 2) مع اسم واجهة برمجة التطبيقات ؛ يعكس هذا العرض دلالات الإطار.  يتكون إطار API من خمسة أجزاء.  HTTP Verb (أمر HTTP) والموارد هي العناصر الأساسية لواجهة برمجة تطبيقات RESTful.  يسمح لك نوع الإرجاع بإنشاء واجهات برمجة تطبيقات مركبة ، أي دمج مكالمات API متعددة لإجراء عملية أكثر تعقيدًا.  غالبًا ما يتم استخدام المعلمات المطلوبة في مكالمات PUT أو POST في واجهة برمجة التطبيقات ، على سبيل المثال ، يعد عنوان ورأس ونص الرسالة معلمات مطلوبة لإرسال البريد الإلكتروني.  غالبًا ما تكون المعلمات الاختيارية موجودة في مكالمات GET في واجهة برمجة التطبيقات ، فهي تساعد في تضييق طلب المعلومات. <br><br>  إذا كانت المعلمات المطلوبة مفقودة ، فإننا نقوم بتسلسل إطار API ، على سبيل المثال: GET-Messages {FILTER (isRead = False) ، SEARCH ("PhD application") ، COUNT ()}.  يمكن أن يكون إطار API حتمياً ويتم تحويله إلى مكالمة API حقيقية.  أثناء عملية التحويل ، ستتم إضافة البيانات السياقية الضرورية ، بما في ذلك معرف المستخدم والموقع والتاريخ والوقت.  في المثال الثاني (الشكل 1) ، سيتم استبدال القيمة الآن في معلمة FILTER بتاريخ ووقت تنفيذ الأمر المقابل أثناء تحويل إطار واجهة برمجة التطبيقات إلى مكالمة API حقيقية.  علاوة على ذلك ، سيتم استخدام مفاهيم إطار API واستدعاء API بالتبادل. <br><br><img src="https://habrastorage.org/webt/zq/ya/1s/zqya1s2fappwxv0soevosjshp6o.png"><br>  <i>الشكل 2. إطار API.</i>  <i>أعلاه: فريق اللغة الطبيعية.</i>  <i>في المنتصف: Frame API.</i>  <i>أسفل: مكالمة API.</i> <br><br><img src="https://habrastorage.org/webt/d1/4j/br/d14jbrsdzhethdl8tpvjlf0v7bq.png"><br>  <i>الشكل 3. الناقل التعهيد الجماعي.</i> <br><br><h2 style=";text-align:right;direction:rtl">  جمع بيانات التدريب </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يصف هذا القسم النهج الأساسي الجديد الذي نقدمه لجمع بيانات التدريب لحلول NL2API باستخدام التعهيد الجماعي. </font><font style="vertical-align: inherit;">أولاً ، نقوم بإنشاء مكالمات API وتحويل كل منهم إلى فريق أساسي ، بالاعتماد على قواعد بسيطة (القسم 3.1) ، ثم نجذب عمال التعهيد الجماعي لإعادة صياغة الفرق الأساسية (الشكل 3). </font><font style="vertical-align: inherit;">نظرًا للطبيعة التركيبية لمكالمات API ، فقد اقترحنا نموذج الاستعانة بمصادر خارجية الاحتمالية الهرمية (القسم 3.2) ، بالإضافة إلى خوارزمية لتحسين التعهيد الجماعي (القسم 3.3). </font></font><br><br><img src="https://habrastorage.org/webt/-m/hx/zh/-mhxzhnfom3w3n8cck-nkazfwiu.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الشكل 4 الشكل 4. توليد الأوامر الكنسي. </font><font style="vertical-align: inherit;">اليسار: المعجم والقواعد. </font><font style="vertical-align: inherit;">اليمين: مثال على الاشتقاق.</font></font></i> <br><br><h4 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> استدعاء API والأمر الأساسي </font></font></h4><br>    API     API.   ,       ,        API,   API  .      ,  Boolean,     (True/False). <br><br>      ,  Datetime,     ,  today  this_week  receivedDateTime.  ,        API           (,    )    API    API. <br><br>     ,        API .        . ,     TOP,         ORDERBY.  ,   Boolean,  isRead,  ORDERBY   .    « »         API   API. <br><br>      API.       API   .     API     API  ( 4).            ( HTTP, ,    ). ,   ⟨sender → NP[from]⟩ ,     from  «sender»,    —   (NP),     . <br><br>       (V),   (VP),  (JJ), - (CP),   ,       (NP/NP),    (PP/NP),  (S)  . . <br><br>  ,       API     ,           RESTful API    OData — « »    . 17     4     API,     ( 5). <br><br>   ,          API.     ⟨t1, t2, ..., tn → c[z]⟩,  <img src="https://habrastorage.org/webt/h5/rj/n2/h5rjn28vmc1twejoa5459flx0gm.png">    , z    API,  cz —   .     4.   API    ,     S,     G4,     API   . C    ,          ,               - «that is not read». <br><br>  ,      . ,  VP[x = False]     B2,   B4,       x.  x     VP,   B2 (, x is hasAttachments → «do not have attachment»);    JJ,    B4 (, x is isRead → «is not read»).       («do not read» or «is not have attachment»)       . <br><br><h4 style=";text-align:right;direction:rtl">   </h4><br>  يمكننا إنشاء عدد كبير من مكالمات API باستخدام النهج المذكور أعلاه ، ولكن التعليق عليها جميعًا باستخدام التعهيد الجماعي غير ممكن اقتصاديًا.  لذلك ، نقترح نموذجًا احتماليًا هرميًا للتعهيد الجماعي يساعدك في تحديد مكالمات API التي يجب التعليق عليها.  على حد علمنا ، هذا هو النموذج الاحتمالي الأول لاستخدام التعهيد الجماعي لإنشاء واجهات NLI ، مما يسمح لنا بحل المهمة الفريدة والمثيرة لنمذجة التفاعل بين تمثيلات اللغة الطبيعية والتمثيلات الهيكلية الدلالية.  إن التمثيلات الرسمية للبنية الدلالية بشكل عام ومكالمات API بشكل خاص تكون تركيبية بطبيعتها.  على سبيل المثال ، z12 = GET-Messages {COUNT () و FILTER (isRead = False)} يتكون من z1 = GET-Messages {FILTER (isRead = False)} و z2 = GET-Messages {COUNT ()} (هذه الأمثلة أكثر تفصيلاً مزيد من المناقشة). <br><br><img src="https://habrastorage.org/webt/fa/w0/eh/faw0ehohhnasifwgtragzrqwg3o.png"><br>  <i>الشكل 5. الشبكة الدلالية.</i>  <i>تتكون الطبقة ith من مكالمات API بمعلمات i.</i>  <i>الأضلاع هي تركيبات.</i>  <i>تميز توزيعات الاحتمال في القمم نماذج اللغة المقابلة.</i> <br><br>  كانت إحدى النتائج الرئيسية لدراستنا هي التأكيد على أنه يمكن استخدام هذا التكوين لنمذجة عملية التعهيد الجماعي. <br><br>  أولاً ، نحدد التكوين بناءً على مجموعة من معلمات استدعاء API. <br><br>  <b>التعريف 3.1 (التكوين).</b>  خذ API ومجموعة من مكالمات API <br><img src="https://habrastorage.org/webt/jp/nd/rx/jpndrxembixwz20-sym5vtxyhaq.png">  إذا حددنا r (z) كمجموعة من المعلمات لـ z ، عندها <img src="https://habrastorage.org/webt/zq/ih/u5/zqihu5tkga6iigokecjod-cg5um.png">  هو تكوين <img src="https://habrastorage.org/webt/_a/1x/jv/_a1xjvs9yduvatefhmfdk6xumq8.png">  إذا وفقط إذا <img src="https://habrastorage.org/webt/0e/oy/hw/0eoyhwaahe8xlrbplt1nqajeego.png">  جزء <img src="https://habrastorage.org/webt/np/q5/sy/npq5syhh47uv3yvyba_t1_4tqc0.png"><br><br>  بناءً على العلاقات التركيبية لمكالمات API ، يمكنك تنظيم جميع مكالمات API في هيكل هرمي واحد.  يتم تمثيل مكالمات API بنفس عدد المعلمات مثل رؤوس طبقة واحدة ، ويتم تمثيل التركيبات على أنها <br>  الأضلاع الموجهة بين الطبقات.  نحن نسمي هذا الهيكل شبكة بدائية (أو SeMesh). <br><br>  قياسا على النهج القائم على نمذجة اللغة في استرجاع المعلومات ، نفترض أن العبارات المقابلة لمكالمة API z واحدة يتم إنشاؤها باستخدام عملية عشوائية تتميز بنموذج اللغة <img src="https://habrastorage.org/webt/hn/r0/ww/hnr0wwjntvtnl8pymcmhkfjsawc.png">  .  من أجل التبسيط ، نركز على احتمالات الكلمات ، وبالتالي <img src="https://habrastorage.org/webt/on/eh/p5/onehp5mxamc9ehgpsl1u4pbkfr4.png">  أين <img src="https://habrastorage.org/webt/a-/v8/rh/a-v8rh1ddeh_ai-eawq8udhqe80.png">  يدل على قاموس. <br><br>  لأسباب ستصبح واضحة بعد ذلك بقليل ، بدلاً من نموذج unigram للغة القياسية ، نقترح استخدام مجموعة من توزيعات برنولي (حقيبة برنولي ، BoB).  يقابل كل توزيع برنولي متغير عشوائي W ، يحدد ما إذا كانت الكلمة w تظهر في الجملة التي تم إنشاؤها على أساس z ، وتوزيع BoB هو مجموعة من توزيعات برنولي لجميع الكلمات <img src="https://habrastorage.org/webt/k0/gw/fj/k0gwfjeikxqircdxhndamv6xbba.png">  .  سوف نستخدم <img src="https://habrastorage.org/webt/j1/vn/qm/j1vnqmhyhigxbdpj7s5irirmxae.png">  كتدوين قصير لـ <img src="https://habrastorage.org/webt/ub/xi/rx/ubxirxha2um6wer3obznfezis7w.png">  . <br><br>  لنفترض أننا شكلنا مجموعة (متعددة) من العبارات <img src="https://habrastorage.org/webt/m5/nb/sr/m5nbsrzyyxpfpzc6isj_qrjjxbs.png">  بالنسبة لـ z ، <br>  يسمح لك الحد الأقصى لتقدير الاحتمال (MLE) لتوزيع BoB بتحديد العبارات التي تحتوي على w: <br><br><img src="https://habrastorage.org/webt/ix/gv/2q/ixgv2qua9ifqtxbp1mi3hf58izc.png"><br><br>  <b>مثال 2.</b> بخصوص استدعاء API أعلاه z1 ، افترض أننا حصلنا على عبارتين u1 = "العثور على رسائل بريد إلكتروني غير مقروءة" و u2 = "رسائل بريد إلكتروني غير مقروءة" ، ثم u = {u1، u2}.  pb ("emails" | z) = 1.0 ، نظرًا لأن "رسائل البريد الإلكتروني" موجودة في العبارتين.  وبالمثل ، pb ("unread" | z) = 0.5 و pb ("meeting" | z) = 0.0. <br><br>  في الشبكة الدلالية ، هناك ثلاث عمليات أساسية على مستوى القمة: <br>  الشروح والتخطيط والاستيفاء. <br><br>  <b>التعليق التوضيحي</b> (للتعليق) يعني جمع البيانات <img src="https://habrastorage.org/webt/m5/nb/sr/m5nbsrzyyxpfpzc6isj_qrjjxbs.png">  لإعادة صياغة الأمر القانوني للرأس z باستخدام التعهيد الجماعي وتقييم التوزيع التجريبي <img src="https://habrastorage.org/webt/u4/o6/hw/u4o6hwaxkucqpz_fmcsbca0eqqo.png">  طريقة الاحتمالية القصوى. <br><br>  <b>يحاول COMPOSE</b> (إنشاء) استنباط نموذج لغوي بناءً على التراكيب لحساب التوزيع المتوقع <img src="https://habrastorage.org/webt/j6/i1/vm/j6i1vmdddqj_xfet6a9uhyzcdt0.png">  .  كما نظهر تجريبيا ، <img src="https://habrastorage.org/webt/zq/ih/u5/zqihu5tkga6iigokecjod-cg5um.png">  هو تكوين ل z.  إذا انطلقنا من افتراض أن العبارات المقابلة تتميز بنفس الاتصال التركيبي ، فعندئذٍ <img src="https://habrastorage.org/webt/j6/i1/vm/j6i1vmdddqj_xfet6a9uhyzcdt0.png">  يجب وضعه على <img src="https://habrastorage.org/webt/xe/zj/vd/xezjvdelmyapzpsz-c-ubbyrowq.png">  : <br><br><img src="https://habrastorage.org/webt/1j/kw/gy/1jkwgy2cjdyy2tkd9fd94_vdtf0.png"><br><br>  حيث f هي دالة تركيبية.  بالنسبة لتوزيع BoB ، ستبدو وظيفة التكوين كما يلي: <br><br><img src="https://habrastorage.org/webt/-j/yo/yc/-jyoycveazjjahzb2va3w26sfv0.png"><br><br>  بمعنى آخر ، إذا كانت ui عبارة zi ، فإن u عبارة <img src="https://habrastorage.org/webt/lr/ls/g_/lrlsg_9r0ga50mjkj47anmczlga.png">  من الناحية التركيبية ، فإن الكلمة w لا تنتمي إليك.  إذا وفقط إذا كان لا ينتمي إلى أي واجهة مستخدم.  عندما تحتوي z على العديد من التراكيب ، يتم حساب xe x بشكل منفصل ثم يتم حساب متوسطها.  لا يؤدي نموذج unigram للغة القياسية إلى وظيفة تركيبية طبيعية.  في عملية تطبيع احتمالات الكلمات ، يتم تضمين طول الجمل ، والذي بدوره يأخذ في الاعتبار تعقيد مكالمات واجهة برمجة التطبيقات ، مما ينتهك التحلل في المعادلة (2).  هذا هو السبب في أننا نقدم توزيع BoB. <br><br>  <b>مثال 3.</b> لنفترض أننا قمنا بإعداد تعليق توضيحي لمكالمات API المذكورة سابقًا z1 و z2 ، ولكل منهما بيانان: <img src="https://habrastorage.org/webt/zy/pr/yx/zypryx-8unafep9q1_lu2bnwewi.png">  = {"البحث عن رسائل بريد إلكتروني غير مقروءة" و "رسائل بريد إلكتروني غير مقروءة"} و <img src="https://habrastorage.org/webt/7n/4a/74/7n4a746gi-pf2_nf0ocy0dohdqm.png">  = {"كم عدد رسائل البريد الإلكتروني لدي" ، "ابحث عن عدد رسائل البريد الإلكتروني"}.  قمنا بتقييم نماذج اللغة <img src="https://habrastorage.org/webt/7a/uj/od/7aujod7s9qek21mw3zemkcgaake.png">  و <img src="https://habrastorage.org/webt/vp/so/fn/vpsofnkfxhjn38dfcjpm6bqzzio.png">  .  تحاول عملية التكوين التقييم <img src="https://habrastorage.org/webt/qt/tm/ud/qttmudo6ekcwmdeptxfjigmmcck.png">  بدون سؤال <img src="https://habrastorage.org/webt/hx/6c/sn/hx6csng8_0l_yqxgvteefbapkm0.png">  .  على سبيل المثال ، بالنسبة لكلمة "emails" ، pb ("emails" | z1) = 1.0 و pb ("emails" | z2) = 1.0 ، لذلك يتبع من المعادلة (3) أن pb ("emails" | z12) = 1.0 ، أي أننا نعتقد أنه سيتم تضمين هذه الكلمة في أي بيان z12.  وبالمثل ، pb ("find" | z1) = 0.5 و pb ("find" | z2) = 0.5 ، لذا pb ("find" | z12) = 0.75.  تتمتع الكلمة بفرصة جيدة لتوليدها من أي z1 أو z2 ، لذا يجب أن تكون احتمالية z12 أعلى. <br><br>  بالطبع ، لا يتم دمج العبارات دائمًا بشكل تأليف.  على سبيل المثال ، يمكن نقل العديد من العناصر في التمثيل الرسمي للبنية الدلالية في كلمة واحدة أو عبارة واحدة في لغة طبيعية ، وتسمى هذه الظاهرة التركيب الفرعي.  يظهر مثال واحد في الشكل 3 ، حيث يتم تمثيل المعلمات الثلاث - TOP (1) و FILTER (start&gt; now) و ORDERBY (start، asc) - بالكلمة المفردة "next".  ومع ذلك ، من المستحيل الحصول على مثل هذه المعلومات دون التعليق على مكالمة API ، لذا فإن المشكلة نفسها تشبه مشكلة الدجاج والبيض.  في حالة عدم وجود مثل هذه المعلومات ، فمن المعقول الالتزام بالافتراض الافتراضي أن العبارات تتميز بنفس العلاقة التركيبية مثل مكالمات API. <br><br>  هذا افتراض معقول.  تجدر الإشارة إلى أن هذا الافتراض يستخدم فقط لنمذجة عملية التعهيد الجماعي بهدف جمع البيانات.  في مرحلة الاختبار ، قد لا تتوافق بيانات المستخدمين الحقيقيين مع هذا الافتراض.  ستكون واجهة اللغة الطبيعية قادرة على التعامل مع مثل هذه المواقف غير التركيبية إذا كانت مغطاة ببيانات التدريب المجمعة. <br><br>  يدمج <b>INTERPOLATE</b> (interpolation) جميع المعلومات المتاحة حول z ، أي الكلمات المشروحة z والمعلومات التي يتم الحصول عليها من المؤلفات ، ويحصل على تقدير أكثر دقة <img src="https://habrastorage.org/webt/hn/r0/ww/hnr0wwjntvtnl8pymcmhkfjsawc.png">  عن طريق الاستيفاء <img src="https://habrastorage.org/webt/u4/o6/hw/u4o6hwaxkucqpz_fmcsbca0eqqo.png">  و <img src="https://habrastorage.org/webt/j6/i1/vm/j6i1vmdddqj_xfet6a9uhyzcdt0.png">  . <br><br><img src="https://habrastorage.org/webt/s4/qk/00/s4qk00v3xupp-nglc-ge-mmgwxa.png"><br><br>  تتحكم معلمة التوازن α في المفاضلات بين التعليقات التوضيحية <br>  القمم الحالية التي تكون دقيقة ولكنها كافية ، وقد لا تكون المعلومات التي يتم الحصول عليها من التراكيب المستندة إلى افتراض التكوين دقيقة ، ولكنها توفر تغطية أوسع.  بمعنى ما ، <img src="https://habrastorage.org/webt/j6/i1/vm/j6i1vmdddqj_xfet6a9uhyzcdt0.png">  يخدم نفس الغرض كمضاد للتعرج في نمذجة اللغة ، مما يسمح بتقدير أفضل لتوزيع الاحتمالية مع بيانات غير كافية (التعليقات التوضيحية).  أكثر من <img src="https://habrastorage.org/webt/xt/ml/w5/xtmlw5p16zioqn1amioucvjhe5o.png">  كلما زاد الوزن <img src="https://habrastorage.org/webt/u4/o6/hw/u4o6hwaxkucqpz_fmcsbca0eqqo.png">  .  بالنسبة لرأس الجذر الذي لا يحتوي على تركيبة ، <img src="https://habrastorage.org/webt/hn/r0/ww/hnr0wwjntvtnl8pymcmhkfjsawc.png">  = <img src="https://habrastorage.org/webt/u4/o6/hw/u4o6hwaxkucqpz_fmcsbca0eqqo.png">  .  لأعلى غير المشروح <img src="https://habrastorage.org/webt/hn/r0/ww/hnr0wwjntvtnl8pymcmhkfjsawc.png">  = <img src="https://habrastorage.org/webt/j6/i1/vm/j6i1vmdddqj_xfet6a9uhyzcdt0.png">  . <br><br>  بعد ذلك ، نصف خوارزمية تحديث الشبكة الدلالية ، أي الحسابات <img src="https://habrastorage.org/webt/hn/r0/ww/hnr0wwjntvtnl8pymcmhkfjsawc.png">  لجميع z (الخوارزمية 1) ، حتى لو تم وضع جزء صغير فقط من القمم في التعليق التوضيحي.  نفترض أن القيمة <img src="https://habrastorage.org/webt/u4/o6/hw/u4o6hwaxkucqpz_fmcsbca0eqqo.png">  تم تحديثه بالفعل لجميع المواقع ذات التعليقات التوضيحية.  نزولاً من أعلى إلى أسفل ، نحسب بالتتابع <img src="https://habrastorage.org/webt/j6/i1/vm/j6i1vmdddqj_xfet6a9uhyzcdt0.png">  و <img src="https://habrastorage.org/webt/hn/r0/ww/hnr0wwjntvtnl8pymcmhkfjsawc.png">  لكل قمة ض.  أولاً ، تحتاج إلى تحديث الطبقات العليا حتى تتمكن من حساب التوزيع المتوقع للقمم في المستوى الأدنى.  قمنا بتدوين جميع رؤوس الجذر ، حتى نتمكن من الحساب <img src="https://habrastorage.org/webt/hn/r0/ww/hnr0wwjntvtnl8pymcmhkfjsawc.png">  لجميع القمم. <br><br>  <i>الخوارزمية 1. تحديث توزيعات عقدة الشبكة الدلالية</i> <br><br><img src="https://habrastorage.org/webt/wd/ja/xx/wdjaxx4oqk_1rqniul9rnbc-fno.png"><br><br><h4 style=";text-align:right;direction:rtl">  3.3 تحسين التعهيد الجماعي </h4><br>  تشكل الشبكة الدلالية نظرة شاملة للمساحة الكاملة لمكالمات API ، بالإضافة إلى تفاعل البيانات والمكالمات.  استنادًا إلى هذا العرض ، يمكننا التعليق بشكل انتقائي فقط على مجموعة فرعية من مكالمات API عالية القيمة.  في هذا القسم ، نصف إستراتيجية التوزيع التفاضلي الخاصة بنا لتحسين التعهيد الجماعي. <br><br>  ضع في اعتبارك شبكة دلالية تحتوي على العديد من القمم Z. مهمتنا هي تحديد مجموعة فرعية من القمم في العملية التكرارية <img src="https://habrastorage.org/webt/ti/9x/ac/ti9xacqha0b1hbtkyeejh30f3sk.png">  ليتم التعليق عليها من قبل عمال التعهيد الجماعي.  القمم المشروحة سابقًا ستسمى دولة الولاية ، <br>  ثم نحتاج إلى إيجاد سياسة سياسة <img src="https://habrastorage.org/webt/9i/oc/9m/9ioc9mao9yuvhq7uhkiemeqet4g.png">  لتقييم كل قمة غير ملحوظة بناءً على الحالة الحالية. <br><br>  قبل الخوض في مناقشة أساليب حساب السياسات الفعالة ، لنفترض أن لدينا بالفعل واحدًا وقدم وصفًا عالي المستوى لخوارزمية التعهيد الجماعي (خوارزمية 2) لوصف الأساليب المصاحبة.  وبشكل أكثر تحديدًا ، نقوم أولاً بتوضيح جميع رؤوس الجذر لتقييم توزيع جميع القمم في Z (السطر 3).  في كل تكرار ، نقوم بتحديث توزيع القمة (السطر 5) ، احسب <br>  سياسة تستند إلى الحالة الحالية للشبكة الدلالية (السطر 6) ، حدد قمة غير مصحوبة بحد أقصى للتقييم (السطر 7) ، وقم بتعليق الرأس والنتيجة في الحالة الجديدة (السطر 8).  من الناحية العملية ، يمكنك إضافة تعليق توضيحي لعدة رؤوس كجزء من التكرار لزيادة الكفاءة. <br><br><img src="https://habrastorage.org/webt/va/tz/hs/vatzhsjcogvaktg8wh4h0a8al70.png"><br>  <i>الشكل 6. التوزيع التفاضلي.</i>  <i>يمثل z12 و z23 زوج الذروات قيد الدراسة.</i>  <i>w هو تقدير محسوب على أساس d (z12، z23) ، وينتشر بشكل متكرر من الأسفل إلى الأعلى ، ويتضاعف في كل تكرار.</i>  <i>سيكون تقدير القمة هو الفرق المطلق بين تقديراتها من z12 و z23 (وبالتالي التفاضلية).</i>  <i>تحصل z2 على درجة 0 لأنها الكيان الأصلي الشائع لـ z12 و z23 ؛</i>  <i>سيكون التعليق التوضيحي في هذه الحالة قليل الفائدة من حيث ضمان التمييز بين z12 و z23.</i> <br><br>  بشكل عام ، يمكن أن تُعزى المهام التي نحلها إلى مشكلة التعلم النشط ، وضعنا لأنفسنا هدف تحديد مجموعة فرعية من الأمثلة للتعليق التوضيحي من أجل الحصول على مجموعة تدريب يمكنها تحسين نتائج التعلم.  ومع ذلك ، لا تسمح العديد من الاختلافات الرئيسية بالتطبيق المباشر لطرق التدريس الكلاسيكية النشطة ، مثل "عدم اليقين في أخذ العينات".  عادة ، في عملية التعلم النشط ، يحاول الطالب ، الذي سيكون في حالتنا واجهة NLI ، دراسة رسم الخرائط f: X → Y ، حيث X هي عينة مساحة الإدخال ، تتكون من مجموعة صغيرة من العينات المميزة وعدد كبير من العينات غير المميزة ، وعادة ما تكون Y مجموعة من العلامات الطبقة. <br><br>  يقوم الطالب بتقييم القيمة الإعلامية للأمثلة غير المصنفة واختيار الأكثر إفادة للحصول على علامة ص من عمال التعهيد الجماعي.  ولكن في إطار المشكلة التي نحلها ، يتم طرح مشكلة التعليقات التوضيحية بشكل مختلف.  نحن بحاجة إلى تحديد مثيل من Y ، مساحة اتصال كبيرة لواجهة برمجة التطبيقات ، ونطلب من العاملين في التعهيد الجماعي تسمية ذلك بتحديد الأنماط في X ، مساحة الجملة.  بالإضافة إلى ذلك ، نحن لسنا مرتبطين بمتدرب معين.  وبالتالي ، نقترح حل جديد للمشكلة المطروحة.  نستمد الإلهام من مصادر عديدة حول التعلم النشط. <br><br>  أولاً ، نحدد الهدف ، والذي سيتم على أساسه تقييم محتوى المعلومات للعقد.  من الواضح أننا نريد تمييز مكالمات API مختلفة.  في الشبكة الدلالية ، هذا يعني أن التوزيع <img src="https://habrastorage.org/webt/hn/r0/ww/hnr0wwjntvtnl8pymcmhkfjsawc.png">  القمم المختلفة لها اختلافات واضحة.  بادئ ذي بدء ، نقدم كل توزيع <img src="https://habrastorage.org/webt/hn/r0/ww/hnr0wwjntvtnl8pymcmhkfjsawc.png">  مثل متجه n- الأبعاد <img src="https://habrastorage.org/webt/nv/ky/pn/nvkypndwq-7j6xnikrteas3oiq4.png">  حيث ن = | <img src="https://habrastorage.org/webt/a-/v8/rh/a-v8rh1ddeh_ai-eawq8udhqe80.png">  |  - حجم القاموس.  بمقياس معين لمسافة المتجه d (في تجاربنا نستخدم المسافة بين المتجهات pL1) نعني <img src="https://habrastorage.org/webt/jc/z9/de/jcz9demx4drw0fsgz1niisgavd0.png">  ، أي أن المسافة بين الذروتين تساوي المسافة بين توزيعاتهم. <br><br>  الهدف الواضح هو زيادة المسافة الإجمالية بين جميع أزواج القمم.  ومع ذلك ، قد يكون تحسين جميع المسافات الزوجية معقدًا جدًا للحسابات ، وحتى هذا ليس ضروريًا.  زوج من القمم البعيدة له بالفعل اختلافات كافية ، لذلك لا معنى لزيادة أخرى في المسافة.  بدلاً من ذلك ، يمكننا التركيز على أزواج القمم التي تسبب أكبر قدر من الارتباك ، أي أن المسافة بينهما هي الأصغر. <br><br><img src="https://habrastorage.org/webt/of/tp/sl/oftpslo2cmmijyxtccepbyqsmsc.png"><br><br>  أين <img src="https://habrastorage.org/webt/1g/-h/nh/1g-hnhpklydkghmo4z7pq7ujouu.png">  يشير إلى أزواج K الأولى من القمم إذا قمنا بترتيب جميع أزواج العقد حسب المسافة بترتيب تصاعدي. <br><br>  <i>الخوارزمية 2. علق بشكل متكرر شبكة دلالية مع سياسة</i> <br><br><img src="https://habrastorage.org/webt/5p/j2/2r/5pj22rp_c5npknusixp4k4ulfli.png"><br><br>  <i>الخوارزمية 3. حساب السياسة على أساس الانتشار التفاضلي</i> <br><br><img src="https://habrastorage.org/webt/s5/ee/zb/s5eezb7ls03ly9nfndyotsqhlva.png"><br><br>  <i>الخوارزمية 4. نشر النقاط بشكل متكرر من عقدة مصدر إلى كافة العقد الأصل الخاصة بها</i> <br><br><img src="https://habrastorage.org/webt/m9/ge/vt/m9gevt8-vlgwxxulaxyfxkovdmk.png"><br><br>  من المحتمل أن تؤدي القمم ذات المحتوى المعلوماتي الأعلى بعد التعليق التوضيحي إلى زيادة قيمة Θ.  من أجل القياس الكمي في هذه الحالة ، نقترح استخدام استراتيجية توزيع تفاضلي.  إذا كانت المسافة بين زوج من القمم صغيرة ، فإننا نفحص جميع القمم الأصلية: إذا كانت القمة الرئيسية شائعة لزوج من القمم ، فيجب أن تحصل على تصنيف منخفض ، لأن التعليق التوضيحي سيؤدي إلى تغييرات مماثلة لكل من القمم. <br><br>  خلاف ذلك ، يجب أن يكون رأس القمة عالي التصنيف ، وكلما اقترب الزوج من القمم ، زاد التصنيف.  على سبيل المثال ، إذا كانت المسافة بين رؤوس "رسائل البريد الإلكتروني غير المقروءة حول تطبيق PhD" و "عدد رسائل البريد الإلكتروني المتعلقة بتطبيق PhD" صغيرة ، فإن التعليق التوضيحي لرأسها الرئيسي "رسائل البريد الإلكتروني حول تطبيق PhD" لا معنى له من وجهة نظر تمييز هذه القمم.  من المستحسن أكثر إضافة تعليق على العقد الأصلية التي لن تكون شائعة بالنسبة لهم: "رسائل البريد الإلكتروني غير المقروءة" و "عدد رسائل البريد الإلكتروني". <br><br>  يظهر مثال لمثل هذا الموقف في الشكل 6 ، والخوارزمية الخاصة به هي الخوارزمية 3. كتقدير ، نأخذ المتبادل لمسافة العقدة التي يحدها ثابت (الخط 6) ، لذلك يكون لأقرب أزواج القمم التأثير الأكبر.  عند العمل مع زوج من القمم ، نقوم في نفس الوقت بتعيين تقييم لكل قمة لجميع القمم الرئيسية (السطر 9 و 10 والخوارزمية 4).  تقدير قمة غير ملحوظة هو الفرق المطلق في تقديرات الزوج المقابل من القمم مع الجمع على جميع أزواج القمم (السطر 12). <br><br><h2 style=";text-align:right;direction:rtl">  واجهة اللغة الطبيعية </h2><br>  لتقييم الإطار المقترح ، من الضروري تدريب نماذج NL2API باستخدام البيانات التي تم جمعها.  في الوقت الحالي ، لا يتوفر نموذج NL2API النهائي ، ولكننا نقوم بتكييف نموذجين NLI تم اختبارهما من مناطق أخرى لتطبيقهما على API. <br><br><h4 style=";text-align:right;direction:rtl">  نموذج استخراج نموذج اللغة </h4><br>  استنادًا إلى التطورات الأخيرة في مجال NLI لقواعد المعرفة ، يمكننا التفكير في إنشاء NL2API في سياق مشكلة استخراج المعلومات من أجل تكييف نموذج الاستخراج استنادًا إلى نموذج اللغة (LM) لظروفنا. <br><br>  لقول u ، تحتاج إلى العثور على مكالمة API z في الشبكة الدلالية بأفضل تطابق لـ u.  أولاً نقوم بتحويل توزيع BoB <img src="https://habrastorage.org/webt/rq/qs/9-/rqqs9-qn12-qsdd7mahxx5tg-si.png">  كل استدعاء لـ API z إلى نموذج unigram للغة: <br><br><img src="https://habrastorage.org/webt/lr/4f/pt/lr4fptel7voyxz2pelzjinbyu14.png"><br><br>  حيث نستخدم التجانس الإضافي ، و 0 ≤ β ≤ 1 هي معلمة التنعيم.  قيمة أعلى <img src="https://habrastorage.org/webt/rh/1e/wc/rh1ewczas_fvleaxd5za0qvury0.png">  ، زاد وزن الكلمات التي لم يتم تحليلها بعد.  يمكن تصنيف مكالمات API حسب الاحتمالية اللوغاريتمية: <br><br><img src="https://habrastorage.org/webt/3c/sf/fu/3csffus3jr7h6kpxq6czdyvhdtm.png"><br><br>  (تخضع لتوزيع احتمالي مسبق) <br><br><img src="https://habrastorage.org/webt/0s/xu/y-/0sxuy-xon3k12zlsbn2f41wzyco.png"><br><br>  يتم استخدام مكالمة API الأعلى تقييمًا كنتيجة محاكاة. <br><br><h4 style=";text-align:right;direction:rtl">  Seq2Seq إعادة صياغة الوحدة النمطية </h4><br>  أصبحت الشبكات العصبية أكثر انتشارًا كنماذج لـ NLI ، في حين أن نموذج Seq2Seq أفضل من الآخرين لهذا الغرض ، لأنه يسمح لك بمعالجة تسلسل المدخلات والمخرجات ذات الأطوال المتغيرة بشكل طبيعي.  نقوم بتكييف هذا النموذج مع NL2API. <br><br>  لتسلسل الإدخال ه <img src="https://habrastorage.org/webt/sl/zv/2w/slzv2wvhssrsrt-2cehxkcosmr0.png">  ، يقدّر النموذج التوزيع الاحتمالي الشرطي p (y | x) لجميع تتابعات الإخراج الممكنة <img src="https://habrastorage.org/webt/zz/ar/74/zzar74ttz1utynmp2qpkuprrhwc.png">  .  يمكن أن تختلف أطوال T و T and وتأخذ أي قيمة.  في NL2API ، x هو بيان الإخراج.  يمكن أن تكون y مكالمة API متسلسلة أو أمرها الأساسي.  سنستخدم الأوامر الأساسية كتسلسلات إخراج الهدف ، والتي تحول في الواقع مشكلتنا إلى مشكلة إعادة صياغة. <br><br>  المشفر الذي يتم تنفيذه كشبكة عصبية متكررة (RNN) مع وحدات التكرار الخاضعة للرقابة (GRU) يمثل أولاً x كمتجه ذي حجم ثابت ، <br><br><img src="https://habrastorage.org/webt/_l/vv/ht/_lvvhtq3g73uajiwibi7r5xzspc.png"><br><br>  حيث RN N هو تمثيل موجز لتطبيق GRU على تسلسل الإدخال بأكمله ، علامة بعلامة ، متبوعًا بإخراج آخر حالة مخفية. <br><br>  يأخذ مفكك التشفير ، وهو أيضًا RNN مع GRU ، h0 كحالة أولية ويعالج تسلسل الإخراج y ، علامة بعلامة ، لتوليد تسلسل من الحالات ، <br><br><img src="https://habrastorage.org/webt/eo/lg/9l/eolg9ljwlyskjfurunypvlmswaa.png"><br><br>  تأخذ طبقة الإخراج كل حالة لفك الشفرة كقيمة إدخال وتولد توزيع القاموس <img src="https://habrastorage.org/webt/a-/v8/rh/a-v8rh1ddeh_ai-eawq8udhqe80.png">  كقيمة الإخراج.  نحن نستخدم فقط تحويل التابعين متبوعًا بالوظيفة اللوجيستية متعددة المتغيرات softmax: <br><br><img src="https://habrastorage.org/webt/qr/ty/c9/qrtyc9lsayvqiczswbr-837_pba.png"><br><br>  الاحتمال الشرطي النهائي ، الذي يسمح لنا بتقييم مدى جودة الأمر الأساسي y يعيد صياغة بيان الإدخال x ، هو <img src="https://habrastorage.org/webt/l5/yt/wn/l5ytwnga_iegxtspqogvabwe5g0.png"><img src="https://habrastorage.org/webt/ul/7k/ny/ul7knyk1imjwc0p_hrjisfmy8-e.png">  .  يتم تصنيف مكالمات API بعد ذلك حسب الاحتمال الشرطي لأمرها الأساسي.  نوصي بأن تتعرف على المصدر ، حيث يتم وصف عملية التعلم النموذجية بمزيد من التفصيل. <br><br><h2 style=";text-align:right;direction:rtl">  التجارب </h2><br>  من الناحية التجريبية ، ندرس مواضيع البحث التالية: [PI1]: هل يمكننا استخدام الإطار المقترح لجمع بيانات تدريب عالية الجودة بسعر معقول؟  [PI2]: هل توفر الشبكة الدلالية تقييمًا أكثر دقة لنماذج اللغة من تقييم الاحتمالية القصوى؟  [PI3]: هل تعمل استراتيجية التوزيع التفاضلي على تحسين كفاءة التعهيد الجماعي؟ <br><br><h4 style=";text-align:right;direction:rtl">  التعهيد الجماعي </h4><br>       -API  Microsoft — GET-Events  GET-Messages —              .       API,    API ( 3.1)      .   API    2.      ,  Amazon Mechanical Turk.    ,     API    . <br><br>             .   API  10 ,       10 .    201 ,        .          44 ,     82       ,    8,2 , ,   ,  .    ,    400    ,     17,4 %. <br><br>         (,     ORDERBY  a COUNT parameter)     (,    ,        ).       .            NLI.  ,  ,    [1] .           . <br><br>  ,      ,         ,   ,  API    (. 3).   API       .        ,    .     61  API  157   GET-Messages,   77  API  190   GET-Events.        ,  ,    API (,    )     , ,     . <br><br><img src="https://habrastorage.org/webt/dc/yk/nv/dcyknvmod2su0cutkru02tpklti.png"><br> <i> 2.   API.</i> <br><br><img src="https://habrastorage.org/webt/x9/dm/_b/x9dm_bbbgyua7xe0cl1fzjloc5o.png"><br> <i> 3.   :  ().</i> <br><br><h4 style=";text-align:right;direction:rtl">   </h4><br>       ,     ,      .    ,   α = 0,3,    LM β = 0,001.    K,    ,  100 000.    , ,      Seq2Seq — 500.           (  ). <br><br>                  NLI,     .          . <br><br><h4 style=";text-align:right;direction:rtl">    </h4><br>  .         ,  ,            .         LM:   ,   .     ,     . ROOT —   . TOP2 = ROOT +    2;  TOP3 = TOP2 +    3.            . <br><br>     4.      LM      (MLE)    ,     <img src="https://habrastorage.org/webt/u4/o6/hw/u4o6hwaxkucqpz_fmcsbca0eqqo.png">    ,      . ,    ,      ,  MLE       . <br><br>    MLE,      <img src="https://habrastorage.org/webt/rz/hi/nv/rzhinvau9uyozj1iphz8idarw9m.png">   ,  <img src="https://habrastorage.org/webt/1d/h2/o8/1dh2o8om1hinyzi3r41ipp4pd3e.png"> -    ,    .     API    .    16   API (ROOT)   LM  SeMesh        Seq2Seq       API (TOP2)    ,   500   API (TOP3). <br><br>    ,   ,     ,  ,     ( 3.2)   .  ,    GET-Events    ,   GET-Messages.   ,  GET-Events  <br>  ,    ,        ,         . <br><br><img src="https://habrastorage.org/webt/pb/ym/e4/pbyme4xdpxcqabwlawu_bmkefkg.png"><br> <i> 4.    .        LM,       Seq2Seq,      .  ,        .</i> <br><br>  LM +  ,      ,       <img src="https://habrastorage.org/webt/1d/h2/o8/1dh2o8om1hinyzi3r41ipp4pd3e.png">     θem with <img src="https://habrastorage.org/webt/rz/hi/nv/rzhinvau9uyozj1iphz8idarw9m.png">  .    <img src="https://habrastorage.org/webt/1d/h2/o8/1dh2o8om1hinyzi3r41ipp4pd3e.png">  و <img src="https://habrastorage.org/webt/rz/hi/nv/rzhinvau9uyozj1iphz8idarw9m.png"> ,    ,    ROOT,          <img src="https://habrastorage.org/webt/1d/h2/o8/1dh2o8om1hinyzi3r41ipp4pd3e.png">  و <img src="https://habrastorage.org/webt/rz/hi/nv/rzhinvau9uyozj1iphz8idarw9m.png">  .    ,        ,    .             MLE.  ,  ,    [2] . <br><br>        0,45  0,6:    ,           NLI   .    ,            API.        API (.   7)     ,    RNN   ,     .       . <br><br>  .        :   |u |    α.   -     LM ( 7).    ,  |u | &lt; 10,         10  .     GET-Events,  GET-Messages  . <br><br> ,         ,   ,    . ,    ,    .   ,       α,        ([0.1, 0.7]).   α      ,   ,      . <br><br><h4 style=";text-align:right;direction:rtl">   </h4><br>            (DP)   .       API  .       50  API,    ,    NL2API      . <br><br> ,     .     LM,      .             .           ,       ( 5.1),          API   . <br><br><img src="https://habrastorage.org/webt/lg/xz/z9/lgxzz9zznpwnk0c4vdqfnfaurrg.png"><br>  7.  . <br><br><img src="https://habrastorage.org/webt/ak/5p/da/ak5pda8vlogeadhfjphy-t33dcg.png"><br>  8.    . : GET-Events. : GET-Messages <br><br>       breadth first (BF),          .    .     .  API    ,       API  . <br><br>      8.    NL2API   API  DP      .     300    API,    Seq2Seq, DP      7 %   API.       ,  .  ,  DP    API,      NL2API.  ,  ,    [3] . <br><br><h2 style=";text-align:right;direction:rtl">    </h2><br> - .   -  (NLI)     .  NLI    . ,   ,       .                . <br><br>      NLI    ,    -,    API   .  NL2API     :      API ,   - ,   .      .      API    REST           . <br><br> <b>    NLI.</b>        NLI    «  ». ,         Google Suggest API,        API   IFTTT.         NLI,       .        ,   . <br><br>          NLI,                  .        NLI   ,          .           ,           ,        . <br><br>                  API  .         ,          -API.                  . <br><br> <b>   -API.</b>     ,   -API. ,   -API      API,         -API   .  NL2API     , ,          API. <br><br><h2 style=";text-align:right;direction:rtl">      </h2><br>     -   -API (NL2API)       NL2API  .                NL2API   .       : (1)  .            , , ? (2)  . <br><br>      ? (3)  NL2API. ,               API. (4)  API.         API? (5)    :    NL2API        ? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar418559/">https://habr.com/ru/post/ar418559/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar418547/index.html">البرمجة غير المتزامنة مع أمثلة: إعادة بناء java.util.concurrent.CompletableFuture أساليب</a></li>
<li><a href="../ar418549/index.html">إنشاء روبوت للمشاركة في AI mini cup 2018 على أساس شبكة عصبية متكررة (الجزء 3)</a></li>
<li><a href="../ar418551/index.html">كم يجب أن يعرف المبرمج الرياضيات؟</a></li>
<li><a href="../ar418553/index.html">Kotlin + React vs Javasript + React</a></li>
<li><a href="../ar418557/index.html">حساب عمليات الموجة في خط هيدروليكي باستخدام طريقة الخصائص</a></li>
<li><a href="../ar418561/index.html">آلات الدولة في خدمة MVP. محاضرة ياندكس</a></li>
<li><a href="../ar418563/index.html">ملخص المواد المثيرة للاهتمام لمطور الجوال رقم 263 (23 يوليو - 29 يوليو)</a></li>
<li><a href="../ar418565/index.html">في الطريق إلى تغطية رمز 100 ٪ مع الاختبارات في Go باستخدام sql-dumper كمثال</a></li>
<li><a href="../ar418567/index.html">ستتوقف شركة Dell عن كونها شركة خاصة وللمرة الأولى منذ 5 سنوات ستطرح أسهمًا في البورصة</a></li>
<li><a href="../ar418569/index.html">الأقمار الصناعية الجديدة - البق الجديد: مستشعر الأشعة تحت الحمراء GOES-17 للأقمار الصناعية لا يبرد بشكل جيد</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>