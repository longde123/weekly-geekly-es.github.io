<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥌 🧚 🕴🏿 Redis sinkronisasi cache untuk layanan Go 🎢 ❇️ 🗿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 


 Selama penyempurnaan satu proyek, menjadi perlu untuk men-cache data yang sering diminta. Implementasi caching dimungkinkan dengan ber...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Redis sinkronisasi cache untuk layanan Go</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482704/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/5c/31/wd5c31_fbcdgecl9nmma5flqsoy.png" width="300"></div><br><h2 id="vvedenie">  Pendahuluan </h2><br><p>  Selama penyempurnaan satu proyek, menjadi perlu untuk men-cache data yang sering diminta.  Implementasi caching dimungkinkan dengan berbagai cara, tetapi saya ingin mengimplementasikannya dengan sedikit perubahan pada proyek asli.  Hasilnya, pro dan kontra dijelaskan di bawah ini. </p><a name="habracut"></a><br><h2 id="kak-vsyo-bylo">  Bagaimana semuanya? </h2><br><p>  Awalnya, untuk setiap kueri yang berisi pengidentifikasi objek yang diminta, kueri dieksekusi dalam database PostgreSQL (DB).  Lebih tepatnya, beberapa pertanyaan, karena untuk membentuk jawaban yang lengkap, perlu diterapkan ke beberapa tabel database.  Sebagai hasil dari pemrosesan permintaan, objek yang agak rumit terbentuk, beberapa bidang diwakili oleh antarmuka.  Dalam memori, objek ini menempati sekitar 250 kB. </p><br><p>  Performa dengan implementasi ini tidak bagus, tidak lebih dari 3500 RPS (permintaan per detik) ketika meminta data yang sama dengan 1000 utas yang bersaing. </p><br><p>  Pertanyaan segera muncul, tetapi bagaimana cara meningkatkan RPS: mengubah router, mengoptimalkan database, data cache?  Router digunakan dengan cukup baik ( <a href="httprouter" rel="nofollow">github.com/julienschmidt/httprouter</a> ), dan mengganti router dalam proyek besar akan membutuhkan banyak waktu dan ada risiko tinggi akan terjadi kerusakan.  Untuk mengoptimalkan pekerjaan dengan database, Anda juga perlu menulis ulang sebagian besar kode (sekarang <a href="http://github.com/jmoiron/sqlx" rel="nofollow">github.com/jmoiron/sqlx</a> digunakan).  Jelas, caching adalah cara paling optimal untuk meningkatkan RPS. </p><br><h2 id="prostoe-reshenie">  Solusi sederhana </h2><br><p>  Hal paling sederhana yang terlintas dalam pikiran adalah penggunaan cache dalam memori.  Saat menggunakan cache seperti itu, sekitar 20.000 RPS diperoleh.  Kinerja cache dalam memori sangat baik, tetapi Anda tidak dapat menggunakan cache seperti itu dengan banyak contoh layanan.  Anda tidak pernah tahu layanan dari mana permintaan akan terbang, dan mungkin ada permintaan tidak hanya untuk menerima data, tetapi juga untuk menghapus / memperbarui. </p><br><p>  Kinerja yang diperoleh dengan cache di memori diambil sebagai standar dalam pencarian lebih lanjut untuk solusi. </p><br><h2 id="ideya-plohaya-ideya">  Ide, ide buruk </h2><br><p>  Apakah mungkin untuk memasukkan hasil query seperti di database NoSQL Redis?  Ini adalah solusi khas untuk caching permintaan respons.  Data disimpan dalam memori, saat menggunakan beberapa contoh layanan, semuanya dapat menggunakan cache umum.  Solusi ini cepat diimplementasikan.  Dan tes menunjukkan ... Dan tes menunjukkan bahwa kinerjanya tidak meningkat banyak. <br>  Penelitian lebih lanjut menunjukkan bahwa kerugian kinerja utama dikaitkan dengan marshaling dan unmarshaling.  Mengubah struktur ke JSON dan sebaliknya membutuhkan penggunaan refleksi, yang sangat mahal dalam kinerja.  Tidak mungkin untuk menolak marshaling / unmarshaling, karena itu perlu untuk mendapatkan objek penuh dari cache dengan kemampuan untuk memanggil metode struktur, dan tidak hanya mendapatkan nilai dari masing-masing bidang.  Menggunakan berbagai pustaka dengan optimalisasi marshaling / unmarshaling juga tidak menyimpan, ada pertumbuhan, tetapi cache di dalam memori sangat jauh.  Oleh karena itu, diputuskan untuk tidak berteman dengan "landak dan ular" dan membuat cache hybrid. </p><br><h2 id="gibrid-uzha-i-ezha">  Ular dan landak hibrida </h2><br><p>  Anda tidak dapat menyebutnya hibrida penuh (lihat. Gbr.), Bahkan, ternyata cache dalam memori, tetapi dengan sinkronisasi melalui Redis (perpustakaan <a href="http://github.com/go-redis/redis" rel="nofollow">github.com/go-redis/redis digunakan</a> ).  Hanya pengidentifikasi unik objek yang diminta dari database (objek ID) yang akan disimpan dalam Redis.  Ini akan ditambahkan ke Redis selama pemrosesan permintaan untuk membuat objek, atau permintaan untuk mendapatkan objek yang ada dari database.  ID objek akan berfungsi sebagai kunci untuk nilai dalam Redis, dan nilainya akan menjadi UUID yang dihasilkan (pengidentifikasi unik universal, pengidentifikasi unik universal ”).  UUID akan dihasilkan hanya ketika objek ditambahkan ke Redis.  Mengapa UUID ini diperlukan akan dijelaskan nanti. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jh/nr/x7/jhnrx7d01qxmgll-s4jtcz4cc7g.jpeg"></div><br><p>  <b>Blok diagram interaksi komponen untuk sinkronisasi cache melalui Redis</b> </p><br><p>  Cache dalam memori diimplementasikan berdasarkan sync.Map.  Untuk item cache hybrid, TTL (waktu untuk hidup, seumur hidup) diatur, dan jika Redis membersihkan item "busuk", maka cache dalam memori dibersihkan oleh timer (time.AfterFunc).  Itu melewati semua elemen cache dan memeriksa apakah elemen itu "busuk".  Jika elemen cache diakses, masa pakainya diperpanjang, operasi serupa dilakukan dengan kunci di Redis. </p><br><p>  Jadi, sekarang sesuai dengan algoritma.  Jika permintaan datang dan kami perlu mengambil objek, urutan tindakan berikut dilakukan: </p><br><ol><li>  Kami melihat apakah ada objek dengan ID-objek yang diberikan di Redis, jika demikian, maka kita dapat mengambil cache instance layanan dari dalam memori: <br><ol><li>  Jika objek tidak ada dalam cache di-memori, maka kita mengambilnya dari database dan menambahkan cache dengan UUID dari Redis ke cache di-memori dan memperbarui TTL dari kunci di Redis. </li><li>  Jika objek berada di cache di memori, maka kami mengambilnya dari cache, memeriksa apakah UUID di cache dan di Redis cocok, dan jika demikian, kemudian perbarui TTL di cache dan di Redis.  Jika UUID tidak cocok, maka hapus objek dari cache di memori, ambil dari database, tambahkan cache dengan UUID dari Redis ke dalam memori. </li></ol></li><li>  Jika objek tidak ada di Redis, maka jika objek berada di cache, hapus dari cache.  Ambil objek dari database dan tambahkan ke cache dan ke Redis.  Untuk menghilangkan situasi ketika memperbarui / menghapus entri lebih cepat daripada menambahkan ke cache ( <a href="https://habr.com/ru/post/482704/">andreyverbin comment</a> ), tambahkan objek dengan UUID nol ke cache.  Kemudian pada akses pertama ke cache, perbedaan dalam UUID dengan Redis akan terungkap, dan data dari database akan diminta lagi. </li></ol><br><p>  Jika permintaan untuk menghapus suatu objek tiba, itu segera dihapus dari database, dan kemudian operasi cache: </p><br><ol><li>  Hapus objek di Redis. </li><li>  Hapus objek dalam cache di memori. </li></ol><br><p>  Sekarang, jika permintaan serupa tiba di instance lain dari layanan, maka meskipun objek masih dalam cache di-memori, itu tidak akan digunakan. </p><br><p>  Pembaruan objek, setelah memperbarui dalam database: </p><br><ol><li>  Hapus objek di Redis. </li><li>  Hapus objek dalam cache di memori. </li></ol><br><p>  Ketika Anda meminta objek dalam instance lain dari layanan, itu akan terungkap bahwa itu bukan di Redis, jadi Anda perlu mengambilnya dari database.  Jika ada contoh lain dari layanan, dan permintaan terbang ke sana setelah memperbarui objek dan setelah menambahkannya dengan contoh kedua di Redis, maka, ketika memeriksa UUID, perbedaan akan terungkap, dan contoh ketiga dari layanan juga akan mengambil objek dari database. </p><br><p>  Yaitu  pada kenyataannya, dalam situasi apa pun yang tidak dapat dipahami, kami percaya bahwa cache kami tidak benar, dan kami perlu mengambil data dari database. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Solusi yang dikembangkan memiliki pro dan kontra. </p><br><h3 id="plyusy">  Pro </h3><br><ul><li>  Skema caching yang dikembangkan memungkinkan untuk mencapai sekitar 19000 RPS, yang hampir setara dengan tes dengan cache dalam memori. </li><li>  Kode proyek asli memiliki jumlah minimum perubahan. </li></ul><br><h3 id="minusy">  Cons </h3><br><ul><li>  Jika Redis crash, layanan secara drastis menurun dalam kinerja dan bersandar pada bekerja dengan database. </li><li>  Setiap instance dari layanan akan membutuhkan lebih banyak memori karena memiliki cache di-memori sendiri. </li></ul><br><p>  Karena kinerja tinggi lebih penting, saya tidak menganggap minus menjadi penting.  Di masa depan, ada ide untuk menulis perpustakaan untuk menyederhanakan implementasi cache hybrid, karena ada kebutuhan untuk menggunakan caching serupa di proyek lain. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id482704/">https://habr.com/ru/post/id482704/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id482692/index.html">Rumah Intel NUC untuk Bekerja dan Virtualisasi</a></li>
<li><a href="../id482694/index.html">Apakah ada kehidupan setelah Windows atau di mana mengembangkan administrator / insinyur sistem Windows pada tahun 2020?</a></li>
<li><a href="../id482698/index.html">[Esai] Didedikasikan untuk Kantor Plankton. Saya tidak terinspirasi oleh pekerjaan saya</a></li>
<li><a href="../id482700/index.html">Cara "bercinta" Google dan Yandex: promosi situs hitam dan putih SEO. Shestakov | Orang PRO # 74</a></li>
<li><a href="../id482702/index.html">Apakah kita benar-benar membutuhkan TypeScript pada tahun 2020?</a></li>
<li><a href="../id482706/index.html">Rekomendasi untuk penerapan akuntansi paralel RAS + IFRS pada platform 1C</a></li>
<li><a href="../id482708/index.html">Salah satu fitur budaya perusahaan yang diperlukan untuk kesejahteraan basis kode</a></li>
<li><a href="../id482714/index.html">Kolom radio Internet paling sederhana "Kodi" atau penyelamatan bata "Raspberry"</a></li>
<li><a href="../id482716/index.html">Pengembangan papan debug untuk K1986BE1QI (air)</a></li>
<li><a href="../id482718/index.html">Piramida terbalik sebagai akhir dari proyek Anda</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>