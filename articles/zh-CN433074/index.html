<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😲 🌷 💽 在Android项目中切换到Kotlin：提示和技巧 🗂️ 🍠 🚷</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="由DataArt强壮的Android开发人员Sergey Yeshin发布 

 自Google宣布对Android中的Kotlin正式支持以来，已经过去了一年半，经验最丰富的开发人员开始在战斗中进行试验，而三年前还没有进行过此类项目。 

 这种新语言在Android社区中受到热烈欢迎，并且绝大多...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在Android项目中切换到Kotlin：提示和技巧</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dataart/blog/433074/"><img src="https://habrastorage.org/webt/ss/no/sd/ssnosdopahysny9zaa0gevj_u54.jpeg"><br>  <i>由DataArt强壮的Android开发人员Sergey Yeshin发布</i> <br><br> 自Google宣布对Android中的Kotlin正式支持以来，已经过去了一年半，经验最丰富的开发人员开始在战斗中进行试验，而三年前还没有进行过此类项目。 <br><br> 这种新语言在Android社区中受到热烈欢迎，并且绝大多数新的Android项目将从Kotlin入手。  Kotlin编译为JVM字节码也很重要，因此，它必须与Java完全兼容。 因此，在用Java编写的现有Android项目中，也有机会（此外，有必要）使用Kotlin的所有功能，这使他获得了众多粉丝。 <br><br> 在本文中，我将讨论将Android应用程序从Java迁移到Kotlin的经验，在此过程中必须克服的困难，并说明为什么所有这些都没有白费。 本文主要针对刚开始学习Kotlin的Android开发人员，除个人经验外，还依赖于其他社区成员的资料。 <a name="habracut"></a><br><br><h2> 为什么选择科特林？ </h2><br> 简要描述Kotlin的功能，由于这个原因，我在项目中切换到它，离开了“舒适而痛苦的熟悉” Java世界： <br><br><ol><li> 全面的Java兼容性 </li><li> 空安全 </li><li> 类型推断 </li><li> 扩展方式 </li><li> 用作一流和lambda对象 </li><li> 泛型 </li><li> 协程 </li><li> 无检查异常 </li></ol><br><h2>  DISCO应用 </h2><br> 这是用于交换折扣卡的小型应用程序，由10个屏幕组成。 使用他的示例，我们将考虑迁移。 <br><br><h3> 简要介绍建筑 </h3><br> 该应用程序将MVVM体系结构与Google体系结构组件一起使用：ViewModel，LiveData，Room。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oe/n1/e4/oen1e4fepl7q4ff8zdth-jxwjlk.png"></div><br> 另外，根据Bob叔叔的“干净架构”原则，我在应用程序中选择了3个层：数据，域和表示。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/em/o4/rz/emo4rzbpvpeadmnhzucuyhhtzpq.png"></div><br> 从哪里开始？ 因此，我们设想了Kotlin的主要功能，并对需要迁移的项目有了一个最小的想法。 自然的问题是“从哪里开始？”。 <br><br> 官方的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Kotlin</a> Android <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">入门</a>文档页面说，如果要将现有应用程序移植到Kotlin，则只需开始编写单元测试。 当您对这种语言有一点了解后，可以用Kotlin编写新代码，您只需要转换现有的Java代码即可。 <br><br> 但是只有一个“但是”。 确实，通过简单的转换通常（尽管并非总是如此）可以使您在Kotlin上获得有效的代码，但是，它的成语还有很多不足之处。 此外，我将告诉您如何消除Kotlin语言所提到的（不仅是）功能所带来的差距。 <br><br><h2> 层迁移 </h2><br> 由于应用程序已经分层，因此从顶部开始逐层迁移是有意义的。 <br><br> 下图显示了迁移期间的层顺序： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kp/oq/k_/kpoqk_8rpc0xg9qstzecyrlp_is.png"></div><br> 我们恰好从上层开始迁移并非偶然。 因此，我们避免了自己在Java代码中使用Kotlin代码。 相反，我们使上层的Kotlin代码使用下层的Java类。 事实是，Kotlin最初的设计考虑了与Java交互的需求。 现有的Java代码可以自然地从Kotlin调用。 我们可以轻松地从现有Java类继承，访问它们并将Java注释应用于Kotlin类和方法。  Kotlin代码也可以在Java中使用而不会带来太多麻烦，但是通常需要花费额外的精力，例如添加JVM注释。 又为什么在Java代码中进行不必要的转换（如果最终仍将用Kotlin重写）呢？ <br><br> 例如，让我们看一下过载的产生。 <br><br> 通常，如果您使用默认参数值编写Kotlin函数，则该函数仅在Java中作为具有所有参数的完整签名可见。 如果要为Java调用提供多个重载，则可以使用@JvmOverloads批注： <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JvmOverloads</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constructor</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Int</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Double</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-number"><span class="hljs-number">0.0</span></span>) { <span class="hljs-meta"><span class="hljs-meta">@JvmOverloads</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: String, b: Int = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, c: String = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"abc"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ ... } }</code> </pre> <br> 对于具有默认值的每个参数，这将创建一个额外的重载，该重载在远程参数列表中具有该参数及其右侧的所有参数。 在此示例中，将创建以下内容： <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Constructors: Foo(int x, double y) Foo(int x) // Methods void f(String a, int b, String c) { } void f(String a, int b) { } void f(String a) { }</span></span></code> </pre> <br> 有许多使用JVM注释来正确运行Kotlin的示例。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">该文档页面</a>详细介绍了从Java到Kotlin的调用。 <br><br> 现在我们逐层描述迁移过程。 <br><br><h3> 表示层 </h3><br> 这是一个用户界面层，其中包含带有视图的屏幕和一个ViewModel，而后者又包含LiveData形式的属性以及来自模型的数据。 接下来，我们来看一下在迁移此应用程序层时有用的技巧和工具。 <br><br><h4>  1. Kapt注释处理器 </h4><br> 与任何MVVM一样，View通过数据绑定绑定到ViewModel属性。 对于Android，我们正在处理使用注解处理的Android Databind库。 因此Kotlin有<b>其自己的注释处理器</b> ，如果您不对相应的build.gradle文件进行更改，则该项目将停止构建。 因此，我们将进行以下更改： <br><br><pre> <code class="java hljs">apply plugin: <span class="hljs-string"><span class="hljs-string">'kotlin-kapt'</span></span> android { dataBinding { enabled = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> } } dependencies { <span class="hljs-function"><span class="hljs-function">api </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fileTree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir: </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'libs'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, include: [</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'*.jar'</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">///… kapt "com.android.databinding:compiler:$android_plugin_version" }</span></span></span></span></code> </pre><br> 重要的是要记住，必须用kapt完全替换build.gradle中所有出现的commentProcessor配置。 <br><br> 例如，如果您在项目中使用Dagger或Room库，并且它们也在后台使用注释处理器进行代码生成，则必须将kapt指定为注释处理器。 <br><br><h4>  2.内联函数 </h4><br> 将功能标记为内联时，我们要求编译器将其放置在使用位置。 函数的主体被嵌入，换言之，它代替了函数的常规用法。 因此，我们可以规避类型擦除的限制，即擦除类型。 使用内联函数时，我们可以在运行时获取类型（类）。 <br><br> 我的代码中使用Kotlin的此功能来“提取”已启动的Activity的类。 <br><br><pre> <code class="scala hljs">inline fun &lt;reified <span class="hljs-type"><span class="hljs-type">T</span></span> : <span class="hljs-type"><span class="hljs-type">Activity</span></span>&gt; <span class="hljs-type"><span class="hljs-type">Context</span></span>?.startActivity(args: <span class="hljs-type"><span class="hljs-type">Bundle</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>?.let { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> intent = <span class="hljs-type"><span class="hljs-type">Intent</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">intent</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">putExtras</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">args</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">it</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">startActivity</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">intent</span></span></span><span class="hljs-class">) } }</span></span></code> </pre> <br> 修饰-指定修饰类型。 <br><br> 在上述示例中，我们还谈到了Kotlin语言的扩展功能。 <br><br><h4>  3.扩展 </h4><br> 它们是扩展。 实用程序方法是在扩展中删除的，这有助于避免过分庞大的类实用程序。 <br><br> 我将举例说明该应用程序涉及的扩展： <br><br><pre> <code class="scala hljs">fun <span class="hljs-type"><span class="hljs-type">Context</span></span>.inflate(res: <span class="hljs-type"><span class="hljs-type">Int</span></span>, parent: <span class="hljs-type"><span class="hljs-type">ViewGroup</span></span>? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>): <span class="hljs-type"><span class="hljs-type">View</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">LayoutInflater</span></span>.from(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).inflate(res, parent, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) } fun &lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt; <span class="hljs-type"><span class="hljs-type">Collection</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt;?.isNotNullOrEmpty(): <span class="hljs-type"><span class="hljs-type">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; isNotEmpty(); } fun <span class="hljs-type"><span class="hljs-type">Fragment</span></span>.hideKeyboard() { view?.let { hideKeyboard(activity, it.windowToken) } }</code> </pre> <br>  Kotlin开发人员通过提供Kotlin Android Extensions插件预先考虑了有用的Android扩展。 他提供的功能包括View绑定和Parcelable支持。 有关此插件功能的详细信息，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a> 。 <br><br><h4>  4. Lambda函数和高阶函数 </h4><br> 使用Android代码中的lambda函数，您可以摆脱笨拙的ClickListener和回调，这在Java中是通过自写接口实现的。 <br><br> 使用lambda代替onClickListener的示例： <br><br><pre> <code class="java hljs">button.setOnClickListener({ doSomething() })</code> </pre> <br>  Lambda也用于高阶函数，例如，用于收集函数。 <br><br> 以<b>地图</b>为例： <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(transform: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; R): List&lt;R&gt; {...}</code> </pre> <br> 我的代码中有一个地方需要“映射”卡的ID，以便随后将其删除。 <br><br> 使用传递给map的lambda表达式，我得到了所需的id数组： <br><br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ids = cards.map { it.id }.toIntArray() cardDao.deleteCardsByIds(ids)</code> </pre> <br> 请注意，如果lambda是唯一的参数，而关键字关键字是唯一的参数的隐式名称，则在调用函数时可以完全省略括号。 <br><br><h4>  5.平台类型 </h4><br> 您将不可避免地需要使用Java编写的SDK（实际上包括Android SDK）。 这意味着您应该始终对Kotlin和Java Interop（例如平台类型）保持警惕。 <br><br> 平台类型是Kotlin找不到空有效性信息的类型。 事实是，默认情况下，Java代码不包含有关null有效性的信息，并且并非总是使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">NotNull</a>和@ Nullable批注。 如果Java中没有相应的注释，则该类型将成为平台。 您既可以将其用作允许null的类型，也可以将其用作不允许null的类型。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zw/r_/cu/zwr_cuwc3ajqxcsezq1b0zqcwyw.png"></div><br> 这意味着就像在Java中一样，开发人员完全负责这种类型的操作。 编译器不会添加空检查运行时，并允许您执行所有操作。 <br><br> 在以下示例中，我们在Activity中覆盖onActivityResult： <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onActivityResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(requestCode: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, resultCode: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">data</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Intent</span></span></span></span><span class="hljs-function"><span class="hljs-params">{ </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">super</span></span></span></span><span class="hljs-function"><span class="hljs-params">.</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">onActivityResult</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">requestCode</span></span></span></span><span class="hljs-function"><span class="hljs-params">, resultCode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">data</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> randomString = <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.getStringExtra(<span class="hljs-string"><span class="hljs-string">"some_string"</span></span>) }</code> </pre> <br> 在这种情况下，数据是可能包含null的平台类型。 但是，从Kotlin代码的角度来看，数据在任何情况下都不能为空，并且无论您是否将Intent类型指定为可为空，都不会从编译器收到警告或错误，因为两种版本的签名均有效。 但是由于不能保证接收非空数据，因为在使用SDK的情况下您无法控制它，因此在这种情况下获取null会导致NPE。 <br><br> 另外，作为示例，我们可以列出以下可能出现的平台类型： <br><br><ol><li>  Service.onStartCommand（），其中Intent可以为null。 </li><li>  BroadcastReceiver.onReceive（）。 </li><li>  Activity.onCreate（），Fragment.onViewCreate（）和其他类似方法。 </li></ol><br> 此外，碰巧该方法的参数都带有注释，但是由于某些原因，工作室在生成替代项时会失去Nullability。 <br><br><h3> 域层 </h3><br> 该层包括所有业务逻辑；它负责数据层和表示层之间的交互。 这里的关键角色是由存储库扮演的。 在存储库中，我们执行服务器端和本地的必要数据操作。 楼上，在Presentation层，我们仅提供Repository接口方法，该方法隐藏了数据操作的复杂性。 <br><br> 如上所述，RxJava用于实现。 <br><br><h4>  1. RxJava </h4><br>  Kotlin与RxJava完全兼容，并且与Java相比更加简洁。 但是，即使在这里，我也不得不面对一个不愉快的问题。 听起来像是这样：如果将lambda作为<b>andThen</b>方法的参数传递，则该lambda将不起作用！ <br><br> 要验证这一点，只需编写一个简单的测试： <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">Completable</span></span> .fromCallable { cardRepository.uploadDataToServer() } .andThen { cardRepository.markLocalDataAsSynced() } .subscribe()</code> </pre> <br>  <b>然后</b>内容<b>将</b>失败。 对于大多数运算符（例如<b>flatMap</b> ， <b>defer</b> ， <b>fromAction</b>和许多其他运算符）就是这种情况， <b>实际上应将</b> lambda作为参数。 有了<b>andThen</b>这样的记录， <b>可以预期Completable / Observable / SingleSource</b> 。 通过使用普通括号（）而不是卷曲{}可以解决此问题。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ Kotlin和Rx2。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我如何因为括号错误而浪费了5个小时</a> 。 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“</a> <br><br><h4>  2.重组 </h4><br> 我们还谈到了有趣的Kotlin语法，例如解构或<i>解构赋值</i> 。 它允许您一次将一个对象分配给多个变量，将其分成多个部分。 <br><br> 假设我们在API中有一个方法可以一次返回多个实体： <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@GET(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/foo/api/sync"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBrandsAndCards</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Single&lt;BrandAndCardResponse&gt; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BrandAndCardResponse</span></span></span></span>(<span class="hljs-meta"><span class="hljs-meta">@SerializedName(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cards"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cards: List&lt;Card&gt;?, <span class="hljs-meta"><span class="hljs-meta">@SerializedName(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"brands"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> brands: List&lt;Brand&gt;?)</code> </pre><br> 从此方法返回结果的一种紧凑方法是解构，如以下示例所示： <br><br><pre> <code class="scala hljs">syncRepository.getBrandsAndCards() .flatMapCompletable {it-&gt; <span class="hljs-type"><span class="hljs-type">Completable</span></span>.fromAction{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> (cards, brands) = it syncCards(cards) syncBrands(brands) } } }</code> </pre> <br> 值得一提的是，多重声明是基于约定的：应该被销毁的类必须包含componentN（）函数，其中N是相应的组件号-该类的成员。 也就是说，上面的示例转换为以下代码： <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cards = it.component1() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> brands = it.component2()</code> </pre> <br> 我们的示例使用一个数据类，该数据类自动声明componentN（）函数。 因此，多条声明可以和他一起工作。 <br><br> 在下一部分中，我们将专门讨论数据层，以进一步讨论数据类。 <br><br><h3> 资料层 </h3><br> 该层包括POJO，用于处理来自服务器和基础的数据，以及用于处理本地数据和从服务器接收的数据的接口。 <br><br> 为了处理本地数据，使用了Room，它为我们提供了一个方便的包装器来处理SQLite数据库。 <br><br> 移植本身的第一个目标就是POJO，它在标准Java代码中是具有许多字段的批量类及其相应的get / set方法。 您可以借助数据类使POJO更加简洁。 一行代码足以描述具有多个字段的实体： <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Card</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id:String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardNumber:String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> brandId:String,<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> barCode:String)</code> </pre><br> 除了简洁之外，我们还获得： <br><br><ul><li> 在幕后重写<b>equals（）</b> ， <b>hashCode（）</b>和<b>toString（）</b>方法。 在为RecyclerView生成视图的适配器中使用DiffUtil时，为数据类的所有属性生成均等值非常方便。 事实是DiffUtil比较两个数据集，两个列表：旧列表和新列表，找出发生了什么更改，并使用notify方法最佳地更新适配器。 通常，列表项使用等于进行比较。 <br><br> 因此，在将新字段添加到类之后，我们无需将其添加到equals，以便DiffUtil将新字段考虑在内。 </li><li> 不变的阶级 </li><li> 支持默认值，可以使用生成器模式替换默认值。 <br><br> 一个例子： <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Card</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id : <span class="hljs-built_in"><span class="hljs-built_in">Long</span></span> = <span class="hljs-number"><span class="hljs-number">0L</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardNumber: String=<span class="hljs-string"><span class="hljs-string">"99"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> barcode: String = <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> brandId: String=<span class="hljs-string"><span class="hljs-string">"1"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newCard = Card(id =<span class="hljs-number"><span class="hljs-number">1L</span></span>,cardNumber = <span class="hljs-string"><span class="hljs-string">"123"</span></span>)</code> </pre> </li></ul><br> 另一个好消息是：配置了kapt（如上所述）后，数据类可以与Room注释配合使用，这使您可以将所有数据库实体转换为数据类。  Room还支持可为空的属性。 的确，Room还不支持Kotlin的默认值，但是已经为此设置了相应的错误。 <br><br><h2> 结论 </h2><br> 我们仅研究了从Java迁移到Kotlin期间可能出现的一些陷阱。 重要的是，尽管出现问题，尤其是缺乏理论知识或实践经验，但所有问题都可以解决。 <br><br> 但是，用Kotlin编写简洁的表达性和安全的代码所带来的乐趣将远远超过过渡路径上出现的所有困难。 我可以有信心地说，DISCO项目的例子肯定证实了这一点。 <br><br><h3> 书籍，有用的链接，资源 </h3><br><ol><li> 语言知识的理论基础将使语言Svetlana Isakova和Dmitry Zhemerov的创建者可以编写<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">《行动中的科特林》</a> 。 <br><br> 保守主义，信息量大，主题广泛，专注于Java开发人员以及俄语版本的可用性使其成为语言学习开始时最好的手册。 我从她开始。 </li><li>  Kotlin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">来源</a>与developer.android。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">科特林俄语指南</a> </li><li> 来自Genesis的Android开发人员Konstantin Mikhailovsky <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的精彩文章</a> ，介绍了切换到Kotlin的经验。 </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN433074/">https://habr.com/ru/post/zh-CN433074/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN433062/index.html">AXIS P1367与IDIS DC-B3303X：比较CCTV摄像机</a></li>
<li><a href="../zh-CN433064/index.html">事件管理：“您不能放弃”或放置逗号的技巧</a></li>
<li><a href="../zh-CN433066/index.html">高负荷杯＃2。 后端开发人员重新投入使用的冠军</a></li>
<li><a href="../zh-CN433070/index.html">如何从香菇中区分洗发水，从香槟中区分烤串... Elasticsearch-在商店数据库中搜索产品</a></li>
<li><a href="../zh-CN433072/index.html">如何破解Sega Dreamcast控制台复制保护</a></li>
<li><a href="../zh-CN433076/index.html">我们如何制作Android Gallery库以查看媒体内容</a></li>
<li><a href="../zh-CN433078/index.html">我们使用StockSharp图形框架编写交易机器人。 第二部分</a></li>
<li><a href="../zh-CN433082/index.html">抽走他人的帐户已成为韩国的刑事犯罪</a></li>
<li><a href="../zh-CN433084/index.html">公开课“以经典泰坦尼克号数据集为例的特征工程”</a></li>
<li><a href="../zh-CN433086/index.html">Tinkoff以及一切，一切，一切：银行的物联网，分析和监控</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>