<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👝 🤙 💅 Création du jeu 35MM. Après l'apocalypse en Russie 💪 👨🏼‍⚖️ 💺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour à tous, je m'appelle Sergey Noskov. Aujourd'hui, je voudrais parler de la création de mon premier projet indépendant à part entière appelé 35M...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Création du jeu 35MM. Après l'apocalypse en Russie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448340/"><img src="https://habrastorage.org/webt/nd/lc/7g/ndlc7ge6rk_kvh7uq0ysdei1sqi.jpeg"><br><br>  Bonjour à tous, je m'appelle Sergey Noskov.  Aujourd'hui, je voudrais parler de la création de mon premier projet indépendant à part entière appelé 35MM, sorti sur Steam en 2016.  L'histoire est bien sûr longue, et depuis lors, plusieurs articles et interviews sur le sujet du projet ont déjà été publiés, cependant, il n'y avait pas de description détaillée du processus de développement.  De plus, les aspects techniques de la mise en œuvre n'ont guère été touchés.  En fait, nous en parlerons. <br><br>  Commençons par un petit historique.  35MM est une aventure avec une vue à la première personne dans le cadre d'une post-apocalypse en Russie.  Le peuple - un simulateur de marche.  Le jeu nous raconte l'histoire du voyage de deux errants à travers les terres désertes laissées par la civilisation.  La majeure partie de la population s'est éteinte après une terrible maladie, et maintenant la nature reprend ses points à l'humanité.  Malheureusement, je ne me souviens pas exactement comment l’idée de ce projet est née, mais je me souviens certainement qu’à cette époque, j’étais un ardent fan du sujet du harceleur, des jeux Metro et, en général, de ces environnements atmosphériques.  Les paysages des villes abandonnées, des zones industrielles et des villages ont toujours éveillé mon inquiétude et ma joie.  Je ne sais pas de quel type de maladie il s'agit et comment expliquer un tel amour, mais nous sommes nombreux.  En général, une telle passion sur ce sujet était suffisante pour commencer à créer votre propre monde du petit jeu. <br><a name="habracut"></a><br><br><img src="https://habrastorage.org/webt/ro/01/jj/ro01jjdr6mpcdqso8mzkghc4dv4.jpeg"><br><br>  Comme j'avais déjà deux petits projets (Light et Train), ainsi qu'une expérience dans le moteur Unity, j'ai commencé à développer un nouveau jeu.  Si je ne me trompe pas, à cette époque, la cinquième version du moteur était déjà disponible, mais dans une certaine mesure, je suis un conservateur (pas mon meilleur trait professionnel), j'ai donc décidé de rester dans la version 4.7.  Pour une compréhension générale, il existe de nombreuses différences importantes entre les versions 4 et 5 du moteur, notamment en termes de rendu, d'éclairage et de matériaux.  Unity 5 a introduit des shaders physiquement précis qui peuvent refléter correctement la lumière et les réflexes d'affichage.  En termes simples - l'éblouissement et les réflexions sur les matériaux avec de tels shaders semblent plus naturels et attrayants.  Dans la version 4, les shaders de base étaient beaucoup plus simples, cependant, l'écriture de vos propres shaders pourrait améliorer considérablement la qualité de l'image.  Nous en reparlerons un peu plus tard.  Il est clair que le développement du jeu comprend de nombreux aspects, en plus de travailler dans le moteur lui-même.  Pour que le moteur ait quelque chose à entasser, du contenu est nécessaire: modèles, textures, sons, scripts, etc.  Tout cela au final on le voit sur le moniteur et on l'entend dans les colonnes.  Et bien sûr, chaque type de contenu nécessite son propre logiciel.  Pour créer des modèles 3D, j'ai utilisé 3D max, pour travailler avec des graphiques 2D et créer des textures - Photoshop, pour travailler avec du son - Adobe Audition, j'ai écrit le code dans le programme Monodevelop fourni avec Unity.  Je vous recommande particulièrement de fermer les yeux ou de passer au chapitre suivant - le jeu est écrit en Javascript.  Seulement chut, ne le dis à personne.  Je sais juste que pour certains c'est du mauvais goût et personne n'écrit sur Javascript.  En général, les principaux outils sont sélectionnés et le flux de travail s'éloigne lentement. <br><br><br><h4>  Comment tout a commencé </h4><br>  Dans certaines interviews, j'ai déjà mentionné que je n'ai généralement pas de plan de développement clair, mais seulement une vue d'ensemble.  Par conséquent, souvent, la création de lieux se fait spontanément et le design est pensé en déplacement.  Bien sûr, c'est plus un inconvénient qu'un avantage, mais il y a un côté positif - c'est très amusant et on ne sait jamais exactement ce qui va se passer ensuite.  Il s'avère que le jeu vit dans une certaine mesure sa propre vie dès les premiers stades.  Le développement de 35MM a commencé avec la création du tout premier emplacement - une maison forestière abandonnée et un terrain spacieux avec des champs et des forêts de conifères. <br><br><img src="https://habrastorage.org/webt/kr/sb/cn/krsbcnewlw_cvsut4sthf26gl1a.jpeg"><br><br>  Pour construire la surface de la terre utilisée terrane avec 5-6 textures d'herbe et de terre.  Le shader terrane standard peint la surface avec différentes textures en utilisant le masque RGBA, que nous créons avec une brosse dans le moteur lui-même, et le résultat semble souvent très flou, les transitions entre les textures sont trop lisses et ne semblent pas naturelles.  Pour affiner ce point, le shader de terrane a été modifié et un masque de décalage a été ajouté.  La texture en noir et blanc a «déplacé» le masque dessiné dans la terrane et créé des bords déchirés et plus nets, ce qui a légèrement compliqué visuellement l'apparence de la surface. <br><br><img src="https://habrastorage.org/webt/ya/xj/ec/yaxjecb49aydjyn16wrezqwgtte.jpeg"><br><br><img src="https://habrastorage.org/webt/_q/yq/_b/_qyq_bril__wzoxhezidghk7sdo.jpeg"><br><br>  La surface de notre terre a été complétée par plusieurs types d'herbe sous la forme de pléins dispersés au hasard.  L'unité dispose également d'un mode panneau d'affichage (lorsque les plaines herbeuses regardent toujours le joueur), mais il n'est pas très adapté pour jouer avec une vue à la première personne, car il est trop perceptible de voir comment l'herbe «regarde» notre caméra.  Vous devez toujours être prudent avec l'herbe et l'ajouter dans des limites raisonnables, car ce plaisir lance beaucoup d'appels, ce qui affecte à son tour les performances.  Plus il y a d'appels, plus la charge sur le système informatique est élevée.  Mais n'oubliez pas que non seulement les défis augmentent la charge.  Il existe de nombreuses façons de tuer les performances dans le jeu.  En plus de l'herbe au sol, pour changer, des mailles avec des branches et des pierres étaient éparpillées, ainsi qu'une série de décalcomanies avec de la saleté et des traces de roues de voiture. <br><br><img src="https://habrastorage.org/webt/8i/jp/u9/8ijpu9_rppnirhxukbnyfczgea0.jpeg"><br><br>  Après avoir créé la surface, allez à la végétation, aux arbres et aux buissons.  J'ai préféré planter la partie principale de la forêt (conifères) en utilisant les outils de la terrane elle-même - c'est-à-dire avec une brosse.  L'avantage de cette méthode est qu'elle se fait rapidement et facilement, de plus, à grande distance, une telle forêt se transforme de mailles en panneaux d'affichage, ce qui affecte très bien l'optimisation.  Cependant, près de la charge est considérablement augmentée, car, si je comprends bien, de tels arbres ne roulent pas.  Peut-être que je me trompe, et quelqu'un me corrigera.  La gravure est un outil d'optimisation très important.  En gros, il s'agit d'une combinaison de mailles avec un matériau dans un maillage commun, ce qui réduit considérablement le nombre d'appels, respectivement, réduit la charge.  Un autre inconvénient de l'assise sur le terrain est la même position des arbres, c'est-à-dire qu'ils sont tous créés au même angle et cette similitude est frappante.  À cet égard, j'ai installé manuellement des pins, des épinettes et des feuillus à différents angles et de différentes tailles, ce qui a ajouté de la variété au paysage.  Les buissons étaient disposés de la même manière. <br><br><img src="https://habrastorage.org/webt/yy/z-/vg/yyz-vgfhvbn27w1bi6enj3vpfoc.jpeg"><br><br><img src="https://habrastorage.org/webt/e1/rc/ew/e1rcewfivsfb3ob6gmhk7rjv-x4.jpeg"><br><br>  Pour être complet, il reste à faire face au ciel.  Pour cette tâche, un matériau skybox ordinaire avec six textures a été utilisé.  Il y a eu des tentatives de modification du shader pour que le ciel ait l'air dynamique, mais le résultat ne s'est pas justifié et cette idée a dû être abandonnée.  Une alternative était l'utilisation d'un système de particules avec une texture de nuage et des panneaux d'affichage horizontaux avec des interpolations de mouvement.  Pour autant que je m'en souvienne, une option similaire a été utilisée dans le jeu Stalker, et en fait il y en a beaucoup plus ailleurs. <br><br><img src="https://habrastorage.org/webt/15/zs/co/15zsco7qze7gwo7mtz-qjagsxdm.jpeg"><br><br><h4>  Eclairage </h4><br>  Dans la 4ème version du moteur Unity, il y avait un mode très pratique pour la cuisson de lightmaps - double lightmapping.  Il existe une option similaire dans les versions actuelles, mais je ne l'ai pas encore étudiée en détail.  Le mode double nous a permis de dessiner des ombres et des reflets en temps réel à courte distance, mais alors que nous nous éloignions de la caméra, tout cela s'est doucement transformé en cartes lumineuses cuites, ce qui a grandement facilité la tâche de notre matériel.  En général, j'ai utilisé cette méthode sur tous les emplacements du jeu.  En conséquence, pour chaque emplacement central, un ensemble d'environ 5 à 10 lightmaps pour le plan proche a été cuit, et une quantité similaire pour le lointain (lightmaps dans le plan proche également, mais uniquement avec la température ambiante cuite au four). <br><br><img src="https://habrastorage.org/webt/rf/x1/mt/rfx1mtclxshah0ofoykqhftdj9a.jpeg"><br><br><img src="https://habrastorage.org/webt/fa/dt/vf/fadtvfm-928kih6ouhi3_axjpz8.jpeg"><br><br>  En général, dans de nombreux domaines, j'ai essayé d'utiliser une lumière complètement cuite, à l'exception de la lumière du soleil.  Des lumières ponctuelles ont été placées à certains endroits pour souligner les accents et plus de lumière.  Cela se faisait principalement dans des pièces où peu de lumière extérieure pénétrait.  Dans un certain nombre d'endroits, bien sûr, des lampes à incandescence avec des ombres ont également été utilisées: la lumière d'un feu, une lampe de table, un plafonnier ou une applique.  Soit dit en passant, lorsque je travaillais avec l'éclairage, j'ai dû faire face à un gros problème lié aux lampes Point et aux ombres en temps réel.  Dans certaines zones, le regard de la caméra sur une source ponctuelle de lumière avec des ombres a produit des frises et des freins étranges.  Il n'est pas tout à fait clair pourquoi la charge était si élevée, mais le profileur à ce moment-là a montré des appels hors échelle pendant une fraction de seconde.  Pour corriger la situation, l'utilisation de deux luminaires Spot dirigés dans des directions opposées l'un à l'autre a aidé.  Cette option s'est avérée moins lourde. <br><br><img src="https://habrastorage.org/webt/cn/0n/dm/cn0ndmoy7smmzdn1aaib9f3te3s.jpeg"><br><br><h4>  Les modèles </h4><br>  La plupart des modèles 3D du jeu ont été créés indépendamment.  Quelque chose a été fait avec beaucoup de soin, avec des cartes normales et d'autres subtilités, et quelque chose a été créé à la hâte pour gagner du temps.  La plupart des objets ont été créés en groupes et utilisaient une seule texture d'atlas.  Autrement dit, dans une texture, il y avait des sections, par exemple, pour un bloc de béton, un panneau routier, des débris de briques, une trappe d'égout, etc.  Cela a permis d'utiliser un seul matériau pour tous ces objets et, par conséquent, a permis aux objets de s'entrechoquer.  Comme nous nous en souvenons, c'est plutôt bien.  Certains modèles ont été fidèlement téléchargés par moi à partir d'Internet, à partir de bibliothèques gratuites.  Fondamentalement, ce sont de petits accessoires pour remplir les pièces, cependant, j'ai essayé de modifier un peu tous ces modèles afin que la similitude ne soit pas très évidente.  Souvent, j'ai remarqué des actifs identiques dans les jeux indépendants, ce qui a quelque peu influencé ma perception pas de la meilleure façon.  Le plus problématique en termes de création a été le transport.  Modéliser des véhicules à roues à partir de zéro prend beaucoup de temps et prend beaucoup de temps.  Par conséquent, plusieurs exemplaires des voitures ont été achetés par moi dans Asset Store. <br><br><img src="https://habrastorage.org/webt/_f/s1/c5/_fs1c5qh9mrgi2u8wiysjevdrdw.jpeg"><br><br><img src="https://habrastorage.org/webt/ey/yk/51/eyyk510atgkm5d0wrzlpdetox9k.jpeg"><br><br><img src="https://habrastorage.org/webt/kc/g9/62/kcg962k7ikvrkueqcmeijk73kzi.jpeg"><br><br>  Une "chanson" distincte était la création de personnages.  C'est encore une expérience.  Pour ceux qui n'ont pas une bonne idée de la quantité de travail nécessaire pour qu'un personnage apparaisse qui puisse en quelque sorte exister dans le jeu, je vais l'expliquer.  Un modèle high-poly est créé avec tous les détails, boutons sur les manches, rides sur le visage, etc.  Un modèle low-poly du même personnage est créé avec un scan de texture (dans mon jeu, le nombre de polygones par personnage était en moyenne d'environ 5-8 mille).  En outre, une carte normale, une carte ambiante (ombrage doux) est supprimée du modèle à poly élevé pour le modèle à faible poly par des manipulations astucieuses ou simples.  Habituellement, à partir de l'ambiant, je crée une carte diffuse dans Photoshop.  Dans la carte diffuse du canal alpha, créez une carte spéculaire pour créer de la brillance. <br><br><img src="https://habrastorage.org/webt/xo/en/kn/xoenknestj0mo76ow0xco-yvyu4.jpeg"><br><br><img src="https://habrastorage.org/webt/9s/v1/sr/9sv1sre0wuc7oryy9ug-u8ynqpo.jpeg"><br><br>  Pour 2019, bien sûr, il est déjà trop primitif, mais pendant 16 ans et pour le projet indépendant, il était tout à fait approprié. <br><br>  De plus, notre persan doit être flirté - pour y placer des os, grâce auxquels il peut bouger ses membres, bouger sa mâchoire, plier et déplier ses doigts, etc.  Eh bien, au final, le tout doit être animé.  Habituellement, un ensemble d'animations avec différents états est créé pour le personnage: marche, course, position debout ou assise.  Mais des fragments uniques sont également nécessaires, par exemple, dans mon cas, pour le partenaire de notre héros Petrovich, un grand nombre de variations d'actions ont été nécessaires: ouvrir des portes, examiner une carte, se battre avec des bandits, lancer une bombe légère au niveau Bor, etc.  Tout cela devait être animé à la main, ce qui, bien sûr, est très frappant dans sa maladresse.  En général, l'animation manuelle des mouvements humains est une tâche très difficile et il est extrêmement difficile d'obtenir un résultat plausible.  Par conséquent, le bouchon de mouvement est la solution la plus appropriée pour cette tâche.  Pour autant que je sache, cette option est désormais moins chère et plus rapide que le travail de l'animateur, bien que les données reçues doivent être traitées et "nettoyées" manuellement. <br><br><img src="https://habrastorage.org/webt/gv/b8/ir/gvb8irricyi1lcirwgwisjcjfkq.jpeg"><br><br><h4>  Shaders </h4><br>  Je précise tout de suite que je comprenais l'écriture de shaders à cette époque de manière très superficielle.  Ma formation a été principalement dans l'analyse d'exemples prêts à l'emploi et leur raffinement.  J'ai pris diverses options du réseau, modifié des paramètres, ajouté de nouvelles ou supprimé les anciennes et vérifié comment cela affecte le résultat.  Il s'est avéré que c'est une activité extrêmement excitante.  Un intérêt particulier pour moi était la manipulation de différents canaux de texture comme un masque.  Dans certains cas, j'ai essayé d'adapter la quantité maximale d'informations dans une texture et de l'utiliser.  Au début de l'article, j'ai mentionné les différences entre la 4e et les versions ultérieures d'Unity, et en particulier, la présence d'un ombrage physiquement correct dans les dernières.  J'ai essayé d'éliminer cette lacune par moi-même, et l'effet Fresnel a été ajouté au shader standard avec une carte spéculaire, cubmap et normale.  C'est une telle caractéristique des matériaux réfléchissants, dans lesquels les surfaces à un angle par rapport à notre vue reflètent l'environnement (ou cubmap dans ce cas) plus fortement et semblent généralement plus claires et plus contrastées.  Cela est très visible sur une boule brillante, dont les bords semblent plus brillants que le centre.  J'ai pu répéter cet effet et ajouter la possibilité de peindre le cubmap dans le matériau, ce que nous pouvons généralement voir sur des surfaces réfléchissantes mais rugueuses.  Ce shader me convenait parfaitement et était appliqué à la plupart des matériaux du jeu. <br><br><img src="https://habrastorage.org/webt/kz/ka/kj/kzkakjqxlpr1izaz4ffc3h7kdac.jpeg"><br><br><img src="https://habrastorage.org/webt/qp/go/0m/qpgo0m9kwezqi0nraikd-lbxuro.jpeg"><br><br>  La deuxième expérience intéressante a été la création d'un shader pour la peau des personnages.  La base était un code trouvé sur Internet qui vous permet d'utiliser une texture dégradée, qui est responsable de la force et de la couleur de l'éclairage qui affecte le modèle.  Une texture similaire avec une teinte rougeâtre au milieu a permis d'imiter la peau humaine, qui, pour ainsi dire, est un peu translucide, c'est-à-dire a sa propre épaisseur, dans laquelle la lumière est diffusée en douceur.  L'effet n'est pas parfait, mais il a l'air mieux que le spéculaire en plastique standard. <br><br><img src="https://habrastorage.org/webt/bd/x9/vq/bdx9vqxqwtq9mpfixc38u3bl0bi.jpeg"><br><br>  En plus des shaders ci-dessus, de nombreuses options secondaires avec des effets individuels ont été créées dans le processus.  Par exemple, un shader de flaque avec un cubmap et une déformation de carte diffuse.  Puisqu'il est trop coûteux d'utiliser de vraies réflexions pour les flaques d'eau et que je ne voulais pas utiliser un rendu dans la texture (c'est lorsque le cadre est enregistré dans la texture et appliqué dans le matériau, pendant lequel, par exemple, des distorsions d'air chaud peuvent être faites), j'ai décidé de faire de simples distorsions de la texture de la terre, tendu sur une flaque d'eau.  L'effet était assez agréable et n'a pas du tout tendu le fer.  Par ailleurs, un shader avec un rendu de texture a été utilisé pour déformer l'air des lampes à pétrole et d'un feu de joie.  Il semble qu'il y ait eu une distorsion thermique de l'actif du détonateur.  De plus, pour simuler les rayons lumineux volumétriques, un vertex shader a été créé avec l'effet Particule douce et l'effet de lumière du bord (lorsque nous regardons les polygones sous un certain angle, le maillage passe en alpha).  Il s'agit d'un mode de mise en œuvre classique et déjà barbu.  Maintenant, pour le nouveau Unity, il existe une option intéressante qui fonctionne sur la base du post-effet et vous permet de dessiner de vrais rayons de lumière, même en tenant compte des ombres. <br><br>  Il convient également de noter l'ensemble de shaders qui a été conçu pour simuler des surfaces humides.  Le jeu a un épisode dans lequel à un moment donné de fortes pluies commencent et certains matériaux acquièrent en douceur un éclat caractéristique.  L'effet principal a été appliqué au terrain sur lequel, comme dans le cas des flaques, la texture diffuse a commencé à se déformer.  Des fuites d'eau sont également apparues sur les fenêtres des maisons.  Eh bien, la puce la plus «humide» était des gouttes tombant sur l'objectif.  Ici, en fait, j'étais tourmenté par des doutes, car le héros n'avait ni lunettes ni casque, et la façon dont les gouttes se manifestent de manière obsessionnelle à l'écran n'était pas claire.  Cependant, visuellement, j'aimais tellement l'effet que je ne pouvais tout simplement pas le refuser. <br><br><img src="https://habrastorage.org/webt/ei/-x/u2/ei-xu2rezxy8cw3icshvbrbqev0.jpeg"><br><br>  Nous passons donc en douceur aux post-effets.  En parlant de gouttes à l'écran, tout est simple: quelques gouttes de la texture se multiplient et descendent à différentes vitesses.  En parallèle, les ondes (textures dégradées) descendent, qui sont multipliées, chacune par son propre groupe de gouttes.  Ensuite, le tout est résumé, légèrement affiché dans la «diffusion», pour ainsi dire, mais il est principalement utilisé comme masque pour déplacer les coordonnées.  En conséquence, notre image est déformée par la réfraction des gouttes d'eau.  Le principal ensemble de post-effets qui étaient toujours ou facultatifs sur la caméra (si le joueur les activait ou les désactivait) est l'anticrénelage, SSAO, Bloom, Aberration, Vignette, Sun Shafts.  Ce sont tous des effets Unity standard, mais SSAO a été modifié pour que le rendu des ombres à distance soit réduit à zéro, car dans la distance dans le brouillard, les taches sombres des ombres semblaient étranges.  L'effet d'aberration a également été modifié (il s'agit de la distorsion des couleurs de l'image lors de l'utilisation d'objectifs, quelque chose comme des contours de couleur sur les bords des objets) .L'effet standard d'Unity a peint les bords des objets vert bourgogne (une solution plutôt étrange à mon avis).  En fait, le plus souvent, les couleurs sont plus proches du jaune-rouge-bleu, ce que j'ai réalisé.  Un autre effet permanent a été la correction des couleurs auto-réalisée.  L'effet Unity standard me semblait trop gourmand en ressources, donc son propre effet simplifié a été réalisé.  Fondamentalement, il a créé l'effet du tonmapping et a légèrement changé le jeu de couleurs en un plus froid.  Le choix d'une palette de couleurs pour une image est toujours une tâche difficile, qui est difficile à déterminer.  Il arrive que vous aimiez des options complètement opposées et qu'il soit extrêmement difficile de prendre une décision.  Dans ce projet, j'ai opté pour des couleurs ternes et froides.  Pour beaucoup, elle semblait trop fanée, mais, il me semble, elle transmet très précisément l'humeur que j'ai essayé de refléter dans mon jeu, l'humeur de tristesse, de découragement et de solitude. <br><br><img src="https://habrastorage.org/webt/qv/er/iv/qverivmj5x-rorvqc0vgmmsrtpo.jpeg"><br><br><img src="https://habrastorage.org/webt/4i/uz/2k/4iuz2kxafowra3gr_cckxkngpzq.jpeg"><br><br><h4>  Et le code? </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai mentionné à plusieurs reprises dans une interview que j'étais toujours loin du sujet de la programmation et plus concentré sur la composante visuelle. J'ai commencé à écrire le premier code à part entière en travaillant sur le jeu "Train", donc au moment de développer 35MM, j'avais déjà quelques compétences. En général, le genre de quête me semblait très approprié pour comprendre la programmation à mon niveau initial. La plupart des actions du jeu sont basées sur des déclencheurs. Un objet entre dans le déclencheur (un cube avec un collisionneur) et quelque chose commence à se produire, par exemple, une scène coupée commence. Dans le script, comme dans le script d'une représentation théâtrale, il est décrit ligne par ligne quand et ce qui se passe - maintenant la caméra du joueur s'éteint, la caméra de la scène coupée s'allume, le personnage apparaît dans le cadre, l'animation de la conversation démarre, etc. Je pense qu'il existe des outils qui facilitent tout ce processus (je croiscar il n’est pas allé en profondeur), mais cette option me semble toujours la plus compréhensible, car vous contrôlez vous-même tous les événements.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le mouvement de notre partenaire dans le jeu a été mis en œuvre à l'aide de déclencheurs, qui étaient des points de contrôle de son itinéraire. Si vous appuyez sur la gâchette, une nouvelle animation peut s'activer ou le personnage peut dire quelque chose. </font></font><br><br><img src="https://habrastorage.org/webt/ts/r9/rz/tsr9rz9e2jumsgryopdvzs_og4m.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette méthode a été utilisée à tous les niveaux sauf le dernier. Au dernier endroit de la ville, si nous arrivions à elle avec un partenaire, il ne nous conduisait plus le long du parcours, mais courait après nous. Là, un contrôleur basé sur NavMesh (un système qui permet à un objet de rechercher un chemin vers une cible et de s'y rendre) a déjà été utilisé.</font></font><br><br><img src="https://habrastorage.org/webt/cx/my/4i/cxmy4ix45uvqvn4auqkvlk0ykby.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les choses ont été plus difficiles avec l'ours au deuxième endroit du match. Il a été utilisé un contrôleur qui ne fonctionne qu'avec un corps rigide (corps physique), de sorte que la bête était stupide et s'est souvent écrasée sur des arbres et d'autres objets. Le matériel physique sans friction nous a permis d'éviter de graves confitures, et l'ours a finalement glissé et a continué à nous poursuivre. Ici, et en général dans les zones où vous pouvez mourir, j'ai rencontré le problème le plus grave pour moi - le lancement de la mort et le redémarrage. Au moment du décès, il fallait tenir compte de tous les états actuels du personnage: la lampe de poche est-elle allumée, la carte est-elle ouverte, le couteau est-il activé, etc. Il fallait aussi préserver les valeurs de santé et de toutes les ressources puis, tout ce qui était activé, il fallait désactiver et démarrer l'animation de la caméra en train de tomber. Après avoir assombri l'écran, il a fallu tout retourner et lire les valeurs stockées.En fait, il n'y a pas de grandes difficultés avec l'approche appropriée, mais dans mon cas, beaucoup de bugs sont apparus: soit le couteau est resté dans mes mains devant mes yeux lorsque l'ours a attaqué, alors la carte n'a pas été retirée - tout comme ça. De plus, vous ne savez jamais comment un joueur peut se conduire en ce moment, où il va courir et dans quelles conditions un ours peut conduire, qui peut rester coincé quelque part ou, par exemple, nous attaquer à travers le mur. En général, il existe de nombreuses nuances que vous ne prévoirez pas immédiatement.nous attaquer à travers le mur. En général, il existe de nombreuses nuances que vous ne prévoirez pas immédiatement.nous attaquer à travers le mur. En général, il existe de nombreuses nuances que vous ne prévoirez pas immédiatement.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'interaction de notre personnage avec des objets a été réalisée à l'aide du rayon Raycast. Tous les objets interactifs ont été étiquetés avec la balise Subject, et lorsque le faisceau les frappe, il active le rétroéclairage (le maillage est un indicateur avec des bords surlignés) et comprend un script qui est déjà responsable de l'action que nous pouvons entreprendre avec cet objet, par exemple, ramasser un objet, lire une note ou ouvrez la porte.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour l'interaction, il était initialement prévu de créer des mains à part entière qui atteindraient des objets, cela créerait un effet de présence plus évident. Mais cette option représentait pour moi la grande difficulté de mise en œuvre et la perspective d'avoir un ensemble complet de bogues à l'avenir, donc il n'y avait que des mains qui portent des éléments déjà sélectionnés. Il y a un préfabriqué avec de petites poignées devant la caméra, dans lequel tous les objets sont déjà présents (caméra, couteau, hache, etc.). Lorsque vous sélectionnez un objet pendant le jeu, celui que vous souhaitez s'allume et ceux inutiles s'éteignent.</font></font><br><br><img src="https://habrastorage.org/webt/kp/my/wh/kpmywhdleoxjlpvbey5nxq6iexa.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un point intéressant était lié à l'animation des personnages qui parlaient. </font><font style="vertical-align: inherit;">La technique est primitive, mais j'y ai pensé moi-même, fier, oui. </font><font style="vertical-align: inherit;">Au début, je pensais que lors de la communication des personnages, je devrais commencer l'animation de l'ouverture de la mâchoire dans un ordre aléatoire avec chaque phrase. </font><font style="vertical-align: inherit;">Mais il m'est alors venu à l'esprit qu'un script pouvait lire le niveau de volume de la bande sonore au moment de la lecture et transférer ce niveau à une valeur flottante, qui est déjà responsable de la position de la mâchoire du héros. </font><font style="vertical-align: inherit;">En fin de compte, la mâchoire s'est automatiquement ouverte lors de la prononciation des mots au rythme du fichier son. </font><font style="vertical-align: inherit;">Cela a grandement simplifié la tâche, même si cela semblait trop "machine".</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Optimisation </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'optimisation est une partie très importante du développement, dont dépend la fluidité du jeu sur différents matériels. Je vais aborder l'optimisation de la composante visuelle du projet. Il existe plusieurs méthodes utiles pour cela: des groupes de lods, l'abattage est occlus, l'écrêtage des objets à distance. Le groupe LOD doit être utilisé dans le cas d'objets «lourds» à haute teneur en polyéthylène. Pour ce faire, créez plusieurs maillages avec un nombre différent de polygones. Plus l'appareil photo est éloigné du sujet, plus le modèle est simplifié dans le cadre. Par exemple, pour 35MM, les lods ont été utilisés dans des modèles de voitures, des personnages et certains arbres. Habituellement, 2 à 3 filons ont été fabriqués, parmi lesquels chaque maille suivante avait presque 2 fois moins de polygones. Pour plus de clarté: le modèle de voiture d'origine se compose de 15 mille polygones, le premier LOD a déjà environ 9 tonnes.(le nombre de nervures diminue, les petites pièces telles que les charnières, les pièces intérieures sont enlevées), le deuxième LOD atteint déjà 5 tonnes (les poignées de porte, les rétroviseurs à l'intérieur de la cabine sont enlevés, la géométrie devient encore plus simple). Plus loin dans la même veine. Pour les lods, au fait, une astuce intéressante a été utilisée. Lorsque nous préparons des lightmaps pour un objet avec des lods, nous devons cuire pour les deux objets. Afin de réduire le temps de cuisson et d'économiser la mémoire système, j'ai utilisé un script qui transférait automatiquement la lightmap affectée avec toutes les coordonnées de l'objet parent (zéro LOD) à tous les autres lods.une astuce intéressante a été utilisée. Lorsque nous préparons des lightmaps pour un objet avec des lods, nous devons cuire pour les deux objets. Afin de réduire le temps de cuisson et d'économiser la mémoire système, j'ai utilisé un script qui transférait automatiquement la lightmap affectée avec toutes les coordonnées de l'objet parent (zéro LOD) à tous les autres lods.une astuce intéressante a été utilisée. Lorsque nous préparons des lightmaps pour un objet avec des lods, nous devons cuire pour les deux objets. Afin de réduire le temps de cuisson et d'économiser la mémoire système, j'ai utilisé un script qui transférait automatiquement la lightmap affectée avec toutes les coordonnées de l'objet parent (zéro LOD) à tous les autres lods.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La deuxième méthode d'optimisation est la suppression d'occlusion. Il s'agit d'un mécanisme dans lequel tout ce qui n'est pas dans le champ de vision de la caméra ou qui est fermé par un autre objet est coupé. Par exemple, lorsque nous entrons dans la pièce, derrière le mur, nous ne voyons plus beaucoup d'objets dans la rue, et donc il n'est pas nécessaire de dépenser des ressources pour les rendre.</font></font><br><br><img src="https://habrastorage.org/webt/j1/_y/tk/j1_ytkv-3hkd3m8m-xbewf8thzw.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un autre moyen utile de simplifier le rendu consiste à découper des objets à distance. C'est la première option que j'ai rencontrée depuis l'époque du projet «Light». Un script est accroché à la caméra qui ajuste sa distance de rendu pour chaque couche. Dans mon cas, trois catégories de couches ont été spécialement créées, avec de petits objets (articles ménagers, marteaux, briques et petits débris), de tailles moyennes et légèrement supérieures à la moyenne (théières, buissons, pots de fleurs, petits lampadaires, etc.). Trois catégories ont été affectées à des distances: 40, 80 et 120 mètres. Une fois au-delà de la distance spécifiée, la caméra a arrêté le rendu de l'objet correspondant. L'option est très pratique et efficace, car les petits accessoires ne peuvent plus être vus de loin, et donc les rendre n'a aucun sens.</font></font><br><br><h4>  Son </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La plupart des sons du jeu proviennent de bibliothèques gratuites d'Internet. Habituellement, je télécharge les options nécessaires, puis les combine et les mélange dans Adobe Audition. En général, il n'y a pas grand-chose à dire sur cette partie du travail, car c'est un processus plutôt routinier, ennuyeux et qui ne m'attire pas particulièrement. Soit dit en passant, le travail consistant à introduire des sons, à marquer des scènes coupées, à ajuster des fichiers sonores pour que le son souhaité soit lu au bon moment - tout cela a probablement pris un quart du temps total consacré au jeu. Le seul moment agréable a été l'introduction de la musique, sur laquelle le compositeur cool et extrêmement talentueux Dmitry Nikolaev a travaillé. Je suis très content de ce qu'il a fait, car dans l'ensemble, je ne savais pas exactement ce que je voulais entendre. Mais Dmitry ressentait très bien l'ambiance,qui a été défini dans le projet et mis en œuvre sous la forme de l'atmosphère atmosphérique. Il s'est avéré quelque chose de fantastique, mystérieux et mélodique.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une autre étape intéressante a été de travailler avec des personnages de doublage. Malgré les critiques de l'extérieur, je suis toujours satisfait du résultat et je pense que les acteurs ont très bien fait leur travail. Soit dit en passant, les personnages principaux exprimés par Vsevolod Petrykin et Alexander Bragi, pour lesquels un grand merci à eux.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En général, il n'y avait pas de problèmes sérieux avec le son, bien que, après la sortie, un bug rare ait été découvert que je ne pouvais toujours pas surmonter, car je ne comprenais toujours pas sa nature. </font><font style="vertical-align: inherit;">Parfois, une partie des sons cessait de jouer ou sonnait avec un fort effet d'écho. </font><font style="vertical-align: inherit;">Lorsque vous parlez à un héros, une voix peut soudainement disparaître et, de la même manière, récupérer soudainement. </font><font style="vertical-align: inherit;">Il y avait des conjectures associées à une grande charge et à un grand nombre de sons joués en même temps. </font><font style="vertical-align: inherit;">Il y avait également des hypothèses sur la connexion du bug avec les zones de réverbération, mais ce n'est pas exact. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C’est probablement tout. </font><font style="vertical-align: inherit;">Cela fait longtemps depuis le développement, certaines choses ont été oubliées, et certaines sont devenues complètement hors de propos, mais j'espère que l'article sera utile à quelqu'un et qu'il pourra répondre à certaines questions. </font><font style="vertical-align: inherit;">Merci à tous et bonne chance!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr448340/">https://habr.com/ru/post/fr448340/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr448330/index.html">Nombres aléatoires et réseaux décentralisés: une application pratique</a></li>
<li><a href="../fr448332/index.html">Initier les adeptes de l'informatique: montrez votre force sur un récif</a></li>
<li><a href="../fr448334/index.html">Quand la productivité d'une personne suscite l'intérêt</a></li>
<li><a href="../fr448336/index.html">Séminaire «Nuages ​​hybrides - avantages et inconvénients: quoi préparer pour les affaires et l'informatique» - 25 avril, Moscou</a></li>
<li><a href="../fr448338/index.html">Décomposer les principes fondamentaux de C #: allouer de la mémoire pour un type de référence sur la pile</a></li>
<li><a href="../fr448342/index.html">MyDrops - TWS à faible coût avec un bon son et Bluetooth fiable</a></li>
<li><a href="../fr448346/index.html">De GNU à Doom: TechTrain 2019 annoncé</a></li>
<li><a href="../fr448350/index.html">Implémentation de dictionnaire en Python</a></li>
<li><a href="../fr448352/index.html">Boring Company va creuser un tunnel à Las Vegas</a></li>
<li><a href="../fr448354/index.html">GraphQL Voyager comme outil de recherche de vulnérabilités</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>