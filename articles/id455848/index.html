<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ü üë©‚Äçüë©‚Äçüëß üìç Teknik untuk menghindari perilaku tidak terdefinisi saat mengakses singleton üíÜüèΩ üíÖüèº üßö</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini membahas penyebab dan metode menghindari perilaku yang tidak terdefinisi ketika mengakses singleton di c ++ modern. Contoh kode single-thr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Teknik untuk menghindari perilaku tidak terdefinisi saat mengakses singleton</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455848/">  Artikel ini membahas penyebab dan metode menghindari perilaku yang tidak terdefinisi ketika mengakses singleton di c ++ modern.  Contoh kode single-threaded disediakan.  Tidak ada yang khusus-compiler, semua sesuai dengan standar. <br><a name="habracut"></a><br><h3>  Pendahuluan </h3><br>  Untuk memulai, saya sarankan Anda membaca artikel lain tentang singleton di Habr√©: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tiga usia pola Singleton</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Singleton dan Common Instances</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3 Cara untuk Melanggar Prinsip Tanggung Jawab Tunggal</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Singleton - pola atau antipattern?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menggunakan pola singleton</a> <br><br>  Dan, akhirnya, sebuah artikel yang menyentuh topik yang sama, tetapi lolos (jika hanya karena kerugian dan keterbatasan tidak dipertimbangkan): <br>  benda-benda tialized (yaitu, objek <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Singleton dan objek seumur hidup</a> <br><br>  Selanjutnya: <br><br><ul><li>  ini <b>bukan</b> artikel tentang properti arsitektur singleton; </li><li>  ini <b>bukan</b> artikel "bagaimana membuat singleton putih dan halus dari singleton yang mengerikan dan mengerikan"; </li><li>  ini <b>bukan</b> kampanye tunggal; </li><li>  ini <b>bukan</b> perang melawan singleton; </li><li>  ini <b>bukan</b> artikel akhir yang menyenangkan. </li></ul><br>  Artikel ini adalah tentang satu yang sangat penting, tetapi masih aspek teknis menggunakan singleton di C ++ modern.  Perhatian utama dalam artikel ini diberikan pada saat kehancuran singleton, sebagai  di sebagian besar sumber, masalah kehancuran tidak diungkapkan dengan baik.  Biasanya, penekanannya adalah pada saat singleton diciptakan, dan tentang kehancuran, paling-paling, ia mengatakan sesuatu seperti "dihancurkan dalam urutan terbalik." <br><br>  <b>Saya akan meminta Anda untuk mengikuti ruang lingkup artikel dalam komentar, terutama untuk tidak mengatur holivar "pola tunggal vs tunggal-antipattern".</b> <br><br>  Jadi ayo pergi. <br><br><h3>  Apa yang dikatakan standar </h3><br>  Kutipan berasal dari C ++ 14 draft final N3936, as  tersedia C ++ 17 konsep tidak ditandai sebagai "final". <br>  Saya memberikan bagian yang paling penting secara keseluruhan.  Tempat-tempat penting disorot oleh saya. <br><br><blockquote>  3.6.3 Pengakhiran [basic.start.term] <br><br>  1. Destructors (12.4) untuk objek yang diinisialisasi (yaitu, objek yang masa pakainya (3.8) telah dimulai) dengan durasi penyimpanan statis disebut sebagai hasil dari kembali dari utama dan sebagai akibat dari panggilan std :: exit (18.5).  Destruktor untuk objek yang diinisialisasi dengan durasi penyimpanan utas dalam utas yang diberikan disebut sebagai hasil dari fungsi awal utas tersebut dan sebagai akibat dari utas yang memanggil std :: exit.  <b>Penyelesaian destruktor untuk semua objek yang diinisialisasi dengan durasi penyimpanan utas dalam utas tersebut diurutkan sebelum inisiasi destruktor objek apa pun dengan durasi penyimpanan statis.</b>  <b>Jika penyelesaian konstruktor atau inisialisasi dinamis suatu objek dengan durasi penyimpanan ulir diurutkan sebelum yang lain, penyelesaian destruktor yang kedua diurutkan sebelum inisiasi destruktor yang pertama.</b>  <b>Jika penyelesaian konstruktor atau inisialisasi dinamis suatu objek dengan durasi penyimpanan statis diurutkan sebelum yang lain, penyelesaian destruktor yang kedua diurutkan sebelum inisiasi destruktor yang pertama.</b>  [Catatan: Definisi ini memungkinkan penghancuran bersamaan.  ‚ÄìEnd note] Jika objek diinisialisasi secara statis, objek dihancurkan dalam urutan yang sama seperti jika objek diinisialisasi secara dinamis.  Untuk objek array atau tipe kelas, semua sub objek dari objek tersebut dihancurkan sebelum objek ruang lingkup blok apa pun dengan durasi penyimpanan statis yang diinisialisasi selama konstruksi subobjek dihancurkan.  Jika penghancuran objek dengan durasi penyimpanan statis atau keluar melalui pengecualian, std :: terminate disebut (15.5.1). <br><br>  2. <b>Jika suatu fungsi berisi objek blok-lingkup durasi penyimpanan statis atau thread yang telah dihancurkan dan fungsi dipanggil selama penghancuran objek dengan durasi penyimpanan statis atau thread, program memiliki perilaku yang tidak ditentukan jika aliran kontrol melewati melalui definisi objek blockscope yang sebelumnya hancur.</b>  Demikian juga, perilaku tidak terdefinisi jika objek lingkup blok digunakan secara tidak langsung (yaitu, melalui pointer) setelah kehancurannya. <br><br>  <b>3. Jika penyelesaian inisialisasi objek dengan durasi penyimpanan statis diurutkan sebelum panggilan ke std :: atexit (lihat "cstdlib", 18.5), panggilan ke fungsi yang diteruskan ke std :: atexit diurutkan sebelum panggilan ke destruktor untuk objek.</b>  <b>Jika panggilan ke std :: atexit diurutkan sebelum penyelesaian inisialisasi objek dengan durasi penyimpanan statis, panggilan ke destruktor untuk objek diurutkan sebelum panggilan ke fungsi yang dilewatkan ke std :: atexit.</b>  <b>Jika panggilan ke std :: atexit diurutkan sebelum panggilan lain ke std :: atexit, panggilan ke fungsi yang diteruskan ke std kedua :: panggilan atexit diurutkan sebelum panggilan ke fungsi dialihkan ke std :: atexit call pertama .</b> <br><br>  4. Jika ada penggunaan objek atau fungsi perpustakaan standar yang tidak diizinkan dalam penangan sinyal (18.10) yang tidak terjadi sebelum (1.10) penyelesaian penghancuran objek dengan durasi penyimpanan statis dan pelaksanaan fungsi terdaftar std :: atexit terdaftar (18.5) ), program memiliki perilaku yang tidak ditentukan.  [Catatan: Jika ada penggunaan objek dengan durasi penyimpanan statis yang tidak terjadi sebelum kerusakan objek, program memiliki perilaku yang tidak ditentukan.  Mengakhiri setiap utas sebelum panggilan ke std :: keluar atau keluar dari utama sudah cukup, tetapi tidak perlu, untuk memenuhi persyaratan ini.  Persyaratan ini mengizinkan manajer utas sebagai objek durasi penyimpanan statis.  ‚ÄîEnd note] <br><br>  5. Memanggil fungsi std :: abort () yang dideklarasikan dalam ‚Äúcstdlib‚Äù mengakhiri program tanpa mengeksekusi destruktor dan tanpa memanggil fungsi yang dilewatkan ke std :: atexit () atau std :: at_quick_exit (). </blockquote>  Interpretasi: <br><br><ul><li>  penghancuran objek dengan durasi penyimpanan thread dilakukan dalam urutan terbalik dari penciptaannya; </li><li>  setelah itu, objek dengan durasi penyimpanan statis dihancurkan dan panggilan dilakukan ke fungsi yang terdaftar dengan std :: atexit dalam urutan terbalik untuk membuat objek tersebut dan mendaftarkan fungsi tersebut; </li><li>  Upaya untuk mengakses objek yang hancur dengan durasi penyimpanan utas atau durasi penyimpanan statis berisi perilaku yang tidak terdefinisi.  Inisialisasi ulang objek tersebut tidak disediakan. </li></ul><br>  Catatan: variabel global dalam standar disebut sebagai "variabel non-lokal dengan durasi penyimpanan statis".  Akibatnya, ternyata semua variabel global, semua singletone (statika lokal) dan semua panggilan ke std :: atexit jatuh ke dalam antrian LIFO tunggal saat mereka dibuat / terdaftar. <br><br>  Informasi yang berguna untuk artikel ini juga terdapat di bagian <b>3.6.2 Inisialisasi variabel non-lokal [basic.start.init]</b> .  Saya hanya membawa yang paling penting: <br><blockquote>  Inisialisasi dinamis dari variabel non-lokal dengan durasi penyimpanan statis dapat dipesan atau tidak.  [...] Variabel dengan inisialisasi terurut yang didefinisikan dalam unit terjemahan tunggal harus diinisialisasi dalam urutan definisi mereka dalam unit terjemahan. </blockquote>  Interpretasi (dengan mempertimbangkan teks lengkap bagian ini): variabel global dalam satu unit terjemahan diinisialisasi dalam urutan deklarasi. <br><br><h3>  Apa yang akan ada dalam kode </h3><br>  Semua contoh kode yang disediakan dalam artikel dipublikasikan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github</a> . <br><br>  Kode terdiri dari tiga lapisan, seolah-olah ditulis oleh orang yang berbeda: <br><br><ul><li>  singleton; </li><li>  utilitas (kelas menggunakan singleton); </li><li>  pengguna (variabel global dan utama). </li></ul><br>  Singleton dan utilitasnya seperti perpustakaan pihak ketiga, dan pengguna adalah pengguna. <br>  Lapisan utilitas dirancang untuk mengisolasi lapisan pengguna dari lapisan tunggal.  Dalam contoh, pengguna memiliki kesempatan untuk mengakses singleton, tetapi kami akan bertindak seolah-olah itu tidak mungkin. <br><br>  Pengguna pertama melakukan segalanya dengan benar, dan kemudian dengan jentikan pergelangan tangan segalanya pecah.  Pertama kita mencoba untuk memperbaikinya di lapisan utilitas, dan jika tidak berhasil, maka di lapisan tunggal. <br><br>  Dalam kode, kita akan terus berjalan di sepanjang tepi - sekarang di sisi terang, lalu di gelap.  Untuk membuatnya lebih mudah untuk beralih ke sisi gelap, case yang paling sulit dipilih - mengakses singleton dari utilitas destruktor. <br><br>  <b>Mengapa kasus pemanggilan dari destruktor yang paling sulit?</b>  Karena utilitas perusak dapat dipanggil dalam proses meminimalkan aplikasi, ketika pertanyaan ‚Äúapakah singleton telah dihancurkan atau belum‚Äù menjadi relevan. <br><br>  <b>Kasingnya semacam sintetis.</b>  <b>Dalam praktiknya, panggilan ke singleton dari destructor tidak diperlukan.</b>  Bahkan sesuai kebutuhan.  Misalnya, untuk mencatat kerusakan objek. <br><br>  Tiga kelas singleton digunakan: <br><br><ul><li>  SingletonClassic - tidak ada petunjuk pintar.  Sebenarnya, itu tidak langsung klasik, tetapi jelas yang paling klasik di antara ketiganya dipertimbangkan; </li><li>  SingletonShared - dengan std :: shared_ptr; </li><li>  SingletonWeak - dengan std :: lemah_ptr. </li></ul><br>  Semua singletones adalah templat.  Parameter template digunakan untuk mewarisi darinya.  Dalam sebagian besar contoh, mereka diparameterisasi oleh kelas Payload, yang menyediakan satu fungsi publik untuk menambahkan data ke std :: set. <br><br>  Penghancur utilitas dalam kebanyakan contoh mencoba mengisi seratus nilai di sana.  Keluaran diagnostik ke konsol juga digunakan dari konstruktor singleton, destruktor singleton, dan instance (). <br><br>  <b>Kenapa begitu sulit?</b>  Untuk membuatnya lebih mudah untuk memahami bahwa kita berada di sisi gelap.  Seruan kepada singleton yang hancur adalah perilaku yang tidak terdefinisi, tetapi mungkin tidak dimanifestasikan dengan cara apa pun secara eksternal.  Memasukkan nilai ke std :: set yang hancur juga tentu saja tidak menjamin manifestasi eksternal, tetapi tidak ada cara yang lebih dapat diandalkan (pada kenyataannya, di GCC di Linux dalam contoh yang salah dengan singleton klasik, std :: set yang dihancurkan berhasil diisi, dan dalam MSVS di bawah Windows - hang).  Dengan perilaku tidak terdefinisi, output ke konsol mungkin <b>tidak</b> terjadi.  Jadi dalam contoh yang benar, kami mengharapkan tidak adanya akses ke instance () setelah destruktor, serta tidak adanya crash dan tidak ada hang, dan pada yang tidak benar, baik dengan adanya banding, atau crash, atau hang, atau sekaligus dalam kombinasi apa pun, atau apa pun. <br><br><h3>  Singleton klasik </h3><br><div class="spoiler">  <b class="spoiler_title">Payload.h</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;set&gt; class Payload { public: Payload() = default; ~Payload() = default; Payload(const Payload &amp;) = delete; Payload(Payload &amp;&amp;) = delete; Payload&amp; operator=(const Payload &amp;) = delete; Payload&amp; operator=(Payload &amp;&amp;) = delete; void add(int value) { m_data.emplace(value); } private: std::set&lt;int&gt; m_data; };</span></span></span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">SingletonClassic.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; template&lt;typename T&gt; class SingletonClassic : public T { public: ~SingletonClassic() { std::cout &lt;&lt; "~SingletonClassic()" &lt;&lt; std::endl; } SingletonClassic(const SingletonClassic &amp;) = delete; SingletonClassic(SingletonClassic &amp;&amp;) = delete; SingletonClassic&amp; operator=(const SingletonClassic &amp;) = delete; SingletonClassic&amp; operator=(SingletonClassic &amp;&amp;) = delete; static SingletonClassic&amp; instance() { std::cout &lt;&lt; "instance()" &lt;&lt; std::endl; static SingletonClassic inst; return inst; } private: SingletonClassic() { std::cout &lt;&lt; "SingletonClassic()" &lt;&lt; std::endl; } };</span></span></span></span></code> </pre><br></div></div><br><h3>  SingletonClassic example 1 </h3><br><div class="spoiler">  <b class="spoiler_title">Classic_Example1_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonClassic.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class ClassicSingleThreadedUtility { public: ClassicSingleThreadedUtility() { // To ensure that singleton will be constucted before utility SingletonClassic&lt;Payload&gt;::instance(); } ~ClassicSingleThreadedUtility() { auto &amp;instance = SingletonClassic&lt;Payload&gt;::instance(); for ( int i = 0; i &lt; 100; ++i ) instance.add(i); } }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified ClassicSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;ClassicSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;ClassicSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order is correct int main() { return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Output Konsol</b> <div class="spoiler_text">  contoh () <br>  SingletonClassic () <br>  contoh () <br>  ~ SingletonClassic () <br></div></div><br>  Utilitas memanggil singleton dalam konstruktor untuk memastikan bahwa singleton dibuat sebelum utilitas dibuat. <br><br>  Pengguna membuat dua std :: unique_ptr: satu kosong, yang kedua berisi utilitas. <br><br>  Urutan penciptaan: <br><br>  - empty std :: unique_ptr. <br>  - singleton; <br>  - utilitas. <br><br>  Dan karenanya, urutan kehancuran: <br><br>  - utilitas; <br>  - singleton; <br>  - empty std :: unique_ptr. <br><br>  Panggilan dari perusak utilitas ke singleton sudah benar. <br><br><h3>  SingletonClassic example 2 </h3><br>  Semuanya sama, tetapi pengguna mengambilnya dan merusak semuanya dengan satu baris. <br><br><div class="spoiler">  <b class="spoiler_title">Classic_Example2_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonClassic.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class ClassicSingleThreadedUtility { public: ClassicSingleThreadedUtility() { // To ensure that singleton will be constucted before utility SingletonClassic&lt;Payload&gt;::instance(); } ~ClassicSingleThreadedUtility() { auto &amp;instance = SingletonClassic&lt;Payload&gt;::instance(); for ( int i = 0; i &lt; 100; ++i ) instance.add(i); } }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified ClassicSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;ClassicSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;ClassicSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order seems to be correct ... int main() { // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); // Guaranteed destruction order is still the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Output Konsol</b> <div class="spoiler_text">  contoh () <br>  SingletonClassic () <br>  ~ SingletonClassic () <br>  contoh () <br></div></div><br>  Urutan penciptaan dan kehancuran dipertahankan.  Tampaknya semuanya masih ada.  Tapi tidak.  Dengan memanggil emptyUnique.swap (utilityUnique), pengguna melakukan perilaku yang tidak terdefinisi. <br><br>  <b>Mengapa pengguna melakukan hal bodoh seperti itu?</b>  Karena dia tidak tahu apa-apa tentang struktur internal perpustakaan, yang memberinya singleton dan utilitas. <br><br>  <b>Dan apakah Anda tahu struktur internal perpustakaan?</b>  ... kalau begitu, dalam kode nyata sangat mudah untuk terlibat.  Dan Anda harus keluar dengan debag yang menyakitkan, karena  untuk memahami apa yang sebenarnya terjadi tidak akan mudah. <br><br>  <b>Mengapa tidak mengharuskan perpustakaan digunakan dengan benar?</b>  <b>Nah, ada semua jenis dermaga untuk ditulis, contoh ...</b> Dan mengapa tidak membuat perpustakaan yang tidak begitu mudah rusak? <br><br><h3>  SingletonClassic example 3 </h3><br>  Dalam mempersiapkan artikel selama beberapa hari, saya percaya bahwa tidak mungkin untuk menghilangkan perilaku tidak terbatas dari contoh sebelumnya di lapisan utilitas, dan solusinya hanya tersedia di lapisan tunggal.  Namun seiring berjalannya waktu, sebuah solusi masih muncul. <br><br>  Sebelum membuka spoiler dengan kode dan penjelasan, saya sarankan pembaca untuk mencoba mencari jalan keluar dari situasi mereka sendiri (hanya di lapisan utilitas!).  Saya tidak mengesampingkan bahwa ada solusi yang lebih baik. <br><br><div class="spoiler">  <b class="spoiler_title">Classic_Example3_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonClassic.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;iostream&gt; class ClassicSingleThreadedUtility { public: ClassicSingleThreadedUtility() { thread_local auto flag_strong = std::make_shared&lt;char&gt;(0); m_flag_weak = flag_strong; SingletonClassic&lt;Payload&gt;::instance(); } ~ClassicSingleThreadedUtility() { if ( !m_flag_weak.expired() ) { auto &amp;instance = SingletonClassic&lt;Payload&gt;::instance(); for ( int i = 0; i &lt; 100; ++i ) instance.add(i); } } private: std::weak_ptr&lt;char&gt; m_flag_weak; }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified ClassicSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;ClassicSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;ClassicSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order seems to be correct ... int main() { // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); { // To demonstrate normal processing before application ends auto utility = ClassicSingleThreadedUtility(); } // Guaranteed destruction order is still the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect ... // ... but utility uses a variable with thread storage duration to detect thread termination. return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Output Konsol</b> <div class="spoiler_text">  contoh () <br>  SingletonClassic () <br>  contoh () <br>  contoh () <br>  ~ SingletonClassic () <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Penjelasan</b> <div class="spoiler_text">  Masalahnya hanya terjadi ketika meminimalkan aplikasi.  Perilaku tidak terdefinisi dapat dihilangkan dengan mengajarkan utilitas untuk mengenali kapan aplikasi diminimalkan.  Untuk melakukan ini, kami menggunakan variabel flag_strong dari std :: shared_ptr type, yang memiliki kualifikasi durasi penyimpanan thread (lihat kutipan dari standar dalam artikel di atas) - ini seperti statis, tetapi hanya dihancurkan ketika utas saat ini berakhir <b>sebelum statika dihancurkan</b> , termasuk sebelum kehancuran singleton.  Variabel flag_strong adalah satu untuk seluruh aliran, dan setiap instance dari utilitas menyimpan salinannya yang lemah. <br><br>  Dalam arti sempit, solusinya bisa disebut hack, karena  itu tidak langsung dan tidak jelas.  Selain itu, ia memperingatkan terlalu dini, dan kadang-kadang (dalam aplikasi multi-utas) umumnya memperingatkan salah.  Namun dalam arti luas, ini bukan peretasan, tetapi solusi dengan sepenuhnya ditentukan oleh properti standar - baik kerugian dan keuntungan. <br></div></div><br><h3>  Singletonshared </h3><br>  Mari kita beralih ke singleton yang dimodifikasi berdasarkan std :: shared_ptr. <br><br><div class="spoiler">  <b class="spoiler_title">SingletonShared.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;iostream&gt; template&lt;typename T&gt; class SingletonShared : public T { public: ~SingletonShared() { std::cout &lt;&lt; "~SingletonShared()" &lt;&lt; std::endl; } SingletonShared(const SingletonShared &amp;) = delete; SingletonShared(SingletonShared &amp;&amp;) = delete; SingletonShared&amp; operator=(const SingletonShared &amp;) = delete; SingletonShared&amp; operator=(SingletonShared &amp;&amp;) = delete; static std::shared_ptr&lt;SingletonShared&gt; instance() { std::cout &lt;&lt; "instance()" &lt;&lt; std::endl; // "new" and no std::make_shared because of private c-tor static auto inst = std::shared_ptr&lt;SingletonShared&gt;(new SingletonShared); return inst; } private: SingletonShared() { std::cout &lt;&lt; "SingletonShared()" &lt;&lt; std::endl; } };</span></span></span></span></code> </pre><br></div></div><br>  <b>Ay-ah-ah, operator baru tidak boleh digunakan dalam kode modern, tetapi std :: make_share diperlukan!</b>  Dan ini dicegah oleh konstruktor pribadi singleton. <br><br>  <b>Ha!</b>  <b>Saya punya masalah juga!</b>  <b>Deklarasikan std :: make_share freind singleton!</b>  ... dan dapatkan variasi PublicMorozov yang antipattern: menggunakan std :: make_share yang sama, dimungkinkan untuk membuat instance tambahan dari singleton yang tidak disediakan oleh arsitektur. <br><br><h3>  SingletonShared Contoh 1 dan 2 </h3><br>  Sepenuhnya sesuai dengan contoh No. 1 dan 2 untuk versi klasik.  Perubahan signifikan dibuat hanya pada lapisan tunggal, utilitas dasarnya tetap sama.  Sama seperti dalam contoh dengan singleton klasik, contoh-1 benar, dan contoh-2 menunjukkan perilaku yang tidak terdefinisi. <br><br><div class="spoiler">  <b class="spoiler_title">Shared_Example1_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Payload.h&gt; #include &lt;memory&gt; class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() { // To ensure that singleton will be constucted before utility SingletonShared&lt;Payload&gt;::instance(); } ~SharedSingleThreadedUtility() { if ( auto instance = SingletonShared&lt;Payload&gt;::instance() ) for ( int i = 0; i &lt; 100; ++i ) instance-&gt;add(i); } }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified SharedSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;SharedSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;SharedSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order is correct int main() { return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Output Konsol</b> <div class="spoiler_text">  contoh () <br>  SingletonShared () <br>  contoh () <br>  ~ SingletonShared () <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Shared_Example2_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() { // To ensure that singleton will be constucted before utility SingletonShared&lt;Payload&gt;::instance(); } ~SharedSingleThreadedUtility() { // Sometimes this check may result as "false" even for destroyed singleton // preventing from visual effects of undefined behaviour ... //if ( auto instance = SingletonShared::instance() ) // for ( int i = 0; i &lt; 100; ++i ) // instance-&gt;add(i); // ... so this code will demonstrate UB in colour auto instance = SingletonShared&lt;Payload&gt;::instance(); for ( int i = 0; i &lt; 100; ++i ) instance-&gt;add(i); } }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified SharedSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;SharedSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;SharedSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order seems to be correct ... int main() { // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); // Guaranteed destruction order is the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Output Konsol</b> <div class="spoiler_text">  contoh () <br>  SingletonShared () <br>  ~ SingletonShared () <br>  contoh () <br></div></div><br><h3>  Contoh SingletonShared 3 </h3><br>  Dan sekarang kami akan mencoba untuk memperbaiki masalah ini lebih baik daripada dalam contoh nomor 3 dari klasik. <br>  Solusinya jelas: Anda hanya perlu memperpanjang umur singleton dengan menyimpan salinan std :: shared_ptr yang dikembalikan oleh singleton dalam utilitas.  Dan solusi ini, lengkap dengan SingletonShared, telah direplikasi secara luas dalam sumber terbuka. <br><br><div class="spoiler">  <b class="spoiler_title">Shared_Example3_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() // To ensure that singleton will be constucted before utility : m_singleton(SingletonShared&lt;Payload&gt;::instance()) { } ~SharedSingleThreadedUtility() { // Sometimes this check may result as "false" even for destroyed singleton // preventing from visual effects of undefined behaviour ... //if ( m_singleton ) // for ( int i = 0; i &lt; 100; ++i ) // m_singleton-&gt;add(i); // ... so this code will allow to demonstrate UB in colour for ( int i = 0; i &lt; 100; ++i ) m_singleton-&gt;add(i); } private: // A copy of smart pointer, not a reference std::shared_ptr&lt;SingletonShared&lt;Payload&gt;&gt; m_singleton; }; // 1. Create an empty unique_ptr // 2. Create singleton (because of SharedSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;SharedSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;SharedSingleThreadedUtility&gt;(); int main() { // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order is correct ... // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); // Guaranteed destruction order is the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect... // ... but utility have made a copy of shared_ptr when it was available, // so it's correct again. return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Output Konsol</b> <div class="spoiler_text">  contoh () <br>  SingletonShared () <br>  ~ SingletonShared () <br></div></div><br>  Dan sekarang, perhatian, pertanyaannya adalah: <b>apakah Anda benar-benar ingin memperpanjang hidup seorang lajang?</b> <br>  Atau apakah Anda ingin menyingkirkan perilaku tak terbatas, dan memilih perpanjangan hidup sebagai cara berbaring di permukaan? <br><br>  Ketidaktepatan teoretis dalam bentuk penggantian tujuan dengan cara mengarah pada risiko kebuntuan (atau referensi siklik - sebut saja apa yang Anda inginkan). <br><br>  <b>Ya nuuuuuuu, ini yang harus kamu coba!</b>  <b>Anda harus datang dengan waktu yang begitu lama, dan Anda pasti tidak akan melakukannya secara tidak sengaja!</b> <br><br><div class="spoiler">  <b class="spoiler_title">CallbackPayload.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;functional&gt; class CallbackPayload { public: CallbackPayload() = default; ~CallbackPayload() = default; CallbackPayload(const CallbackPayload &amp;) = delete; CallbackPayload(CallbackPayload &amp;&amp;) = delete; CallbackPayload&amp; operator=(const CallbackPayload &amp;) = delete; CallbackPayload&amp; operator=(CallbackPayload &amp;&amp;) = delete; void setCallback(std::function&lt;void()&gt; &amp;&amp;fn) { m_callbackFn = std::move(fn); } private: std::function&lt;void()&gt; m_callbackFn; };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">SomethingWithVeryImportantDestructor.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; class SomethingWithVeryImportantDestructor { public: SomethingWithVeryImportantDestructor() { std::cout &lt;&lt; "SomethingWithVeryImportantDestructor()" &lt;&lt; std::endl; } ~SomethingWithVeryImportantDestructor() { std::cout &lt;&lt; "~SomethingWithVeryImportantDestructor()" &lt;&lt; std::endl; } SomethingWithVeryImportantDestructor(const SomethingWithVeryImportantDestructor &amp;) = delete; SomethingWithVeryImportantDestructor(SomethingWithVeryImportantDestructor &amp;&amp;) = delete; SomethingWithVeryImportantDestructor&amp; operator=(const SomethingWithVeryImportantDestructor &amp;) = delete; SomethingWithVeryImportantDestructor&amp; operator=(SomethingWithVeryImportantDestructor &amp;&amp;) = delete; };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Shared_Example4_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CallbackPayload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SomethingWithVeryImportantDestructor.h"</span></span></span><span class="hljs-meta"> class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// To ensure that singleton will be constucted before utility : m_singleton(SingletonShared&lt;CallbackPayload&gt;::instance()) { std::cout &lt;&lt; "SharedSingleThreadedUtility()" &lt;&lt; std::endl; } ~SharedSingleThreadedUtility() { std::cout &lt;&lt; "~SharedSingleThreadedUtility()" &lt;&lt; std::endl; } void setCallback(std::function&lt;void()&gt; &amp;&amp;fn) { if ( m_singleton ) m_singleton-&gt;setCallback(std::move(fn)); } private: // A copy of smart pointer, not a reference std::shared_ptr&lt;SingletonShared&lt;CallbackPayload&gt;&gt; m_singleton; }; int main() { auto utility = std::make_shared&lt;SharedSingleThreadedUtility&gt;(); auto something = std::make_shared&lt;SomethingWithVeryImportantDestructor&gt;(); // lambda with "utility" and "something" captured utility-&gt;setCallback( [utility, something](){} ); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Output Konsol</b> <div class="spoiler_text">  contoh () <br>  SingletonShared () <br>  SharedSingleThreadedUtility () <br>  SomethingWithVeryImportantDestructor () <br></div></div><br>  Singleton diciptakan. <br><br>  Utilitas telah dibuat. <br><br>  <b>Sesuatu S-Sangat-Penting-Destructor telah dibuat</b> (saya menambahkan ini untuk intimidasi, karena di Internet ada tulisan seperti "well, singleton destructor tidak akan dipanggil, jadi bagaimana dengan ini, itu harus ada sepanjang waktu program ‚Äù). <br><br>  Tapi tidak ada destructor yang dipanggil untuk benda-benda ini! <br><br>  Karena apa?  Karena penggantian tujuan dengan cara. <br><br><h3>  Singletonweak </h3><br><div class="spoiler">  <b class="spoiler_title">SingletonWeak.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;iostream&gt; template&lt;typename T&gt; class SingletonWeak : public T { public: ~SingletonWeak() { std::cout &lt;&lt; "~SingletonWeak()" &lt;&lt; std::endl; } SingletonWeak(const SingletonWeak &amp;) = delete; SingletonWeak(SingletonWeak &amp;&amp;) = delete; SingletonWeak&amp; operator=(const SingletonWeak &amp;) = delete; SingletonWeak&amp; operator=(SingletonWeak &amp;&amp;) = delete; static std::weak_ptr&lt;SingletonWeak&gt; instance() { std::cout &lt;&lt; "instance()" &lt;&lt; std::endl; // "new" and no std::make_shared because of private c-tor static auto inst = std::shared_ptr&lt;SingletonWeak&gt;(new SingletonWeak); return inst; } private: SingletonWeak() { std::cout &lt;&lt; "SingletonWeak()" &lt;&lt; std::endl; } };</span></span></span></span></code> </pre><br></div></div><br>  Modifikasi singleton dalam sumber terbuka, jika diberikan, tentu tidak sering.  Saya bertemu dengan beberapa varian aneh yang terbalik dengan std :: lemah_ptr, yang tampaknya digunakan, yang, tampaknya, menawarkan utilitas tidak lebih dari untuk memperpanjang umur seorang singleton: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lajang menggunakan std :: lemah_ptr</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apakah ini cara yang benar untuk membuat kelas sinlgeton oleh lemah_ptr</a> </li></ul><br>  Opsi yang saya usulkan, bila diterapkan dengan benar di lapisan tunggal dan utilitas: <br><br><ul><li>  melindungi terhadap tindakan di lapisan pengguna yang dijelaskan dalam contoh di atas, termasuk mencegah kebuntuan; </li><li>  menentukan saat pelipatan aplikasi lebih akurat daripada aplikasi thread_local di Classic_Example3_correct, mis.  memungkinkan Anda untuk mendekat ke tepi; </li><li>  Saya tidak menderita dari masalah teoretis dengan mengganti tujuan dengan cara (saya tidak tahu apakah sesuatu yang nyata selain kebuntuan dapat muncul dari masalah teoritis ini). </li></ul><br>  Namun, ada kekurangannya: memperpanjang umur seorang lajang <b>masih</b> bisa <b>membuatnya semakin dekat</b> ke tepi. <br><br><h3>  Contoh SingletonWeak 1 </h3><br>  Mirip dengan Shared_Example3_correct.cpp. <br><br><div class="spoiler">  <b class="spoiler_title">Weak_Example1_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonWeak.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class WeakSingleThreadedUtility { public: WeakSingleThreadedUtility() // To ensure that singleton will be constucted before utility : m_weak(SingletonWeak&lt;Payload&gt;::instance()) { } ~WeakSingleThreadedUtility() { // Sometimes this check may result as "false" even in case of incorrect usage, // and there's no way to guarantee a demonstration of undefined behaviour in colour if ( auto strong = m_weak.lock() ) for ( int i = 0; i &lt; 100; ++i ) strong-&gt;add(i); } private: // A weak copy of smart pointer, not a reference std::weak_ptr&lt;SingletonWeak&lt;Payload&gt;&gt; m_weak; }; // 1. Create an empty unique_ptr // 2. Create singleton (because of WeakSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;WeakSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;WeakSingleThreadedUtility&gt;(); int main() { // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order is correct ... // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); // Guaranteed destruction order is the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect... // ... but utility have made a weak copy of shared_ptr when it was available, // so it's correct again. return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Output Konsol</b> <div class="spoiler_text">  contoh () <br>  SingletonWeak () <br>  ~ SingletonWeak () <br></div></div><br>  <b>Mengapa kita perlu SingletonWeak, karena tidak ada yang mengganggu utilitas untuk menggunakan SingletonShared sebagai SingletonWeak?</b>  Ya, tidak ada yang mengganggu.  Dan bahkan tidak ada yang mengganggu utilitas untuk menggunakan SingletonWeak sebagai SingletonShared.  Tetapi menggunakannya untuk tujuan yang dimaksudkan sedikit lebih mudah daripada menggunakannya untuk tujuan lain. <br><br><h3>  Contoh SingletonWeak 2 </h3><br>  Mirip dengan Shared_Example4_incorrect, tetapi hanya kebuntuan yang tidak terjadi dalam kasus ini. <br><br><div class="spoiler">  <b class="spoiler_title">Weak_Example2_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonWeak.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CallbackPayload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SomethingWithVeryImportantDestructor.h"</span></span></span><span class="hljs-meta"> class WeakSingleThreadedUtility { public: WeakSingleThreadedUtility() </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// To ensure that singleton will be constucted before utility : m_weak(SingletonWeak&lt;CallbackPayload&gt;::instance()) { std::cout &lt;&lt; "WeakSingleThreadedUtility()" &lt;&lt; std::endl; } ~WeakSingleThreadedUtility() { std::cout &lt;&lt; "~WeakSingleThreadedUtility()" &lt;&lt; std::endl; } void setCallback(std::function&lt;void()&gt; &amp;&amp;fn) { if ( auto strong = m_weak.lock() ) strong-&gt;setCallback(std::move(fn)); } private: // A weak copy of smart pointer, not a reference std::weak_ptr&lt;SingletonWeak&lt;CallbackPayload&gt;&gt; m_weak; }; int main() { auto utility = std::make_shared&lt;WeakSingleThreadedUtility&gt;(); auto something = std::make_shared&lt;SomethingWithVeryImportantDestructor&gt;(); // lambda with "utility" and "something" captured utility-&gt;setCallback( [utility, something](){} ); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Output Konsol</b> <div class="spoiler_text">  contoh () <br>  SingletonWeak () <br>  LemahSingleThreadedUtility () <br>  SomethingWithVeryImportantDestructor () <br>  ~ SingletonWeak () <br>  ~ SomethingWithVeryImportantDestructor () <br>  ~ LemahSingleThreadedUtility () <br></div></div><br><h3>  Alih-alih sebuah kesimpulan </h3><br>  <b>Dan apa, modifikasi singleton seperti itu akan menghilangkan perilaku tidak terdefinisi?</b>  Saya berjanji tidak akan ada akhir yang bahagia.  Contoh-contoh berikut menunjukkan bahwa tindakan sabotase yang terampil di lapisan pengguna dapat menghancurkan bahkan perpustakaan pemikiran yang benar dengan satu singleton (tetapi kita harus mengakui bahwa <b>ini</b> hampir tidak dapat dilakukan secara kebetulan). <br><br><div class="spoiler">  <b class="spoiler_title">Shared_Example5_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;cstdlib&gt; class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() // To ensure that singleton will be constucted before utility : m_singleton(SingletonShared&lt;Payload&gt;::instance()) { } ~SharedSingleThreadedUtility() { // Sometimes this check may result as "false" even for destroyed singleton // preventing from visual effects of undefined behaviour ... //if ( m_singleton ) // for ( int i = 0; i &lt; 100; ++i ) // m_singleton-&gt;add(i); // ... so this code will allow to demonstrate UB in colour for ( int i = 0; i &lt; 100; ++i ) m_singleton-&gt;add(i); } private: // A copy of smart pointer, not a reference std::shared_ptr&lt;SingletonShared&lt;Payload&gt;&gt; m_singleton; }; void cracker() { SharedSingleThreadedUtility(); } // 1. Register cracker() using std::atexit // 2. Create singleton // 3. Create utility auto reg = [](){ std::atexit(&amp;cracker); return 0; }(); auto utility = SharedSingleThreadedUtility(); // This guarantee destruction in order: // - utility; // - singleton. // This order is correct. // Additionally, there's a copy of shared_ptr in the class instance... // ... but there was std::atexit registered before singleton, // so cracker() will be invoked after destruction of utility and singleton. // There's second try to create a singleton - and it's incorrect. int main() { return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Output Konsol</b> <div class="spoiler_text">  contoh () <br>  SingletonShared () <br>  ~ SingletonShared () <br>  contoh () <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Weak_Example3_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonWeak.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;cstdlib&gt; class WeakSingleThreadedUtility { public: WeakSingleThreadedUtility() // To ensure that singleton will be constucted before utility : m_weak(SingletonWeak&lt;Payload&gt;::instance()) { } ~WeakSingleThreadedUtility() { // Sometimes this check may result as "false" even in case of incorrect usage, // and there's no way to guarantee a demonstration of undefined behaviour in colour if ( auto strong = m_weak.lock() ) for ( int i = 0; i &lt; 100; ++i ) strong-&gt;add(i); } private: // A weak copy of smart pointer, not a reference std::weak_ptr&lt;SingletonWeak&lt;Payload&gt;&gt; m_weak; }; void cracker() { WeakSingleThreadedUtility(); } // 1. Register cracker() using std::atexit // 2. Create singleton // 3. Create utility auto reg = [](){ std::atexit(&amp;cracker); return 0; }(); auto utility = WeakSingleThreadedUtility(); // This guarantee destruction in order: // - utility; // - singleton. // This order is correct. // Additionally, there's a copy of shared_ptr in the class instance... // ... but there was std::atexit registered before singleton, // so cracker() will be invoked after destruction of utility and singleton. // There's second try to create a singleton - and it's incorrect. int main() { return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Output Konsol</b> <div class="spoiler_text">  contoh () <br>  SingletonWeak () <br>  ~ SingletonWeak () <br>  contoh () <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455848/">https://habr.com/ru/post/id455848/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455834/index.html">Tolok ukur untuk server Linux: 5 alat terbuka</a></li>
<li><a href="../id455840/index.html">Cara bekerja dengan beberapa kueri. Komposisi, Peredam, FP</a></li>
<li><a href="../id455842/index.html">Sebarkan daftar yang terhubung sendiri. Edisi cepat</a></li>
<li><a href="../id455844/index.html">Membuat penganalisis Roslyn menggunakan pengujian enkapsulasi sebagai contoh</a></li>
<li><a href="../id455846/index.html">Komputasi Terdistribusi di Julia</a></li>
<li><a href="../id455850/index.html">Kotak Alat untuk Peneliti - Edisi Ketiga: Mencari dan Bekerja dengan Sumber</a></li>
<li><a href="../id455852/index.html">Pengangkatan sinus dan implantasi simultan</a></li>
<li><a href="../id455854/index.html">Bagaimana menerapkan Menu Konteks di iOS 13</a></li>
<li><a href="../id455856/index.html">Suhu nirkabel, kelembaban dan sensor tekanan atmosfer pada nRF52832</a></li>
<li><a href="../id455858/index.html">Jaringan TV kabel untuk yang terkecil. Bagian 9: Headend</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>