<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😶 🆙 🎤 Tidak Aman. AsSpan: Rentang <T> bagaimana cara mengganti pointer? ⌨️ 👋 ✌🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C# adalah bahasa yang sangat fleksibel. Di atasnya Anda dapat menulis tidak hanya aplikasi backend atau desktop. Saya menggunakan C# untuk bekerja den...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tidak Aman. AsSpan: Rentang <T> bagaimana cara mengganti pointer?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465077/"><p><img src="https://habrastorage.org/webt/3f/dh/ia/3fdhia5h25mpjbabeocnlygdd1c.png"></p><br><p> <code>C#</code> adalah bahasa yang sangat fleksibel.  Di atasnya Anda dapat menulis tidak hanya aplikasi backend atau desktop.  Saya menggunakan <code>C#</code> untuk bekerja dengan data ilmiah, yang memaksakan persyaratan tertentu pada alat yang tersedia dalam bahasa.  Meskipun <code>netcore</code> mengambil agenda (mengingat bahwa setelah <code>netstandard2.0</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebagian besar</a> fitur dari kedua bahasa dan runtime tidak <code>netframework</code> untuk <code>netframework</code> ), saya terus bekerja dengan proyek-proyek warisan. </p><br><p>  Pada artikel ini, saya menganggap satu aplikasi <code>Span&lt;T&gt;</code> tidak jelas (tapi mungkin diinginkan?) Dan perbedaan antara implementasi <code>Span&lt;T&gt;</code> dalam <code>netframework</code> dan <code>netcore</code> karena spesifikasi <code>clr</code> . </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Penafian 1</b> <div class="spoiler_text"><p>  Cuplikan kode dalam artikel ini sama sekali tidak dimaksudkan untuk digunakan dalam proyek dunia nyata. </p><br><p>  Solusi yang diajukan untuk Masalah (yang dibuat-buat?) Itu lebih merupakan konsep bukti. <br>  Bagaimanapun, dengan menerapkan ini dalam proyek Anda, Anda melakukan ini atas risiko dan risiko Anda sendiri. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Penafian 2</b> <div class="spoiler_text"><p>  Saya benar-benar yakin bahwa di suatu tempat, dalam beberapa kasus, ini <strong>pasti akan</strong> menembak seseorang di lutut. </p><br><p>  Tipe bypass keamanan dalam <code>C#</code> tidak mungkin mengarah ke sesuatu yang baik. </p><br><p>  Untuk alasan yang jelas, saya tidak menguji kode ini dalam semua situasi yang mungkin, namun, hasil awal terlihat menjanjikan. </p></div></div><br><h1 id="a-zachem-mne-voobsche-spant">  Mengapa saya perlu <code>Span&lt;T&gt;</code> ? </h1><br><p>  Spen memungkinkan Anda untuk bekerja dengan array tipe yang <code>unmanaged</code> dalam bentuk yang lebih nyaman, mengurangi jumlah alokasi yang diperlukan.  Terlepas dari kenyataan bahwa span support di <code>BCL</code> <code>netframework</code> hampir sepenuhnya tidak ada, beberapa alat dapat diperoleh menggunakan <code>System.Memory</code> , <code>System.Buffers</code> dan <code>System.Runtime.CompilerServices.Unsafe</code> . <br>  Penggunaan bentang dalam proyek lawas saya terbatas, namun, saya menemukan mereka penggunaan yang tidak terlihat, sambil meludahi keamanan jenis. <br>  Apa aplikasi ini?  Dalam proyek saya, saya bekerja dengan data yang diperoleh dari alat ilmiah.  Ini adalah gambar yang, secara umum, adalah array dari <code>T[]</code> , di mana <code>T</code> adalah salah satu tipe primitif yang <code>unmanaged</code> , misalnya <code>Int32</code> (alias <code>int</code> ).  Untuk membuat serial gambar-gambar ini dengan benar ke disk, saya perlu mendukung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">format warisan yang</a> sangat tidak nyaman, yang diusulkan pada tahun <a href="">1981</a> , dan sejak itu sedikit berubah.  Masalah utama dari format ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BigEndian</a> .  Jadi, untuk menulis (atau membaca) larik <code>T[]</code> tidak terkompresi, Anda perlu mengubah endianess dari setiap elemen.  Tugas sepele. <br>  Apa sajakah solusi yang jelas? </p><br><ol><li>  Kita beralih ke array <code>T[]</code> , panggil <code>BitConverter.GetBytes(T)</code> , perluas beberapa byte ini, salin ke array target. </li><li>  Kami beralih ke array <code>T[]</code> , melakukan penipuan dari bentuk <code>new byte[] {(byte)((x &amp; 0xFF00) &gt;&gt; 8), (byte)(x &amp; 0x00FF)};</code>  (harus bekerja pada tipe byte ganda), tulis ke array target. </li><li>  <sup>*</sup> Tapi apakah <code>T[]</code> sebuah array?  Elemen ada dalam satu baris, bukan?  Jadi, Anda dapat melakukan semuanya, misalnya, <code>Buffer.BlockCopy(intArray, 0, byteArray, 0, intArray.Length * sizeof(int));</code>  .  Metode menyalin array ke array mengabaikan pemeriksaan jenis.  Hanya perlu untuk tidak melewatkan batasan dan alokasi.  Kami mencampur byte sebagai hasilnya. </li><li>  <sup>*</sup> Mereka mengatakan bahwa <code>C#</code> adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>(C++)++</code></a> .  Oleh karena itu, aktifkan <code>/unsafe</code> , <code>fixed(int* p = &amp;intArr[0]) byte* bPtr = (byte*)p;</code>  dan sekarang Anda dapat menjalankan representasi byte dari array sumber, mengubah endianess dengan cepat dan menulis blok ke disk (menambahkan <code>stackalloc byte[]</code> atau <code>ArrayPool&lt;byte&gt;.Shared</code> untuk buffer perantara) tanpa mengalokasikan memori untuk array byte baru. </li></ol><br><p>  Tampaknya poin <strong>4</strong> memungkinkan Anda untuk menyelesaikan semua masalah, tetapi penggunaan eksplisit konteks yang <code>unsafe</code> dan bekerja dengan pointer agak berbeda.  Lalu <code>Span&lt;T&gt;</code> datang membantu kami. </p><br><h1 id="spant"> <code>Span&lt;T&gt;</code> </h1> <br><p>  <code>Span&lt;T&gt;</code> harus secara teknis menyediakan alat untuk bekerja dengan plot memori hampir seperti bekerja melalui pointer, sambil menghilangkan kebutuhan untuk "memperbaiki" array dalam memori.  Seperti pointer <code>GC</code> sadar dengan batas array.  Semuanya baik dan aman. <br>  Satu hal tetapi - terlepas dari kekayaan <code>System.Runtime.CompilerServices.Unsafe</code> , <code>Span&lt;T&gt;</code> dipaku untuk mengetik <code>T</code>  Mengingat bahwa spen pada dasarnya adalah penunjuk panjang <sup>1</sup> +, bagaimana jika Anda menarik penunjuk Anda, mengonversinya ke jenis lain, menghitung ulang panjangnya dan membuat rentang baru?  Untungnya, kami memiliki <code>public Span&lt;T&gt;(void* pointer, int length)</code> . <br>  Mari kita menulis tes sederhana: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Flip</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Span&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; span</span></span></span><span class="hljs-function">)</span></span> {<span class="hljs-comment"><span class="hljs-comment">/*   endianess */</span></span>} Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] {<span class="hljs-number"><span class="hljs-number">123</span></span>}; Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; y = DangerousCast&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;(x); Assert.AreEqual(<span class="hljs-number"><span class="hljs-number">123</span></span>, x[<span class="hljs-number"><span class="hljs-number">0</span></span>]); Flip(y); Assert.AreNotEqual(<span class="hljs-number"><span class="hljs-number">123</span></span>, x[<span class="hljs-number"><span class="hljs-number">0</span></span>]); Flip(y); Assert.AreEqual(<span class="hljs-number"><span class="hljs-number">123</span></span>, x[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }</code> </pre> <br><p>  Pengembang yang lebih maju daripada saya harus segera menyadari apa yang salah di sini.  Akankah tes gagal?  Jawabannya, seperti biasanya terjadi, <strong>tergantung</strong> . <br>  Dalam hal ini, itu tergantung terutama pada runtime.  Pada <code>netcore</code> tes <em>harus</em> bekerja, tetapi pada <code>netframework</code> , bagaimana <code>netframework</code> . <br>  Menariknya, jika Anda menghapus beberapa esai, tes mulai berfungsi dengan benar dalam 100% kasus. <br>  Mari kita perbaiki. </p><br><p>  Saya <em>salah</em> . </p><br><h1 id="pravilnyy-otvet-zavisit">  Jawaban yang benar: tergantung </h1><br><p>  Mengapa hasilnya <em>tergantung</em> ? <br>  Mari kita hapus semua yang tidak perlu dan tulis kode di sini: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; Check(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Check</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] {<span class="hljs-number"><span class="hljs-number">999</span></span>, <span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">-100</span></span>}; Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; y = As&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> x); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">@"FRAMEWORK_NAME"</span></span>); Write(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> x); Write(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> y); Console.WriteLine(); Write&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> x, <span class="hljs-string"><span class="hljs-string">"Span&lt;int&gt; [0]"</span></span>); Write&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> y, <span class="hljs-string"><span class="hljs-string">"Span&lt;byte&gt;[0]"</span></span>); Console.WriteLine(); Write&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> Offset&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> x[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-string"><span class="hljs-string">"Span&lt;int&gt; [0] offset by size_t"</span></span>); Write&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> Offset&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> y[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-string"><span class="hljs-string">"Span&lt;byte&gt;[0] offset by size_t"</span></span>); Console.WriteLine(); GC.Collect(<span class="hljs-number"><span class="hljs-number">0</span></span>, GCCollectionMode.Forced, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); Write&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> x, <span class="hljs-string"><span class="hljs-string">"Span&lt;int&gt; [0] after GC"</span></span>); Write&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> y, <span class="hljs-string"><span class="hljs-string">"Span&lt;byte&gt;[0] after GC"</span></span>); Console.WriteLine(); Write(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> x); Write(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> y); }</code> </pre> <br><p>  Metode <code>Write&lt;T, U&gt;</code> menerima rentang tipe <code>T</code> , membaca alamat elemen pertama, dan membaca melalui pointer ini satu elemen dari tipe <code>U</code>  Dengan kata lain, <code>Write&lt;int, int&gt;(ref x)</code> akan menampilkan alamat dalam memori + angka 999. <br>  Normal <code>Write</code> mencetak array. <br>  Sekarang tentang metode <code>As&lt;,&gt;</code> : </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> Span&lt;U&gt; As&lt;T, U&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> Span&lt;T&gt; span) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> U : unmanaged { <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span>(T* ptr = span) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Span&lt;U&gt;(ptr, span.Length * Unsafe.SizeOf&lt;T&gt;() / Unsafe.SizeOf&lt;U&gt;()); }</code> </pre> <br><p>  Sintaks <code>C#</code> sekarang mendukung catatan kondisi <code>fixed</code> ini dengan memanggil metode <code>Span&lt;T&gt;.GetPinnableReference()</code> secara implisit. <br>  Jalankan metode ini di <code>netframework4.8</code> dalam mode <code>x64</code> .  Kami melihat apa yang terjadi: </p><br><pre> <code class="plaintext hljs">LEGACY [ 999, 123, 11, -100 ] [ 231, 3, 0, 0, 123, 0, 0, 0, 11, 0, 0, 0, 156, 255, 255, 255 ] 0x|00|00|02|8C|00|00|2F|B0 999 Span&lt;int&gt; [0] 0x|00|00|02|8C|00|00|2F|B0 999 Span&lt;byte&gt;[0] 0x|00|00|02|8C|00|00|2F|B8 11 Span&lt;int&gt; [0] offset by size_t 0x|00|00|02|8C|00|00|2F|B8 11 Span&lt;byte&gt;[0] offset by size_t 0x|00|00|02|8C|00|00|2B|18 999 Span&lt;int&gt; [0] after GC 0x|00|00|02|8C|00|00|2F|B0 6750318 Span&lt;byte&gt;[0] after GC [ 999, 123, 11, -100 ] [ 110, 0, 103, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]</code> </pre> <br><p>  Awalnya, kedua bentang (terlepas dari jenis yang berbeda) berperilaku identik, dan <code>Span&lt;byte&gt;</code> , pada dasarnya, mewakili tampilan byte dari array asli.  Apa yang kamu butuhkan <br>  Oke, mari kita coba menggeser awal rentang ke ukuran satu <code>IntPtr</code> (atau <code>2 X int</code> pada <code>x64</code> ) dan membaca.  Kami mendapatkan elemen ketiga dari array dan alamat yang benar.  Dan kemudian kita akan mengumpulkan sampah ... </p><br><pre> <code class="plaintext hljs">GC.Collect(0, GCCollectionMode.Forced, true, true);</code> </pre> <br><p>  Bendera terakhir dalam metode ini meminta <code>GC</code> memadatkan tumpukan.  Setelah memanggil <code>GC.Collect</code> <code>GC</code> memindahkan array lokal asli.  <code>Span&lt;int&gt;</code> mencerminkan perubahan ini, tetapi <code>Span&lt;byte&gt;</code> terus menunjuk ke alamat lama, di mana sekarang tidak jelas apa.  Cara yang bagus untuk menembak diri sendiri dengan berlutut! </p><br><p>  Sekarang mari kita lihat hasil dari fragmen kode yang sama persis disebut pada <code>netcore3.0.100-preview8</code> . </p><br><pre> <code class="plaintext hljs">CORE [ 999, 123, 11, -100 ] [ 231, 3, 0, 0, 123, 0, 0, 0, 11, 0, 0, 0, 156, 255, 255, 255 ] 0x|00|00|01|F2|8F|BD|C6|90 999 Span&lt;int&gt; [0] 0x|00|00|01|F2|8F|BD|C6|90 999 Span&lt;byte&gt;[0] 0x|00|00|01|F2|8F|BD|C6|98 11 Span&lt;int&gt; [0] offset by size_t 0x|00|00|01|F2|8F|BD|C6|98 11 Span&lt;byte&gt;[0] offset by size_t 0x|00|00|01|F2|8F|BD|BF|38 999 Span&lt;int&gt; [0] after GC 0x|00|00|01|F2|8F|BD|BF|38 999 Span&lt;byte&gt;[0] after GC [ 999, 123, 11, -100 ] [ 231, 3, 0, 0, 123, 0, 0, 0, 11, 0, 0, 0, 156, 255, 255, 255 ]</code> </pre> <br><p>  Semuanya bekerja, dan itu bekerja dengan <em>stabil</em> , sejauh yang saya bisa lihat.  Setelah pemadatan, kedua spanyol mengubah penunjuknya.  Hebat!  Tetapi bagaimana sekarang membuatnya bekerja dalam proyek warisan? </p><br><h1 id="jit-intrinsic">  Jit intrinsik </h1><br><p>  Saya benar-benar lupa bahwa dukungan untuk bentang diimplementasikan dalam <code>netcore</code> melalui <a href="">intrinsik</a> .  Dengan kata lain, <code>netcore</code> dapat membuat pointer internal bahkan ke fragmen array dan memperbarui tautan dengan benar ketika <code>GC</code> memindahkannya.  Dalam <code>netframework</code> , implementasi <code>nuget</code> dari span adalah penopang.  Faktanya, kami memiliki dua spen yang berbeda: satu dibuat dari array dan melacak tautannya, yang kedua dari pointer dan tidak tahu apa yang ditunjukkannya.  Setelah memindahkan array asli, pointer span terus menunjuk ke tempat pointer melewati konstruktornya menunjuk.  Sebagai perbandingan, ini adalah <em>contoh</em> implementasi span di <code>netcore</code> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Span&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ByReference&lt;T&gt; _pointer; <span class="hljs-comment"><span class="hljs-comment">//  -   private readonly int _length; }</span></span></code> </pre> <br><p>  dan di <code>netframework</code> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Span&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Pinnable&lt;T&gt; _pinnable; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IntPtr _byteOffset; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _length; }</code> </pre> <br><p>  <code>_pinnable</code> berisi referensi ke array, jika seseorang dilewatkan ke konstruktor, <code>_byteOffset</code> berisi pergeseran (bahkan rentang seluruh array memiliki beberapa pergeseran non-nol terkait dengan cara array diwakili dalam memori, <em>mungkin</em> ).  Jika Anda melewatkan <code>void*</code> pointer ke konstruktor, itu hanya dikonversi ke absolut <code>_byteOffset</code> .  Rentang akan dipaku erat ke area memori, dan semua metode contoh penuh dengan kondisi seperti <code>if(_pinnable is null) {/*    */} else {/*    _pinnable */}</code> .  Apa yang harus dilakukan dalam situasi seperti itu? </p><br><h1 id="kak-delat-ne-stoit-no-ya-vse-zhe-sdelal">  Bagaimana melakukannya tidak sepadan, tetapi saya masih melakukannya </h1><br><p>  Bagian ini dikhususkan untuk berbagai implementasi yang didukung oleh <code>netframework</code> , yang memungkinkan <code>netframework</code> <code>Span&lt;T&gt; -&gt; Span&lt;U&gt;</code> , menjaga semua tautan yang diperlukan. <br>  <strong>Saya memperingatkan Anda: ini adalah zona pemrograman abnormal dengan kemungkinan kesalahan mendasar dan Perilaku Tidak Terdefinisi pada akhirnya</strong> </p><br><h2 id="metod-1-naivnyy">  Metode 1: Naif </h2><br><p>  Seperti yang ditunjukkan contoh, konversi pointer tidak akan memberikan hasil yang diinginkan pada <code>netframework</code> .  Kami membutuhkan nilai <code>_pinnable</code> .  Oke, kami akan mengungkap refleksi dengan menarik keluar bidang pribadi (sangat buruk dan tidak selalu mungkin), kami akan menuliskannya di spen baru, kami akan senang.  Hanya ada satu masalah <em>kecil</em> : spen adalah sebuah <code>ref struct</code> , itu tidak bisa menjadi argumen umum, juga tidak dapat dikemas menjadi <code>object</code> .  Metode refleksi standar akan membutuhkan, dengan satu atau lain cara, untuk mendorong rentang ke tipe referensi.  Saya tidak menemukan cara sederhana (bahkan mempertimbangkan refleksi di bidang pribadi). </p><br><h2 id="metod-2-we-need-to-go-deeper">  Metode 2: Kita perlu lebih dalam </h2><br><p>  Semuanya telah dilakukan sebelum saya ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">[1]</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">[2]</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">[3]</a> ).  Spen adalah struktur, terlepas dari <code>T</code> tiga bidang menempati jumlah memori <em>yang sama</em> ( <em>pada arsitektur yang sama</em> ).  Bagaimana jika <code>[FieldOffset(0)]</code> ?  Tidak lebih cepat dikatakan daripada dilakukan. </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Explicit)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Exchange&lt;T, U&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> U : unmanaged { [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;T&gt; Span_1; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;U&gt; Span_2; }</code> </pre> <br><p>  Tetapi ketika Anda memulai program (atau lebih tepatnya, ketika mencoba menggunakan tipe), <code>TypeLoadException</code> bertemu dengan <code>TypeLoadException</code> - generik tidak boleh <code>LayoutKind.Explicit</code> .  Oke, itu tidak masalah, ayo jalan yang sulit: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Explicit)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Exchange { [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; ByteSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">sbyte</span></span>&gt; SByteSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">ushort</span></span>&gt; UShortSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">short</span></span>&gt; ShortSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>&gt; UIntSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; IntSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span>&gt; ULongSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>&gt; LongSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; FloatSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; DoubleSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; CharSpan; }</code> </pre> <br><p>  Sekarang Anda bisa melakukan ini: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Span&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">As2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Span&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; span</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> exchange = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exchange() { IntSpan = span }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> exchange.ByteSpan; }</code> </pre> <br><p>  Metode ini bekerja hanya dengan satu masalah - bidang <code>_length</code> disalin sebagaimana <code>_length</code> , jadi ketika casting <code>int</code> -&gt; <code>byte</code> rentang byte 4 kali lebih kecil dari array nyata. <br>  Tidak masalah: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Sequential)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Raw { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Pinnable; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IntPtr Pointer; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Length; } [StructLayout(LayoutKind.Explicit)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Exchange { <span class="hljs-comment"><span class="hljs-comment">/* */</span></span> [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Raw RawView; }</code> </pre> <br><p>  Sekarang melalui <code>RawView</code> Anda dapat mengakses setiap bidang rentang individual. </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Span&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">As2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Span&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; span</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> exchange = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exchange() { IntSpan = span }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> exchange2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exchange() { RawView = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Raw() { Pinnable = exchange.RawView.Pinnable, Pointer = exchange.RawView.Pointer, Length = exchange.RawView.Length * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; / <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> exchange2.ByteSpan; }</code> </pre> <br><p>  Dan itu berfungsi <strong>sebagaimana mestinya</strong> , jika Anda mengabaikan penggunaan trik kotor.  Minus - versi generik dari konverter tidak dapat dibuat, Anda harus puas dengan tipe yang telah ditentukan. </p><br><h2 id="metod-3-bezumnyy">  Metode 3: Gila </h2><br><p>  Seperti programmer normal, saya suka mengotomatiskan hal-hal.  Kebutuhan untuk menulis konverter untuk setiap pasangan jenis yang tidak <code>unmanaged</code> tidak menyenangkan saya.  Solusi apa yang bisa ditawarkan?  Itu benar, dapatkan <code>CLR</code> untuk menulis kode <em>untuk Anda</em> . </p><br><p>  Bagaimana cara mencapai ini?  Ada berbagai cara, ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> .  Singkatnya, prosesnya terlihat seperti ini: <br>  Buat build builder -&gt; create builder modul -&gt; build a type -&gt; {Fields, Methods, etc.} -&gt; pada output kita mendapatkan instance <code>Type</code> . <br>  Untuk memahami persis seperti apa bentuknya (ini adalah <code>ref struct</code> ), kami menggunakan alat apa pun dari jenis <code>ildasm</code> .  Dalam kasus saya, itu <strong>dotPeek</strong> . <br>  Membuat pembuat tipe terlihat seperti ini: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> typeBuilder = _mBuilder.DefineType(<span class="hljs-string"><span class="hljs-string">$"Generated_</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">typeof</span></span></span></span><span class="hljs-string"><span class="hljs-subst">(T).Name}</span></span></span><span class="hljs-string">"</span></span>, TypeAttributes.Public | TypeAttributes.Sealed | TypeAttributes.ExplicitLayout <span class="hljs-comment"><span class="hljs-comment">// &lt;-    | TypeAttributes.AnsiClass | TypeAttributes.BeforeFieldInit, typeof(ValueType));</span></span></code> </pre> <br><p>  Sekarang bidangnya.  Karena kita tidak dapat secara langsung menyalin <code>Span&lt;T&gt;</code> ke <code>Span&lt;U&gt;</code> karena perbedaan panjangnya, kita perlu membuat dua jenis masing-masing pemain </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Explicit)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Generated_Int32 { [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;Int32&gt; Span; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Raw Raw; }</code> </pre> <br><p>  Di sini, <code>Raw</code> kita dapat mendeklarasikan dengan tangan kita dan menggunakan kembali.  Jangan lupa tentang <code>IsByRefLikeAttribute</code> .  Dengan bidang, semuanya sederhana: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> spanField = typeBuilder.DefineField(<span class="hljs-string"><span class="hljs-string">"Span"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Span&lt;T&gt;), FieldAttributes.Private); spanField.SetOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rawField = typeBuilder.DefineField(<span class="hljs-string"><span class="hljs-string">"Raw"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Raw), FieldAttributes.Private); rawField.SetOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  Itu saja, tipe paling sederhana sudah siap.  Sekarang cache modul assembly.  Jenis khusus di-cache, misalnya, dalam kamus ( <code>T -&gt; Generated_{nameof(T)}</code> ).  Kami membuat pembungkus yang, menurut dua jenis <code>TOut</code> dan <code>TOut</code> menghasilkan dua jenis pembantu dan melakukan operasi yang diperlukan pada bentang.  Ada satu tapi.  Seperti dalam kasus refleksi, hampir tidak mungkin untuk menggunakannya pada bentang (atau pada <code>ref struct</code> lainnya).  <em>Atau saya tidak menemukan solusi yang sederhana</em> .  Bagaimana menjadi? </p><br><h2 id="delegates-to-the-rescue">  Delegasi untuk menyelamatkan </h2><br><p>  Metode refleksi biasanya terlihat seperti ini: </p><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Invoke</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MethodInfo mi, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] otherArgs</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br><p>  Mereka tidak membawa informasi tentang jenis, jadi jika tinju (= kemasan) dapat Anda terima, tidak ada masalah. <br>  Dalam kasus kami, <code>@this</code> dan <code>otherArgs</code> harus mengandung <code>ref struct</code> , yang saya tidak bisa menyiasati. <br>  Namun, ada cara yang lebih sederhana.  Mari kita bayangkan bahwa suatu tipe memiliki metode pengambil dan penyetel (bukan properti, tetapi metode sederhana yang dibuat secara manual). <br>  Sebagai contoh: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Generated_Int32.SetSpan(Span&lt;Int32&gt; span) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Span = span;</code> </pre> <br><p>  Selain metode, kita dapat mendeklarasikan tipe delegasi (secara eksplisit dalam kode): </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SpanSetterDelegate&lt;T&gt;(Span&lt;T&gt; span) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged;</code> </pre> <br><p>  Kita harus melakukan ini karena tindakan standar harus memiliki tanda tangan <code>Action&lt;Span&lt;T&gt;&gt;</code> , tetapi adegan tidak dapat digunakan sebagai argumen umum.  <code>SpanSetterDelegate</code> , bagaimanapun, adalah delegasi yang benar-benar valid. <br>  Buat delegasi yang diperlukan.  Untuk melakukan ini, lakukan manipulasi standar: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mi = type.GetMethod(<span class="hljs-string"><span class="hljs-string">"Method_Name"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ,    public &amp; instance var spanSetter = (SpanSetterDelegate&lt;T&gt;) mi.CreateDelegate(typeof(SpanSetterDelegate&lt;T&gt;), @this);</span></span></code> </pre> <br><p>  Sekarang <code>spanSetter</code> dapat digunakan sebagai, misalnya, <code>spanSetter(Span&lt;T&gt;.Empty);</code>  .  Adapun <code>@this</code> <sup>2</sup> , ini adalah turunan dari tipe dinamis kami, dibuat, tentu saja, melalui <code>Activator.CreateInstance(type)</code> , karena struktur memiliki konstruktor default tanpa argumen. </p><br><p>  Jadi, perbatasan terakhir - kita perlu secara dinamis menghasilkan metode. </p><br><p>  <sup>2</sup> Anda mungkin melihat ada sesuatu yang salah di sini - <code>Activator.CreateInstance()</code> mengemas instance <code>ref struct</code> .  Lihat akhir bagian selanjutnya. </p><br><h2 id="znakomtes-reflectionemit">  Temui <code>Reflection.Emit</code> </h2><br><p>  Saya pikir metode dapat dihasilkan menggunakan <code>Expression</code> , sebagai  tubuh getter / setter sepele kami terdiri dari beberapa ekspresi.  Saya memilih pendekatan yang berbeda dan lebih langsung. </p><br><p>  Jika Anda melihat kode <strong>IL</strong> dari pengambil yang sepele, Anda dapat melihat sesuatu seperti ( <code>Debug</code> , <code>X86</code> , <code>netframework4.8</code> ) </p><br><pre> <code class="plaintext hljs">nop ldarg.0 ldfld /* - */ stloc.0 br.s /*  */ ldloc.0 ret</code> </pre> <br><p>  Ada banyak tempat untuk berhenti dan debug. <br>  Dalam versi rilis, hanya yang paling penting yang tersisa: </p><br><pre> <code class="plaintext hljs">ldarg.0 ldfld /* - */ ret</code> </pre> <br><p>  Argumen nol metode instance adalah ... <code>this</code> .  Jadi, yang berikut ini ditulis dalam <strong>IL</strong> : <br>  1) Unduh <code>this</code> <br>  2) Masukkan nilai bidang <br>  3) Bawa kembali </p><br><p>  Hanya ya?  <code>Reflection.Emit</code> memiliki kelebihan khusus yang dibutuhkan, selain kode op, juga parameter deskriptor bidang.  Sama seperti yang kami terima sebelumnya, misalnya <code>spanField</code> . </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getSpan = type.DefineMethod(<span class="hljs-string"><span class="hljs-string">"GetSpan"</span></span>, MethodAttributes.Public | MethodAttributes.HideBySig, CallingConventions.Standard, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Span&lt;T&gt;), Array.Empty&lt;Type&gt;()); gen = getSpan.GetILGenerator(); gen.Emit(OpCodes.Ldarg_0); gen.Emit(OpCodes.Ldfld, spanField); gen.Emit(OpCodes.Ret);</code> </pre> <br><p>  Untuk penyetel, ini sedikit lebih rumit, Anda perlu memuat ini di stack, memuat argumen pertama dari fungsi, lalu memanggil instruksi tulis di bidang dan tidak mengembalikan apa pun: </p><br><pre> <code class="cs hljs">ldarg<span class="hljs-number"><span class="hljs-number">.0</span></span> ldarg<span class="hljs-number"><span class="hljs-number">.1</span></span> stfld <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> ret</code> </pre> <br><p>  Setelah melakukan prosedur ini untuk bidang <code>Raw</code> , mendeklarasikan delegasi yang diperlukan (atau menggunakan yang standar), kami mendapatkan tipe dinamis dan empat metode pengakses dari mana delegasi generik yang benar dihasilkan. </p><br><p>  Kami menulis kelas pembungkus yang, menggunakan dua parameter generik ( <code>TOut</code> , <code>TOut</code> ), menerima instance tipe <code>Type</code> yang mereferensikan tipe dinamis (cache) yang sesuai, setelah itu ia membuat satu objek dari setiap tipe dan menghasilkan empat delegasi generik, yaitu </p><br><ol><li>  <code>void SetSpan(Span&lt;TIn&gt; span)</code> untuk menulis rentang sumber ke struktur </li><li>  <code>Raw GetRaw()</code> untuk membaca konten span sebagai struktur <code>Raw</code> </li><li>  <code>void SetRaw(Raw raw)</code> untuk menulis struktur <code>Raw</code> dimodifikasi ke objek kedua </li><li>  <code>Span&lt;TOut&gt; GetSpan()</code> untuk mengembalikan rentang jenis yang diinginkan dengan bidang yang ditetapkan dan dihitung ulang dengan benar. </li></ol><br><p>  Menariknya, instance tipe dinamis perlu dibuat sekali.  Saat membuat delegasi, referensi ke objek-objek ini dilewatkan sebagai parameter <code>@this</code> .  <strong>Ini adalah pelanggaran aturan.</strong>  <strong><code>Activator.CreateInstance</code> mengembalikan <code>object</code> .</strong>  <strong>Rupanya ini disebabkan oleh fakta bahwa tipe dinamis itu sendiri tidak menghasilkan <code>ref</code></strong> <code>type.IsByRef</code> <strong>(</strong> <code>type.IsByRef</code> <s>Like</s> <code>== false</code> <strong>), tetapi dimungkinkan untuk membuat bidang <code>ref</code> like.</strong>  <strong>Rupanya, pembatasan semacam itu ada dalam bahasa itu, tetapi <code>CLR</code> mencernanya.</strong>  <strong>Mungkin di sinilah lutut akan ditembak jika digunakan tidak standar.</strong>  <sup>3</sup> </p><br><p>  Jadi, kita mendapatkan instance dari tipe generik yang berisi empat delegasi dan dua referensi implisit ke instance kelas dinamis.  Delegasi dan struktur dapat digunakan kembali saat melakukan kasta yang sama dalam satu baris.  Untuk meningkatkan kinerja, kami cache lagi (sudah konverter tipe) untuk sepasang <code>(TIn, TOut) -&gt; Generator&lt;TIn, TOut&gt;</code> . </p><br><h2 id="shtrih-posledniy-privodim-tipy-spantin---spantout">  Stroke adalah yang terakhir: kami berikan tipe, <code>Span&lt;TIn&gt; -&gt; Span&lt;TOut&gt;</code> </h2><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Span&lt;TOut&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Cast</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Span&lt;TIn&gt; span</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      if (span.IsEmpty) return Span&lt;TOut&gt;.Empty; // Caller   ,       if (span.Length * Unsafe.SizeOf&lt;TIn&gt;() % Unsafe.SizeOf&lt;TOut&gt;() != 0) throw new InvalidOperationException(); //      // Span&lt;TIn&gt; _input.Span = span; _spanSetter(span); //  Raw // Raw raw = _input.Raw; var raw = _rawGetter(); var newRaw = new Raw() { Pinnable = raw.Pinnable, //    Pinnable Pointer = raw.Pointer, //   Length = raw.Length * Unsafe.SizeOf&lt;TIn&gt;() / Unsafe.SizeOf&lt;TOut&gt;() //   }; //   Raw    // Raw _output.Raw = newRaw; _rawSetter(newRaw); //     // Span&lt;TOut&gt; _output.Span return _spanGetter(); }</span></span></code> </pre> <br><h1 id="vyvod">  Kesimpulan </h1><br><p>  Terkadang - demi minat olahraga - Anda dapat melewati beberapa batasan bahasa dan menerapkan fungsi yang tidak standar.  Tentu saja, dengan risiko dan risiko Anda sendiri.  Perlu dicatat bahwa metode dinamis memungkinkan Anda untuk sepenuhnya meninggalkan pointer dan konteks yang <code>unsafe / fixed</code> , yang bisa menjadi bonus.  Kelemahan yang jelas adalah perlunya refleksi dan generasi jenis. </p><br><h1 id="dlya-teh-kto-dochital-do-konca">  Bagi yang sudah membaca sampai akhir. </h1><br><div class="spoiler">  <b class="spoiler_title">Hasil Benchmark Naif</b> <div class="spoiler_text"><p>  Dan seberapa cepat semuanya? <br>  Saya membandingkan kecepatan kasta dalam skenario bodoh yang tidak mencerminkan penggunaan aktual / potensial kasta dan rentang tersebut, tetapi setidaknya memberikan gambaran tentang kecepatan. </p><br><ol><li> <code>Cast_Explicit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menggunakan konversi melalui tipe yang dinyatakan secara eksplisit, seperti dalam </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode 2</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Setiap kasta membutuhkan alokasi dua struktur kecil dan akses ke ladang;</font></font></li><li> <code>Cast_IL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengimplementasikan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode 3</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tetapi setiap kali membuat instance lagi </font></font><code>Generator&lt;TIn, TOut&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang mengarah ke pencarian konstan dalam kamus, setelah pass pertama menghasilkan semua jenis;</font></font></li><li> <code>Cast_IL_Cached</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cache instance konverter langsung </font></font><code>Generator&lt;TIn, TOut&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, itulah sebabnya ternyata menjadi lebih cepat rata-rata, karena </font><font style="vertical-align: inherit;">seluruh kasta bermuara pada panggilan empat delegasi;</font></font></li><li> <code>Buffer</code>   ,       ,     .     . </li></ol><br><p>    —         <code>int[N]</code>   <code>N/2</code>   . </p><br><p>   ,        ,    .              ,             .    ,          ,            .  ,  <em></em> <em></em> <em>   </em>     <code>unmanaged</code>   <em>  </em> . </p><br><pre> <code class="plaintext hljs">BenchmarkDotNet=v0.11.5, OS=Windows 10.0.18362 Intel Core i7-2700K CPU 3.50GHz (Sandy Bridge), 1 CPU, 8 logical and 4 physical cores [Host] : .NET Framework 4.7.2 (CLR 4.0.30319.42000), 32bit LegacyJIT-v4.8.3815.0 Clr : .NET Framework 4.7.2 (CLR 4.0.30319.42000), 32bit LegacyJIT-v4.8.3815.0 Job=Clr Runtime=Clr InvocationCount=1 UnrollFactor=1</code> </pre><br><div class="scrollable-table"><table><thead><tr><th> Method </th><th> N </th><th> Mean </th><th> Error </th><th> StdDev </th><th> Median </th><th> Ratio </th><th> RatioSD </th></tr></thead><tbody><tr><td> <strong>Cast_Explicit</strong> </td><td> <strong>100</strong> </td><td> <strong>362.2 ns</strong> </td><td> <strong>18.0967 ns</strong> </td><td> <strong>52.7888 ns</strong> </td><td> <strong>400.0 ns</strong> </td><td> <strong>1.00</strong> </td><td> <strong>0.00</strong> </td></tr><tr><td> Cast_IL </td><td>  100 </td><td> 1,237.9 ns </td><td> 28.5954 ns </td><td> 67.4027 ns </td><td> 1,200.0 ns </td><td> 3.47 </td><td> 0.51 </td></tr><tr><td> Cast_IL_Cached </td><td>  100 </td><td> 522.8 ns </td><td> 25.2640 ns </td><td> 71.2576 ns </td><td> 500.0 ns </td><td> 1.46 </td><td> 0.27 </td></tr><tr><td> Buffer </td><td>  100 </td><td> 300.0 ns </td><td> 0.0000 ns </td><td> 0.0000 ns </td><td> 300.0 ns </td><td> 0.78 </td><td> 0.11 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td> <strong>Cast_Explicit</strong> </td><td>  <strong>1000</strong> </td><td> <strong>2,628.6 ns</strong> </td><td> <strong>54.0688 ns</strong> </td><td> <strong>64.3650 ns</strong> </td><td> <strong>2,600.0 ns</strong> </td><td> <strong>1.00</strong> </td><td> <strong>0.00</strong> </td></tr><tr><td> Cast_IL </td><td> 1000 </td><td> 3,216.7 ns </td><td> 49.8568 ns </td><td> 38.9249 ns </td><td> 3,200.0 ns </td><td> 1.21 </td><td> 0.03 </td></tr><tr><td> Cast_IL_Cached </td><td> 1000 </td><td> 2,484.6 ns </td><td> 44.9717 ns </td><td> 37.5534 ns </td><td> 2,500.0 ns </td><td> 0.94 </td><td> 0.02 </td></tr><tr><td> Buffer </td><td> 1000 </td><td> 2,055.6 ns </td><td> 43.9695 ns </td><td> 73.4631 ns </td><td> 2,000.0 ns </td><td> 0.78 </td><td> 0.03 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td> <strong>Cast_Explicit</strong> </td><td> <strong>1000000</strong> </td><td> <strong>2,515,157.1 ns</strong> </td><td> <strong>11,809.8538 ns</strong> </td><td> <strong>10,469.1278 ns</strong> </td><td> <strong>2,516,050.0 ns</strong> </td><td> <strong>1.00</strong> </td><td> <strong>0.00</strong> </td></tr><tr><td> Cast_IL </td><td>  1.000.000 </td><td> 2,263,826.7 ns </td><td> 23,724.4930 ns </td><td> 22,191.9054 ns </td><td> 2,262,000.0 ns </td><td> 0.90 </td><td> 0.01 </td></tr><tr><td> Cast_IL_Cached </td><td>  1.000.000 </td><td> 2,265,186.7 ns </td><td> 19,505.5913 ns </td><td> 18,245.5422 ns </td><td> 2,266,300.0 ns </td><td> 0.90 </td><td> 0.01 </td></tr><tr><td> Buffer </td><td>  1.000.000 </td><td> 1,959,547.8 ns </td><td> 39,175.7435 ns </td><td> 49,544.7719 ns </td><td> 1,959,200.0 ns </td><td> 0.78 </td><td> 0.02 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td> <strong>Cast_Explicit</strong> </td><td> <strong>100000000</strong> </td><td> <strong>255,751,392.9 ns</strong> </td><td> <strong>2,595,107.7066 ns</strong> </td><td> <strong>2,300,495.3873 ns</strong> </td><td> <strong>255,298,950.0 ns</strong> </td><td> <strong>1.00</strong> </td><td> <strong>0.00</strong> </td></tr><tr><td> Cast_IL </td><td> 100000000 </td><td> 228,709,457.1 ns </td><td> 527,430.9293 ns </td><td> 467,553.7809 ns </td><td> 228,864,100.0 ns </td><td> 0.89 </td><td> 0.01 </td></tr><tr><td> Cast_IL_Cached </td><td> 100000000 </td><td> 227,966,553.8 ns </td><td> 355,027.3545 ns </td><td> 296,463.9203 ns </td><td> 227,903,600.0 ns </td><td> 0.89 </td><td> 0.01 </td></tr><tr><td> Buffer </td><td> 100000000 </td><td> 213,216,776.9 ns </td><td> 1,198,565.1142 ns </td><td> 1,000,856.1536 ns </td><td> 213,517,800.0 ns </td><td> 0.83 </td><td> 0.01 </td></tr></tbody></table></div></div></div><br><div class="spoiler"> <b class="spoiler_title">Acknowledgements</b> <div class="spoiler_text"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>JetBrains</strong></a> (      :-))   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>R#</strong></a>    <strong>VS</strong>  standalone- <strong>dotPeek</strong> ,     .  <code>BenchmarkDotNet</code>  BenchmarkDotNet, youtube- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>NDC Conferences</strong></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>DotNext</strong></a>    ,  ,         . </p></div></div><br><h1 id="ps">  PS </h1><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><p> <sup>3</sup>         ,      <code>ref</code> ,      ,   .  <s></s>   (   )   .    <code>ref</code> structs,        </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Raw Generated_Int32.GetRaw(Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; span) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> inst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Generated_Int32() { Span = span }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inst.Raw; }</code> </pre> <br><p>     ,     <code>Reflection.Emit</code> .      ,   <em></em>  <code>ILGenerator.DeclareLocal</code> .     </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; Generated_Int32.GetSpan(Raw raw);</code> </pre> <br><p>    </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> Raw GetRaw&lt;T&gt;(Span&lt;T&gt; span) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged; <span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> Span&lt;T&gt; GetSpan&lt;T&gt;(Raw raw) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged;</code> </pre> <br><p> , <em> </em> ,       <code>ref</code> — .  Karena     ,      </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getter = type.GetMethod(<span class="hljs-string"><span class="hljs-string">@"GetRaw"</span></span>, BindingFlags.Static | BindingFlags.Public).CreateDelegate(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(GetRaw&lt;T&gt;), <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> GetRaw&lt;T&gt;;</code> </pre> <br><p>   —  </p><br><pre> <code class="cs hljs">Raw raw = getter(Span&lt;TIn&gt;.Empty); Raw newRaw = convert(raw); Span&lt;TOut&gt; = setter(newRaw);</code> </pre> </div></div><br><p> <em>UPD01:   </em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id465077/">https://habr.com/ru/post/id465077/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id465063/index.html">10 kesalahan paling umum saat bekerja dengan platform Spring. Bagian 2</a></li>
<li><a href="../id465069/index.html">Baru di Hadoop: Kenali Berbagai Format File di Hadoop</a></li>
<li><a href="../id465071/index.html">TechTrain 2019 IT festival: bagaimana JUG.ru, JUGNsk dan JUG.MSK berpartisipasi di dalamnya</a></li>
<li><a href="../id465073/index.html">Jangan muncul! Transisi Interruptable di iOS</a></li>
<li><a href="../id465075/index.html">Di taksi pengemudi kereta</a></li>
<li><a href="../id465081/index.html">CLRium # 6: Concurrency & Parallelism. Mempelajari keajaiban paralelisasi tugas</a></li>
<li><a href="../id465083/index.html">Pengawasan pintu yang waspada</a></li>
<li><a href="../id465085/index.html">Daftar Periksa Anti-Phishing</a></li>
<li><a href="../id465087/index.html">Bagaimana NASA menyewa Snoopy dan mengambil pakaian Barbie</a></li>
<li><a href="../id465089/index.html">Bagaimana peluang dapat membantu ahli matematika</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>