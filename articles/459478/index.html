<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçüî¨ üìå üö§ Mi experiencia en la creaci√≥n de una aplicaci√≥n multiproceso para trabajar con copias de seguridad üòõ ‚úçüèª üëÅÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este momento, no sorprender√° a nadie con aplicaciones multiproceso, pero creo que en este art√≠culo puede encontrar algunas ideas interesantes. Mi e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mi experiencia en la creaci√≥n de una aplicaci√≥n multiproceso para trabajar con copias de seguridad</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459478/"><p>  En este momento, no sorprender√° a nadie con aplicaciones multiproceso, pero creo que en este art√≠culo puede encontrar algunas ideas interesantes.  Mi estudio de Java comenz√≥ con este proyecto, as√≠ que tal vez en algunos lugares me equivocar√© mucho o construir√© una bicicleta grande, pero espero que alguien est√© interesado en la experiencia de un principiante en Java.  Dar√© varias caracter√≠sticas de la aplicaci√≥n: </p><br><ul><li>  Funciona con copias de seguridad exclusivamente en la memoria, independientemente del tama√±o de la copia de seguridad. </li><li>  No carga la copia de seguridad completa en la memoria </li><li>  Las operaciones de copia de seguridad / restauraci√≥n pueden cancelarse </li></ul><br><p>  Bajo el corte se considerar√° la arquitectura de la aplicaci√≥n, as√≠ como los principales problemas encontrados y su soluci√≥n. </p><a name="habracut"></a><br><h2 id="obzor-prilozheniya">  Resumen de la aplicaci√≥n </h2><br><p>  La comunicaci√≥n con la aplicaci√≥n se realiza a trav√©s de la interfaz de usuario web, pero en el futuro ser√° posible agregar una API REST si es necesario. </p><br><p>  La aplicaci√≥n puede: </p><br><ol><li>  Cree copias de seguridad y c√°rguelas en uno o m√°s almacenes </li><li>  Restaurar copias de seguridad carg√°ndolas desde el almacenamiento </li><li>  Eliminar copias de seguridad de todos los almacenes </li><li>  Crear copias de seguridad peri√≥dicamente </li></ol><br><p>  Repositorios actualmente soportados: </p><br><ul><li>  Sistema de archivos local (no compatible con Docker) </li><li>  Dropbox </li></ul><br><p>  Bases de datos compatibles actualmente: </p><br><ul><li>  PostgreSQL </li></ul><br><p>  De una aplicaci√≥n especial, puedo notar: </p><br><ol><li>  Corregir el trabajo en una configuraci√≥n de cl√∫ster </li><li>  Una copia de seguridad nunca se carga completamente en la memoria, independientemente del tama√±o de la copia de seguridad.  El sistema de archivos para el almacenamiento de respaldo temporal tampoco est√° involucrado.  Tanto la creaci√≥n de una copia de seguridad como la restauraci√≥n, y por lo tanto la carga / descarga de una copia de seguridad, se producen exclusivamente en la memoria. </li><li>  Multiplataforma: funciona tanto en Windows como en Linux. </li><li>  Podemos monitorear todas las tareas en ejecuci√≥n y cancelarlas si es necesario. </li></ol><br><p>  A continuaci√≥n se muestran capturas de pantalla de la interfaz de usuario web que describen claramente las caracter√≠sticas de la aplicaci√≥n. </p><br><div class="spoiler">  <b class="spoiler_title">Gesti√≥n de almacenamiento</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/vl/qg/n5/vlqgn5f58ub5jhxixeeg2uq-oa8.png" title="Agregar almacenamiento"></a> <br> <a href=""><img src="https://habrastorage.org/webt/oj/o5/uj/ojo5uj_raxkwd1btsjrktiowifo.png" title="Lista de almacenamiento"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Gesti√≥n de bases de datos</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/wn/6p/bk/wn6pbkcqg4qu_9btgrvnqm3l7x0.png" title="Agregar una base de datos"></a> <br> <a href=""><img src="https://habrastorage.org/webt/wu/9a/4k/wu9a4ky7icuiyqdxeiii9xbu5d8.png" title="Listado de bases de datos"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Creaci√≥n de respaldo</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/1d/zb/6s/1dzb6scvtua5v3m_3l11lch4rgm.png" title="Creaci√≥n de respaldo"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Recuperaci√≥n de copia de seguridad</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/gj/9f/w0/gj9fw0onqw7f0lf7ycw05aphinc.png" title="Recuperaci√≥n de copia de seguridad"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Administrar copias de seguridad creadas</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/sy/jz/y6/syjzy68wqxgi8smgq74giqstgu0.png" title="Lista de copias de seguridad creadas"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Copias de seguridad peri√≥dicas</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/hk/pw/tg/hkpwtg3kf7c5ho3f7ae7_uos7v0.png" title="Crea una tarea peri√≥dica"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Realizar un seguimiento de las tareas en ejecuci√≥n</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/al/dt/su/aldtsuel4amtjlvbbbusccxddh0.png" title="Lista de tareas en ejecuci√≥n"></a> </p></div></div><br><hr><br><h2 id="arhitektura">  Arquitectura </h2><br><p>  El trabajo principal tendr√° lugar en 3 servicios: <em>base de datos</em> , <em>procesador</em> , <em>almacenamiento</em> , y los conectaremos juntos utilizando el <em>concepto de tareas</em> .  Sobre todo esto m√°s all√°. </p><br><h3 id="databasebackup">  Copia de seguridad de la base de datos </h3><br><p>  Este servicio es responsable de crear y restaurar copias de seguridad de texto sin formato. </p><br><p>  Interfaz de servicio: </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DatabaseBackup</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">InputStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createBackup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DatabaseSettings databaseSettings, Integer id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restoreBackup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputStream in, DatabaseSettings databaseSettings, Integer id)</span></span></span></span>; }</code> </pre> <br><p>  Ambos m√©todos de interfaz operan en instancias de <strong>InputStream</strong> , ya que necesitamos que la copia de seguridad completa no se cargue en la memoria, lo que significa que la copia de seguridad debe leerse / escribirse en modo de transmisi√≥n.  La entidad <em>DatabaseSettings</em> se crea previamente desde la interfaz de usuario web y almacena las diversas configuraciones necesarias para acceder a la base de datos.  ¬øCu√°l es este par√°metro, <code>id</code> ?, Se explicar√° un poco m√°s. </p><br><p>  Los requisitos de servicio son los siguientes: </p><br><ol><li>  Ambos m√©todos no deber√≠an leer la copia de seguridad completa en la memoria. </li><li>  El m√©todo <code>restoreBackup()</code> debe restaurar la copia de seguridad en una sola transacci√≥n, de modo que, en caso de error, no deje la base de datos en un estado inconsistente. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Implementaci√≥n para PostgreSQL (descripci√≥n del texto)</b> <div class="spoiler_text"><p>  Espec√≠ficamente, en la implementaci√≥n de PostgreSQL, el servicio se implementa de la siguiente manera: </p><br><ol><li>  <code>createBackup()</code> : se <em>crea</em> un proceso <em>pg_dump</em> que crear√° una copia de seguridad y la escribir√° en la secuencia de salida est√°ndar.  La secuencia de salida del proceso est√°ndar se devuelve desde el m√©todo (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://docs.oracle.com/javase/8/docs/api/java/lang/Process.html#getInputStream--</a> ).  Los flujos de E / S en el sistema se basan en un b√∫fer de cierto tama√±o, y cuando un proceso escribe en el flujo de salida, en realidad escribe en el b√∫fer en la memoria.  Lo m√°s importante aqu√≠ es que el hilo del proceso no escribir√° en el b√∫fer <em>lleno</em> hasta que este √∫ltimo haya sido le√≠do por el otro lado, lo que significa que el hilo estar√° bloqueado y la copia de seguridad no se cargar√° completamente en la memoria.  Es posible que haya encontrado una situaci√≥n en la que su programa Java se estanc√≥ mientras trabajaba con procesos debido al hecho de que no ley√≥ el stdout o stderr del proceso.  Es extremadamente importante monitorear esto, porque el proceso no puede continuar si est√° bloqueado en una llamada de bloqueo de E / S cuando se escribe en un b√∫fer completo y nadie lee este b√∫fer. </li><li>  <code>restoreBackup()</code> : se <em>crea</em> un proceso <em>psql</em> , la copia de seguridad se lee desde el <code>restoreBackup()</code> pasado al m√©todo y se escribe simult√°neamente en la secuencia de entrada est√°ndar psql (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://docs.oracle.com/javase/8/docs/api/java/lang/Process. html # getOutputStream--</a> ).  Esto funciona porque la copia de seguridad de PostgreSQL en texto plano es solo una colecci√≥n de comandos DDL y DML que son f√°ciles de entender psql. </li></ol><br><p>  Hay mucho c√≥digo, as√≠ que no lo dar√© aqu√≠, pero puedes verlo en GitHub usando el enlace al final del art√≠culo. </p></div></div><br><h3 id="processor">  Procesador </h3><br><p>  Este servicio es responsable del uso de procesadores y el reprocesamiento de copias de seguridad inversas.  Los procesadores se utilizan antes de descargar al almacenamiento o despu√©s de descargar del almacenamiento.  Ejemplo de procesador: compresor, cifrado. </p><br><p>  Interfaz de servicio: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Processor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">InputStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputStream in)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">InputStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deprocess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputStream in)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">ProcessorType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ProcessorType -  Enum,     int getPrecedence(); //   }</span></span></code> </pre> <br><p>  Cada procesador tiene prioridad: si se especifican varios procesadores, se aplicar√°n en orden descendente de prioridad.  Aplicando la funci√≥n inversa en el mismo orden en que se aplicaron los procesadores, obtenemos la copia de seguridad original. </p><br><h3 id="storage">  Almacenamiento </h3><br><p>  Este servicio es responsable de cargar y descargar una copia de seguridad, as√≠ como su eliminaci√≥n del almacenamiento.  Ejemplo de almacenamiento: Dropbox, sistema de archivos local. </p><br><p>  Interfaz de servicio: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Storage</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uploadBackup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputStream in, StorageSettings storageSettings, String backupName, Integer id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">InputStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBackup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StorageSettings storageSettings, String backupName, Integer id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deleteBackup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StorageSettings storageSettings, String backupName, Integer id)</span></span></span></span>; }</code> </pre> <br><p>  A cada copia de seguridad creada se le asigna un nombre √∫nico, por lo que podemos encontrarla en cualquiera de los almacenes en los que se descarg√≥.  La forma en que se presenta la copia de seguridad en el almacenamiento depende exclusivamente de la implementaci√≥n del servicio, pero al transferir el nombre de la copia de seguridad a una de las funciones, debemos esperar el comportamiento correcto.  La entidad <em>StorageSettings</em> se crea previamente desde la interfaz de usuario web y almacena la configuraci√≥n necesaria para acceder al almacenamiento. </p><br><hr><br><h3 id="koncepciya-taskov">  Concepto de tarea </h3><br><p>  Nos gustar√≠a poder rastrear el estado de nuestras tareas, manejar posibles errores dependiendo del progreso de la tarea y tambi√©n cancelar tareas.  Por lo tanto, continuaremos operando solo con tareas.  Cada tarea estar√° representada en la base de datos por un registro en la tabla y program√°ticamente por la instancia <strong>Future</strong> (ver Java <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Future</a> ).  Cada registro en la tabla est√° asociado con su propio futuro (adem√°s, si se est√°n ejecutando varios servidores, las instancias futuras pueden estar en la memoria de diferentes servidores). </p><br><p>  Vamos secuencialmente.  En primer lugar, necesitamos un servicio para iniciar tareas: crear, restaurar y eliminar copias de seguridad. </p><br><h4 id="zapusk-zadach">  Lanzamiento de tarea </h4><br><p>  <strong>Crear una copia de seguridad:</strong> </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startBackupTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Task.RunType runType, @NotNull List&lt;String&gt; storageSettingsNameList, @Nullable List&lt;ProcessorType&gt; processors, @NotNull DatabaseSettings databaseSettings)</span></span></span><span class="hljs-function"> </span></span>{ Objects.requireNonNull(runType); Objects.requireNonNull(storageSettingsNameList); Objects.requireNonNull(processors); Objects.requireNonNull(databaseSettings); BackupProperties backupProperties = backupPropertiesManager.initNewBackupProperties(storageSettingsNameList, processors, databaseSettings.getName()); Task task = tasksManager.initNewTask(Task.Type.CREATE_BACKUP, runType, backupProperties.getId()); Integer taskId = task.getId(); Future future = tasksStarterExecutorService.submit(() -&gt; { tasksManager.updateTaskState(taskId, Task.State.CREATING); logger.info(<span class="hljs-string"><span class="hljs-string">"Creating backup..."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream backupStream = databaseBackupManager.createBackup(databaseSettings, taskId)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.APPLYING_PROCESSORS); logger.info(<span class="hljs-string"><span class="hljs-string">"Applying processors on created backup. Processors: {}"</span></span>, processors); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream processedBackupStream = backupProcessorManager.process(backupStream, processors)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.UPLOADING); logger.info(<span class="hljs-string"><span class="hljs-string">"Uploading backup..."</span></span>); backupLoadManager.uploadBackup(processedBackupStream, backupProperties, taskId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.COMPLETED); logger.info(<span class="hljs-string"><span class="hljs-string">"Creating backup completed. Backup properties: {}"</span></span>, backupProperties); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException ex) { logger.error(<span class="hljs-string"><span class="hljs-string">"Error occurred while closing input stream of created backup"</span></span>, ex); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (RuntimeException ex) { logger.error(<span class="hljs-string"><span class="hljs-string">"Error occurred while creating backup. Backup properties: {}"</span></span>, backupProperties, ex); errorTasksManager.addErrorTask(taskId); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException ex) { tasksManager.setInterrupted(taskId); logger.error(<span class="hljs-string"><span class="hljs-string">"Backup creating task was interrupted. Task ID: {}"</span></span>, taskId); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { futures.remove(taskId); } }); futures.put(taskId, future); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> task; }</code> </pre> <br><p>  La creaci√≥n de una copia de seguridad pasa por 3 pasos principales en el siguiente orden: creaci√≥n de una copia de seguridad -&gt; aplicaci√≥n de procesadores -&gt; carga en almacenamiento.  En casi todos los m√©todos de servicio, reenviamos el ID de la tarea actual para que el servicio pueda informar un error de un hilo que funciona en segundo plano.  Sobre el manejo de errores, por qu√© se <em>interrumpe la excepci√≥n</em> aqu√≠ y qu√© sucede con un error despu√©s de recibir una <em>excepci√≥n RuntimeException</em> se discutir√° m√°s adelante. </p><br><p>  Y as√≠ es como ejecutaremos la tarea de crear una copia de seguridad: </p><br><pre> <code class="java hljs">tasksStarterService.startBackupTask(Task.RunType.USER, storageSettingsNameList, processors, databaseSettings);</code> </pre> <br><p>  El primer par√°metro que pasamos al iniciador de la tarea: el usuario o la tarea del servidor interno (un ejemplo de una tarea interna es una copia de seguridad peri√≥dica).  El conocimiento del iniciador de tareas nos permite mostrar en la interfaz de usuario web solo aquellas tareas iniciadas por el usuario.  Los par√°metros restantes son necesarios para crear una copia de seguridad directamente: una lista de almacenamientos, procesadores para usar, una base de datos cuyo volcado necesita crear. </p><br><p>  Al crear una copia de seguridad, tambi√©n se crea un registro en la base de datos llamada <strong>BackupProperties</strong> .  Esta entidad almacenar√° las propiedades de la copia de seguridad, como el nombre, los procesadores utilizados y la lista de repositorios en los que se descarg√≥ la copia de seguridad.  Adem√°s, para restaurar o eliminar la copia de seguridad, operaremos con esta entidad en particular. </p><br><p>  La tarea en la base de datos se almacena de la siguiente forma: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"backup_tasks"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Identifier of each backup task. Identifier is generated by PostgreSQL database after saving of entity. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(insertable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span>(strategy = GenerationType.IDENTITY) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer id; <span class="hljs-comment"><span class="hljs-comment">/** * Backup task type. * &lt;p&gt; * Type is set at the very start of any task and can't be changed. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> Type */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Enumerated</span></span>(EnumType.STRING) <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Type type; <span class="hljs-comment"><span class="hljs-comment">/** * Who initiated a task: user or server. * &lt;p&gt; * We need to know it to show on front only these tasks that was started by user. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> RunType */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Enumerated</span></span>(EnumType.STRING) <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> RunType runType; <span class="hljs-comment"><span class="hljs-comment">/** * Backup task state. * &lt;p&gt; * State is updated with every new step in task being executed. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> Task.State */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Enumerated</span></span>(EnumType.STRING) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> State state; <span class="hljs-comment"><span class="hljs-comment">/** * Whether task has been interrupted or not. * &lt;p&gt; * Default is {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@literal</span></span></span><span class="hljs-comment"> false}. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(insertable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> interrupted; <span class="hljs-comment"><span class="hljs-comment">/** * Identifier of {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> BackupProperties}. * &lt;p&gt; * We need to know backup ID to be able to handle occurred errors. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer backupPropertiesId; <span class="hljs-comment"><span class="hljs-comment">/** * Start time of the task. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> LocalDateTime date; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> RunType { USER, INTERNAL } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> State { PLANNED, CREATING, RESTORING, DELETING, APPLYING_PROCESSORS, APPLYING_DEPROCESSORS, DOWNLOADING, UPLOADING, COMPLETED, } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Type { CREATE_BACKUP { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"CREATE BACKUP"</span></span>; } }, RESTORE_BACKUP { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"RESTORE BACKUP"</span></span>; } }, DELETE_BACKUP { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"DELETE BACKUP"</span></span>; } } } <span class="hljs-comment"><span class="hljs-comment">// getters &amp; setters... }</span></span></code> </pre> <br><p>  Por lo tanto, puede describir el proceso de creaci√≥n de una copia de seguridad en forma de diagrama de la siguiente manera: <br><img src="https://habrastorage.org/webt/bm/um/cy/bmumcyhyapjg4ono73qo8kiquom.png" alt="  " title="Proceso de respaldo"></p><br><hr><br><p>  Otros tipos de tareas se inician por analog√≠a.  Para no saturar el art√≠culo con una gran cantidad de c√≥digo, para los curiosos les dar√© el c√≥digo para iniciar tareas para restaurar y eliminar copias de seguridad por separado en el spoiler. </p><br><div class="spoiler">  <b class="spoiler_title">Recuperaci√≥n de copia de seguridad</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startRestoreTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Task.RunType runType, @NotNull BackupProperties backupProperties, @NotNull String storageSettingsName, @NotNull DatabaseSettings databaseSettings)</span></span></span><span class="hljs-function"> </span></span>{ Objects.requireNonNull(runType); Objects.requireNonNull(backupProperties); Objects.requireNonNull(storageSettingsName); Objects.requireNonNull(databaseSettings); Task task = tasksManager.initNewTask(Task.Type.RESTORE_BACKUP, runType, backupProperties.getId()); Integer taskId = task.getId(); Future future = tasksStarterExecutorService.submit(() -&gt; { tasksManager.updateTaskState(taskId, Task.State.DOWNLOADING); logger.info(<span class="hljs-string"><span class="hljs-string">"Downloading backup..."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream downloadedBackup = backupLoadManager.downloadBackup(backupProperties.getBackupName(), storageSettingsName, taskId)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted() || downloadedBackup == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.APPLYING_DEPROCESSORS); logger.info(<span class="hljs-string"><span class="hljs-string">"Deprocessing backup..."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream deprocessedBackup = backupProcessorManager.deprocess(downloadedBackup, backupProperties.getProcessors())) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.RESTORING); logger.info(<span class="hljs-string"><span class="hljs-string">"Restoring backup..."</span></span>); databaseBackupManager.restoreBackup(deprocessedBackup, databaseSettings, taskId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.COMPLETED); logger.info(<span class="hljs-string"><span class="hljs-string">"Restoring backup completed. Backup properties: {}"</span></span>, backupProperties); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException ex) { logger.error(<span class="hljs-string"><span class="hljs-string">"Error occurred while closing input stream of downloaded backup"</span></span>, ex); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (RuntimeException ex) { logger.info(<span class="hljs-string"><span class="hljs-string">"Error occurred while restoring backup. Backup properties: {}"</span></span>, backupProperties, ex); errorTasksManager.addErrorTask(taskId); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException ex) { tasksManager.setInterrupted(taskId); logger.error(<span class="hljs-string"><span class="hljs-string">"Task was interrupted. Task ID: {}"</span></span>, taskId); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { futures.remove(taskId); } }); futures.put(taskId, future); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> task; }</code> </pre> <br><p>  La restauraci√≥n de una copia de seguridad pasa por 3 pasos principales en el siguiente orden: descargar una copia de seguridad del almacenamiento -&gt; usar deprocesadores para obtener la copia de seguridad de texto sin formato original -&gt; restaurar una copia de seguridad. </p><br><p>  Comience la recuperaci√≥n de la siguiente manera: </p><br><pre> <code class="java hljs">tasksStarterService.startRestoreTask(Task.RunType.USER, backupProperties, storageSettingsName, databaseSettings);</code> </pre> <br><p>  El proceso de recuperaci√≥n de la copia de seguridad en forma de diagrama: <br><img src="https://habrastorage.org/webt/hr/_m/bk/hr_mbkvfkszhyhj6ebi1q_wa1nc.png" alt="  " title="Proceso de recuperaci√≥n de respaldo"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Eliminar copia de seguridad</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startDeleteTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Task.RunType runType, @NotNull BackupProperties backupProperties)</span></span></span><span class="hljs-function"> </span></span>{ Objects.requireNonNull(runType); Objects.requireNonNull(backupProperties); Task task = tasksManager.initNewTask(Task.Type.DELETE_BACKUP, runType, backupProperties.getId()); Integer taskId = task.getId(); Future future = tasksStarterExecutorService.submit(() -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { logger.info(<span class="hljs-string"><span class="hljs-string">"Deleting backup started. Backup properties: {}"</span></span>, backupProperties); tasksManager.updateTaskState(taskId, Task.State.DELETING); backupLoadManager.deleteBackup(backupProperties, taskId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.COMPLETED); logger.info(<span class="hljs-string"><span class="hljs-string">"Deleting backup completed. Backup properties: {}"</span></span>, backupProperties); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (RuntimeException ex) { logger.error(<span class="hljs-string"><span class="hljs-string">"Error occurred while deleting backup. Backup properties: {}"</span></span>, backupProperties, ex); errorTasksManager.addErrorTask(taskId); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException ex) { tasksManager.setInterrupted(taskId); logger.error(<span class="hljs-string"><span class="hljs-string">"Task was interrupted. Task ID: {}"</span></span>, taskId); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { futures.remove(taskId); } }); futures.put(taskId, future); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> task; }</code> </pre> <br><p>  El proceso de eliminaci√≥n de una copia de seguridad es bastante simple: una copia de seguridad simplemente se elimina de todos los almacenamientos en los que se descarg√≥. </p><br><p>  Ejecute la desinstalaci√≥n de la siguiente manera: </p><br><pre> <code class="java hljs">tasksStarterService.startDeleteTask(Task.RunType.USER, backupProperties);</code> </pre> <br><p>  El proceso de eliminar una copia de seguridad en forma de diagrama: <br><img src="https://habrastorage.org/webt/y4/ca/yp/y4cayp76w4v0tx8umvzcp6flzd4.png" alt="  " title="Proceso de eliminaci√≥n de respaldo"></p></div></div><br><hr><br><h3 id="otmena-taskov">  Cancelar tarea </h3><br><p>  ¬øQu√© es la cancelaci√≥n de tareas?  Por supuesto, esto no es m√°s que una terminaci√≥n de hilo.  Podr√≠a ver que todo el c√≥digo principal que se ejecuta en Future est√° envuelto en la siguiente construcci√≥n try-catch: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException ex) { ... tasksManager.setInterrupted(taskId); }</code> </pre> <br><p>  Y tambi√©n despu√©s de cada m√©todo importante, cuyo flujo de ejecuci√≥n controlamos, se instala la siguiente construcci√≥n: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); }</code> </pre> <br><p>  Antes de continuar, se debe dar una breve teor√≠a de interrupciones y estados de subprocesos JVM. </p><br><p>  Los subprocesos en la JVM pueden tener los siguientes estados: </p><br><ol><li>  Nuevo </li><li>  Ejecutable </li><li>  Tiempo de espera </li><li>  Esperando </li><li>  Bloqueado </li><li>  Terminado </li></ol><br><p>  Solo nos interesan los estados de espera y de espera cronometrada.  El <code>Object.wait()</code> en estado de <em>espera</em> mediante los m√©todos <code>Object.wait()</code> , <code>Thread.join()</code> y otros.  El hilo se transfiere al estado de <em>espera temporizada</em> (es decir, una espera que dura un cierto per√≠odo de tiempo) utilizando los m√©todos <code>Object.wait(timeout)</code> , <code>Thread.join(timeout)</code> , <code>Thread.sleep(sleeping)</code> y otros. </p><br><p>  Lo m√°s importante aqu√≠ es que si interrumpe el hilo <em>antes de entrar en el estado de</em> espera o de espera temporizada o cuando el hilo <em>est√° en este estado</em> , el hilo se despierta y produce una <strong>excepci√≥n interrumpida</strong> . </p><br><p>  Pero eso no es todo.  No es en absoluto un hecho que un hilo entrar√° en datos de estado al crear, restaurar o eliminar una copia de seguridad.  ¬øC√≥mo informar entonces al hilo que fue interrumpido? </p><br><p>  La primera forma es verificar independientemente el indicador de interrupci√≥n con el hilo utilizando los m√©todos Thread.interrupted <code>Thread.interrupted()</code> o <code>Thread.currentThread.isInterrupted()</code> .  La diferencia entre los dos es que el primero llama al m√©todo nativo privado <code>currentThread.isInterrupted(boolean ClearInterrupted)</code> , que le pasa <code>true</code> , lo que indica que el indicador de interrupci√≥n se borrar√°, y el segundo pasa <code>false</code> , dejando el indicador de interrupci√≥n intacto.  La elecci√≥n entre estos dos m√©todos depende completamente de la situaci√≥n.  Cuando se lanza una excepci√≥n interrumpida, tambi√©n se borra la bandera de interrupci√≥n; vale la pena recordarlo. </p><br><p>  Pero debe haber una manera m√°s f√°cil, y lo es.  En la aplicaci√≥n, hay una gran cantidad de trabajo con flujos de E / S y, por lo tanto, con m√©todos de E / S.  Nuestra tarea es asegurar que al llamar a los m√©todos <code>read()</code> o <code>write(int b)</code> en el flujo de E / S, se produzca un error durante la interrupci√≥n, informando que la llamada de bloqueo de E / S se interrumpi√≥.  Afortunadamente, Java tiene una excepci√≥n: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">InterruptedIOException</a> .  Sin embargo, no todos los m√©todos de flujo de lectura / escritura monitorean las interrupciones de subprocesos, y espec√≠ficamente solo <em>PipedInputStream lo</em> monitorea.  Por lo tanto, en aquellos lugares donde esta secuencia no est√° involucrada, debemos extender el m√©todo de lectura / escritura para que cuando haya una interrupci√≥n, se produzca una InterruptedIOException.  De hecho, la extensi√≥n del m√©todo read () fue suficiente para m√≠ en la aplicaci√≥n solo en un lugar, cuando InputStream regres√≥ del m√©todo de carga de respaldo.  As√≠ es como podemos aprender sobre el origen de una interrupci√≥n sin tener que colocar controles de plantilla en la bandera en todas partes.  Sin embargo, es importante detectar esta excepci√≥n por separado de la IOException y manejarla por separado.  Por supuesto, no puede prescindir de la ayuda de una verificaci√≥n de plantilla de la bandera en algunos lugares, pero ya ha mejorado. </p><br><p>  Tambi√©n es importante tener en cuenta que si el indicador se borr√≥ durante el proceso de interrupci√≥n, siempre es necesario volver a establecer el indicador de interrupci√≥n para que despu√©s de regresar del m√©todo podamos averiguar la interrupci√≥n que se produjo. </p><br><p>  Perm√≠tanme explicar con un ejemplo por qu√© esto es importante.  Supongamos que cargamos una copia de seguridad en el almacenamiento en el m√©todo upload () y se produce una interrupci√≥n.  La interrupci√≥n se procesa, el trabajo se detiene y el m√©todo regresa.  La interrupci√≥n no ocurre con casualidad, significa que se produjo un error en alguna parte o que el usuario cancel√≥ la tarea.  Independientemente de la raz√≥n, debemos detener todo el trabajo en este Futuro.  Pero si no configura el indicador de interrupci√≥n nuevamente antes de regresar del m√©todo de arranque, nunca sabremos en el bloque Future principal sobre la interrupci√≥n que sucedi√≥. <br>  El mismo ejemplo de c√≥digo: </p><br><pre> <code class="java hljs">backupLoadManager.uploadBackup(processedBackupStream, backupProperties, taskId); &lt;-   ,       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-comment"><span class="hljs-comment">//      ,      - ,    throw new InterruptedException(); }</span></span></code> </pre> <br><p>  Por lo tanto, es una buena pr√°ctica manejar una <strong>InterruptedException</strong> o <strong>InterruptedIOException de la</strong> siguiente manera: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { <span class="hljs-comment"><span class="hljs-comment">//  InterruptedIOException ... // re-interrupt the thread Thread.currentThread().interrupt(); }</span></span></code> </pre> <br><p>  Bueno, podemos manejar la interrupci√≥n, pero ¬øqui√©n realmente interrumpir√° los hilos? <br>  Para hacer esto, crearemos otra entidad llamada <em>CancelTask</em> , que almacenar√° la ID de la tarea para su cancelaci√≥n, y tambi√©n escribiremos un reloj que intentar√° interrumpir las tareas.  ¬øPor qu√© intentarlo?  Porque: </p><br><ol><li>  No se puede terminar el hilo en la memoria de otro servidor.  Varios servidores pueden funcionar para nosotros, lo que significa que Future est√° disperso en diferentes servidores.  Por lo tanto, cuando llega una solicitud para cancelar una tarea en uno de los servidores, el futuro deseado puede estar en la memoria de otro servidor. </li><li>  La tarea no se puede cancelar porque se perdi√≥ el futuro debido a un bloqueo del servidor. </li></ol><br><p>  Describa brevemente el algoritmo de cancelaci√≥n en la noche: <br>  Watercher saca todos los registros de la tabla <em>cancel_tasks</em> (el bloqueo no se establece al mismo tiempo), <em>revisa</em> cada uno e intenta obtener el futuro correspondiente de su memoria.  Si Future se recibe con √©xito, el hilo correspondiente se interrumpe, la tarea se revierte y la solicitud se elimina de la tabla.  Si se supera la solicitud de tiempo de espera para cancelar la tarea (lo que significa que el servidor se bloque√≥ y se perdi√≥ el futuro), la solicitud simplemente se elimina de la tabla.  Si varios servidores notan un tiempo de espera y eliminan el registro de la tabla, no ocurrir√° nada malo, porque la eliminaci√≥n en PostgreSQL es idempotente. </p><br><p>  <strong>C√≥digo de CancelTasksWatcher:</strong> </p><br><div class="spoiler">  <b class="spoiler_title">Texto oculto</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * This class scans for tasks to cancel and tries to cancel them. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CancelTasksWatcher</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger logger = LoggerFactory.getLogger(CancelTasksWatcher.class); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Duration cancelTimeout = Duration.ofMinutes(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CancelTasksManager cancelTasksManager; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TasksStarterService tasksStarterService; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TasksManager tasksManager; <span class="hljs-comment"><span class="hljs-comment">// spring setters... /** * This watcher wakes up every time 10 seconds passed from the last completion, checks if there are any tasks to cancel and tries to * cancel each task. * &lt;p&gt; * Since there are can be working more that one instance of the program, {@literal Future} instance of task can belong to different * servers. We can't get access to {@literal Future} if it's not in memory of the server where task cancellation request was accepted. * So the purpose of this watcher is to be able cancel tasks that works in the other instance of program. Each server has this watcher * checking for available cancellation requests and if any, the watcher tries to cancel corresponding {@literal Future}. * If cancellation is successful task will be also reverted. * &lt;p&gt; * If task cancellation request timeout exceeded, then it means a server that had requested {@literal Future} instances has been * shutdown, so all {@literal Future} instances lost and task can't be canceled. In such case task cancellation request will be ignored. * * @see TasksStarterService#getFuture(Integer) * @see TasksManager#revertTask(Task) */ @Scheduled(fixedDelay = 10 * 1000) @Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRES_NEW) public void watchTasksToCancel() { Iterable&lt;CancelTask&gt; cancelTasks = cancelTasksManager.findAll(); Iterable&lt;Task&gt; tasks = tasksManager.findAllById(StreamSupport.stream(cancelTasks.spliterator(), false) .map(CancelTask::getTaskId).collect(Collectors.toList())); Map&lt;Integer, Task&gt; tasksAsMap = StreamSupport.stream(tasks.spliterator(), false) .collect(Collectors.toMap(Task::getId, Function.identity())); List&lt;Integer&gt; taskIdsForDeleting = new ArrayList&lt;&gt;(); for (CancelTask cancelTask : cancelTasks) { Integer taskId = cancelTask.getTaskId(); Task task = tasksAsMap.get(taskId); if (task == null) { logger.error("Can't cancel task: no such entity with ID {}", taskId); taskIdsForDeleting.add(taskId); continue; } // timeout exceeded, that is server shutdown and lost all Future instances, so task can't be canceled if (LocalDateTime.now(ZoneOffset.UTC).isAfter(cancelTask.getPutTime().plus(cancelTimeout))) { logger.error("Can't cancel task: timeout exceed. Task ID: {}", taskId); taskIdsForDeleting.add(taskId); continue; } tasksStarterService.getFuture(taskId).ifPresent(future -&gt; { logger.info("Canceling task with ID {}", taskId); boolean canceled = future.cancel(true); if (canceled) { try { // give time to properly handle interrupt Thread.sleep(10000); } catch (InterruptedException e) { // should not happen } tasksManager.revertTask(task); } taskIdsForDeleting.add(taskId); logger.info("Task canceled: {}. Task ID: {}", canceled, taskId); }); } cancelTasksManager.deleteByTaskIdIn(taskIdsForDeleting); } }</span></span></code> </pre> </div></div><br><hr><br><h4 id="obrabotka-oshibok">  Manejo de errores </h4><br><p>    ,    ,   Future,    try-catch : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (RuntimeException e) { ... errorTasksManager.addErrorTask(taskId); }</code> </pre> <br><p>     <em>RuntimeException</em>   ,     Future  ,         . </p><br><p>  <code>addErrorTask(taskId)</code>        ,   ID ,    . <br>      ?       ,    ,        ,   . </p><br><p>      : <br>                  ,        ,       .  ‚Äî  PostgreSQL <code>select for update</code> ,   select   <code>skip locked</code>      . ,  ,    <code>revertTask()</code> ,               . </p><br><p> <strong> ErrorTasksWatcher</strong> : </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * This class scans for erroneous tasks and handles them depending on their state. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ErrorTasksWatcher</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger logger = LoggerFactory.getLogger(ErrorTasksWatcher.class); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Integer nRows = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TasksManager tasksManager; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ErrorTasksManager errorTasksManager; <span class="hljs-comment"><span class="hljs-comment">// spring setters... /** * This watcher wakes up every time 1 minute passed from the last completion, checks backup states periodically and handles erroneous * tasks if any. * &lt;p&gt; * The watcher handles at most N tasks as described by {@link #nRows} constant and skips already locked tasks. * When retrieving error tasks from database pessimistic lock is set. It allows safely run more than one copy of program, as no other * watcher can pick up already being handled error tasks. * &lt;p&gt; * If the server shutdowns while rows was locked, transaction will be rolled back and lock released, so these entities can be picked * up by the other running server. */ @Scheduled(fixedDelay = 60 * 1000) @Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRES_NEW) public void watchErrorTasks() { for (ErrorTask errorTask : errorTasksManager.findFirstNAndLock(nRows)) { if (!errorTask.isErrorHandled()) { Integer backupTaskId = errorTask.getTaskId(); Optional&lt;Task&gt; optionalTask = tasksManager.findById(backupTaskId); if (!optionalTask.isPresent()) { logger.info("Can't handle erroneous task: no corresponding backup task entity. Backup task ID: {}", backupTaskId); continue; } tasksManager.revertTask(optionalTask.get()); errorTask.setErrorHandled(true); } } } }</span></span></code> </pre> </div></div><br><p> <strong> <code>revertTask(Task)</code> :</strong> </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * This function reverts erroneous task by its entity. * &lt;p&gt; * Use this function only after canceling related {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@literal</span></span></span><span class="hljs-comment"> Future}. * &lt;p&gt; * If the task was of the type {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> Task.Type#CREATE_BACKUP} then related {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> BackupProperties} will be deleted. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> task the entity */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">revertTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Task task)</span></span></span><span class="hljs-function"> </span></span>{ Objects.requireNonNull(task); Task.State state = task.getState(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DOWNLOADING: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> APPLYING_DEPROCESSORS: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RESTORING: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DELETING: { logger.info(<span class="hljs-string"><span class="hljs-string">"Handling broken operation. Operation: {}. No extra actions required"</span></span>, state.toString()); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CREATING: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> APPLYING_PROCESSORS: { logger.info(<span class="hljs-string"><span class="hljs-string">"Handling broken operation. Operation: {}. Delete backup properties..."</span></span>, state.toString()); Integer backupPropertiesID = task.getBackupPropertiesId(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!backupPropertiesManager.existsById(backupPropertiesID)) { logger.error(<span class="hljs-string"><span class="hljs-string">"Can't revert task: no related backup properties. Task info: {}"</span></span>, task); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } backupPropertiesManager.deleteById(backupPropertiesID); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> UPLOADING: { logger.info(<span class="hljs-string"><span class="hljs-string">"Handling broken operation. Operation: {}. Deleting backup from storage..."</span></span>, state); Integer backupPropertiesId = task.getBackupPropertiesId(); Optional&lt;BackupProperties&gt; optionalBackupProperties = backupPropertiesManager.findById(backupPropertiesId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!optionalBackupProperties.isPresent()) { logger.error(<span class="hljs-string"><span class="hljs-string">"Can't revert task: no related backup properties. Task info: {}"</span></span>, task); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } tasksStarterService.startDeleteTask(Task.RunType.INTERNAL, optionalBackupProperties.get()); backupPropertiesManager.deleteById(backupPropertiesId); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: { logger.error(<span class="hljs-string"><span class="hljs-string">"Can't revert task: unknown state. Task info: {}"</span></span>, task); } } }</code> </pre> <br><p>   : </p><br><ol><li>     <em>DOWNLOADING</em> , <em>APPLYING_DEPROCESSORS</em> , <em>RESTORING</em> , <em>DELETING</em> ‚Äî    .      ,       . </li><li>     <em>CREATING</em> , <em>APPLYING_PROCESSORS</em> ‚Äî  ,       .      BackupProperties  ,       ( BackupProperties   Web UI    ). </li><li>     <em>UPLOADING</em> ‚Äî       .        BackupProperties   ,       .       . </li></ol></div></div><br><p> ,    .         ,    ? ,   ,    Future (  1),     ,          InputStream (  2). ,      2,   1            2    ? </p><br><p>  ,     ,    ,       .      Future (    1)     : </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Throwable t, @NotNull Integer taskId)</span></span></span><span class="hljs-function"> </span></span>{ logger.error(<span class="hljs-string"><span class="hljs-string">"Exception caught. Task ID: {}"</span></span>, taskId, t); Optional&lt;Future&gt; optionalFuture = tasksStarterService.getFuture(taskId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!optionalFuture.isPresent()) { logger.error(<span class="hljs-string"><span class="hljs-string">"Can't cancel the Future of task with ID {}: no such Future instance"</span></span>, taskId); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> canceled = optionalFuture.get().cancel(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!canceled) { logger.error(<span class="hljs-string"><span class="hljs-string">"Error canceling the Future of task with ID {}"</span></span>, taskId); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { logger.info(<span class="hljs-string"><span class="hljs-string">"Task canceled. Task ID: {}"</span></span>, taskId); errorTasksManager.setError(taskId); } } }</code> </pre> <br><p>   ,     ,      ID  ,   ,    Future   -  ,  ID     . </p><br><p>    ,          ,     ,     ,         ,          . </p><br><p> <strong>  ,   :</strong> </p><br><p> ,   ,        ,    .       ‚Äî       Future. </p><br><p>   ,      ,    ,      I/O ,          ‚Äî     /   .     ,      .       : </p><br><ol><li>  ,  .     ,      ‚Äî     . </li><li>     ‚Äî     Future   ,   .  , /   ,  ,     (  ,     ‚Äî    IOException  ,        ,   ). </li></ol><br><p>  ,   ‚Äî            (   ID       ,  ,    ),        . </p><br><hr><br><p>  ,    ,        .      ,    ,             . </p><br><h3 id="plany-na-buduschee">    </h3><br><ol><li>  Web UI:   ,   .     ,      </li><li>     </li><li>      </li><li>     </li><li>     </li></ol><br><h3 id="zaklyuchenie">  Conclusi√≥n </h3><br><p>   : </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>GitHub</strong></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>Docker Hub</strong></a> </li></ul><br><p>   ,   !           ,       GitHub! <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/459478/">https://habr.com/ru/post/459478/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459464/index.html">Lua en Mosc√∫ 2019: entrevista con Roberto Jerusalem</a></li>
<li><a href="../459466/index.html">Lua en Mosc√∫ 2019: entrevista con Roberto Ierusalimschy</a></li>
<li><a href="../459470/index.html">Parte 4: Sigue ejecutando Linux en RISC-V RISC-V</a></li>
<li><a href="../459472/index.html">Heroku + Docker + Spring Boot</a></li>
<li><a href="../459474/index.html">C√≥mo hacer texto perfectamente escrito en un segundo: una macro en Word para aquellos que escriben mucho</a></li>
<li><a href="../459480/index.html">Vivaldi: ¬øC√≥mo gana dinero el navegador?</a></li>
<li><a href="../459482/index.html">C√≥mo derrotamos al √°rbol de categor√≠as</a></li>
<li><a href="../459484/index.html">Generaci√≥n Arduino. Lo que inventan los estudiantes modernos</a></li>
<li><a href="../459488/index.html">Modos de juego especiales en el contexto de Roguelike</a></li>
<li><a href="../459490/index.html">Trucos sucios de vendedores de CRM: ¬øcomprar√≠as un auto sin ruedas?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>