<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§öüèΩ üë®üèΩ‚Äçüíº ‚úåüèª Laplace Blur - Est-il possible de blub Laplace au lieu de Gauss, combien de fois est plus rapide, et vaut-il la perte de pr√©cision 1/32 ‚úùÔ∏è üéÉ üë∞üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Flou" chez les gens du commun est un effet de flou dans le traitement d'image num√©rique. Il peut √™tre tr√®s efficace en soi, et en tant que composant ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Laplace Blur - Est-il possible de blub Laplace au lieu de Gauss, combien de fois est plus rapide, et vaut-il la perte de pr√©cision 1/32</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427077/"><img src="https://habrastorage.org/webt/ge/pb/p3/gepbp3bpdluk4yg0-xzbn0via3y.jpeg" alt="image"><br><br>  "Flou" chez les gens du commun est un effet de flou dans le traitement d'image num√©rique.  Il peut √™tre tr√®s efficace en soi, et en tant que composant d'animations d'interface, ou d'effets d√©riv√©s plus complexes (bloom / focusBlur / motionBlur).  Avec tout cela, les bleus honn√™tes sur le front sont plut√¥t lents.  Et souvent, les impl√©mentations int√©gr√©es √† la plate-forme cible laissent beaucoup √† d√©sirer.  Soit la vitesse est triste, les artefacts blessent les yeux.  La situation donne lieu √† de nombreuses mises en ≈ìuvre de compromis mieux ou moins bien adapt√©es √† certaines conditions.  Une impl√©mentation originale avec une bonne qualit√© de fiabilit√© et la vitesse la plus √©lev√©e, tandis que la plus faible d√©pendance au mat√©riel vous attend sous la coupe.  Bon app√©tit! <br><a name="habracut"></a><br>  (Flou de Laplace - Nom d'algorithme d'origine propos√©) <br><br>  Aujourd'hui, ma d√©mosc√®ne interne m'a donn√© des coups de pied et m'a forc√© √† √©crire un article qui devait √™tre √©crit il y a six mois.  En tant qu'amateur, √† loisir, pour d√©velopper des algorithmes d'effets originaux, je voudrais proposer au public un algorithme de ¬´blurah presque gausien¬ª, caract√©ris√© par l'utilisation d'instructions de processeur exceptionnellement rapides (shift et masques), et donc accessible √† l'impl√©mentation jusqu'aux microcontr√¥leurs (extr√™mement rapide dans un environnement limit√©). <br><br>  Selon ma tradition d'√©crire des articles sur Habr, je vais donner des exemples en JS comme le langage le plus populaire, et croyez-le ou non, c'est tr√®s pratique pour le prototypage rapide d'algorithmes.  De plus, la possibilit√© de l'impl√©menter efficacement sur JS est venue avec des tableaux typ√©s.  Sur mon ordinateur portable pas tr√®s puissant, l'image plein √©cran est trait√©e √† une vitesse de 30 images par seconde (le multithreading des travailleurs n'√©tait pas impliqu√©). <br><br><div class="spoiler">  <b class="spoiler_title">Avis de non-responsabilit√© pour Cool Maths</b> <div class="spoiler_text">  Je dirai tout de suite que je retire mon chapeau parce que je me consid√®re comme n'√©tant pas suffisamment averti en math√©matiques fondamentales.  Cependant, je suis toujours guid√© par l'esprit g√©n√©ral d'une approche fondamentale.  Par cons√©quent, avant de tromper mon approche quelque peu ¬´observationnelle¬ª de l'approximation, prenez soin de calculer la complexit√© en bits de l'algorithme, qui, comme vous le pensez, peut √™tre obtenue par des m√©thodes d'approximation polynomiales classiques.  J'ai devin√© non?  Vous vouliez les rapprocher rapidement?  √âtant donn√© qu'ils n√©cessitent une arithm√©tique flottante, ils seront consid√©rablement plus lents qu'un d√©calage √† un seul bit, ce que j'expliquerai √† la fin.  En un mot, ne vous pr√©cipitez pas vers l'int√©grisme th√©orique et n'oubliez pas le contexte dans lequel je r√©sous le probl√®me. <br></div></div><br>  Cette description est pr√©sente ici plut√¥t afin d'expliquer le cours de mes pens√©es et conjectures qui m'ont conduit au r√©sultat.  Pour ceux qui seront int√©ress√©s: <br><br>  Fonction originale de Gauss: <br><br><img src="https://habrastorage.org/webt/63/h0/km/63h0kmf5xougnx-tcp05_esii1y.png" alt="image"><br><br>  g (x) = a * e ** (- ((xb) ** 2) / c), o√π <br>  a est l'amplitude (si nous avons huit bits de couleur par canal, alors il = 256) <br>  e est la constante d'Euler ~ 2,7 <br>  b - d√©calage graphique en x (nous n'avons pas besoin = 0) <br>  c - param√®tre affectant la largeur du graphique qui lui est associ√© comme ~ w / 2,35 <br><br>  Notre fonction priv√©e (moins l'exposant supprim√© avec le remplacement de la multiplication par division): <br><br><img src="https://habrastorage.org/webt/rj/o-/ns/rjo-nsq8o1nptsuyrbhpit1ozkw.png" alt="image"><br><br>  g (x) = 256 / e ** (x * x / c) <br><br>  Que l'action d'approximation sale commence: <br>  Notez que le param√®tre c est tr√®s proche de la demi-largeur et d√©fini sur 8 (cela est d√ª au nombre d'√©tapes que vous pouvez d√©placer un canal de 8 bits chacun). <br><br>  Nous rempla√ßons aussi grossi√®rement e par 2, cependant, notant que cela affecte la courbure de la ¬´cloche¬ª plus que ses bordures.  En fait, cela affecte 2 / e fois, mais la surprise est que cette erreur compense le param√®tre c, de sorte que les conditions aux limites sont toujours en ordre, et l'erreur n'appara√Æt que dans une ¬´distribution normale¬ª l√©g√®rement incorrecte, pour le graphique algorithmes, cela affectera la dynamique des transitions de d√©grad√© de couleurs, mais il est presque impossible de le remarquer √† l'≈ìil nu. <br><br>  Alors maintenant, notre fonction est la suivante: <br>  gg (x) = 256/2 ** (x * x / 8) ou gg (x) = 2 ** (8 - x * x / 8) <br>  Notez que l'exposant (x * x / 8) a la m√™me plage de valeurs [0-8] que la fonction d'un abs d'ordre inf√©rieur (x), donc ce dernier est un candidat pour le remplacement.  Nous allons rapidement v√©rifier la supposition en regardant comment le graphique change avec lui gg (x) = 256 / (2 ** abs (x)): <br><br>  GaussBlur vs LaplasBlur: <br><br><img src="https://habrastorage.org/webt/ri/9m/wn/ri9mwnl06vzoim4atrlhnyi5wye.png" alt="image"><br><br>  Les √©carts semblent trop importants, d'ailleurs, la fonction, ayant perdu son liss√©, a maintenant un pic.  Mais bon. <br><br>  Tout d'abord, n'oublions pas que la r√©gularit√© des gradients obtenus par le flou ne d√©pend pas de la fonction de densit√© de probabilit√© (qui est la fonction de Gauss), mais de son int√©grale - la fonction de distribution.  A cette √©poque, je ne connaissais pas ce fait, mais en fait, apr√®s avoir effectu√© une approximation ¬´destructrice¬ª par rapport √† la fonction de densit√© de probabilit√© (Gauss), la fonction de distribution est rest√©e assez similaire. <br><br>  C'√©tait: <br><br><img src="https://habrastorage.org/webt/gj/nl/_l/gjnl_lzdrv_e_yvi87kxcrnu-e4.png" alt="image"><br><br>  C'est devenu: <br><br><img src="https://habrastorage.org/webt/le/nw/te/lenwteibjhhx9mwosint393sgjo.png" alt="image"><br><br>  La preuve, tir√©e de l'algorithme pr√™t √† l'emploi, co√Øncide: <br><br><img src="https://habrastorage.org/webt/lg/ly/bm/lglybmx2fx4-rtff1eq_natuodm.png" alt="image"><br><br>  (Pour l'avenir, je dirai que l'erreur de flou de mon algorithme par rapport √† Gausian x5 n'√©tait que de 3%). <br><br>  Nous nous sommes donc rapproch√©s beaucoup plus de la fonction de distribution de Laplace.  Qui aurait pens√©, mais ils peuvent laver les images √† 97% pas pire. <br><br>  Preuve, diff√©rences Gausian blura x5 et "Laplace blura" x7: <br><br><img src="https://habrastorage.org/webt/qy/1g/z1/qy1gz1d0fahnsbstiqwijj-rb3y.png" alt="image"><br><br>  (ce n'est pas une image noire! Vous pouvez √©tudier dans l'√©diteur) <br><br>  L'hypoth√®se de cette transformation nous a permis de passer √† l'id√©e d'obtenir la valeur par filtrage it√©ratif, √† laquelle j'avais pr√©vu de r√©duire initialement. <br><br>  Avant de dire un algorithme sp√©cifique, il sera honn√™te de continuer et de d√©crire imm√©diatement son seul inconv√©nient (bien que la mise en ≈ìuvre puisse √™tre corrig√©e avec une perte de vitesse).  Mais cet algorithme est impl√©ment√© en utilisant l'arithm√©tique de cisaillement, et les puissances de 2 sont sa limitation.  L'original est donc fait pour brouiller x7 (qui dans les tests est le plus proche de Gausian x5).  Cette limitation d'impl√©mentation est due au fait qu'avec une couleur √† huit bits, en d√©calant la valeur dans le lecteur de filtre d'un bit par √©tape, toute action √† partir du point se termine par un maximum de 8 √©tapes.  J'ai √©galement impl√©ment√© une version l√©g√®rement plus lente gr√¢ce √† des proportions et des ajouts suppl√©mentaires, qui impl√©mente une division rapide par 1,5 (r√©sultant en un rayon de x15).  Mais avec l'application de cette approche, l'erreur augmente et la vitesse diminue, ce qui ne permet pas de l'utiliser comme √ßa.  En revanche, il convient de noter que x15 est d√©j√† suffisant pour ne pas remarquer la diff√©rence, le r√©sultat est obtenu √† partir de l'original ou de l'image sous-√©chantillonn√©e.  La m√©thode est donc tout √† fait appropri√©e si vous avez besoin d'une vitesse extraordinaire dans un environnement limit√©. <br><br>  Ainsi, le c≈ìur de l'algorithme est simple, quatre passes du m√™me type sont effectu√©es: <br><br>  1. La moiti√© de la valeur du lecteur t (initialement √©gale √† z√©ro) est ajout√©e √† la moiti√© de la valeur du pixel suivant, le r√©sultat lui est attribu√©.  Continuez ainsi jusqu'√† la fin de la ligne d'image.  Pour toutes les lignes. <br><br>  √Ä la fin de la premi√®re passe, l'image est floue dans une direction. <br><br>  2. Au deuxi√®me passage, nous faisons de m√™me dans la direction oppos√©e pour toutes les lignes. <br>  On obtient une image compl√®tement floue horizontalement. <br><br>  3-4.  Maintenant, faites la m√™me chose verticalement. <br>  C'est fait! <br><br>  Initialement, j'ai utilis√© un algorithme √† deux passes avec l'impl√©mentation du back-flur √† travers la pile, mais il est difficile √† comprendre, pas gracieux, et il s'est av√©r√© plus lent sur les architectures actuelles.  Peut-√™tre que l'algorithme en un seul passage sera plus rapide sur les microcontr√¥leurs, plus la possibilit√© de produire progressivement le r√©sultat sera √©galement un plus. <br><br>  La m√©thode d'impl√©mentation quadridirectionnelle actuelle, j'ai regard√© Habr√© du pr√©c√©dent gourou sur les algorithmes de flou.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">habr.com/post/151157</a> J'en profite pour lui exprimer ma solidarit√© et ma profonde gratitude. <br><br>  Mais les hacks ne s'arr√™taient pas l√†.  Maintenant, comment calculer les trois canaux de couleur dans une instruction de processeur!  Le fait est que le d√©calage de bits utilis√© comme division par deux vous permet de tr√®s bien contr√¥ler la position des bits de r√©sultat.  Le seul probl√®me est que les bits inf√©rieurs des canaux glissent dans les plus hauts voisins, mais vous pouvez simplement les r√©initialiser, puis r√©soudre le probl√®me, avec une certaine perte de pr√©cision.  Et selon la formule de filtre d√©crite, l'ajout de la moiti√© de la valeur du lecteur √† la moiti√© de la valeur de la cellule suivante (sous r√©serve de r√©initialiser les bits d√©charg√©s) ne conduit jamais √† un d√©bordement, vous ne devez donc pas vous en soucier.  Et la formule de filtre pour le calcul simultan√© de tous les chiffres devient ceci: <br><br>  buf32 [i] = t = (((t &gt;&gt; 1) &amp; 0x7F7F7F) + ((buf32 [i] &gt;&gt; 1) &amp; 0x7F7F7F); <br><br>  Cependant, un ajout suppl√©mentaire est n√©cessaire: il a √©t√© constat√© exp√©rimentalement que la perte de pr√©cision dans cette formule est trop importante, la luminosit√© de l'image saute visuellement de mani√®re significative.  Il est devenu clair que le bit perdu doit √™tre arrondi √† l'entier le plus proche et non jet√©.  Un moyen facile de le faire en arithm√©tique enti√®re consiste √† ajouter la moiti√© du diviseur avant la division.  Notre diviseur est deux, vous devez donc en ajouter un, dans tous les chiffres, - la constante 0x010101.  Mais avec tout ajout, il faut se m√©fier des d√©bordements.  Nous ne pouvons donc pas utiliser une telle correction pour calculer la moiti√© de la valeur de la cellule suivante.  (S'il y a de la couleur blanche, nous obtiendrons un d√©bordement, donc nous ne le corrigerons pas).  Mais il s'est av√©r√© que la principale erreur a √©t√© commise par plusieurs divisions de l'entra√Ænement, que nous pouvons simplement corriger.  Parce que, en fait, m√™me avec une telle correction, la valeur dans le lecteur ne d√©passera pas 254. Mais lorsqu'elle est ajout√©e √† 0x010101, le d√©bordement ne sera pas garanti.  Et la formule de filtre avec correction prend la forme: <br><br>  buf32 [i] = t = ((((((0x010101 + t) &gt;&gt; 1) &amp; 0x7F7F7F) + ((buf32 [i] &gt;&gt; 1) &amp; 0x7F7F7F); <br><br>  En fait, la formule effectue assez bien la correction, donc lorsque vous appliquez √† plusieurs reprises cet algorithme √† l'image, les artefacts commencent √† √™tre visibles uniquement dans les dix secondes suivantes.  (pas le fait que la r√©p√©tition du blura gausien ne produira pas de tels artefacts). <br><br>  De plus, il y a une magnifique propri√©t√© avec de nombreux cols.  (Cela n'est pas d√ª √† mon algorithme, mais √† la "normalit√©" de la distribution normale).  D√©j√† au deuxi√®me passage du Laplace Blura, la fonction de densit√© de probabilit√© (si j'ai bien compris) ressemblera √† ceci: <br><br><img src="https://habrastorage.org/webt/sl/1m/tk/sl1mtkidvvurt8z7vxiuhjbfzka.png" alt="image"><br><br>  Ce qui, vous voyez, est d√©j√† tr√®s proche de la gaussienne. <br><br>  Empiriquement, j'ai trouv√© que l'utilisation de modifications avec un grand rayon est autoris√©e par paires, car  la propri√©t√© d√©crite ci-dessus compense les erreurs si la derni√®re passe est plus pr√©cise (la plus pr√©cise est l'algorithme de flou x7 d√©crit ici). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©mo</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rap</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cabillaud</a> <br><br>  Un appel pour les math√©maticiens sympas: <br>  Ce qui serait int√©ressant de savoir √† quel point il est correct d'utiliser un tel filtre s√©par√©ment, je ne sais pas s'il y a une image de distribution sym√©trique.  Bien que l'h√©t√©rog√©n√©it√© de l'≈ìil ne soit pas visible. <br><br>  upd: Ici, je vais soulever des liens utiles, aimablement pr√©sent√©s par des commentateurs, et trouv√©s d'autres Khabrovites. <br>  1. Fonctionnement des assistants Intel bas√©s sur la puissance de SSE - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">software.intel.com/en-us/articles/iir-gaussian-blur-filter-implementation-using-intel-advanced-vector-extensions</a> (merci <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">vladimirovich</a> ) <br>  2. Base th√©orique sur le sujet ¬´Convolutions d'images rapides¬ª + certaines de ses applications personnalis√©es en relation avec l'honn√™te <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bleut</a> gaussien - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">blog.ivank.net/fastest-gaussian-blur.html</a> (merci <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Grox</a> ) <br><br>  Les suggestions, commentaires, critiques constructives sont les bienvenus! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr427077/">https://habr.com/ru/post/fr427077/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr427059/index.html">"Humain, trop humain." Ne deviendrons-nous pas des otages de notre esprit en mettant en ≈ìuvre l'IA universelle?</a></li>
<li><a href="../fr427061/index.html">Assistants vocaux au volant de la voiture: pour qui l'avenir</a></li>
<li><a href="../fr427065/index.html">M√©tamorphoses d'attributs de classe</a></li>
<li><a href="../fr427069/index.html">D√©p√¥t NPM local en 5 minutes avec ses packages et sa mise en cache</a></li>
<li><a href="../fr427075/index.html">L'histoire d'un d√©veloppement</a></li>
<li><a href="../fr427079/index.html">NetApp Insight 2018</a></li>
<li><a href="../fr427081/index.html">Crit√®res de l'esprit humain, du point de vue d'un programmeur</a></li>
<li><a href="../fr427087/index.html">Cours MIT "S√©curit√© des syst√®mes informatiques". Conf√©rence 12: S√©curit√© du r√©seau, partie 2</a></li>
<li><a href="../fr427091/index.html">V√©rification num√©rique de l'hypoth√®se abc (oui, celle-l√†)</a></li>
<li><a href="../fr427093/index.html">Cours MIT "S√©curit√© des syst√®mes informatiques". Conf√©rence 12: S√©curit√© du r√©seau, partie 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>