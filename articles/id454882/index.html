<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖐🏼 🧓🏼 🙎 Arsitektur situasi yang luar biasa: halaman 2 dari 4 ⏪ 👷 🏴󠁧󠁢󠁳󠁣󠁴󠁿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya kira salah satu masalah paling penting dalam topik ini adalah membangun arsitektur penanganan pengecualian dalam aplikasi Anda. Ini menarik karen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arsitektur situasi yang luar biasa: halaman 2 dari 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/454882/"><p><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img width="350" align="left" src="https://habrastorage.org/webt/vh/7j/tq/vh7jtqhzbne4h3rjhprca2pruhu.png"></a>  Saya kira salah satu masalah paling penting dalam topik ini adalah membangun arsitektur penanganan pengecualian dalam aplikasi Anda.  Ini menarik karena berbagai alasan.  Dan alasan utama, saya pikir, adalah kesederhanaan yang jelas, yang Anda tidak selalu tahu harus melakukan apa.  Semua konstruksi dasar seperti <code>IEnumerable</code> , <code>IDisposable</code> , <code>IObservable</code> , dll.  miliki properti ini dan gunakan di mana-mana.  Di satu sisi, kesederhanaan mereka menggoda untuk menggunakan konstruksi ini dalam situasi yang berbeda.  Di sisi lain, mereka penuh jebakan yang mungkin tidak Anda keluarkan.  Ada kemungkinan bahwa dengan melihat jumlah informasi yang akan kami bahas, Anda punya pertanyaan: apa yang istimewa tentang situasi luar biasa? </p><br><p>  Namun, untuk membuat kesimpulan tentang membangun arsitektur kelas pengecualian, kita harus mempelajari beberapa detail tentang klasifikasi mereka.  Karena sebelum membangun sistem jenis yang akan jelas bagi pengguna kode, seorang programmer harus menentukan kapan harus memilih jenis kesalahan dan kapan harus menangkap atau melewatkan pengecualian.  Jadi, mari kita mengklasifikasikan situasi luar biasa (bukan jenis pengecualian) berdasarkan berbagai fitur. </p><a name="habracut"></a><br><h3 id="based-on-a-theoretical-possibility-to-catch-a-future-exception">  Berdasarkan kemungkinan teoritis untuk menangkap pengecualian di masa depan. </h3><br><p>  Berdasarkan fitur ini, kami dapat membagi pengecualian menjadi yang pasti ditangkap dan yang sangat mungkin tidak akan tertangkap.  Mengapa saya mengatakan <em>sangat mungkin</em> ?  Karena selalu ada seseorang yang akan mencoba menangkap pengecualian sementara ini tidak perlu. </p><br><p>  Pertama, mari kita gambarkan kelompok pengecualian pertama - mereka yang harus ditangkap. </p><br><p>  Dalam kasus pengecualian seperti itu, kami, di satu sisi, mengatakan kepada subsistem kami bahwa kami sampai pada keadaan ketika tidak ada gunanya tindakan lebih lanjut dengan data kami.  Di sisi lain, kami maksudkan bahwa tidak ada bencana yang terjadi dan kami dapat menemukan jalan keluar dari situasi hanya dengan menangkap pengecualian.  Properti ini sangat penting karena mendefinisikan kekritisan kesalahan dan memberikan keyakinan bahwa jika kita menangkap pengecualian dan sumber daya yang jelas, kita dapat melanjutkan dengan kode. </p><br><p>  Kelompok kedua membahas pengecualian yang, meskipun mungkin terdengar aneh, tidak harus ditangkap.  Mereka dapat digunakan hanya untuk logging kesalahan, tetapi tidak untuk memperbaiki situasi.  Contoh paling sederhana adalah <code>ArgumentException</code> dan <code>NullReferenceException</code> .  Bahkan, dalam situasi biasa Anda tidak perlu menangkap, misalnya, <code>ArgumentNullException</code> karena dalam kasus ini sumber kesalahan adalah Anda.  Jika Anda menangkap pengecualian seperti itu, Anda mengakui bahwa Anda membuat kesalahan dan mengirimkan sesuatu yang tidak dapat diterima ke metode: </p><br><pre> <code class="plaintext hljs">void SomeMethod(object argument) { try { AnotherMethod(argument); } catch (ArgumentNullException exception) { // Log it } }</code> </pre> <br><p>  Dalam metode ini kami mencoba menangkap <code>ArgumentNullException</code> .  Tapi saya pikir ini aneh karena memberikan argumen yang benar pada suatu metode sepenuhnya menjadi perhatian kita.  Bereaksi setelah peristiwa akan salah: hal terbaik yang dapat Anda lakukan dalam situasi seperti ini adalah memeriksa data yang dikirimkan terlebih dahulu sebelum memanggil metode atau bahkan membangun kode seperti itu di mana mendapatkan parameter yang salah tidak mungkin. </p><br><p>  Kelompok lain dari situasi luar biasa adalah kesalahan fatal.  Jika beberapa cache salah dan pekerjaan subsistem tidak benar, maka itu adalah kesalahan fatal dan kode terdekat pada stack tidak akan menangkapnya dengan pasti: </p><br><pre> <code class="plaintext hljs">T GetFromCacheOrCalculate() { try { if(_cache.TryGetValue(Key, out var result)) { return result; } else { T res = Strategy(Key); _cache[Key] = res; return res; } } cache (CacheCorruptedException exception) { RecreateCache(); return GetFromCacheOrCalculate(); } }</code> </pre> <br><p>  <code>CacheCorruptedException</code> adalah pengecualian yang berarti bahwa "cache hard drive tidak konsisten".  Kemudian, jika penyebab kesalahan seperti itu fatal bagi subsistem cache (misalnya tidak ada hak akses file cache), kode berikut ini tidak dapat membuat kembali cache menggunakan instruksi <code>RecreateCache</code> dan karenanya menangkap pengecualian ini adalah kesalahan itu sendiri. </p><br><h3 id="based-on-the-area-where-an-exceptional-situation-is-actually-catched">  Berdasarkan area di mana situasi luar biasa sebenarnya ditangkap </h3><br><p>  Masalah lainnya adalah apakah kita harus menangkap beberapa pengecualian atau memberikannya kepada seseorang yang memahami situasi dengan lebih baik.  Dengan kata lain, kita harus menetapkan bidang tanggung jawab.  Mari kita periksa kode berikut: </p><br><pre> <code class="plaintext hljs">namespace JetFinance.Strategies { public class WildStrategy : StrategyBase { private Random random = new Random(); public void PlayRussianRoulette() { if(DateTime.Now.Second == (random.Next() % 60)) { throw new StrategyException(); } } } public class StrategyException : Exception { /* .. */ } } namespace JetFinance.Investments { public class WildInvestment { WildStrategy _strategy; public WildInvestment(WildStrategy strategy) { _strategy = strategy; } public void DoSomethingWild() { ?try? { _strategy.PlayRussianRoulette(); } catch(StrategyException exception) { } } } } using JetFinance.Strategies; using JetFinance.Investments; void Main() { var foo = new WildStrategy(); var boo = new WildInvestment(foo); ?try? { boo.DoSomethingWild(); } catch(StrategyException exception) { } }</code> </pre><br><p>  Manakah dari dua strategi yang lebih tepat?  Area tanggung jawab sangat penting.  Awalnya, mungkin terlihat bahwa kerja dan konsistensi <code>WildInvestment</code> sepenuhnya bergantung pada <code>WildStrategy</code> .  Jadi, jika <code>WildInvestment</code> mengabaikan pengecualian ini, itu akan naik ke level atas dan kita seharusnya tidak melakukan apa-apa.  Namun, perhatikan bahwa dalam hal arsitektur, metode <code>Main</code> menangkap pengecualian dari satu tingkat sambil memanggil metode dari yang lain.  Bagaimana tampilannya dalam hal penggunaan?  Begini tampilannya: </p><br><ul><li>  tanggung jawab untuk pengecualian ini diserahkan kepada kami; </li><li>  pengguna kelas ini tidak yakin bahwa pengecualian ini sebelumnya melewati serangkaian metode yang disengaja; </li><li>  kita mulai membuat dependensi baru yang kita hilangkan dengan memanggil lapisan perantara. </li></ul><br><p>  Namun, ada kesimpulan lain yang dihasilkan dari ini: kita harus menggunakan <code>catch</code> dalam metode <code>DoSomethingWild</code> .  Dan ini sedikit aneh bagi kami: <code>WildInvestment</code> adalah semacam hampir tidak bergantung pada sesuatu.  Maksud saya jika <code>PlayRussianRoulette</code> tidak berfungsi, hal yang sama akan terjadi pada <code>DoSomethingWild</code> : tidak memiliki kode pengembalian, tetapi harus memainkan roulette.  Jadi, apa yang bisa kita lakukan dalam situasi yang tampaknya tanpa harapan?  Jawabannya sebenarnya sederhana: berada di level lain <code>DoSomethingWild</code> harus membuang pengecualiannya sendiri yang termasuk level ini dan membungkusnya dengan <code>InnerException</code> sebagai sumber asli masalah: </p><br><pre> <code class="plaintext hljs">namespace JetFinance.Strategies { pubilc class WildStrategy { private Random random = new Random(); public void PlayRussianRoulette() { if(DateTime.Now.Second == (random.Next() % 60)) { throw new StrategyException(); } } } public class StrategyException : Exception { /* .. */ } } namespace JetFinance.Investments { public class WildInvestment { WildStrategy _strategy; public WildInvestment(WildStrategy strategy) { _strategy = strategy; } public void DoSomethingWild() { try { _strategy.PlayRussianRoulette(); } catch(StrategyException exception) { throw new FailedInvestmentException("Oops", exception); } } } public class InvestmentException : Exception { /* .. */ } public class FailedInvestmentException : Exception { /* .. */ } } using JetFinance.Investments; void Main() { var foo = new WildStrategy(); var boo = new WildInvestment(foo); try { boo.DoSomethingWild(); } catch(FailedInvestmentException exception) { } }</code> </pre> <br><p>  Dengan membungkus satu pengecualian di yang lain, kami mentransfer masalah dari satu tingkat aplikasi ke yang lain dan menjadikan pekerjaannya lebih mudah diprediksi dalam hal konsumen kelas ini: metode <code>Main</code> . </p><br><h3 id="based-on-reuse-issues">  Berdasarkan masalah penggunaan kembali </h3><br><p>  Seringkali kita merasa terlalu malas untuk membuat tipe pengecualian baru, tetapi ketika kita memutuskan untuk melakukannya, tidak selalu jelas tipe yang menjadi dasar.  Namun justru keputusan inilah yang menentukan keseluruhan arsitektur situasi luar biasa.  Mari kita lihat beberapa solusi populer dan buat beberapa kesimpulan. </p><br><p>  Saat memilih jenis pengecualian, kita dapat menggunakan solusi yang dibuat sebelumnya, yaitu untuk menemukan pengecualian dengan nama yang mengandung arti yang sama dan menggunakannya.  Misalnya, jika kami mendapat entitas melalui parameter dan kami tidak menyukai entitas ini, kami dapat melempar <code>InvalidArgumentException</code> , yang mengindikasikan penyebab kesalahan dalam Pesan.  Skenario ini terlihat bagus terutama karena <code>InvalidArgumentException</code> termasuk dalam kelompok pengecualian yang mungkin tidak tertangkap.  Namun, pilihan <code>InvalidDataException</code> akan salah jika Anda bekerja dengan beberapa tipe data.  Itu karena jenis ini ada di area <code>System.IO</code> , yang mungkin bukan yang Anda hadapi.  Dengan demikian, hampir selalu salah untuk mencari jenis yang sudah ada daripada mengembangkannya sendiri.  Hampir tidak ada pengecualian untuk berbagai tugas umum.  Hampir semuanya adalah untuk situasi tertentu dan jika Anda menggunakannya kembali dalam kasus lain, itu akan sangat melanggar arsitektur situasi luar biasa.  Selain itu, pengecualian untuk tipe tertentu (misalnya, <code>System.IO.InvalidDataException</code> ) dapat membingungkan pengguna: di satu sisi, ia akan melihat bahwa pengecualian milik namespace <code>System.IO</code> , sementara di sisi lain ia dilempar dari namespace yang sama sekali berbeda.  Jika pengguna ini mulai berpikir tentang aturan melempar pengecualian ini, ia dapat pergi ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Referenceource.microsoft.com</a> dan menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">semua tempat di mana itu dilemparkan</a> : </p><br><ul><li> <code>internal class System.IO.Compression.Inflater</code> </li> </ul><br><p>  Pengguna akan mengerti itu <del>  seseorang jempol </del>  jenis pengecualian ini membingungkannya karena metode yang melempar pengecualian ini tidak berurusan dengan kompresi. </p><br><p>  Selain itu, dalam hal penggunaan kembali, Anda cukup membuat satu pengecualian dan mendeklarasikan bidang <code>ErrorCode</code> di dalamnya.  Itu sepertinya ide yang bagus.  Anda hanya melempar pengecualian yang sama, mengatur kode, dan menggunakan hanya satu <code>catch</code> untuk menangani pengecualian, meningkatkan stabilitas aplikasi, tidak lebih.  Namun, saya yakin Anda harus memikirkan kembali posisi ini.  Tentu saja, pendekatan ini membuat hidup lebih mudah di satu sisi.  Namun, di sisi lain, Anda menolak kemungkinan untuk menangkap subkelompok pengecualian yang memiliki beberapa fitur umum.  Misalnya, <code>ArgumentException</code> yang menyatukan banyak pengecualian dengan warisan.  Kerugian serius lainnya adalah kode yang terlalu besar dan tidak dapat dibaca yang harus mengatur penyaringan berdasarkan kode kesalahan.  Namun, memperkenalkan tipe mencakup dengan kode kesalahan akan lebih tepat ketika pengguna tidak perlu peduli menentukan kesalahan. </p><br><pre> <code class="plaintext hljs">public class ParserException { public ParserError ErrorCode { get; } public ParserException(ParserError errorCode) { ErrorCode = errorCode; } public override string Message { get { return Resources.GetResource($"{nameof(ParserException)}{Enum.GetName(typeof(ParserError), ErrorCode)}"); } } } public enum ParserError { MissingModifier, MissingBracket, // ... } // Usage throw new ParserException(ParserError.MissingModifier);</code> </pre> <br><p>  Kode yang melindungi panggilan parser tidak peduli mengapa gagal parsing: tertarik pada kesalahan seperti itu.  Namun, jika penyebab kegagalan menjadi penting, pengguna selalu bisa mendapatkan kode kesalahan dari properti <code>ErrorCode</code> .  Dan Anda benar-benar tidak perlu mencari kata-kata yang diperlukan dalam substring <code>Message</code> . </p><br><p>  Jika kami tidak memilih untuk menggunakan kembali, kami dapat membuat jenis pengecualian untuk setiap situasi.  Di satu sisi, ini terdengar logis: satu jenis kesalahan - satu jenis pengecualian.  Namun, jangan berlebihan: memiliki terlalu banyak jenis pengecualian akan menyebabkan masalah menangkapnya karena kode metode panggilan akan kelebihan beban dengan blok <code>catch</code> .  Karena itu perlu memproses semua jenis pengecualian yang ingin Anda sampaikan.  Kerugian lain adalah murni arsitektur.  Jika Anda tidak menggunakan pengecualian, Anda membingungkan mereka yang akan menggunakan pengecualian ini: mereka mungkin memiliki banyak kesamaan tetapi akan ditangkap secara terpisah. </p><br><p>  Namun, ada skenario hebat untuk memperkenalkan tipe terpisah untuk situasi tertentu.  Misalnya, ketika kesalahan mempengaruhi bukan seluruh entitas, tetapi metode tertentu.  Maka jenis kesalahan ini harus mengambil tempat sedemikian dalam hierarki warisan sehingga tidak ada yang akan berpikir untuk menangkapnya bersama dengan sesuatu yang lain: misalnya, melalui cabang warisan yang terpisah. </p><br><p>  Juga, jika Anda menggabungkan kedua pendekatan ini, Anda bisa mendapatkan seperangkat instrumen yang kuat untuk bekerja dengan sekelompok kesalahan: Anda dapat memperkenalkan jenis abstrak umum dan mewarisi kasus-kasus tertentu dari itu.  Kelas dasar (tipe umum kami) harus mendapatkan properti abstrak, yang dirancang untuk menyimpan kode kesalahan sementara pewaris akan menentukan kode ini dengan menimpa properti ini. </p><br><pre> <code class="plaintext hljs">public abstract class ParserException { public abstract ParserError ErrorCode { get; } public override string Message { get { return Resources.GetResource($"{nameof(ParserException)}{Enum.GetName(typeof(ParserError), ErrorCode)}"); } } } public enum ParserError { MissingModifier, MissingBracket } public class MissingModifierParserException : ParserException { public override ParserError ErrorCode { get; } =&gt; ParserError.MissingModifier; } public class MissingBracketParserException : ParserException { public override ParserError ErrorCode { get; } =&gt; ParserError.MissingBracket; } // Usage throw new MissingModifierParserException(ParserError.MissingModifier);</code> </pre> <br><p>  Dengan menggunakan pendekatan ini, kami mendapatkan beberapa properti indah: </p><br><ul><li>  di satu sisi, kami terus menangkap pengecualian menggunakan tipe dasar (umum); </li><li>  di sisi lain, bahkan menangkap pengecualian dengan tipe dasar ini kita masih dapat mengidentifikasi situasi tertentu; </li><li>  ditambah, kita dapat menangkap pengecualian melalui tipe tertentu dan bukan tipe dasar tanpa menggunakan struktur datar kelas. </li></ul><br><p>  Saya pikir ini sangat nyaman. </p><br><h3 id="based-on-belonging-to-a-specific-group-of-behavioral-situations">  Didasarkan pada milik kelompok situasi perilaku tertentu </h3><br><p>  Kesimpulan apa yang bisa kita buat berdasarkan alasan sebelumnya?  Mari kita coba mendefinisikannya. </p><br><p>  Pertama-tama, mari kita putuskan apa artinya suatu situasi?  Biasanya, kita berbicara tentang kelas dan objek dalam hal entitas dengan keadaan internal dan kita dapat melakukan tindakan pada entitas ini.  Dengan demikian, jenis situasi perilaku pertama termasuk tindakan pada beberapa entitas.  Selanjutnya, jika kita melihat pada grafik objek dari luar kita akan melihat bahwa itu secara logis direpresentasikan sebagai kombinasi dari kelompok-kelompok fungsional: kelompok pertama berurusan dengan caching, yang kedua bekerja dengan basis data, yang ketiga melakukan perhitungan matematis.  Lapisan yang berbeda dapat melewati semua grup ini, misalnya lapisan status internal yang masuk, proses logging, dan penelusuran panggilan metode.  Lapisan dapat mencakup beberapa kelompok fungsional.  Misalnya, bisa ada lapisan model, lapisan pengontrol dan lapisan presentasi.  Kelompok-kelompok ini dapat berada dalam satu majelis atau dalam majelis yang berbeda, tetapi masing-masing kelompok dapat menciptakan situasi yang luar biasa. </p><br><p>  Jadi, kita dapat membangun hierarki untuk jenis situasi luar biasa berdasarkan pada kepemilikan jenis ini ke satu atau lain kelompok atau lapisan.  Dengan demikian, kami memungkinkan kode tangkapan untuk dengan mudah menavigasi di antara jenis-jenis ini dalam hierarki. </p><br><p>  Mari kita periksa kode berikut: </p><br><pre> <code class="plaintext hljs">namespace JetFinance { namespace FinancialPipe { namespace Services { namespace XmlParserService { } namespace JsonCompilerService { } namespace TransactionalPostman { } } } namespace Accounting { /* ... */ } }</code> </pre><br><p>  Seperti apa itu?  Saya pikir namespace adalah cara sempurna untuk secara alami mengelompokkan jenis-jenis pengecualian berdasarkan situasi perilaku: segala sesuatu yang dimiliki kelompok tertentu harus tetap ada, termasuk pengecualian.  Selain itu, ketika Anda mendapatkan pengecualian tertentu, Anda akan melihat nama jenisnya dan juga namespace-nya yang akan menentukan grup miliknya.  Apakah Anda ingat penggunaan kembali yang buruk dari <code>InvalidDataException</code> yang sebenarnya didefinisikan dalam <code>System.IO</code> namespace?  Fakta bahwa itu milik namespace ini berarti jenis pengecualian ini dapat dilempar dari kelas-kelas yang ada dalam <code>System.IO</code> namespace atau yang lebih bersarang.  Tetapi pengecualian yang sebenarnya dilemparkan dari ruang yang sama sekali berbeda, membingungkan seseorang yang menangani masalah ini.  Namun, jika Anda menempatkan jenis pengecualian dan jenis yang membuang pengecualian ini di ruang nama yang sama, Anda menjaga arsitektur tipe konsisten dan memudahkan pengembang untuk memahami alasan apa yang terjadi. </p><br><p>  Apa cara kedua untuk pengelompokan pada level kode?  Warisan: </p><br><pre> <code class="plaintext hljs">public abstract class LoggerExceptionBase : Exception { protected LoggerException(..); } public class IOLoggerException : LoggerExceptionBase { internal IOLoggerException(..); } public class ConfigLoggerException : LoggerExceptionBase { internal ConfigLoggerException(..); }</code> </pre><br><p>  Perhatikan bahwa untuk entitas aplikasi biasa, mereka mewarisi perilaku dan data serta tipe grup yang dimiliki oleh <em>satu grup entitas</em> .  Namun, sebagai pengecualian, mereka mewarisi dan dikelompokkan berdasarkan <em>satu kelompok situasi</em> , karena esensi pengecualian bukanlah suatu entitas tetapi masalah. </p><br><p>  Menggabungkan dua metode pengelompokan ini kita dapat membuat kesimpulan berikut: </p><br><ul><li>  harus ada jenis dasar pengecualian di dalam <code>Assembly</code> yang akan dilemparkan oleh majelis ini.  Jenis pengecualian ini harus berada dalam root namespace majelis.  Ini akan menjadi lapisan pertama pengelompokan. </li><li>  lebih lanjut, bisa ada satu atau beberapa ruang nama di dalam sebuah majelis.  Masing-masing dari mereka membagi rakitan menjadi zona fungsional, mendefinisikan kelompok-kelompok situasi, yang muncul dalam rakitan ini.  Ini mungkin zona pengendali, entitas basis data, algoritma pemrosesan data, dll.  Bagi kami, ruang nama ini berarti jenis pengelompokan berdasarkan fungsinya.  Namun, dalam hal pengecualian, mereka dikelompokkan berdasarkan masalah dalam majelis yang sama; </li><li>  pengecualian harus diwarisi dari jenis di namespace tingkat atas yang sama.  Ini memastikan bahwa pengguna akhir akan memahami situasi dengan jelas dan tidak akan menangkap pengecualian berbasis tipe yang <em>salah</em> .  Akui, akan aneh untuk menangkap <code>global::Finiki.Logistics.OhMyException</code> dengan <code>catch(global::Legacy.LoggerExeption exception)</code> , sedangkan kode berikut terlihat sangat sesuai: </li></ul><br><pre> <code class="plaintext hljs">namespace JetFinance.FinancialPipe { namespace Services.XmlParserService { public class XmlParserServiceException : FinancialPipeExceptionBase { // .. } public class Parser { public void Parse(string input) { // .. } } } public abstract class FinancialPipeExceptionBase : Exception { } } using JetFinance.FinancialPipe; using JetFinance.FinancialPipe.Services.XmlParserService; var parser = new Parser(); try { parser.Parse(); } catch (XmlParserServiceException exception) { // Something is wrong in the parser } catch (FinancialPipeExceptionBase exception) { // Something else is wrong. Looks critical because we don't know the real reason }</code> </pre><br><p>  Di sini, kode pengguna memanggil metode pustaka yang, seperti kita ketahui, dapat melempar <code>XmlParserServiceException</code> dalam beberapa situasi.  Dan, seperti yang kita ketahui, pengecualian ini merujuk ke namespace yang diwariskan <code>JetFinance.FinancialPipe.FinancialPipeExceptionBase</code> , yang berarti bahwa mungkin ada beberapa pengecualian lain - kali ini <code>XmlParserService</code> hanya membuat satu pengecualian tetapi pengecualian lain mungkin muncul di masa depan.  Karena kami memiliki konvensi untuk membuat jenis pengecualian, kami tahu dari entitas mana pengecualian baru ini akan diwarisi dan memasukkan <code>catch</code> mencakup sebelumnya.  Itu memungkinkan kita untuk melewati semua hal yang tidak relevan bagi kita. </p><br><p>  Bagaimana cara membangun hierarki jenis seperti itu? </p><br><ul><li>  Pertama-tama, kita harus membuat kelas dasar untuk domain.  Sebut saja kelas basis domain.  Dalam hal ini, domain adalah kata yang mencakup sejumlah majelis, menggabungkannya berdasarkan beberapa fitur: logging, business-logic, UI.  Maksud saya zona fungsional aplikasi yang sebesar mungkin. </li><li>  Selanjutnya, kita harus memperkenalkan kelas dasar tambahan untuk pengecualian yang harus ditangkap: semua pengecualian yang akan ditangkap menggunakan kata kunci <code>catch</code> akan diwarisi dari kelas dasar ini; </li><li>  Semua pengecualian yang mengindikasikan kesalahan fatal harus diwarisi langsung dari kelas basis domain.  Dengan demikian kami akan memisahkan mereka dari yang tertangkap pada tingkat arsitektur; <br>  - Membagi domain menjadi area fungsional berdasarkan ruang nama dan mendeklarasikan tipe dasar pengecualian yang akan dilempar dari setiap area.  Di sini perlu untuk menggunakan akal sehat: jika aplikasi memiliki tingkat tinggi namespace nesting, Anda tidak harus melakukan tipe dasar untuk setiap level nesting.  Namun, jika ada percabangan pada tingkat bersarang ketika satu kelompok pengecualian pergi ke satu namespace dan grup lain pergi ke namespace lain, perlu menggunakan dua tipe dasar untuk setiap subkelompok; </li><li>  Pengecualian khusus harus diwarisi dari jenis pengecualian yang termasuk dalam area fungsional </li><li>  Jika sekelompok pengecualian khusus dapat digabungkan, Anda perlu melakukannya dalam satu tipe dasar lagi: sehingga Anda dapat menangkapnya dengan lebih mudah; </li><li>  Jika Anda mengira grup akan lebih sering tertangkap menggunakan kelas dasar, perkenalkan Mode Campuran dengan ErrorCode. </li></ul><br><h3 id="based-on-the-source-of-an-error">  Berdasarkan sumber kesalahan </h3><br><p>  Sumber kesalahan dapat menjadi dasar lain untuk menggabungkan pengecualian dalam grup.  Misalnya, jika Anda mendesain perpustakaan kelas, hal-hal berikut ini dapat membentuk kelompok sumber: </p><br><ul><li>  panggilan kode tidak aman dengan kesalahan.  Situasi ini dapat ditangani dengan membungkus pengecualian atau kode kesalahan dalam jenis pengecualian sendiri sambil menyimpan data yang dikembalikan (misalnya kode kesalahan asli) di properti publik pengecualian; </li><li>  panggilan kode oleh dependensi eksternal, yang telah melemparkan pengecualian yang tidak dapat ditangkap oleh perpustakaan kami karena mereka berada di luar tanggung jawabnya.  Grup ini dapat menyertakan pengecualian dari metode entitas yang diterima sebagai parameter metode saat ini atau pengecualian dari konstruktor kelas yang metode ini disebut ketergantungan eksternal.  Sebagai contoh, metode kelas kami telah memanggil metode kelas lain, contohnya dikembalikan melalui parameter metode lain.  Jika pengecualian menunjukkan bahwa kami adalah sumber masalah, kami harus membuat pengecualian sendiri sambil mempertahankan yang asli di <code>InnerExcepton</code> .  Namun, jika kita memahami bahwa masalahnya disebabkan oleh dependensi eksternal, kita mengabaikan pengecualian ini sebagai bagian dari grup dependensi eksternal di luar kendali kita; </li><li>  kode kita sendiri yang secara tidak sengaja dimasukkan ke dalam kondisi yang tidak konsisten.  Contoh yang baik adalah parsing teks - tidak ada dependensi eksternal, tidak ada transfer ke dunia yang <code>unsafe</code> , tetapi masalah parsing terjadi. </li></ul><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Bab ini diterjemahkan dari bahasa Rusia bersama oleh penulis dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penerjemah profesional</a> .  Anda dapat membantu kami dengan terjemahan dari bahasa Rusia atau Inggris ke bahasa lain, terutama ke bahasa Cina atau Jerman. <br><br>  Juga, jika Anda ingin berterima kasih kepada kami, cara terbaik yang dapat Anda lakukan adalah memberi kami bintang di github atau untuk repositori garpu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id454882/">https://habr.com/ru/post/id454882/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id454872/index.html">Space Invaders: sekarang dalam 512 byte (Assembler x86)</a></li>
<li><a href="../id454874/index.html">Sedikit tentang multitasking dalam mikrokontroler</a></li>
<li><a href="../id454876/index.html">Tentang merancang sistem kemampuan karakter yang fleksibel dalam game</a></li>
<li><a href="../id454878/index.html">Kami mempelajari MITER ATT & CK. Matriks Seluler: Akses Perangkat. Bagian 3</a></li>
<li><a href="../id454880/index.html">“Off-season” dalam kehidupan freelancer: bagaimana cara bertahan dan bertahan?</a></li>
<li><a href="../id454884/index.html">Penamaan Tes yang Dapat Dibaca dalam JS dan Pola Perilaku</a></li>
<li><a href="../id454886/index.html">Duduk di hati. Mengapa pengangkatan tumor hati merupakan indikator dari keterampilan ahli bedah yang unggul</a></li>
<li><a href="../id454892/index.html">Moto. Mock aws</a></li>
<li><a href="../id454894/index.html">WWDC 2019 :: apa yang harus dilihat</a></li>
<li><a href="../id454896/index.html">Mengapa saya mengubah freelance ke tim jarak jauh</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>