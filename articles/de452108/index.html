<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚴🏽 🤸🏿 ✍🏼 Docker: harmloser Rat 👼🏻 📿 👩🏿‍🤝‍👩🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In den Kommentaren zu meinem Docker- Artikel : Schlechte Ratschläge gab es viele Anfragen zu erklären, warum die darin beschriebene Docker- Datei so s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Docker: harmloser Rat</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/452108/"><p>  In den Kommentaren zu meinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Docker-</a> Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">: Schlechte Ratschläge</a> gab es viele Anfragen zu erklären, warum die darin beschriebene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Docker-</a> Datei so schrecklich ist. </p><br><p>  <em>Zusammenfassung der vorherigen Serie</em> : Zwei Entwickler in einer schwierigen Frist bilden das Dockerfile.  Dabei kommt Ops Igor Ivanovich zu ihnen.  Das resultierende Dockerfile ist so schlecht, dass die KI kurz vor einem Herzinfarkt steht. </p><br><p><img src="https://habrastorage.org/webt/nl/uj/xm/nlujxmo7chgsgo7dti72jckbk04.jpeg"></p><br><p>  Lassen Sie uns nun herausfinden, was mit dieser Docker-Datei nicht stimmt. </p><br><p>  Es ist also eine Woche vergangen. </p><a name="habracut"></a><br><p>  Dev Petya trifft sich im Speisesaal mit einer Tasse Kaffee mit Ops Igor Ivanovich. </p><br><p>  P: Igor Ivanovich, bist du sehr beschäftigt?  Ich würde gerne herausfinden, wo wir es vermasselt haben. </p><br><p>  AI: Das ist gut, man trifft nicht oft Entwickler, die sich für den Betrieb interessieren. <br>  Lassen Sie uns zunächst einige Dinge vereinbaren: </p><br><ol><li>  Docker-Ideologie: ein Container - ein Prozess. </li><li>  Je kleiner der Behälter, desto besser. </li><li>  Je mehr Cache belegt ist, desto besser. </li></ol><br><p>  P: Und warum sollte es einen Prozess in einem Container geben? </p><br><p>  AI: Docker überwacht beim Starten des Containers den Status des Prozesses mit pid 1. Wenn der Prozess stirbt, versucht Docker, den Container neu zu starten.  Angenommen, in Ihrem Container werden mehrere Anwendungen ausgeführt oder die Hauptanwendung wird nicht mit pid 1 ausgeführt. Wenn der Prozess abbricht, weiß Docker nichts davon. </p><br><p>  Wenn Sie keine weiteren Fragen haben, zeigen Sie Ihre Docker-Datei. </p><br><p>  Und Petja zeigte: </p><br><pre><code class="plaintext hljs">FROM ubuntu:latest #    COPY ./ /app WORKDIR /app #    RUN apt-get update #   RUN apt-get upgrade #    RUN apt-get -y install libpq-dev imagemagick gsfonts ruby-full ssh supervisor #  bundler RUN gem install bundler #  nodejs     RUN curl -sL https://deb.nodesource.com/setup_9.x | sudo bash - RUN apt-get install -y nodejs #   RUN bundle install --without development test --path vendor/bundle #     RUN rm -rf /usr/local/bundle/cache/*.gem RUN apt-get clean RUN rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/* RUN rake assets:precompile #  ,   ,    . CMD ["/app/init.sh"]</code> </pre> <br><p>  AI: Oh, lass es uns in der richtigen Reihenfolge klären.  Beginnen wir mit der ersten Zeile: </p><br><pre> <code class="plaintext hljs">FROM ubuntu:latest</code> </pre> <br><p>  Sie nehmen das <code>latest</code> Tag.  Die Verwendung des <code>latest</code> Tags führt zu unvorhersehbaren Konsequenzen.  Stellen Sie sich vor, der Image-Betreuer erstellt eine neue Version des Images mit einer anderen Softwareliste. Dieses Image erhält das neueste Tag.  Und im besten Fall hört Ihr Container auf zu sammeln, und im schlimmsten Fall fangen Sie Fehler, die vorher nicht existierten. </p><br><p>  Sie nehmen ein Bild mit einem vollständigen Betriebssystem mit viel unnötiger Software auf, wodurch der Container aufgeblasen wird.  Und je mehr Software, desto mehr Lücken und Schwachstellen. </p><br><p>  Je größer das Image, desto mehr Speicherplatz benötigt es auf dem Host und in der Registrierung (speichern Sie die Images irgendwo)? </p><br><p>  P: Ja, natürlich haben wir eine Registrierung, und Sie haben sie eingerichtet. </p><br><p>  II: Also, wovon spreche ich? .. Oh ja, Volumen ... Die Netzwerklast wächst ebenfalls.  Für ein einzelnes Image ist dies unsichtbar, aber bei kontinuierlicher Montage, Tests und Bereitstellung ist dies spürbar.  Und wenn Sie in AWS keinen Gottesmodus haben, erhalten Sie auch ein Space-Konto. </p><br><p>  Daher müssen Sie das am besten geeignete Bild mit der genauen Version und der minimalen Software auswählen.  Nehmen Sie zum Beispiel: <code>FROM ruby:2.5.5-stretch</code> </p><br><p>  P: Oh, ich verstehe.  Und wie und wo sehen Sie die verfügbaren Bilder?  Wie kann ich verstehen, welches ich brauche? </p><br><p>  AI: Normalerweise werden Bilder von einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dockhub aufgenommen</a> , nicht mit einem Pornhub verwechseln :).  Es gibt normalerweise mehrere Baugruppen für ein Bild: <br>  <strong>Alpine</strong> : Images werden auf einem minimalistischen Linux-Image mit nur 5 MB kompiliert.  Das Minus: Es wurde mit einer eigenen Implementierung von libc erstellt, Standardpakete funktionieren nicht.  Das Finden und Installieren des richtigen Pakets nimmt viel Zeit in Anspruch. <br>  <strong>Scratch</strong> : Basisbild, das nicht zum Erstellen anderer Bilder verwendet wird.  Es ist ausschließlich dazu gedacht, binäre, vorbereitete Daten auszuführen.  Ideal zum Ausführen von Binäranwendungen, die alles enthalten, was Sie benötigen, z. B. Go-Anwendungen. <br>  Basierend auf jedem Betriebssystem wie Ubuntu oder Debian.  Nun, hier, denke ich, muss ich es nicht erklären. </p><br><p>  II: Jetzt müssen wir alles extra setzen.  Pakete und reinigen Sie die Caches.  Und sofort können Sie <em>apt-get Upgrade</em> werfen.  Andernfalls werden mit jeder Baugruppe trotz des festen Tags des Basisbilds unterschiedliche Bilder erhalten.  Das Aktualisieren von Paketen in einem Image ist Aufgabe des Betreuers und wird von einer Tag-Änderung begleitet. </p><br><p>  P: Ja, ich habe es versucht, es stellte sich so heraus: </p><br><pre> <code class="plaintext hljs">WORKDIR /app COPY ./ /app RUN curl -sL https://deb.nodesource.com/setup_9.x | bash - \ &amp;&amp; apt-get -y install libpq-dev imagemagick gsfonts ruby-full ssh supervisor nodejs \ &amp;&amp; gem install bundler \ &amp;&amp; bundle install --without development test --path vendor/bundle RUN rm -rf /usr/local/bundle/cache/*.gem \ &amp;&amp; apt-get clean \ &amp;&amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*</code> </pre> <br><p>  II: Nicht schlecht, aber es gibt auch etwas zu arbeiten.  Schauen Sie, hier ist dieser Befehl: </p><br><pre> <code class="plaintext hljs">RUN rm -rf /usr/local/bundle/cache/*.gem \ &amp;&amp; apt-get clean \ &amp;&amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*</code> </pre> <br><p>  ... löscht keine Daten aus dem endgültigen Bild, sondern erstellt nur eine zusätzliche Ebene ohne diese Daten.  Richtig so: </p><br><pre> <code class="plaintext hljs">RUN curl -sL https://deb.nodesource.com/setup_9.x | bash - \ &amp;&amp; apt-get -y install libpq-dev imagemagick gsfonts nodejs \ &amp;&amp; gem install bundler \ &amp;&amp; bundle install --without development test --path vendor/bundle \ &amp;&amp; rm -rf /usr/local/bundle/cache/*.gem \ &amp;&amp; apt-get clean \ &amp;&amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*</code> </pre> <br><p>  Das ist aber noch nicht alles.  Was hast du da, Ruby?  Dann ist es nicht notwendig, das gesamte Projekt zu Beginn zu kopieren.  Kopieren Sie einfach Gemfile und Gemfile.lock. </p><br><p>  Bei diesem Ansatz wird die Bundle-Installation nicht für jede Änderung an der Quelle ausgeführt, sondern nur, wenn sich Gemfile oder Gemfile.lock geändert haben. </p><br><p>  Dieselben Methoden funktionieren für andere Sprachen mit dem Abhängigkeitsmanager, z. B. npm, pip, composer und andere, basierend auf der Datei mit der Liste der Abhängigkeiten. </p><br><p>  Und schließlich, erinnern Sie sich, am Anfang habe ich über die Docker-Ideologie „Ein Container - ein Prozess“ gesprochen?  Dies bedeutet, dass kein Supervisor benötigt wird.  Installieren Sie systemd aus den gleichen Gründen auch nicht.  In der Tat ist Docker selbst ein Supervisor.  Wenn Sie versuchen, mehrere Prozesse darin auszuführen, ist dies wie das Starten mehrerer Anwendungen in einem Supervisor-Prozess. <br>  Beim Zusammenstellen erstellen Sie ein einzelnes Image und führen dann die gewünschte Anzahl von Containern aus, sodass jeder Prozess einen Prozess hat. </p><br><p>  Aber dazu später mehr. </p><br><p>  P: Es scheint zu verstehen.  Sehen Sie, was passiert: </p><br><pre> <code class="plaintext hljs">FROM ruby:2.5.5-stretch WORKDIR /app COPY Gemfile* /app RUN curl -sL https://deb.nodesource.com/setup_9.x | bash - \ &amp;&amp; apt-get -y install libpq-dev imagemagick gsfonts nodejs \ &amp;&amp; gem install bundler \ &amp;&amp; bundle install --without development test --path vendor/bundle \ &amp;&amp; rm -rf /usr/local/bundle/cache/*.gem \ &amp;&amp; apt-get clean \ &amp;&amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/* COPY . /app RUN rake assets:precompile CMD ["bundle”, “exec”, “passenger”, “start"]</code> </pre> <br><p>  Werden die Dämonen neu definiert, wenn der Container startet? </p><br><p>  AI: Ja, das stimmt.  Sie können übrigens sowohl CMD als auch ENTRYPOINT verwenden.  Und um zu verstehen, was der Unterschied ist, sind dies Ihre Hausaufgaben.  Zu diesem Thema gibt es in Habré einen guten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> . </p><br><p>  Also komm schon.  Sie laden die Datei herunter, um den Knoten zu installieren, es gibt jedoch keine Garantie dafür, dass er das enthält, was Sie benötigen.  Es ist notwendig, eine Validierung hinzuzufügen.  Zum Beispiel so: </p><br><pre> <code class="plaintext hljs">RUN curl -sL https://deb.nodesource.com/setup_9.x &gt; setup_9.x \ &amp;&amp; echo "958c9a95c4974c918dca773edf6d18b1d1a41434 setup_9.x" | sha1sum -c - \ &amp;&amp; bash setup_9.x \ &amp;&amp; rm -rf setup_9.x \ &amp;&amp; apt-get -y install libpq-dev imagemagick gsfonts nodejs \ &amp;&amp; gem install bundler \ &amp;&amp; bundle install --without development test --path vendor/bundle \ &amp;&amp; rm -rf /usr/local/bundle/cache/*.gem \ &amp;&amp; apt-get clean \ &amp;&amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*</code> </pre> <br><p>  Mit der Prüfsumme können Sie überprüfen, ob Sie die richtige Datei heruntergeladen haben. </p><br><p>  P: Wenn sich die Datei ändert, funktioniert die Assembly nicht. </p><br><p>  II: Ja, und seltsamerweise ist dies auch ein Plus.  Sie werden feststellen, dass sich die Datei geändert hat, und Sie können sehen, was dort geändert wurde.  Man weiß nie, fügten sie beispielsweise ein Skript hinzu, das alles entfernt, was es erreicht, oder eine Hintertür macht. </p><br><p>  P: Danke.  Es stellt sich heraus, dass die endgültige Docker-Datei folgendermaßen aussehen wird: </p><br><pre> <code class="plaintext hljs">FROM ruby:2.5.5-stretch WORKDIR /app COPY Gemfile* /app RUN curl -sL https://deb.nodesource.com/setup_9.x &gt; setup_9.x \ &amp;&amp; echo "958c9a95c4974c918dca773edf6d18b1d1a41434 setup_9.x" | sha1sum -c - \ &amp;&amp; bash setup_9.x \ &amp;&amp; rm -rf setup_9.x \ &amp;&amp; apt-get -y install libpq-dev imagemagick gsfonts nodejs \ &amp;&amp; gem install bundler \ &amp;&amp; bundle install --without development test --path vendor/bundle \ &amp;&amp; rm -rf /usr/local/bundle/cache/*.gem \ &amp;&amp; apt-get clean \ &amp;&amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/* COPY . /app RUN rake assets:precompile CMD ["bundle”, “exec”, “passenger”, “start"]</code> </pre> <br><p>  P: Igor Ivanovich, danke für die Hilfe.  Es ist Zeit für mich zu rennen, ich muss für heute 10 weitere Commits machen. </p><br><p>  Igor Iwanowitsch, der seinen hastigen Kollegen mit einem Blick aufhält, trinkt einen Schluck starken Kaffee.  Nachdem er einige Sekunden über die 99,9% SLA und den Code ohne Fehler nachgedacht hat, stellt er eine Frage. </p><br><p>  AI: Und wo bewahren Sie die Protokolle auf? </p><br><p>  P: Natürlich in Production.log.  Übrigens, ja, wie können wir ohne ssh darauf zugreifen? </p><br><p>  II: Wenn Sie sie in den Dateien belassen, wurde bereits eine Lösung für Sie erfunden.  Mit dem Befehl docker exec können Sie jeden Befehl in einem Container ausführen.  Sie können beispielsweise eine Katze für Protokolle erstellen.  Mit dem Schalter <em>-it</em> und dem Ausführen von bash (sofern es im Container installiert ist) erhalten Sie interaktiven Zugriff auf den Container. </p><br><p>  Sie sollten jedoch keine Protokolle in Dateien speichern.  Zumindest führt dies zu einem unkontrollierten Wachstum des Containers, aber niemand dreht die Protokolle.  Alle Protokolle müssen in stdout geworfen werden.  Dort können Sie sie bereits mit dem <em>Befehl docker logs sehen</em> . </p><br><p>  P: Igor Ivanovich, aber können die Protokolle als Benutzerdaten in das bereitgestellte Verzeichnis auf dem physischen Knoten gestellt werden? </p><br><p>  AI: Es ist gut, dass Sie nicht vergessen haben, die auf die Knotenfestplatte heruntergeladenen Daten zu entfernen.  Bei Protokollen ist dies ebenfalls möglich. Denken Sie daran, die Rotation einzurichten. <br>  Alles was du laufen kannst. </p><br><p>  P: Igor Ivanovich, aber raten Sie, was zu lesen? </p><br><p>  AI: Lesen Sie zuerst die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Empfehlungen der Entwickler von Docker</a> , kaum jemand kennt Docker besser als sie. </p><br><p>  Und wenn Sie durch die Praxis gehen wollen, gehen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">intensiv</a> .  Eine Theorie ohne Praxis ist schließlich tot. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452108/">https://habr.com/ru/post/de452108/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452092/index.html">In-App-Updates: Beschleunigen von Android-Anwendungsupdates</a></li>
<li><a href="../de452094/index.html">.NET: Tools zum Arbeiten mit Multithreading und Asynchronität. Teil 1</a></li>
<li><a href="../de452098/index.html">Protokolle des Frontend-Entwicklers Habr: Refactor und Reflex</a></li>
<li><a href="../de452102/index.html">Fotospiel für Drohnenliebhaber: kurz über AirSelfie 2</a></li>
<li><a href="../de452106/index.html">Wir laden Redner zum Sommer-DIY-Meeting am 16. Juni 2019 ein</a></li>
<li><a href="../de452110/index.html">Automatisieren Sie den Festplattenaustausch mit Ansible</a></li>
<li><a href="../de452112/index.html">CRM ++</a></li>
<li><a href="../de452114/index.html">HolyJS 2019: Nachbesprechung von SEMrush (Teil 1)</a></li>
<li><a href="../de452116/index.html">Indizes in PostgreSQL - 8 (RUM)</a></li>
<li><a href="../de452118/index.html">Wissenschaftler bricht den Code des mysteriösen Manuskripts von Voynich</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>