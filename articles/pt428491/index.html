<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéõÔ∏è üßõüèæ üèïÔ∏è Otimiza√ß√£o proativa do desempenho do banco de dados Oracle ‚õìÔ∏è üëò ü¶ï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A primeira coisa que encontramos quando falamos em otimiza√ß√£o proativa √© que n√£o se sabe o que precisa ser otimizado. "Fa√ßa isso, eu n√£o sei o que." 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Otimiza√ß√£o proativa do desempenho do banco de dados Oracle</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/428491/">  A primeira coisa que encontramos quando falamos em otimiza√ß√£o proativa √© que n√£o se sabe o que precisa ser otimizado.  "Fa√ßa isso, eu n√£o sei o que." <br><br><ul><li>  N√£o h√° algoritmo cl√°ssico. </li><li>  O problema ainda n√£o surgiu (desconhecido), e s√≥ podemos adivinhar onde pode estar. </li><li>  Precisamos encontrar alguns pontos fracos em potencial no sistema. </li><li>  Tente otimizar o desempenho da consulta nesses locais. </li></ul><br><h3>  Os principais objetivos da otimiza√ß√£o proativa <br></h3><br>  As principais tarefas da otimiza√ß√£o proativa diferem das tarefas da otimiza√ß√£o reativa e s√£o as seguintes: <br><br><ul><li>  livrar-se de gargalos no banco de dados; </li><li>  diminui√ß√£o no consumo de recursos do banco de dados. </li></ul><br>  O √∫ltimo momento √© o mais fundamental.  No caso de otimiza√ß√£o reativa, n√£o temos a tarefa de reduzir o consumo de recursos como um todo, mas apenas a tarefa de levar o tempo de resposta da funcionalidade para dentro dos limites aceit√°veis. <br><br><img src="https://habrastorage.org/webt/zl/eg/b5/zlegb5nfhfvxy9bajfsxkv3u7ao.png"><br><br>  Se voc√™ trabalha com servidores de batalha, tem uma boa id√©ia do que significam incidentes de desempenho.  Voc√™ precisa sair de tudo e resolver rapidamente o problema.  O RNKO Payment Center LLC trabalha com muitos agentes e √© muito importante que eles tenham o m√≠nimo de problemas poss√≠vel.  Alexander Makarov, da HighLoad ++ Siberia, contou o que foi feito para reduzir significativamente o n√∫mero de incidentes de desempenho.  A otimiza√ß√£o proativa veio em socorro.  E por que e como √© produzido em um servidor de combate, leia abaixo. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/r_/kt/zz/r_ktzzegcm2xca_nrh4yusjtpqy.png"><br><br>  <strong>Sobre o Orador:</strong> Alexander Makarov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">AL_IG_Makarov</a> ), Administrador L√≠der do Banco de Dados Oracle, LLC RNCO Payment Center.  Apesar da posi√ß√£o, h√° muito pouca administra√ß√£o como tal, as principais tarefas est√£o relacionadas √† manuten√ß√£o do complexo e seu desenvolvimento, em particular, a solu√ß√£o de problemas de desempenho. <br><br><h1>  A otimiza√ß√£o em um banco de dados de combate √© proativa? <br></h1><br>  Primeiro, trataremos dos termos aos quais este relat√≥rio se refere como "otimiza√ß√£o proativa de desempenho".  √Äs vezes, voc√™ pode conhecer o ponto de vista de que a otimiza√ß√£o proativa ocorre quando a an√°lise das √°reas problem√°ticas √© realizada antes mesmo do lan√ßamento do aplicativo.  Por exemplo, descobrimos que algumas consultas n√£o funcionam da melhor maneira, pois n√£o h√° √≠ndice suficiente ou a consulta usa um algoritmo ineficiente, e esse trabalho √© feito em servidores de teste. <br><br>  No entanto, n√≥s da RNCO fizemos esse projeto <strong>em servidores de batalha</strong> .  Muitas vezes ouvi: ‚ÄúComo assim?  Voc√™ faz isso em um servidor de combate - isso significa que n√£o √© uma otimiza√ß√£o proativa do desempenho! ‚Äù  Aqui precisamos lembrar a abordagem cultivada no ITIL.  Do ponto de vista da ITIL, temos: <br><br><ul><li>  incidentes de desempenho s√£o o que j√° aconteceu; </li><li>  as medidas que tomamos para impedir a ocorr√™ncia de incidentes de desempenho. </li></ul><br>  Nesse sentido, nossas a√ß√µes s√£o proativas.  Apesar de estarmos resolvendo o problema em um servidor de combate, o problema em si ainda n√£o surgiu: o incidente n√£o ocorreu, n√£o corremos e n√£o tentamos resolv√™-lo em pouco tempo. <br><br>  Portanto, neste relat√≥rio, proatividade √© entendida como <strong>proatividade no sentido de ITIL</strong> , resolvemos o problema antes que ocorra um incidente de desempenho. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/y68RLr825VE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1>  Ponto de refer√™ncia <br></h1><br>  O "Centro de Pagamento" da RNKO atende a 2 grandes sistemas: <br><br><ul><li>  RBS-Banco de varejo; </li><li>  Banco CFT. </li></ul><br>  A natureza da carga nesses sistemas √© mista (DSS + OLTP): h√° algo que funciona muito rapidamente, h√° relat√≥rios, h√° cargas m√©dias. <br><br>  Somos confrontados com o fato de que n√£o com muita frequ√™ncia, mas com uma certa frequ√™ncia, ocorreram incidentes de desempenho.  Quem trabalha com servidores de batalha imagina o que √©.  Isso significa que voc√™ precisa encerrar tudo e resolver rapidamente o problema, porque, nesse momento, o cliente n√£o pode receber o servi√ßo, algo ou n√£o funciona, ou funciona muito devagar. <br><br>  Como muitos agentes e clientes est√£o ligados √† nossa organiza√ß√£o, isso √© muito importante para n√≥s.  Se n√£o conseguirmos resolver rapidamente os incidentes de desempenho, nossos clientes sofrer√£o de uma maneira ou de outra.  Por exemplo, eles n√£o poder√£o reabastecer um cart√£o ou fazer uma transfer√™ncia.  Portanto, nos perguntamos o que poderia ser feito para eliminar at√© mesmo esses incidentes de desempenho pouco frequentes.  Para trabalhar em um modo em que voc√™ precise largar tudo e resolver um problema - isso n√£o est√° totalmente correto.  Usamos sprints e elaboramos um plano de trabalho.  A presen√ßa de incidentes de desempenho tamb√©m √© um desvio do plano de trabalho. <br><br>  Algo deve ser feito com isso! <br><br><h1>  Abordagens de otimiza√ß√£o <br></h1><br>  Pensamos e chegamos a entender a tecnologia da otimiza√ß√£o proativa.  Mas antes de falar sobre otimiza√ß√£o proativa, devo dizer algumas palavras sobre a otimiza√ß√£o reativa cl√°ssica. <br><br><h2>  Otimiza√ß√£o reativa <br></h2><br>  O cen√°rio √© simples, existe um servidor de combate no qual algo aconteceu: eles lan√ßaram um relat√≥rio, os clientes recebem instru√ß√µes, neste momento h√° atividade em andamento no banco de dados e, de repente, algu√©m decidiu atualizar algum tipo de diret√≥rio volumoso.  O sistema come√ßa a desacelerar.  Nesse momento, o cliente chega e diz: "Eu n√£o posso fazer isso ou aquilo" - precisamos encontrar uma raz√£o pela qual ele n√£o pode fazer isso. <br><br>  <strong>Algoritmo de a√ß√£o cl√°ssico:</strong> <br><br><ol><li>  Reproduza o problema. </li><li>  Localize o ponto do problema. </li><li>  Otimize o local do problema. </li></ol><br>  Dentro da estrutura da abordagem reativa, a tarefa principal n√£o √© tanto encontrar a causa raiz e elimin√°-la, mas fazer o sistema funcionar normalmente.  A elimina√ß√£o da causa raiz pode ser tratada mais tarde.  O principal √© restaurar rapidamente o servidor para que o cliente possa receber o servi√ßo. <br><br><h3>  Os principais objetivos da otimiza√ß√£o reativa <br></h3><br>  Na otimiza√ß√£o reativa, dois objetivos principais podem ser distinguidos: <br><br>  1. <strong>Diminuir o tempo de resposta</strong> . <br><br>  Uma a√ß√£o, por exemplo, recebendo um relat√≥rio, extrato, transa√ß√£o, deve ser executada por algum tempo agendado.  √â necess√°rio garantir que o tempo de recebimento do servi√ßo retorne aos limites aceit√°veis ‚Äã‚Äãpara o cliente.  Talvez o servi√ßo funcione um pouco mais devagar que o normal, mas para o cliente isso √© aceit√°vel.  Ent√£o acreditamos que o incidente de desempenho foi eliminado e come√ßamos a trabalhar na causa raiz. <br><br>  2. <strong>Um aumento no n√∫mero de objetos processados ‚Äã‚Äãpor unidade de tempo durante o processamento em lote</strong> . <br><br>  Quando o processamento em lote de transa√ß√µes est√° em andamento, √© necess√°rio reduzir o tempo de processamento de um objeto a partir de um lote. <br><br>  <strong>Pr√≥s de uma abordagem reativa:</strong> <br><br>  ‚óè <em>Uma variedade de ferramentas e t√©cnicas</em> √© a principal vantagem de uma abordagem reativa. <br><br>  Usando ferramentas de monitoramento, podemos entender qual √© o problema diretamente: n√£o h√° CPU, threads, mem√≥ria ou o sistema de disco escorregou ou os logs est√£o sendo processados ‚Äã‚Äãlentamente.  Existem muitas ferramentas e t√©cnicas para estudar o problema de desempenho atual no banco de dados Oracle. <br><br>  ‚óè O <em>tempo de resposta desejado</em> √© outra vantagem. <br><br>  No processo desse trabalho, levamos a situa√ß√£o a um tempo de resposta aceit√°vel, ou seja, n√£o tentamos reduzi-la ao valor m√≠nimo, mas atingimos um certo valor e, ap√≥s essa a√ß√£o, terminamos, porque acreditamos que atingimos limites aceit√°veis. <br><br>  <strong>Contras da abordagem reativa:</strong> <br><br><ul><li>  <em>Os incidentes de desempenho permanecem</em> - esse √© o maior ponto negativo da abordagem reativa, porque nem sempre podemos alcan√ßar a causa raiz.  Ela poderia ficar em algum lugar fora do caminho e mentir em algum lugar mais profundo, apesar do fato de termos alcan√ßado um desempenho aceit√°vel. </li></ul><br>  E como lidar com incidentes de desempenho se eles ainda n√£o aconteceram?  Vamos tentar formular como a otimiza√ß√£o proativa pode ser realizada para evitar tais situa√ß√µes. <br><br><h2>  Otimiza√ß√£o proativa <br></h2><br>  A primeira coisa que encontramos √© que n√£o se sabe o que precisa ser otimizado.  "Fa√ßa isso, eu n√£o sei o que." <br><br><ul><li>  N√£o h√° algoritmo cl√°ssico. </li><li>  O problema ainda n√£o surgiu (desconhecido), e s√≥ podemos adivinhar onde pode estar. </li><li>  Precisamos encontrar alguns pontos fracos em potencial no sistema. </li><li>  Tente otimizar o desempenho da consulta nesses locais. </li></ul><br><h3>  Os principais objetivos da otimiza√ß√£o proativa <br></h3><br>  As principais tarefas da otimiza√ß√£o proativa diferem das tarefas da otimiza√ß√£o reativa e s√£o as seguintes: <br><br><ul><li>  livrar-se de gargalos no banco de dados; </li><li>  diminui√ß√£o no consumo de recursos do banco de dados. </li></ul><br>  O √∫ltimo momento √© o mais fundamental.  No caso de otimiza√ß√£o reativa, n√£o temos a tarefa de reduzir o consumo de recursos como um todo, mas apenas a tarefa de levar o tempo de resposta da funcionalidade para dentro dos limites aceit√°veis. <br><br><h3>  Como encontrar gargalos no banco de dados? <br></h3><br>  Quando come√ßamos a pensar sobre esse problema, muitas subtarefas surgem imediatamente.  √â necess√°rio executar: <br><br><ul><li>  Teste de CPU </li><li>  teste de carga em leituras / registros; </li><li>  teste de estresse pelo n√∫mero de sess√µes ativas; </li><li>  teste de carga em ... etc. </li></ul><br>  Se tentarmos simular esses problemas em um complexo de teste, podemos encontrar o fato de que o problema que surgiu no servidor de teste n√£o tem nada a ver com o de combate.  H√° muitas raz√µes para isso, come√ßando com o fato de que os servidores de teste geralmente s√£o mais fracos.  Bem, se √© poss√≠vel tornar o servidor de teste uma c√≥pia exata do combate, mas isso n√£o garante que a carga seja reproduzida da mesma maneira, porque voc√™ precisa reproduzir com precis√£o a atividade do usu√°rio e muitos outros fatores que afetam a carga final.  Se voc√™ tentar simular essa situa√ß√£o, em geral, ningu√©m garante que exatamente a mesma coisa acontecer√° no servidor de batalha. <br><br>  Se, em um caso, o problema surgiu porque um novo registro chegou, no outro poderia surgir porque o usu√°rio lan√ßou um relat√≥rio enorme fazendo uma classifica√ß√£o grande, por causa do qual o espa√ßo de tabela tempor√°rio foi preenchido e, como Como resultado, o sistema come√ßou a desacelerar.  Ou seja, os motivos podem ser diferentes e nem sempre √© poss√≠vel prever.  Portanto, <strong>abandonamos as tentativas de procurar gargalos nos servidores de teste</strong> quase desde o in√≠cio.  Confiamos apenas no servidor de combate e no que estava acontecendo nele. <br><br>  O que fazer neste caso?  Vamos tentar entender quais os recursos com maior probabilidade de faltar em primeiro lugar. <br><br><h3>  Diminuindo o consumo de recursos do banco de dados <br></h3><br>  Com base nos complexos industriais que temos √† nossa disposi√ß√£o, a <strong>falta mais frequente de recursos √© observada nas leituras de disco e nas CPUs</strong> .  Portanto, em primeiro lugar, procuraremos pontos fracos precisamente nessas √°reas. <br><br>  A segunda quest√£o importante: como procurar algo? <br>  A quest√£o √© muito trivial.  Usamos o Oracle Enterprise Edition com a op√ß√£o Diagnostic Pack e, por n√≥s mesmos, encontramos essa ferramenta - <b>relat√≥rios AWR</b> (em outras edi√ß√µes do Oracle, voc√™ pode usar os <b>relat√≥rios STATSPACK</b> ).  No PostgreSQL, h√° um anal√≥gico - pgstatspack, h√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pg_profile de</a> Andrey Zubkov.  O √∫ltimo produto, como eu o entendo, apareceu e come√ßou a se desenvolver apenas no ano passado.  Para o MySQL, n√£o consegui encontrar ferramentas semelhantes, mas n√£o sou especialista em MySQL. <br><br>  A abordagem em si n√£o est√° vinculada a nenhum tipo espec√≠fico de banco de dados.  Se for poss√≠vel obter informa√ß√µes sobre a carga do sistema em algum relat√≥rio, usando a t√©cnica sobre a qual falarei agora, voc√™ poder√° executar o trabalho de otimiza√ß√£o proativa <strong>em qualquer base</strong> . <br><br><h3>  <strong>Otimiza√ß√£o das 5 principais opera√ß√µes</strong> <br></h3><br>  A tecnologia de otimiza√ß√£o proativa que desenvolvemos e estamos usando no Payment Center RNCO consiste em quatro est√°gios. <br><br>  <strong>Etapa 1. Recebemos o relat√≥rio AWR pelo maior per√≠odo poss√≠vel.</strong> <br><br>  O maior per√≠odo de tempo poss√≠vel √© necess√°rio para calcular a carga m√©dia em diferentes dias da semana, pois √†s vezes √© muito diferente.  Por exemplo, os registros da semana passada chegam ao RBS-Retail Bank na ter√ßa-feira, come√ßam a ser processados ‚Äã‚Äãe, durante todo o dia, temos uma carga m√©dia de cerca de 2 a 3 vezes.  Nos outros dias, a carga √© menor. <br><br>  Se voc√™ souber que o sistema possui algumas especificidades - em alguns dias a carga √© maior, em alguns dias - menos, ser√° necess√°rio receber relat√≥rios para esses per√≠odos separadamente e trabalhar com eles separadamente, se quisermos otimizar intervalos de tempo espec√≠ficos .  Se voc√™ precisar otimizar a situa√ß√£o geral no servidor, poder√° obter um grande relat√≥rio para o m√™s e ver o que os recursos do servidor realmente consomem. <br><br>  √Äs vezes, situa√ß√µes muito inesperadas aparecem.  Por exemplo, no caso do CFT Bank, uma solicita√ß√£o que verifique a fila do servidor de relat√≥rio pode estar entre os 10 primeiros.  Al√©m disso, essa solicita√ß√£o √© oficial e n√£o executa nenhuma l√≥gica comercial, mas apenas verifica se h√° ou n√£o um relat√≥rio de execu√ß√£o. <br><br>  <strong>Etapa 2. Observamos as se√ß√µes:</strong> <br><br><ul><li>  SQL ordenado por tempo decorrido - consultas SQL classificadas por tempo de execu√ß√£o; </li><li>  SQL ordenado pelo CPU Time - para uso da CPU; </li><li>  SQL ordenado por Gets - por leituras l√≥gicas; </li><li>  SQL ordenado por leituras - para leituras f√≠sicas. </li></ul><br>  As se√ß√µes restantes do SQL ordenadas por s√£o estudadas conforme necess√°rio. <br><br>  <strong>Etapa 3. Determinamos as opera√ß√µes e solicita√ß√µes dos pais dependentes delas.</strong> <br><br>  O relat√≥rio AWR possui se√ß√µes separadas em que, dependendo da vers√£o do Oracle, 15 ou mais consultas principais s√£o exibidas em cada uma dessas se√ß√µes.  Mas essas consultas da Oracle no relat√≥rio AWR mostram uma bagun√ßa. <br>  Por exemplo, h√° uma opera√ß√£o pai, nela podem haver tr√™s consultas principais.  O Oracle no relat√≥rio AWR mostrar√° a opera√ß√£o pai e todas essas tr√™s consultas.  Portanto, voc√™ precisa fazer uma an√°lise dessa lista e ver a quais solicita√ß√µes espec√≠ficas de opera√ß√£o se referem, agrup√°-las. <br><br>  <strong>Etapa 4. Otimizamos as 5 principais opera√ß√µes.</strong> <br><br>  Ap√≥s esse agrupamento, a sa√≠da √© uma lista de opera√ß√µes das quais voc√™ pode selecionar as mais dif√≠ceis.  Estamos limitados a 5 opera√ß√µes (n√£o solicita√ß√µes, ou seja, opera√ß√µes).  Se o sistema for mais complexo, voc√™ poder√° usar mais. <br><br><h3>  Erros comuns de design de consulta <br></h3><br>  Durante a aplica√ß√£o desta t√©cnica, compilamos uma pequena lista de erros t√≠picos de design.  Alguns erros s√£o t√£o simples que parece que n√£o podem ser. <br><br>  ‚óè <strong>Falta de √≠ndice ‚Üí Verifica√ß√£o completa</strong> <br>  Existem casos muito incidentais, por exemplo, com a aus√™ncia de um √≠ndice no esquema de combate.  Tivemos um exemplo concreto em que uma consulta por muito tempo funcionou rapidamente sem um √≠ndice.  Mas houve uma varredura completa e, √† medida que o tamanho da tabela aumentou gradualmente, a consulta come√ßou a funcionar mais lentamente e, de um quarto para outro, demorou um pouco mais.  No final, prestamos aten√ß√£o a ele e constatamos que o √≠ndice n√£o est√° l√°. <br><br>  ‚óè <strong>Sele√ß√£o ampla ‚Üí Varredura completa</strong> <br>  O segundo erro comum √© uma grande amostra de dados - o caso cl√°ssico de uma verifica√ß√£o completa.  Todo mundo sabe que uma verifica√ß√£o completa deve ser usada apenas quando for realmente justificada.  √Äs vezes, h√° momentos em que uma varredura completa aparece onde voc√™ poderia ficar sem ela, por exemplo, se voc√™ transferir as condi√ß√µes de filtragem do c√≥digo pl / sql para a consulta. <br><br>  ‚óè <strong>√çndice ineficaz ‚Üí Longo INDEX RANGE SCAN</strong> <br>  Talvez este seja at√© o erro mais comum, pelo qual, por algum motivo, eles dizem muito pouco - o chamado √≠ndice ineficiente (varredura longa de √≠ndice, varredura longa de INDEX RANGE).  Por exemplo, temos uma tabela para registros.  Na solicita√ß√£o, tentamos encontrar todos os registros desse agente e, por fim, adicionamos algum tipo de condi√ß√£o de filtragem, por exemplo, por um determinado per√≠odo, ou com um n√∫mero espec√≠fico ou um cliente espec√≠fico.  Nessas situa√ß√µes, o √≠ndice geralmente √© criado apenas no campo "agente" por raz√µes de universalidade de uso.  O resultado √© a seguinte imagem: no primeiro ano de trabalho, por exemplo, o agente teve 100 entradas nesta tabela, no pr√≥ximo ano j√° 1.000, em outro ano pode haver 10.000 entradas.  Com o passar do tempo, esses registros se tornam 100.000. Obviamente, a solicita√ß√£o come√ßa a funcionar lentamente, porque na solicita√ß√£o voc√™ precisa adicionar n√£o apenas o pr√≥prio identificador do agente, mas tamb√©m algum filtro adicional, neste caso por data.  Caso contr√°rio, o tamanho da amostra aumentar√° de ano para ano, √† medida que o n√∫mero de registros desse agente estiver aumentando.  Esse problema deve ser resolvido no n√≠vel do √≠ndice.  Se houver muitos dados, j√° devemos pensar na dire√ß√£o do particionamento. <br><br>  ‚óè <strong>Ramos de c√≥digo de distribui√ß√£o desnecess√°rios</strong> <br>  Este tamb√©m √© um caso curioso, mas, no entanto, acontece.  Olhamos para as principais consultas e vemos algumas consultas estranhas l√°.  Chegamos aos desenvolvedores e dizemos: "Encontramos alguns pedidos, vamos descobrir e ver o que pode ser feito sobre isso".  O desenvolvedor pensa, depois de um tempo e diz: ‚ÄúEste ramo de c√≥digo n√£o deve estar no seu sistema.  Voc√™ n√£o usa essa funcionalidade. ‚Äù  Em seguida, o desenvolvedor recomenda que voc√™ ative alguma configura√ß√£o especial para contornar esta se√ß√£o do c√≥digo. <br><br><h3>  Estudos de caso <br></h3><br>  Agora eu gostaria de considerar dois exemplos de nossa pr√°tica real.  Quando lidamos com as principais consultas, √© claro que antes de tudo pensamos no fato de que deve haver algo mega pesado, n√£o trivial, com opera√ß√µes complexas.  De fato, esse nem sempre √© o caso.  √Äs vezes, existem casos em que consultas muito simples se enquadram nas principais opera√ß√µes. <br><br><h4>  Exemplo 1 <br></h4><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> o.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rnko_dep_reestr_in_oper o <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> o.type_oper = <span class="hljs-string"><span class="hljs-string">'proc'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> o.ean_rnko <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> l.ean_rnko <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rnko_dep_link l <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> l.s_rnko = :<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> o.date_oper_bnk <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>, o.date_reg <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ROWNUM</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Neste exemplo, uma consulta consiste em apenas duas tabelas, e essas n√£o s√£o tabelas pesadas - apenas alguns milh√µes de registros.  Parece mais f√°cil?  No entanto, a solicita√ß√£o chegou ao topo. <br><br>  Vamos tentar descobrir o que h√° de errado com ele. <br><br>  Abaixo est√° uma imagem do Enterprise Manager Cloud Control - dados sobre as estat√≠sticas desta solicita√ß√£o (a Oracle possui uma ferramenta).  Pode-se observar que h√° uma carga regular nessa solicita√ß√£o (gr√°fico superior).  O n√∫mero 1 ao lado indica que, em m√©dia, n√£o h√° mais de uma sess√£o em execu√ß√£o.  O diagrama verde mostra que a <strong>solicita√ß√£o usa apenas a CPU</strong> , o que √© duplamente interessante. <br><br><img src="https://habrastorage.org/webt/cd/jl/tm/cdjltmcxv_hgjn7ykitlcdjwdes.jpeg"><br><br>  Vamos tentar descobrir o que est√° acontecendo aqui? <br><br><img src="https://habrastorage.org/webt/gk/h9/8r/gkh98r5cr3dprhk49xl0d3-y1nm.jpeg"><br><br>  Acima est√° uma tabela com estat√≠sticas a pedido.  Quase 700 mil lan√ßamentos - isso n√£o surpreender√° ningu√©m.  Mas o intervalo de tempo entre o Primeiro carregamento em 15 de dezembro e o √öltimo carregamento em 22 de dezembro (veja a figura anterior) √© de uma semana.  Se voc√™ contar o n√∫mero de partidas por segundo, a <strong>consulta ser√° executada em m√©dia a cada segundo</strong> . <br><br>  N√≥s olhamos mais longe.  O tempo de execu√ß√£o da consulta √© de 0,93 segundos, ou seja,  menos de um segundo, isso √© √≥timo.  Podemos nos alegrar - o pedido n√£o √© pesado.  No entanto, ele chegou ao topo, o que significa que ele consome muitos recursos.  Onde consome muitos recursos? <br><br>  A tabela possui uma linha para leituras l√≥gicas.  Vemos que, para um lan√ßamento, ele precisa de quase 8 mil blocos (normalmente 1 bloco tem 8 KB).  Acontece que a solicita√ß√£o, trabalhando uma vez por segundo, carrega cerca de 64 MB de dados da mem√≥ria.  Algo est√° errado aqui, precisamos entender. <br><br>  Vamos ver o plano: h√° uma varredura completa.  Bem, vamos seguir em frente. <br><br><pre> <code class="sql hljs"> Plan hash value: 634977963 <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------- | Id | Operation | Name | ------------------------------------------------------------------- | 0 | SELECT STATEMENT | | |* 1 | COUNT STOPKEY | | | 2 | VIEW | | |* 3 | SORT ORDER BY STOPKEY | | | 4 | NESTED LOOPS | | | 5 | TABLE ACCESS BY INDEX ROWID| RNKO_DEP_LINK | |* 6 | INDEX UNIQUE SCAN | UK_RNKODEPLINK$S_RNKO | |* 7 | TABLE ACCESS FULL | RNKO_DEP_REESTR_IN_OPER | ------------------------------------------------------------------- Predicate Information (identified by operation id): 1 - filter(ROWNUM=1) 3 - filter(ROWNUM=1) 6 - access("L"."S_RNKO"=:1) 7 - filter(("O"."TYPE_OPER"='proc' AND "O"."EAN_RNKO"="L"."EAN_RNKO"))</span></span></code> </pre><br>  Na tabela rnko_dep_reestr_in_oper, existem apenas 5 milh√µes de linhas e seu comprimento m√©dio √© de 150 bytes.  Mas aconteceu que n√£o h√° √≠ndice suficiente para o campo que est√° se conectando - a subconsulta √© conectada √† solicita√ß√£o atrav√©s do campo ean_rnko, para o qual n√£o h√° √≠ndice! <br><br>  Al√©m disso, mesmo que ele apare√ßa, de fato a situa√ß√£o n√£o ser√° muito boa.  Essa verifica√ß√£o de √≠ndice longa (INDEX RANGE SCAN) ocorrer√°.  ean_rnko √© o identificador interno do agente.  Os registros do agente ser√£o acumulados e, a cada ano, a quantidade de dados que essa solicita√ß√£o selecionar√° aumentar√° e a solicita√ß√£o diminuir√°. <br><br>  <strong>Solu√ß√£o:</strong> crie um √≠ndice para os campos ean_rnko e date_reg, solicite aos desenvolvedores que limitem a profundidade da verifica√ß√£o por data nesta solicita√ß√£o.  Em seguida, voc√™ pode pelo menos em certa medida garantir que o desempenho da consulta permanecer√° aproximadamente nos mesmos limites, pois o tamanho da amostra ser√° limitado a um intervalo de tempo fixo e a tabela inteira n√£o precisar√° ser lida.  Este √© um ponto muito importante, veja o que aconteceu. <br><img src="https://habrastorage.org/webt/zl/eg/b5/zlegb5nfhfvxy9bajfsxkv3u7ao.png"><br><br>  Ap√≥s a otimiza√ß√£o, o tempo de opera√ß√£o ficou menor que um cent√©simo de segundo (era 0,93), o n√∫mero de blocos se tornou uma m√©dia de 8,5 a 1000 vezes menor que antes. <br><br><h4>  Exemplo 2 <br></h4><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> loy$barcodes t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> t.id_processing = :b1 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> t.id_rec_out <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> t.barcode <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> t.status = <span class="hljs-string"><span class="hljs-string">'u'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> t.id_card <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span></code> </pre><br>  Comecei a hist√≥ria dizendo que geralmente algo complicado √© esperado no topo da consulta.  Abaixo est√° um exemplo de uma consulta "complexa" que vai para uma tabela (!), E tamb√©m entra nas principais consultas :) H√° um √≠ndice no campo ID_PROCESSING! <br>  Existem 3 condi√ß√µes IS NULL nesta consulta e, como sabemos, essas condi√ß√µes n√£o s√£o indexadas (voc√™ n√£o pode usar o √≠ndice nesse caso).  Al√©m disso, existem apenas duas condi√ß√µes do tipo de igualdade (por ID_PROCESSING e STATUS). <br><br>  Provavelmente, o desenvolvedor que examinaria essa consulta, antes de tudo, sugeriria criar um √≠ndice em ID_PROCESSING e STATUS.  Mas, dada a quantidade de dados que ser√£o escolhidos (haver√° muitos deles), essa solu√ß√£o n√£o funciona. <br><br>  No entanto, a solicita√ß√£o consome muitos recursos, o que significa que algo precisa ser feito para faz√™-lo funcionar mais rapidamente.  Vamos tentar descobrir os motivos. <br><img src="https://habrastorage.org/webt/wt/s4/cx/wts4cxw4pwappessb8lypge_uzg.png"><br><br>  As estat√≠sticas acima s√£o de 1 dia, a partir das quais √© poss√≠vel observar que a solicita√ß√£o √© iniciada a cada 5 minutos.  O principal consumo de recursos √© a CPU e a leitura do disco.  Abaixo no gr√°fico com estat√≠sticas do n√∫mero de consultas iniciadas, √© poss√≠vel observar que tudo est√° em ordem - o n√∫mero de partidas quase n√£o muda ao longo do tempo - uma situa√ß√£o bastante est√°vel. <br><img src="https://habrastorage.org/webt/5x/09/ge/5x09gen-19peucgd4eu430ichrq.png"><br><br>  E, se voc√™ procurar mais, pode ver que o tempo de consulta √†s vezes varia bastante - v√°rias vezes, o que j√° √© significativo. <br><img src="https://habrastorage.org/webt/ue/tj/mx/uetjmxbf2hbrv6kvzojoshoisyy.png"><br><br>  Vamos descobrir a seguir. <br><br>  O Oracle Enterprise Manager possui um utilit√°rio de monitoramento de SQL.  Com este utilit√°rio, voc√™ pode ver em tempo real o consumo de recursos por solicita√ß√£o. <br><img src="https://habrastorage.org/webt/ap/j6/k-/apj6k--jewoeighhu8_7edfkiu8.png"><br><br>  Relat√≥rio acima para solicita√ß√£o problem√°tica.  Antes de tudo, devemos estar interessados ‚Äã‚Äãno fato de que a INDEX RANGE SCAN (linha inferior) na coluna Linhas reais mostra 17 milh√µes de linhas.  Provavelmente vale a pena considerar. <br><br>  Se olharmos mais para o plano de implementa√ß√£o, verifica-se que, ap√≥s o pr√≥ximo item do plano, dessas 17 milh√µes de linhas, restam apenas 1705. A quest√£o √©: por que foram escolhidos 17 milh√µes?  Cerca de 0,01% permaneceu na amostra final, ou seja <strong>, obviamente ineficiente, foi realizado um trabalho desnecess√°rio</strong> .  Al√©m disso, este trabalho √© realizado a cada 5 minutos.  Aqui est√° o problema!  Portanto, essa solicita√ß√£o atingiu as principais consultas. <br><br>  Vamos tentar resolver esse problema n√£o trivial.  O √≠ndice que se implora em primeiro lugar √© ineficiente, ent√£o voc√™ precisa criar algo complicado e derrotar as condi√ß√µes IS NULL. <br><br><h4>  Novo √≠ndice <br></h4><br>  Consultamos os desenvolvedores, pensamos e tomamos essa decis√£o: criamos um √≠ndice funcional no qual existe uma coluna ID_PROCESSING, que estava com a condi√ß√£o de igualdade na solicita√ß√£o e inclu√≠mos todos os outros campos como argumentos dessa fun√ß√£o: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> gc.loy$barcod_unload_i <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> gc.loy$barcodes (gc.loy_barcodes_ic_unload(id_rec_out, barcode, id_card, <span class="hljs-keyword"><span class="hljs-keyword">status</span></span>), id_processing);  function loy_barcodes_ic_unload( pIdRecOut in loy$barcodes.id_rec_out%type, pBarcode in loy$barcodes.barcode%type, pIdCard in loy$barcodes.id_card%type, pStatus in loy$barcodes.status%type) return varchar2 deterministic is vRes varchar2(1) := ''; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pIdRecOut <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pBarcode <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pIdCard <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pStatus = <span class="hljs-string"><span class="hljs-string">'U'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> vRes := pStatus; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; return vRes; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> loy_barcodes_ic_unload;</code> </pre><br>  Essa fun√ß√£o √© do tipo determin√≠stica, ou seja, no mesmo conjunto de par√¢metros, sempre fornece a mesma resposta.  Garantimos que essa fun√ß√£o sempre retornasse sempre um valor - neste caso, "U".  Quando todas essas condi√ß√µes s√£o cumpridas, "U" √© emitido, quando n√£o preenchido - NULL.  Esse √≠ndice funcional torna poss√≠vel filtrar efetivamente os dados. <br><br>  A aplica√ß√£o desse √≠ndice levou ao seguinte resultado: <br><br><img src="https://habrastorage.org/webt/xh/wj/nb/xhwjnbiaw-hvj7uumjpwr9uu-mi.png"><br><br>  Aqui, uma coluna √© uma captura instant√¢nea, elas s√£o feitas a cada meia hora do banco de dados.  Atingimos nosso objetivo e esse √≠ndice foi realmente eficaz.  Vamos ver as caracter√≠sticas quantitativas: <br><br><table width="408"><tbody><tr><td width="408" colspan="3">  Estat√≠sticas m√©dias de solicita√ß√£o <br><br></td></tr><tr><td width="174"></td><td width="124">  <strong>Antes de</strong> <br><br></td><td width="110">  <strong>DEPOIS</strong> <br><br></td></tr><tr><td width="174">  Tempo decorrido, seg <br><br></td><td width="124">  143,21 <br><br></td><td width="110">  60,7 <br><br></td></tr><tr><td width="174">  Tempo da CPU, seg <br><br></td><td width="124">  33,23 <br><br></td><td width="110">  45,38 <br><br></td></tr><tr><td width="174">  Buffer Obt√©m Bloco <br><br></td><td width="124">  6`288`237,67 <br><br></td><td width="110">  1`589`836 <br><br></td></tr><tr><td width="174">  Bloco de leitura de disco <br><br></td><td width="124">  266`600,33 <br><br></td><td width="110">  2`680 <br><br></td></tr></tbody></table><br>  O tempo operacional diminuiu 2,5 vezes e o consumo de recursos (Buffer Gets) - cerca de 4. O n√∫mero de blocos de dados lidos no disco diminuiu significativamente. <br><br><h3>  Resultados de otimiza√ß√£o proativa <br></h3><br>  Recebemos: <br><br><ul><li>  reduzindo a carga no banco de dados; </li><li>  melhorar a estabilidade do banco de dados; </li><li>  uma redu√ß√£o significativa no n√∫mero de incidentes de desempenho de software. </li></ul><br>  <strong>Os incidentes de desempenho diminu√≠ram 10 vezes</strong> .  √â uma quantia subjetiva, antes dos incidentes ocorrerem no complexo RBS-Retail Bank, 1-2 vezes por m√™s, mas agora praticamente nos esquecemos deles. <br><br>  Isso levanta a quest√£o - e os incidentes de desempenho de software?  N√≥s n√£o lidamos com eles diretamente? <br><br>  Voltar para a √∫ltima agenda.  Se voc√™ se lembra, havia uma varredura completa, era necess√°rio armazenar um grande n√∫mero de blocos na mem√≥ria.  Como a solicita√ß√£o foi executada regularmente, todos esses blocos foram armazenados no cache do Oracle.  Acontece que, se nesse momento ocorrer uma carga alta no banco de dados, por exemplo, algu√©m come√ßar a usar a mem√≥ria ativamente, ser√° necess√°rio um cache para armazenar os blocos de dados.  Assim, parte dos dados de nossa solicita√ß√£o ser√° compactada, o que significa que teremos que fazer leituras f√≠sicas.  Se voc√™ fizer leituras f√≠sicas, o tempo de execu√ß√£o da consulta aumentar√° tremendamente imediatamente. <br><br>  A leitura l√≥gica est√° funcionando com a mem√≥ria, acontece rapidamente e qualquer acesso ao disco √© lento (se voc√™ observar as horas, milissegundos).  Se voc√™ tiver sorte e houver esses dados no cache do sistema operacional ou no cache da matriz, ainda ser√£o dezenas de microssegundos.  A leitura do cache do Oracle √© muito mais r√°pida. <br><br>  Quando nos livramos da verifica√ß√£o completa, a necessidade de armazenar um n√∫mero t√£o grande de blocos no cache (Buffer Cache) desapareceu.  Quando h√° falta desses recursos, a solicita√ß√£o √© mais ou menos est√°vel.  N√£o h√° mais picos t√£o grandes que estavam com o √≠ndice antigo. <br><br>  <strong>Resumo da otimiza√ß√£o proativa:</strong> <br><br><ul><li>  A otimiza√ß√£o inicial da consulta deve ser realizada em servidores de teste, para ver como as consultas e sua l√≥gica de neg√≥cios funcionam, para n√£o fazer nada sup√©rfluo.  Estes trabalhos permanecem. </li><li>  Periodicamente, por√©m, a cada poucos meses, faz sentido remover relat√≥rios com carga total do servidor, pesquisar as principais consultas e opera√ß√µes no banco de dados e otimiz√°-las. </li></ul><br>  <strong>Existem muitas ferramentas para obter estat√≠sticas em um banco de dados Oracle:</strong> <br><br><ul><li>  Relat√≥rio AWR (DBMS_WORKLOAD_REPOSITORY.awr_report_html); </li><li>  Enterprise Manager Cloud Control 12c (Detalhes do SQL); </li><li>  Relat√≥rio ativo de detalhes do SQL (DBMS_PERF.report_sql); </li><li>  Monitoramento de SQL (guia EMCC); </li><li>  Relat√≥rio de monitoramento SQL (DBMS_SQLTUNE.report_sql_monitor *). </li></ul><br>  Algumas dessas ferramentas funcionam no console, ou seja, n√£o est√£o vinculadas ao Enterprise Manager. <br><br><div class="spoiler">  <b class="spoiler_title">Exemplos de ferramentas Oracle para coletar estat√≠sticas</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/d9/nk/rr/d9nkrrmgv-omldaqotcf1vxxub0.png"><br><br><ul><li>  O gr√°fico superior mostra quantas sess√µes funcionam com esta solicita√ß√£o. </li><li>  O bloco esquerdo mostra de onde essa solicita√ß√£o √© iniciada e em quais m√≥dulos ela est√° localizada. </li><li>  Parte inferior esquerda - informa√ß√µes sobre o uso do pool compartilhado. </li><li>  √Ä direita, o diagrama mostra os eventos de espera que est√£o no sistema.  Nesse caso, √© apenas a CPU. </li><li>  No canto inferior direito - o mais interessante - um prato com caracter√≠sticas de qualidade mais importantes na an√°lise de problemas de desempenho. </li></ul><br><img src="https://habrastorage.org/webt/h-/xw/en/h-xwenxxptrffbthe3bsj-dl0n4.png"><br><br>  O SQL-Monitoring mostra como tudo fica em tempo real (onde a engrenagem verde est√° girando, a consulta est√° funcionando agora). <br><img src="https://habrastorage.org/webt/ke/3n/vg/ke3nvg_q8afcbolkbcxdnkg3qaa.png"><br><br>  Acima est√° o conte√∫do interno do relat√≥rio SQL-Monitoring.  Ele mostra em tempo real qual linha de consulta √© executada e quantas linhas √© lida (coluna Linhas reais).  Nesse caso, o INDEX RANGE SCAN j√° contabilizou 5 milh√µes. <br><br><img src="https://habrastorage.org/webt/ow/39/j1/ow39j1yvfaecppovtbgjb8tgsaq.png"><br><br>  A ferramenta de texto Relat√≥rio de Monitoramento SQL, na qual h√° algumas informa√ß√µes (n√£o todas). <br><img src="https://habrastorage.org/webt/br/zu/py/brzupy-mengmdxvh_cppnsogl0w.png"><br></div></div><br>  <strong>B√¥nus: os</strong> especialistas do ‚ÄúCentro de Pagamento‚Äù e CFT da RNCO estavam bem preparados para a confer√™ncia em Novosibirsk, fizeram alguns relat√≥rios √∫teis e tamb√©m organizaram um r√°dio de sa√≠da real.  Durante dois dias, especialistas, palestrantes e organizadores conseguiram visitar a r√°dio CFT.  Voc√™ pode voltar ao ver√£o da Sib√©ria incluindo entradas. Aqui est√£o os links para os blocos: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Kubernetes: pr√≥s e contras</a> ;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ci√™ncia de dados e aprendizado de m√°quina</a> ;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DevOps</a> . <br><br><blockquote>  No HighLoad ++ em Moscou, que j√° √© 8 e 9 de novembro, haver√° coisas ainda mais interessantes.  O <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">programa</a> inclui relat√≥rios sobre todos os aspectos do trabalho em projetos altamente carregados, master classes, reuni√µes e eventos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">parceiros</a> que compartilhar√£o conselhos de especialistas e encontrar√£o algo para surpreender.  N√£o deixe de escrever sobre as mais interessantes e notificar no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">boletim informativo</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fique</a> conectado! <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt428491/">https://habr.com/ru/post/pt428491/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt428477/index.html">Para quem escolhe um firewall</a></li>
<li><a href="../pt428481/index.html">Contratos digitais: um guia r√°pido para os advogados da NOT</a></li>
<li><a href="../pt428485/index.html">A maioria das pessoas irritantes √© publicidade irrelevante e o uso de gadgets em p√∫blico</a></li>
<li><a href="../pt428487/index.html">Por que o Ruby on Rails √© bom e como acelera o desenvolvimento</a></li>
<li><a href="../pt428489/index.html">Magreza e espessura dos √≠cones. Sketch Pro, recursos de renderiza√ß√£o e um jogo com espessura de linha</a></li>
<li><a href="../pt428493/index.html">Git subrepo</a></li>
<li><a href="../pt428495/index.html">Como fiz um simulador de futebol por 13 anos</a></li>
<li><a href="../pt428497/index.html">Redutor sem fio personalizado Noolite SUF-1-300</a></li>
<li><a href="../pt428499/index.html">Gigantes azuis assustadores podem revelar os segredos da evolu√ß√£o estelar</a></li>
<li><a href="../pt428501/index.html">DartUP: a primeira confer√™ncia em russo sobre Dart and Flutter em 1¬∫ de dezembro em S√£o Petersburgo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>