<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📈 👭 ❕ Ikatan dua arah sudut, sedikit lebih pengertian 🙆🏾 💿 👦🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dari penerjemah  Dari seorang penerjemah : dua tahun lalu saya memulai proyek pertama saya tentang Angular (2+), memiliki latar belakang AngularJS yan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ikatan dua arah sudut, sedikit lebih pengertian</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453696/"><div class="spoiler">  <b class="spoiler_title">Dari penerjemah</b> <div class="spoiler_text">  <b>Dari seorang penerjemah</b> : dua tahun lalu saya memulai proyek pertama saya tentang Angular (2+), memiliki latar belakang AngularJS yang besar dan sukses.  Transisi tersebut membutuhkan format pemikiran yang nyata, karena terlalu banyak pada A1 dan A2 + dilakukan "sedikit berbeda".  Rasa sakit dari transisi secara nyata mengurangi blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">thoughtram</a> bagi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saya</a> .  Setahun yang lalu, saya mendapat izin untuk menerjemahkan artikel ini "tentang dasar dan mudah dimengerti oleh semua orang."  Tapi mereka adalah tangan seperti itu (artikel mereka adalah sekelompok yang belum selesai).  Anehnya, artikel tersebut diterjemahkan dengan baik di Google translate.  Tetapi beberapa nuansa dalam terjemahan ini hilang, belum lagi gaya penulisnya.  Gaya penulis belum sepenuhnya dipertahankan dalam versi saya.  Tapi, saya harap, saya berhasil menyampaikan mood dan pemikiran artikel tersebut. <br><br>  Saya mengerti bahwa Angular bukan topik terpopuler di Habré, tetapi saya berharap terjemahannya akan membantu seseorang, seperti artikel asli yang pernah membantu saya. <br></div></div><br>  Itulah yang menyebabkan efek wow di AngularJS tua yang baik, sehingga "mengikat dua arah."  Sihir ini langsung jatuh cinta pada AngularJS, dan memecah semua gagasan tentang pemrograman halaman yang membosankan dan (oh, horor!) Formulir Web.  Perubahan pada data langsung ditampilkan di layar dan sebaliknya.  Mereka yang sebelumnya mengembangkan aplikasi jQuery dianggap mengikat jatuh ke dalam dongeng.  Dan monster berjanggut, menggergaji klien yang gemuk sebelum jQuery, mulai dengan panik menghitung bulan-bulan yang hilang secara bodoh itu. <br><br>  Dan, lebih dari itu, keajaiban ikatan dua arah tersedia tidak hanya untuk notasi khusus dan komponen tertentu.  Kita dapat dengan mudah menggunakannya dalam arahan dan komponen kita sendiri (hanya dengan mengatur parameter konfigurasi). <br><br>  <b>Di Angular2 +, pembuat meninggalkan pengikatan data dua arah</b> bawaan (kecuali melalui ngModel).  Tetapi ini tidak berarti bahwa kita tidak dapat menggunakan pengikatan dua arah dalam arahan kita sendiri ... Hanya saja freebie telah selesai dan sekarang kita perlu melakukan sesuatu sendiri.  Dan, lebih disukai, dengan pemahaman tentang cara kerjanya di Angular. <br><a name="habracut"></a><br><h3>  Daftar isi </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penjilidan dua arah singkatnya</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memahami ngModel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Buat ikatan data dua arah Anda sendiri</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kesimpulan</a> </li></ul><br><a name="in2word"></a><h3>  Penjilidan dua arah singkatnya </h3><br>  Di A2 +, hanya satu arahan tunggal yang menerapkan pengikatan data dua arah: <b>ngModel</b> .  Dan pada pandangan pertama, ini adalah sihir yang sama seperti di AngularJS (hanya dalam notasi yang berbeda).  Tapi apa yang ada di bawah tenda? <br><br>  Anehnya, di bawah tenda, semuanya relatif sederhana dan logis: pengikatan dua arah dikurangi menjadi pengikatan properti dan pengikatan acara.  Dua ikatan unilateral, bukan satu bilateral?  Ok, ayo dua. <br><br>  Dan segera sebuah contoh: <br><br><pre><code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> [(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngModel</span></span></span><span class="hljs-tag">)]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"username"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Hello {{username}}!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Ya, ya, ini adalah demo Angular2 yang indah dan menakjubkan dari 2009.  Tidak bercanda, cantik.  Saat mengubah bidang, nilai <b>nama pengguna</b> jatuh ke dalam model, dan langsung tercermin dalam pesan selamat datang di formulir. <br><br>  Tetapi bagaimana cara kerjanya?  Ingat bahwa pengikatan dua arah dalam Angular2 adalah pengikatan properti dan pengikatan acara.  Dan ya, mereka dapat secara bersamaan tersedia dalam satu arahan.  Selain itu, bahkan tanpa <b>ngModel</b> , kita dapat dengan mudah menerapkan pengikatan data dua arah.  Misalnya, seperti ini: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"username"</span></span></span><span class="hljs-tag"> (</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">input</span></span></span><span class="hljs-tag">)=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"username = $event.target.value"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Hello {{username}}!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Output <b>{{username}}</b> jelas, tetapi apa yang tertulis di sana dalam <b>input</b> ?  Mari kita pahami: <br><br><ul><li>  <b>[value] = “nama pengguna”</b> - notasi dengan tanda kurung, mengaitkan ekspresi nama pengguna dengan properti nilai </li><li>  <b>(input) = "ekspresi"</b> - sebuah notasi dengan tanda kurung, ekspresi terlampir pada acara <b>input</b> (ya, ada peristiwa seperti itu).  Dalam kasus kami: <br><ul><li>  <b>username = $ event.target.value</b> - ungkapan ini akan dieksekusi sebagai respons terhadap acara masukan </li><li>  <b>$ event</b> adalah variabel sintetis dalam peristiwa Angular yang membawa muatan: dalam kasus ini, ia berisi informasi tentang apa yang terjadi dan sekitarnya </li></ul></li></ul><br>  Apakah semakin jelas?  Kami memperbaikinya. <br><br>  Kami mengikat properti <b>nama pengguna</b> model Angular ke properti <b>nilai</b> elemen input browser (pengikatan satu arah dari model untuk melihat). <br><br>  Kami juga mengikat ekspresi ke acara <b>masukan</b> elemen kami.  Yang menetapkan nilai <b>$ event.target.value</b> ke properti <b>nama pengguna</b> model. <br><br>  Apa itu <b>$ event.target.value</b> ?  Seperti yang telah disebutkan, <b>$ event</b> penuh dengan berbagai informasi berguna tentang acara tersebut.  Dalam kasus ini, ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">InputEventObject</a> di mana properti <b>target</b> merujuk ke elemen DOM yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memicu</a> peristiwa (mis. Elemen input kami). <br><br>  Jadi, semua yang kita lakukan pada dasarnya adalah membaca konten ( <b>nilai</b> ) dari elemen input ( <b>$ event.target</b> ) ketika pengguna memasukkan nilai.  Dan ketika kami menetapkan nilai nama pengguna ini, data tampilan akan dikirim ke model. <br><br>  <b>Itu saja.</b>  <b>Ini adalah "ikatan dua arah singkatnya</b> . <b>"</b>  Kecantikan <br><br>  Tapi kapan <b>ngModel</b> ikut bermain?  Skenario bekerja dengan elemen input sangat umum dan diminati.  Dan untuk beberapa alasan saya ingin memiliki arahan yang menyembunyikan implementasi dan menghemat dari penekanan tombol ekstra. <br><br><a name="ngModel"></a><h3>  Memahami ngModel </h3><br>  Jika Anda melihat sumbernya, Anda dapat memastikan bahwa <b>ngModel</b> juga memiliki ikatan ke properti dan acara tersebut.  Inilah contoh contoh ngModel kami, tetapi tanpa menggunakan sintaks steno: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngModel</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"username"</span></span></span><span class="hljs-tag"> (</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngModelChange</span></span></span><span class="hljs-tag">)=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"username = $event"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Hello {{username}}!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Hampir semuanya sama.  Pengikatan properti <b>[ngModel]</b> menangani pembaruan nilai elemen input.  <b>Penjilidan</b> acara <b>(ngModelChange)</b> memberi tahu dunia bahwa perubahan sedang terjadi di DOM. <br><br>  Dan Anda perhatikan bahwa ekspresi handler hanya menggunakan <b>$ event</b> , bukan <b>$ event.target.value</b> .  Apa ada yang salah di sini?  Tidak semuanya.  Seperti yang dinyatakan di atas, <b>$ event</b> adalah variabel sintetis yang membawa <b>muatan</b> .  Keputusan apa yang dianggap berguna diambil oleh Angular.  Dengan kata lain, <b>ngModelChange</b> menangani ekstraksi <b>target.value</b> dari <b>$</b> internal <b>acara</b> dan hanya memberi kita apa yang kita inginkan, tanpa kemasan dan rebana.  Secara teknis akurat, ini adalah orang-orang dari <a href="">DefaultValueAccessor</a> : dialah yang mengekstrak data dan mentransfernya ke objek DOM dasar, meskipun ... Anda tidak bisa memikirkannya). <br><br>  Last but not least, karena menulis <b>nama pengguna</b> dan <b>ngModel</b> dua kali masih berlebihan, Angular memungkinkan penggunaan sintaks yang disingkat <b>[()]</b> , juga disebut "pisang dalam kotak".  Yang mirip dengan contoh sebelumnya, dan mengembalikan kita ke contoh dari awal bagian, tetapi dengan pemahaman tentang implementasi <b>ngModel</b> .  Memberikan ikatan dua arah yang sama. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> [(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngModel</span></span></span><span class="hljs-tag">)]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"username"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Hello {{username}}!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><a name="bindings"></a><br><h3>  Buat ikatan data dua arah Anda sendiri </h3><br>  Sekarang kita cukup tahu untuk membuat binding data dua arah kita sendiri.  Yang perlu Anda lakukan hanyalah mengikuti aturan yang sama seperti <b>ngModel</b> , yaitu: <br><br><ul><li>  Masukkan penjilidan properti (misalnya: <b>[foo]</b> ) </li><li>  Bind ke acara dengan nama dan akhiran yang sama <b>Ubah</b> (misalnya: <b>(fooChange)</b> ) </li><li>  Pastikan bahwa acara yang mengikat mengurus pengambilan properti (jika perlu) </li></ul><br>  Perhatikan bahwa membuat pengikatan data dua arah membutuhkan kerja lebih banyak daripada AngularJS?  Ini bisa sangat menyebalkan bagi kita ... Jika kita akan mencoba menggunakan ikatan dua arah kita sendiri jika memungkinkan.  Dalam kehidupan nyata, Anda harus selalu mempertimbangkan apakah kita memerlukan pengikatan dua arah, dan jika perlu, apakah lebih mudah untuk mengambil keuntungan dari ngModel.  Yang terakhir, misalnya, terjadi ketika membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kontrol formulir kustom</a> . <br><br>  Tetapi katakanlah kita membuat komponen penghitung khusus (dan tidak ingin menggunakan kontrol formulir khusus). <br><br><pre> <code class="javascript hljs">@Component({ <span class="hljs-attr"><span class="hljs-attr">selector</span></span>: <span class="hljs-string"><span class="hljs-string">'custom-counter'</span></span>, <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-string"><span class="hljs-string">` &lt;button (click)="decrement()"&gt;-&lt;/button&gt; &lt;span&gt;{{counter}}&lt;/span&gt; &lt;button (click)="increment()"&gt;+&lt;/button&gt; `</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomCounterComponent</span></span></span><span class="hljs-class"> </span></span>{ counterValue = <span class="hljs-number"><span class="hljs-number">0</span></span>; get counter() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counterValue; } set counter(value) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counterValue = value; } decrement() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counter--; } increment() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counter++; } }</code> </pre><br>  Kami memiliki properti komponen <b>penghitung</b> untuk menampilkan nilai penghitung saat ini.  Untuk memberikannya pengikatan dua arah, hal pertama yang harus dilakukan adalah mengubahnya menjadi parameter <b>Input</b> .  Untuk ini, dekorator <b>@Input ()</b> sangat berguna: <br><br><pre> <code class="javascript hljs">@Component() <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomCounterComponent</span></span></span><span class="hljs-class"> </span></span>{ counterValue = <span class="hljs-number"><span class="hljs-number">0</span></span>; @Input() get counter() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counterValue; } ... }</code> </pre><br>  Ini sudah memungkinkan Anda untuk mengikat properti komponen ke konsumen sebagai berikut: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">custom-counter</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">counter</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"someValue"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">custom-counter</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Sekarang kita perlu mengatur <b>event @Output ()</b> dengan nama yang sama ( <b>counter</b> ) dan suffix <b>Change</b> (ternyata counterChange).  Kami ingin meningkatkan acara ini setiap kali perubahan <b>counter</b> .  Mengapa menambahkan properti <b>@Output ()</b> .  Dan kami menyelesaikan, dalam beberapa getter, counter setter, di mana kami akan mencegat perubahan nilai dan membuang acara dengan nilai counter saat ini: <br><br><pre> <code class="javascript hljs">@Component() <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomCounterComponent</span></span></span><span class="hljs-class"> </span></span>{ ... @Output() counterChange = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventEmitter(); set counter(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counterValue = val; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counterChange.emit(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counterValue); } ... }</code> </pre><br>  Ini dia!  Sekarang kita dapat mengikat ekspresi ke properti ini menggunakan sintaks pengikatan data dua arah: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">custom-counter</span></span></span><span class="hljs-tag"> [(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">counter</span></span></span><span class="hljs-tag">)]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"someValue"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">custom-counter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>counterValue = {{someValue}}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">demo</a> dan coba! <br><br>  Sekali lagi, perlu diingat bahwa komponen seperti penghitung kustom paling baik diimplementasikan dengan kontrol formulir kustom, dan manfaatkan <b>ngModel</b> untuk menerapkan pengikatan data dua arah, seperti dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini</a> . <br><br><a name="conclusion"></a><h3>  Kesimpulan </h3><br>  Angular tidak lagi hadir dengan pengikatan data dua arah bawaan.  Sebaliknya, ada API di kotak yang memungkinkan Anda untuk menerapkan ikatan penuh sebagai properti dan acara yang mengikat. <br><br>  <b>ngModel</b> hadir sebagai direktif pengikatan dua arah bawaan di FormsModule (jangan lupa untuk menambahkannya ke bagian <b>impor</b> pada deklarasi <b>@NgModule</b> : sekitar per).  Menautkan melalui ngModel harus lebih disukai saat membuat komponen yang berfungsi sebagai kontrol formulir kustom.  Kalau tidak, itu semua tergantung pada imajinasi Anda. <br><br>  <b>PS dari penerjemah:</b> <i>implementasi yang mengikat dalam A2 + telah menjadi lebih modern.</i>  <i>Sekarang, hampir set "bebas" digunakan untuk memantau perubahan dengan "feng shui" (meskipun jelas bahwa mekanisme untuk pemeriksaan kotor tetap, setidaknya untuk komponen pengguna tingkat tinggi).</i>  <i>Ini memungkinkan untuk meninggalkan 100.500 pengamat (prosedur memantau perubahan dalam data "mereka").</i>  <i>Yang di A1 suka membuat muatan berbahaya di browser dan membutuhkan tangan langsung yang tidak biasa ketika merencanakan halaman interaktif yang kaya.</i> <i><br><br></i>  <i>Dengan komponen yang dirancang dengan benar, A2 out of the box telah menjadi jauh lebih responsif.</i>  <i>Biarkan dengan mengorbankan pekerjaan programmer.</i>  <i>Sekarang Anda dapat menempatkan sejumlah besar komponen pada halaman dan jangan khawatir tentang sumber daya prosesor.</i> <i><br><br></i>  <i>Sisi lain dari koin adalah biaya awal dari "proses masuk" di A2 +, yang mempengaruhi popularitas kerangka kerja.</i>  <i>Tetapi A1 juga memiliki biaya masuk yang tinggi, hanya saja ia diturunkan ke liga utama.</i>  <i>Karena kurangnya pemahaman tentang bagaimana mengatur aplikasi besar, banyak prototipe "lepas landas" pada A1, kemudian "hancur" dan berhubungan dengan Bereaksi dan Vue.</i> <i><br><br></i>  <i>Saya berharap bahwa dengan artikel ini saya akan membantu sedikit menurunkan ambang untuk pintu masuk awal ke A2 +, yang terus diminati (yang saya tahu secara langsung).</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id453696/">https://habr.com/ru/post/id453696/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id453682/index.html">Pengembangan "firmware" paling sederhana untuk FPGA yang dipasang di Redd. Bagian 2. Kode program</a></li>
<li><a href="../id453686/index.html">Pekan Keamanan 22: statistik ancaman, trojan perbankan, dan eksploitasi populer</a></li>
<li><a href="../id453688/index.html">Java tidak hanya berdarah perusahaan, tetapi juga aplikasi yang sensitif terhadap latensi cepat</a></li>
<li><a href="../id453692/index.html">Game 3D Shaders for Beginners: Effects</a></li>
<li><a href="../id453694/index.html">Terhubung ke Windows melalui SSH seperti di Linux</a></li>
<li><a href="../id453698/index.html">Informasi kuantum dalam kesadaran kuantum</a></li>
<li><a href="../id453700/index.html">Pelajaran tentang SDL 2: Pelajaran 1 - Halo, SDL 2</a></li>
<li><a href="../id453706/index.html">Bagaimana Saya Lulus dari Ujian Sertifikasi Insinyur Data Google Cloud Professional</a></li>
<li><a href="../id453708/index.html">OS real-time AQUA RTOS untuk MK AVR di lingkungan BASCOM AVR</a></li>
<li><a href="../id453710/index.html">Praktik pengembangan dalam proyek-proyek besar: mitp SberPractice iOS # 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>