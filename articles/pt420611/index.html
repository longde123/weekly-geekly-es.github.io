<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òîÔ∏è üíáüèæ üÜö Modelando emaranhamento qu√¢ntico em C # üë© ‚ô•Ô∏è üèúÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="√Ä medida que o t√≥pico do entrela√ßamento qu√¢ntico aparece cada vez mais, eu queria ir um pouco mais fundo. A julgar pelos coment√°rios nos artigos sobre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Modelando emaranhamento qu√¢ntico em C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420611/">  √Ä medida que o t√≥pico do entrela√ßamento qu√¢ntico aparece cada vez mais, eu queria ir um pouco mais fundo.  A julgar pelos coment√°rios nos artigos sobre entrela√ßamento qu√¢ntico, essas informa√ß√µes n√£o ser√£o √∫teis apenas para mim.  Bem, levando em considera√ß√£o o fato de que, para a maioria de n√≥s, o c√≥digo do programa √© muito mais conveniente do que qualquer alegoria, foi decidido apresentar meu entendimento na forma de c√≥digo. <br><a name="habracut"></a><br>  Este artigo estende o artigo de outro autor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">, "Quantum Entanglement for Dummies"</a> (eu recomendo a leitura, isso me ajudou muito).  Em seu artigo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">indomit</a> deu um exemplo de um programa que demonstra claramente o problema da teoria dos par√¢metros ocultos, mas n√£o poderia dar um exemplo de um c√≥digo para part√≠culas em superposi√ß√£o.  Neste artigo, tentaremos simular 2 casos: <br><br><ol><li>  Como as part√≠culas entrela√ßadas se comportariam no determinismo, quando o estado das part√≠culas √© estabelecido antes da medi√ß√£o, simplesmente n√£o podemos medi-lo sem introduzir distor√ß√µes (a pr√≥pria teoria dos par√¢metros ocultos).  Obtemos os n√∫meros e vemos a discrep√¢ncia com a pr√°tica. </li><li>  Escreveremos um modelo de part√≠culas emaranhadas em superposi√ß√£o (o estado das part√≠culas n√£o √© definido antes da medi√ß√£o).  Vamos tentar assumir como a part√≠cula √© programada dentro, ou seja, ajustaremos seu c√≥digo aos dados obtidos experimentalmente. </li></ol><br>  O artigo baseia-se na explica√ß√£o popular do fen√¥meno do entrela√ßamento qu√¢ntico de Mermin: <br><br><div class="spoiler">  <b class="spoiler_title">O Paradoxo de Mermin Explicado</b> <div class="spoiler_text">  Para o relato popular do paradoxo, D. Mermin prop√µe construir um dispositivo simples [23].  O dispositivo deve consistir de um emissor de part√≠culas e dois detectores.  Duas part√≠culas id√™nticas s√£o emitidas para cada uma delas.  Depois de capturar uma part√≠cula, o detector fornece uma resposta bin√°ria (0 ou 1), dependendo da part√≠cula e do interruptor de ajuste de tr√™s posi√ß√µes.  A detec√ß√£o de um par de part√≠culas deve fornecer as mesmas respostas: <br><br><ol><li>  Sempre que os detectores s√£o configurados da mesma maneira. </li><li>  Segundo as estat√≠sticas, na metade dos casos, quando s√£o configurados aleatoriamente. </li></ol><br>  A primeira propriedade requer que todos os detectores usem a mesma codifica√ß√£o, a posi√ß√£o do comutador √© ‚àà {1,2,3} ‚Ü¶ resposta ‚àà {0,1}, sem nenhum elemento aleat√≥rio.  Ou seja, eles devem concordar antecipadamente qual das respostas, 0 ou 1, fornece √† posi√ß√£o do comutador, escolhendo para cada part√≠cula uma das oito fun√ß√µes poss√≠veis, 000, 001, 010, 011, 100, 101, 110 e 111. A escolha de 000 ou 111 resultar√° em 100% de coincid√™ncia das leituras dos detectores, independentemente da posi√ß√£o do bot√£o de controle.  Se os detectores implementarem uma das seis fun√ß√µes restantes, um dos d√≠gitos √© pressionado por um interruptor sintonizado aleatoriamente em 2/3 dos casos, o outro com uma probabilidade de 1/3.  A probabilidade de coincid√™ncia das duas respostas ser√° (‚Öî) ¬≤ + (‚Öì) ¬≤ = 5/9.  Portanto, n√£o importa qual seja o algoritmo do aut√¥mato, a correla√ß√£o inevitavelmente excede 50%, violando o segundo requisito. <br><br>  <i>Mas como essa m√°quina ainda pode ser constru√≠da (por exemplo, posicionando os polarizadores a 120 ¬∞ como no experimento de Bohm), n√£o pode haver determinismo (par√¢metros), mesmo de forma oculta.</i>  <i>Em vez disso, as correla√ß√µes de resposta s√£o mantidas pela transmiss√£o de informa√ß√µes de uma part√≠cula "medida" para outra mais rapidamente que a segunda medi√ß√£o.</i> <br><br>  Retirado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">daqui</a> . <br></div></div><br>  Infelizmente, eu n√£o pratico f√≠sica nem profissionalmente nem no n√≠vel amador, n√£o finjo ser impec√°vel.  O objetivo principal do artigo √© demonstrar como tornar um modelo compreens√≠vel para aqueles familiarizados com a programa√ß√£o.  Se algu√©m trabalha profissionalmente nesse campo, em vez de censurar, tente escrever modelos de intera√ß√£o mais precisos com base no meu artigo. <br><br><h2>  [Update] Explica√ß√£o da descri√ß√£o do Mermin </h2><br>  Embora v√°rios meses se passaram desde a reda√ß√£o do artigo e ningu√©m retorne a ele, decidi fazer um esclarecimento para acalmar minha consci√™ncia. <br><br>  Fui um pouco mais fundo e cheguei √† conclus√£o de que a descri√ß√£o de acordo com Mermin √© bastante simplificada e as tentativas de vincul√°-la a experimentos f√≠sicos reais <i>n√£o</i> t√™m <i>sentido</i> . <br><br>  Inicialmente, tentei vincular o artigo a um experimento real com polariza√ß√£o circular e cometi um erro nisso.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">O ARad</a> tentou desenvolver uma liga√ß√£o a experimentos f√≠sicos reais, escreveu sobre os erros cometidos e at√© prop√¥s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sua pr√≥pria vers√£o do c√≥digo</a> (que tamb√©m n√£o corresponde a nenhum experimento f√≠sico). <br><br>  Para que o artigo fizesse algum sentido, foi decidido remover todos os links imagin√°rios de experimentos f√≠sicos reais e simplesmente <i>explicar a descri√ß√£o de Mermin no c√≥digo</i> e torn√°-lo mais visual.  Experimentos reais s√£o mais complicados e, para simul√°-los, voc√™ precisa gastar muito mais tempo. <br><br>  Na primeira vers√£o do artigo, aceitamos que no primeiro experimento (a posi√ß√£o dos sensores coincide) as part√≠culas d√£o um resultado espelhado, mas na descri√ß√£o original de acordo com Mermin, o resultado da medi√ß√£o com a mesma posi√ß√£o dos sensores sempre coincide.  Isso est√° <i>consertado</i> . <br><br>  Al√©m disso, acrescentarei uma "explica√ß√£o para uma explica√ß√£o" deste pr√≥prio Mermin, uma vez que n√£o est√° escrito sem ambiguidade: <br><br><blockquote>  Ou seja, eles devem concordar antecipadamente qual das respostas, 0 ou 1, atribui √† posi√ß√£o do comutador, escolhendo para cada part√≠cula uma das oito fun√ß√µes poss√≠veis, 000, 001, 010, 011, 100, 101, 110 e 111. <br></blockquote><br>  A frase "oito fun√ß√µes poss√≠veis" √© amb√≠gua.  Oito variantes poss√≠veis do impacto <i>potencial</i> de part√≠culas no sensor s√£o discutidas.  O sensor possui tr√™s posi√ß√µes (veja a descri√ß√£o completa acima).  Se acreditarmos que o estado das duas part√≠culas coincide e √© definido com anteced√™ncia, podemos determinar com anteced√™ncia qual resposta (0 ou 1) receberemos potencialmente para cada uma das tr√™s posi√ß√µes do comutador (embora possamos "medir" apenas uma das tr√™s op√ß√µes). <br><br><blockquote>  Selecionar 000 ou 111 resultar√° em 100% de correspond√™ncia das leituras do detector, independentemente da posi√ß√£o do bot√£o de ajuste. </blockquote><br>  Se as part√≠culas puderem assumir um valor no qual possamos receber potencialmente uma resposta "1" para qualquer posi√ß√£o do comutador (assim como 0 para qualquer posi√ß√£o do comutador), o segundo experimento nesses casos fornecer√° 100% de coincid√™ncia.  Para se aproximar de 50%, essas op√ß√µes podem ser exclu√≠das. <br><br><blockquote>  Se os detectores implementarem uma das seis fun√ß√µes restantes, um dos d√≠gitos √© pressionado por um interruptor sintonizado aleatoriamente em 2/3 dos casos, o outro com uma probabilidade de 1/3. </blockquote><br>  Isso significa que em cada um dos 6 triplos (001, 010, 011, 100, 101, 110) - apenas dois dos tr√™s d√≠gitos correspondem (na primeira vers√£o, dois dos tr√™s s√£o "0" e um dos tr√™s √© "1" ) <br><br>  Para avaliar a probabilidade, compilamos uma tabela para o primeiro caso <b>001</b> : <br><br><table><tbody><tr><th>  Posi√ß√£o do sensor 1 </th><th>  Posi√ß√£o do sensor 2 </th><th>  As medidas correspondem </th></tr><tr><td>  1 </td><td>  1 </td><td>  + </td></tr><tr><td>  1 </td><td>  2 </td><td>  + </td></tr><tr><td>  1 </td><td>  3 </td><td>  - </td></tr><tr><td>  2 </td><td>  1 </td><td>  + </td></tr><tr><td>  2 </td><td>  2 </td><td>  + </td></tr><tr><td>  2 </td><td>  3 </td><td>  - </td></tr><tr><td>  3 </td><td>  1 </td><td>  - </td></tr><tr><td>  3 </td><td>  2 </td><td>  - </td></tr><tr><td>  3 </td><td>  3 </td><td>  + </td></tr></tbody></table><br>  Pode-se observar que em cinco casos de nove medi√ß√µes coincidem.  A mesma probabilidade ser√° para cada uma dessas seis op√ß√µes (afinal, em cada uma delas os dois n√∫meros s√£o iguais). <br><br><h2>  Medi√ß√µes </h2><br>  Em cada um dos modelos (determin√≠sticos e superposicionais), realizaremos dois experimentos com part√≠culas emaranhadas correspondentes √†s primeira e segunda condi√ß√µes de acordo com Mermin: <br><br><ol><li>  Primeiro, coloque os dois sensores na mesma posi√ß√£o.  Nesse caso, obteremos resultados 100% id√™nticos (se o primeiro f√≥ton passar pelo polarizador, o f√≥ton associado tamb√©m passar√° pelo polarizador no mesmo √¢ngulo). </li><li>  Em seguida, definiremos a posi√ß√£o dos sensores aleatoriamente. </li></ol><br>  Aqui est√° o c√≥digo para o primeiro experimento: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> totalAttempts = <span class="hljs-number"><span class="hljs-number">10000</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     var position = GetRandomInteger(1, 3); //        //            int firstSensorPosition = position; int secondSensorPosition = position; bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" ‚Ññ1: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); //  </span></span></code> </pre> <br>  Aqui est√° o c√≥digo para o segundo experimento: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> totalAttempts = <span class="hljs-number"><span class="hljs-number">10000</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     int firstSensorPosition = GetRandomInteger(1, 3); //      1 int secondSensorPosition = GetRandomInteger(1, 3); //      2 bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" ‚Ññ2: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100);</span></span></code> </pre><br>  Os mesmos testes ser√£o para todos os modelos de part√≠culas, apenas o c√≥digo de part√≠culas ser√° diferente para os modelos determin√≠stico e de superposi√ß√£o (mais sobre isso abaixo). <br><br><h2>  Modelo determin√≠stico </h2><br>  Aten√ß√£o!  Veja ATUALIZA√á√ÉO no final do artigo! <br><br>  Para quem deseja executar imediatamente o c√≥digo, isso pode ser feito no navegador: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dotnetfiddle.net/N5Xg18</a> <br><br>  Ent√£o, de acordo com a explica√ß√£o de Mermin, temos uma part√≠cula qu√¢ntica com 3 par√¢metros: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   ( , ) public class Particle { private bool _measured = false; public bool A { get; private set; } //       1 public bool B { get; private set; } //       2 public bool C { get; private set; } //       3 public Particle(bool a, bool b, bool c) { A = a; B = b; C = c; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (_measured) throw new InvalidOperationException("    !"); _measured = true; switch (sensorPosition) { case 1: return A; case 2: return B; case 3: return C; default: throw new ArgumentOutOfRangeException(); } } }</span></span></code> </pre><br>  Como o modelo √© determin√≠stico, todos os par√¢metros da part√≠cula s√£o inicializados no momento de sua cria√ß√£o, ou seja, diretamente no construtor.  A √∫nica condi√ß√£o √© que a medi√ß√£o seja permitida apenas uma vez! <br><br>  Pr√≥ximo.  Um par de part√≠culas emaranhadas: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (   ,         ) public EntanglementParticles() { //         bool a; bool b; bool c; do { a = GetRandomBoolean(); //     1 b = GetRandomBoolean(); //     2 c = GetRandomBoolean(); ; //     3 } while (a == b &amp;&amp; b == c); //   000  111 (    ,       ) First = new Particle(a, b, c); Second = new Particle(a, b, c); //       } }</span></span></code> </pre><br><br>  Pode-se observar que os valores de cada uma das part√≠culas s√£o definidos no momento da cria√ß√£o de um par de part√≠culas emaranhadas, e os par√¢metros da segunda part√≠cula correspondem aos par√¢metros da primeira (sem isso, n√£o podemos passar no primeiro teste).  Utilizamos n√∫meros aleat√≥rios, mas, de acordo com o modelo, os par√¢metros dependem de fatores no momento do emaranhado (como resultado da roleta, depende de v√°rios fatores no momento de desenroscar). <br><br>  C√≥digo de exemplo completo: <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo C # do modelo determin√≠stico (fixo)</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Random Random = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); <span class="hljs-comment"><span class="hljs-comment">//   public class Particle { private bool _measured = false; public bool A { get; private set; } //       1 public bool B { get; private set; } //       2 public bool C { get; private set; } //       3 public Particle(bool a, bool b, bool c) { A = a; B = b; C = c; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (_measured) throw new InvalidOperationException("    !"); _measured = true; switch (sensorPosition) { case 1: return A; case 2: return B; case 3: return C; default: throw new ArgumentOutOfRangeException(); } } } //    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (   ,         ) public EntanglementParticles() { //         bool a; bool b; bool c; do { a = GetRandomBoolean(); //     1 b = GetRandomBoolean(); //     2 c = GetRandomBoolean();; //     3 } while (a == b &amp;&amp; b == c); //   000  111 (   ,       ) First = new Particle(a, b, c); Second = new Particle(a, b, c); //       } } public static void Main(string[] args) { Experiment1(); Experiment2(); } private static void Experiment1() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     var position = GetRandomInteger(1, 3); //        //            int firstSensorPosition = position; int secondSensorPosition = position; bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" ‚Ññ1: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); //   } private static void Experiment2() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     int firstSensorPosition = GetRandomInteger(1, 3); //      1 int secondSensorPosition = GetRandomInteger(1, 3); //      2 bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" ‚Ññ2: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); } private static bool GetRandomBoolean() { return GetRandomInteger(0, 1) == 1; } private static int GetRandomInteger(int from, int to) { return Random.Next(from, to + 1); //          } }</span></span></code> </pre><br></div></div><br>  Voc√™ pode inici√°-lo no navegador (mais uma vez no link: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dotnetfiddle.net/N5Xg18</a> ). <br><br>  Ap√≥s o lan√ßamento, estes s√£o os resultados: <br><br><blockquote>  Experi√™ncia n¬∫ 1: 100% dos valores coincidiram <br>  Experi√™ncia n¬∫ 2: 55,6700% dos valores correspondentes <br></blockquote><br>  O primeiro teste aprovado, corresponde ao que est√° acontecendo na realidade.  Mas o segundo - n√£o corresponde, pois devem receber 50%! <br><br>  Como resultado, os f√≠sicos foram for√ßados a chegar √† conclus√£o de que a teoria dos par√¢metros ocultos √© err√¥nea.  E com isso, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">princ√≠pio da localidade √©</a> refutado e o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">princ√≠pio da causalidade foi</a> at√© abalado. <br><br><h2>  Modelo de superposi√ß√£o </h2><br>  Imediatamente um link para um c√≥digo de exemplo, para quem gosta de detalhes (pode ser iniciado em um navegador): <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dotnetfiddle.net/Mb7JqU</a> <br><br>  Para explicar os resultados obtidos durante os experimentos, foi necess√°rio o uso de modelos mais complexos.  Nos modelos modernos, o estado dos par√¢metros das part√≠culas n√£o √© definido antes da medi√ß√£o e as pr√≥prias part√≠culas emaranhadas t√™m a capacidade de afetar instantaneamente (al√©m da velocidade da luz) o estado uma da outra.  Aqui est√° a apar√™ncia do nosso modelo de part√≠culas agora: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   public class Particle { private Particle _superluminalChannel; //         . private int? _measuredPosition; public bool? A { get; private set; } //       1 public bool? B { get; private set; } //       2 public bool? C { get; private set; } //       3 internal void CreateSuperluminalChannelWith(Particle particle) { _superluminalChannel = particle; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (null != _measuredPosition) throw new InvalidOperationException("    !"); _measuredPosition = sensorPosition; if (null != _superluminalChannel._measuredPosition) //        { var measuredValue = _superluminalChannel.GetNakedValue(); //         (    ),   ,     . if (sensorPosition == _superluminalChannel._measuredPosition) return measuredValue; if (GetRandomInteger(1, 4) == 1) return measuredValue; return !measuredValue; } //  .        ,       -  . //   ! var value = GetRandomBoolean(); SetValue(sensorPosition, value); return value; } private bool GetNakedValue() //           ,    . { if (null == _measuredPosition) throw new InvalidOperationException(); switch (_measuredPosition.Value) { case 1: return A.Value; case 2: return B.Value; case 3: return C.Value; default: throw new InvalidOperationException(); } } private void SetValue(int position, bool value) { switch (position) { case 1: A = value; break; case 2: B = value; break; case 3: C = value; break; default: throw new ArgumentOutOfRangeException(); } } }</span></span></code> </pre><br>  Primeiro, os par√¢metros s√£o Anul√°veis ‚Äã‚Äã(eles podem n√£o importar) e n√£o os definimos no construtor.  Em segundo lugar, o m√©todo CreateSuperluminalChannelWith para definir o canal superluz entre part√≠culas, ou seja,  Agora, uma part√≠cula pode obter o estado de outra instantaneamente, independentemente da dist√¢ncia.  Bem, e mais importante, agora o estado de uma part√≠cula √© <i>estabelecido apenas no momento da medi√ß√£o</i> (chamando o m√©todo GetValue) e depende se outra part√≠cula relacionada a ela foi medida. <br><br>  O interior do m√©todo GetValue √© pura especula√ß√£o.  Ningu√©m sabe como a part√≠cula √© organizada no interior, mas sabemos que funciona assim: 100% de incompatibilidade ao medir o mesmo par√¢metro e 50% de incompatibilidade ao medir par√¢metros em uma ordem aleat√≥ria. <br><br>  Na minha vers√£o do c√≥digo, uma part√≠cula atrav√©s de um canal superluminal verifica se a medi√ß√£o √© confundida com ela e age assim: <br><br><ol><li>  Se o par√¢metro medido de outra part√≠cula for o mesmo que estamos tentando medir, ele fornecer√° o mesmo valor. </li><li>  Se o par√¢metro for diferente, em 1/4 dos casos, obt√©m o mesmo valor, e em 3/4 dos casos, fornece o valor oposto (j√° que obtemos 50/50). </li></ol><br>  Se a medi√ß√£o n√£o foi realizada, a part√≠cula usa a aleatoriedade verdadeira para definir seu valor, ou seja, uma rela√ß√£o causal √© violada (o valor n√£o existia antes da medi√ß√£o e a pr√≥pria medi√ß√£o n√£o determinava seu valor). <br><br>  <i>A prop√≥sito!</i>  <i>Voc√™ pode reescrever essa fun√ß√£o de outra maneira, mas para que os resultados do teste sejam os mesmos.</i>  <i>Mesmo assim, ningu√©m sabe como a part√≠cula elementar √© organizada e como 50% √© alcan√ßado no segundo teste.</i> <i><br></i> <br>  Um par de part√≠culas emaranhadas ficou mais f√°cil, pois no momento do emaranhamento nenhum valor √© definido (os valores ainda n√£o foram determinados): <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (  ,   ) public EntanglementParticles() { First = new Particle(); //   ,    Second = new Particle(); //   ,    //         First.CreateSuperluminalChannelWith(Second); Second.CreateSuperluminalChannelWith(First); } }</span></span></code> </pre><br>  C√≥digo de exemplo completo: <br><br><div class="spoiler">  <b class="spoiler_title">Modelo de superposi√ß√£o em C #</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Random Random = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); <span class="hljs-comment"><span class="hljs-comment">//   public class Particle { private Particle _superluminalChannel; //         . private int? _measuredPosition; public bool? A { get; private set; } //       1 public bool? B { get; private set; } //       2 public bool? C { get; private set; } //       3 internal void CreateSuperluminalChannelWith(Particle particle) { _superluminalChannel = particle; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (null != _measuredPosition) throw new InvalidOperationException("    !"); _measuredPosition = sensorPosition; if (null != _superluminalChannel._measuredPosition) //        { var measuredValue = _superluminalChannel.GetNakedValue(); //         (    ),   ,     . if (sensorPosition == _superluminalChannel._measuredPosition) return measuredValue; if (GetRandomInteger(1, 4) == 1) return measuredValue; return !measuredValue; } //  .        ,       -  . //   ! var value = GetRandomBoolean(); SetValue(sensorPosition, value); return value; } private bool GetNakedValue() //           ,    . { if (null == _measuredPosition) throw new InvalidOperationException(); switch (_measuredPosition.Value) { case 1: return A.Value; case 2: return B.Value; case 3: return C.Value; default: throw new InvalidOperationException(); } } private void SetValue(int position, bool value) { switch (position) { case 1: A = value; break; case 2: B = value; break; case 3: C = value; break; default: throw new ArgumentOutOfRangeException(); } } } //    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (  ,   ) public EntanglementParticles() { First = new Particle(); //   ,    Second = new Particle(); //   ,    //         First.CreateSuperluminalChannelWith(Second); Second.CreateSuperluminalChannelWith(First); } } public static void Main(string[] args) { Experiment1(); Experiment2(); } private static void Experiment1() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     var position = GetRandomInteger(1, 3); //        //            int firstSensorPosition = position; int secondSensorPosition = position; bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" ‚Ññ1: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); //   } private static void Experiment2() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     int firstSensorPosition = GetRandomInteger(1, 3); //      1 int secondSensorPosition = GetRandomInteger(1, 3); //      2 bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" ‚Ññ2: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); } private static bool GetRandomBoolean() { return GetRandomInteger(0, 1) == 1; } private static int GetRandomInteger(int from, int to) { return Random.Next(from, to + 1); //          } }</span></span></code> </pre><br></div></div><br>  Resultados: <br><br><blockquote>  Experi√™ncia n¬∫ 1: 100% dos valores coincidiram <br>  Experi√™ncia n¬∫ 2: 49,7700% dos valores coincidiram <br></blockquote><br>  Executar no navegador: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dotnetfiddle.net/Mb7JqU</a> <br><br><h2>  Conclus√µes </h2><br>  Gostaria de mais interpreta√ß√µes dispon√≠veis, como as expressas por Mermin.  Com base nessa interpreta√ß√£o, consegui criar modelos visuais de teorias existentes e at√© apresentar um modelo alternativo, e esses modelos n√£o s√£o aleg√≥ricos - voc√™ pode execut√°-los e ver como eles funcionam. <br><br>  Infelizmente, n√£o tenho recursos de tempo para um conhecimento mais profundo da f√≠sica qu√¢ntica e espero que aqueles que conhecem possam seguir o meu exemplo e fornecer modelos de trabalho mais precisos. <br><br>  <b>ATUALIZA√á√ÉO</b> <br>  A explica√ß√£o de Mermin n√£o tem nada a ver com o design de detectores.  Por minha pr√≥pria iniciativa, adicionei uma explica√ß√£o para A, B e C como uma proje√ß√£o da rota√ß√£o nos eixos X, Y e Z, respectivamente.  Ou seja, eu queria adicionar uma liga√ß√£o aos fen√¥menos f√≠sicos nos coment√°rios ao c√≥digo para que n√£o ficasse t√£o seco.  E eu estava enganado nisso ... <br><br>  O artigo √© corrigido e todas as tentativas v√£s de vincular a explica√ß√£o de Mermin a experimentos f√≠sicos reais s√£o exclu√≠das. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt420611/">https://habr.com/ru/post/pt420611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt420599/index.html">Treze coisas que Lem previram</a></li>
<li><a href="../pt420603/index.html">Estat√≠sticas do propriet√°rio do Tesla Model S</a></li>
<li><a href="../pt420605/index.html">Vis√£o Geral do Algoritmo da Entrevista de Trabalho - Gera√ß√£o de Conjunto</a></li>
<li><a href="../pt420607/index.html">Eventos digitais em Moscou de 20 a 26 de agosto</a></li>
<li><a href="../pt420609/index.html">O resumo de materiais frescos do mundo do front-end da √∫ltima semana n ¬∞ 327 (13 a 19 de agosto de 2018)</a></li>
<li><a href="../pt420613/index.html">11 bibliotecas (conjuntos de componentes) para o React Native que voc√™ deve conhecer em 2018</a></li>
<li><a href="../pt420615/index.html">JavaScript: explorando objetos</a></li>
<li><a href="../pt420617/index.html">Guia de web design para desenvolvedores</a></li>
<li><a href="../pt420619/index.html">Imagens responsivas: truques CSS que economizam tempo</a></li>
<li><a href="../pt420623/index.html">Aplicativos C ++ distribu√≠dos com um m√≠nimo de esfor√ßo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>