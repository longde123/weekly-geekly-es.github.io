<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëèüèª üîà üòÅ Rosqueamento adequado no Qt ‚ô£Ô∏è ‚ô®Ô∏è üåã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Qt √© uma estrutura extremamente poderosa e conveniente para C ++. Mas essa conveni√™ncia tem uma desvantagem: muitas coisas no Qt acontecem ocultas ao ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rosqueamento adequado no Qt</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467261/">  Qt √© uma estrutura extremamente poderosa e conveniente para C ++.  Mas essa conveni√™ncia tem uma desvantagem: muitas coisas no Qt acontecem ocultas ao usu√°rio.  Na maioria dos casos, a funcionalidade correspondente no Qt funciona ‚Äúmagicamente‚Äù e ensina o usu√°rio a simplesmente considerar essa m√°gica como garantida.  No entanto, quando a m√°gica se quebra, √© extremamente dif√≠cil reconhecer e resolver um problema que de repente aparece em um n√≠vel aparentemente plano. <br><br>  Este artigo √© uma tentativa de sistematizar como o Qt "sob o cap√¥" implementa o trabalho com fluxos e sobre v√°rias armadilhas n√£o √≥bvias associadas √†s limita√ß√µes deste modelo. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O b√°sico</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Afinidade, inicializa√ß√£o e suas limita√ß√µes de encadeamento</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Thread principal, QCoreApplication e GUI</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Thread de renderiza√ß√£o</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Conclus√£o</a> <br><br><a name="habracut"></a><a name="part1"></a><h3>  O b√°sico </h3><br>  Vamos come√ßar com o b√°sico.  No Qt, todos os objetos capazes de manipular sinais e slots s√£o descendentes da classe QObject.  Esses objetos, por design, s√£o imposs√≠veis de copiar e representam logicamente algumas entidades individuais que "conversam" entre si - reagem a determinados eventos e podem gerar eventos.  Em outras palavras, o QObject no Qt implementa o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">padr√£o de atores</a> .  Se implementado corretamente, qualquer programa Qt nada mais √© do que uma rede de QObjects interagindo entre si, na qual toda a l√≥gica do programa "vive". <br><br>  Al√©m de um conjunto de QObjects, um programa Qt pode incluir objetos de dados.  Esses objetos n√£o podem gerar e receber sinais, mas podem ser copiados.  Por exemplo, voc√™ pode comparar QStringList e QStringListModel entre si.  Um deles √© o QObject e n√£o √© copi√°vel, mas pode interagir diretamente com os objetos da interface do usu√°rio, o outro √© um cont√™iner de dados copi√°vel comum.  Por sua vez, os objetos com dados s√£o divididos em ‚ÄúQt Meta-types‚Äù e todos os outros.  Por exemplo, QStringList √© do tipo Qt Meta, mas std :: list &lt;std :: string&gt; (sem gestos adicionais) n√£o √©.  O primeiro pode ser usado em qualquer contexto Qt-shnom (transmitido por sinais, em QVariant etc.), mas requer um procedimento de registro especial e a classe deve ter um destruidor p√∫blico, construtor de c√≥pias e construtor padr√£o.  O segundo s√£o tipos arbitr√°rios de C ++. <br><br><a name="part2"></a><h3>  V√° diretamente para os threads reais </h3><br>  Portanto, temos "dados" condicionais e existe um "c√≥digo" condicional que funciona com eles.  Mas quem realmente executar√° esse c√≥digo?  No modelo Qt, a resposta a esta pergunta √© definida explicitamente: cada QObject est√° estritamente vinculado a algum encadeamento QThread que, de fato, est√° envolvido em slots de manuten√ß√£o e outros eventos desse objeto.  Um encadeamento pode servir muitos QObjects de uma s√≥ vez, ou nenhum, mas o QObject sempre tem um encadeamento pai e √© sempre exatamente um.  De fato, podemos assumir que cada QThread "possui" algum conjunto de QObject.  Na terminologia Qt, isso √© chamado de afinidade de segmento.  Vamos tentar visualizar para maior clareza: <br><br><img src="https://habrastorage.org/webt/zs/py/t2/zspyt2yti1t8-mr6k708rer0rao.png"><br><br>  Dentro de cada QThread h√° uma fila de mensagens endere√ßadas a objetos que esse QThread ‚Äúpossui‚Äù.  No modelo Qt, sup√µe-se que, se queremos que um QObject execute alguma a√ß√£o, "enviamos" uma mensagem QEvent para esse QObject: <br><br><pre><code class="cpp hljs">QCoreApplication::postEvent(QObject *receiver, QEvent *event, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority);</code> </pre> <br>  Nesta chamada de thread-safe, Qt localiza o QThread ao qual o objeto receptor pertence, grava o QEvent na fila de mensagens desse thread e ativa esse thread, se necess√°rio.  Espera-se que o c√≥digo em execu√ß√£o neste QThread em algum momento depois disso leia a mensagem da fila e execute a a√ß√£o correspondente.  Para que isso realmente ocorra, o c√≥digo no QThread deve inserir o loop de eventos QEventLoop, criando o objeto apropriado e chamando-o de m√©todo exec () ou processEvents ().  A primeira op√ß√£o entra em um loop infinito de processamento de mensagens (antes que o QEventLoop receba o evento quit ()), a segunda se limita ao processamento de mensagens que foram acumuladas anteriormente na fila. <br><br><img src="https://habrastorage.org/webt/8x/ia/6o/8xia6o7i8wf0q5hoxkvzdjsl9xq.png"><br><br>  √â f√°cil ver que os eventos para todos os objetos pertencentes a um encadeamento s√£o processados ‚Äã‚Äãsequencialmente.  Se o processamento de um evento por um encadeamento demorar muito, todos os outros objetos ser√£o "congelados" - seus eventos ser√£o acumulados na fila do fluxo, mas n√£o ser√£o processados.  Para impedir que isso aconte√ßa, o Qt oferece a possibilidade de multitarefa cooperativa - os manipuladores de eventos em qualquer lugar podem "interromper temporariamente" criando um novo QEventLoop e passando o controle para ele.  Como o manipulador de eventos tamb√©m foi chamado anteriormente de QEventLoop no fluxo, com essa abordagem, uma cadeia de loops de eventos "aninhados" um no outro √© formada. <br><br><div class="spoiler">  <b class="spoiler_title">Algumas palavras sobre o Event Dispatcher</b> <div class="spoiler_text">  Estritamente falando, o QEventLoop nada mais √© do que um inv√≥lucro f√°cil de usar sobre um primitivo de n√≠vel inferior dependente do sistema chamado Event Dispatcher e implementa a interface QAbstractEventDispatcher.  √â ele quem realiza a coleta e o processamento reais dos eventos.  Um encadeamento pode ter apenas um QAbstractEventDispatcher e √© instalado apenas uma vez.  Entre outras coisas, come√ßando com Qt5, isso permite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">substituir</a> facilmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o expedidor por um mais adequado,</a> se necess√°rio, adicionando apenas 1 linha √† inicializa√ß√£o do fluxo e sem tocar nos locais potencialmente numerosos em que o QEventLoop √© usado. </div></div><br>  O que est√° inclu√≠do no conceito de ‚Äúevento‚Äù processado nesse ciclo?  Bem conhecido por todos os funcion√°rios da Qt, ‚Äúsinais‚Äù √© apenas um exemplo espec√≠fico, QEvent :: MetaCall.  Esse QEvent armazena um ponteiro para as informa√ß√µes necess√°rias para identificar a fun√ß√£o (slot) que precisa ser chamada e seus argumentos.  No entanto, al√©m dos sinais no Qt, existem cerca de cem (!) Outros eventos, dos quais uma d√∫zia √© reservada para eventos Qt especiais (ChildAdded, DeferredDelete, ParentChange) e o restante corresponde a v√°rias mensagens do sistema operacional. <br><br><div class="spoiler">  <b class="spoiler_title">Por que existem tantos deles e por que era imposs√≠vel ficar sem apenas sinais?</b> <div class="spoiler_text">  O leitor pode perguntar: por que existem tantos eventos e por que era imposs√≠vel sobreviver com apenas um mecanismo de sinal conveniente e universal?  O fato √© que sinais diferentes podem ser processados ‚Äã‚Äãde maneira muito diferente.  Por exemplo, alguns dos sinais s√£o compact√°veis ‚Äã‚Äã- se a fila j√° tiver uma mensagem bruta desse tipo (por exemplo, QEvent :: Paint), as mensagens subsequentes simplesmente a modificar√£o.  Outros sinais podem ser filtrados.  A presen√ßa de um pequeno n√∫mero de QEvents padr√£o e facilmente identific√°veis ‚Äã‚Äãsimplifica significativamente o processamento correspondente.  Al√©m disso, o processamento de QEvent devido a um dispositivo visivelmente mais simples geralmente √© realizado um pouco mais r√°pido do que o processamento de um sinal semelhante. </div></div><br>  Uma das armadilhas n√£o √≥bvias aqui √© que no Qt, um fluxo, em geral, pode nem ter um Dispatcher e, portanto, nem um √∫nico EventLoop.  Os objetos pertencentes a este fluxo n√£o responder√£o aos eventos enviados a eles.  Como QThread :: run (), por padr√£o, chama QThread :: exec () dentro do qual o EventLoop padr√£o √© implementado, aqueles que frequentemente tentam determinar sua pr√≥pria vers√£o de run () herdada do QThread enfrentam esse problema.  Um caso de uso semelhante para o QThread √©, em princ√≠pio, bastante v√°lido e at√© recomendado na documenta√ß√£o, mas contraria a id√©ia geral de organizar o c√≥digo no Qt descrito acima e geralmente n√£o funciona como os usu√°rios <i>esperam</i> .  Um erro t√≠pico nesse caso √© uma tentativa de parar um QThread personalizado chamando QThread :: exit () ou quit ().  Ambas as fun√ß√µes enviam uma mensagem para QEventLoop, mas se simplesmente n√£o houver QEventLoop no fluxo, naturalmente n√£o haver√° ningu√©m para process√°-las.  Como resultado, usu√°rios inexperientes que tentam "corrigir uma classe quebrada" come√ßam a tentar usar um QThread :: terminate "funcional", o que √© absolutamente imposs√≠vel.  Lembre-se - se voc√™ redefinir run () e n√£o usar o loop de eventos padr√£o, precisar√° fornecer um mecanismo para sair do encadeamento - por exemplo, usando a fun√ß√£o QThread :: requestInterruption () especialmente adicionada para isso.  √â mais correto, no entanto, simplesmente n√£o herdar o QThread se voc√™ realmente n√£o implementar algum tipo especial de encadeamento e usar o QtConcurrent especialmente criado para esses scripts ou colocar a l√≥gica em um Object Worker especial herdado do QObject, colocar o √∫ltimo no QThread padr√£o e gerenciar Trabalhador usando sinais. <br><br><a name="part3"></a><h3>  Afinidade, inicializa√ß√£o e suas limita√ß√µes de encadeamento </h3><br>  Ent√£o, como j√° descobrimos, cada objeto no Qt "pertence" a algum fluxo.  Ao mesmo tempo, surge uma pergunta l√≥gica: para qual, de fato, exatamente?  As seguintes conven√ß√µes s√£o aceitas no Qt: <br><br>  <b>1. Todos os "filhos" de qualquer "pai" sempre vivem no mesmo fluxo que o pai</b> <br><br>  Essa talvez seja a limita√ß√£o mais poderosa do modelo de fluxo Qt, e as tentativas de quebr√°-lo geralmente fornecem resultados muito estranhos para o usu√°rio.  Por exemplo, uma tentativa de tornar setParent em um objeto que vive em outro encadeamento no Qt simplesmente falha silenciosamente (um aviso √© gravado no console).  Aparentemente, esse compromisso foi alcan√ßado devido ao fato de que a remo√ß√£o segura de threads de "filhos" no caso da morte de um pai que vive em outro thread √© muito pouco trivial e propensa a dificuldades para capturar bugs.  Se voc√™ deseja implementar uma hierarquia de objetos interagindo vivendo em fluxos diferentes, precisar√° organizar a exclus√£o por conta pr√≥pria. <br><br>  <b>2. Um objeto cujo pai n√£o √© especificado durante a cria√ß√£o vive no fluxo que o criou</b> <br><br>  Tudo aqui ao mesmo tempo, de maneira simples e ao mesmo tempo nem sempre √© √≥bvio.  Por exemplo, em virtude dessa regra, QThread (como um objeto) vive em um thread diferente do que ele controla (e em virtude da regra 1, ele n√£o pode possuir nenhum dos objetos criados nesse thread).  Ou, digamos, se voc√™ redefinir o QThread :: run e criar qualquer descendente do QObject dentro dele, sem tomar medidas especiais (conforme discutido no cap√≠tulo anterior), os objetos criados n√£o responder√£o aos sinais. <br><br>  A afinidade do encadeamento pode ser alterada, se necess√°rio, chamando QObject :: moveToThread.  Em virtude da regra 1, somente os "pais" de n√≠vel superior (para os quais os pais == nulos) podem ser movidos, uma tentativa de mover qualquer "filho" ser√° silenciosamente ignorada.  Quando o "pai" do n√≠vel superior se move, todos os seus "filhos" tamb√©m se mudam para um novo fluxo.  Curiosamente, a chamada para moveToThread (nullptr) tamb√©m √© legal e √© uma maneira de criar um objeto com uma afinidade de thread "nula";  esses objetos n√£o podem receber nenhuma mensagem. <br><br>  Voc√™ pode obter o encadeamento "atual" de execu√ß√£o por meio de uma chamada para a fun√ß√£o QThread :: currentThread (), o encadeamento ao qual o objeto est√° associado - por meio de uma chamada para QObject :: thread () <br><br><div class="spoiler">  <b class="spoiler_title">Uma pergunta interessante sobre aten√ß√£o</b> <div class="spoiler_text">  Observe que a implementa√ß√£o da funcionalidade de propriedade de objetos e armazenamento de QEvents endere√ßados a eles, obviamente, requer o fluxo para armazenar os dados correspondentes em algum lugar.  No caso do Qt, a classe base QThread geralmente est√° envolvida na extra√ß√£o e gerenciamento de tais dados.  Mas o que acontece se voc√™ criar um QObject em algum std :: thread ou chamar a fun√ß√£o QThread :: currentThread () desse thread?  Acontece que, neste caso, o Qt implicitamente "nos bastidores" criar√° um objeto de inv√≥lucro especial que n√£o possui QAdoptedThread.  Ao mesmo tempo, cabe ao usu√°rio garantir de forma independente que todos os objetos desse fluxo sejam exclu√≠dos antes que o fluxo que os gerou seja parado. <br></div></div><br><a name="part4"></a><h3>  Thread principal, QCoreApplication e GUI </h3><br>  Entre todos os threads, o Qt definitivamente destacar√° um "thread principal", que no caso de aplicativos de interface do usu√°rio tamb√©m se torna um thread da GUI.  Nesse segmento, vive o objeto QApplication (QCoreApplication / QGuiApplication), que serve o loop principal de eventos orientado para trabalhar com mensagens do sistema operacional.  Em virtude da regra 2 da se√ß√£o anterior, na pr√°tica, o encadeamento "principal" ser√° aquele que realmente criou o objeto QApplication e, como em muitos sistemas operacionais o encadeamento principal tem um significado especial, a documenta√ß√£o recomenda fortemente a cria√ß√£o de QApplication com o primeiro objeto em Qt e fa√ßa-o imediatamente ap√≥s iniciar o aplicativo (== dentro do primeiro encadeamento do processo).  Para obter um ponteiro para o thread principal do aplicativo, respectivamente, voc√™ pode usar uma constru√ß√£o do formul√°rio QCoreApplication :: instance () -&gt; thread ().  Entretanto, puramente tecnicamente, o QApplication <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tamb√©m pode ser suspenso em um fluxo n√£o main ()</a> , por exemplo, se a interface Qt for criada dentro de algum tipo de plug-in e, em muitos casos, isso funcionar√° bem. <br><br>  Devido √† regra ‚Äúobjetos criados herdam o encadeamento atual‚Äù, voc√™ sempre pode trabalhar com calma, sem ir al√©m dos limites de um encadeamento.  Todos os objetos criados ir√£o automaticamente para o encadeamento "principal" para manuten√ß√£o, onde sempre haver√° um loop de eventos e (devido √† aus√™ncia de outros encadeamentos) nunca haver√° problemas com a sincroniza√ß√£o.  Mesmo se voc√™ estiver trabalhando com um sistema mais complexo que requer multithreading, a maioria dos objetos provavelmente cair√° no fluxo principal, com exce√ß√£o dos poucos que ser√£o explicitamente colocados em outro lugar.  Talvez seja precisamente essa circunst√¢ncia que d√° origem √† aparente ‚Äúm√°gica‚Äù na qual os objetos parecem funcionar de forma independente, sem nenhum esfor√ßo (porque a multitarefa cooperativa √© implementada dentro do fluxo) e, ao mesmo tempo, n√£o requer sincroniza√ß√£o, bloqueio ou similares (porque tudo acontece em um encadeamento ) <br><br>  Al√©m do fato de que o encadeamento "principal" √© o "primeiro" e cont√©m o loop principal de processamento de eventos QCoreApplication, outra caracter√≠stica de limita√ß√£o do Qt √© que todos os objetos conectados √† GUI devem "viver" nesse encadeamento.  Isso √© parcialmente uma conseq√º√™ncia do Legacy: devido ao fato de que em v√°rios sistemas operacionais qualquer opera√ß√£o com a GUI pode ocorrer apenas no encadeamento principal, o Qt subdivide todos os objetos em "widgets" e "n√£o-widgets".  O objeto do tipo widget pode viver apenas no encadeamento principal, uma tentativa de "superar" esse objeto em qualquer outro ser√° acionada automaticamente.  Em virtude disso, existe at√© um m√©todo QObject :: isWidgetType () especial que reflete diferen√ßas internas bastante profundas na mec√¢nica de trabalhar com esses objetos.  Mas √© interessante que no QtQuick, muito mais recente, onde eles tentaram fugir da muleta com o isWidgetType, o mesmo problema permaneceu. <br><br>  Qual √© o problema?  No Qt5, os objetos QML n√£o s√£o mais widgets e podem ser renderizados em um thread separado.  Mas isso levou a outro problema - dificuldades de sincroniza√ß√£o.  A renderiza√ß√£o de objetos da interface do usu√°rio √© uma ‚Äúleitura‚Äù de seu estado e deve ser consistente: se tentarmos alterar o estado de um objeto ao mesmo tempo que sua renderiza√ß√£o, o resultado da ‚Äúcorrida‚Äù resultante pode n√£o nos agradar.  Al√©m disso, o OpenGL em torno do qual os "novos" gr√°ficos Qt s√£o constru√≠dos √© extremamente "agu√ßado" ao fato de que a forma√ß√£o de comandos de desenho √© realizada por um thread que trabalha com algum estado global - o "contexto gr√°fico" que s√≥ pode mudar como uma s√©rie de opera√ß√µes seq√ºenciais.  Simplesmente n√£o podemos desenhar simultaneamente dois objetos gr√°ficos diferentes na tela - eles sempre ser√£o desenhados sequencialmente um ap√≥s o outro.  Como resultado, retornamos √† mesma solu√ß√£o - renderizando a interface do usu√°rio √© atribu√≠da a um thread.  Um leitor atento, no entanto, notar√° que esse thread n√£o precisa ser o thread principal - e no Qt5 a estrutura realmente tentar√° usar um thread de Renderiza√ß√£o separado para isso. <br><br><a name="part5"></a><h3>  Thread de renderiza√ß√£o </h3><br>  Na estrutura do novo modelo Qt5, toda a renderiza√ß√£o de objetos ocorre em um thread especialmente alocado para esse thread de renderiza√ß√£o.  Ao mesmo tempo, para que isso fa√ßa sentido e n√£o se limite a simplesmente alternar de um fluxo "principal" para outro, os objetos s√£o implicitamente divididos em um "front-end" que o programador v√™ e, geralmente, um "back-end" oculto dele que realmente executa a renderiza√ß√£o real.  O back-end vive no segmento de renderiza√ß√£o, enquanto o front-end, teoricamente, pode viver em qualquer outro segmento.  Sup√µe-se que o front-end execute o trabalho √∫til (se houver) na forma de processamento de eventos, enquanto a fun√ß√£o de back-end √© limitada apenas pela renderiza√ß√£o.  Em teoria, acontece vantajoso para as duas partes: a parte traseira periodicamente ‚Äúconsulta‚Äù o estado atual dos objetos e os desenha na tela, enquanto n√£o pode ser ‚Äúinterrompida‚Äù pelo fato de que alguns dos objetos estavam ‚Äúpensando‚Äù demais durante o processamento do evento devido ao fato de que isso O processamento lento ocorre em outro thread.  Por sua vez, o fluxo do objeto n√£o precisa aguardar "respostas" do driver gr√°fico, confirmando a conclus√£o da renderiza√ß√£o, e objetos diferentes podem funcionar em fluxos diferentes. <br><br>  Mas, como j√° mencionei no cap√≠tulo anterior, como temos um fluxo que cria dados (uma frente) e um fluxo que os l√™ (costas), precisamos de alguma forma sincroniz√°-los.  Essa sincroniza√ß√£o no Qt √© feita por bloqueios.  O fluxo em que a frente fica temporariamente suspenso, seguido por uma chamada de fun√ß√£o especial (QQuickItem :: updatePaintNode (), QQuickFramebufferObject :: Renderer :: synchronize ()) cuja √∫nica tarefa √© copiar o objeto relevante para visualizar o estado de frente para tr√°s "  Nesse caso, a chamada dessa fun√ß√£o ocorre <i>dentro do encadeamento de renderiza√ß√£o</i> , mas devido ao fato de que o encadeamento em que o objeto vive neste momento est√° parado, o usu√°rio pode trabalhar livremente com os dados do objeto como se isso acontecesse "como sempre", dentro do fluxo ao qual o objeto pertence. <br><br>  Est√° tudo bem, est√° tudo bem?  Infelizmente, n√£o, e momentos bastante √≥bvios come√ßam aqui.  Se usarmos um bloqueio individualmente para cada objeto, ser√° bastante lento, pois o encadeamento de renderiza√ß√£o ser√° for√ßado a esperar at√© que esses objetos concluam o processamento de seus eventos.  O fluxo "travar" onde o objeto vive √© "travar" e renderizar.  Al√©m disso, uma "dessincroniza√ß√£o" ser√° poss√≠vel quando, quando dois objetos forem alterados simultaneamente, um ser√° desenhado no quadro N e o outro ser√° desenhado apenas no quadro N + 1.  Seria prefer√≠vel usar o bloqueio apenas uma vez e para todos os objetos de uma s√≥ vez e somente quando tivermos certeza de que esse bloqueio ser√° bem-sucedido. <br><br>  O que foi implementado para resolver este problema no Qt?  Primeiramente, foi decidido que todos os objetos "gr√°ficos" de uma janela viver√£o em um fluxo.  Assim, para desenhar uma janela e bloquear todos os objetos nela contidos, torna-se suficiente interromper esse fluxo sozinho.  Em segundo lugar, o encadeamento com objetos de interface do usu√°rio inicia o bloqueio para atualizar o backend, enviando uma mensagem para o encadeamento de renderiza√ß√£o sobre a necessidade de sincroniza√ß√£o e parada (QSGThreadedRenderLoop :: polishAndSync, se algu√©m estiver interessado).  Isso garante que o encadeamento de renderiza√ß√£o nunca ‚Äúespere‚Äù por um fluxo de front-end.  Se de repente "travar", o segmento de renderiza√ß√£o continuar√° simplesmente desenhando o estado "antigo" dos objetos sem receber mensagens sobre a necessidade de atualiza√ß√£o.  Isso realmente d√° origem a bugs bastante divertidos do formul√°rio "se, por algum motivo, a renderiza√ß√£o n√£o puder abrir a janela imediatamente, o thread principal congela", mas, em geral, √© um compromisso razo√°vel.  Come√ßando com o QtQuick 2.0, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">v√°rios objetos "animados"</a> podem at√© ser "preenchidos" no thread de renderiza√ß√£o, para que a anima√ß√£o tamb√©m possa continuar funcionando se o thread principal for "pensado". <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bc0/250/3da/bc02503da9d76ff4b66ae038ce3cf81f.png"><br><br>  No entanto, a conseq√º√™ncia pr√°tica dessa solu√ß√£o √© que todos os objetos da interface do usu√°rio devem viver no mesmo encadeamento de qualquer maneira.  No caso de widgets antigos, no segmento "principal", no caso de novos objetos Qt Quick, no segmento de objeto QQuickWindow que os possui.  A √∫ltima regra √© superada de maneira elegante - para desenhar um QQuickItem, ele precisa tornar setParent no QQuickWindow correspondente, o que, como j√° discutido, garante que o objeto seja movido para o fluxo correspondente ou a chamada setParent falhe. <br><br>  E agora, infelizmente, uma mosca na pomada: embora o QQuickWindow diferente possa teoricamente viver em fluxos diferentes, na pr√°tica isso requer o envio preciso de mensagens do sistema operacional para eles e no Qt hoje ele n√£o est√° implementado.  No Qt 5.13, por exemplo, o QCoreApplication tenta se comunicar com o QQuickWindow via sendEvent, exigindo que o destinat√°rio e a parte remetente estejam no mesmo encadeamento (em vez de postEvent, que permite que os encadeamentos sejam diferentes).  Portanto, na pr√°tica, o QQuickWindow s√≥ funciona corretamente em um thread da GUI e, como resultado, todos os objetos QtQuick vivem no mesmo local.  Como resultado, apesar da presen√ßa do encadeamento de renderiza√ß√£o, quase todos os objetos relacionados √† GUI dispon√≠veis para o usu√°rio ainda vivem no mesmo encadeamento da GUI.  Talvez isso mude no quarto trimestre. <br><br>  Al√©m do acima, tamb√©m vale lembrar que, como o Qt funciona em muitas plataformas diferentes (incluindo aquelas que n√£o suportam multithreading), a estrutura fornece um n√∫mero decente de fallbacks e, em alguns casos, a funcionalidade do thread de renderiza√ß√£o √© realmente executada pelo mesmo thread da GUI .  Nesse caso, a interface do usu√°rio inteira, incluindo a renderiza√ß√£o, vive em um thread e o problema de sincroniza√ß√£o desaparece automaticamente.  A situa√ß√£o √© semelhante √† interface do usu√°rio mais antiga, baseada no widget no estilo Qt4.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se desejar, voc√™ pode fazer o Qt funcionar nesse modo "single-threaded", configurando a vari√°vel de ambiente QSG_RENDER_LOOP para a op√ß√£o apropriada. </font></font><br><br><a name="part6"></a><h3>  Conclus√£o </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Qt √© uma estrutura enorme e complexa, e trabalhar com threads reflete parte dessa complexidade. </font><font style="vertical-align: inherit;">Mas ele foi projetado com muito cuidado, l√≥gica e compet√™ncia; portanto, ao entender v√°rias id√©ias-chave com fluxos no Qt, √© bastante simples trabalhar sem erros. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deixe-me lembr√°-lo novamente dos pontos principais;</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cada objeto possui um encadeamento que o possui, executando manipuladores de todos os eventos que ocorrem com o objeto, incluindo sinais na fila </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se o encadeamento "propriet√°rio" do objeto n√£o executar o Qt Event Loop, os objetos pertencentes a ele n√£o receber√£o nenhuma mensagem e o encadeamento em si n√£o responder√° √†s tentativas de solicitar a sa√≠da () </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pais e descendentes sempre vivem no mesmo riacho. </font><font style="vertical-align: inherit;">Somente o pai de n√≠vel superior pode ser transferido de fluxo em fluxo. </font><font style="vertical-align: inherit;">A viola√ß√£o desta regra pode resultar em falha silenciosa da opera√ß√£o setParent ou moveToThread</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um objeto cujo pai n√£o est√° especificado se torna propriedade do encadeamento que esse objeto criou. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Todos os objetos da GUI, exceto o backend de renderiza√ß√£o, devem viver no fluxo da GUI </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O segmento da GUI √© aquele em que o objeto QApplication foi criado </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Espero que isso ajude voc√™ a usar o Qt com mais efici√™ncia e n√£o cometa erros associados ao seu modelo multiencadeado. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt467261/">https://habr.com/ru/post/pt467261/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt467251/index.html">Ref√©ns COBOL e Matem√°tica. Parte 1</a></li>
<li><a href="../pt467253/index.html">Ref√©ns COBOL e Matem√°tica. Parte 2</a></li>
<li><a href="../pt467255/index.html">Tr√™s erros comuns de seguran√ßa que todo desenvolvedor de reagentes deve conhecer</a></li>
<li><a href="../pt467257/index.html">N√£o guarde todos os seus ovos em uma cesta de uma s√≥ vez</a></li>
<li><a href="../pt467259/index.html">O DPI (inspe√ß√£o SSL) contradiz o significado da criptografia, mas as empresas o implementam</a></li>
<li><a href="../pt467263/index.html">Ganhamos em energia solar ou renda passiva a 25% ao ano, experi√™ncia pr√°tica. Parte 2</a></li>
<li><a href="../pt467269/index.html">Modelos em Seguran√ßa da Informa√ß√£o</a></li>
<li><a href="../pt467271/index.html">Programador profissional, qu√≠mico por profiss√£o</a></li>
<li><a href="../pt467275/index.html">Para o dia do programador. Programador em 2019</a></li>
<li><a href="../pt467277/index.html">pg_stat_statements + pg_stat_activity + loq_query = pg_ash?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>