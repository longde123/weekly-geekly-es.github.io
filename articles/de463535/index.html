<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚ÄçüöÄ üë¶üèº ü•ô √úberpr√ºfen des Quellcodes der .NET Core Libraries mit dem PVS-Studio Static Analyzer üë©üèº‚Äçüè´ ü¶ã üõ•Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=".NET Core-Bibliotheken sind eines der beliebtesten C # -Projekte auf GitHub. Es ist keine √úberraschung, da es weithin bekannt und verwendet ist. Aus d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√úberpr√ºfen des Quellcodes der .NET Core Libraries mit dem PVS-Studio Static Analyzer</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/463535/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/-a/bm/pb/-abmpb2yelga7y1zu59bejm6vgo.png" alt="Bild 19"></div><br>  .NET Core-Bibliotheken sind eines der beliebtesten C # -Projekte auf GitHub.  Es ist keine √úberraschung, da es weithin bekannt und verwendet ist.  Aus diesem Grund wird der Versuch, die dunklen Ecken des Quellcodes aufzudecken, immer faszinierender.  Dies versuchen wir also mit Hilfe des statischen Analysators PVS-Studio.  Was denkst du - werden wir irgendwann etwas Interessantes finden? <br><a name="habracut"></a><br>  Ich mache mich seit √ºber anderthalb Jahren auf den Weg zu diesem Artikel.  Irgendwann hatte ich die Idee, dass die .NET Core-Bibliotheken ein Leckerbissen sind und ihre √úberpr√ºfung vielversprechend ist.  Ich habe das Projekt mehrmals √ºberpr√ºft, der Analysator hat immer mehr interessante Codefragmente gefunden, aber es ging nicht weiter als nur durch die Liste der Warnungen zu scrollen.  Und hier ist es - es ist endlich passiert!  Das Projekt wird √ºberpr√ºft, der Artikel liegt direkt vor Ihnen. <br><br><h2>  Details zum Projekt und Check </h2><br>  Wenn Sie sich mit Code-Untersuchungen befassen m√∂chten, k√∂nnen Sie diesen Abschnitt weglassen.  Ich m√∂chte jedoch, dass Sie es lesen, da ich hier mehr √ºber das Projekt und den Analysator sowie √ºber die Durchf√ºhrung der Analyse und die Wiedergabe von Fehlern erz√§hle. <br><br><h3>  Projekt unter der Kontrolle </h3><br>  Vielleicht h√§tte ich √ºberspringen k√∂nnen, was CoreFX (.NET Core Libraries) ist, aber falls Sie noch nichts davon geh√∂rt haben, finden Sie die folgende Beschreibung.  Es ist dasselbe wie auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Projektseite auf GitHub</a> , wo Sie auch den Quellcode herunterladen k√∂nnen. <br><br>  Beschreibung: <i>Dieses Repo enth√§lt die Bibliotheksimplementierung ("CoreFX" genannt) f√ºr .NET Core.</i>  <i>Es enth√§lt System.Collections, System.IO, System.Xml und viele andere Komponenten.</i>  <i>Das entsprechende .NET Core Runtime-Repo ("CoreCLR" genannt) enth√§lt die Laufzeitimplementierung f√ºr .NET Core.</i>  <i>Es enth√§lt RyuJIT, .NET GC und viele andere Komponenten.</i>  <i>Laufzeitspezifischer Bibliothekscode (System.Private.CoreLib) befindet sich im CoreCLR-Repo.</i>  <i>Es muss zusammen mit der Laufzeit erstellt und versioniert werden.</i>  <i>Der Rest von CoreFX ist unabh√§ngig von der Laufzeitimplementierung und kann auf jeder kompatiblen .NET-Laufzeit (z</i> . <i>B. CoreRT) ausgef√ºhrt werden</i> . <br><br><h3>  Verwendeter Analysator und die Analysemethode </h3><br>  Ich habe den Code mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>statischen Analyseger√§t PVS-Studio</u></a> √ºberpr√ºft.  Im Allgemeinen kann PVS-Studio nicht nur den C # -Code, sondern auch C, C ++ und Java analysieren.  Die C # -Code-Analyse funktioniert bisher nur unter Windows, w√§hrend der C-, C ++ - und Java-Code unter Windows, Linux und MacOS analysiert werden kann. <br><br>  Normalerweise verwende ich zum √úberpr√ºfen von C # -Projekten das PVS-Studio-Plugin f√ºr Visual Studio (unterst√ºtzt die Versionen 2010-2019), da dies in diesem Fall wahrscheinlich das einfachste und bequemste Analyseszenario ist: L√∂sung √∂ffnen, Analyse ausf√ºhren, Warnliste bearbeiten.  Mit CoreFX wurde es jedoch etwas komplizierter. <br><br>  Der schwierige Teil ist, dass das Projekt keine einzige SLN-Datei enth√§lt. Daher ist es nicht m√∂glich, sie in Visual Studio zu √∂ffnen und eine vollst√§ndige Analyse mit dem PVS-Studio-Plugin durchzuf√ºhren.  Es ist wahrscheinlich eine gute Sache - ich wei√ü nicht wirklich, wie Visual Studio mit einer L√∂sung dieser Gr√∂√üe umgehen w√ºrde. <br><br>  Es gab jedoch keine Probleme mit der Analyse, da die PVS-Studio-Distribution die Analyzer-Befehlszeilenversion f√ºr MSBuild-Projekte (und .sln) enth√§lt.  Alles, was ich tun musste, war ein kleines Skript zu schreiben, das "PVS-Studio_Cmd.exe" f√ºr jede .sln im CoreFX-Verzeichnis ausf√ºhrte und die Ergebnisse in einem separaten Verzeichnis speicherte (es wird durch ein Befehlszeilenflag des Analysators angegeben). . <br><br>  Presto!  Infolgedessen habe ich eine Pandora-Box mit einer Reihe von Berichten, in denen einige interessante Dinge gespeichert sind.  Falls gew√ºnscht, k√∂nnen diese Protokolle mit dem Dienstprogramm PlogConverter kombiniert werden, das Teil der Distribution ist.  F√ºr mich war es bequemer, mit separaten Protokollen zu arbeiten, sodass ich sie nicht zusammenf√ºhrte. <br><br>  Bei der Beschreibung einiger Fehler verweise ich auf die Dokumentation aus den Paketen docs.microsoft.com und NuGet, die von nuget.org heruntergeladen werden k√∂nnen.  Ich gehe davon aus, dass der in der Dokumentation / den Paketen beschriebene Code geringf√ºgig vom analysierten Code abweichen kann.  Es w√§re jedoch sehr seltsam, wenn beispielsweise in der Dokumentation keine generierten Ausnahmen bei einem bestimmten Eingabedatensatz beschrieben w√ºrden, die neue Paketversion diese jedoch enthalten w√ºrde.  Sie m√ºssen zugeben, dass es eine zweifelhafte √úberraschung w√§re.  Das Reproduzieren von Fehlern in Paketen von NuGet unter Verwendung derselben Eingabedaten, die zum Debuggen von Bibliotheken verwendet wurden, zeigt, dass dieses Problem nicht neu ist.  Am wichtigsten ist, dass Sie es ber√ºhren k√∂nnen, ohne das Projekt aus Quellen zu erstellen. <br><br>  Unter Ber√ºcksichtigung der M√∂glichkeit einer theoretischen Desynchronisation des Codes halte ich es daher f√ºr akzeptabel, auf die Beschreibung der relevanten Methoden unter docs.microsoft.com zu verweisen und Probleme mithilfe von Paketen von nuget.org zu reproduzieren. <br><br>  Dar√ºber hinaus m√∂chte ich darauf hinweisen, dass die Beschreibung durch die angegebenen Links, die Informationen (Kommentare) in Paketen (in anderen Versionen) im Laufe des Schreibens des Artikels ge√§ndert worden sein k√∂nnte. <br><br><h3>  Andere gepr√ºfte Projekte </h3><br>  Dieser Artikel ist √ºbrigens nicht einzigartig.  Wir schreiben andere Artikel √ºber Projektpr√ºfungen.  √úber diesen Link finden Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Liste der gepr√ºften Projekte</a> .  Dar√ºber hinaus finden Sie auf unserer Website nicht nur Artikel zu Projektpr√ºfungen, sondern auch verschiedene technische Artikel zu C, C ++, C #, Java sowie einige interessante Hinweise.  All dies finden Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>Blog</u></a> . <br><br>  Mein Kollege hat bereits im Jahr 2015 .NET Core-Bibliotheken √ºberpr√ºft. Die Ergebnisse der vorherigen Analyse finden Sie im entsprechenden Artikel: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>Weihnachtsanalyse von .NET Core-Bibliotheken (CoreFX)</u></a> ". <br><br><h2>  Erkannte Fehler, verd√§chtige und interessante Fragmente </h2><br>  Wie immer schlage ich aus Gr√ºnden des gr√∂√üeren Interesses vor, dass Sie zuerst selbst nach Fehlern in den angegebenen Fragmenten suchen und erst dann die Analysatormeldung und die Beschreibung des Problems lesen. <br><br>  Der Einfachheit halber habe ich die Teile mithilfe von <b>Issue N-</b> Etiketten klar voneinander getrennt. Auf diese Weise ist es einfacher zu erkennen, wo die Beschreibung eines Fehlers endet, gefolgt von der n√§chsten.  Au√üerdem ist es einfacher, auf bestimmte Fragmente zu verweisen. <br><br>  <b>Problem 1</b> <br><br><pre><code class="cpp hljs">abstract <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Principal</span></span></span><span class="hljs-class"> :</span></span> IDisposable { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PrincipalContext context)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( context.ContextType == ContextType.Machine || _ctx.ContextType == ContextType.Machine) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException( SR.SaveToNotSupportedAgainstMachineStore); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (context == null) { Debug.Assert(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.unpersisted == <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(SR.NullArguments); } .... } .... }</code> </pre> <br>  <b>PVS-Studio-Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3095</u></a> Das ' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>Kontext'</u></a> -Objekt wurde verwendet, bevor es gegen Null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 340, 346. Principal.cs 340 <br><br>  Entwickler geben eindeutig an, dass der <i>Nullwert</i> f√ºr den <i>Kontextparameter</i> ung√ºltig ist. Sie m√∂chten dies mit Ausnahme des <i>InvalidOperationException-</i> Typs <i>hervorheben</i> .  Genau oben in der vorherigen Bedingung sehen wir jedoch eine bedingungslose Dereferenzierung des Referenzkontexts - <i>context.ContextType</i> .  Wenn der <i>Kontextwert</i> <i>null ist,</i> wird daher anstelle des erwarteten <i>InvalidOperationExcetion</i> die Ausnahme des Typs <i>NullReferenceException</i> generiert <i>.</i> <br><br>  Versuchen wir, das Problem zu reproduzieren.  Wir werden dem Projekt einen Verweis auf die Bibliothek <i>System.DirectoryServices.AccountManagement</i> hinzuf√ºgen und den folgenden Code ausf√ºhren: <br><br><pre> <code class="cpp hljs">GroupPrincipal groupPrincipal = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GroupPrincipal(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PrincipalContext(ContextType.Machine)); groupPrincipal.Save(null);</code> </pre> <br>  <i>GroupPrincipal</i> erbt von der abstrakten <i>Principal-</i> Klasse, die die <i>Save-</i> Methode implementiert, an der wir interessiert sind.  Also f√ºhren wir den Code aus und sehen, was zum Beweis erforderlich war. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/290/09a/2cc/29009a2cc3a5408808b9814d48bb0dea.png" alt="Bild 1"></div><br>  Aus Gr√ºnden des Interesses k√∂nnen Sie versuchen, das entsprechende Paket von NuGet herunterzuladen und das Problem auf die gleiche Weise zu wiederholen.  Ich habe das Paket 4.5.0 installiert und das erwartete Ergebnis erhalten. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3de/891/b4a/3de891b4a4ba8100bb63af19e4455842.png" alt="Bild 2"></div><br>  <b>Problem 2</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> SearchResultCollection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> findMoreThanOne)</span></span></span><span class="hljs-function"> </span></span>{ searchResult = null; DirectoryEntry clonedRoot = null; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_assertDefaultNamingContext == null) { clonedRoot = SearchRoot.CloneBrowsable(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { clonedRoot = SearchRoot.CloneBrowsable(); } .... }</code> </pre> <br>  <b>PVS-Studio-Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3004</u></a> Die Anweisung 'then' entspricht der Anweisung 'else'.  DirectorySearcher.cs 629 <br><br>  Unabh√§ngig davon, ob die Bedingung <i>_assertDefaultNamingContext == null</i> wahr oder falsch ist, werden dieselben Aktionen wie <i>damals ausgef√ºhrt,</i> und <i>ansonsten haben</i> Zweige der <i>if-</i> Anweisung dieselben K√∂rper.  Entweder sollte es eine andere Aktion in einem Zweig geben, oder Sie k√∂nnen die <i>if-</i> Anweisung weglassen, um Entwickler und den Analysator nicht zu verwirren. <br><br>  <b>Ausgabe 3</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DirectoryEntry</span></span></span><span class="hljs-class"> :</span></span> Component { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshCache</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] propertyNames)</span></span></span><span class="hljs-function"> </span></span>{ .... object[] names = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> object[propertyNames.Length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; propertyNames.Length; i++) names[i] = propertyNames[i]; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_propertyCollection != null &amp;&amp; propertyNames != null) .... .... } .... }</code> </pre> <br>  <b>PVS-Studio-Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3095</u></a> Das Objekt 'propertyNames' wurde verwendet, bevor es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 990, 1004. DirectoryEntry.cs 990 <br><br>  Wieder sehen wir eine seltsame Reihenfolge von Handlungen.  In der Methode gibt es eine Pr√ºfung <i>propertyNames! = Null</i> , d. H. Entwickler decken ihre Basen ab, <i>wenn Null</i> in die Methode eingeht.  Oben sehen Sie jedoch einige Zugriffsvorg√§nge anhand dieser m√∂glicherweise null Referenz - <i>propertyNames.Length</i> und <i>propertyNames [i]</i> .  Das Ergebnis ist ziemlich vorhersehbar - das Auftreten einer Ausnahme vom Typ <i>NullReferenceExcepption</i> , falls eine <i>Nullreferenz</i> an die Methode √ºbergeben wird. <br><br>  Was f√ºr ein Zufall!  <i>RefreshCache</i> ist eine √∂ffentliche Methode in der √∂ffentlichen Klasse.  Was ist mit dem Versuch, das Problem zu reproduzieren?  Dazu f√ºgen wir dem Projekt die erforderliche Bibliothek System. Directory <i>Services hinzu</i> und schreiben Code wie folgt: <br><br><pre> <code class="cpp hljs">DirectoryEntry de = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DirectoryEntry(); de.RefreshCache(null);</code> </pre> <br>  Nachdem wir den Code ausgef√ºhrt haben, k√∂nnen wir sehen, was wir erwartet haben. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d9/040/d0a/2d9040d0ae8d91394c476d6788aa7275.png" alt="Bild 3"></div><br>  Nur zum Spa√ü k√∂nnen Sie versuchen, das Problem in der Release-Version des NuGet-Pakets zu reproduzieren.  Als N√§chstes f√ºgen wir dem Projekt einen Verweis auf das <i>System.DirectoryServices-</i> Paket (ich habe die Version 4.5.0 verwendet) hinzu und f√ºhren den bereits bekannten Code aus.  Das Ergebnis ist unten. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d6/31e/309/0d631e3096fa8ba00b41fe10ad1001db.png" alt="Bild 4"></div><br>  <b>Ausgabe 4</b> <br><br>  Jetzt gehen wir vom Gegenteil aus - zuerst versuchen wir, den Code zu schreiben, der eine Klasseninstanz verwendet, und dann schauen wir hinein.  Verweisen wir auf die <i>System.Drawing.CharacterRange-</i> Struktur aus der <i>System.Drawing.Common-</i> Bibliothek und dem gleichnamigen NuGet-Paket. <br><br>  Wir werden diesen Code verwenden: <br><br><pre> <code class="cpp hljs">CharacterRange range = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CharacterRange(); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> eq = range.Equals(null); Console.WriteLine(eq);</code> </pre> <br>  Nur f√ºr den Fall, dass wir uns nur an unser Ged√§chtnis wenden, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>wenden</u></a> wir uns an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>docs.microsoft.com</u></a> , um uns <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>daran</u></a> zu erinnern, welcher zur√ºckgegebene Wert vom Ausdruck <i>obj.Equals (null)</i> erwartet wird: <br><br>  <i>Die folgenden Aussagen m√ºssen f√ºr alle Implementierungen der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u><i>Equals (Object)</i></u></a> -Methode zutreffen.</i>  <i>In der Liste stehen x, y und z f√ºr Objektreferenzen, die nicht null sind.</i> <br><br>  <i>....</i> <br><br>  <b><i>x.Equals (null) gibt false zur√ºck.</i></b> <br><br>  Denken Sie, dass der Text "False" in der Konsole angezeigt wird?  Nat√ºrlich nicht.  Es w√§re zu einfach.  :) Deshalb f√ºhren wir den Code aus und schauen uns das Ergebnis an. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e87/159/8f6/e871598f6ca5dacdb4a4fae7b5776520.png" alt="Bild 5"></div><br>  Es war die Ausgabe des obigen Codes unter Verwendung des NuGet <i>System.Drawing.Common-</i> Pakets der Version 4.5.1.  Der n√§chste Schritt besteht darin, denselben Code mit der Version der Debugging-Bibliothek auszuf√ºhren.  Das sehen wir: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e9/f27/f1a/6e9f27f1a78768078fdd940e0a4be0ad.png" alt="Bild 6"></div><br>  Schauen wir uns nun den Quellcode an, insbesondere die Implementierung der <i>Equals-</i> Methode in der <i>CharacterRange-</i> Struktur und die Analyse-Warnung: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj.GetType() != typeof(CharacterRange)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; CharacterRange cr = (CharacterRange)obj; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((_first == cr.First) &amp;&amp; (_length == cr.Length)); }</code> </pre> <br>  <b>PVS-Studio-Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3115 Die √úbergabe von</u></a> 'null' an die Methode 'Equals' sollte nicht zu 'NullReferenceException' f√ºhren.  CharacterRange.cs 56 <br><br>  Wir k√∂nnen beobachten, was bewiesen werden musste - der Parameter <i>obj</i> wird unsachgem√§√ü behandelt.  Aus diesem <i>Grund</i> tritt die <i>NullReferenceException-</i> Ausnahme im bedingten Ausdruck auf, wenn die Instanzmethode <i>GetType aufgerufen wird.</i> <br><br>  <b>Ausgabe 5</b> <br><br>  Betrachten wir w√§hrend der Erkundung dieser Bibliothek ein weiteres interessantes Fragment - die <i>Icon</i> <i>.</i> <i>Save-</i> Methode <i>.</i>  Schauen wir uns vor der Recherche die Methodenbeschreibung an. <br><br>  Es gibt keine Beschreibung der Methode: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffd/fef/402/ffdfef402f77c462c94b9ff284f42e0c.png" alt="Bild 7"></div><br>  Wenden wir uns an docs.microsoft.com - " <u>Icon.Save (Stream) -Methode</u> ".  Es gibt jedoch auch keine Einschr√§nkungen f√ºr Eingaben oder Informationen zu den generierten Ausnahmen. <br><br>  Fahren wir nun mit der Code√ºberpr√ºfung fort. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Icon</span></span></span><span class="hljs-class"> :</span></span> MarshalByRefObject, ICloneable, IDisposable, ISerializable { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Stream outputStream)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_iconData != null) { outputStream.Write(_iconData, <span class="hljs-number"><span class="hljs-number">0</span></span>, _iconData.Length); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (outputStream == null) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-string"><span class="hljs-string">"dataStream"</span></span>); .... } } .... }</code> </pre> <br>  <b>PVS-Studio-Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3095</u></a> Das Objekt 'outputStream' wurde verwendet, bevor es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 654, 672. Icon.Windows.cs 654 <br><br>  Wieder ist es die Geschichte, die wir bereits kennen - m√∂gliche Dereferenzierung einer Nullreferenz, da der Parameter der Methode dereferenziert wird, ohne nach <i>Null</i> zu <i>suchen</i> .  Wieder ein erfolgreiches Zusammentreffen der Umst√§nde - sowohl die Klasse als auch die Methode sind √∂ffentlich, sodass wir versuchen k√∂nnen, das Problem zu reproduzieren. <br><br>  Unsere Aufgabe ist einfach: Code-Ausf√ºhrung in den Ausdruck <i>outputStream.Write (_iconData, 0, _iconData.Length) zu bringen;</i>  und speichern Sie gleichzeitig den Wert der Variablen <i>outputStream</i> - <i>null</i> .  Die Bedingung <i>_iconData! = Null zu erf√ºllen,</i> reicht daf√ºr aus. <br><br>  Schauen wir uns den einfachsten √∂ffentlichen Konstruktor an: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Icon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fileName)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">this</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fileName, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br>  Es delegiert die Arbeit nur an einen anderen Konstruktor. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Icon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fileName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">this</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (FileStream f = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read)) { Debug.Assert(f != null, <span class="hljs-string"><span class="hljs-string">"File.OpenRead returned null instead of throwing an exception"</span></span>); _iconData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> byte[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)f.Length]; f.Read(_iconData, <span class="hljs-number"><span class="hljs-number">0</span></span>, _iconData.Length); } Initialize(width, height); }</code> </pre> <br>  Das ist es, das ist was wir brauchen.  Wenn wir nach dem Aufrufen dieses Konstruktors erfolgreich Daten aus der Datei lesen und die <i>Initialize-</i> Methode keine Abst√ºrze aufweist, enth√§lt das Feld <i>_iconData</i> einen Verweis auf ein Objekt. Dies ist das, was wir ben√∂tigen. <br><br>  Es stellt sich heraus, dass wir die Instanz der <i>Icon-</i> Klasse erstellen und eine tats√§chliche Icon-Datei angeben m√ºssen, um das Problem zu reproduzieren.  Danach m√ºssen wir die <i>Save-</i> Methode aufrufen, nachdem wir den <i>Nullwert</i> als Argument √ºbergeben haben.  Der Code k√∂nnte beispielsweise so aussehen: <br><br><pre> <code class="cpp hljs">Icon icon = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Icon(@<span class="hljs-string"><span class="hljs-string">"D:\document.ico"</span></span>); icon.Save(null);</code> </pre> <br>  Das Ergebnis der Ausf√ºhrung wird erwartet. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b37/fdb/dd1/b37fdbdd1288c054fdaaa0add0ffcfcf.png" alt="Bild 8"></div><br>  <b>Ausgabe 6</b> <br><br>  Wir setzen die √úberpr√ºfung fort und fahren fort.  Versuchen Sie, 3 Unterschiede zwischen den Aktionen zu finden, die im <i>Fall CimType.UInt32</i> und im anderen <i>Fall ausgef√ºhrt werden</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertToNumericValueAndAddToArray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> retFunctionName = <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.Empty; enumType = <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.Empty; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(cimType) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CimType.UInt8: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CimType.SInt8: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CimType.SInt16: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CimType.UInt16: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CimType.SInt32: arrayToAdd.Add(System.Convert.ToInt32( numericValue, (IFormatProvider)CultureInfo.InvariantCulture .GetFormat(typeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)))); retFunctionName = <span class="hljs-string"><span class="hljs-string">"ToInt32"</span></span>; enumType = <span class="hljs-string"><span class="hljs-string">"System.Int32"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CimType.UInt32: arrayToAdd.Add(System.Convert.ToInt32( numericValue, (IFormatProvider)CultureInfo.InvariantCulture .GetFormat(typeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)))); retFunctionName = <span class="hljs-string"><span class="hljs-string">"ToInt32"</span></span>; enumType = <span class="hljs-string"><span class="hljs-string">"System.Int32"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retFunctionName; }</code> </pre> <br>  Nat√ºrlich gibt es keine Unterschiede, da der Analysator uns davor warnt. <br><br>  <b>PVS-Studio-Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3139</u></a> Zwei oder mehr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>Fallzweige</u></a> f√ºhren dieselben Aktionen aus.  WMIGenerator.cs 5220 <br><br>  Pers√∂nlich ist dieser Codestil nicht sehr klar.  Wenn es keinen Fehler gibt, sollte meiner Meinung nach dieselbe Logik nicht auf verschiedene F√§lle angewendet werden. <br><br>  <b>Ausgabe 7</b> <br><br>  <i>Microsoft.CSharp-</i> Bibliothek. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IList&lt;KeyValuePair&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, object&gt;&gt; QueryDynamicObject(object obj) { .... List&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; names = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(mo.GetDynamicMemberNames()); names.Sort(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (names != null) { .... } .... }</code> </pre> <br>  <b>PVS-Studio-Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3022</u></a> Ausdruck 'names! = Null' ist immer wahr.  DynamicDebuggerProxy.cs 426 <br><br>  Ich k√∂nnte diese Warnung wahrscheinlich ignorieren, zusammen mit vielen √§hnlichen, die von den Diagnosen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3022</u></a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3063 ausgegeben wurden</u></a> .  Es gab viele (viele) seltsame Schecks, aber dieser kam irgendwie in meine Seele.  Vielleicht liegt der Grund darin, was passiert, bevor die lokale <i>Namensvariable</i> mit <i>null</i> verglichen wird <i>.</i>  Die Referenz wird nicht nur in der Variablen <i>names</i> f√ºr ein neu erstelltes Objekt gespeichert, sondern auch die Instanz- <i>Sortiermethode</i> wird aufgerufen.  Sicher, es ist kein Fehler, aber f√ºr mich lohnt es sich, darauf zu achten. <br><br>  <b>Ausgabe 8</b> <br><br>  Ein weiterer interessanter Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InsertChildNoGrow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Symbol child)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (sym?.nextSameName != null) { sym = sym.nextSameName; } Debug.Assert(sym != null &amp;&amp; sym.nextSameName == null); sym.nextSameName = child; .... }</code> </pre> <br>  <b>PVS-Studio-Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3042</u></a> M√∂gliche NullReferenceException.  Das '?.'  und '.'  Operatoren werden f√ºr den Zugriff auf Mitglieder des 'sym'-Objekts SymbolStore.cs 56 verwendet <br><br>  Schau was das Ding ist.  Die Schleife endet, wenn mindestens eine von zwei Bedingungen erf√ºllt ist: <br><br><ul><li>  <i>sym == null</i> ; </li><li>  <i>sym.nextSameName == null</i> . </li></ul><br>  Es gibt keine Probleme mit der zweiten Bedingung, die nicht √ºber die erste gesagt werden k√∂nnen.  Da auf das <i>Namensinstanzfeld</i> unten unbedingt zugegriffen wird und wenn <i>sym</i> - <i>null ist</i> , tritt eine Ausnahme vom Typ <i>NullReferenceException</i> auf. <br><br>  Bist du blind  Es gibt den <i>Debug.Assert-</i> Aufruf, bei dem √ºberpr√ºft wird, ob <i>sym! = Null ist</i> - jemand k√∂nnte argumentieren.  Im Gegenteil, das ist der Punkt!  Wenn Sie in der Release-Version arbeiten, <i>hilft Debug.Assert</i> nicht weiter. Unter den oben genannten Bedingungen erhalten wir <i>lediglich die NullReferenceException</i> .  Au√üerdem habe ich bereits einen √§hnlichen Fehler in einem anderen Projekt von Microsoft gesehen - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>Roslyn</u></a> , wo eine √§hnliche Situation mit <i>Debug.Assert aufgetreten ist</i> .  Lassen Sie mich f√ºr einen Moment f√ºr Roslyn beiseite drehen. <br><br>  Das Problem kann entweder bei Verwendung von <i>Microsoft.CodeAnalysis-</i> Bibliotheken oder direkt in Visual Studio bei Verwendung von Syntax Visualizer reproduziert werden.  In Visual Studio 16.1.6 + Syntax Visualizer 1.0 kann dieses Problem weiterhin reproduziert werden. <br><br>  Dieser Code reicht daf√ºr: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C1</span></span></span><span class="hljs-class">&lt;T1, T2&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ T1 val = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val is null) { } } }</code> </pre> <br>  Au√üerdem m√ºssen wir in Syntax Visualizer den Knoten des Syntaxbaums vom Typ <i>ConstantPatternSyntax finden</i> , der im Code <i>null</i> entspricht, und <i>TypeSymbol</i> daf√ºr <i>anfordern</i> . <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/855/b9c/baa/855b9cbaa67c9a5909117d513e154293.png" alt="Bild 9"></div><br>  Danach wird Visual Studio neu gestartet.  Wenn wir zur Ereignisanzeige gehen, finden wir einige Informationen zu Problemen in Bibliotheken: <br><br><pre> <code class="cpp hljs">Application: devenv.exe Framework Version: v4<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.30319</span></span> Description: The process was terminated due to an unhandled exception. Exception Info: System.Resources.MissingManifestResourceException at System.Resources.ManifestBasedResourceGroveler .HandleResourceStreamMissing(System.String) at System.Resources.ManifestBasedResourceGroveler.GrovelForResourceSet( System.Globalization.CultureInfo, System.Collections.Generic.Dictionary<span class="hljs-string"><span class="hljs-string">'2 &lt;System.String,System.Resources.ResourceSet&gt;, Boolean, Boolean, System.Threading.StackCrawlMark ByRef) at System.Resources.ResourceManager.InternalGetResourceSet( System.Globalization.CultureInfo, Boolean, Boolean, System.Threading.StackCrawlMark ByRef) at System.Resources.ResourceManager.InternalGetResourceSet( System.Globalization.CultureInfo, Boolean, Boolean) at System.Resources.ResourceManager.GetString(System.String, System.Globalization.CultureInfo) at Roslyn.SyntaxVisualizer.DgmlHelper.My. Resources.Resources.get_SyntaxNodeLabel() ....</span></span></code> </pre> <br>  Was das Problem mit devenv.exe betrifft: <br><br><pre> <code class="cpp hljs">Faulting application name: devenv.exe, version: <span class="hljs-number"><span class="hljs-number">16.1</span></span><span class="hljs-number"><span class="hljs-number">.29102</span></span><span class="hljs-number"><span class="hljs-number">.190</span></span>, time stamp: <span class="hljs-number"><span class="hljs-number">0x5d1c133b</span></span> Faulting <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> name: KERNELBASE.dll, version: <span class="hljs-number"><span class="hljs-number">10.0</span></span><span class="hljs-number"><span class="hljs-number">.18362</span></span><span class="hljs-number"><span class="hljs-number">.145</span></span>, time stamp: <span class="hljs-number"><span class="hljs-number">0xf5733ace</span></span> Exception code: <span class="hljs-number"><span class="hljs-number">0xe0434352</span></span> Fault offset: <span class="hljs-number"><span class="hljs-number">0x001133d2</span></span> ....</code> </pre> <br>  Mit Debugging-Versionen von Roslyn-Bibliotheken k√∂nnen Sie den Ort finden, an dem es eine Ausnahme gab: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Conversion </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClassifyImplicitBuiltInConversionSlow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TypeSymbol source, TypeSymbol destination, ref HashSet&lt;DiagnosticInfo&gt; useSiteDiagnostics)</span></span></span><span class="hljs-function"> </span></span>{ Debug.Assert((object)source != null); Debug.Assert((object)destination != null); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( source.SpecialType == SpecialType.System_Void || destination.SpecialType == SpecialType.System_Void) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Conversion.NoConversion; } .... }</code> </pre> <br>  Wie im oben beschriebenen Code aus .NET Core-Bibliotheken wird auch hier eine √úberpr√ºfung von <i>Debug.Assert durchgef√ºhrt,</i> die bei der Verwendung von Release-Versionen von Bibliotheken nicht hilfreich ist. <br><br>  <b>Ausgabe 9</b> <br><br>  Wir haben hier einen kleinen Offpoint, also kehren wir zu den .NET Core-Bibliotheken zur√ºck.  Das <i>System.IO.IsolatedStorage-</i> Paket enth√§lt den folgenden interessanten Code. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ContainsUnknownFiles</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> directory)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (files.Length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span> || ( (!IsIdFile(files[<span class="hljs-number"><span class="hljs-number">0</span></span>]) &amp;&amp; !IsInfoFile(files[<span class="hljs-number"><span class="hljs-number">0</span></span>]))) || (files.Length == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; !IsIdFile(files[<span class="hljs-number"><span class="hljs-number">1</span></span>]) &amp;&amp; !IsInfoFile(files[<span class="hljs-number"><span class="hljs-number">1</span></span>])) ); }</code> </pre> <br>  <b>PVS-Studio-Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3088</u></a> Der Ausdruck wurde zweimal in Klammern eingeschlossen: ((Ausdruck)).  Ein Klammerpaar ist nicht erforderlich oder es liegt ein Druckfehler vor.  IsolatedStorageFile.cs 839 <br><br>  Zu sagen, dass die Code-Formatierung verwirrend ist, ist eine andere Art, nichts zu sagen.  Wenn ich mir diesen Code kurz anschaue, w√ºrde ich sagen, dass der linke Operand des ersten ||  Der Operator, auf den ich <i>gesto√üen</i> bin, war <i>files.Length&gt; 2</i> , der richtige ist der in Klammern.  Zumindest ist der Code so formatiert.  Wenn Sie etwas genauer hinschauen, k√∂nnen Sie verstehen, dass dies nicht der Fall ist.  Tats√§chlich der richtige Operand - <i>((! IsIdFile (files [0]) &amp;&amp;! IsInfoFile (files [0])))</i> .  Ich finde diesen Code ziemlich verwirrend. <br><br>  <b>Ausgabe 10</b> <br><br>  In PVS-Studio 7.03 wurde die Diagnoseregel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3138</u></a> eingef√ºhrt, mit der nach Fehlern in interpolierten Zeichenfolgen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>gesucht wird</u></a> .  Genauer gesagt, in der Zeichenfolge, die h√∂chstwahrscheinlich interpoliert werden musste, aber aufgrund des fehlenden <i>$</i> -Symbols nicht <i>.</i>  In <i>System.Net-</i> Bibliotheken habe ich einige interessante Vorkommen dieser Diagnoseregel gefunden. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CacheCredential</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SafeFreeCredentials newHandle)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ExceptionCheck.IsFatal(e)) { NetEventSource.Fail(null, <span class="hljs-string"><span class="hljs-string">"Attempted to throw: {e}"</span></span>); } } }</code> </pre> <br>  <b>PVS-Studio-Warnung: Das</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3138-</u></a> String-Literal enth√§lt einen potenziellen interpolierten Ausdruck.  Betrachten Sie Folgendes: e.  SSPIHandleCache.cs 42 <br><br>  Es ist sehr wahrscheinlich, dass das zweite Argument der <i>Fail-</i> Methode eine interpolierte Zeichenfolge sein musste, in der die Zeichenfolgendarstellung der <i>e-</i> Ausnahme ersetzt werden w√ºrde.  Aufgrund eines fehlenden <i>$</i> -Symbols wurde jedoch keine Zeichenfolgendarstellung ersetzt. <br><br>  <b>Ausgabe 11</b> <br><br>  Hier ist ein weiterer √§hnlicher Fall. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> async Task&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; GetDigestTokenForCredential(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NetEventSource.IsEnabled) NetEventSource.Error(digestResponse, <span class="hljs-string"><span class="hljs-string">"Algorithm not supported: {algorithm}"</span></span>); .... }</code> </pre> <br>  <b>PVS-Studio-Warnung: Das</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3138-</u></a> String-Literal enth√§lt einen potenziellen interpolierten Ausdruck.  Betrachten Sie Folgendes: Algorithmus.  AuthenticationHelper.Digest.cs 58 <br><br>  Die Situation ist √§hnlich wie oben, wieder wird das <i>$</i> -Symbol √ºbersehen, was dazu f√ºhrt, dass die falsche Zeichenfolge in die <i>Fehlermethode</i> √ºbergeht <i>.</i> <br><br>  <b>Ausgabe 12</b> <br><br>  <i>System.Net.Mail-</i> Paket.  Die Methode ist klein, ich werde sie vollst√§ndig zitieren, um die Suche nach dem Fehler interessanter zu machen. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetContent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Stream stream)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stream == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(nameof(stream)); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_streamSet) { _stream.Close(); _stream = null; _streamSet = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } _stream = stream; _streamSet = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; _streamUsedOnce = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; TransferEncoding = TransferEncoding.Base64; }</code> </pre> <br>  <b>PVS-Studio-Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3008</u></a> Der Variablen '_streamSet' werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 123, 119. MimePart.cs 123 <br><br>  Die doppelte Wertzuweisung an die Variable <i>_streamSet</i> sieht seltsam aus (zuerst - unter der Bedingung, dann - au√üerhalb).  Gleiche Geschichte beim Zur√ºcksetzen der <i>Stream-</i> Variablen.  Infolgedessen hat <i>_stream</i> weiterhin den <i>Wertstrom</i> , und <i>_streamSet</i> ist <i>true.</i> <br><br>  <b>Ausgabe 13</b> <br><br>  Ein interessantes Codefragment aus der <i>System.Linq.Expressions-</i> Bibliothek, das zwei Analysatorwarnungen gleichzeitig ausl√∂st.  In diesem Fall handelt es sich eher um eine Funktion als um einen Fehler.  Die Methode ist jedoch ziemlich ungew√∂hnlich ... <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// throws NRE when o is null protected static void NullCheck(object o) { if (o == null) { o.GetType(); } }</span></span></code> </pre> <br>  <b>PVS-Studio-Warnungen:</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3010</u></a> Der R√ºckgabewert der Funktion 'GetType' muss verwendet werden.  Instruction.cs 36 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3080</u></a> M√∂gliche Null-Dereferenzierung.  Betrachten Sie die Inspektion von 'o'.  Instruction.cs 36 </li></ul><br>  Hier gibt es wahrscheinlich nichts zu kommentieren. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c9/a88/a22/5c9a88a221d4cd5ba5f4f1d9f74a346b.png" alt="Bild 20"></div><br>  <b>Ausgabe 14</b> <br><br>  Betrachten wir einen anderen Fall, den wir "von au√üen" behandeln werden.  Zuerst schreiben wir den Code, erkennen die Probleme und schauen dann hinein.  Wir werden die <i>System.Configuration.ConfigurationManager-</i> Bibliothek und das gleichnamige NuGet-Paket zur √úberpr√ºfung verwenden.  Ich habe das 4.5.0-Versionspaket verwendet.  Wir werden uns mit der <i>System.Configuration.CommaDelimitedStringCollection-</i> Klasse befassen. <br><br>  Lassen Sie uns etwas Unkompliziertes tun.  Zum Beispiel erstellen wir ein Objekt, extrahieren seine Zeichenfolgendarstellung, ermitteln die L√§nge dieser Zeichenfolge und drucken sie dann aus.  Der relevante Code: <br><br><pre> <code class="cpp hljs">CommaDelimitedStringCollection collection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CommaDelimitedStringCollection(); Console.WriteLine(collection.ToString().Length);</code> </pre> <br>  F√ºr alle F√§lle <i>lesen</i> wir die Beschreibung der <i>ToString-</i> Methode: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8dc/544/56d/8dc54456dd1296d89fbe447fac71ac17.png" alt="Bild 11"></div><br>  Es wird keine spezielle Zeichenfolgendarstellung eines Objekts zur√ºckgegeben.  F√ºr alle F√§lle werde ich docs.microsoft.com - " <u>CommaDelimitedStringCollection.ToString Method</u> " √ºberpr√ºfen.  Hier scheint es nichts Besonderes zu geben. <br><br>  Okay, lassen Sie uns den Code ausf√ºhren, aaund ... <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa5/89f/1af/fa589f1afc8ceb9415694e1261e59ab7.png" alt="Bild 12"></div><br>  Hmm, √úberraschung.  Lassen Sie uns versuchen, ein Element zur Sammlung hinzuzuf√ºgen und dann die Zeichenfolgendarstellung abzurufen.  Als n√§chstes werden wir "absolut versehentlich" eine leere Zeichenfolge hinzuf√ºgen :).  Der Code √§ndert sich und sieht folgenderma√üen aus: <br><br><pre> <code class="cpp hljs">CommaDelimitedStringCollection collection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CommaDelimitedStringCollection(); collection.Add(String.Empty); Console.WriteLine(collection.ToString().Length);</code> </pre> <br>  Ausf√ºhren und sehen ... <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d37/4bc/d2e/d374bcd2ed23bd048276493ed19d30fe.png" alt="Bild 13"></div><br>  Was nochmal ?!  Lassen Sie uns nun endlich die Implementierung der <i>ToString-</i> Methode aus der <i>CommaDelimitedStringCollection-</i> Klasse behandeln.  Der Code ist unten: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Count &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); foreach (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> str in <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { ThrowIfContainsDelimiter(str); <span class="hljs-comment"><span class="hljs-comment">// .... sb.Append(str.Trim()); sb.Append(','); } if (sb.Length &gt; 0) sb.Length = sb.Length - 1; return sb.Length == 0 ? null : sb.ToString(); }</span></span></code> </pre> <br>  <b>PVS-Studio-Warnungen:</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3108</u></a> Es wird nicht empfohlen, 'null' von der 'ToSting ()' - Methode zur√ºckzugeben.  StringAttributeCollection.cs 57 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3108</u></a> Es wird nicht empfohlen, 'null' von der 'ToSting ()' - Methode zur√ºckzugeben.  StringAttributeCollection.cs 71 </li></ul><br>  Hier sehen wir 2 Fragmente, bei denen die aktuelle <i>ToString-</i> Implementierung <i>null zur√ºckgeben kann.</i>  An dieser Stelle erinnern wir uns an die Empfehlung von Microsoft zur Implementierung der <i>ToString-</i> Methode.  Konsultieren wir also docs.microsoft.com - " <u>Object.ToString Method</u> ": <br><br>  <i>Hinweise f√ºr Vererbungen .... √úberschreibungen der ToString () -Methode sollten den folgenden Richtlinien folgen:</i> <br><br><ul><li>  <i>....</i> </li><li>  <i>Ihre ToString () - √úberschreibung sollte weder leer noch eine</i> <b><i>Nullzeichenfolge zur√ºckgeben</i></b> <i>.</i> </li><li>  <i>....</i> </li></ul><br>  Darum warnt PVS-Studio.  Zwei oben angegebene Codefragmente, die wir geschrieben haben, um das Problem zu reproduzieren, erhalten unterschiedliche Austrittspunkte - den ersten und den zweiten <i>Null-</i> R√ºckgabepunkt.  Lassen Sie uns etwas tiefer graben. <br><br>  Erster Fall.  <i>Count</i> ist eine Eigenschaft der Basisklasse <i>StringCollection</i> .  Da keine Elemente hinzugef√ºgt wurden, <i>Count == 0</i> , die Bedingung <i>Count &lt;= 0</i> ist wahr, wird der <i>Nullwert</i> zur√ºckgegeben. <br><br>  Im zweiten Fall haben wir das Element mithilfe der Instanz <i>CommaDelimitedStringCollection.Add-</i> Methode hinzugef√ºgt. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">new</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ ThrowIfReadOnly(); ThrowIfContainsDelimiter(value); _modified = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; base.Add(value.Trim()); }</code> </pre> <br>  √úberpr√ºfungen sind in der <i>ThrowIf ...</i> -Methode erfolgreich und das Element wird der <i>Basissammlung</i> hinzugef√ºgt.  Dementsprechend wird der <i>Count-</i> Wert 1. <i>Kehren</i> wir nun zur <i>ToString-</i> Methode zur√ºck.  Wert des Ausdrucks <i>Count &lt;= 0</i> - <i>false</i> , daher gibt die Methode nicht zur√ºck und die Codeausf√ºhrung wird fortgesetzt.  Die interne Auflistung wird durchlaufen. Der Instanz des Typs <i>StringBuilder werden</i> 2 Elemente hinzugef√ºgt - eine leere Zeichenfolge und ein Komma.  Als Ergebnis stellt sich heraus, dass <i>sb</i> nur ein Komma enth√§lt, der Wert der <i>Length-</i> Eigenschaft ist gleich 1. Der Wert des Ausdrucks <i>sb.Length&gt; 0</i> ist <i>wahr</i> , Subtraktion und Schreiben in <i>sb.Length</i> werden ausgef√ºhrt, jetzt der Wert von <i>sb.Length</i> ist 0. Dies f√ºhrt dazu, dass der <i>Nullwert</i> erneut von der Methode zur√ºckgegeben wird. <br><br>  <b>Ausgabe 15</b> <br><br>  Pl√∂tzlich bekam ich das Verlangen, die Klasse <i>System.Configuration.ConfigurationProperty zu verwenden</i> .  Nehmen wir einen Konstruktor mit der gr√∂√üten Anzahl von Parametern: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConfigurationProperty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, Type type, object defaultValue, TypeConverter typeConverter, ConfigurationValidatorBase validator, ConfigurationPropertyOptions options, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> description)</span></span></span></span>;</code> </pre> <br>  Sehen wir uns die Beschreibung des letzten Parameters an: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// description: // The description of the configuration entity.</span></span></code> </pre> <br>  Das gleiche steht in der Konstruktorbeschreibung unter docs.microsoft.com.  Schauen wir uns an, wie dieser Parameter im Konstruktork√∂rper verwendet wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConfigurationProperty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> description)</span></span></span><span class="hljs-function"> </span></span>{ ConstructorInit(name, type, options, validator, typeConverter); SetDefaultValue(defaultValue); }</code> </pre> <br>  Ob Sie es glauben oder nicht, der Parameter wird nicht verwendet. <br><br>  <b>PVS-Studio-Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3117 Der</u></a> Konstruktorparameter 'description' wird nicht verwendet.  ConfigurationProperty.cs 62 <br><br>  Wahrscheinlich verwenden Code-Autoren es absichtlich nicht, aber die Beschreibung des relevanten Parameters ist sehr verwirrend. <br><br>  <b>Ausgabe 16</b> <br><br>  Hier ist ein weiteres √§hnliches Fragment: Versuchen Sie, den Fehler selbst zu finden. Ich gebe den Code des Konstruktors unten an. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SectionXmlInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> configKey, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> definitionConfigPath, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> targetConfigPath, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> subPath, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lineNumber, object streamVersion, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rawXml, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> configSource, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> configSourceStreamName, object configSourceStreamVersion, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> protectionProviderName, OverrideModeSetting overrideMode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> skipInChildApps)</span></span></span><span class="hljs-function"> </span></span>{ ConfigKey = configKey; DefinitionConfigPath = definitionConfigPath; TargetConfigPath = targetConfigPath; SubPath = subPath; Filename = filename; LineNumber = lineNumber; StreamVersion = streamVersion; RawXml = rawXml; ConfigSource = configSource; ConfigSourceStreamName = configSourceStreamName; ProtectionProviderName = protectionProviderName; OverrideModeSetting = overrideMode; SkipInChildApps = skipInChildApps; }</code> </pre> <br>  <b>PVS-Studio-Warnung: Der</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3117-</u></a> Konstruktorparameter 'configSourceStreamVersion' wird nicht verwendet.  SectionXmlInfo.cs 16 <br><br>  Es gibt eine entsprechende Eigenschaft, aber ehrlich gesagt sieht es ein bisschen seltsam aus: <br><br><pre> <code class="cpp hljs">internal object ConfigSourceStreamVersion { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { } }</code> </pre> <br>  Im Allgemeinen sieht der Code verd√§chtig aus.  Vielleicht bleibt der Parameter / die Eigenschaft aus Kompatibilit√§tsgr√ºnden √ºbrig, aber das ist nur meine Vermutung. <br><br>  <b>Ausgabe 17</b> <br><br>  <i>Werfen</i> wir einen Blick auf interessante <i>Dinge</i> in der <i>System.Runtime.WindowsRuntime.UI.Xaml-</i> Bibliothek und den gleichnamigen <i>Paketcode</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RepeatBehavior</span></span></span><span class="hljs-class"> :</span></span> IFormattable { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> InternalToString(null, null); } .... }</code> </pre> <br>  <b>PVS-Studio-Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3108</u></a> Es wird nicht empfohlen, 'null' von der Methode 'ToSting ()' zur√ºckzugeben.  RepeatBehavior.cs 113 <br><br>  Bekannte Geschichte, die wir bereits kennen - die <i>ToString-</i> Methode kann den <i>Nullwert</i> zur√ºckgeben.  Aus diesem Grund kann der Autor des Aufrufercodes, der davon ausgeht, dass <i>RepeatBehavior.ToString</i> immer eine Nicht-Null-Referenz zur√ºckgibt, irgendwann unangenehm √ºberrascht sein.  Auch hier widerspricht es den Richtlinien von Microsoft. <br><br>  Nun, aber die Methode macht nicht klar, dass <i>ToString</i> <i>null</i> <i>zur√ºckgeben</i> kann - wir m√ºssen tiefer gehen und einen Blick in die <i>InternalToString-</i> Methode <i>werfen</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InternalToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> format, IFormatProvider formatProvider)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (_Type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RepeatBehaviorType.Forever: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Forever"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RepeatBehaviorType.Count: StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); sb.AppendFormat( formatProvider, <span class="hljs-string"><span class="hljs-string">"{0:"</span></span> + format + <span class="hljs-string"><span class="hljs-string">"}x"</span></span>, _Count); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sb.ToString(); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RepeatBehaviorType.Duration: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _Duration.ToString(); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } }</code> </pre> <br>  Der Analysator hat festgestellt, dass <i>InternalToString</i> den <i>Nullwert</i> zur√ºckgibt, wenn der <i>Standardzweig</i> in <i>switch ausgef√ºhrt</i> wird.  Daher gibt <i>ToString</i> auch <i>null zur√ºck</i> . <br><br>  <i>RepeatBehavior</i> ist eine √∂ffentliche Struktur und <i>ToString</i> ist eine √∂ffentliche Methode, sodass wir versuchen k√∂nnen, das Problem in der Praxis zu reproduzieren.  Dazu erstellen wir die <i>RepeatBehavior-</i> Instanz, rufen die <i>ToString-</i> Methode auf und lassen dabei nicht aus, dass <i>_Type</i> nicht gleich <i>RepeatBehaviorType.Forever</i> , <i>RepeatBehaviorType.Count</i> oder <i>RepeatBehaviorType.Duration sein darf</i> . <br><br>  <i>_Type</i> ist ein privates Feld, das √ºber eine √∂ffentliche Eigenschaft zugewiesen werden kann: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RepeatBehavior</span></span></span><span class="hljs-class"> :</span></span> IFormattable { .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> RepeatBehaviorType _Type; .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RepeatBehaviorType Type { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _Type; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { _Type = value; } } .... }</code> </pre> <br>  So weit, so gut.  Lassen Sie uns <i>fortfahren</i> und sehen, was der Typ <i>RepeatBehaviorType ist</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> RepeatBehaviorType { Count, Duration, Forever }</code> </pre> <br>  Wie wir sehen k√∂nnen, ist <i>RepeatBehaviorType</i> die Aufz√§hlung, die alle drei Elemente enth√§lt.  Zusammen mit diesem werden alle diese drei Elemente in dem <i>Schalterausdruck</i> behandelt, an dem wir interessiert sind.  Dies bedeutet jedoch nicht, dass der Standardzweig nicht erreichbar ist. <br><br>  Um das Problem zu reproduzieren, f√ºgen wir dem Projekt einen Verweis auf das Paket <i>System.Runtime.WindowsRuntime.UI.Xaml hinzu</i> (ich habe die Version 4.3.0 verwendet) und f√ºhren den folgenden Code aus. <br><br><pre> <code class="cpp hljs">RepeatBehavior behavior = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RepeatBehavior() { Type = (RepeatBehaviorType)<span class="hljs-number"><span class="hljs-number">666</span></span> }; Console.WriteLine(behavior.ToString() is null);</code> </pre> <br>  <i>True</i> wird wie erwartet in der Konsole angezeigt. <i>Dies</i> bedeutet, dass <i>ToString</i> <i>null zur√ºckgegeben hat</i> , da <i>_Type</i> keinem der Werte in <i>Fallzweigen</i> entspricht und der <i>Standardzweig</i> die Kontrolle erhalten hat.  Das haben wir versucht. <br><br>  Au√üerdem m√∂chte ich darauf hinweisen, dass weder Kommentare zur Methode noch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>docs.microsoft.com</u></a> angeben, dass die Methode den <i>Nullwert zur√ºckgeben</i> kann. <br><br>  <b>Ausgabe 18</b> <br><br>  Als N√§chstes werden wir einige Warnungen von <i>System.Private.DataContractSerialization pr√ºfen</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CharType</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte None = <span class="hljs-number"><span class="hljs-number">0x00</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte FirstName = <span class="hljs-number"><span class="hljs-number">0x01</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte Name = <span class="hljs-number"><span class="hljs-number">0x02</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte Whitespace = <span class="hljs-number"><span class="hljs-number">0x04</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte Text = <span class="hljs-number"><span class="hljs-number">0x08</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte AttributeText = <span class="hljs-number"><span class="hljs-number">0x10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte SpecialWhitespace = <span class="hljs-number"><span class="hljs-number">0x20</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte Comment = <span class="hljs-number"><span class="hljs-number">0x40</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> byte[] s_charType = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> byte[<span class="hljs-number"><span class="hljs-number">256</span></span>] { .... CharType.None, <span class="hljs-comment"><span class="hljs-comment">/* 9 (.) */</span></span> CharType.None| CharType.Comment| CharType.Comment| CharType.Whitespace| CharType.Text| CharType.SpecialWhitespace, <span class="hljs-comment"><span class="hljs-comment">/* A (.) */</span></span> CharType.None| CharType.Comment| CharType.Comment| CharType.Whitespace| CharType.Text| CharType.SpecialWhitespace, <span class="hljs-comment"><span class="hljs-comment">/* B (.) */</span></span> CharType.None, <span class="hljs-comment"><span class="hljs-comment">/* C (.) */</span></span> CharType.None, <span class="hljs-comment"><span class="hljs-comment">/* D (.) */</span></span> CharType.None| CharType.Comment| CharType.Comment| CharType.Whitespace, <span class="hljs-comment"><span class="hljs-comment">/* E (.) */</span></span> CharType.None, .... };</code> </pre> <br>  <b>PVS-Studio-Warnungen:</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3001</u></a> Links und rechts vom '|' befinden sich identische Unterausdr√ºcke 'CharType.Comment'.  Betreiber.  XmlUTF8TextReader.cs 56 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3001</u></a> Links und rechts vom '|' befinden sich identische Unterausdr√ºcke 'CharType.Comment'.  Betreiber.  XmlUTF8TextReader.cs 58 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3001</u></a> Links und rechts vom '|' befinden sich identische Unterausdr√ºcke 'CharType.Comment'.  Betreiber.  XmlUTF8TextReader.cs 64 </li></ul><br>  Der Analysator hat die Verwendung des Ausdrucks <i>CharType.Comment | CharType.Comment als</i> verd√§chtig eingestuft.  Sieht etwas seltsam aus, als <i>(CharType.Comment | CharType.Comment) == CharType.Comment</i> .  Bei der Initialisierung anderer Array-Elemente, die <i>CharType.Comment verwenden</i> , gibt es keine solche Duplizierung. <br><br>  <b>Ausgabe 19</b> <br><br>  Fahren wir fort.  <i>Schauen</i> wir uns die Informationen zum <i>R√ºckgabewert</i> der <i>XmlBinaryWriterSession.TryAdd-</i> Methode in der Methodenbeschreibung und unter docs.microsoft.com an - " <u>XmlBinaryWriterSession.TryAdd (XmlDictionaryString, Int32) -Methode</u> ": <u>R√ºckgabe</u> <i>: true, wenn die Zeichenfolge hinzugef√ºgt werden k√∂nnte;</i>  <i>sonst falsch.</i> <br><br>  Schauen wir uns nun den Hauptteil der Methode an: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryAdd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XmlDictionaryString value, out </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key)</span></span></span><span class="hljs-function"> </span></span>{ IntArray keys; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == null) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> System.Runtime .Serialization .DiagnosticUtility .ExceptionUtility .ThrowHelperArgumentNull(nameof(value)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_maps.TryGetValue(value.Dictionary, out keys)) { key = (keys[value.Key] - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key != <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// If the key is already set, then something is wrong throw System.Runtime .Serialization .DiagnosticUtility .ExceptionUtility .ThrowHelperError( new InvalidOperationException( SR.XmlKeyAlreadyExists)); } key = Add(value.Value); keys[value.Key] = (key + 1); return true; } key = Add(value.Value); keys = AddKeys(value.Dictionary, value.Key + 1); keys[value.Key] = (key + 1); return true; }</span></span></code> </pre> <br>  <b>PVS-Studio-Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3009</u></a> Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zur√ºckgibt.  XmlBinaryWriterSession.cs 29 <br><br>  Es scheint seltsam, dass die Methode entweder <i>true</i> zur√ºckgibt oder eine Ausnahme ausl√∂st, aber der <i>falsche</i> Wert wird niemals zur√ºckgegeben. <br><br>  <b>Ausgabe 20</b> <br><br>  Ich bin auf den Code mit einem √§hnlichen Problem gesto√üen, aber in diesem Fall im Gegenteil - die Methode gibt immer <i>false zur√ºck</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnHandleReference</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xmlWriter.depth &lt; depthToCheckCyclicReference) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (canContainCyclicReference) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_byValObjectsInScope.Contains(obj)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ....; _byValObjectsInScope.Push(obj); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  <b>PVS-Studio-Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3009</u></a> Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'false' zur√ºckgibt.  XmlObjectSerializerWriteContext.cs 415 <br><br>  Nun, wir haben schon einen langen Weg zur√ºckgelegt!  Bevor Sie weitermachen, schlage ich vor, dass Sie eine kleine Pause einlegen: Muskeln aufr√ºhren, herumlaufen, Ihren Augen Ruhe geben, aus dem Fenster schauen ... <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/008/d6a/92d/008d6a92d6f4cf4066e744e4c857b47d.png" alt="Bild 24"></div><br>  Ich hoffe an diesem Punkt bist du wieder voller Energie, also lass uns weitermachen.  :) :) <br><br>  <b>Ausgabe 21</b> <br><br>  Lassen Sie uns einige ansprechende Fragmente des <i>System.Security.Cryptography.Algorithms-</i> Projekts <i>√ºberpr√ºfen</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> override byte[] GenerateMask(byte[] rgbSeed, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cbReturn) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (HashAlgorithm hasher = (HashAlgorithm)CryptoConfig.CreateFromName(_hashNameValue)) { byte[] rgbCounter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> byte[<span class="hljs-number"><span class="hljs-number">4</span></span>]; byte[] rgbT = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> byte[cbReturn]; uint counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ib = <span class="hljs-number"><span class="hljs-number">0</span></span>; ib &lt; rgbT.Length;) { <span class="hljs-comment"><span class="hljs-comment">// Increment counter -- up to 2^32 * sizeof(Hash) Helpers.ConvertIntToByteArray(counter++, rgbCounter); hasher.TransformBlock(rgbSeed, 0, rgbSeed.Length, rgbSeed, 0); hasher.TransformFinalBlock(rgbCounter, 0, 4); byte[] hash = hasher.Hash; hasher.Initialize(); Buffer.BlockCopy(hash, 0, rgbT, ib, Math.Min(rgbT.Length - ib, hash.Length)); ib += hasher.Hash.Length; } return rgbT; } }</span></span></code> </pre> <br>  <b>PVS-Studio-Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3080</u></a> M√∂gliche Null-Dereferenzierung.  Betrachten Sie die Inspektion "Hasher".  PKCS1MaskGenerationMethod.cs 37 <br><br>  Der Analysator warnt, dass der Wert der <i>Hash-</i> Variablen bei der Auswertung des <i>Hashers</i> <i>null sein</i> <i>kann. Der TransformBlock-</i> Ausdruck f√ºhrt zu einer Ausnahme des <i>NullReferenceException-</i> Typs.  Das Auftreten dieser Warnung wurde aufgrund einer interprozeduralen Analyse m√∂glich. <br><br>  <i>Um</i> herauszufinden, ob der <i>Hasher</i> in diesem Fall den <i>Nullwert</i> <i>annehmen</i> kann, m√ºssen wir in die <i>CreateFromName-</i> Methode <i>eintauchen</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateFromName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CreateFromName(name, null); }</code> </pre> <br>  Bisher nichts - gehen wir tiefer.  Der Hauptteil der √ºberladenen <i>CreateFromName-</i> Version mit zwei Parametern ist ziemlich gro√ü, daher zitiere ich die Kurzversion. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateFromName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, params object[] args)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (retvalType == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cons == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (candidates.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rci == null || typeof(Delegate).IsAssignableFrom(rci.DeclaringType)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retval; }</code> </pre> <br> As you can see, there are several exit points in the method where the <i>null</i> value is explicitly returned. Therefore, at least theoretically, in the method above, that triggered a warning, an exception of the <i>NullReferenceException</i> type might occur. <br><br> Theory is great, but let's try to reproduce the problem in practice. To do this, we'll take another look at the original method and note the key points. Also, we'll reduce the irrelevant code from the method. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PKCS1MaskGenerationMethod</span></span></span><span class="hljs-class"> :</span></span> .... <span class="hljs-comment"><span class="hljs-comment">// &lt;= 1 { .... public PKCS1MaskGenerationMethod() // &lt;= 2 { _hashNameValue = DefaultHash; } .... public override byte[] GenerateMask(byte[] rgbSeed, int cbReturn) // &lt;= 3 { using (HashAlgorithm hasher = (HashAlgorithm)CryptoConfig.CreateFromName(_hashNameValue)) // &lt;= 4 { byte[] rgbCounter = new byte[4]; byte[] rgbT = new byte[cbReturn]; // &lt;= 5 uint counter = 0; for (int ib = 0; ib &lt; rgbT.Length;) // &lt;= 6 { .... Helpers.ConvertIntToByteArray(counter++, rgbCounter); // &lt;= 7 hasher.TransformBlock(rgbSeed, 0, rgbSeed.Length, rgbSeed, 0); .... } .... } } }</span></span></code> </pre> <br> Let's take a closer look at the key points: <br><br> <b>1, 3</b> . The class and method have <i>public</i> access modifiers. Hence, this interface is available when adding reference to a library ‚Äî we can try reproducing this issue. <br><br>  <b>2</b> . The class is non-abstract instance, has a public constructor. It must be easy to create an instance, which we'll work with. In some cases, that I considered, classes were abstract, so to reproduce the issue I had to search for inheritors and ways to obtain them. <br><br>  <b>4</b> . <i>CreateFromName</i> mustn't generate any exceptions and must return <i>null</i> ‚Äî the most important point, we'll get back to it later. <br><br> <b>5, 6</b> . The <i>cbReturn</i> value has to be &gt; 0 (but, of course, within adequate limits for the successful creation of an array). Compliance of the <i>cbReturn &gt; 0</i> condition is needed to meet the further condition <i>ib &lt; rgbT.Length</i> and enter the loop body. <br><br>  <b>7</b> . <i>Helpres.ConvertIntToByteArray</i> must work without exceptions. <br><br> To meet the conditions that depend on the method parameters, it is enough to simply pass appropriate arguments, for example: <br><br><ul><li> <i>rgbCeed</i> ‚Äî new byte[] { 0, 1, 2, 3 }; </li><li> <i>cbReturn</i> ‚Äî 42. </li></ul><br> In order to ¬´discredit¬ª the <i>CryptoConfig.CreateFromName</i> method, we need to be able to change the value of the <i>_hashNameValue</i> field. Fortunately, we have it, as the class defines a wrapper property for this field: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> HashName { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _hashNameValue; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { _hashNameValue = value ?? DefaultHash; } }</code> </pre> <br> By setting a 'synthetic' value for <i>HashName</i> (that is <i>_hashNameValue),</i> we can get the <i>null</i> value from the <i>CreateFromName</i> method at the first exit point from the ones we marked. I won't go into the details of analyzing this method (hope you'll forgive me for this), as the method is quite large. <br><br> As a result, the code which will lead to an exception of the <i>NullReferenceException</i> type, might look as follows: <br><br><pre> <code class="cpp hljs">PKCS1MaskGenerationMethod tempObj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PKCS1MaskGenerationMethod(); tempObj.HashName = <span class="hljs-string"><span class="hljs-string">"Dummy"</span></span>; tempObj.GenerateMask(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> byte[] { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> }, <span class="hljs-number"><span class="hljs-number">42</span></span>);</code> </pre> <br> Now we add reference to the debugging library, run the code and get the expected result: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ab/384/8e5/2ab3848e542172cd92a7e03f55bba9fe.png" alt="Bild 10"></div><br> Just for the fun of it, I tried to execute the same code using the NuGet package of the 4.3.1 version. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b4/a94/766/7b4a947666444496ca077e7530415c76.png" alt="Bild 14"></div><br> There's no information on generated exceptions, limitations of output parameters in the method description. Docs.microsoft.com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>PKCS1MaskGenerationMethod.GenerateMask(Byte[], Int32) Method</u></a> " doesn't specify it either. <br><br> By the way, right when writing the article and describing the order of actions to reproduce the problem, I found 2 more ways to ¬´break¬ª this method: <br><br><ul><li> pass a too large value as a <i>cbReturn</i> argument; </li><li> pass the <i>null</i> value as <i>rgbSeed.</i> </li></ul><br> In the first case, we'll get an exception of the <i>OutOfMemoryException</i> type. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c50/474/7f9/c504747f9a771843da10a128866811dd.png" alt="Bild 15"></div><br> In the second case, we'll get an exception of the <i>NullReferenceException</i> type when executing the <i>rgbSeed.Length</i> expression. In this case, it's important, that <i>hasher</i> has a non-null value. Otherwise, the control flow won't get to <i>rgbSeed.Length</i> . <br><br> <b>Issue 22</b> <br><br> I came across a couple of similar places. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignatureDescription</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> FormatterAlgorithm { get; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> DeformatterAlgorithm { get; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SignatureDescription</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> AsymmetricSignatureDeformatter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDeformatter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( AsymmetricAlgorithm key)</span></span></span><span class="hljs-function"> </span></span>{ AsymmetricSignatureDeformatter item = (AsymmetricSignatureDeformatter) CryptoConfig.CreateFromName(DeformatterAlgorithm); item.SetKey(key); <span class="hljs-comment"><span class="hljs-comment">// &lt;= return item; } public virtual AsymmetricSignatureFormatter CreateFormatter( AsymmetricAlgorithm key) { AsymmetricSignatureFormatter item = (AsymmetricSignatureFormatter) CryptoConfig.CreateFromName(FormatterAlgorithm); item.SetKey(key); // &lt;= return item; } .... }</span></span></code> </pre> <br> <b>PVS-Studio warnings:</b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3080</u></a> Possible null dereference. Consider inspecting 'item'. SignatureDescription.cs 31 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3080</u></a> Possible null dereference. Consider inspecting 'item'. SignatureDescription.cs 38 </li></ul><br> Again, in <i>FormatterAlgorithm</i> and <i>DeformatterAlgorithm</i> properties we can write such values, for which the <i>CryptoConfig.CreateFromName</i> method return the <i>null</i> value in the <i>CreateDeformatter</i> and <i>CreateFormatter</i> methods. Further, when calling the <i>SetKey</i> instance method, a <i>NullReferenceException</i> exception will be generated. The problem, again, is easily reproduced in practice: <br><br><pre> <code class="cpp hljs">SignatureDescription signature = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SignatureDescription() { DeformatterAlgorithm = <span class="hljs-string"><span class="hljs-string">"Dummy"</span></span>, FormatterAlgorithm = <span class="hljs-string"><span class="hljs-string">"Dummy"</span></span> }; signature.CreateDeformatter(null); <span class="hljs-comment"><span class="hljs-comment">// NRE signature.CreateFormatter(null); // NRE</span></span></code> </pre> <br> In this case, when calling <i>CreateDeformatter</i> as well as calling <i>CreateFormatter</i> , an exception of the <i>NullReferenceException</i> type is thrown. <br><br> <b>Issue 23</b> <br><br> Let's review interesting fragments from the <i>System.Private.Xml</i> project. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteBase64</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(byte[] buffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_inAttr &amp;&amp; (_inCDataSection || StartCDataSection())) _wrapped.WriteBase64(buffer, index, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> _wrapped.WriteBase64(buffer, index, count); }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3004</u></a> The 'then' statement is equivalent to the 'else' statement. QueryOutputWriterV1.cs 242 <br><br> It looks strange that <i>then</i> and <i>else</i> branches of the <i>if</i> statement contain the same code. Either there's an error here and another action has to be made in one of the branches, or the <i>if</i> statement can be omitted. <br><br> <b>Issue 24</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Depends</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XmlSchemaObject item, ArrayList refs)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (content is XmlSchemaSimpleTypeRestriction) { baseType = ((XmlSchemaSimpleTypeRestriction)content).BaseType; baseName = ((XmlSchemaSimpleTypeRestriction)content).BaseTypeName; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (content is XmlSchemaSimpleTypeList) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (content is XmlSchemaSimpleTypeRestriction) { baseName = ((XmlSchemaSimpleTypeRestriction)content).BaseTypeName; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t == typeof(XmlSchemaSimpleTypeUnion)) { .... } .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3003</u></a> The use of 'if (A) {...} else if (A) {...}' pattern was detected. There is a probability of logical error presence. Check lines: 381, 396. ImportContext.cs 381 <br><br> In the <i>if-else-if</i> sequence there are two equal conditional expressions ‚Äî <i>content is XmlSchemaSimpleTypeRestriction</i> . What is more, bodies of <i>then</i> branches of respective statements contain a different set of expressions. Anyway, either the body of the first relevant <i>then</i> branch will be executed (if the conditional expression is true), or none of them in case if the relevant expression is false. <br><br> <b>Issue 25</b> <br><br> To make it more intriguing to search for the error in the next method, I'll cite is entire body. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MatchesXmlType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IList&lt;XPathItem&gt; seq, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> indexType)</span></span></span><span class="hljs-function"> </span></span>{ XmlQueryType typBase = GetXmlType(indexType); XmlQueryCardinality card; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (seq.Count) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: card = XmlQueryCardinality.Zero; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: card = XmlQueryCardinality.One; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: card = XmlQueryCardinality.More; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(card &lt;= typBase.Cardinality)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; typBase = typBase.Prime; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; seq.Count; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateXmlType(seq[<span class="hljs-number"><span class="hljs-number">0</span></span>]).IsSubtypeOf(typBase)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br> If you've coped ‚Äî congratulations! <br> If not ‚Äî PVS-Studio to the rescue: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3102</u></a> Suspicious access to element of 'seq' object by a constant index inside a loop. XmlQueryRuntime.cs 738 <br><br> The <i>for</i> loop is executed, the expression <i>i &lt; seq.Count</i> is used as an exit condition. It suggests the idea that developers want to bypass the <i>seq</i> sequence. But in the loop, authors access sequence elements not by using the counter ‚Äî <i>seq[i]</i> , but a number literal ‚Äî zero ( <i>seq[0]</i> ). <br><br> <b>Issue 26</b> <br><br> The next error fits in a small piece of code, but it's no less interesting. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ WriteValue(value); }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3110</u></a> Possible infinite recursion inside 'WriteValue' method. XmlAttributeCache.cs 166 <br><br> The method calls itself, forming recursion without an exit condition. <br><br> <b>Issue 27</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IList&lt;XPathNavigator&gt; DocOrderDistinct(IList&lt;XPathNavigator&gt; seq) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (seq.Count &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> seq; XmlQueryNodeSequence nodeSeq = (XmlQueryNodeSequence)seq; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nodeSeq == null) nodeSeq = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XmlQueryNodeSequence(seq); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nodeSeq.DocOrderDistinct(_docOrderCmp); }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3095</u></a> The 'seq' object was used before it was verified against null. Check lines: 880, 884. XmlQueryRuntime.cs 880 <br><br> The method can get the <i>null</i> value as an argument. Due to this, when accessing the <i>Count</i> property, an exception of the <i>NullReferenceException</i> type will be generated. Below the variable <i>nodeSeq</i> is checked. <i>nodeSeq</i> is obtained as a result of explicit <i>seq</i> casting, still it's not clear why the check takes place. If the <i>seq</i> value is <i>null</i> , the control flow won't get to this check because of the exception. If the <i>seq</i> value isn't <i>null</i> , then: <br><br><ul><li> if casting fails, an exception of the <i>InvalidCastException</i> type will be generated; </li><li> if casting is successful, <i>nodeSeq</i> definitely isn't <i>null</i> . </li></ul><br> <b>Issue 28</b> <br><br> I came across 4 constructors, containing unused parameters. Perhaps, they are left for compatibility, but I found no additional comments on these unused parameters. <br><br> <b>PVS-Studio warnings:</b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3117</u></a> Constructor parameter 'securityUrl' is not used. XmlSecureResolver.cs 15 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3117</u></a> Constructor parameter 'strdata' is not used. XmlEntity.cs 18 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3117</u></a> Constructor parameter 'location' is not used. Compilation.cs 58 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3117</u></a> Constructor parameter 'access' is not used. XmlSerializationILGen.cs 38 </li></ul><br> The first one interested me the most (at least, it got into the list of warnings for the article). What's so special?  Ich bin mir nicht sicher. Perhaps, its name. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">XmlSecureResolver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XmlResolver resolver, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> securityUrl)</span></span></span><span class="hljs-function"> </span></span>{ _resolver = resolver; }</code> </pre> <br> Just for the sake of interest, I checked out what's written at docs.microsoft.com ‚Äî " <u>XmlSecureResolver Constructors</u> " about the <i>securityUrl</i> parameter: <br><br> <i>The URL used to create the PermissionSet that will be applied to the underlying XmlResolver. The XmlSecureResolver calls PermitOnly() on the created PermissionSet before calling GetEntity(Uri, String, Type) on the underlying XmlResolver.</i> <br><br> <b>Issue 29</b> <br><br> In the <i>System.Private.Uri</i> package I found the method, which wasn't following exactly Microsoft guidelines on the <i>ToString</i> method overriding. Here we need to recall one of the tips from the page " <u>Object.ToString Method</u> ": <b><i>Your ToString() override should not throw an exception</i></b> <i>.</i> <br><br> The overridden method itself looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_username.Length == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; _password.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UriFormatException(SR.net_uri_BadUserPassword); } .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3108</u></a> It is not recommended to throw exceptions from 'ToSting()' method. UriBuilder.cs 406 <br><br> The code first sets an empty string for the <i>_username</i> field and a nonempty one for the <i>_password</i> field respectively through the public properties <i>UserName</i> and <i>Password.</i> After that it calls the <i>ToString</i> method. Eventually this code will get an exception. An example of such code: <br><br><pre> <code class="cpp hljs">UriBuilder uriBuilder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UriBuilder() { UserName = String.Empty, Password = <span class="hljs-string"><span class="hljs-string">"Dummy"</span></span> }; String stringRepresentation = uriBuilder.ToString(); Console.WriteLine(stringRepresentation);</code> </pre> <br> But in this case developers honestly warn that calling might result in an exception. It is described in comments to the method and at docs.microsoft.com ‚Äî " <u>UriBuilder.ToString Method</u> ". <br><br> <b>Issue 30</b> <br><br> Look at the warnings, issued on the <i>System.Data.Common</i> project code. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ArrayList _tables; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> DataTable </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tableName, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ns)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_tables.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (DataTable)_tables[<span class="hljs-number"><span class="hljs-number">0</span></span>]; .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3106</u></a> Possibly index is out of bound. The '0' index is pointing beyond '_tables' bound. XMLDiffLoader.cs 277 <br><br> Does this piece of code look unusual? What do you think it is? An unusual way to generate an exception of the <i>ArgumentOutOfRangeException</i> type? I wouldn't be surprised by this approach. Overall, it's very strange and suspicious code. <br><br> <b>Issue 31</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal XmlNodeOrder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ComparePosition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XPathNodePointer other)</span></span></span><span class="hljs-function"> </span></span>{ RealFoliate(); other.RealFoliate(); Debug.Assert(other != null); .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3095</u></a> The 'other' object was used before it was verified against null. Check lines: 1095, 1096. XPathNodePointer.cs 1095 <br><br> The expression <i>other != null</i> as an argument of the <i>Debug.Assert</i> method suggests, that the <i>ComparePosition</i> method can obtain the <i>null</i> value as an argument. At least, the intention was to catch such cases. But at the same time, the line above the <i>other.RealFoliate</i> instance method is called. As a result, if <i>other</i> has the <i>null</i> value, an exception of the <i>NullReferenceException</i> type will be generated before checking through <i>Assert</i> . <br><br> <b>Issue 32</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> PropertyDescriptorCollection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetProperties</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Attribute[] attributes)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (Attribute attribute in attributes) { Attribute attr = property.Attributes[attribute.GetType()]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (attr == null &amp;&amp; !attribute.IsDefaultAttribute()) || !attr.Match(attribute)) { match = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3080</u></a> Possible null dereference. Consider inspecting 'attr'. DbConnectionStringBuilder.cs 534 <br><br> Conditional expression of the <i>if</i> statement looks quite suspicious. <i>Match</i> is an instance method. According to the check <i>attr == null</i> , <i>null</i> is the acceptable (expected) value for this variable. Therefore, if control flow gets to the right operand of the || operator (if <i>attr</i> ‚Äî <i>null</i> ), we'll get an exception of the <i>NullReferenceException</i> type. <br><br> Accordingly, conditions of the exception occurrence are the following: <br><br><ol><li> The value of <i>attr</i> ‚Äî <i>null</i> . The right operand of the &amp;&amp; operator is evaluated. </li><li> The value of <i>!attribute.IsDefaultAttribute()</i> ‚Äî <i>false</i> . The overall result of the expression with the &amp;&amp; operator ‚Äî <i>false</i> . </li><li> Since the left operand of the || operator is of the <i>false</i> value, the right operand is evaluated. </li><li> Since <i>attr</i> ‚Äî <i>null</i> , when calling the <i>Match</i> method, an exception is generated. </li></ol><br> <b>Issue 33</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadOldRowData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DataSet ds, ref DataTable table, ref </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pos, XmlReader row)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (table == null) { row.Skip(); <span class="hljs-comment"><span class="hljs-comment">// need to skip this element if we dont know about it, // before returning -1 return -1; } .... if (table == null) throw ExceptionBuilder.DiffgramMissingTable( XmlConvert.DecodeName(row.LocalName)); .... }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3021</u></a> There are two 'if' statements with identical conditional expressions. The first 'if' statement contains method return. This means that the second 'if' statement is senseless XMLDiffLoader.cs 301 <br><br> There are two <i>if</i> statements, containing the equal expression ‚Äî <i>table == null</i> . With that, <i>then</i> branches of these statements contain different actions ‚Äî in the first case, the method exits with the value -1, in the second one ‚Äî an exception is generated. The <i>table</i> variable isn't changed between the checks. Thus, the considered exception won't be generated. <br><br> <b>Issue 34</b> <br><br> Look at the interesting method from the <i>System.ComponentModel.TypeConverter</i> project. Well, let's first read the comment, describing it: <br><br> <i>Removes the last character from the formatted string. (Remove last character in virtual string). On exit the out param contains the position where the operation was actually performed. This position is relative to the test string. The MaskedTextResultHint out param gives more information about the operation result. Returns</i> <b><i>true</i></b> <i>on success,</i> <b><i>false</i></b> <i>otherwise.</i> <br><br> The key point on the return value: if an operation is successful, the method returns <i>true</i> , otherwise ‚Äî <i>false</i> . Let's see what happens in fact. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(out </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> testPosition, out MaskedTextResultHint resultHint)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lastAssignedPos == INVALID_INDEX) { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// nothing to remove. } .... return true; }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3009</u></a> It's odd that this method always returns one and the same value of 'true'. MaskedTextProvider.cs 1529 <br><br> In fact, it turns out that the only return value of the method is <i>true</i> . <br><br> <b>Issue 35</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_table != null) { .... } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_table.fInitInProgress &amp;&amp; _delayLoadingConstraints != null) { .... } .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3125</u></a> The '_table' object was used after it was verified against null. Check lines: 437, 423. ConstraintCollection.cs 437 <br><br> The <i>_table != null</i> check speaks for itself ‚Äî the <i>_table</i> variable can have the <i>null</i> value. At least, in this case code authors get reinsured. However, below they address the instance field via <i>_table</i> but without the check for <i>null</i> ‚Äî <i>_table .fInitInProgress</i> . <br><br> <b>Issue 36</b> <br><br> Now let's consider several warnings, issued for the code of the <i>System.Runtime.Serialization.Formatters</i> project. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (memberNameInfo != null) { .... _serWriter.WriteObjectEnd(memberNameInfo, typeNameInfo); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((objectInfo._objectId == _topId) &amp;&amp; (_topName != null)) { _serWriter.WriteObjectEnd(topNameInfo, typeNameInfo); .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ReferenceEquals(objectInfo._objectType, Converter.s_typeofString)) { _serWriter.WriteObjectEnd(typeNameInfo, typeNameInfo); } }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3038</u></a> The argument was passed to method several times. It is possible that other argument should be passed instead. BinaryObjectWriter.cs 262 <br><br> The analyzer was confused by the last call <i>_serWriter.WriteObjectEnd</i> with two equal arguments ‚Äî <i>typeNameInfo</i> . It looks like a typo, but I can't say for sure. I decided to check out what is the callee <i>WriteObjectEnd</i> method. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteObjectEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NameInfo memberNameInfo, NameInfo typeNameInfo)</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br> Well‚Ä¶ Let's move on.  :) :) <br><br> <b>Issue 37</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteSerializationHeader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> topId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> headerId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> minorVersion, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> majorVersion)</span></span></span><span class="hljs-function"> </span></span>{ var record = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializationHeaderRecord( BinaryHeaderEnum.SerializedStreamHeader, topId, headerId, minorVersion, majorVersion); record.Write(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br> When reviewing this code, I wouldn't say at once what's wrong here or what looks suspicious. But the analyzer may well say what's the thing. <br><br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3066</u></a> Possible incorrect order of arguments passed to 'SerializationHeaderRecord' constructor: 'minorVersion' and 'majorVersion'. BinaryFormatterWriter.cs 111 <br><br> See the callee constructor of the <i>SerializationHeaderRecord</i> class. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SerializationHeaderRecord</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( BinaryHeaderEnum binaryHeaderEnum, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> topId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> headerId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> majorVersion, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> minorVersion)</span></span></span><span class="hljs-function"> </span></span>{ _binaryHeaderEnum = binaryHeaderEnum; _topId = topId; _headerId = headerId; _majorVersion = majorVersion; _minorVersion = minorVersion; }</code> </pre> <br> As we can see, constructor's parameters follow in the order <i>majorVersion</i> , <i>minorVersion</i> ; whereas when calling the constructor they are passed in this order: <i>minorVersion</i> , <i>majorVersion</i> . Seems like a typo. In case it was made deliberately (what if?) ‚Äî I think it would require an additional comment. <br><br> <b>Issue 38</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ObjectManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ISurrogateSelector selector, StreamingContext context, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> checkSecurity, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isCrossAppDomain)</span></span></span><span class="hljs-function"> </span></span>{ _objects = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectHolder[DefaultInitialSize]; _selector = selector; _context = context; _isCrossAppDomain = isCrossAppDomain; }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3117</u></a> Constructor parameter 'checkSecurity' is not used. ObjectManager.cs 33 <br><br> The <i>checkSecurity</i> parameter of the constructor isn't used in any way. There are no comments on it. I guess it's left for compatibility, but anyway, in the context of recent security conversations, it looks interesting. <br><br> <b>Issue 39</b> <br><br> Here's the code that seemed unusual to me. The pattern looks one and the same in all three detected cases and is located in methods with equal names and variables names. Consequently: <br><br><ul><li> either I'm not enlightened enough to get the purpose of such duplication; </li><li> or the error was spread by the copy-paste method. </li></ul><br> The code itself: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnlargeArray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newLength = _values.Length * <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newLength &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newLength == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializationException(SR.Serialization_TooManyElements); } newLength = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } FixupHolder[] temp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FixupHolder[newLength]; Array.Copy(_values, <span class="hljs-number"><span class="hljs-number">0</span></span>, temp, <span class="hljs-number"><span class="hljs-number">0</span></span>, _count); _values = temp; }</code> </pre> <br> <b>PVS-Studio warnings:</b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3022</u></a> Expression 'newLength == int.MaxValue' is always false. ObjectManager.cs 1423 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3022</u></a> Expression 'newLength == int.MaxValue' is always false. ObjectManager.cs 1511 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3022</u></a> Expression 'newLength == int.MaxValue' is always false. ObjectManager.cs 1558 </li></ul><br> What is different in other methods is the type of the <i>temp</i> array elements (not <i>FixupHolder</i> , but <i>long</i> or <i>object</i> ). So I still have suspicions of copy-paste‚Ä¶ <br><br> <b>Issue 40</b> <br><br> Code from the <i>System.Data.Odbc</i> project. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnquoteIdentifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(quotePrefix) || quotePrefix != <span class="hljs-string"><span class="hljs-string">" "</span></span>) { .... } .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3022</u></a> Expression '!string.IsNullOrEmpty(quotePrefix) || quotePrefix != " "' is always true. OdbcCommandBuilder.cs 338 <br><br> The analyzer assumes that the given expression always has the <i>true</i> value. It is really so. It even doesn't matter what value is actually in <i>quotePrefix</i> ‚Äî the condition itself is written incorrectly. Let's get to the bottom of this. <br><br> We have the || operator, so the expression value will be <i>true</i> , if the left or right (or both) operand will have the <i>true</i> value. It's all clear with the left one. The right one will be evaluated only in case if the left one has the <i>false</i> value. This means, if the expression is composed in the way that the value of the right operand is always <i>true</i> when the value of the left one is <i>false</i> , the result of the entire expression will permanently be <i>true</i> . <br><br> From the code above we know that if the right operand is evaluated, the value of the expression <i>string.IsNullOrEmpty(quotePrefix)</i> ‚Äî <i>true</i> , so one of these statements is true: <br><br><ul><li> <i>quotePrefix == null</i> ; </li><li> <i>quotePrefix.Length == 0</i> . </li></ul><br> If one of these statements is true, the expression <i>quotePrefix != " "</i> will also be true, which we wanted to prove. Meaning that the value of the entire expression is always <i>true</i> , regardless of the <i>quotePrefix</i> contents. <br><br> <b>Issue 41</b> <br><br> Going back to constructors with unused parameters: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PendingGetConnection</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PendingGetConnection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dueTime, DbConnection owner, TaskCompletionSource&lt;DbConnectionInternal&gt; completion, DbConnectionOptions userOptions)</span></span></span><span class="hljs-function"> </span></span>{ DueTime = dueTime; Owner = owner; Completion = completion; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> DueTime { get; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DbConnection Owner { get; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TaskCompletionSource&lt;DbConnectionInternal&gt; Completion { get; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DbConnectionOptions UserOptions { get; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3117</u></a> Constructor parameter 'userOptions' is not used. DbConnectionPool.cs 26 <br><br> We can see from the analyzer warnings and the code, that only one constructor's parameter isn't used <i>‚Äî userOptions</i> , and others are used for initializing same-name properties. It looks like a developer forgot to initialize one of the properties. <br><br> <b>Issue 42</b> <br><br> There's suspicious code, that we've come across 2 times. The pattern is the same. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> DataTable </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (DataRow row in schemaTable.Rows) { resultTable.Columns .Add(row[<span class="hljs-string"><span class="hljs-string">"ColumnName"</span></span>] as <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, (Type)row[<span class="hljs-string"><span class="hljs-string">"DataType"</span></span>] as Type); } .... }</code> </pre> <br> <b>PVS-Studio warnings:</b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3051</u></a> An excessive type cast. The object is already of the 'Type' type. DbMetaDataFactory.cs 176 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3051</u></a> An excessive type cast. The object is already of the 'Type' type. OdbcMetaDataFactory.cs 1109 </li></ul><br> The expression <i>(Type)row[¬´DataType¬ª] as Type</i> looks suspicious. First, explicit casting will be performed, after that ‚Äî casting via the <i>as</i> operator. If the value <i>row[¬´DataType¬ª]</i> ‚Äî <i>null,</i> it will successfully 'pass' through both castings and will do as an argument to the <i>Add</i> method. If <i>row[¬´DataType¬ª]</i> returns the value, which cannot be casted to the <i>Type</i> type, an exception of the <i>InvalidCastException</i> type will be generated right during the explicit cast. In the end, why do we need two castings here? The question is open. <br><br> <b>Issue 43</b> <br><br> Let's look at the suspicious fragment from <i>System.Runtime.InteropServices.RuntimeInformation</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> FrameworkDescription { get { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s_frameworkDescription == null) { <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> versionString = (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>)AppContext.GetData(<span class="hljs-string"><span class="hljs-string">"FX_PRODUCT_VERSION"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (versionString == null) { .... versionString = typeof(object).Assembly .GetCustomAttribute&lt; AssemblyInformationalVersionAttribute&gt;() ?.InformationalVersion; .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> plusIndex = versionString.IndexOf(<span class="hljs-string"><span class="hljs-string">'+'</span></span>); .... } .... } .... } }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3105</u></a> The 'versionString' variable was used after it was assigned through null-conditional operator. NullReferenceException is possible. RuntimeInformation.cs 29 <br><br> The analyzer warns about a possible exception of the <i>NullReferenceException</i> type when calling the <i>IndexOf</i> method for the <i>versionString</i> variable. When receiving the value for a variable, code authors use the '?.' operator to avoid a <i>NullReferenceException</i> exception when accessing the <i>InfromationalVersion</i> property. The trick is that if the call of <i>GetCustomAttribute&lt;...&gt;</i> returns <i>null</i> , an exception will still be generated, but below ‚Äî when calling the <i>IndexOf</i> method, as <i>versionString</i> will have the <i>null</i> value. <br><br> <b>Issue 44</b> <br><br> Let's address the <i>System.ComponentModel.Composition</i> project and look through several warnings. Two warnings were issued for the following code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CanSpecialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... object[] genericParameterConstraints = ....; GenericParameterAttributes[] genericParameterAttributes = ....; <span class="hljs-comment"><span class="hljs-comment">// if no constraints and attributes been specifed, anything can be created if ((genericParameterConstraints == null) &amp;&amp; (genericParameterAttributes == null)) { return true; } if ((genericParameterConstraints != null) &amp;&amp; (genericParameterConstraints.Length != partArity)) { return false; } if ((genericParameterAttributes != null) &amp;&amp; (genericParameterAttributes.Length != partArity)) { return false; } for (int i = 0; i &lt; partArity; i++) { if (!GenericServices.CanSpecialize( specialization[i], (genericParameterConstraints[i] as Type[]). CreateTypeSpecializations(specialization), genericParameterAttributes[i])) { return false; } } return true; }</span></span></code> </pre> <br> <b>PVS-Studio warnings:</b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3125</u></a> The 'genericParameterConstraints' object was used after it was verified against null. Check lines: 603, 589. GenericSpecializationPartCreationInfo.cs 603 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3125</u></a> The 'genericParameterAttributes' object was used after it was verified against null. Check lines: 604, 594. GenericSpecializationPartCreationInfo.cs 604 </li></ul><br> In code there are checks <i>genericParameterAttributes != null</i> and <i>genericParameterConstraints != null</i> . Therefore, <i>null</i> ‚Äî acceptable values for these variables, we'll take it into account. If both variables have the <i>null</i> value, we'll exit the method, no questions. What if one of two variables mentioned above is <i>null</i> , but in doing so we don't exit the method? If such case is possible and execution gets to traversing the loop, we'll get an exception of the <i>NullReferenceException</i> type. <br><br> <b>Issue 45</b> <br><br> Next we'll move to another interesting warning from this project. And though, let's do something different ‚Äî first we'll use the class again, and then look at the code. Next, we'll add reference to the same-name NuGet package of the last available prerelease version in the project (I installed the package of the version 4.6.0-preview6.19303.8). Let's write simple code, for example, such as: <br><br><pre> <code class="cpp hljs">LazyMemberInfo lazyMemberInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LazyMemberInfo(); var eq = lazyMemberInfo.Equals(null); Console.WriteLine(eq);</code> </pre> <br> The <i>Equals</i> method isn't commented, I didn't find this method description for .NET Core at docs.microsoft.com, only for .NET Framework. If we look at it (" <u>LazyMemberInfo.Equals(Object) Method</u> ") ‚Äî we won't see anything special whether it returns <i>true</i> or <i>false</i> , there is no information on generated exceptions. We'll execute the code and see: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e5/8f7/aa4/8e58f7aa4e5a274751cde57da4d9497f.png" alt="Bild 16"></div><br> We can get a little twisted and write the following code and also get interesting output: <br><br><pre> <code class="cpp hljs">LazyMemberInfo lazyMemberInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LazyMemberInfo(); var eq = lazyMemberInfo.Equals(typeof(String)); Console.WriteLine(eq);</code> </pre> <br> The result of the code execution. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e74/199/292/e74199292d39b2df8a7b205218c9c1fe.png" alt="Bild 17"></div><br><br> Interestingly, these both exceptions are generated in the same expression. Let's look insidethe <i>Equals</i> method. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object obj)</span></span></span><span class="hljs-function"> </span></span>{ LazyMemberInfo that = (LazyMemberInfo)obj; <span class="hljs-comment"><span class="hljs-comment">// Difefrent member types mean different members if (_memberType != that._memberType) { return false; } // if any of the lazy memebers create accessors in a delay-loaded fashion, // we simply compare the creators if ((_accessorsCreator != null) || (that._accessorsCreator != null)) { return object.Equals(_accessorsCreator, that._accessorsCreator); } // we are dealing with explicitly passed accessors in both cases if(_accessors == null || that._accessors == null) { throw new Exception(SR.Diagnostic_InternalExceptionMessage); } return _accessors.SequenceEqual(that._accessors); }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3115</u></a> Passing 'null' to 'Equals' method should not result in 'NullReferenceException'. LazyMemberInfo.cs 116 <br><br> Actually in this case the analyzer screwed up a bit, as it issued a warning for the <i>that._memberType</i> expression. However, exceptions occur earlier when executing the expression <i>(LazyMemberInfo)obj</i> . We've already made a note of it. <br><br> I think it's all clear with <i>InvalidCastException.</i> Why is <i>NullReferenceException</i> generated? The fact is that <i>LazyMemberInfo</i> is a struct, therefore, it gets unboxed. The <i>null</i> value unboxing, in turns, leads to occurrence of an exception of the <i>NullReferenceException</i> type. Also there is a couple of typos in comments ‚Äî authors should probably fix them. An explicit exception throwing is still on the authors hands. <br><br> <b>Issue 46</b> <br><br> By the way, I came across a similar case in <i>System.Drawing.Common</i> in the <i>TriState</i> structure. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object o)</span></span></span><span class="hljs-function"> </span></span>{ TriState state = (TriState)o; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _value == state._value; }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3115</u></a> Passing 'null' to 'Equals' method should not result in 'NullReferenceException'. TriState.cs 53 <br><br> The problems are the same as in the case described above. <br><br> <b>Issue 47</b> <br><br> Let's consider several fragments from <i>System.Text.Json</i> . <br><br> Remember I wrote that <i>ToString</i> mustn't return <i>null</i> ? Time to solidify this knowledge. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (TokenType) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JsonTokenType.None: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JsonTokenType.Null: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.Empty; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JsonTokenType.True: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>.TrueString; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JsonTokenType.False: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>.FalseString; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JsonTokenType.Number: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JsonTokenType.StartArray: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JsonTokenType.StartObject: { <span class="hljs-comment"><span class="hljs-comment">// null parent should have hit the None case Debug.Assert(_parent != null); return _parent.GetRawValueAsString(_idx); } case JsonTokenType.String: return GetString(); case JsonTokenType.Comment: case JsonTokenType.EndArray: case JsonTokenType.EndObject: default: Debug.Fail($"No handler for {nameof(JsonTokenType)}.{TokenType}"); return string.Empty; } }</span></span></code> </pre> <br> At first sight, this method doesn't return <i>null</i> , but the analyzer argues the converse. <br><br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3108</u></a> It is not recommended to return 'null' from 'ToSting()' method. JsonElement.cs 1460 <br><br> The analyzer points to the line with calling the <i>GetString()</i> method. Let's have a look at it. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ CheckValidInstance(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _parent.GetString(_idx, JsonTokenType.String); }</code> </pre> <br> Let's go deeper in the overloaded version of the <i>GetString</i> method: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, JsonTokenType expectedType)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tokenType == JsonTokenType.Null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } .... }</code> </pre> <br> Right after we see the condition, whose execution will result in the <i>null</i> value ‚Äî both from this method and <i>ToString</i> which we initially considered. <br><br> <b>Issue 48</b> <br><br> Another interesting fragment: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal JsonPropertyInfo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreatePolymorphicProperty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ JsonPropertyInfo runtimeProperty = CreateProperty(property.DeclaredPropertyType, runtimePropertyType, property.ImplementedPropertyType, property?.PropertyInfo, Type, options); property.CopyRuntimeSettingsTo(runtimeProperty); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> runtimeProperty; }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3042</u></a> Possible NullReferenceException. The '?.' and '.' operators are used for accessing members of the 'property' object JsonClassInfo.AddProperty.cs 179 <br><br> When calling the <i>CreateProperty</i> method, properties are referred several times through the variable <i>property</i> : <i>property.DeclaredPropertyType</i> , <i>property.ImplementedPropertyType</i> , <i>property?.PropertyInfo</i> . As you can see, in one case code authors use the '?.'  Betreiber. If it's not out of place here and <i>property</i> can have the <i>null</i> value, this operator won't be of any help, as an exception of the <i>NullReferenceException</i> type will be generated with direct access. <br><br> <b>Issue 49</b> <br><br> The following suspicious fragments were found in the <i>System.Security.Cryptography.Xml</i> project. They are paired up, the same as it has been several times with other warnings. Again, the code looks like copy-paste, compare these yourself. <br><br> The first fragment: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StringBuilder strBuilder, DocPosition docPos, AncestralNamespaceContextManager anc)</span></span></span><span class="hljs-function"> </span></span>{ docPos = DocPosition.BeforeRootElement; foreach (XmlNode childNode in ChildNodes) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (childNode.NodeType == XmlNodeType.Element) { CanonicalizationDispatcher.Write( childNode, strBuilder, DocPosition.InRootElement, anc); docPos = DocPosition.AfterRootElement; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { CanonicalizationDispatcher.Write(childNode, strBuilder, docPos, anc); } } }</code> </pre> <br> The second fragment. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteHash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HashAlgorithm hash, DocPosition docPos, AncestralNamespaceContextManager anc)</span></span></span><span class="hljs-function"> </span></span>{ docPos = DocPosition.BeforeRootElement; foreach (XmlNode childNode in ChildNodes) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (childNode.NodeType == XmlNodeType.Element) { CanonicalizationDispatcher.WriteHash( childNode, hash, DocPosition.InRootElement, anc); docPos = DocPosition.AfterRootElement; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { CanonicalizationDispatcher.WriteHash(childNode, hash, docPos, anc); } } }</code> </pre> <br> <b>PVS-Studio warnings:</b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3061</u></a> Parameter 'docPos' is always rewritten in method body before being used. CanonicalXmlDocument.cs 37 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3061</u></a> Parameter 'docPos' is always rewritten in method body before being used. CanonicalXmlDocument.cs 54 </li></ul><br> In both methods the <i>docPos</i> parameter is overwritten before its value is used. Therefore, the value, used as a method argument, is simply ignored. <br><br> <b>Issue 50</b> <br><br> Let's consider several warnings on the code of the <i>System.Data.SqlClient</i> project. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsBOMNeeded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MetaType type, object value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type.NullableType == TdsEnums.SQLXMLTYPE) { Type currentType = value.GetType(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentType == typeof(SqlString)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!((SqlString)value).IsNull &amp;&amp; ((((SqlString)value).Value).Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((((SqlString)value).Value[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>) != <span class="hljs-number"><span class="hljs-number">0xff</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((currentType == typeof(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>)) &amp;&amp; (((String)value).Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((value != null) &amp;&amp; (((<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>)value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>) != <span class="hljs-number"><span class="hljs-number">0xff</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentType == typeof(SqlXml)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!((SqlXml)value).IsNull) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentType == typeof(XmlDataFeed)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Values will eventually converted to unicode string here } } return false; }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3095</u></a> The 'value' object was used before it was verified against null. Check lines: 8696, 8708. TdsParser.cs 8696 <br><br> The analyzer was confused by the check <i>value != null</i> in one of the conditions. It seems like it was lost there during refactoring, as <i>value</i> gets dereferenced many times. If <i>value</i> can have the <i>null</i> value ‚Äî things are bad. <br><br> <b>Issue 51</b> <br><br> The next error is from tests, but it seemed interesting to me, so I decided to cite it. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> TDSMessageCollection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateQueryResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( lowerBatchText.Contains(<span class="hljs-string"><span class="hljs-string">"name"</span></span>) &amp;&amp; lowerBatchText.Contains(<span class="hljs-string"><span class="hljs-string">"state"</span></span>) &amp;&amp; lowerBatchText.Contains(<span class="hljs-string"><span class="hljs-string">"databases"</span></span>) &amp;&amp; lowerBatchText.Contains(<span class="hljs-string"><span class="hljs-string">"db_name"</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// SELECT [name], [state] FROM [sys].[databases] WHERE [name] = db_name() { // Delegate to current database response responseMessage = _PrepareDatabaseResponse(session); } .... }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3053</u></a> An excessive expression. Examine the substrings 'name' and 'db_name'. QueryEngine.cs 151 <br><br> The fact is that in this case the combination of subexpressions <i>lowerBatchText.Contains(¬´name¬ª)</i> and <i>lowerBatchText.Contains(¬´db_name¬ª)</i> is redundant. Indeed, if the checked string contains the substring <i>¬´db_name¬ª</i> , it will contain the <i>¬´name¬ª</i> substring as well. If the string doesn't contain <i>¬´name¬ª</i> , it won't contain <i>¬´db_name¬ª</i> either. As a result, it turns out that the check <i>lowerBatchText.Contains(¬´name¬ª)</i> is redundant. Unless it can reduce the number of evaluated expressions, if the checked string doesn't contain <i>¬´name¬ª</i> . <br><br> <b>Issue 52</b> <br><br> A suspicious fragment from the code of the <i>System.Net.Requests</i> project. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override PipelineInstruction </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PipelineCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( PipelineEntry entry, ResponseDescription response, ....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NetEventSource.IsEnabled) NetEventSource.Info(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, $<span class="hljs-string"><span class="hljs-string">"Command:{entry?.Command} Description:{response?.StatusDescription}"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// null response is not expected if (response == null) return PipelineInstruction.Abort; .... if (entry.Command == "OPTS utf8 on\r\n") .... .... }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3125</u></a> The 'entry' object was used after it was verified against null. Check lines: 270, 227. FtpControlStream.cs 270 <br><br> When composing an interpolated string, such expressions as <i>entry?.Command</i> and <i>response?.Description</i> are used. The '?.' operator is used instead of the '.' operator not to get an exception of the <i>NullReferenceException</i> type in case if any of the corresponding parameters has the <i>null</i> value. In this case, this technique works. Further, as we can see from the code, a possible <i>null</i> value for <i>response</i> gets split off (exit from the method if <i>response == null</i> ), whereas there's nothing similar for <i>entry.</i> As a result, if <i>entry</i> ‚Äî <i>null</i> further along the code when evaluating <i>entry.Command</i> (with the usage of '.', not '?.'), an exception will be generated. <br><br> At this point, a fairly detailed code review is waiting for us, so I suggest that you have another break ‚Äî chill out, make some tea or coffee. After that I'll be right here to continue. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56a/3fc/f07/56a3fcf075284f021a56249627e518bb.png" alt="Bild 21"></div><br> Are you back? Then let's keep going.  :) :) <br><br> <b>Issue 53</b> <br><br> Now let's find something interesting in the <i>System.Collections.Immutable</i> project. This time we'll have some experiments with the <i>System.Collections.Immutable.ImmutableArray&lt;T&gt;</i> struct. The methods <i>IStructuralEquatable.Equals</i> and <i>IStructuralComparable.CompareTo</i> are of special interest for us. <br><br> Let's start with the <i>IStructuralEquatable.Equals</i> method. The code is given below, I suggest that you try to get what's wrong yourself: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IStructuralEquatable.Equals(object other, IEqualityComparer comparer) { var self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; Array otherArray = other as Array; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherArray == null) { var theirs = other as IImmutableArray; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (theirs != null) { otherArray = theirs.Array; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> == null &amp;&amp; otherArray == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } } IStructuralEquatable ours = self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ours.Equals(otherArray, comparer); }</code> </pre> <br> Did you manage? If yes ‚Äî my congrats.  :) :) <br><br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3125</u></a> The 'ours' object was used after it was verified against null. Check lines: 1212, 1204. ImmutableArray_1.cs 1212 <br><br> The analyzer was confused by the call of the instance <i>Equals</i> method through the <i>ours</i> variable, located in the last <i>return</i> expression, as it suggests that an exception of the <i>NullReferenceException</i> type might occur here. Why does the analyzer suggest so? To make it easier to explain, I'm giving a simplified code fragment of the same method below. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IStructuralEquatable.Equals(object other, IEqualityComparer comparer) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> == null &amp;&amp; otherArray == null) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> == null) { .... } } } IStructuralEquatable ours = self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ours.Equals(otherArray, comparer); }</code> </pre> <br> In the last expressions, we can see, that the value of the <i>ours</i> variable comes from <i>self.array</i> . The check <i>self.array == null</i> is performed several times above. Which means, <i>ours,</i> the same as <i>self.array,</i> can have the <i>null</i> value. At least in theory. Is this state reachable in practice? Let's try to find out. To do this, once again I cite the body of the method with set key points. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IStructuralEquatable.Equals(object other, IEqualityComparer comparer) { var self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-comment"><span class="hljs-comment">// &lt;= 1 Array otherArray = other as Array; if (otherArray == null) // &lt;= 2 { var theirs = other as IImmutableArray; if (theirs != null) // &lt;= 3 { otherArray = theirs.Array; if (self.array == null &amp;&amp; otherArray == null) { return true; } else if (self.array == null) // &lt;= 4 { return false; } } IStructuralEquatable ours = self.array; // &lt;= 5 return ours.Equals(otherArray, comparer); }</span></span></code> </pre> <br> <b>Key point 1.</b> <i>self.array == this.array</i> (due to <i>self = this</i> ). Therefore, before calling the method, we need to get the condition <i>this.array == null</i> . <br><br> <b>Key point 2</b> . We can ignore this <i>if</i> , which will be the simplest way to get what we want. To ignore this <i>if</i> , we only need the <i>other</i> variable to be of the <i>Array</i> type or a derived one, and not to contain the <i>null</i> value. This way, after using the <i>as</i> operator, a non-null reference will be written in <i>otherArray</i> and we'll ignore the first <i>if</i> statement <i>.</i> <br><br> <b>Key point 3</b> . This point requires a more complex approach. We definitely need to exit on the second <i>if</i> statement (the one with the conditional expression <i>theirs != null</i> ). If it doesn't happen and <i>then</i> branch starts to execute, most certainly we won't get the needed point 5 under the condition <i>self.array == null</i> due to the key point 4. To avoid entering the <i>if</i> statement of the key point 3, one of these conditions has to be met: <br><br><ul><li> the <i>other</i> value has to be <i>null</i> ; </li><li> the actual <i>other</i> type mustn't implement the <i>IImmutableArray</i> interface. </li></ul><br> <b>Key point 5</b> . If we get to this point with the value <i>self.array == null</i> , it means that we've reached our aim, and an exception of the <i>NullReferenceException</i> type will be generated. <br><br> We get the following datasets that will lead us to the needed point. <br><br> First: <i>this.array ‚Äî null</i> . <br><br> Second ‚Äî one of the following ones: <br><br><ul><li> <i>other</i> ‚Äî <i>null</i> ; </li><li> <i>other</i> has the <i>Array</i> type or one derived from it; </li><li> <i>other</i> doesn't have the <i>Array</i> type or a derived from it and in doing so, doesn't implement the <i>IImmutableArray</i> interface. </li></ul><br> <i>array</i> is the field, declared in the following way: <br><br><pre> <code class="cpp hljs">internal T[] <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>;</code> </pre> <br> As <i>ImmutableArray&lt;T&gt;</i> is a structure, it has a default constructor (without arguments) that will result in the <i>array</i> field taking value by default, which is <i>null.</i> And that's what we need. <br><br> Let's not forget that we were investigating an explicit implementation of the interface method, therefore, casting has to be done before the call. <br><br> Now we have the game in hands to reach the exception occurrence in three ways. We add reference to the debugging library version, write the code, execute and see what happens. <br><br> <b>Code fragment 1.</b> <br><br><pre> <code class="cpp hljs">var comparer = EqualityComparer&lt;String&gt;.Default; ImmutableArray&lt;String&gt; immutableArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImmutableArray&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(); ((IStructuralEquatable)immutableArray).Equals(null, comparer);</code> </pre> <br> <b>Code fragment 2.</b> <br><br><pre> <code class="cpp hljs">var comparer = EqualityComparer&lt;String&gt;.Default; ImmutableArray&lt;String&gt; immutableArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImmutableArray&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(); ((IStructuralEquatable)immutableArray).Equals(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[] { }, comparer);</code> </pre> <br> <b>Code fragment 3.</b> <br><br><pre> <code class="cpp hljs">var comparer = EqualityComparer&lt;String&gt;.Default; ImmutableArray&lt;String&gt; immutableArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImmutableArray&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(); ((IStructuralEquatable)immutableArray).Equals(typeof(Object), comparer);</code> </pre> <br> The execution result of all three code fragments will be the same, only achieved by different input entry data, and execution paths. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/13a/a3b/e8a/13aa3be8a0b68a646aee130773f2c862.png" alt="Bild 18"></div><br> <b>Issue 54</b> <br><br> If you didn't forget, we have another method that we need to discredit. :) But this time we won't cover it in such detail. Moreover, we already know some information from the previous example. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IStructuralComparable.CompareTo(object other, IComparer comparer) { var self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; Array otherArray = other as Array; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherArray == null) { var theirs = other as IImmutableArray; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (theirs != null) { otherArray = theirs.Array; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> == null &amp;&amp; otherArray == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> == null ^ otherArray == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException( SR.ArrayInitializedStateNotEqual, nameof(other)); } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherArray != null) { IStructuralComparable ours = self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ours.CompareTo(otherArray, comparer); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } throw new ArgumentException(SR.ArrayLengthsNotEqual, nameof(other)); }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3125</u></a> The 'ours' object was used after it was verified against null. Check lines: 1265, 1251. ImmutableArray_1.cs 1265 <br><br> As you can see, the case is very similar to the previous example. <br><br> Let's write the following code: <br><br><pre> <code class="cpp hljs">Object other = ....; var comparer = Comparer&lt;String&gt;.Default; ImmutableArray&lt;String&gt; immutableArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImmutableArray&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(); ((IStructuralComparable)immutableArray).CompareTo(other, comparer);</code> </pre> <br> We'll try to find some entry data to reach the point, where exception of the <i>NullReferenceException</i> type might occur: <br><br> <b>Value:</b> <i>other</i> ‚Äî <i>new String[]{ }</i> ; <br><br> Result: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eef/d77/08a/eefd7708a187f5060f2074e642f18434.png" alt="Bild 22"></div><br> Thus, we again managed to figure out such data, with which an exception occurs in the method. <br><br> <b>Issue 55</b> <br><br> In the <i>System.Net.HttpListener</i> project I stumbled upon several both suspicious and very similar places. Once again, I can't shake the feeling about copy-paste, taking place here. Since the pattern is the same, we'll look at one code example. I'll cite analyzer warnings for the rest cases. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override IAsyncResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginRead</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(byte[] buffer, ....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NetEventSource.IsEnabled) { NetEventSource.Enter(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); NetEventSource.Info(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"buffer.Length:"</span></span> + buffer.Length + <span class="hljs-string"><span class="hljs-string">" size:"</span></span> + size + <span class="hljs-string"><span class="hljs-string">" offset:"</span></span> + offset); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(nameof(buffer)); } .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3095</u></a> The 'buffer' object was used before it was verified against null. Check lines: 51, 53. HttpRequestStream.cs 51 <br><br> Generation of an exception of the <i>ArgumentNullException</i> type under the condition <i>buffer == null</i> obviously suggests that <i>null</i> is an unacceptable value for this variable. However, if the value of the <i>NetEventSource.IsEnabled</i> expression is <i>true</i> and <i>buffer</i> ‚Äî <i>null</i> , when evaluating the <i>buffer.Length</i> expression, an exception of the <i>NullReferenceException</i> type will be generated. As we can see, we won't even reach the <i>buffer == null</i> check in this case. <br><br> PVS-Studio warnings issued for other methods with the pattern: <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3095</u></a> The 'buffer' object was used before it was verified against null. Check lines: 49, 51. HttpResponseStream.cs 49 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3095</u></a> The 'buffer' object was used before it was verified against null. Check lines: 74, 75. HttpResponseStream.cs 74 </li></ul><br> <b>Issue 56</b> <br><br> A similar code snippet was in the <i>System.Transactions.Local</i> project. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnterState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InternalTransaction tx)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tx._outcomeSource._isoLevel == IsolationLevel.Snapshot) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> TransactionException.CreateInvalidOperationException( TraceSourceType.TraceSourceLtm, SR.CannotPromoteSnapshot, null, tx == null ? Guid.Empty : tx.DistributedTxId); } .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3095</u></a> The 'tx' object was used before it was verified against null. Check lines: 3282, 3285. TransactionState.cs 3282 <br><br> Under a certain condition, an author wants to throw an exception of the <i>InvalidOperationException</i> type. When calling the method for creating an exception object, code authors use the <i>tx</i> parameter, check it for <i>null</i> to avoid an exception of the <i>NullReferenceException</i> type when evaluating the <i>tx.DistributedTxId</i> expression. It's ironic that the check won't be of help, as when evaluating the condition of the <i>if</i> statement, instance fields are accessed via the <i>tx</i> variable ‚Äî <i>tx._outcomeSource._isoLevel</i> . <br><br> <b>Issue 57</b> <br><br> Code from the <i>System.Runtime.Caching</i> project. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetLimit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cacheMemoryLimitMegabytes)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> cacheMemoryLimit = cacheMemoryLimitMegabytes; cacheMemoryLimit = cacheMemoryLimit &lt;&lt; MEGABYTE_SHIFT; _memoryLimit = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// never override what the user specifies as the limit; // only call AutoPrivateBytesLimit when the user does not specify one. if (cacheMemoryLimit == 0 &amp;&amp; _memoryLimit == 0) { // Zero means we impose a limit _memoryLimit = EffectiveProcessMemoryLimit; } else if (cacheMemoryLimit != 0 &amp;&amp; _memoryLimit != 0) { // Take the min of "cache memory limit" and // the host's "process memory limit". _memoryLimit = Math.Min(_memoryLimit, cacheMemoryLimit); } else if (cacheMemoryLimit != 0) { // _memoryLimit is 0, but "cache memory limit" // is non-zero, so use it as the limit _memoryLimit = cacheMemoryLimit; } .... }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3022</u></a> Expression 'cacheMemoryLimit != 0 &amp;&amp; _memoryLimit != 0' is always false. CacheMemoryMonitor.cs 250 <br><br> If you look closely at the code, you'll notice that one of the expressions ‚Äî <i>cacheMemoryLimit != 0 &amp;&amp; _memoryLimit != 0</i> will always be <i>false</i> . Since <i>_memoryLimit</i> has the 0 value (is set before the <i>if</i> statement), the right operand of the &amp;&amp; operator is <i>false</i> . Therefore, the result of the entire expression is <i>false</i> . <br><br> <b>Issue 58</b> <br><br> I cite a suspicious code fragment from the <i>System.Diagnostics.TraceSource</i> project below. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ StackNode n = _stack.Value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == null) { base.Pop(); } _stack.Value = n.Prev; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n.Value; }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3125</u></a> The 'n' object was used after it was verified against null. Check lines: 115, 111. CorrelationManager.cs 115 <br><br> In fact, it is an interesting case. Due to the check <i>n == null,</i> I assume, that <i>null</i> is an expected value for this local variable. If so, an exception of the <i>NullReferenceException</i> type will be generated when accessing the instance property ‚Äî <i>n.Prev</i> . If in this case <i>n</i> can never be <i>null</i> , <i>base.Pop()</i> will never be called. <br><br> <b>Issue 59</b> <br><br> An interesting code fragment from the <i>System.Drawing.Primitives</i> project. Again, I suggest that you try to find the problem yourself. Here's the code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToHtml</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Color c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> colorString = <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.Empty; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c.IsEmpty) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> colorString; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ColorUtil.IsSystemColor(c)) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (c.ToKnownColor()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ActiveBorder: colorString = <span class="hljs-string"><span class="hljs-string">"activeborder"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.GradientActiveCaption: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ActiveCaption: colorString = <span class="hljs-string"><span class="hljs-string">"activecaption"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.AppWorkspace: colorString = <span class="hljs-string"><span class="hljs-string">"appworkspace"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.Desktop: colorString = <span class="hljs-string"><span class="hljs-string">"background"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.Control: colorString = <span class="hljs-string"><span class="hljs-string">"buttonface"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ControlLight: colorString = <span class="hljs-string"><span class="hljs-string">"buttonface"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ControlDark: colorString = <span class="hljs-string"><span class="hljs-string">"buttonshadow"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ControlText: colorString = <span class="hljs-string"><span class="hljs-string">"buttontext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ActiveCaptionText: colorString = <span class="hljs-string"><span class="hljs-string">"captiontext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.GrayText: colorString = <span class="hljs-string"><span class="hljs-string">"graytext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.HotTrack: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.Highlight: colorString = <span class="hljs-string"><span class="hljs-string">"highlight"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.MenuHighlight: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.HighlightText: colorString = <span class="hljs-string"><span class="hljs-string">"highlighttext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.InactiveBorder: colorString = <span class="hljs-string"><span class="hljs-string">"inactiveborder"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.GradientInactiveCaption: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.InactiveCaption: colorString = <span class="hljs-string"><span class="hljs-string">"inactivecaption"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.InactiveCaptionText: colorString = <span class="hljs-string"><span class="hljs-string">"inactivecaptiontext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.Info: colorString = <span class="hljs-string"><span class="hljs-string">"infobackground"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.InfoText: colorString = <span class="hljs-string"><span class="hljs-string">"infotext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.MenuBar: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.Menu: colorString = <span class="hljs-string"><span class="hljs-string">"menu"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.MenuText: colorString = <span class="hljs-string"><span class="hljs-string">"menutext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ScrollBar: colorString = <span class="hljs-string"><span class="hljs-string">"scrollbar"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ControlDarkDark: colorString = <span class="hljs-string"><span class="hljs-string">"threeddarkshadow"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ControlLightLight: colorString = <span class="hljs-string"><span class="hljs-string">"buttonhighlight"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.Window: colorString = <span class="hljs-string"><span class="hljs-string">"window"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.WindowFrame: colorString = <span class="hljs-string"><span class="hljs-string">"windowframe"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.WindowText: colorString = <span class="hljs-string"><span class="hljs-string">"windowtext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c.IsNamedColor) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == Color.LightGray) { <span class="hljs-comment"><span class="hljs-comment">// special case due to mismatch between Html and enum spelling colorString = "LightGrey"; } else { colorString = c.Name; } } else { colorString = "#" + cRToString("X2", null) + cGToString("X2", null) + cBToString("X2", null); } return colorString; }</span></span></code> </pre> <br> Okay, okay, just kidding‚Ä¶ Or did you still find something? Anyway, let's reduce the code to clearly state the issue. <br><br> Here is the short code version: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (c.ToKnownColor()) { .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.Control: colorString = <span class="hljs-string"><span class="hljs-string">"buttonface"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ControlLight: colorString = <span class="hljs-string"><span class="hljs-string">"buttonface"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3139</u></a> Two or more case-branches perform the same actions. ColorTranslator.cs 302 <br><br> I can't say for sure, but I think it's an error. In other cases, when a developer wanted to return the same value for several enumerators he used several <i>case(s)</i> , following each other. And it's easy enough to make a mistake with copy-paste here, I think. <br><br> Let's dig a little deeper. To get the <i>¬´buttonface¬ª</i> value from the analyzed <i>ToHtml</i> method, you can pass one of the following values to it (expected): <br><br><ul><li> <i>SystemColors.Control</i> ; </li><li> <i>SystemColors.ControlLight</i> . </li></ul><br> If we check ARGB values for each of these colors, we'll see the following: <br><br><ul><li> <i>SystemColors.Control</i> ‚Äî <i>(255, 240, 240, 240)</i> ; </li><li> <i>SystemColors.ControlLight ‚Äî (255, 227, 227, 227)</i> . </li></ul><br> If we call the inverse conversion method <i>FromHtml</i> on the received value ( <i>¬´buttonface¬ª</i> ), we'll get the color <i>Control (255, 240, 240, 240)</i> . Can we get the <i>ControlLight</i> color from <i>FromHtml</i> ?  Ja This method contains the table of colors, which is the basis for composing colors (in this case). The table's initializer has the following line: <br><br><pre> <code class="cpp hljs">s_htmlSysColorTable[<span class="hljs-string"><span class="hljs-string">"threedhighlight"</span></span>] = ColorUtil.FromKnownColor(KnownColor.ControlLight);</code> </pre> <br> Accordingly, <i>FromHtml</i> returns the <i>ControlLight (255, 227, 227, 227)</i> color for the <i>¬´threedhighlight¬ª</i> value. I think that's exactly what should have been used in <i>case KnownColor.ControlLight</i> . <br><br> <b>Issue 60</b> <br><br> We'll check out a couple of interesting warnings from the <i>System.Text.RegularExpressions</i> project. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TextposDescription</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ var sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> remaining; sb.Append(runtextpos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sb.Length &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) sb.Append(<span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span> - sb.Length); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (runtextpos &gt; runtextbeg) sb.Append(RegexCharClass.CharDescription(runtext[runtextpos - <span class="hljs-number"><span class="hljs-number">1</span></span>])); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sb.Append(<span class="hljs-string"><span class="hljs-string">'^'</span></span>); sb.Append(<span class="hljs-string"><span class="hljs-string">'&gt;'</span></span>); remaining = runtextend - runtextpos; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = runtextpos; i &lt; runtextend; i++) { sb.Append(RegexCharClass.CharDescription(runtext[i])); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sb.Length &gt;= <span class="hljs-number"><span class="hljs-number">64</span></span>) { sb.Length = <span class="hljs-number"><span class="hljs-number">61</span></span>; sb.Append(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { sb.Append(<span class="hljs-string"><span class="hljs-string">'$'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sb.ToString(); }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3137</u></a> The 'remaining' variable is assigned but is not used by the end of the function. RegexRunner.cs 612 <br><br> A value is written in the local <i>remaining</i> variable, but it's not longer used in the method. Perhaps, some code, using it, was removed, but the variable itself was forgotten. Or there is a crucial error and this variable has to somehow be used. <br><br> <b>Issue 61</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> first, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> last)</span></span></span><span class="hljs-function"> </span></span>{ _rangelist.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SingleRange(first, last)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_canonical &amp;&amp; _rangelist.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; first &lt;= _rangelist[_rangelist.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>].Last) { _canonical = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3063</u></a> A part of conditional expression is always true if it is evaluated: _rangelist.Count &gt; 0. RegexCharClass.cs 523 <br><br> The analyzer rightly noted, that a part of the expression <i>_rangelist.Count &gt; 0</i> will always be <i>true</i> , if this code is executed. Even if this list (which <i>_rangelist</i> points at), was empty, after adding the element <i>_rangelist.Add(....)</i> it wouldn't be the same. <br><br> <b>Issue 62</b> <br><br> Let's look at the warnings of the <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3128</u></a> diagnostic rule in the projects <i>System.Drawing.Common</i> and <i>System.Transactions.Local</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArrayEnumerator</span></span></span><span class="hljs-class"> :</span></span> IEnumerator { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> object[] _array; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> object _item; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _index; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _startIndex; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _endIndex; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ArrayEnumerator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object[] </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">array</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count)</span></span></span><span class="hljs-function"> </span></span>{ _array = <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; _startIndex = startIndex; _endIndex = _index + count; _index = _startIndex; } .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3128</u></a> The '_index' field is used before it is initialized in constructor. PrinterSettings.Windows.cs 1679 <br><br> When initializing the <i>_endIndex</i> field, another <i>_index</i> field is used, which has a standard value <i>default(int)</i> , (that is <i>0</i> ) at the moment of its usage. The <i>_index</i> field is initialized below. In case if it's not an error ‚Äî the <i>_index</i> variable should have been omitted in this expression not to be confusing. <br><br> <b>Issue 63</b> <br><br><pre> <code class="cpp hljs">internal <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TransactionTable</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _timerInterval; .... <span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TransactionTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Create a timer that is initially disabled by specifing // an Infinite time to the first interval _timer = new Timer(new TimerCallback(ThreadTimer), null, Timeout.Infinite, _timerInterval); .... // Store the timer interval _timerInterval = 1 &lt;&lt; TransactionTable.timerInternalExponent; .... } }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3128</u></a> The '_timerInterval' field is used before it is initialized in constructor. TransactionTable.cs 151 <br><br> The case is similar to the one above. First the value of the <i>_timerInterval</i> field is used (while it's still <i>default(int)</i> ) to initialize <i>_timer.</i> Only after that the <i>_timerInterval</i> field itself will be initialized. <br><br> <b>Issue 64</b> <br><br> Next warnings were issued by the diagnostic rule, which is still in development. There's no documentation or final message, but we've already found a couple of interesting fragments with its help. Again these fragments look like <i>copy-paste</i> , so we'll consider only one code fragment. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessNotifyConnection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... WeakReference reference = (WeakReference)( LdapConnection.s_handleTable[referralFromConnection]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( reference != null &amp;&amp; reference.IsAlive &amp;&amp; null != ((LdapConnection)reference.Target)._ldapHandle) { .... } .... }</code> </pre> <br> <b>PVS-Studio warning (stub):</b> VXXXX TODO_MESSAGE. LdapSessionOptions.cs 974 <br><br> The trick is that after checking <i>reference.IsAlive</i> , garbage might be collected and the object, which <i>WeakReference</i> points to, will be garbage collected. In this case, <i>Target</i> will return the <i>null</i> value. As a result, when accessing the instance field <i>_ldapHandle</i> , an exception of the <i>NullReferenceException</i> type will occur. Microsoft itself warns about this trap with the check IsAlive. A quote from docs.microsoft.com ‚Äî " <u>WeakReference.IsAlive Property</u> ": <i>Because an object could potentially be reclaimed for garbage collection immediately after the IsAlive property returns true, using this property is not recommended unless you are testing only for a false return value.</i> <br><br><h2> Summary on Analysis </h2><br> Are these all errors and interesting places, found during the analysis? Of course, not! When looking through the analysis results, I was thoroughly checking out the warnings. As their number increased and it became clear there were enough of them for an article, I was scrolling through the results, trying to select only the ones that seemed to me the most interesting. When I got to the last ones (the largest logs), I was only able to look though the warnings until the sight caught on something unusual. So if you dig around, I'm sure you can find much more interesting places. <br><br> For example, I ignored almost all <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3022</u></a> and <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3063</a> warnings. So to speak, if I came across such code: <br><br><pre> <code class="cpp hljs">String str = null; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str == null) ....</code> </pre> <br> I would omit it, as there were many other interesting places that I wanted to describe. There were warnings on unsafe locking using the <i>lock statement</i> with locking by <i>this</i> and so on ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3090</u></a> ; unsafe event calls ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3083</u></a> <u>;</u> objects, which types implement <i>IDisposable</i> , but for which <i>Dispose</i> / <i>Close</i> isn't called ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>V3072</u></a> and similar diagnostics and much more. <br><br> I also didn't note problems, written in tests. At least, I tried, but could accidentally take some. Except for a couple of places that I found interesting enough to draw attention to them. But the testing code can also contain errors, due to which the tests will work incorrectly. <br><br> Generally, there are still many things to investigate ‚Äî but I didn't have the intention to mark <i>all found issues</i> . <br><br> The quality of the code seemed uneven to me. Some projects were perfectly clean, others contained suspicious places. Perhaps we might expect clean projects, especially when it comes to the most commonly used library classes. <br><br> To sum up, we can say, that the code is of quite high-quality, as its amount was considerable. But, as this article suggests, there were some dark corners. <br><br> By the way, a project of this size is also a good test for the analyzer. I managed to find a number of false / weird warnings that I selected to study and correct. So as a result of the analysis, I managed to find the points, where we have to work on the PVS-Studio itself. <br><br><h2>  Fazit </h2><br> If you got to this place by reading the whole article ‚Äî let me shake your hand! I hope that I was able to show you interesting errors and demonstrate the benefit of static analysis. If you have learned something new for yourself, that will let you write better code ‚Äî I will be doubly pleased. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ef/dbc/f2d/6efdbcf2d984bef000cf44face04c6a4.png" alt="Bild 23"></div><br> Anyway, some help by the static analysis won't hurt, so suggest that you <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>try PVS-Studio</u></a> on your project and see what interesting places can be found with its usage. If you have any questions or you just want to share interesting found fragments ‚Äî don't hesitate to write at <a href="">support@viva64.com</a> .  :) :) <br><br> Best regards! <br><br><h2> PS For .NET Core libraries developers </h2><br> Thank you so much for what you do!  Gute Arbeit! Hopefully this article will help you make the code a bit better. Remember, that I haven't written all suspicious places and you'd better check the project yourself using the analyzer. This way, you'll be able to investigate all warnings in details. Moreover, it'll be more convenient to work with it, rather than with simple text log / list of errors ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">I wrote about this in more details here</a> ). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463535/">https://habr.com/ru/post/de463535/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463513/index.html">Beste Webentwicklungs-Frameworks im Jahr 2019</a></li>
<li><a href="../de463515/index.html">Verwenden der HTMS-API zum Arbeiten mit einer relationalen Netzwerkdatenbank</a></li>
<li><a href="../de463525/index.html">Selen, Selenoid, Selenid, Selendroid ... Was bedeutet das alles?</a></li>
<li><a href="../de463527/index.html">Pop up! Transkribiert auf iOS</a></li>
<li><a href="../de463533/index.html">Was jeder Entwickler von Anfang an wissen sollte</a></li>
<li><a href="../de463537/index.html">√úberpr√ºfung des Quellcodes von .NET Core-Bibliotheken durch den statischen Analysator PVS-Studio</a></li>
<li><a href="../de463541/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 17. Zusammenfassung und Roadmap des CCNA-Kurses</a></li>
<li><a href="../de463551/index.html">Umgang mit Mitarbeitern und Organisation des Workflows in gro√üen IT-Unternehmen</a></li>
<li><a href="../de463553/index.html">"Googlest du Leute?" oder 5 Dinge, die wir bei der Einstellung getan haben (aber nicht mehr)</a></li>
<li><a href="../de463559/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 18. Routing-Grundlagen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>