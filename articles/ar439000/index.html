<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☹️ 🐘 🙅🏻 2D التلاعب المكاني مع الحقول مسافة موقعة 🛀🏾 🎅🏼 🚤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="عند العمل باستخدام الأصول المضلعة ، يمكنك رسم كائن واحد فقط في وقت واحد (إذا كنت لا تأخذ في الاعتبار تقنيات مثل التجميع والتثبيط) ، ولكن إذا كنت تستخد...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>2D التلاعب المكاني مع الحقول مسافة موقعة</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439000/" style=";text-align:right;direction:rtl"> عند العمل باستخدام الأصول المضلعة ، يمكنك رسم كائن واحد فقط في وقت واحد (إذا كنت لا تأخذ في الاعتبار تقنيات مثل التجميع والتثبيط) ، ولكن إذا كنت تستخدم حقول المسافات بعلامة (حقول المسافة الموقعة ، SDF) ، فنحن لا نقتصر على ذلك.  إذا كان لموضعين نفس الإحداثيات ، فسوف تُرجع وظائف المسافة الموقعة القيمة نفسها ، وفي حساب واحد يمكننا الحصول على عدة أرقام.  لفهم كيفية تحويل المساحة المستخدمة لإنشاء حقول مسافة موقَّعة ، نوصيك بمعرفة كيفية <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">إنشاء أشكال باستخدام وظائف المسافة الموقعة</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">والجمع بين أشكال sdf</a> . <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/b13/a59/cc9/b13a59cc9538d7f55cc41cba474575d7.gif"></div><a name="habracut"></a><br><h2 style=";text-align:right;direction:rtl">  التكوين </h2><br>  بالنسبة لهذا البرنامج التعليمي ، أقوم بتعديل الاقتران بين المربع والدائرة ، لكن يمكنك استخدامه لأي شكل آخر.  هذا مشابه لتكوين <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">البرنامج التعليمي السابق</a> . <br><br>  من المهم هنا أن يكون الجزء القابل للتعديل قبل استخدام المواقف لإنشاء أرقام. <br><br><pre style=";text-align:right;direction:rtl"><code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/036_SDF_Space_Manpulation/Type"</span></span>{ Properties{ _InsideColor(<span class="hljs-string"><span class="hljs-string">"Inside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _OutsideColor(<span class="hljs-string"><span class="hljs-string">"Outside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _LineDistance(<span class="hljs-string"><span class="hljs-string">"Mayor Line Distance"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) = <span class="hljs-number"><span class="hljs-number">1</span></span> _LineThickness(<span class="hljs-string"><span class="hljs-string">"Mayor Line Thickness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.05</span></span> [IntRange]_SubLines(<span class="hljs-string"><span class="hljs-string">"Lines between major lines"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)) = <span class="hljs-number"><span class="hljs-number">4</span></span> _SubLineThickness(<span class="hljs-string"><span class="hljs-string">"Thickness of inbetween lines"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.05</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.01</span></span> } SubShader{ <span class="hljs-comment"><span class="hljs-comment">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry Tags{ "RenderType"="Opaque" "Queue"="Geometry"} Pass{ CGPROGRAM #include "UnityCG.cginc" #include "2D_SDF.cginc" #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; struct v2f{ float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; v2f vert(appdata v){ v2f o; //calculate the position in clip space to render the object o.position = UnityObjectToClipPos(v.vertex); //calculate world position of vertex o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { // manipulate position with cool methods here! float2 squarePosition = position; squarePosition = translate(squarePosition, float2(2, 2)); squarePosition = rotate(squarePosition, .125); float squareShape = rectangle(squarePosition, float2(1, 1)); float2 circlePosition = position; circlePosition = translate(circlePosition, float2(1, 1.5)); float circleShape = circle(circlePosition, 1); float combination = merge(circleShape, squareShape); return combination; } float4 _InsideColor; float4 _OutsideColor; float _LineDistance; float _LineThickness; float _SubLines; float _SubLineThickness; fixed4 frag(v2f i) : SV_TARGET{ float dist = scene(i.worldPos.xz); fixed4 col = lerp(_InsideColor, _OutsideColor, step(0, dist)); float distanceChange = fwidth(dist) * 0.5; float majorLineDistance = abs(frac(dist / _LineDistance + 0.5) - 0.5) * _LineDistance; float majorLines = smoothstep(_LineThickness - distanceChange, _LineThickness + distanceChange, majorLineDistance); float distanceBetweenSubLines = _LineDistance / _SubLines; float subLineDistance = abs(frac(dist / distanceBetweenSubLines + 0.5) - 0.5) * distanceBetweenSubLines; float subLines = smoothstep(_SubLineThickness - distanceChange, _SubLineThickness + distanceChange, subLineDistance); return col * majorLines * subLines; } ENDCG } } FallBack "Standard" }</span></span></code> </pre> <br>  وتبدو الوظيفة 2D_SDF.cginc الموجودة في نفس المجلد مع التظليل ، والتي سنقوم بتوسيعها ، في البداية كما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SDF_2D #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SDF_2D </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//transforms float2 rotate(float2 samplePosition, float rotation){ const float PI = 3.14159; float angle = rotation * PI * 2 * -1; float sine, cosine; sincos(angle, sine, cosine); return float2(cosine * samplePosition.x + sine * samplePosition.y, cosine * samplePosition.y - sine * samplePosition.x); } float2 translate(float2 samplePosition, float2 offset){ //move samplepoint in the opposite direction that we want to move shapes in return samplePosition - offset; } float2 scale(float2 samplePosition, float scale){ return samplePosition / scale; } //combinations ///basic float merge(float shape1, float shape2){ return min(shape1, shape2); } float intersect(float shape1, float shape2){ return max(shape1, shape2); } float subtract(float base, float subtraction){ return intersect(base, -subtraction); } float interpolate(float shape1, float shape2, float amount){ return lerp(shape1, shape2, amount); } /// round float round_merge(float shape1, float shape2, float radius){ float2 intersectionSpace = float2(shape1 - radius, shape2 - radius); intersectionSpace = min(intersectionSpace, 0); float insideDistance = -length(intersectionSpace); float simpleUnion = merge(shape1, shape2); float outsideDistance = max(simpleUnion, radius); return insideDistance + outsideDistance; } float round_intersect(float shape1, float shape2, float radius){ float2 intersectionSpace = float2(shape1 + radius, shape2 + radius); intersectionSpace = max(intersectionSpace, 0); float outsideDistance = length(intersectionSpace); float simpleIntersection = intersect(shape1, shape2); float insideDistance = min(simpleIntersection, -radius); return outsideDistance + insideDistance; } float round_subtract(float base, float subtraction, float radius){ return round_intersect(base, -subtraction, radius); } ///champfer float champfer_merge(float shape1, float shape2, float champferSize){ const float SQRT_05 = 0.70710678118; float simpleMerge = merge(shape1, shape2); float champfer = (shape1 + shape2) * SQRT_05; champfer = champfer - champferSize; return merge(simpleMerge, champfer); } float champfer_intersect(float shape1, float shape2, float champferSize){ const float SQRT_05 = 0.70710678118; float simpleIntersect = intersect(shape1, shape2); float champfer = (shape1 + shape2) * SQRT_05; champfer = champfer + champferSize; return intersect(simpleIntersect, champfer); } float champfer_subtract(float base, float subtraction, float champferSize){ return champfer_intersect(base, -subtraction, champferSize); } /// round border intersection float round_border(float shape1, float shape2, float radius){ float2 position = float2(shape1, shape2); float distanceFromBorderIntersection = length(position); return distanceFromBorderIntersection - radius; } float groove_border(float base, float groove, float width, float depth){ float circleBorder = abs(groove) - width; float grooveShape = subtract(circleBorder, base + depth); return subtract(base, grooveShape); } //shapes float circle(float2 samplePosition, float radius){ //get distance from center and grow it according to radius return length(samplePosition) - radius; } float rectangle(float2 samplePosition, float2 halfSize){ float2 componentWiseEdgeDistance = abs(samplePosition) - halfSize; float outsideDistance = length(max(componentWiseEdgeDistance, 0)); float insideDistance = min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), 0); return outsideDistance + insideDistance; } #endif</span></span></span></span></code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/e60/788/36d/e6078836d9a222c4df1578609bdfaced.png"></div><br><h2 style=";text-align:right;direction:rtl">  تكرار الفضاء </h2><br><h3 style=";text-align:right;direction:rtl">  انعكاس المرآة </h3><br>  واحدة من أبسط العمليات هي عكس العالم عن المحور.  لنسخها حول المحور y ، نأخذ القيمة المطلقة للمكون x في موضعنا.  وبالتالي ، فإن الإحداثيات إلى يمين ويسار المحور ستكون هي نفسها.  <code>(-1, 1)</code> يتحول إلى <code>(1, 1)</code> ، ويظهر داخل الدائرة ، باستخدام <code>(1, 1)</code> كأصل <code>(1, 1)</code> ويبلغ نصف قطرها أكبر من 0. <br><br>  في أغلب الأحيان ، سيبدو الرمز الذي يستخدم هذه الوظيفة مثل <code>position = mirror(position);</code> النسخة <code>position = mirror(position);</code>  حتى نتمكن من تبسيطها قليلا.  سوف نعلن ببساطة حجة الموقف كما inout.  وبالتالي ، عند الكتابة إلى الوسيطة ، فإنه سيغير أيضًا المتغير الذي نمرره إلى الوظيفة.  يمكن أن تكون قيمة الإرجاع من النوع "باطلة" ، لأننا ما زلنا لا نستخدم قيمة الإرجاع. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc void mirror(inout float2 position){ position.x = abs(position.x); }</span></span></code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in shader function mirror(position);</span></span></code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/62f/6b0/40e/62f6b040e1e648e7d6411ecf634571f4.png"></div><br>  لقد اتضح أنه جيد بالفعل بالفعل ، ولكن بهذه الطريقة نحصل على محور واحد فقط للنسخ المتطابق.  يمكننا توسيع الوظيفة عن طريق تدوير المساحة كما فعلنا عند تدوير الأشكال.  تحتاج أولاً إلى تدوير المساحة ، ثم عكسها ، ثم إعادة تدويرها.  بهذه الطريقة يمكننا أداء النسخ المتطابق فيما يتعلق بأي زاوية.  نفس الشيء ممكن عند نقل المساحة وتنفيذ النقل العكسي بعد النسخ المتطابق.  (إذا قمت بإجراء كلتا العمليتين ، ثم قبل النسخ المتطابق ، لا تنسَ إجراء عملية النقل أولاً ، ثم المنعطف ، وبعد ذلك يتم الدوران أولاً). <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in shader function float rotation = _Time.y * 0.25; position = rotate(position, rotation); mirror(position); position = rotate(position, -rotation);</span></span></code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/23a/afd/284/23aafd284c90054af5e7d8b453aac212.gif"></div><br><h2 style=";text-align:right;direction:rtl">  خلايا </h2><br>  إذا كنت تعرف كيف يعمل <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">توليد الضوضاء</a> ، فأنت تفهم أنه بالنسبة للجيل الإجرائي ، فإننا غالبًا ما نكرر هذا الموقف ونحصل على خلايا صغيرة متماثلة أساسًا ، تختلف فقط في المعلمات غير المهمة.  يمكننا أن نفعل الشيء نفسه بالنسبة لحقول المسافة. <br><br>  نظرًا لأن وظيفة <code>fmod</code> (بالإضافة إلى استخدام٪ للقسمة على الباقي) تعطينا الباقي ، وليس تعريف الباقي ، فسوف يتعين علينا استخدام خدعة.  أولاً ، نأخذ باقي تقسيم عدد صحيح بواسطة الدالة fmod.  بالنسبة للأرقام الموجبة ، هذا هو بالضبط ما نحتاج إليه ، وبالنسبة للأعداد السالبة ، هذه هي النتيجة التي نحتاجها مطروحًا منها هذه الفترة.  يمكنك إصلاح ذلك عن طريق إضافة فترة ومرة ​​أخرى أخذ باقي التقسيم.  ستؤدي إضافة فترة إلى إعطاء النتيجة المرغوبة لقيم المدخلات السالبة ، وقيم المدخلات الموجبة ، تكون القيمة أعلى بفترة واحدة.  لن تفعل البقية الثانية من القسمة أي شيء بقيم قيم المدخلات السلبية ، لأنها موجودة بالفعل في النطاق من 0 إلى الفترة ، وبالنسبة لقيم المدخلات الإيجابية ، فإننا نطرح أساسًا فترة واحدة. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc void cells(inout float2 position, float2 period){ position = fmod(position, period); //negative positions lead to negative modulo position += period; //negative positions now have correct cell coordinates, positive input positions too high position = fmod(position, period); //second mod doesn't change values between 0 and period, but brings down values that are above period. }</span></span></code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in shader function cells(position, float2(3, 3));</span></span></code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/4b9/3f0/b53/4b93f0b53e221b11780ed0c627ebe5c8.png"></div><br>  المشكلة في الخلايا هي أننا نفقد الاستمرارية التي نحب بها حقول المسافات.  هذا ليس سيئًا إذا كانت الأشكال موجودة فقط في منتصف الخلايا ، ولكن في المثال الموضح أعلاه ، يمكن أن يؤدي ذلك إلى بعض التحف الفنية الهامة التي ينبغي تجنبها عند استخدام حقول المسافات لمجموعة متنوعة من المهام التي يمكن فيها عادة استخدام حقول المسافات. <br><br>  هناك حل واحد لا يعمل في كل حالة ، لكن عندما ينجح ، من الرائع: عكس كل خلية أخرى.  للقيام بذلك ، نحتاج إلى فهرس خلايا البكسل ، لكننا لا نزال لا نمتلك قيمة إرجاع في الوظيفة ، حتى نتمكن من استخدامها فقط لإرجاع فهرس الخلية. <br><br>  لحساب مؤشر الخلية ، نقوم بتقسيم الموضع على الفترة.  وبالتالي ، 0-1 هي الخلية الأولى ، 1-2 هي الثانية ، وهكذا ... ويمكننا أن نفهمها بسهولة.  للحصول على فهرس الخلية ، قمنا ببساطة بتقريب القيمة لأسفل وإرجاع النتيجة.  الشيء المهم هو أننا نحسب مؤشر الخلية قبل الانقسام مع الباقي لتكرار الخلايا.  وإلا ، فسنحصل على مؤشر 0 في كل مكان ، لأن الموضع لا يمكن أن يتجاوز المدة. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc float2 cells(inout float2 position, float2 period){ position = fmod(position, period); //negative positions lead to negative modulo position += period; //negative positions now have correct cell coordinates, positive input positions too high position = fmod(position, period); //second mod doesn't change values between 0 and period, but brings down values that are above period. float2 cellIndex = position / period; cellIndex = floor(cellIndex); return cellIndex; }</span></span></code> </pre> <br>  مع هذه المعلومات ، يمكننا قلب الخلايا.  لفهم ما إذا كان يجب قلبه أم لا ، نقسم معامل فهرس الخلية 2. تكون نتيجة هذه العملية بالتناوب 0 و 1 أو -1 في كل خلية ثانية.  لجعل التغيير أكثر ديمومة ، نأخذ القيمة المطلقة ونحصل على قيمة تنتقل بين 0 و 1. <br><br>  لاستخدام هذه القيمة للانعكاس بين الموضع العادي والمقلوب ، نحتاج إلى وظيفة لا تفعل شيئًا للقيمة 0 ، ونطرح الموضع من الفترة التي يكون فيها التقليب هو 1. وهذا هو ، ونحن نقوم بإجراء الاستيفاء الخطي من الوضع الطبيعي إلى المقلوب باستخدام متغير التقليب .  نظرًا لأن المتغير flip هو ناقل ثنائي الأبعاد ، يتم قلب مكوناته بشكل فردي. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in shader function float2 period = 3; float2 cell = cells(position, period); float2 flip = abs(fmod(cell, 2)); position = lerp(position, period - position, flip);</span></span></code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/45a/c36/5a1/45ac365a1cb18e89306a5ac1f0d01b57.png"></div><br><h2 style=";text-align:right;direction:rtl">  خلايا شعاعية </h2><br>  ميزة أخرى كبيرة هي تكرار الفضاء في نمط شعاعي. <br><br>  للحصول على هذا التأثير ، نقوم أولاً بحساب الموضع الشعاعي.  للقيام بذلك ، نقوم بتشفير الزاوية بالنسبة إلى مركز المحور س والمسافة من المركز على طول المحور ص. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">float2 radialPosition = float2(<span class="hljs-built_in"><span class="hljs-built_in">atan2</span></span>(position.x, position.y), length(position));</code> </pre> <br>  ثم نكرر الزاوية.  نظرًا لأن نقل عدد التكرارات أسهل بكثير من زاوية كل قطعة ، فنحن أولاً نحسب حجم كل قطعة.  الدائرة بأكملها هي 2 * pi ، حتى نحصل على الجزء الصحيح ، نقسم 2 * pi على حجم الخلية. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> PI = <span class="hljs-number"><span class="hljs-number">3.14159</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cellSize = PI * <span class="hljs-number"><span class="hljs-number">2</span></span> / cells;</code> </pre> <br>  باستخدام هذه المعلومات ، يمكننا تكرار المكون x للموضع الكعبري لكل وحدات حجم الخلية.  نقوم بإجراء التكرار عن طريق القسمة على الباقي ، وبالتالي ، كما كان من قبل ، فإننا نواجه مشاكل مع الأعداد السالبة ، والتي يمكن القضاء عليها بمساعدة وظيفتي تقسيم مع الباقي. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">radialPosition.x = <span class="hljs-built_in"><span class="hljs-built_in">fmod</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">fmod</span></span>(radialPosition.x, cellSize) + cellSize, cellSize);</code> </pre> <br>  ثم تحتاج إلى نقل الموضع الجديد مرة أخرى إلى إحداثيات س ص المعتادة.  هنا نستخدم الدالة sincos مع المكون x للموضع الكعبري كزاوية لكتابة الجيب إلى إحداثي x للموقف وجيب التمام إلى إحداثي y.  مع هذه الخطوة ، حصلنا على وضع طبيعي.  للحصول على الاتجاه الصحيح من المركز ، تحتاج إلى ضربه بالمكون ص في الموضع الشعاعي ، وهو ما يعني الطول. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc void radial_cells(inout float2 position, float cells){ const float PI = 3.14159; float cellSize = PI * 2 / cells; float2 radialPosition = float2(atan2(position.x, position.y), length(position)); radialPosition.x = fmod(fmod(radialPosition.x, cellSize) + cellSize, cellSize); sincos(radialPosition.x, position.x, position.y); position = position * radialPosition.y; }</span></span></code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in shader function float2 period = 6; radial_cells(position, period, false);</span></span></code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/1db/a77/c42/1dba77c426e68d224172d2587b0a3a6f.png"></div><br>  ثم يمكننا أيضًا إضافة فهرس الخلايا والنسخ المتطابق ، كما فعلنا مع الخلايا العادية. <br><br>  من الضروري حساب مؤشر الخلية بعد حساب الموضع الشعاعي ، ولكن قبل استلام الباقي من القسمة.  نحصل عليه بتقسيم المكون x للموضع الشعاعي وتقريب النتيجة لأسفل.  في هذه الحالة ، يمكن أن يكون الفهرس سالبًا ، وهذه مشكلة إذا كان عدد الخلايا غريبًا.  على سبيل المثال ، مع 3 خلايا ، نحصل على خلية واحدة بمؤشر من 0 ، وخلية واحدة بمؤشر من -1 و 2 من الخلايا النصفية مع الفهارس 1 و -2.  للتغلب على هذه المشكلة ، نضيف عدد الخلايا إلى المتغير المقرب لأسفل المتغير ، ثم نقسم على حجم الخلية مع الباقي. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc float cellIndex = fmod(floor(radialPosition.x / cellSize) + cells, cells); //at the end of the function: return cellIndex;</span></span></code> </pre> <br>  لعكس هذا ، نحتاج إلى أن تكون الإحداثيات بالراديان ، لذلك لتجنب إعادة حساب الإحداثيات الشعاعية خارج الوظيفة ، نضيف خيارًا لها باستخدام الوسيطة bool.  عادةً ما يكون الترحيل في التظليل غير مرحب به (في حالة البناء) ، ولكن في هذه الحالة ، ستذهب جميع وحدات البكسل على الشاشة إلى نفس المسار ، لذلك هذا طبيعي. <br><br>  يجب أن يحدث النسخ المتطابق بعد الإحداثي نصف الدائري ، ولكن قبل أن يتم تحويله إلى وضعه الطبيعي.  سوف نكتشف ما إذا كنا بحاجة إلى قلب الخلية الحالية بتقسيم مؤشر الخلية على 2 مع الباقي ، وعادةً ما يعطينا هذا أصفارًا وأخرى ، لكن في حالتي ، تظهر عدة توائم ، وهي غريبة ، ولا يزال بإمكاننا التعامل معها.  للتخلص من الثغرات ، نقوم ببساطة بطرح 1 من متغير الوجه ، ثم نأخذ القيمة المطلقة.  وبالتالي ، تصبح الأصفار والقصاصات وحدات ، وتصبح الوحدات أصفارًا ، حسب حاجتنا ، بترتيب عكسي فقط. <br><br>  نظرًا لأن الأصفار والأخرى بالترتيب الخاطئ ، فنحن نقوم بإجراء الاستيفاء الخطي من الإصدار رأسًا على عقب إلى الإصدار رأسًا على عقب ، وليس العكس ، كما كان من قبل.  لقلب الإحداثيات ، نقوم ببساطة بطرح الموضع من حجم الخلية. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc float radial_cells(inout float2 position, float cells, bool mirrorEverySecondCell = false){ const float PI = 3.14159; float cellSize = PI * 2 / cells; float2 radialPosition = float2(atan2(position.x, position.y), length(position)); float cellIndex = fmod(floor(radialPosition.x / cellSize) + cells, cells); radialPosition.x = fmod(fmod(radialPosition.x, cellSize) + cellSize, cellSize); if(mirrorEverySecondCell){ float flip = fmod(cellIndex, 2); flip = abs(flip-1); radialPosition.x = lerp(cellSize - radialPosition.x, radialPosition.x, flip); } sincos(radialPosition.x, position.x, position.y); position = position * radialPosition.y; return cellIndex; }</span></span></code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in shader function float2 period = 6; radial_cells(position, period, true);</span></span></code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/1b0/3ea/d5e/1b03ead5e0a63236e909d31a5025d8c7.png"></div><br><h2 style=";text-align:right;direction:rtl">  يتمايل الفضاء </h2><br>  ولكن لتغيير الفضاء ليس من الضروري لتكرار ذلك.  على سبيل المثال ، في البرنامج التعليمي حول الأساسيات ، قمنا بتدويره ونقله وتغيير حجمه.  يمكنك أيضًا القيام بما يلي: حرك كل محور على أساس الآخر بموجة جيبية.  سيؤدي ذلك إلى جعل مسافات وظيفة المسافة الموقعة أقل دقة ، ولكن حتى يتأرجح كثيرًا ، سيكون كل شيء على ما يرام. <br><br>  أولاً ، نحسب حجم التغير في الموضع عن طريق قلب مكونات x و y ، ثم ضربها بتردد التذبذب.  ثم نأخذ جيب من هذه القيمة ونضربها بمقدار التمايل الذي نريد إضافته.  بعد ذلك ، نضيف ببساطة عامل التذبذب إلى الموضع ونطبق النتيجة مرة أخرى على الموضع. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc void wobble(inout float2 position, float2 frequency, float2 amount){ float2 wobble = sin(position.yx * frequency) * amount; position = position + wobble; }</span></span></code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in shader function wobble(position, 5, .05);</span></span></code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/01c/67e/ec8/01c67eec8726bff917f97e90a5fa8431.png"></div><br>  يمكننا أيضًا تحريك هذا التلويح ، وتغيير موضعه ، وتطبيق التلويح في موضع الإزاحة وإعادة المساحة مرة أخرى.  بحيث لا تصبح أرقام الفاصلة العائمة كبيرة جدًا ، أقوم بالتقسيم مع الباقي pi * 2 حسب التردد المتذبذب ، وهذا يرتبط بالتذبذب (الجيوب الأنفية يكرر كل وحدة pi * 2) ، لذلك نتجنب القفزات والإزاحة الكبيرة جدًا. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in shader function const float PI = 3.14159; float frequency = 5; float offset = _Time.y; offset = fmod(offset, PI * 2 / frequency); position = translate(position, offset); wobble(position, 5, .05); position = translate(position, -offset);</span></span></code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/b13/a59/cc9/b13a59cc9538d7f55cc41cba474575d7.gif"></div><br><h2 style=";text-align:right;direction:rtl">  شفرة المصدر </h2><br><h3 style=";text-align:right;direction:rtl">  2D مكتبة قوات الدفاع الذاتى </h3><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/036_SDF_space_manipulation/2D_SDF.cginc</a> </li></ul><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SDF_2D #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SDF_2D </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//transforms float2 rotate(float2 samplePosition, float rotation){ const float PI = 3.14159; float angle = rotation * PI * 2 * -1; float sine, cosine; sincos(angle, sine, cosine); return float2(cosine * samplePosition.x + sine * samplePosition.y, cosine * samplePosition.y - sine * samplePosition.x); } float2 translate(float2 samplePosition, float2 offset){ //move samplepoint in the opposite direction that we want to move shapes in return samplePosition - offset; } float2 scale(float2 samplePosition, float scale){ return samplePosition / scale; } //combinations ///basic float merge(float shape1, float shape2){ return min(shape1, shape2); } float intersect(float shape1, float shape2){ return max(shape1, shape2); } float subtract(float base, float subtraction){ return intersect(base, -subtraction); } float interpolate(float shape1, float shape2, float amount){ return lerp(shape1, shape2, amount); } /// round float round_merge(float shape1, float shape2, float radius){ float2 intersectionSpace = float2(shape1 - radius, shape2 - radius); intersectionSpace = min(intersectionSpace, 0); float insideDistance = -length(intersectionSpace); float simpleUnion = merge(shape1, shape2); float outsideDistance = max(simpleUnion, radius); return insideDistance + outsideDistance; } float round_intersect(float shape1, float shape2, float radius){ float2 intersectionSpace = float2(shape1 + radius, shape2 + radius); intersectionSpace = max(intersectionSpace, 0); float outsideDistance = length(intersectionSpace); float simpleIntersection = intersect(shape1, shape2); float insideDistance = min(simpleIntersection, -radius); return outsideDistance + insideDistance; } float round_subtract(float base, float subtraction, float radius){ return round_intersect(base, -subtraction, radius); } ///champfer float champfer_merge(float shape1, float shape2, float champferSize){ const float SQRT_05 = 0.70710678118; float simpleMerge = merge(shape1, shape2); float champfer = (shape1 + shape2) * SQRT_05; champfer = champfer - champferSize; return merge(simpleMerge, champfer); } float champfer_intersect(float shape1, float shape2, float champferSize){ const float SQRT_05 = 0.70710678118; float simpleIntersect = intersect(shape1, shape2); float champfer = (shape1 + shape2) * SQRT_05; champfer = champfer + champferSize; return intersect(simpleIntersect, champfer); } float champfer_subtract(float base, float subtraction, float champferSize){ return champfer_intersect(base, -subtraction, champferSize); } /// round border intersection float round_border(float shape1, float shape2, float radius){ float2 position = float2(shape1, shape2); float distanceFromBorderIntersection = length(position); return distanceFromBorderIntersection - radius; } float groove_border(float base, float groove, float width, float depth){ float circleBorder = abs(groove) - width; float grooveShape = subtract(circleBorder, base + depth); return subtract(base, grooveShape); } // space repetition void mirror(inout float2 position){ position.x = abs(position.x); } float2 cells(inout float2 position, float2 period){ //find cell index float2 cellIndex = position / period; cellIndex = floor(cellIndex); //negative positions lead to negative modulo position = fmod(position, period); //negative positions now have correct cell coordinates, positive input positions too high position += period; //second mod doesn't change values between 0 and period, but brings down values that are above period. position = fmod(position, period); return cellIndex; } float radial_cells(inout float2 position, float cells, bool mirrorEverySecondCell = false){ const float PI = 3.14159; float cellSize = PI * 2 / cells; float2 radialPosition = float2(atan2(position.x, position.y), length(position)); float cellIndex = fmod(floor(radialPosition.x / cellSize) + cells, cells); radialPosition.x = fmod(fmod(radialPosition.x, cellSize) + cellSize, cellSize); if(mirrorEverySecondCell){ float flip = fmod(cellIndex, 2); flip = abs(flip-1); radialPosition.x = lerp(cellSize - radialPosition.x, radialPosition.x, flip); } sincos(radialPosition.x, position.x, position.y); position = position * radialPosition.y; return cellIndex; } void wobble(inout float2 position, float2 frequency, float2 amount){ float2 wobble = sin(position.yx * frequency) * amount; position = position + wobble; } //shapes float circle(float2 samplePosition, float radius){ //get distance from center and grow it according to radius return length(samplePosition) - radius; } float rectangle(float2 samplePosition, float2 halfSize){ float2 componentWiseEdgeDistance = abs(samplePosition) - halfSize; float outsideDistance = length(max(componentWiseEdgeDistance, 0)); float insideDistance = min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), 0); return outsideDistance + insideDistance; } #endif</span></span></span></span></code> </pre> <br><h3 style=";text-align:right;direction:rtl">  شادر التجريبي الأساسي </h3><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/036_SDF_space_manipulation/sdf_mirror.shader</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/036_SDF_space_manipulation/sdf_cells.shader</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/036_SDF_space_manipulation/sdf_wobble.shader</a> </li></ul><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/036_SDF_Space_Manpulation/Mirror"</span></span>{ Properties{ _InsideColor(<span class="hljs-string"><span class="hljs-string">"Inside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _OutsideColor(<span class="hljs-string"><span class="hljs-string">"Outside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _LineDistance(<span class="hljs-string"><span class="hljs-string">"Mayor Line Distance"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) = <span class="hljs-number"><span class="hljs-number">1</span></span> _LineThickness(<span class="hljs-string"><span class="hljs-string">"Mayor Line Thickness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.05</span></span> [IntRange]_SubLines(<span class="hljs-string"><span class="hljs-string">"Lines between major lines"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)) = <span class="hljs-number"><span class="hljs-number">4</span></span> _SubLineThickness(<span class="hljs-string"><span class="hljs-string">"Thickness of inbetween lines"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.05</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.01</span></span> } SubShader{ <span class="hljs-comment"><span class="hljs-comment">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry Tags{ "RenderType"="Opaque" "Queue"="Geometry"} Pass{ CGPROGRAM #include "UnityCG.cginc" #include "2D_SDF.cginc" #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; struct v2f{ float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; v2f vert(appdata v){ v2f o; //calculate the position in clip space to render the object o.position = UnityObjectToClipPos(v.vertex); //calculate world position of vertex o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { // modify position here! float2 squarePosition = position; squarePosition = translate(squarePosition, float2(2, 2)); squarePosition = rotate(squarePosition, .125); float squareShape = rectangle(squarePosition, float2(1, 1)); float2 circlePosition = position; circlePosition = translate(circlePosition, float2(1, 1.5)); float circleShape = circle(circlePosition, 1); float combination = merge(circleShape, squareShape); return combination; } float4 _InsideColor; float4 _OutsideColor; float _LineDistance; float _LineThickness; float _SubLines; float _SubLineThickness; fixed4 frag(v2f i) : SV_TARGET{ float dist = scene(i.worldPos.xz); fixed4 col = lerp(_InsideColor, _OutsideColor, step(0, dist)); float distanceChange = fwidth(dist) * 0.5; float majorLineDistance = abs(frac(dist / _LineDistance + 0.5) - 0.5) * _LineDistance; float majorLines = smoothstep(_LineThickness - distanceChange, _LineThickness + distanceChange, majorLineDistance); float distanceBetweenSubLines = _LineDistance / _SubLines; float subLineDistance = abs(frac(dist / distanceBetweenSubLines + 0.5) - 0.5) * distanceBetweenSubLines; float subLines = smoothstep(_SubLineThickness - distanceChange, _SubLineThickness + distanceChange, subLineDistance); return col * majorLines * subLines; } ENDCG } } FallBack "Standard" //fallback adds a shadow pass so we get shadows on other objects }</span></span></code> </pre> <br>  الآن أنت تعرف كل أساسيات وظائف مسافة الإشارة التي يمكن أن أتذكرها.  في البرنامج التعليمي التالي ، سأحاول القيام بشيء مثير للاهتمام معهم. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/842/5fe/d84/8425fed84e484cd150a7eba8b4d8901c.gif"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar439000/">https://habr.com/ru/post/ar439000/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar438988/index.html">رد فعل البرنامج التعليمي الجزء 15: ورش عمل الدولة المكون</a></li>
<li><a href="../ar438992/index.html">المطور يوميات أو قرارات سيئة</a></li>
<li><a href="../ar438994/index.html">إنتل زيون W-3175X ، لاعب الدرامز الساخن. اختبار</a></li>
<li><a href="../ar438996/index.html">شركة الشبكة و MitM. الجزء 1</a></li>
<li><a href="../ar438998/index.html">CGDevs Moscow Meetup # 2</a></li>
<li><a href="../ar439002/index.html">كيف تتوقف عن "كتابة المعارف التقليدية" وتبدأ العمل؟</a></li>
<li><a href="../ar439006/index.html">كيف يساعد الذكاء الاصطناعى تعلم لغة الإشارة</a></li>
<li><a href="../ar439010/index.html">كيف يعمل دمج الأرشيف في DeviceLock DLP</a></li>
<li><a href="../ar439012/index.html">دليل هاتف المنظمة - نسخة مطبوعة</a></li>
<li><a href="../ar439016/index.html">جداول عامة ثابتة</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>