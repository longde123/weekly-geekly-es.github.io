<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔈 👨‍👩‍👧‍👦 🦐 Quorum blockchain: integrasi ke dalam kode Java 🐵 🏁 😞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! 


 Bagi mereka yang tertarik dengan masalah blockchain, bukan rahasia lagi bahwa selain blockchain publik, seperti Ethereum , Bitcoin , Z...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Quorum blockchain: integrasi ke dalam kode Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462549/"><p>  Halo, Habr! </p><br><p>  Bagi mereka yang tertarik dengan masalah blockchain, bukan rahasia lagi bahwa selain blockchain publik, seperti <em>Ethereum</em> , <em>Bitcoin</em> , <em>Zcash</em> , dll., Ada juga "perusahaan (pribadi)" "saudara" mereka yang dalam beberapa hal lebih baik daripada jaringan publik, tetapi dalam sesuatu mereka kalah dari mereka.  Di antara jaringan yang paling terkenal, saya pikir Anda dapat memberi nama <em>Quorum</em> (vendor - <strong>JP Morgan Chase</strong> ), <em>Pantheon</em> (vendor - <strong>PegaSys</strong> ) dan <em>Hyperledger</em> (dikelola oleh <strong>The Linux Foundation</strong> ).  Terlepas dari kenyataan bahwa ada cukup banyak keputusan publik, bisnis semakin tertarik pada blockchain pribadi karena mereka mampu memberikan tingkat privasi yang diperlukan, transaksi lebih cepat dan sebagainya. <a name="habracut"></a>  Perbedaan antara blockchain swasta dan publik, serta kelebihan dan kekurangannya, bukan topik artikel ini.  Jika Anda tertarik untuk membacanya, artinya, misalnya, artikel tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Media</a> . </p><br><p>  Dalam artikel ini, saya ingin memberi tahu Anda bagaimana Anda dapat menggunakan blockchain <em>Quorum</em> untuk mengembangkan aplikasi Anda dengan dukungan untuk transaksi pribadi dan publik.  Untuk menunjukkan kemampuannya, kami akan menulis aplikasi kecil <em>Java / Spring</em> yang akan menerima permintaan untuk menyebarkan (menyebarkan) kontrak pintar, melakukan transaksi dan membaca data dari kontrak pintar.  Sebenarnya, inilah tumpukan teknologi yang akan digunakan dalam artikel: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java 8</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gradle 5.2.1</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kerangka pegas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Web3j</a> (perpustakaan untuk bekerja dengan transaksi publik di jaringan seperti Ethereum) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Web3j-kuorum</a> (perpustakaan untuk bekerja dengan transaksi pribadi di jaringan kuorum) </li></ul><br><h1 id="nemnogo-obschey-informacii-o-quorum">  Beberapa informasi umum tentang Kuorum </h1><br><p>  <em>Quorum</em> adalah proyek dengan kode sumber terbuka di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> , yang tujuannya adalah untuk menyediakan blockchain yang akan memungkinkan untuk melakukan transaksi tidak hanya secara publik tetapi juga dalam mode pribadi juga.  Dari sudut pandang teknis, <em>Quorum</em> adalah peningkatan <em>Ethereum</em> , ia juga memiliki klien <em>Geth yang</em> dimodifikasi untuk dapat melakukan transaksi pribadi. </p><br><p>  Tambahan penting juga layanan <em>kantong</em> , yang bertanggung jawab untuk penyimpanan, enkripsi dan distribusi transaksi pribadi di antara mereka sendiri.  Sekarang ada 2 layanan <em>enklave tersebut</em> : </p><br><ol><li>  <strong>Konstelasi</strong> - ditulis dalam Haskell, versi <em>kantong pertama</em> , tetapi sekarang tidak berkembang lagi, dan kemungkinan besar di masa depan itu akan ditinggalkan demi yang baru; </li><li>  <strong>Tessera</strong> - layanan baru, ditulis di <em>Jawa</em> , didukung oleh pengembang dari JP Morgan Chase, memiliki lebih banyak opsi untuk integrasi dengan database dan pengelolaan informasi sensitif (misalnya, ada opsi integrasi dengan <em>HashiCorp Vault</em> untuk mengelola rahasia). </li></ol><br><p>  Adapun transaksi, dari sudut pandang antarmuka <em>Ethereum</em> biasa <em>,</em> tidak banyak yang berubah (dan ini bagus).  Untuk mengirim transaksi pribadi, selain informasi biasa tentang transaksi, Anda juga harus menentukan parameter <strong>privateFor</strong> - ini adalah <strong>larik</strong> baris, dan baris ini adalah kunci publik dari simpul <em>kantong</em> .  Dengan menggunakan kunci ini, transaksi <em>payload</em> <em>dienkripsi</em> dan <em>payload</em> didistribusikan antara node <strong>Tessera</strong> di dalam blockchain. </p><br><p>  Untuk perkenalan yang lebih mendalam dengan <em>Quorum</em> , cara kerjanya, dan cara meningkatkan jaringan blockchain, Anda dapat menemukannya di situs web resmi (tautan ke dokumentasi, serta tautan ke tutorial tentang cara meluncurkan blockchain uji, saya akan tinggalkan di akhir artikel). </p><br><h1 id="razrabotka-java-prilozheniya">  Pengembangan Aplikasi Java </h1><br><p>  Sebagai contoh, saya akan menunjukkan API tenang kecil yang ditulis di <em>Java / Spring</em> , dengan <em>Gradle</em> sebagai alat manajemen membangun dan ketergantungan yang akan memuat kontrak pintar ke dalam blockchain, melakukan fungsi mengubah keadaan kontrak dan membaca keadaan dari kontrak pintar. </p><br><p>  Sebelum memulai pengembangan itu sendiri, saya harus mengklarifikasi sesuatu.  Terlepas dari kenyataan bahwa <em>Quorum</em> secara resmi memiliki 2 opsi transaksi, saya lebih suka membaginya menjadi 3 jenis: </p><br><ol><li>  Transaksi <em>publik</em> - transaksi sepenuhnya dapat dilihat oleh semua peserta jaringan (termasuk <em>muatan</em> ), simpul <em>kantong</em> tidak mengambil bagian dalam memproses atau menyimpan transaksi.  Transaksi publik dalam <em>Kuorum</em> tidak berbeda dengan transaksi dalam jaringan <em>Ethereum</em> ; </li><li>  Transaksi yang <em>diizinkan</em> - transaksi pada dasarnya bersifat pribadi, tetapi untuk beberapa peserta jaringan, yaitu di jaringan publik, kami memiliki informasi tentang transaksi dan status pelaksanaannya, tetapi alih-alih <em>payload</em> nyata di jaringan publik, kami hanya memiliki string hash 64-bit, yang merupakan oleh pengidentifikasi untuk <em>muatan</em> nyata dalam simpul <em>kantong</em> , simpul <em>kantong</em> itu sendiri bertanggung jawab untuk menandatangani, mengenkripsi, menyimpan dan mendistribusikan <em>muatan</em> antara pihak-pihak yang ditunjukkan untuk transaksi; </li><li>  Transaksi <em>pribadi</em> - berbeda dari yang <em>diizinkan</em> karena transaksi hanya tersedia untuk simpul yang membuat transaksi ini, peserta jaringan lain tidak dapat melihat transaksi <em>payload</em> . <br>  Saya akan menggunakan klasifikasi ini di seluruh artikel. </li></ol><br><p> Untuk memulai, saya akan menunjukkan kepada Anda seperti apa file build itu - <code>gradle.build</code> : </p><br><pre> <code class="plaintext hljs">plugins { id 'org.springframework.boot' version '2.1.6.RELEASE' id 'java' } apply plugin: 'io.spring.dependency-management' group = 'com.github' version = '1.0' sourceCompatibility = '1.8' configurations { compileOnly { extendsFrom annotationProcessor } } repositories { mavenCentral() } test { testLogging.showStandardStreams = true } dependencies { implementation 'org.springframework.boot:spring-boot-starter-webflux' implementation group: 'org.web3j', name: 'quorum', version: '4.0.6' implementation group: 'org.web3j', name: 'core', version: '4.1.0' implementation group: 'org.web3j', name: 'codegen', version: '4.1.0' compileOnly 'org.projectlombok:lombok' annotationProcessor 'org.projectlombok:lombok' annotationProcessor 'org.springframework.boot:spring-boot-configuration-processor' testImplementation 'org.springframework.boot:spring-boot-starter-test' testImplementation 'io.projectreactor:reactor-test' } task generateWrappers(type: JavaExec) { group 'Demo' description 'Generates wrappers for smart-contracts' classpath = sourceSets.main.runtimeClasspath main = 'com.github.quorum.utils.WrappersGenerator' }</code> </pre> <br><p>  Sedikit penjelasan: </p><br><ol><li>  <code>org.web3j.core</code> - ketergantungan untuk bekerja dengan transaksi di jaringan <em>Ethereum</em> dan transaksi publik di jaringan <em>Kuorum</em> </li><li>  <code>org.web3j.quorum</code> - ketergantungan untuk bekerja dengan transaksi pribadi di jaringan <em>Kuorum</em> </li><li>  <code>org.web3j.codegen</code> - ketergantungan untuk menghasilkan <code>org.web3j.codegen</code> untuk kontrak pintar <em>Solidity</em> </li><li>  <em>generateWrappers</em> - Gradle-task untuk menghasilkan pembungkus <em>Java</em> dari kontrak pintar <em>Solidity</em> </li></ol><br><p>  Selanjutnya, saya akan menunjukkan kepada Anda kode kontrak pintar yang akan digunakan dalam artikel ini: File <code>QuorumDemo.sol</code> : </p><br><pre> <code class="plaintext hljs">pragma solidity 0.5.0; /** * @dev Smart-Contract for demonstration purposes. */ contract QuorumDemo { string public user; /** * @dev Rewrite user name in storage. */ function writeUser(string calldata _user) public { user = _user; } }</code> </pre> <br><p>  Kontrak sengaja dibuat sederhana, tetapi cukup untuk keperluan artikel kami.  Jika Anda tahu <em>Solidity</em> , maka Anda dapat melewatkan penjelasan: </p><br><ul><li>  <code>string public user</code> - variabel publik tipe <em>string</em> dan nama <em>pengguna</em> .  Tidak seperti <em>Java</em> , <em>Solidity</em> secara otomatis menghasilkan <em>pengambil</em> untuk variabel publik, jadi Anda tidak perlu mengimplementasikannya secara manual. </li><li>  <code>function writeUser(...)</code> - fungsi mengubah nilai variabel, pada kenyataannya - <em>setter</em> . </li></ul><br><p>  Untuk membuat <code>Java-wrapper</code> dari kontrak pintar, Anda harus meletakkan file di folder <code>src/main/solidity/contracts</code> dengan nama apa pun, misalnya <code>QuorumDemo.sol</code> . <br>  Selanjutnya, jalankan Gradle-task <em>generateWrappers dengan</em> perintah: </p><br><pre> <code class="plaintext hljs">gradle generateWrappers</code> </pre> <br><p>  Setelah menyelesaikan tugas ini, <em>Java-wrapper</em> akan dibuat di <code>src/main/java/com/github/quorum/component/wrappers</code> , yang sudah dapat Anda gunakan dengan kode <em>Java</em> . </p><br><p>  Agar backend dapat menandatangani transaksi, kami harus dapat menerima transaksi <em>payload</em> sebelum kami mengirimkannya.  Untuk melakukan ini, akan menyenangkan untuk mendapatkannya langsung dari kelas <em>Java-wrapper</em> .  Di sini saya membuat 2 metode di dalam bungkusnya.  Metode pertama hanya mengembalikan <em>ABI</em> kontrak, yang dapat digunakan untuk mengunduh kontrak pintar baru.  Metode kedua adalah pembentukan transaksi untuk mengubah status kontrak pintar.  Berikut ini kode untuk metode ini: </p><br><pre> <code class="plaintext hljs">public static String getBinary() { return BINARY; } public static String getDataOnWriteUser(final String user) { final Function function = new Function( FUNC_WRITEUSER, Arrays.asList(new Utf8String(user)), Collections.emptyList() ); return FunctionEncoder.encode(function); }</code> </pre> <br><p>  Dengan memasukkannya ke dalam <em>pembungkus Java yang</em> dihasilkan, Anda dapat menerima <em>payload</em> untuk transaksi. </p><br><p>  Selanjutnya, kita memerlukan cara yang mudah untuk mengirim transaksi ke blockchain, lebih disukai dengan antarmuka yang sama untuk transaksi pribadi dan publik.  Oleh karena itu, saya membuat antarmuka manajer transaksi dan 2 implementasinya: </p><br><ol><li>  <code>TesseraTransactionManager</code> , untuk mengirim transaksi pribadi </li><li>  <code>GethTransactionManager</code> , untuk mengirim transaksi publik </li></ol><br><p>  Mari kita pisahkan mereka.  Kode <code>TesseraTransactionManager</code> : </p><br><pre> <code class="plaintext hljs">@Slf4j public class TesseraTransactionManager implements TransactionManager { private static final byte ATTEMPTS = 20; private static final int SLEEP_DURATION = 100; private final Quorum quorum; private final String fromAddress; private final QuorumTransactionManager quorumTxManager; private final TransactionReceiptProcessor txReceiptProcessor; public TesseraTransactionManager( Quorum quorum, Credentials credentials, String publicKey, List&lt;String&gt; privateFor, Tessera tessera ) { this.quorum = quorum; this.fromAddress = credentials.getAddress(); this.quorumTxManager = new QuorumTransactionManager(quorum, credentials, publicKey, privateFor, tessera); this.txReceiptProcessor = new PollingTransactionReceiptProcessor(quorum, SLEEP_DURATION, ATTEMPTS); } @Override public TransactionReceipt executeTransaction( final BigInteger gasPrice, final BigInteger gasLimit, final String to, final String data) { while (true) { try { final EthSendTransaction ethSendTx = sendTransaction(gasPrice, gasLimit, to, data); if (ethSendTx.hasError() &amp;&amp; NONCE_TOO_LOW_ERROR_MESSAGE.equals(ethSendTx.getError().getMessage())) { log.warn("[BLOCKCHAIN] try to re-send transaction cause error {}", ethSendTx.getError().getMessage()); continue; } return processResponse(ethSendTx); } catch (TransactionException ex) { log.error("[BLOCKCHAIN] exception while receiving TransactionReceipt from Quorum node", ex); throw new RuntimeException(ex); } catch (Exception ex) { log.error("[BLOCKCHAIN] exception while sending transaction to Quorum node", ex); throw new RuntimeException(ex); } } } private EthSendTransaction sendTransaction( final BigInteger gasPrice, final BigInteger gasLimit, final String to, final String data) throws IOException { final BigInteger nonce = getNonce(); final RawTransaction rawTransaction = RawTransaction.createTransaction(nonce, gasPrice, gasLimit, to, data); return this.quorumTxManager.signAndSend(rawTransaction); } private TransactionReceipt processResponse(final EthSendTransaction transactionResponse) throws IOException, TransactionException { if (transactionResponse.hasError()) { throw new RuntimeException( "[BLOCKCHAIN] error processing transaction request: " + transactionResponse.getError().getMessage() ); } final String transactionHash = transactionResponse.getTransactionHash(); return this.txReceiptProcessor.waitForTransactionReceipt(transactionHash); } private BigInteger getNonce() throws IOException { final EthGetTransactionCount ethGetTxCount = this.quorum.ethGetTransactionCount( this.fromAddress, DefaultBlockParameterName.PENDING).send(); return ethGetTxCount.getTransactionCount(); } }</code> </pre> <br><ul><li>  <code>TransactionReceipt executeTransaction(...)</code> - implementasi antarmuka, metode untuk melakukan transaksi di jaringan dan menangani kesalahan jika terjadi.  Mengembalikan objek dengan hasil transaksi; </li><li>  <code>EthSendTransaction sendTransaction(...)</code> - metode untuk menandatangani dan mengirim transaksi ke blockchain.  Mengembalikan objek dengan status transaksi dan hash-nya; </li><li>  <code>TransactionReceipt processResponse(...)</code> - metode yang menunggu transaksi untuk menyelesaikan dan mengembalikan <code>TransactionReceipt</code> setelah pelaksanaannya; </li><li>  <code>BigInteger getNonce()</code> - Mengembalikan "nonce" dari jaringan. </li></ul><br><p>  Dan kode <code>GethTransactionManager</code> : </p><br><pre> <code class="plaintext hljs">@Slf4j public class GethTransactionManager extends FastRawTransactionManager implements TransactionManager { private static final byte ATTEMPTS = 20; private static final int SLEEP_DURATION = 100; private final TransactionReceiptProcessor txReceiptProcessor; public GethTransactionManager(Web3j web3j, Credentials credentials) { this(web3j, credentials, new PollingTransactionReceiptProcessor(web3j, SLEEP_DURATION, ATTEMPTS)); } public GethTransactionManager(Web3j web3j, Credentials credentials, TransactionReceiptProcessor txReceiptProcessor) { super(web3j, credentials, txReceiptProcessor); this.txReceiptProcessor = txReceiptProcessor; } @Override public TransactionReceipt executeTransaction( final BigInteger gasPrice, final BigInteger gasLimit, final String to, final String data) { while (true) { try { final EthSendTransaction ethSendTx = sendTransaction(gasPrice, gasLimit, to, data, BigInteger.ZERO); if (ethSendTx != null &amp;&amp; ethSendTx.hasError() &amp;&amp; NONCE_TOO_LOW_ERROR_MESSAGE.equals(ethSendTx.getError().getMessage())) { log.warn("[BLOCKCHAIN] try to re-send transaction cause error: {}", ethSendTx.getError().getMessage()); continue; } return this.txReceiptProcessor.waitForTransactionReceipt(ethSendTx.getTransactionHash()); } catch (TransactionException ex) { log.error("[BLOCKCHAIN] exception while receiving TransactionReceipt from Quorum node", ex); throw new RuntimeException(ex); } catch (IOException ex) { log.error("[BLOCKCHAIN] exception while sending transaction to Quorum node", ex); throw new RuntimeException(ex); } } } @Override public EthSendTransaction sendTransaction( final BigInteger gasPrice, final BigInteger gasLimit, final String to, final String data, final BigInteger value ) throws IOException { return super.sendTransaction(gasPrice, gasLimit.add(BigInteger.valueOf(21_000L)), to, data, value); } }</code> </pre> <br><ul><li>  <code>TransactionReceipt executeTransaction(...)</code> - implementasi antarmuka, metode untuk melakukan transaksi di jaringan dan menangani kesalahan jika terjadi.  Mengembalikan objek dengan hasil transaksi; </li><li>  <code>EthSendTransaction sendTransaction(...)</code> adalah metode yang memanggil metode <code>EthSendTransaction sendTransaction(...)</code> untuk mengirim transaksi ke blockchain. </li></ul><br><p>  Handler untuk permintaan yang datang ke <em>API</em> : </p><br><pre> <code class="plaintext hljs">@Slf4j @Component public class RequestHandler { private final Web3j web3j; private final Quorum quorum; private final Tessera tessera; private final Credentials credentials; private final BlockchainConfig blockchainConfig; private String deployedContract; @Autowired public RequestHandler( @Qualifier("initWeb3j") Web3j web3j, Quorum quorum, Tessera tessera, Credentials credentials, BlockchainConfig blockchainConfig ) { this.web3j = web3j; this.quorum = quorum; this.tessera = tessera; this.credentials = credentials; this.blockchainConfig = blockchainConfig; } /** * Deploy new smart-contract. * * @param serverRequest * - {@link ServerRequest} object with request information * @return {@link ServerResponse} object with response data */ public Mono&lt;ServerResponse&gt; deployContract(final ServerRequest serverRequest) { return serverRequest .bodyToMono(APIRequest.class) .map(this::getTransactionManager) .map(this::deployContract) .flatMap(this::generateResponse); } private TransactionManager getTransactionManager(final APIRequest apiRequest) { log.info("[HANDLER] privateFor = {}", apiRequest.getPrivateFor()); TransactionManager txManager; if (isPrivate(apiRequest.getPrivateFor())) { if (apiRequest.getPrivateFor().size() == 0) { apiRequest.getPrivateFor().add(this.blockchainConfig.getTesseraPublicKey()); } txManager = new TesseraTransactionManager(this.quorum, this.credentials, this.blockchainConfig.getTesseraPublicKey(), apiRequest.getPrivateFor(), this.tessera); } else { txManager = new GethTransactionManager(this.web3j, this.credentials); } return txManager; } private boolean isPrivate(final List&lt;String&gt; limitedTo) { return limitedTo == null || limitedTo.size() == 0 || !limitedTo.get(0).equals("public"); } private APIResponse deployContract(final TransactionManager txManager) { log.info("[HANDLER] deploying new smart-contract"); final String data = QuorumDemo.getBinary(); final TransactionReceipt txReceipt = txManager.executeTransaction(GAS_PRICE, DEPLOY_GAS_LIMIT, null, data); final APIResponse apiResponse = APIResponse.newInstance(txReceipt); this.deployedContract = txReceipt.getContractAddress(); log.info("[HANDLER] contract has been successfully deployed. Result: {}", apiResponse.getMap()); return apiResponse; } private Mono&lt;ServerResponse&gt; generateResponse(final APIResponse apiResponse) { return ServerResponse .ok() .body(Mono.just(apiResponse.getMap()), Map.class); } /** * Send transaction on update user in smart-contract. * * @param serverRequest * - {@link ServerRequest} object with request information * @return {@link ServerResponse} object with response data */ public Mono&lt;ServerResponse&gt; updateUser(final ServerRequest serverRequest) { return serverRequest .bodyToMono(APIRequest.class) .map(this::sendTransaction) .flatMap(this::generateResponse); } private APIResponse sendTransaction(final APIRequest apiRequest) { final TransactionManager txManager = getTransactionManager(apiRequest); log.info("[HANDLER] sending new transaction"); final String data = QuorumDemo.getDataOnWriteUser(apiRequest.getUser()); final TransactionReceipt txReceipt = txManager.executeTransaction(GAS_PRICE, TX_GAS_LIMIT, this.deployedContract, data); final APIResponse apiResponse = APIResponse.newInstance(txReceipt); log.info("[HANDLER] transaction has been successfully executed. Result: {}", apiResponse.getMap()); return apiResponse; } /** * Read user from smart-contract. * * @param serverRequest * - {@link ServerRequest} object with request information * @return {@link ServerResponse} object with response data */ public Mono&lt;ServerResponse&gt; getUser(final ServerRequest serverRequest) { final APIResponse apiResponse = getUser(); return generateResponse(apiResponse); } private APIResponse getUser() { log.info("[HANDLER] reading user from smart-contract"); final QuorumDemo quorumDemo = QuorumDemo.load(this.deployedContract, this.web3j, this.credentials, new StaticGasProvider(GAS_PRICE, DEPLOY_GAS_LIMIT)); final String user = readUserFromSmartContract(quorumDemo); final APIResponse apiResponse = APIResponse.newInstance(user); log.info("[HANDLER] user: '{}'", user); return apiResponse; } private String readUserFromSmartContract(final QuorumDemo quorumDemo) { try { return quorumDemo.user().send().getValue(); } catch (Exception ex) { log.info("[HANDLER] exception while reading user from smart-contract: {}", ex); return null; } } }</code> </pre> <br><p>  Sekarang saya akan menjelaskan metode apa yang bertanggung jawab untuk apa. <br>  Metode <code>Mono&lt;ServerResponse&gt; deployContract(...)</code> - menjelaskan logika umum <code>Mono&lt;ServerResponse&gt; deployContract(...)</code> kontrak pintar, baik negeri maupun swasta. <br>  Metode <code>TransactionManager getTransactionManager(...)</code> - mengembalikan objek implementasi manajer transaksi tergantung pada jenis transaksi.  Untuk ini, parameter permintaan akan berisi parameter <strong>privateFor</strong> , yang merupakan larik string kunci publik <em>Tessera</em> . <br>  Metode <code>boolean isPrivate(...)</code> - mengembalikan "true" jika parameter <strong>privateFor</strong> kosong (transaksi <em>pribadi</em> ) atau memiliki daftar kunci publik (transaksi yang <em>diijinkan</em> ).  Mengembalikan "false" jika parameter <strong>privateFor</strong> tidak kosong, dan elemen array pertama sama dengan "publik". <br>  <code>APIResponse deployContract(...)</code> - mengirimkan transaksi deploy ke blockchain. <br>  Metode <code>Mono&lt;ServerResponse&gt; generateResponse(...)</code> - menghasilkan objek dengan respons ke klien. <br>  Metode <code>Mono&lt;ServerResponse&gt; updateUser(...)</code> - menjelaskan logika umum transaksi untuk mengubah status kontrak pintar. <br>  <code>APIResponse sendTransaction(...)</code> - mengirimkan transaksi perubahan status ke blockchain. <br>  <code>APIResponse getUser()</code> - menjelaskan logika umum untuk membaca informasi dari kontrak pintar dan mengembalikan respons kepada klien. <br>  Metode <code>String readUserFromSmartContract(...)</code> - membaca status dari kontrak pintar dan mengembalikan hasilnya. </p><br><p>  Kode aplikasi lengkap tersedia di repositori <em>Github</em> , tautan yang akan ada di akhir artikel ini. </p><br><h1 id="proverka">  Periksa </h1><br><p>  Untuk menguji semua 3 jenis transaksi, saya menulis kelas uji (kode ada di repositori <em>GitHub</em> ).  Untuk melakukan ini, saya menggunakan blockchain dengan 3 <em>kuorum</em> node (3 <em>geth</em> node + 3 node <em>Tessera</em> ).  3 node <em>kuorum</em> adalah node minimum yang diperlukan untuk memverifikasi semua jenis transaksi.  Ingatlah hal ini jika Anda ingin mencobanya sendiri. </p><br><h2 id="public-tranzakcii">  Transaksi publik </h2><br><p>  Untuk menjalankan uji kasus dengan transaksi publik, Anda harus menjalankan perintah berikut: </p><br><pre> <code class="plaintext hljs">gradle test --tests *.PublicTransactionsTests</code> </pre> <br><p>  Kasing uji ini akan mengirim 3 permintaan <em>API</em> .  Yang pertama adalah penyebaran kontrak pintar ke blockchain, yang kedua adalah perubahan status kontrak dan permintaan ketiga adalah pembacaan informasi dari kontrak pintar.  Sebagai hasil dari pengujian, Anda akan melihat kira-kira log berikut (alamat pada jaringan Anda akan berbeda, dan juga hash transaksi): </p><br><pre> <code class="plaintext hljs">[HANDLER] privateFor = [public] [HANDLER] deploying new smart-contract [HANDLER] contract has been successfully deployed. Result: {contract_address=0xf9425b94e459805da09950f5988071692d925097, transaction_hash=0x31bc179f8cd12c640d1663f3df51ce6da1fbc2875f2b724c3911108fcd19a5d0} [HANDLER] privateFor = [public] [HANDLER] sending new transaction [HANDLER] transaction has been successfully executed. Result: {contract_address=null, transaction_hash=0x33ba66d5deec33f3142bfa190a0d37d0ff07c2e66b06037f5b5ff9578154a3ff} [HANDLER] reading user from smart-contract [HANDLER] user: 'Public Test User'</code> </pre> <br><p>  Secara umum, log ini menunjukkan bahwa semua 3 operasi berhasil.  3 log pertama - milik permintaan untuk penyebaran kontrak pintar, 3 log berikutnya - milik transaksi, dan 2 log terakhir - untuk membaca informasi dari kontrak pintar. <br>  Fakta bahwa dalam hasil pemuatan kontrak kita melihat <strong>contract_address</strong> , tetapi dalam kasus transaksi sederhana - tidak, ini cukup normal, karena kedua kalinya kita tidak menggunakan kontrak, tetapi melakukan transaksi pada kontrak pintar yang ada. </p><br><p>  Sekarang mari kita periksa apa yang ditunjukkan oleh <em>Geth kepada kita</em> , jalankan perintah berikut untuk terhubung ke antarmuka <em>IPC</em> proses <em>Geth</em> klien: </p><br><pre> <code class="plaintext hljs">geth attach /path/to/ipc</code> </pre> <br><p>  Setelah kami “terbiasa dengan” prosesnya, Anda dapat meninjau sepenuhnya semua informasi yang diperlukan.  Mari kita lihat transaksi <code>TransactionReceipt</code> pada penerapan kontrak pintar baru dengan mengeksekusi perintah (hash transaksi harus disiapkan dan diambil dari log pengujian): </p><br><pre> <code class="plaintext hljs">web3.eth.getTransactionReceipt('0x31bc179f8cd12c640d1663f3df51ce6da1fbc2875f2b724c3911108fcd19a5d0');</code> </pre> <br><p>  Hasilnya, kita melihat yang berikut: </p><br><p><img src="https://habrastorage.org/webt/so/jm/yw/sojmyw_4gei16afdq47ypzmvtru.png"></p><br><p>  Kami tertarik pada parameter berikut: </p><br><ul><li>  "contractAddress" - jika bukan "null", maka kami memahami bahwa ini adalah transaksi untuk penyebaran kontrak cerdas; </li><li>  "status" - dalam hal ini, sama dengan "0x1" - yang berarti transaksi berhasil. </li></ul><br><p>  Dan mari kita lihat transaksi itu sendiri.  Dengan menjalankan perintah: </p><br><pre> <code class="plaintext hljs">web3.eth.getTransaction('0x31bc179f8cd12c640d1663f3df51ce6da1fbc2875f2b724c3911108fcd19a5d0');</code> </pre> <br><p>  Hasil: </p><br><p><img src="https://habrastorage.org/webt/ju/jq/86/jujq86cugnifanot96ypy_hvusm.png"></p><br><p>  Di sini kita tertarik pada parameter berikut: </p><br><ul><li>  "input" adalah transaksi <em>payload</em> ; </li><li>  "v" - secara umum, ini adalah parameter untuk <em>ECDSA</em> , algoritma tanda tangan digital, tetapi sekarang kami tertarik pada hal lain - arti dari variabel.  Ini penting karena dalam transaksi publik dan pribadi akan berbeda.  "0x1c" ("28" dalam sistem desimal) dan "0x1b" ("27" dalam sistem desimal) adalah tipikal untuk transaksi publik, dan "0x25" ("37" dalam sistem desimal) dan "0x26" ("38" dalam desimal sistem) - ini adalah kode transaksi pribadi. </li></ul><br><p>  Anda juga dapat memeriksa bahwa pada node lain informasinya tidak berbeda dari yang kita lihat sekarang. </p><br><p>  Sekarang Anda dapat melihat perubahan status transaksi dari kontrak pintar.  Jalankan perintah: </p><br><pre> <code class="plaintext hljs">web3.eth.getTransactionReceipt('0x33ba66d5deec33f3142bfa190a0d37d0ff07c2e66b06037f5b5ff9578154a3ff');</code> </pre> <br><p>  Hasil: </p><br><p><img src="https://habrastorage.org/webt/zz/8g/a-/zz8ga-le8lswmr7vkizq5tu_zog.png"></p><br><p>  Kami tertarik pada parameter berikut: </p><br><ul><li>  "ke" - kita melihat bahwa transaksi beralih ke kontrak pintar yang ditunggu-tunggu saja; </li><li>  "status" - sama dengan "0x1", yang berarti transaksi berhasil. </li></ul><br><p>  Transaksi: </p><br><p><img src="https://habrastorage.org/webt/t9/yh/xp/t9yhxp0-hzbkvylmous8p--ft2e.png"></p><br><p>  Tidak ada yang aneh, tetapi Anda dapat memeriksa informasi pada node lain, ini berguna. </p><br><h2 id="private-tranzakcii">  Transaksi Pribadi </h2><br><p>  Untuk menjalankan uji kasus dengan transaksi pribadi, Anda harus menjalankan perintah berikut: </p><br><pre> <code class="plaintext hljs">gradle test --tests *.PrivateTransactionsTests</code> </pre> <br><p>  Seperti dalam uji kasus dengan transaksi publik, uji kasus ini akan menggunakan kontrak pintar baru, melaksanakan transaksi perubahan negara dan membaca informasi dari perubahan dalam kontrak pintar. </p><br><p>  Akibatnya, program akan menulis log berikut: </p><br><pre> <code class="plaintext hljs">[HANDLER] privateFor = [] [HANDLER] deploying new smart-contract [HANDLER] contract has been successfully deployed. Result: {contract_address=0x3e2284d92842f781b83cc7e56fbb074ab15f9a90, transaction_hash=0x8fd619bd9a526f83e29d7b417551e174862f7503ef430eb45793509d05039595} [HANDLER] privateFor = [] [HANDLER] sending new transaction [HANDLER] transaction has been successfully executed. Result: {contract_address=null, transaction_hash=0x72a0458a7b313c8a1c18269ae160e140c6a6e41cb2fd087c64cf665b08a6aefb} [HANDLER] reading user from smart-contract [HANDLER] user: 'Private Test User'</code> </pre> <br><p>  Perubahan, dibandingkan dengan transaksi publik, adalah parameter <strong>privateFor</strong> - sekarang memiliki nilai array kosong. <br>  Mari kita periksa <code>TransactionReceipt</code> untuk transaksi.  Tim: </p><br><pre> <code class="plaintext hljs">web3.eth.getTransactionReceipt('0x8fd619bd9a526f83e29d7b417551e174862f7503ef430eb45793509d05039595');</code> </pre> <br><p>  Hasil: </p><br><p><img src="https://habrastorage.org/webt/qx/aj/1g/qxaj1gluf9gl-o-rwbwaa6-oww8.png"></p><br><p>  Dari perubahan tersebut, dibandingkan dengan transaksi publik, perlu dikatakan bahwa Anda tidak akan melihat jumlah gas yang dihabiskan untuk transaksi - <strong>gasUsed</strong> dan <strong>kumulatifGasUsed</strong> memiliki nilai "0". <br>  Sekarang mari kita lihat transaksi itu sendiri.  Jalankan perintah: </p><br><pre> <code class="plaintext hljs">web3.eth.getTransaction('0x8fd619bd9a526f83e29d7b417551e174862f7503ef430eb45793509d05039595');</code> </pre> <br><p>  Sebagai hasilnya, kita akan melihat ini: </p><br><p><img src="https://habrastorage.org/webt/of/zj/ud/ofzjuds-akmr-koc9ed9dasubnq.png"></p><br><p>  Apa yang perlu diperhatikan dalam transaksi ini: </p><br><ol><li>  Seperti yang saya sebutkan di awal artikel ini, alih-alih transaksi <em>payload</em> nyata, Anda akan melihat garis tetap 64 byte (128 karakter) di bidang <strong>input</strong> .  Baris ini adalah pengidentifikasi untuk data dalam repositori <em>Tessera</em> , Anda bisa mendapatkan data nyata berdasarkan permintaan ke <em>Tessera</em> . </li><li>  "v" - alih-alih kode "0x1c" atau "0x1b" seperti dalam transaksi publik, untuk transaksi pribadi Anda akan melihat "0x26" atau "0x25". </li></ol><br><p>  Sekarang mari kita periksa <code>TransactionReceipt</code> dan transaksi itu sendiri untuk mengubah status kontrak (Anda sudah tahu perintahnya).  Hasil: </p><br><p><img src="https://habrastorage.org/webt/of/zj/ud/ofzjuds-akmr-koc9ed9dasubnq.png"></p><br><p><img src="https://habrastorage.org/webt/cw/mp/vk/cwmpvk3hjzcnh51isapyhecpkf0.png"></p><br><p>  Pada prinsipnya, kami tidak akan mempelajari hal baru dari transaksi pribadi ini. </p><br><h2 id="permissioned-tranzakcii">  Transaksi yang Diijinkan </h2><br><p>  Karena ini juga merupakan transaksi pribadi, mereka hanya bersifat pribadi, bukan untuk 1 simpul, tetapi untuk beberapa node, hasil dari transaksi tersebut tidak akan berbeda dari transaksi pribadi.  Anda dapat membuat perbedaan jika Anda mencoba untuk mendapatkan informasi dari node yang ditentukan dalam <strong>privateFor</strong> dan dari node yang kunci publiknya tidak terdaftar di <strong>privateFor</strong> (Anda bisa mendapatkan informasi dari node pertama dan tidak bisa dari yang kedua). <br>  Untuk menjalankan kasus uji dengan transaksi pribadi untuk beberapa peserta jaringan (transaksi yang diizinkan), Anda perlu menjalankan perintah berikut: </p><br><pre> <code class="plaintext hljs">gradle test --tests *.PermissionTransactionsTests</code> </pre> <br><p>  Log <em>API Java</em> : </p><br><pre> <code class="plaintext hljs">[HANDLER] privateFor = [wQTHrl/eqa7TvOz9XJcazsp4ZuncfxHb8c1J1njIOGA=] [HANDLER] deploying new smart-contract [HANDLER] contract has been successfully deployed. Result: {contract_address=0xf1cc0ba22bd0d18fc9acb22dd57795a3f2fb4ebd, transaction_hash=0x585980bec88aa8a0fe5caffe6d6f24b82d3cd381fcf72fdd8e2102ce67799f01} [HANDLER] privateFor = [wQTHrl/eqa7TvOz9XJcazsp4ZuncfxHb8c1J1njIOGA=] [HANDLER] sending new transaction [HANDLER] transaction has been successfully executed. Result: {contract_address=null, transaction_hash=0x47edc0d00fa9447b2da9f5a78f44602f96145497238cb1ce1d879afb351a3cbe} [HANDLER] reading user from smart-contract [HANDLER] user: 'Permissioned Test User'</code> </pre> <br><p>  Hasil dalam klien <em>Geth</em> , pada penyebaran kontrak pintar baru, <code>TransactionReceipt</code> dan transaksi itu sendiri, masing-masing: </p><br><p><img src="https://habrastorage.org/webt/nk/cs/do/nkcsdozorvcuh7gv7kxspwovxmm.png"></p><br><p><img src="https://habrastorage.org/webt/bc/z5/1u/bcz51u6c28aussavjw7fdieayuq.png"></p><br><p>  Dan status mengubah transaksi, <code>TransactionReceipt</code> dan transaksi itu sendiri: </p><br><p><img src="https://habrastorage.org/webt/4f/al/lt/4falltfjniekypa5r38xu8j6tzo.png"></p><br><p><img src="https://habrastorage.org/webt/tq/-s/ta/tq-stauf7_6a00ts7qgkzif0p18.png"></p><br><h3 id="http-zaprosy">  Permintaan HTTP </h3><br><p>  Terlepas dari kenyataan bahwa kami melihat bagaimana transaksi publik berbeda dari yang pribadi dari sudut pandang klien <em>Geth</em> , ini tidak menunjukkan batasan nyata dalam memperoleh informasi.  Oleh karena itu, untuk menunjukkan kepada Anda bahwa sangat mungkin untuk membatasi jumlah node yang dapat membaca transaksi Anda, saya akan membuat beberapa permintaan menggunakan <em>CURL</em> selama 3 node untuk membaca informasi dari kontrak pintar (permintaan akan menyangkut transaksi <em>pribadi</em> dan <em>pengiriman</em> ). <br>  Permintaan HTTP akan memiliki 2 parameter di badan permintaan: </p><br><ol><li>  "endpoint" - secara langsung endpoint ke simpul <em>Kuorum</em> , Anda harus terhubung ke simpul tersebut. </li><li>  "contractAddress" adalah alamat kontrak dari mana data akan dibaca. </li></ol><br><p>  Dalam kasus saya, "endopint" akan memiliki satu host - <em>localhost</em> - tetapi port yang berbeda untuk 3 node <em>Kuorum</em> : 22000 (semua transaksi dilakukan dari node ini), 22001 (kunci publiknya ditentukan dalam transaksi yang diizinkan), 22002 (seharusnya tidak memiliki akses ke informasi). </p><br><p>  Mari kita mulai dengan transaksi <em>pribadi</em> (hanya node pada port 22000 yang dapat melihat informasi dalam kontrak pintar). </p><br><p>  Permintaan <em>CURL</em> pada simpul yang melakukan transaksi: </p><br><pre> <code class="plaintext hljs">curl -X POST \ http://127.0.0.1:8080/user \ -H 'Content-Type: application/json' \ -d '{ "endpoint": "http://127.0.0.1:22000", "contractAddress": "0x3e2284d92842f781b83cc7e56fbb074ab15f9a90" }'</code> </pre> <br><p>  Hasilnya, kami mendapat yang berikut: </p><br><pre> <code class="plaintext hljs">{"data":{"user":"Private Test User"}}</code> </pre> <br><p>  Ini berarti bahwa node memiliki kemampuan untuk melihat informasi dalam kontrak pintar. </p><br><p>  Sekarang mari kita lihat apa node pada port 22001 kembali kepada kita.  Permintaan <em>CURL</em> : </p><br><pre> <code class="plaintext hljs">curl -X POST \ http://127.0.0.1:8080/user \ -H 'Content-Type: application/json' \ -d '{ "endpoint": "http://127.0.0.1:22001", "contractAddress": "0x3e2284d92842f781b83cc7e56fbb074ab15f9a90" }'</code> </pre> <br><p>  Hebat!        : </p><br><pre> <code class="plaintext hljs">{"data":{"status_code":500,"description":"Something went wrong"}}</code> </pre> <br><p>     ,        - —    ! </p><br><p>     , 3- . <em>CURL</em> : </p><br><pre> <code class="plaintext hljs">curl -X POST \ http://127.0.0.1:8080/user \ -H 'Content-Type: application/json' \ -d '{ "endpoint": "http://127.0.0.1:22002", "contractAddress": "0x3e2284d92842f781b83cc7e56fbb074ab15f9a90" }'</code> </pre> <br><p>  Hebat! API  : </p><br><pre> <code class="plaintext hljs">{"data":{"status_code":500,"description":"Something went wrong"}}</code> </pre> <br><p>   ,        .     "permissioned" . </p><br><p>  <em>CURL</em>       "permissioned" -  ,    22000: </p><br><pre> <code class="plaintext hljs">curl -X POST \ http://127.0.0.1:8080/user \ -H 'Content-Type: application/json' \ -d '{ "endpoint": "http://127.0.0.1:22000", "contractAddress": "0xf1cc0ba22bd0d18fc9acb22dd57795a3f2fb4ebd" }'</code> </pre> <br><p> : </p><br><pre> <code class="plaintext hljs">{"data":{"user":"Permissioned Test User"}}</code> </pre> <br><p>  ,         ,   ,       . </p><br><p>       -   ,         -,       . <em>CURL</em> : </p><br><pre> <code class="plaintext hljs">curl -X POST \ http://127.0.0.1:8080/user \ -H 'Content-Type: application/json' \ -d '{ "endpoint": "http://127.0.0.1:22001", "contractAddress": "0xf1cc0ba22bd0d18fc9acb22dd57795a3f2fb4ebd" }'</code> </pre> <br><p>  Hebat!         : </p><br><pre> <code class="plaintext hljs">{"data":{"user":"Permissioned Test User"}}</code> </pre> <br><p>      ,          ,    . <em>CURL</em> : </p><br><pre> <code class="plaintext hljs">curl -X POST \ http://127.0.0.1:8080/user \ -H 'Content-Type: application/json' \ -d '{ "endpoint": "http://127.0.0.1:22002", "contractAddress": "0xf1cc0ba22bd0d18fc9acb22dd57795a3f2fb4ebd" }'</code> </pre> <br><p>  Hebat!         -.    . </p><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p>      ,    <em>Quorum blockchain</em>   Java .      ,    -     . </p><br><p>   : </p><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  <em>Quorum</em></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   <em>Quorum</em></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  <em>GitHub</em></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>Quorum</em>   <em>Slack</em></a> </li></ol><br><p>  Terima kasih atas perhatian anda! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id462549/">https://habr.com/ru/post/id462549/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id462539/index.html">Hindari trigonometri</a></li>
<li><a href="../id462541/index.html">Menggunakan Bersyarat di Musim Semi</a></li>
<li><a href="../id462543/index.html">Java meetup di Raiffeisenbank</a></li>
<li><a href="../id462545/index.html">Pemblokiran telegram, subnet / 16 Hetzner, pengalaman dengan ILV</a></li>
<li><a href="../id462547/index.html">SGX Malvar: bagaimana penjahat mengeksploitasi teknologi baru Intel untuk tujuan yang salah</a></li>
<li><a href="../id462551/index.html">Pertanyaan pengembang populer tentang pengujian</a></li>
<li><a href="../id462553/index.html">Sedikit tentang sederhana. Desain tes. Bagian 1</a></li>
<li><a href="../id462555/index.html">Diskusi: bagaimana jika bekerja tanpa cookie - kami memberi tahu Anda apa alternatifnya</a></li>
<li><a href="../id462563/index.html">Webinar "Bagaimana cara bertahan kepatuhan?" Pendekatan terbaik untuk memenuhi persyaratan peraturan ”</a></li>
<li><a href="../id462565/index.html">Cara menyiapkan data untuk Penambangan Proses SAP oleh Celonis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>