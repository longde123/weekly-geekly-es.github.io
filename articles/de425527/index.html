<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💃🏿 😿 📨 Listen bei Kotlin. Haskell Ansatz 🚢 🎅🏾 🧛🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Haskell ist eine voll funktionsfähige und äußerst prägnante Sprache. Jeder, der jemals versucht hat, Code in Haskell zu schreiben, merkt, wie prägnant...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Listen bei Kotlin. Haskell Ansatz</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425527/">  Haskell ist eine voll funktionsfähige und äußerst prägnante Sprache.  Jeder, der jemals versucht hat, Code in Haskell zu schreiben, merkt, wie prägnant und elegant es ist, als dasselbe in einer zwingenden Sprache zu schreiben.  Dasselbe in Java zu erreichen, ist meiner Meinung nach unmöglich, aber Kotlin ermöglicht es Ihnen, sich in diese Richtung zu bewegen und einen voll funktionsfähigen Stil auszuprobieren.  Wir können alle komplexen Funktionen, die wir benötigen, von der Startbasis der 3 bekanntesten Funktionen ableiten: Map, Filter, Reduce.  Außerdem habe ich ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository erstellt</a> , in dem Sie die Tests studieren und anzeigen können. <br><a name="habracut"></a><br>  Bevor ich anfange, möchte ich darauf hinweisen, dass es sich nicht lohnt, einen funktionalen Ansatz auf diese Weise zu implementieren, da der Code kritisch langsam ist und nicht in Produktionsanwendungen verwendet werden sollte.  Es gibt sicherlich Optionen zur Verbesserung, aber der Zweck des Artikels besteht nicht darin, diese Optionen offenzulegen, sondern einen alternativen Ansatz zum Schreiben von Code in Betracht zu ziehen.  In jedem Fall hilft Ihnen ein Verständnis dieses Ansatzes bei rekursiven Datenstrukturen, und Sie werden möglicherweise die Schönheit und Eleganz des Lesens des Codes und dessen Verständnis schätzen. <br><br><h3>  Grundfunktionen </h3><br>  Listen spielen eine sehr wichtige Rolle in der Sprache, und viele nützliche Funktionen sind für sie implementiert.  Schauen wir uns einige davon an und wie sie auf Kotlin implementiert werden können. <br><br><pre><code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">head</span></span> (x:_) = x head [] = badHead</code> </pre> <br>  Wenn die Liste Elemente enthält, geben wir das erste zurück, andernfalls geben wir einen Fehler zurück. <br>  Wir haben nicht die Möglichkeit, einen solchen Code zu schreiben, aber wenn Sie genau hinschauen, ist er im Allgemeinen dem der Vorlage sehr ähnlich.  Wir verwenden auch die Erweiterungsfunktion, um diese Methode später für Listen verwenden zu können und eine etwas präzisere Methode zu haben, um den Wert ohne die Klammern am Ende zu erhalten, wie bei einem Methodenaufruf. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> &lt;T&gt; List&lt;T&gt;.head: T <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isEmpty()) { <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> NoSuchElementException(<span class="hljs-string"><span class="hljs-string">"List is empty."</span></span>) <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] }</code> </pre><br>  Um die Rekursion bequem nutzen zu können, möchten wir die Liste auch in das erste Element + alle anderen aufteilen.  Versuchen wir, die Tail-Funktion dafür zu implementieren. <br><br>  So sieht es auf haskell aus: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">tail</span></span> (_:xs) = xs tail [] = errorEmptyList <span class="hljs-string"><span class="hljs-string">"tail"</span></span></code> </pre><br>  Leider bietet Kotlin keine solche Musterübereinstimmung, die Entwickler im gleichen Stil beschreiben können. Deshalb müssen wir hier ein wenig schreiben, wann. <br><br><pre> <code class="hljs xml">val <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>.tail: List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> get() = drop(1)</code> </pre><br>  Es ist etwas unehrlich, eine Funktion aus der Sprachbibliothek zu verwenden, aber andererseits müssten wir auf jeden Fall Code für diese Methode schreiben, daher wäre es besser, Methoden zu verwenden, die bereits gut funktionieren. <br><br>  Jetzt können wir die Liste in das erste Element + den Rest der Liste unterteilen.  Wir benötigen außerdem die Funktion, die Liste und ein Element zu verketten, die später aktiv für die Konvertierung und andere Operationen in der Liste verwendet werden. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: List&lt;T&gt; = ArrayList(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).also { it.add(x) }</code> </pre><br>  Jetzt können wir dem Element am Ende eine Liste hinzufügen, und unsere Implementierung der Kartenfunktion funktioniert und ist einsatzbereit.  Leider gibt es auch hier keine bequemere Möglichkeit, ein Objekt zur Liste <b>hinzuzufügen</b> . Daher verwenden wir die Methode <b>add</b> . <br><br>  Im Moment haben wir fast alles was wir brauchen.  Jetzt müssen wir nur noch die Randbedingung für das Verlassen der Rekursion beschreiben können.  Dazu verwenden wir die Standardmethode <b>isEmpty ()</b> .  Lassen Sie uns anhalten und sehen, was wir im Moment haben: <br><br><ul><li>  isEmpty () - Gibt es Elemente in der Liste? </li><li>  head - das erste Element der Liste </li><li>  Schwanz - eine Liste ohne das erste Element </li><li>  list + element - wir können die Liste mit einem Objekt verketten </li></ul><br>  Das ist alles, was wir brauchen, um alle Methoden zu bekommen, die wir brauchen. <br>  Für meinen Geschmack wäre es bequemer, den Listenlängenvergleich in <b>when-</b> Anweisungen zu verwenden.  Kotlin gibt uns bereits die <b>Größe</b> , um diese Listenlänge zu erhalten.  Angenommen, wir möchten es selbst implementieren.  Mit unserer Funktionalität wird es ganz einfach: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> &lt;T&gt; List&lt;T&gt;.size: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isEmpty()) { <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tail.size }</code> </pre><br><h3>  Anwendung von Grundfunktionen </h3><br>  Betrachten Sie das häufigste Beispiel.  Angenommen, wir haben eine Liste von ganzen Zahlen, und wir möchten sie zusammenfassen und dabei die Existenz von Zyklen vergessen.  Alles, was wir haben, sind die Methoden, die wir oben abgeleitet haben, und die Rekursion.  Dazu verwenden wir den gleichen Ansatz wie bei der Berechnung der Listengröße: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; xs.head + sum(xs.tail) }</code> </pre><br>  Die Idee ist sehr einfach: Wenn die Liste keine Elemente enthält, ist die Summe 0;  Andernfalls ist es die Summe des ersten Elements und ein rekursiver Aufruf der Summe für den Schwanz. <br><br>  Trotz der Tatsache, dass wir uns nicht um Geschwindigkeit und Optimierungen in diesem Code kümmern, können wir nicht anders, als uns an die Fähigkeiten der Sprache zur Verwendung der Schwanzrekursion zu erinnern.  Die Schwanzrekursion ist ein Sonderfall der Rekursion, bei dem ein rekursiver Aufruf die letzte Operation vor der Rückkehr von einer Funktion ist.  Diese Art der Rekursion ist bemerkenswert, da Sie garantiert den Code für die Iteration neu erstellen können.  Wie Sie wissen, besteht das Hauptproblem der Rekursion darin, dass während der Ausführung der Funktion der Aufrufstapel gespeichert werden muss, damit Sie bei Erreichen der Randbedingung zurückgehen und das Endergebnis neu berechnen können. <br><br>  Es scheint, dass die Funktion des von uns beschriebenen Betrags einfach so ist, da der letzte Aufruf <b>sum (xs.tail) ist</b> .  Dies ist jedoch nicht wahr.  Wenn Sie den Code etwas anders beschreiben, wird klar: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> head = xs.head <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tailSum = sum(xs.tail) head + tailSum } }</code> </pre><br>  Jetzt sehen wir, dass der letzte Aufruf tatsächlich die Summe des ersten Elements und des verbleibenden Teils des Schwanzes ist. <br><br>  Die gute Nachricht ist, dass die IDE Ihnen <b>mitteilt</b> , dass die Funktion dies nicht ist, wenn Sie einer Funktion den Modifikator <b>tailrec</b> hinzufügen.  Dies zu beheben ist jedoch ziemlich einfach.  Ein häufiger Trick, der eine Funktion korrigiert, besteht darin, eine Hilfsvariable zum Speichern der Ergebnisse zu verwenden.  Es sieht so aus: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">tailrec</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, acum: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; acum <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; sum(xs.tail, xs.head + acum) }</code> </pre><br>  Um die Summe der Elemente zu berechnen, reicht es aus, 0 als zweiten Parameter zu übergeben, und um sie vollständig idiomatisch zu machen, werden wir die Funktion ein wenig wiederholen und die Hauptberechnungen in der internen Funktion verbergen, ohne dass die Außenwelt Zugriff auf den Parameter hat, den sie enthält nicht benötigt. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>:<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">tailrec</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sumInner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, acum: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; acum <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; sumInner(xs.tail, xs.head + acum) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sumInner(xs, <span class="hljs-number"><span class="hljs-number">0</span></span>) }</code> </pre><br>  Mit diesem Wissen können Sie feststellen, dass die oben implementierte Größenfunktion nicht die erforderlichen Bedingungen für die Schwanzrekursion erfüllt. <br><br>  Jetzt können wir Map, Filter und Reduce mit Kotlin implementieren.  Später werden wir sehen, dass es ausreichte, nur letzteres zu realisieren, und der Rest sind im Allgemeinen Ableitungen davon.  Aber das Wichtigste zuerst. <br><br><h3>  Hauptfunktionen </h3><br><h4>  KARTE </h4><br>  Eine iterative Implementierung dieser Funktion umfasst das sequentielle Verschieben durch die Liste unter Verwendung der Konvertierungsfunktion und das Hinzufügen aller empfangenen Elemente zur neuen Sammlung.  Wir werden rekursive Aufrufe verwenden, bei denen die Randbedingung eine leere Liste ist.  Dann sieht die Implementierung folgendermaßen aus: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; R): List&lt;R&gt; = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; listOf() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; f(head) + tail.map(f) }</code> </pre><br>  Wenn die ursprüngliche Liste keine Elemente enthält, geben wir eine leere Liste zurück. Andernfalls wenden wir die Transformation auf das erste Element an und fügen am Ende einen rekursiven Aufruf für den Rest der Liste hinzu. <br><br>  Wir haben jedoch immer noch keine Funktion zum Verketten eines Elements und einer Liste.  Aber wir können es schon realisieren.  Zunächst leiten wir einen allgemeineren Fall der Verkettung eines Listenpaars ab und verwenden ihn anschließend, um dem Element eine weitere Liste hinzuzufügen. <br><br><pre> <code class="hljs xml">operator fun <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>.plus(xs: List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>): List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> = when (xs.size) { 0 -&gt; ArrayList(this) else -&gt; (this + xs.head) + xs.tail } operator fun <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> T.plus(xs: List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>): List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> = listOf(this) + xs</code> </pre><br><h4>  Filter </h4><br>  Die Implementierung wird der Karte sehr ähnlich sein.  Der einzige Unterschied besteht darin, dass Sie verstehen müssen, ob Sie das aktuelle Element zum Ergebnis hinzufügen müssen.  Dazu rufen wir das Lambda auf, das wir als Parameter erhalten haben.  Die Implementierung sieht folgendermaßen aus: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>): List&lt;T&gt; = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; listOf() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f(head)) head + tail.filter(f) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> tail.filter(f) }</code> </pre><br>  Wenn das aktuelle Element die Filterbedingung erfüllt, fügen Sie es rekursiv zum Ende der Liste hinzu. Andernfalls arbeiten wir weiterhin nur mit dem Ende der Liste. <br><br><h4>  REDUZIEREN </h4><br>  Die am schwierigsten zu verstehende und gleichzeitig leistungsstärkste Funktion (in der Funktionswelt wird sie als <b>Fold bezeichnet</b> ).  Meistens wird es verwendet, um eine Liste auf ein einzelnes Element zu reduzieren.  Sie haben einen bestimmten Startwert <b>s0</b> und es gibt auch eine Liste der Elemente <b>a []</b> und eine Funktion <b>f</b> , die einen neuen für den Startwert und das nächste Element der Liste zurückgibt.  <b>f (s0, a [0]) = s1</b> .  Und so gehen wir nacheinander die gesamte Liste der Elemente durch und erhalten eine Art Einzelwert am Ausgang.  Ein ziemlich häufiges Beispiel ist die Summierung von Array-Elementen.  In diesem Fall ist der Startwert 0 und die Funktion gibt die Summe zweier Elemente zurück: <b>f (s, a [i]) = s + a [i]</b> .  Überlegen Sie, wie wir diese Funktion rekursiv implementieren können. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">R</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, R)</span></span></span></span> -&gt; T): T = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; s <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; reduce(f(s, xs.head), xs.tail, f) }</code> </pre><br>  Im Prinzip ist die Implementierung genau die gleiche wie oben beschrieben.  Wenn die Liste keine Elemente enthält, geben wir den aktuellen Wert zurück. Andernfalls berechnen wir das neue erste Element und rufen erneut die Reduktionsfunktion für dieses Element und das Ende der Liste auf. <br><br>  Beachten Sie, dass wir auch Änderungen an dieser Funktion vornehmen können.  Übergeben Sie beispielsweise nicht den Startwert, sondern verwenden Sie dazu das erste Element der Liste.  Um zu verstehen, dass Reduzieren nicht dort endet, stellen Sie sich vor, wir verwenden eine andere Liste als Startwert.  In diesem Fall speichern wir jedes Mal bei der Iteration nicht einen Wert, sondern eine Liste, dank derer unsere Fähigkeiten erheblich zunehmen.  Versuchen wir beispielsweise, die Reduzierungsfunktion so anzuwenden, dass die ursprüngliche Liste am Ausgang angezeigt wird: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduceSame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> = reduce(listOf&lt;T&gt;(), xs) { ys, s -&gt; ys + s }</code> </pre><br>  Nun, ich denke, Sie vermuten, dass wir für eine alternative Implementierung der Karte den Filter reduzieren könnten.  Da wir gelernt haben, mit reduzieren genau dieselbe Liste zurückzugeben, müssen wir nur sehr wenige Änderungen vornehmen, um jedes Element konvertieren zu können.  Für Filter ist alles sehr ähnlich. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; R): List&lt;R&gt; = reduce(mutableListOf(), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { xs, s -&gt; (xs + f(s)).toMutableList() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>): List&lt;T&gt; = reduce(mutableListOf(), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { ys, s -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f(s)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span><span class="hljs-symbol"><span class="hljs-symbol">@reduce</span></span> (ys + s).toMutableList() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ys }</code> </pre><br>  Außerdem vergessen sie oft, dass wir Reduce auch nicht vom Anfang der Liste, sondern vom Ende verwenden können.  Natürlich können wir die Liste einfach erweitern und danach reduzieren, aber das ist nicht interessant.  Versuchen wir zu schreiben und zu verstehen, wie Reduzieren funktioniert, um die Liste in umgekehrter Reihenfolge zu reduzieren. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduceRight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">R</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, R)</span></span></span></span> -&gt; T): T = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; s <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; f(reduceRight(s, xs.tail, f), xs.head) }</code> </pre><br>  Wenn die Liste nicht leer ist, wenden wir die Funktion f auf das Ergebnis des Faltens des Endes der Liste und des Kopfes der Liste an.  Somit wird das erste Element zuletzt verarbeitet;  vorletzte - 2. und so weiter.  Für diese Option können Sie auch Änderungen hinzufügen, die das letzte Element der Liste als Startwert usw. verwenden. <br><br>  Wenn Sie mit Listen arbeiten, können Sie fast immer eine Kombination dieser drei Funktionen verwenden, um das gewünschte Ergebnis zu erzielen. <br><br>  Implementieren wir auch die <b>Zip-</b> Funktion, mit der wir zwei Listen kombinieren können. <br>  Am Eingang bekommen wir 2 Listen.  Und wir möchten eine Liste von Paaren zurückgeben, deren Länge dem Minimum der ursprünglichen Listen entspricht. <br><br>  Wie üblich müssen Sie darüber nachdenken, die Rekursion zu beenden und eine Funktion zu schreiben. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zip</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, ys: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">R</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: List&lt;Pair&lt;T, R&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.isEmpty() || ys.isEmpty()) { <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; listOf() <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; Pair(xs.head, ys.head) + zip(xs.tail, ys.tail) } }</code> </pre><br>  Sie können Ihre eigenen Änderungen hinzufügen, sodass Sie, anstatt ein Elementpaar zurückzugeben, eine bestimmte Funktion auf zwei Elemente anwenden können.  In Haskell heißt diese Funktion <b>zipWith</b> .  Und es wird mit der Funktionalität implementiert, die wir sehr einfach schreiben konnten: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R, C&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zipWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, ys: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">R</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, R)</span></span></span></span> -&gt; C): List&lt;C&gt; = zip(xs, ys).map { f(it.first, it.second) }</code> </pre><br>  Sehr oft treten bei Verwendung des funktionalen Ansatzes Probleme auf, wenn Sie Manipulationen durchführen müssen, die nicht auf Objekten in Listen, sondern auf Indizes basieren.  Zum Beispiel müssen wir alle geraden Elemente einer Liste summieren.  Sie können versuchen, dies zu erreichen, indem Sie Pair &lt;Int, Boolean&gt; als aktuellen Wert beibehalten und einen Wert hinzufügen, wenn flag == true, und die Flag-Negation jedes Mal für den nächsten Schritt übernehmen.  Dies sieht jedoch nicht besonders hübsch aus, und der Leser muss herausfinden, was Sie mit diesem Code ausdrücken möchten.  Kotlin hat unendlich viele Sequenzen und sie eignen sich hervorragend zur Lösung dieses Problems.  Wenn wir analysieren, was wir tun möchten, stellt sich heraus, dass wir alle Elemente mit ungeraden Indizes herausfiltern und die verbleibenden summieren möchten.  Und um Indizes erhalten zu können, reicht es aus, <b>zip</b> für die Liste und <b>Sequenz</b> [0,1,2 ..] aufzurufen. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sumWithEvenIndexes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> = zip(xs, generateSequence(<span class="hljs-number"><span class="hljs-number">0</span></span>) { it + <span class="hljs-number"><span class="hljs-number">1</span></span> }.take(xs.size).toList()) .filter { it.second % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> } .map { it.first } .sum()</code> </pre><br>  In der Kotlin-Standardbibliothek finden Sie die Zip-Funktion für das Sequenzpaar. <br><br>  Schauen wir uns nun eine einfache Aufgabe an, die mich dazu inspiriert hat, diesen Leitfaden zu schreiben, und wie seine Implementierung in einer zwingenden Sprache in Kotlin und ganz am Ende in Haskell aussieht. <br><br>  Es ist notwendig, den maximalen Betrag unter Paaren benachbarter Zahlen in einem Array von ganzen Zahlen zu berechnen.  Die Länge des Arrays ist größer als 1, und Sie müssen sich beim Summieren von Elementen keine Gedanken über ein Überlaufen machen. <br><br>  Imperativer Java-Ansatz: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Integer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">maxSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Integer&gt; array)</span></span></span><span class="hljs-function"> </span></span>{ Integer max = array.get(<span class="hljs-number"><span class="hljs-number">0</span></span>) + array.get(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; array.size(); i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array.get(i) + array.get(i-<span class="hljs-number"><span class="hljs-number">1</span></span>) &gt; max) max = array.get(i) + array.get(i-<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> max; }</code> </pre><br>  Ein funktionaler Ansatz für Kotlin unter Verwendung schriftlicher Funktionen (ich schlage vor, die Max-Funktion als Training selbst zu implementieren): <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">maxSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> = zipWith(xs, xs.tail, {a, b -&gt; a + b}).max()</code> </pre><br>  Haskell-Implementierung: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">maxSum</span></span> xs = maximum $ zipWith (+) xs (tail xs)</code> </pre><br>  Wie wir sehen können, ist das, was wir auf Kotlin implementiert haben (wir könnten übrigens Reduce verwenden, um dieses Problem zu lösen), dem sehr ähnlich, was in Haskell geschrieben werden kann. <br><br><h3>  Fazit </h3><br>  Zweifellos sollte dies nicht in der Entwicklung verwendet werden, da alles nicht optimal implementiert wurde, nur um einen funktionalen Ansatz zu demonstrieren.  Außerdem befindet sich fast alles, was geschrieben wurde, in der Kotlin-Standardbibliothek. Vielleicht verwenden Sie in Zukunft den funktionalen Stil, den Kotlin uns bietet, anstatt eine weitere for-Schleife zu schreiben. <br><br>  Das wahrscheinlich Schwierigste im funktionalen Stil ist, dass das Problem auf verschiedene Arten gelöst werden kann.  Das offensichtlichste kann in Zukunft umständlich und schwer zu verstehen sein, und das Schreiben des verständlichsten kann Zeit und ernsthafte Überlegungen erfordern.  Das einzige, was beim Mastering helfen kann, ist ständiges Üben und Trainieren. <br><br>  PS: Wie oben erwähnt, können Sie das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository</a> mit allen Beispielen im Artikel sehen.  Führen Sie die Tests durch und sehen Sie, wie es funktioniert! <br><br>  PPS: Sie können sich auch einen alternativen Ansatz ansehen, der ähnliche <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionen</a> implementiert. <br><br>  Und sehen Sie sich später <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://arrow-kt.io/ an</a> .  Meiner Meinung nach sollten Sie nicht sofort dorthin schauen, da alles ziemlich beängstigend aussieht, aber später, wenn Funktoren und Monaden Sie nicht erschrecken, sollten Sie es unbedingt studieren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425527/">https://habr.com/ru/post/de425527/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425511/index.html">Nicht offensichtliche Funktionen der Rotativa-Anwendung zum Generieren von PDF in der ASP.NET MVC-Anwendung</a></li>
<li><a href="../de425515/index.html">Apple blockiert die unabhängige Reparatur neuer MacBook-Modelle</a></li>
<li><a href="../de425517/index.html">Wie Yandex mithilfe von Radar und Satelliten eine globale Niederschlagsvorhersage erstellte</a></li>
<li><a href="../de425521/index.html">Geschützte Methoden in JavaScript ES5</a></li>
<li><a href="../de425525/index.html">Tim Berners-Lee geht auf den Kriegspfad: "Ein kleiner Schritt für das Web ..."</a></li>
<li><a href="../de425529/index.html">Sans Forgetica: Eine Schriftart, mit der Sie sich das Gelesene etwas besser merken können</a></li>
<li><a href="../de425531/index.html">Kühlung der Flüssigkeitsbremse. Systementwicklungsoptionen</a></li>
<li><a href="../de425533/index.html">So arbeiten Sie in der Cloud: von der Überprüfung der Zuverlässigkeit eines Rechenzentrums bis zur Verwaltung einer virtuellen Infrastruktur</a></li>
<li><a href="../de425537/index.html">Wie man Java, Js und Grafiken mit Kunst kombiniert oder wie ein interaktives Theater geschaffen wurde</a></li>
<li><a href="../de425541/index.html">So umgehen Sie schnell und ohne unnötige Chips die Unveränderlichkeit der Adresse des HTU21-Sensors</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>