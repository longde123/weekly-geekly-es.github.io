<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÉüèø üòø üì® Listen bei Kotlin. Haskell Ansatz üö¢ üéÖüèæ üßõüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Haskell ist eine voll funktionsf√§hige und √§u√üerst pr√§gnante Sprache. Jeder, der jemals versucht hat, Code in Haskell zu schreiben, merkt, wie pr√§gnant...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Listen bei Kotlin. Haskell Ansatz</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425527/">  Haskell ist eine voll funktionsf√§hige und √§u√üerst pr√§gnante Sprache.  Jeder, der jemals versucht hat, Code in Haskell zu schreiben, merkt, wie pr√§gnant und elegant es ist, als dasselbe in einer zwingenden Sprache zu schreiben.  Dasselbe in Java zu erreichen, ist meiner Meinung nach unm√∂glich, aber Kotlin erm√∂glicht es Ihnen, sich in diese Richtung zu bewegen und einen voll funktionsf√§higen Stil auszuprobieren.  Wir k√∂nnen alle komplexen Funktionen, die wir ben√∂tigen, von der Startbasis der 3 bekanntesten Funktionen ableiten: Map, Filter, Reduce.  Au√üerdem habe ich ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository erstellt</a> , in dem Sie die Tests studieren und anzeigen k√∂nnen. <br><a name="habracut"></a><br>  Bevor ich anfange, m√∂chte ich darauf hinweisen, dass es sich nicht lohnt, einen funktionalen Ansatz auf diese Weise zu implementieren, da der Code kritisch langsam ist und nicht in Produktionsanwendungen verwendet werden sollte.  Es gibt sicherlich Optionen zur Verbesserung, aber der Zweck des Artikels besteht nicht darin, diese Optionen offenzulegen, sondern einen alternativen Ansatz zum Schreiben von Code in Betracht zu ziehen.  In jedem Fall hilft Ihnen ein Verst√§ndnis dieses Ansatzes bei rekursiven Datenstrukturen, und Sie werden m√∂glicherweise die Sch√∂nheit und Eleganz des Lesens des Codes und dessen Verst√§ndnis sch√§tzen. <br><br><h3>  Grundfunktionen </h3><br>  Listen spielen eine sehr wichtige Rolle in der Sprache, und viele n√ºtzliche Funktionen sind f√ºr sie implementiert.  Schauen wir uns einige davon an und wie sie auf Kotlin implementiert werden k√∂nnen. <br><br><pre><code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">head</span></span> (x:_) = x head [] = badHead</code> </pre> <br>  Wenn die Liste Elemente enth√§lt, geben wir das erste zur√ºck, andernfalls geben wir einen Fehler zur√ºck. <br>  Wir haben nicht die M√∂glichkeit, einen solchen Code zu schreiben, aber wenn Sie genau hinschauen, ist er im Allgemeinen dem der Vorlage sehr √§hnlich.  Wir verwenden auch die Erweiterungsfunktion, um diese Methode sp√§ter f√ºr Listen verwenden zu k√∂nnen und eine etwas pr√§zisere Methode zu haben, um den Wert ohne die Klammern am Ende zu erhalten, wie bei einem Methodenaufruf. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> &lt;T&gt; List&lt;T&gt;.head: T <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isEmpty()) { <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> NoSuchElementException(<span class="hljs-string"><span class="hljs-string">"List is empty."</span></span>) <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] }</code> </pre><br>  Um die Rekursion bequem nutzen zu k√∂nnen, m√∂chten wir die Liste auch in das erste Element + alle anderen aufteilen.  Versuchen wir, die Tail-Funktion daf√ºr zu implementieren. <br><br>  So sieht es auf haskell aus: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">tail</span></span> (_:xs) = xs tail [] = errorEmptyList <span class="hljs-string"><span class="hljs-string">"tail"</span></span></code> </pre><br>  Leider bietet Kotlin keine solche Muster√ºbereinstimmung, die Entwickler im gleichen Stil beschreiben k√∂nnen. Deshalb m√ºssen wir hier ein wenig schreiben, wann. <br><br><pre> <code class="hljs xml">val <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>.tail: List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> get() = drop(1)</code> </pre><br>  Es ist etwas unehrlich, eine Funktion aus der Sprachbibliothek zu verwenden, aber andererseits m√ºssten wir auf jeden Fall Code f√ºr diese Methode schreiben, daher w√§re es besser, Methoden zu verwenden, die bereits gut funktionieren. <br><br>  Jetzt k√∂nnen wir die Liste in das erste Element + den Rest der Liste unterteilen.  Wir ben√∂tigen au√üerdem die Funktion, die Liste und ein Element zu verketten, die sp√§ter aktiv f√ºr die Konvertierung und andere Operationen in der Liste verwendet werden. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: List&lt;T&gt; = ArrayList(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).also { it.add(x) }</code> </pre><br>  Jetzt k√∂nnen wir dem Element am Ende eine Liste hinzuf√ºgen, und unsere Implementierung der Kartenfunktion funktioniert und ist einsatzbereit.  Leider gibt es auch hier keine bequemere M√∂glichkeit, ein Objekt zur Liste <b>hinzuzuf√ºgen</b> . Daher verwenden wir die Methode <b>add</b> . <br><br>  Im Moment haben wir fast alles was wir brauchen.  Jetzt m√ºssen wir nur noch die Randbedingung f√ºr das Verlassen der Rekursion beschreiben k√∂nnen.  Dazu verwenden wir die Standardmethode <b>isEmpty ()</b> .  Lassen Sie uns anhalten und sehen, was wir im Moment haben: <br><br><ul><li>  isEmpty () - Gibt es Elemente in der Liste? </li><li>  head - das erste Element der Liste </li><li>  Schwanz - eine Liste ohne das erste Element </li><li>  list + element - wir k√∂nnen die Liste mit einem Objekt verketten </li></ul><br>  Das ist alles, was wir brauchen, um alle Methoden zu bekommen, die wir brauchen. <br>  F√ºr meinen Geschmack w√§re es bequemer, den Listenl√§ngenvergleich in <b>when-</b> Anweisungen zu verwenden.  Kotlin gibt uns bereits die <b>Gr√∂√üe</b> , um diese Listenl√§nge zu erhalten.  Angenommen, wir m√∂chten es selbst implementieren.  Mit unserer Funktionalit√§t wird es ganz einfach: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> &lt;T&gt; List&lt;T&gt;.size: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isEmpty()) { <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tail.size }</code> </pre><br><h3>  Anwendung von Grundfunktionen </h3><br>  Betrachten Sie das h√§ufigste Beispiel.  Angenommen, wir haben eine Liste von ganzen Zahlen, und wir m√∂chten sie zusammenfassen und dabei die Existenz von Zyklen vergessen.  Alles, was wir haben, sind die Methoden, die wir oben abgeleitet haben, und die Rekursion.  Dazu verwenden wir den gleichen Ansatz wie bei der Berechnung der Listengr√∂√üe: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; xs.head + sum(xs.tail) }</code> </pre><br>  Die Idee ist sehr einfach: Wenn die Liste keine Elemente enth√§lt, ist die Summe 0;  Andernfalls ist es die Summe des ersten Elements und ein rekursiver Aufruf der Summe f√ºr den Schwanz. <br><br>  Trotz der Tatsache, dass wir uns nicht um Geschwindigkeit und Optimierungen in diesem Code k√ºmmern, k√∂nnen wir nicht anders, als uns an die F√§higkeiten der Sprache zur Verwendung der Schwanzrekursion zu erinnern.  Die Schwanzrekursion ist ein Sonderfall der Rekursion, bei dem ein rekursiver Aufruf die letzte Operation vor der R√ºckkehr von einer Funktion ist.  Diese Art der Rekursion ist bemerkenswert, da Sie garantiert den Code f√ºr die Iteration neu erstellen k√∂nnen.  Wie Sie wissen, besteht das Hauptproblem der Rekursion darin, dass w√§hrend der Ausf√ºhrung der Funktion der Aufrufstapel gespeichert werden muss, damit Sie bei Erreichen der Randbedingung zur√ºckgehen und das Endergebnis neu berechnen k√∂nnen. <br><br>  Es scheint, dass die Funktion des von uns beschriebenen Betrags einfach so ist, da der letzte Aufruf <b>sum (xs.tail) ist</b> .  Dies ist jedoch nicht wahr.  Wenn Sie den Code etwas anders beschreiben, wird klar: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> head = xs.head <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tailSum = sum(xs.tail) head + tailSum } }</code> </pre><br>  Jetzt sehen wir, dass der letzte Aufruf tats√§chlich die Summe des ersten Elements und des verbleibenden Teils des Schwanzes ist. <br><br>  Die gute Nachricht ist, dass die IDE Ihnen <b>mitteilt</b> , dass die Funktion dies nicht ist, wenn Sie einer Funktion den Modifikator <b>tailrec</b> hinzuf√ºgen.  Dies zu beheben ist jedoch ziemlich einfach.  Ein h√§ufiger Trick, der eine Funktion korrigiert, besteht darin, eine Hilfsvariable zum Speichern der Ergebnisse zu verwenden.  Es sieht so aus: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">tailrec</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, acum: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; acum <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; sum(xs.tail, xs.head + acum) }</code> </pre><br>  Um die Summe der Elemente zu berechnen, reicht es aus, 0 als zweiten Parameter zu √ºbergeben, und um sie vollst√§ndig idiomatisch zu machen, werden wir die Funktion ein wenig wiederholen und die Hauptberechnungen in der internen Funktion verbergen, ohne dass die Au√üenwelt Zugriff auf den Parameter hat, den sie enth√§lt nicht ben√∂tigt. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>:<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">tailrec</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sumInner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, acum: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; acum <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; sumInner(xs.tail, xs.head + acum) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sumInner(xs, <span class="hljs-number"><span class="hljs-number">0</span></span>) }</code> </pre><br>  Mit diesem Wissen k√∂nnen Sie feststellen, dass die oben implementierte Gr√∂√üenfunktion nicht die erforderlichen Bedingungen f√ºr die Schwanzrekursion erf√ºllt. <br><br>  Jetzt k√∂nnen wir Map, Filter und Reduce mit Kotlin implementieren.  Sp√§ter werden wir sehen, dass es ausreichte, nur letzteres zu realisieren, und der Rest sind im Allgemeinen Ableitungen davon.  Aber das Wichtigste zuerst. <br><br><h3>  Hauptfunktionen </h3><br><h4>  KARTE </h4><br>  Eine iterative Implementierung dieser Funktion umfasst das sequentielle Verschieben durch die Liste unter Verwendung der Konvertierungsfunktion und das Hinzuf√ºgen aller empfangenen Elemente zur neuen Sammlung.  Wir werden rekursive Aufrufe verwenden, bei denen die Randbedingung eine leere Liste ist.  Dann sieht die Implementierung folgenderma√üen aus: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; R): List&lt;R&gt; = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; listOf() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; f(head) + tail.map(f) }</code> </pre><br>  Wenn die urspr√ºngliche Liste keine Elemente enth√§lt, geben wir eine leere Liste zur√ºck. Andernfalls wenden wir die Transformation auf das erste Element an und f√ºgen am Ende einen rekursiven Aufruf f√ºr den Rest der Liste hinzu. <br><br>  Wir haben jedoch immer noch keine Funktion zum Verketten eines Elements und einer Liste.  Aber wir k√∂nnen es schon realisieren.  Zun√§chst leiten wir einen allgemeineren Fall der Verkettung eines Listenpaars ab und verwenden ihn anschlie√üend, um dem Element eine weitere Liste hinzuzuf√ºgen. <br><br><pre> <code class="hljs xml">operator fun <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>.plus(xs: List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>): List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> = when (xs.size) { 0 -&gt; ArrayList(this) else -&gt; (this + xs.head) + xs.tail } operator fun <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> T.plus(xs: List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>): List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> = listOf(this) + xs</code> </pre><br><h4>  Filter </h4><br>  Die Implementierung wird der Karte sehr √§hnlich sein.  Der einzige Unterschied besteht darin, dass Sie verstehen m√ºssen, ob Sie das aktuelle Element zum Ergebnis hinzuf√ºgen m√ºssen.  Dazu rufen wir das Lambda auf, das wir als Parameter erhalten haben.  Die Implementierung sieht folgenderma√üen aus: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>): List&lt;T&gt; = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; listOf() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f(head)) head + tail.filter(f) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> tail.filter(f) }</code> </pre><br>  Wenn das aktuelle Element die Filterbedingung erf√ºllt, f√ºgen Sie es rekursiv zum Ende der Liste hinzu. Andernfalls arbeiten wir weiterhin nur mit dem Ende der Liste. <br><br><h4>  REDUZIEREN </h4><br>  Die am schwierigsten zu verstehende und gleichzeitig leistungsst√§rkste Funktion (in der Funktionswelt wird sie als <b>Fold bezeichnet</b> ).  Meistens wird es verwendet, um eine Liste auf ein einzelnes Element zu reduzieren.  Sie haben einen bestimmten Startwert <b>s0</b> und es gibt auch eine Liste der Elemente <b>a []</b> und eine Funktion <b>f</b> , die einen neuen f√ºr den Startwert und das n√§chste Element der Liste zur√ºckgibt.  <b>f (s0, a [0]) = s1</b> .  Und so gehen wir nacheinander die gesamte Liste der Elemente durch und erhalten eine Art Einzelwert am Ausgang.  Ein ziemlich h√§ufiges Beispiel ist die Summierung von Array-Elementen.  In diesem Fall ist der Startwert 0 und die Funktion gibt die Summe zweier Elemente zur√ºck: <b>f (s, a [i]) = s + a [i]</b> .  √úberlegen Sie, wie wir diese Funktion rekursiv implementieren k√∂nnen. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">R</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, R)</span></span></span></span> -&gt; T): T = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; s <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; reduce(f(s, xs.head), xs.tail, f) }</code> </pre><br>  Im Prinzip ist die Implementierung genau die gleiche wie oben beschrieben.  Wenn die Liste keine Elemente enth√§lt, geben wir den aktuellen Wert zur√ºck. Andernfalls berechnen wir das neue erste Element und rufen erneut die Reduktionsfunktion f√ºr dieses Element und das Ende der Liste auf. <br><br>  Beachten Sie, dass wir auch √Ñnderungen an dieser Funktion vornehmen k√∂nnen.  √úbergeben Sie beispielsweise nicht den Startwert, sondern verwenden Sie dazu das erste Element der Liste.  Um zu verstehen, dass Reduzieren nicht dort endet, stellen Sie sich vor, wir verwenden eine andere Liste als Startwert.  In diesem Fall speichern wir jedes Mal bei der Iteration nicht einen Wert, sondern eine Liste, dank derer unsere F√§higkeiten erheblich zunehmen.  Versuchen wir beispielsweise, die Reduzierungsfunktion so anzuwenden, dass die urspr√ºngliche Liste am Ausgang angezeigt wird: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduceSame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> = reduce(listOf&lt;T&gt;(), xs) { ys, s -&gt; ys + s }</code> </pre><br>  Nun, ich denke, Sie vermuten, dass wir f√ºr eine alternative Implementierung der Karte den Filter reduzieren k√∂nnten.  Da wir gelernt haben, mit reduzieren genau dieselbe Liste zur√ºckzugeben, m√ºssen wir nur sehr wenige √Ñnderungen vornehmen, um jedes Element konvertieren zu k√∂nnen.  F√ºr Filter ist alles sehr √§hnlich. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; R): List&lt;R&gt; = reduce(mutableListOf(), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { xs, s -&gt; (xs + f(s)).toMutableList() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>): List&lt;T&gt; = reduce(mutableListOf(), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { ys, s -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f(s)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span><span class="hljs-symbol"><span class="hljs-symbol">@reduce</span></span> (ys + s).toMutableList() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ys }</code> </pre><br>  Au√üerdem vergessen sie oft, dass wir Reduce auch nicht vom Anfang der Liste, sondern vom Ende verwenden k√∂nnen.  Nat√ºrlich k√∂nnen wir die Liste einfach erweitern und danach reduzieren, aber das ist nicht interessant.  Versuchen wir zu schreiben und zu verstehen, wie Reduzieren funktioniert, um die Liste in umgekehrter Reihenfolge zu reduzieren. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduceRight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">R</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, R)</span></span></span></span> -&gt; T): T = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; s <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; f(reduceRight(s, xs.tail, f), xs.head) }</code> </pre><br>  Wenn die Liste nicht leer ist, wenden wir die Funktion f auf das Ergebnis des Faltens des Endes der Liste und des Kopfes der Liste an.  Somit wird das erste Element zuletzt verarbeitet;  vorletzte - 2. und so weiter.  F√ºr diese Option k√∂nnen Sie auch √Ñnderungen hinzuf√ºgen, die das letzte Element der Liste als Startwert usw. verwenden. <br><br>  Wenn Sie mit Listen arbeiten, k√∂nnen Sie fast immer eine Kombination dieser drei Funktionen verwenden, um das gew√ºnschte Ergebnis zu erzielen. <br><br>  Implementieren wir auch die <b>Zip-</b> Funktion, mit der wir zwei Listen kombinieren k√∂nnen. <br>  Am Eingang bekommen wir 2 Listen.  Und wir m√∂chten eine Liste von Paaren zur√ºckgeben, deren L√§nge dem Minimum der urspr√ºnglichen Listen entspricht. <br><br>  Wie √ºblich m√ºssen Sie dar√ºber nachdenken, die Rekursion zu beenden und eine Funktion zu schreiben. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zip</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, ys: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">R</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: List&lt;Pair&lt;T, R&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.isEmpty() || ys.isEmpty()) { <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; listOf() <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; Pair(xs.head, ys.head) + zip(xs.tail, ys.tail) } }</code> </pre><br>  Sie k√∂nnen Ihre eigenen √Ñnderungen hinzuf√ºgen, sodass Sie, anstatt ein Elementpaar zur√ºckzugeben, eine bestimmte Funktion auf zwei Elemente anwenden k√∂nnen.  In Haskell hei√üt diese Funktion <b>zipWith</b> .  Und es wird mit der Funktionalit√§t implementiert, die wir sehr einfach schreiben konnten: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R, C&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zipWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, ys: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">R</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, R)</span></span></span></span> -&gt; C): List&lt;C&gt; = zip(xs, ys).map { f(it.first, it.second) }</code> </pre><br>  Sehr oft treten bei Verwendung des funktionalen Ansatzes Probleme auf, wenn Sie Manipulationen durchf√ºhren m√ºssen, die nicht auf Objekten in Listen, sondern auf Indizes basieren.  Zum Beispiel m√ºssen wir alle geraden Elemente einer Liste summieren.  Sie k√∂nnen versuchen, dies zu erreichen, indem Sie Pair &lt;Int, Boolean&gt; als aktuellen Wert beibehalten und einen Wert hinzuf√ºgen, wenn flag == true, und die Flag-Negation jedes Mal f√ºr den n√§chsten Schritt √ºbernehmen.  Dies sieht jedoch nicht besonders h√ºbsch aus, und der Leser muss herausfinden, was Sie mit diesem Code ausdr√ºcken m√∂chten.  Kotlin hat unendlich viele Sequenzen und sie eignen sich hervorragend zur L√∂sung dieses Problems.  Wenn wir analysieren, was wir tun m√∂chten, stellt sich heraus, dass wir alle Elemente mit ungeraden Indizes herausfiltern und die verbleibenden summieren m√∂chten.  Und um Indizes erhalten zu k√∂nnen, reicht es aus, <b>zip</b> f√ºr die Liste und <b>Sequenz</b> [0,1,2 ..] aufzurufen. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sumWithEvenIndexes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> = zip(xs, generateSequence(<span class="hljs-number"><span class="hljs-number">0</span></span>) { it + <span class="hljs-number"><span class="hljs-number">1</span></span> }.take(xs.size).toList()) .filter { it.second % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> } .map { it.first } .sum()</code> </pre><br>  In der Kotlin-Standardbibliothek finden Sie die Zip-Funktion f√ºr das Sequenzpaar. <br><br>  Schauen wir uns nun eine einfache Aufgabe an, die mich dazu inspiriert hat, diesen Leitfaden zu schreiben, und wie seine Implementierung in einer zwingenden Sprache in Kotlin und ganz am Ende in Haskell aussieht. <br><br>  Es ist notwendig, den maximalen Betrag unter Paaren benachbarter Zahlen in einem Array von ganzen Zahlen zu berechnen.  Die L√§nge des Arrays ist gr√∂√üer als 1, und Sie m√ºssen sich beim Summieren von Elementen keine Gedanken √ºber ein √úberlaufen machen. <br><br>  Imperativer Java-Ansatz: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Integer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">maxSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Integer&gt; array)</span></span></span><span class="hljs-function"> </span></span>{ Integer max = array.get(<span class="hljs-number"><span class="hljs-number">0</span></span>) + array.get(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; array.size(); i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array.get(i) + array.get(i-<span class="hljs-number"><span class="hljs-number">1</span></span>) &gt; max) max = array.get(i) + array.get(i-<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> max; }</code> </pre><br>  Ein funktionaler Ansatz f√ºr Kotlin unter Verwendung schriftlicher Funktionen (ich schlage vor, die Max-Funktion als Training selbst zu implementieren): <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">maxSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> = zipWith(xs, xs.tail, {a, b -&gt; a + b}).max()</code> </pre><br>  Haskell-Implementierung: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">maxSum</span></span> xs = maximum $ zipWith (+) xs (tail xs)</code> </pre><br>  Wie wir sehen k√∂nnen, ist das, was wir auf Kotlin implementiert haben (wir k√∂nnten √ºbrigens Reduce verwenden, um dieses Problem zu l√∂sen), dem sehr √§hnlich, was in Haskell geschrieben werden kann. <br><br><h3>  Fazit </h3><br>  Zweifellos sollte dies nicht in der Entwicklung verwendet werden, da alles nicht optimal implementiert wurde, nur um einen funktionalen Ansatz zu demonstrieren.  Au√üerdem befindet sich fast alles, was geschrieben wurde, in der Kotlin-Standardbibliothek. Vielleicht verwenden Sie in Zukunft den funktionalen Stil, den Kotlin uns bietet, anstatt eine weitere for-Schleife zu schreiben. <br><br>  Das wahrscheinlich Schwierigste im funktionalen Stil ist, dass das Problem auf verschiedene Arten gel√∂st werden kann.  Das offensichtlichste kann in Zukunft umst√§ndlich und schwer zu verstehen sein, und das Schreiben des verst√§ndlichsten kann Zeit und ernsthafte √úberlegungen erfordern.  Das einzige, was beim Mastering helfen kann, ist st√§ndiges √úben und Trainieren. <br><br>  PS: Wie oben erw√§hnt, k√∂nnen Sie das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository</a> mit allen Beispielen im Artikel sehen.  F√ºhren Sie die Tests durch und sehen Sie, wie es funktioniert! <br><br>  PPS: Sie k√∂nnen sich auch einen alternativen Ansatz ansehen, der √§hnliche <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionen</a> implementiert. <br><br>  Und sehen Sie sich sp√§ter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://arrow-kt.io/ an</a> .  Meiner Meinung nach sollten Sie nicht sofort dorthin schauen, da alles ziemlich be√§ngstigend aussieht, aber sp√§ter, wenn Funktoren und Monaden Sie nicht erschrecken, sollten Sie es unbedingt studieren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425527/">https://habr.com/ru/post/de425527/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425511/index.html">Nicht offensichtliche Funktionen der Rotativa-Anwendung zum Generieren von PDF in der ASP.NET MVC-Anwendung</a></li>
<li><a href="../de425515/index.html">Apple blockiert die unabh√§ngige Reparatur neuer MacBook-Modelle</a></li>
<li><a href="../de425517/index.html">Wie Yandex mithilfe von Radar und Satelliten eine globale Niederschlagsvorhersage erstellte</a></li>
<li><a href="../de425521/index.html">Gesch√ºtzte Methoden in JavaScript ES5</a></li>
<li><a href="../de425525/index.html">Tim Berners-Lee geht auf den Kriegspfad: "Ein kleiner Schritt f√ºr das Web ..."</a></li>
<li><a href="../de425529/index.html">Sans Forgetica: Eine Schriftart, mit der Sie sich das Gelesene etwas besser merken k√∂nnen</a></li>
<li><a href="../de425531/index.html">K√ºhlung der Fl√ºssigkeitsbremse. Systementwicklungsoptionen</a></li>
<li><a href="../de425533/index.html">So arbeiten Sie in der Cloud: von der √úberpr√ºfung der Zuverl√§ssigkeit eines Rechenzentrums bis zur Verwaltung einer virtuellen Infrastruktur</a></li>
<li><a href="../de425537/index.html">Wie man Java, Js und Grafiken mit Kunst kombiniert oder wie ein interaktives Theater geschaffen wurde</a></li>
<li><a href="../de425541/index.html">So umgehen Sie schnell und ohne unn√∂tige Chips die Unver√§nderlichkeit der Adresse des HTU21-Sensors</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>