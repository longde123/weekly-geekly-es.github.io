<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ© ğŸ‘¢ ğŸ˜ƒ Pengujian fungsional keterampilan Yandex Alice di Node.js ğŸ™‹ğŸ¼ ğŸ§‘ğŸ¿â€ğŸ¤â€ğŸ§‘ğŸ½ ğŸŒ¶ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hampir setahun telah berlalu sejak kesempatan untuk menciptakan keterampilan Anda untuk Alice, asisten suara dari Yandex, muncul. Keterampilan baru ti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengujian fungsional keterampilan Yandex Alice di Node.js</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441978/"><p><img src="https://habrastorage.org/webt/lc/at/o1/lcato1rqb8swcdwuqtw1ahcgy5y.png" alt="Alice, luncurkan skill"></p><br><p>  Hampir setahun telah berlalu sejak kesempatan untuk menciptakan keterampilan Anda untuk Alice, asisten suara dari Yandex, muncul.  Keterampilan baru tiba setiap hari di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">katalog</a> , dan jumlah total mereka beberapa ratus.  Sayangnya, komunikasi dengan beberapa keterampilan secara halus "tidak bertambah."  Keterampilan baik loop pada frasa yang sama atau umumnya rusak dan tidak merespons. </p><br><p>  Pada artikel ini, saya akan mempertimbangkan menulis tes otomatis fungsional untuk keterampilan di Node.js.  Kehadiran tes semacam itu memungkinkan Anda untuk menciptakan keterampilan yang lebih baik dan memberi kepercayaan pada kinerja mereka. </p><a name="habracut"></a><br><h2 id="suschestvuyuschie-instrumenty-testirovaniya">  Alat Pengujian yang Ada </h2><br><p> Skill for Alice adalah server web yang dapat menanggapi permintaan POST dalam format tertentu.  Saat ini, ada beberapa alat di mana Anda dapat mentransfer URL skill dan memeriksa operasinya: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Konsol pengembang</a> resmi, tempat Anda dapat menguji keterampilan dengan teks dan melihat permintaan / jawaban </li><li>  Aimylogic <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Station</a> Simulator, mendukung suara </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dialog</a> proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">open-source.popstas.ru</a> untuk pengujian keterampilan lokal </li></ul><br><p>  Keunikan alat ini adalah mereka menawarkan beberapa UI untuk pengujian keterampilan manual.  Saya ingin dalam tradisi terbaik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">integrasi berkelanjutan</a> <br>  jalankan perintah di konsol, secara otomatis memeriksa semua skrip dan hanya kemudian mengunggah versi baru. </p><br><p>  Pada saat yang sama, saya tidak ingin mempelajari pengujian unit modul keterampilan individu.  Protokol permintaan / respons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dicatat dalam dokumentasi</a> , dan pada tingkat ini lebih baik untuk menguji.  Kemudian, bahkan setelah sepenuhnya menulis ulang arsitektur internal, Anda tidak perlu mengubah tes.  Intinya, ini adalah tes <em>fungsional</em> . </p><br><p>  Saya tidak menemukan perpustakaan yang selesai untuk Node.js untuk tugas seperti itu, jadi kami akan menulis sendiri :) </p><br><h2 id="navyk-dlya-testov">  Keterampilan tes </h2><br><p>  Ambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh keterampilan resmi</a> dari repositori Yandex di GitHub.  Ini adalah keterampilan "Parrot", yang hanya mengulangi semua yang dikatakan pengguna.  Dibangun berdasarkan kerangka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mikro</a> dan hanya berisi beberapa baris kode: </p><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// server.js const micro = require('micro'); const {json} = micro; module.exports = micro(async req =&gt; { const {request, session, version} = await json(req); return { version, session, response: { text: request.original_utterance || 'Hello!', end_session: false, }, }; });</span></span></code> </pre> <br><p>  Pada panggilan pertama, skill akan menerima pesan kosong dari pengguna (original_utterance) dan menjawab <code>"Hello!"</code>  .  Dalam kasus lain, itu hanya menyalin pesan pengguna ke bidang <code>response.text</code> . </p><br><p>  Saya membungkus kode contoh GitHub asli dalam fungsi <code>micro()</code> sehingga ekspor mengembalikan server http, yang akan kami gunakan dalam pengujian. </p><br><h2 id="test-plan">  Rencana uji </h2><br><p>  Jadi, untuk mencakup keterampilan seperti itu dengan tes, Anda perlu yang berikut: </p><br><ol><li>  Naikkan server dengan keahlian di port lokal </li><li>  Periksa dua kasus: <br><ul><li>  Pengguna memasuki skill, skill harus menjawab "Halo!" </li><li>  Pengguna mengirim pesan ke skill, skill harus merespons dengan pesan yang sama </li></ul></li><li>  Hentikan server dengan keterampilan dan tampilkan laporan </li></ol><br><p>  Dengan mengotomatiskan pemeriksaan ini, Anda dapat menjalankannya sebelum setiap komit dan memastikan tidak ada yang rusak. </p><br><p>  Kami akan menulis kode tes sesuai rencana, menggunakan sintaks untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">moka</a> .  Misalkan kita sudah memiliki beberapa kelas <code>User</code> yang dapat melakukan semua yang kita butuhkan: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// test.js const assert = require('assert'); before(done =&gt; { //    server.listen(PORT, done); }); it('should get hello on enter', async () =&gt; { //     const user = new User(`http://localhost:${PORT}`); //       const response = await user.enter(); //    assert.equal(response.text, 'Hello!'); }); after(done =&gt; { //   server.close(done); });</span></span></code> </pre> <br><p>  Masih menulis kelas <code>User</code> dan dimungkinkan untuk menjalankan tes. </p><br><h2 id="virtualnyy-polzovatel">  Pengguna virtual </h2><br><p>  Hal utama yang harus dapat dilakukan oleh pengguna tes adalah mengirim permintaan POST ke url keterampilan dengan data dalam format yang diinginkan.  Format permintaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dijelaskan dalam dokumentasi</a> .  Sekarang kita tidak perlu semua bidang, jadi saya hanya meninggalkan yang diperlukan agar tidak mengembang kode contoh.  Kelas <code>User</code> dengan komentar: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// user.js const fetch = require('node-fetch'); module.exports = class User { /** *  * @param {String} webhookUrl */ constructor(webhookUrl) { this._webhookUrl = webhookUrl; } /** *     */ async enter() { const headers = { 'Accept': 'application/json', 'Content-Type': 'application/json' }; //    ,  -   const body = this._buildRequest(''); const response = await fetch(this._webhookUrl, { method: 'post', headers, body: JSON.stringify(body), }); const json = await response.json(); return json.response; } /** *        * @param {String} message */ _buildRequest(message) { return { request: { command: message, original_utterance: message, type: 'SimpleUtterance', }, session: { new: true, user_id: 'user-1', session_id: 'session-1' }, version: '1.0' } } };</span></span></code> </pre> <br><h2 id="zapusk">  Luncurkan </h2><br><p>  Untuk memulai, masih mengimpor kelas pengguna dan server ke file uji, dan juga mengatur nilai port tempat server akan naik: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// test.js ... const server = require('./server'); const User = require('./user'); const PORT = 3456; ...</span></span></code> </pre> <br><p>  Instal semua dependensi yang diperlukan: </p><br><pre> <code class="bash hljs">npm install micro node-fetch mocha</code> </pre> <br><p>  Dan jalankan tes: </p><br><pre> <code class="bash hljs">$ mocha test.js âœ“ should get hello on enter 1 passing (34ms)</code> </pre> <br><p>  Semua baik-baik saja, tes telah berlalu! </p><br><p>  Tetapi sebelum melanjutkan, Anda perlu memastikan bahwa tes benar-benar berfungsi.  Untuk melakukan ini, ganti keterampilan respons "Halo!"  untuk "halo!"  dan jalankan lagi: </p><br><pre> <code class="bash hljs">$ mocha test.js 0 passing (487ms) 1 failing 1) should get hello on enter: AssertionError [ERR_ASSERTION]: <span class="hljs-string"><span class="hljs-string">'!'</span></span> == <span class="hljs-string"><span class="hljs-string">'Hello!'</span></span> + expected - actual -! +Hello!</code> </pre> <br><p>  Tes menunjukkan kesalahan - sebagaimana mestinya. <br>  Sekarang, tentu saja, kami menganggap kasus pertama yang akan dibahas. </p><br><h2 id="uchim-polzovatelya-obschatsya">  Kami mengajarkan pengguna untuk berkomunikasi </h2><br><p>  Kasus kedua tetap ketika pengguna mengirim pesan ke skill dan harus menerima pesan yang sama kembali.  Agar pengguna dapat "berkomunikasi", saya menambahkan metode <code>say(message)</code> ke kelas <code>User</code> .  Saya juga melakukan sedikit refactoring: Saya membuat mengirim permintaan-http ke metode terpisah dan menggunakannya di dalam <code>enter()</code> dan <code>say(message)</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// user.js const fetch = require('node-fetch'); module.exports = class User { /** *  * @param {String} webhookUrl */ constructor(webhookUrl) { this._webhookUrl = webhookUrl; } /** *     */ async enter() { //    ,  -   const body = this._buildRequest(''); return this._sendRequest(body); } /** *     * @param {String} message */ async say(message) { const body = this._buildRequest(message); return this._sendRequest(body); } /** *  http- * @param {Object} body   */ async _sendRequest(body) { const headers = { 'Accept': 'application/json', 'Content-Type': 'application/json' }; const response = await fetch(this._webhookUrl, { method: 'post', headers, body: JSON.stringify(body), }); const json = await response.json(); return json.response; } // ... };</span></span></code> </pre> <br><p>  Kode uji untuk kasus kedua terlihat seperti ini: </p><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'should reply the same message'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-comment"><span class="hljs-comment">//   const user = new User(`http://localhost:${PORT}`); //    await user.enter(); //   const response = await user.say('  ?'); //    assert.equal(response.text, '  ?'); });</span></span></code> </pre><br><p>  Kami mulai lagi, dan kami melihat bahwa kedua tes telah lulus: </p><br><pre> <code class="bash hljs">$ mocha test.js âœ“ should get hello on enter âœ“ should reply the same message 2 passing (37ms)</code> </pre> <br><h2 id="dalneyshie-shagi">  Langkah selanjutnya </h2><br><p>  Dengan cara yang sama, Anda bisa menambahkan skrip yang lebih kompleks ke dalam ketrampilan, yang meliputi dengan tes.  Ini akan memastikan bahwa perubahan baru tidak rusak lama. </p><br><p>  Infrastruktur pengujian yang dibuat juga dapat ditingkatkan: </p><br><ul><li>  modifikasi kelas <code>User</code> sehingga bidang yang tersisa dalam permintaan dapat diubah (misalnya, centang kotak bahwa pengguna tidak memiliki layar) </li><li>  menghubungkan cakupan kode (mis. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">nyc</a> ) </li><li>  menggantung semua cek pada kait pre-commit / pre-push (mis. menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">husky</a> ) </li></ul><br><p>  Saya memiliki beberapa keterampilan, jadi saya menempatkan kelas pengguna tes dalam paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alice-tester yang</a> terpisah, mungkin seseorang akan berguna. </p><br><p>  Saya juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memposting</a> kode contoh lengkap dari artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di GitHub</a> .  Anda dapat mengkloning repositori dan bereksperimen. </p><br><p>  Terima kasih atas perhatian anda! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id441978/">https://habr.com/ru/post/id441978/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id441968/index.html">Pengembangan cabang produk baru: cara menyingkirkan tidak praktis dan tetap bermanfaat</a></li>
<li><a href="../id441970/index.html">Analisis FinFisher Butkit</a></li>
<li><a href="../id441972/index.html">Invidious - frontend YouTube alternatif</a></li>
<li><a href="../id441974/index.html">Jalan sejarawan dari HR ke programmer Java: sedikit keberuntungan dan ketekunan</a></li>
<li><a href="../id441976/index.html">Dengan Anda FizTech.Science: kami mencari parameter tersembunyi dan terjun ke dunia kuantum yang luar biasa</a></li>
<li><a href="../id441980/index.html">Para ilmuwan telah mengidentifikasi kekurangan dari antarmuka Pembaruan Windows, yang sebagian dirancang untuk "pengguna bodoh"</a></li>
<li><a href="../id441982/index.html">Berperahu pesiar - itu bisa murah</a></li>
<li><a href="../id441984/index.html">Memprogram mikrokontroler ESP8266 / ESP32 dengan menulis file konfigurasi YAML</a></li>
<li><a href="../id441986/index.html">freetype 2 dan opengl menulis teks</a></li>
<li><a href="../id441988/index.html">Kamera 2019: berdiri sendiri, cerdas, mandiri</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>