<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçüè≠ ü•§ üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø Toda la verdad sobre RTOS. Art√≠culo 13. Estructuras de datos de tareas y llamadas de API no compatibles üë¢ üì´ üóæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este art√≠culo de la tercera y √∫ltima tarea, analizar√© las estructuras de datos de Nucleus SE y describir√© las llamadas a la API RTOS que no se impl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toda la verdad sobre RTOS. Art√≠culo 13. Estructuras de datos de tareas y llamadas de API no compatibles</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425353/"><img src="https://habrastorage.org/webt/a2/hi/au/a2hiaum17nhh6_ibldqgahpgaxo.jpeg"><br><br>  En este art√≠culo de la tercera y √∫ltima tarea, analizar√© las estructuras de datos de Nucleus SE y describir√© las llamadas a la API RTOS que no se implementan en Nucleus SE, as√≠ como otros problemas de compatibilidad. <br><a name="habracut"></a><br>  Art√≠culos anteriores de la serie: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Servicios para trabajar con tareas.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tareas: configuraci√≥n e introducci√≥n a la API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Programador: funciones avanzadas y preservaci√≥n del contexto</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Programador: implementaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nucleus SE: dise√±o interno y despliegue</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">N√∫cleo SE: Introducci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Otros servicios RTOS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Interacci√≥n de tareas y sincronizaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tareas, cambio de contexto e interrupciones</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tareas y planificaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RTOS: estructura y modo en tiempo real</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RTOS: introducci√≥n.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><br></a> <br><h2>  Estructuras de datos </h2><br>  Las tareas utilizan varias estructuras de datos (tanto en RAM como en ROM), que, como otros objetos de Nucleus SE, son un conjunto de tablas cuyo tama√±o corresponde al n√∫mero de tareas y par√°metros seleccionados. <br><br>  Recomiendo encarecidamente que el c√≥digo de la aplicaci√≥n acceda a estas estructuras de datos utilizando funciones API, y no directamente.  Esto evita efectos secundarios no deseados, incompatibilidad con futuras versiones de Nucleus SE y tambi√©n simplifica la transferencia de la aplicaci√≥n a Nucleus RTOS.  Para una mejor comprensi√≥n del funcionamiento del c√≥digo de llamada de servicio y del proceso de depuraci√≥n, a continuaci√≥n se proporciona una descripci√≥n detallada de las estructuras de datos. <br><br><h3>  Estructuras de datos del kernel alojadas en RAM </h3><br>  Estas estructuras de datos incluyen: <br><br>  <b>NUSE_Task_Context [] []</b> : una matriz bidimensional de tipo <b>ADDR</b> , tiene una fila para cada tarea.  El n√∫mero de columnas depende de la arquitectura del controlador y est√° determinado por el s√≠mbolo <b>NUSE_REGISTERS</b> , que se define en <b>nuse_types.h</b> .  El programador utiliza esta matriz para guardar el contexto de cada tarea y se ha descrito en detalle en la secci√≥n "Guardar el contexto" del art√≠culo n.¬∫ 10.  No se crea si se usa el planificador RTC. <br>  <b>NUSE_Task_Signal_Flags []</b> : una matriz de tipo <b>U8</b> , creada si las se√±ales est√°n habilitadas, y contiene 8 banderas de se√±al para cada tarea.  Las se√±ales ser√°n discutidas en uno de los siguientes art√≠culos. <br>  <b>NUSE_Task_Timeout_Counter []</b> es una matriz de tipo <b>U16</b> , consiste en restar contadores para cada tarea y se crea si la llamada a la API <b>NUSE_Task_Sleep () est√°</b> activada. <br>  <b>NUSE_Task_Status []</b> : una matriz de tipo U8, contiene los estados de cada tarea: <b>NUSE_READY</b> o suspender estados.  Creado solo si la suspensi√≥n de la tarea est√° activada. <br>  <b>NUSE_Task_Blocking_Return []</b> : una matriz de tipo U8, creada si se activa el bloqueo de llamadas API.  Contiene un c√≥digo de retorno que se usar√° despu√©s de bloquear las llamadas a la API.  Por lo general, contiene <b>NUSE_SUCCESS</b> o c√≥digo que indica que el objeto se ha restablecido (por ejemplo, <b>NUSE_MAILBOX_WAS_RESET</b> ). <br>  <b>NUSE_Task_Schedule_Count []</b> : una matriz de tipo <b>U16</b> , contiene un contador para cada tarea y se crea solo si se ha activado el conteo del planificador. <br><br>  <b>NUSE_Task_Context [] [] se</b> inicializa principalmente con ceros, excepto las entradas correspondientes al registro de estado (registro de estado, SR), contador de programa (contador de programa, PC) y puntero de pila (puntero de pila, SP), a los que se asignan valores iniciales (consulte "Datos en ROM "a continuaci√≥n), y todas las dem√°s estructuras de datos <b>NUSE_Init_Task () se</b> asignan ceros al iniciar Nucleus SE.  Uno de los siguientes art√≠culos contendr√° una lista completa de los procedimientos de inicio de Nucleus SE con su descripci√≥n. <br><br>  Las siguientes son definiciones de las estructuras de datos contenidas en el archivo nuse_init.c. <br><br><img src="https://habrastorage.org/webt/fj/hr/le/fjhrlehn7si_hkt5lnnyk6dosno.jpeg"><br><br><h3>  Datos de usuario RAM </h3><br>  El usuario debe definir una pila para cada tarea (si no se usa el planificador RTC).  Deben ser matrices <b>ADDR</b> , que generalmente se definen en <b>nuse_config.c</b> .  Las direcciones y los tama√±os de pila deben colocarse en las entradas de tarea <b>NUSE_Task_Stack_Base []</b> y <b>NUSE_Task_Stack_Size [],</b> respectivamente (ver Datos en ROM). <br><br><h3>  Datos ROM </h3><br>  Una ROM almacena de una a cuatro estructuras de datos relacionadas con tareas.  La cantidad exacta depende de los par√°metros seleccionados: <br><br>  <b>NUSE_Task_Start_Address []</b> es una matriz de tipo <b>ADDR</b> que tiene una entrada para cada tarea, que es un puntero al punto de entrada de c√≥digo para la tarea. <br>  <b>NUSE_Task_Stack_Base []</b> es una matriz de tipo <b>ADDR</b> que tiene una entrada para cada tarea, que es un puntero a la direcci√≥n base de la pila para la tarea.  Esta matriz se crea si se utiliza cualquier planificador que no sea RTC. <br>  <b>NUSE_Task_Stack_Size []</b> es una matriz de tipo <b>U16</b> que tiene una entrada para cada tarea, que muestra el tama√±o de la pila para la tarea (en palabras).  Esta matriz se crea si se utiliza cualquier planificador que no sea RTC. <br>  <b>NUSE_Task_Initial_State []</b> es una matriz de tipo <b>U8</b> , que tiene una entrada para cada tarea, que muestra el estado inicial de la tarea.  Puede ser <b>NUSE_READY</b> o <b>NUSE_PURE_SUSPEND</b> .  Esta matriz se crea si se selecciona el soporte para el estado inicial de la tarea. <br><br>  Estas estructuras de datos se declaran e inicializan (est√°ticamente) en <b>nuse_config.c</b> : <br><br><img src="https://habrastorage.org/webt/2g/pp/bu/2gppbu3zs8wc0gipo3kggntvxek.jpeg"><br><br><h3>  La cantidad de memoria para almacenar datos de tareas (Footprint Footprint) </h3><br>  Como todos los objetos centrales de Nucleus SE, la cantidad de memoria requerida para almacenar datos es predecible. <br><br>  Tama√±o de ROM (en bytes) requerido para todas las tareas de la aplicaci√≥n: <br>  <b>NUSE_TASK_NUMBER * sizeof (ADDR)</b> <br><br>  Adem√°s, si se selecciona un planificador que no sea RTC: <br>  <b>NUSE_TASK_NUMBER * (sizeof (ADDR) +2)</b> <br><br>  Adem√°s, si se selecciona el soporte para el estado inicial de la tarea: <br>  <b>NUSE_TASK_NUMBER</b> <br><br>  Para almacenar datos en la RAM, la cantidad de memoria (en bytes) est√° determinada por los par√°metros seleccionados, y puede tener un valor cero si no se selecciona ninguno de los par√°metros. <br>  Si se selecciona un planificador que no sea RTC: <br>  <b>NUSE_TASK_NUMBER * NUSE REGISTERS * sizeof (ADDR)</b> <br><br>  Adem√°s, si se selecciona el soporte de se√±al: <br>  <b>NUSE_TASK_NUMBER</b> <br><br>  Adem√°s, si la llamada a la API NUSE_Task_Sleep () est√° activada: <br>  <b>NUSE_TASK_NUMBER * 2</b> <br><br>  Adem√°s, si la suspensi√≥n de tareas est√° activada: <br>  <b>NUSE_TASK_NUMBER</b> <br><br>  Adem√°s, si el bloqueo de llamadas API est√° activado: <br>  <b>NUSE_TASK_NUMBER</b> <br><br>  Adem√°s, si el contador del planificador est√° activado: <br>  <b>NUSE_TASK_NUMBER * 2</b> <br><br><h2>  Llamadas API no implementadas en Nucleus SE </h2><br>  A continuaci√≥n se enumeran siete llamadas API que est√°n disponibles en Nucleus RTOS que no se implementan en Nucleus SE. <br><br><h3>  Crear tarea </h3><br>  Esta llamada a la API crea una tarea de aplicaci√≥n.  Nucleus SE no necesita esta funci√≥n porque las tareas se crean de forma est√°tica. <br><br>  Prototipo de llamada: <br><br>  <b>ESTADO NU_Create_Task (NU_TASK * task, CHAR * name, VOID (* task_entry) (UNSIGNED, VOID *), UNSIGNED argc, VOID * argv, VOID * stack_address, UNSIGNED stack_size, OPTION prioridad, UNSIGNED time_slice, OPTION time_slice, OPTION</b> <br><br>  Par√°metros: <br><br>  <b>tarea</b> : un puntero a un bloque de control de tareas del usuario, se puede utilizar como identificador / enlace ("identificador") de una tarea en otras llamadas API; <br>  <b>nombre</b> : apunta al nombre de la tarea, una cadena de 7 caracteres con un cero final; <br>  <b>task_entry</b> : indica la funci√≥n de entrada para la tarea; <br>  <b>argc</b> : elemento de datos <b>NO</b> <b>FIRMADO</b> que se puede usar para pasar informaci√≥n inicial a la tarea; <br>  <b>argv</b> : un puntero que se puede usar para transmitir informaci√≥n a la tarea; <br>  <b>stack_address</b> : establece el sector inicial de la memoria para la pila de tareas; <br>  <b>stack_size</b> : indica el n√∫mero de bytes en la pila; <br>  <b>prioridad</b> : indica el valor de prioridad de la tarea: de 0 a 255, donde los n√∫meros m√°s bajos corresponden a la prioridad m√°s alta; <br>  <b>time_slice</b> : indica el n√∫mero m√°ximo de <b>segmentos</b> de tiempo que pueden transcurrir durante esta tarea.  Un valor de "0" deshabilita la divisi√≥n de tiempo para esta tarea; <br>  <b>preferencia</b> - indica si la tarea se suplanta o no.  Puede tener valores <b>NU_PREEMPT</b> y <b>NU_NO_PREEMPT</b> ; <br>  <b>auto_start</b> : muestra el estado inicial de la tarea.  <b>NU_START</b> significa que la tarea est√° lista para su ejecuci√≥n, y <b>NU_NO_START significa</b> que la tarea est√° suspendida. <br><br>  Valor de retorno: <br><br>  <b>NU_SUCCESS</b> - indica una finalizaci√≥n exitosa del servicio; <br>  <b>NU_INVALID_TASK</b> : indica que el puntero a la unidad de control de tareas es <b>NULL</b> ; <br>  <b>NU_INVALID_ENTRY</b> : indica que el puntero a la funci√≥n de entrada de la tarea es <b>NULL</b> ; <br>  <b>NU_INVALID_MEMORY</b> : indica que el sector de memoria asignado por el par√°metro stack_address es cero ( <b>NULL</b> ); <br>  <b>NU_INVALID_SIZE</b> : indica que el tama√±o de pila especificado es insuficiente; <br>  <b>NU_INVALID_PREEMPT</b> : indica que el par√°metro de <b>preferencia est√°</b> configurado incorrectamente; <br>  <b>NU_INVALID_START</b> : indica que el par√°metro <b>auto_start est√°</b> configurado incorrectamente. <br><br><h3>  Eliminar tarea </h3><br>  Esta llamada a la API elimina una tarea de aplicaci√≥n creada previamente que debe estar <i>finalizada</i> o <i>finalizada</i> .  Esta llamada tampoco es necesaria para Nucleus SE, ya que las tareas se crean de forma est√°tica y no se pueden eliminar. <br><br>  Prototipo de llamada: <br><br>  <b>ESTADO NU_Delete_Task (tarea NU_TASK *);</b> <br><br>  Par√°metros: <br><br>  <b>tarea</b> : puntero al bloque de control de tareas <br><br>  Valor de retorno: <br><br>  <b>NU_SUCCESS</b> - indica una finalizaci√≥n exitosa del servicio; <br>  <b>NU_INVALID_TASK</b> : indica que el puntero a la tarea est√° configurado incorrectamente; <br>  <b>NU_INVALID_DELETE</b> : indica que la tarea no est√° en el estado Finalizado o Terminado. <br><br><h3>  Obtener punteros de tareas </h3><br>  Esta llamada a la API forma una lista secuencial de punteros a todas las tareas en el sistema.  No es necesario en Nucleus SE, ya que las tareas se identifican utilizando un √≠ndice simple, no un puntero. <br><br>  Prototipo de llamada: <br><br>  <b>NU_Task_Pointers SIN FIRMAR (NU_TASK ** pointer_list, UNSIGNED maximum_pointers);</b> <br><br>  Par√°metros: <br><br>  <b>pointer_list</b> : puntero a una matriz de punteros <b>NU_TASK</b> .  Esta matriz se llenar√° con punteros a las tareas instaladas en el sistema; <br>  <b>maximum_pointers</b> : el n√∫mero m√°ximo de punteros que se pueden colocar en la matriz. <br><br>  Valor de retorno: <br><br>  El n√∫mero de punteros <b>NU_TASK</b> colocados en la matriz. <br><br><h3>  Cambiar prioridad de tarea </h3><br>  Esta llamada a la API le da a la tarea una nueva prioridad.  En Nucleus SE, no es obligatorio, ya que las prioridades de la tarea son constantes. <br><br>  Prototipo de llamada: <br><br>  <b>OPTION NU_Change_Priority (tarea NU_TASK *, OPTION new_priority);</b> <br><br>  Par√°metros: <br><br>  <b>tarea</b> : un puntero a un bloque de control de tarea; <br>  <b>nueva_prioridad</b> : establece la prioridad de 0 a 255. <br><br>  Valor de retorno: <br>  El valor de prioridad de tarea anterior. <br><br><h3>  Cambiar el algoritmo de preajuste de tarea </h3><br>  Esta llamada a la API cambia el orden en que se desplaza la tarea en progreso.  Nucleus SE no lo necesita porque utiliza un algoritmo de programaci√≥n m√°s simple. <br><br>  Prototipo de llamada: <br>  <b>OPCI√ìN NU_Change_Preemption (opci√≥n OPC);</b> <br><br>  Par√°metros: <br>  <b>preempt</b> - nuevo algoritmo <b>preventivo</b> , acepta <b>NU_PREEMPT</b> o <b>NU_NO_PREEMPT</b> <br><br>  Valor de retorno: <br>  El algoritmo anterior para desplazar una tarea. <br><br><h3>  Cambiar el intervalo de tiempo de la tarea </h3><br>  Esta llamada a la API cambia el segmento de tiempo de una tarea espec√≠fica.  Nucleus SE no lo necesita, ya que los segmentos de tiempo de la tarea son fijos. <br><br>  Prototipo de llamada: <br>  <b>UNSIGNED NU_Change_Time_Slice (tarea NU_TASK *, UNSIGNED time_slice);</b> <br><br>  Par√°metros: <br>  <b>tarea</b> : un puntero a un bloque de control de tarea; <br>  <b>time_slice</b> : el n√∫mero m√°ximo de <b>segmentos</b> de tiempo que pueden transcurrir durante esta tarea; un valor cero de este campo deshabilita la cuantizaci√≥n de tiempo para esta tarea. <br><br>  Valor de retorno: <br>  El valor anterior del tiempo de tarea cu√°ntico. <br><br><h3>  Terminar tarea </h3><br>  Esta llamada a la API completa una tarea espec√≠fica.  Nucleus SE no necesita esto porque el estado <i>Terminado</i> no es compatible. <br><br>  Prototipo de llamada: <br>  <b>ESTADO NU_Terminate_Task (tarea NU_TASK *);</b> <br><br>  Par√°metros: <br>  <b>tarea</b> : un puntero a un bloque de control de tarea. <br><br>  Valor de retorno: <br>  <b>NU_SUCCESS</b> - indica una finalizaci√≥n exitosa del servicio; <br>  <b>NU_INVALID_TASK</b> : indica que el puntero de la tarea es incorrecto. <br><br><h2>  Nucleus RTOS Compatible </h2><br>  Al desarrollar Nucleus SE, uno de los objetivos principales era garantizar un alto nivel de compatibilidad de c√≥digo con Nucleus RTOS.  Las tareas no son una excepci√≥n y, desde el punto de vista del usuario, se implementan de la misma manera que en Nucleus RTOS.  Hay algunas √°reas incompatibles donde llegu√© a la conclusi√≥n de que tal incompatibilidad ser√≠a aceptable, dado que el c√≥digo final es m√°s f√°cil de entender y puede usar la memoria de manera m√°s eficiente.  Sin embargo, adem√°s de estas incompatibilidades, el resto de las llamadas a la API Nucleus RTOS se pueden usar casi directamente como llamadas Nucleus SE.  Uno de los siguientes art√≠culos proporcionar√° m√°s detalles sobre la transici√≥n de Nucleus RTOS a Nucleus SE <br><br><h3>  Identificadores de objetos </h3><br>  En Nucleus RTOS, todos los objetos se describen mediante una estructura de datos (unidades de control) que son de un tipo espec√≠fico.  Un puntero a esta unidad de control sirve como un identificador para la tarea.  En Nucleus SE, decid√≠ que se necesitaba un enfoque diferente para el uso eficiente de la memoria.  Todos los objetos del n√∫cleo se describen mediante un conjunto de tablas en RAM y / o ROM.  El tama√±o de estas tablas est√° determinado por el n√∫mero de tipos de objetos.  El identificador de un objeto espec√≠fico es el √≠ndice en estas tablas.  Entonces <b>defin√≠ NUSE_TASK</b> como el equivalente de <b>U8</b> .  Una variable de este tipo (no un puntero) sirve como un identificador para las tareas.  Esta es una peque√±a incompatibilidad que es f√°cil de descubrir si el c√≥digo se transfiere ao desde Nucleus RTOS.  Los identificadores de objetos generalmente se almacenan y transmiten sin cambios. <br><br>  Nucleus RTOS tambi√©n admite el nombramiento de tareas.  Estos nombres se usan solo para la depuraci√≥n.  Los exclu√≠ de Nucleus SE para ahorrar memoria. <br><br><h3>  Estados de la tarea </h3><br>  En Nucleus RTOS, las tareas pueden estar en uno de varios estados: <i>Ejecuci√≥n</i> , <i>Listo</i> , <i>Suspendido</i> (lo que genera incertidumbre: la tarea est√° en espera o bloqueada por una llamada API), <i>Terminada</i> o Finalizada. <br><br>  Nucleus SE tambi√©n admite los estados de <i>Ejecuci√≥n</i> y <i>Listo</i> .  Las tres opciones <i>suspendidas</i> son compatibles opcionalmente.  <i>Terminado</i> y terminado no son compatibles.  No hay llamadas de API para completar tareas.  Una funci√≥n de tarea externa nunca debe devolver un valor, ya sea expl√≠cita o impl√≠citamente (esto dar√° como resultado un estado <i>Finalizado</i> en Nucleus RTOS). <br><br><h3>  Llamadas API no realizadas </h3><br>  Nucleus RTOS admite 16 llamadas de oficina para trabajar con tareas.  De estos, 7 no est√°n implementados en Nucleus SE.  Su descripci√≥n, as√≠ como el motivo de su exclusi√≥n se describen anteriormente. <br><br>  En el siguiente art√≠culo, comenzaremos a analizar la administraci√≥n de memoria RTOS. <br><br>  <b>Sobre el autor:</b> Colin Walls ha trabajado en la industria electr√≥nica durante m√°s de treinta a√±os, dedicando la mayor parte de su tiempo al firmware.  Ahora es ingeniero de firmware en Mentor Embedded (una divisi√≥n de Mentor Graphics).  Colin Walls a menudo habla en conferencias y seminarios, autor de numerosos art√≠culos t√©cnicos y dos libros sobre firmware.  Vive en el Reino Unido.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Blog</a> profesional <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de Colin</a> , correo electr√≥nico: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es425353/">https://habr.com/ru/post/es425353/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es425343/index.html">25 herramientas √∫tiles de Kubernetes: implementaci√≥n y administraci√≥n</a></li>
<li><a href="../es425345/index.html">Simplificaci√≥n de nombres: 802.11ax se convierte en Wi-Fi 6</a></li>
<li><a href="../es425347/index.html">Dumping Mask: mito o realidad</a></li>
<li><a href="../es425349/index.html">El foro de Positive Hack Days 9 se llevar√° a cabo los d√≠as 21 y 22 de mayo en Crocus Expo</a></li>
<li><a href="../es425351/index.html">Los programadores de bricolaje pierden sus trabajos</a></li>
<li><a href="../es425355/index.html">Calificaci√≥n de seguridad del proyecto ICO</a></li>
<li><a href="../es425357/index.html">C√≥mo armamos una pila tecnol√≥gica de 12 pisos y no nos volvimos locos</a></li>
<li><a href="../es425359/index.html">Los chinos usaron un microchip para controlar las computadoras estadounidenses</a></li>
<li><a href="../es425361/index.html">Bloqueo de contenido, extensi√≥n para navegadores de cromo</a></li>
<li><a href="../es425363/index.html">Consejos para estudiantes programadores.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>