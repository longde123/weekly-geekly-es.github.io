<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëàüèΩ üôÖ üë©üèø‚Äçü§ù‚Äçüë©üèæ Mod√®le jetable (principe de conception jetable) pt.3 üíú ‚óÄÔ∏è üöÇ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Multithreading 


 Parlons maintenant de la glace mince. Dans les sections pr√©c√©dentes sur IDisposable, nous avons abord√© un concept tr√®s important qu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mod√®le jetable (principe de conception jetable) pt.3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/443962/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/nm/tj/eq/nmtjeqodhdjh27wvs0w6v8_0dhu.png"></a> </p><br><h2 id="multithreading">  Multithreading </h2><br><p>  Parlons maintenant de la glace mince.  Dans les sections pr√©c√©dentes sur IDisposable, nous avons abord√© un concept tr√®s important qui sous-tend non seulement les principes de conception des types jetables, mais tout type en g√©n√©ral.  Il s'agit du concept d'int√©grit√© de l'objet.  Cela signifie qu'√† un moment donn√©, un objet est dans un √©tat strictement d√©termin√© et que toute action avec cet objet transforme son √©tat en l'une des options pr√©d√©termin√©es lors de la conception d'un type de cet objet.  En d'autres termes, aucune action avec l'objet ne doit le transformer en un √©tat ind√©fini.  Cela entra√Æne un probl√®me avec les types con√ßus dans les exemples ci-dessus.  Ils ne sont pas thread-safe.  Il est possible que les m√©thodes publiques de ces types soient appel√©es lorsque la destruction d'un objet est en cours.  R√©solvons ce probl√®me et d√©cidons si nous devons le r√©soudre. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Ce chapitre a √©t√© traduit du russe conjointement par l'auteur et par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des traducteurs professionnels</a> .  Vous pouvez nous aider avec la traduction du russe ou de l'anglais dans n'importe quelle autre langue, principalement en chinois ou en allemand. <br><br>  Aussi, si vous voulez nous remercier, la meilleure fa√ßon de le faire est de nous donner une √©toile sur github ou sur fork repository <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote><a name="habracut"></a><br><pre><code class="plaintext hljs">public class FileWrapper : IDisposable { IntPtr _handle; bool _disposed; object _disposingSync = new object(); public FileWrapper(string name) { _handle = CreateFile(name, 0, 0, 0, 0, 0, IntPtr.Zero); } public void Seek(int position) { lock(_disposingSync) { CheckDisposed(); // Seek API call } } public void Dispose() { lock(_disposingSync) { if(_disposed) return; _disposed = true; } InternalDispose(); GC.SuppressFinalize(this); } [MethodImpl(MethodImplOptions.AggressiveInlining)] private void CheckDisposed() { lock(_disposingSync) { if(_disposed) { throw new ObjectDisposedException(); } } } private void InternalDispose() { CloseHandle(_handle); } ~FileWrapper() { InternalDispose(); } /// other methods }</code> </pre> <br><p>  Le code de validation <code>_disposed</code> dans Dispose () doit √™tre initialis√© en tant que section critique.  En fait, tout le code des m√©thodes publiques devrait √™tre initialis√© en tant que section critique.  Cela r√©soudra le probl√®me de l'acc√®s simultan√© √† une m√©thode publique d'un type d'instance et √† une m√©thode de destruction.  Cependant, cela apporte d'autres probl√®mes qui deviennent une bombe √† retardement: </p><br><ul><li>  L'utilisation intensive des m√©thodes d'instance de type ainsi que la cr√©ation et la destruction d'objets r√©duiront consid√©rablement les performances.  En effet, la prise d'un verrou prend du temps.  Ce temps est n√©cessaire pour allouer les tables SyncBlockIndex, v√©rifier le thread actuel et bien d'autres choses (nous les traiterons dans le chapitre sur le multithreading).  Cela signifie que nous devrons sacrifier les performances de l'objet tout au long de sa vie pour le ¬´dernier kilom√®tre¬ª de sa vie. </li><li>  Trafic m√©moire suppl√©mentaire pour les objets de synchronisation. </li><li>  √âtapes suppl√©mentaires que GC doit suivre pour parcourir un graphe d'objets. </li></ul><br><p>  Maintenant, nommons le deuxi√®me et, √† mon avis, la chose la plus importante.  Nous permettons la destruction d'un objet et en m√™me temps nous attendons √† travailler avec lui √† nouveau.  Qu'esp√©rons-nous dans cette situation?  qu'il √©chouera?  Parce que si Dispose s'ex√©cute en premier, l'utilisation suivante des m√©thodes objet entra√Ænera certainement <code>ObjectDisposedException</code> .  Vous devez donc d√©l√©guer la synchronisation entre les appels Dispose () et d'autres m√©thodes publiques d'un type du c√¥t√© service, c'est-√†-dire au code qui a cr√©√© l'instance de la classe <code>FileWrapper</code> .  C'est parce que seul le c√¥t√© cr√©ateur sait ce qu'il fera avec une instance d'une classe et quand la d√©truire.  D'un autre c√¥t√©, un appel Dispose ne devrait produire que des erreurs critiques, telles que <code>OutOfMemoryException</code> , mais pas IOException par exemple.  Cela est d√ª aux exigences pour l'architecture des classes qui impl√©mentent IDisposable.  Cela signifie que si Dispose est appel√© √† partir de plusieurs threads √† la fois, la destruction d'une entit√© peut se produire √† partir de deux threads simultan√©ment (nous sautons la v√©rification <code>if(_disposed) return;</code> ).  Cela d√©pend de la situation: si une ressource <em>peut √™tre</em> lib√©r√©e plusieurs fois, il n'est pas n√©cessaire d'effectuer des v√©rifications suppl√©mentaires.  Sinon, une protection est n√©cessaire: </p><br><pre> <code class="plaintext hljs">// I don't show the whole pattern on purpose as the example will be too long // and will not show the essence class Disposable : IDisposable { private volatile int _disposed; public void Dispose() { if(Interlocked.CompareExchange(ref _disposed, 1, 0) == 0) { // dispose } } }</code> </pre> <br><h2 id="two-levels-of-disposable-design-principle">  Deux niveaux de principe de conception jetable </h2><br><p>  Quel est le mod√®le le plus populaire pour impl√©menter <code>IDisposable</code> que vous pouvez rencontrer dans les livres .NET et Internet?  Quel mod√®le attendez-vous de vous pendant les entretiens pour un nouvel emploi potentiel?  Tr√®s probablement celui-ci: </p><br><pre> <code class="plaintext hljs">public class Disposable : IDisposable { bool _disposed; public void Dispose() { Dispose(true); GC.SuppressFinalize(this); } protected virtual void Dispose(bool disposing) { if(disposing) { // here we release managed resources } // here we release unmanaged resources } protected void CheckDisposed() { if(_disposed) { throw new ObjectDisposedException(); } } ~Disposable() { Dispose(false); } }</code> </pre> <br><p>  Quel est le probl√®me avec cet exemple et pourquoi nous n'avons pas √©crit comme √ßa auparavant?  En fait, c'est un bon mod√®le adapt√© √† toutes les situations.  Cependant, son utilisation omnipr√©sente n'est pas un bon style √† mon avis, car nous ne traitons presque pas les ressources non g√©r√©es dans la pratique, ce qui fait que la moiti√© du mod√®le ne sert √† rien.  De plus, puisqu'il g√®re simultan√©ment des ressources g√©r√©es et non g√©r√©es, il viole le principe de partage des responsabilit√©s.  Je pense que c'est faux.  Regardons une approche l√©g√®rement diff√©rente.  <em>Principe de conception jetable</em> .  En bref, cela fonctionne comme suit: </p><br><p>  L'√©limination est divis√©e en deux niveaux de classes: </p><br><ul><li>  Les types de niveau 0 encapsulent directement les ressources non g√©r√©es <br><ul><li>  Ils sont soit abstraits soit emball√©s. </li><li>  Toutes les m√©thodes doivent √™tre marqu√©es: <br>  - PrePrepareMethod, afin qu'une m√©thode puisse √™tre compil√©e lors du chargement d'un type <br><ul><li>  SecuritySafeCritical pour se prot√©ger contre un appel du code, fonctionnant sous des restrictions </li><li>  ReliabilityContract (Consistency.WillNotCorruptState, Cer.Success / MayFail)] pour mettre CER pour une m√©thode et tous ses appels enfants <br>  - Ils peuvent r√©f√©rencer des types de niveau 0, mais doivent incr√©menter le compteur d'objets r√©f√©renc√©s pour garantir le bon ordre d'entr√©e dans le ¬´dernier kilom√®tre¬ª </li></ul></li></ul></li><li>  Les types de niveau 1 encapsulent uniquement les ressources g√©r√©es <br><ul><li>  Ils sont h√©rit√©s uniquement des types de niveau 1 ou impl√©mentent directement IDisposable </li><li>  Ils ne peuvent pas h√©riter des types de niveau 0 ou CriticalFinalizerObject </li><li>  Ils peuvent encapsuler les types g√©r√©s de niveau 1 et de niveau 0 </li><li>  Ils impl√©mentent IDisposable. √âliminer en d√©truisant les objets encapsul√©s √† partir des types de niveau 0 et en allant au niveau 1 </li><li>  Ils n'impl√©mentent pas de finaliseur car ils ne traitent pas des ressources non g√©r√©es </li><li>  Ils doivent contenir une propri√©t√© prot√©g√©e qui donne acc√®s aux types de niveau 0. </li></ul></li></ul><br><p>  C'est pourquoi j'ai utilis√© la division en deux types depuis le d√©but: celle qui contient une ressource g√©r√©e et celle avec une ressource non g√©r√©e.  Ils devraient fonctionner diff√©remment. </p><br><h2 id="other-ways-to-use-dispose">  Autres fa√ßons d'utiliser Dispose </h2><br><p>  L'id√©e derri√®re la cr√©ation d'IDisposable √©tait de lib√©rer des ressources non g√©r√©es.  Mais comme pour de nombreux autres mod√®les, il est tr√®s utile pour d'autres t√¢ches, par exemple pour publier des r√©f√©rences √† des ressources g√©r√©es.  Bien que la lib√©ration des ressources g√©r√©es ne semble pas tr√®s utile.  Je veux dire qu'ils sont appel√©s g√©r√©s expr√®s afin que nous nous d√©tendions avec un sourire concernant les d√©veloppeurs C / C ++, non?  Mais ce n'est pas le cas.  Il peut toujours y avoir une situation o√π nous perdons une r√©f√©rence √† un objet mais en m√™me temps pensons que tout va bien: GC va collecter les ordures, y compris notre objet.  Cependant, il s'av√®re que la m√©moire augmente.  Nous entrons dans le programme d'analyse de la m√©moire et voyons que quelque chose d'autre contient cet objet.  Le fait est qu'il peut y avoir une logique pour la capture implicite d'une r√©f√©rence √† votre entit√© dans la plate-forme .NET et l'architecture des classes externes.  Comme la capture est implicite, un programmeur peut manquer la n√©cessit√© de sa lib√©ration et obtenir une fuite de m√©moire. </p><br><h3 id="delegates-events">  D√©l√©gu√©s, √©v√©nements </h3><br><p>  Regardons cet exemple synth√©tique: </p><br><pre> <code class="plaintext hljs">class Secondary { Action _action; void SaveForUseInFuture(Action action) { _action = action; } public void CallAction() { _action(); } } class Primary { Secondary _foo = new Secondary(); public void PlanSayHello() { _foo.SaveForUseInFuture(Strategy); } public void SayHello() { _foo.CallAction(); } void Strategy() { Console.WriteLine("Hello!"); } }</code> </pre> <br><p>  Quel probl√®me ce code montre-t-il?  La classe secondaire stocke <code>Action</code> d√©l√©gu√© de type <code>Action</code> dans le champ <code>_action</code> qui est accept√© dans la m√©thode <code>SaveForUseInFuture</code> .  Ensuite, la m√©thode <code>PlanSayHello</code> √† <code>Primary</code> int√©rieur de la classe <code>Primary</code> transmet le pointeur de la m√©thode <code>Strategy</code> √† la classe <code>Secondary</code> .  C'est curieux mais si, dans cet exemple, vous passez quelque part une m√©thode statique ou une m√©thode d'instance, la <code>SaveForUseInFuture</code> pass√©e ne sera pas modifi√©e, mais une instance de classe <code>Primary</code> sera r√©f√©renc√©e <em>implicitement</em> ou ne sera pas r√©f√©renc√©e du tout.  Ext√©rieurement, il semble que vous ayez demand√© la m√©thode √† appeler.  Mais en fait, un d√©l√©gu√© est construit non seulement √† l'aide d'un pointeur de m√©thode, mais √©galement √† l'aide du pointeur vers une instance d'une classe.  Un appelant doit comprendre pour quelle instance d'une classe il doit appeler la m√©thode <code>Strategy</code> !  C'est l'instance de la classe <code>Secondary</code> qui a implicitement accept√© et d√©tient le pointeur vers l'instance de la classe <code>Primary</code> , bien qu'il ne soit pas indiqu√© explicitement.  Pour nous, cela signifie seulement que si nous passons le pointeur <code>_foo</code> ailleurs et perdons la r√©f√©rence √† <code>Primary</code> , GC <em>ne collectera pas d'</em> objet <code>Primary</code> , car <code>Secondary</code> le conservera.  Comment √©viter de telles situations?  Nous avons besoin d'une approche d√©termin√©e pour nous communiquer une r√©f√©rence.  Un m√©canisme qui correspond parfaitement √† cet objectif est <code>IDisposable</code> </p><br><pre> <code class="plaintext hljs">// This is a simplified implementation class Secondary : IDisposable { Action _action; public event Action&lt;Secondary&gt; OnDisposed; public void SaveForUseInFuture(Action action) { _action = action; } public void CallAction() { _action?.Invoke(); } void Dispose() { _action = null; OnDisposed?.Invoke(this); } }</code> </pre> <br><p>  Maintenant, l'exemple semble acceptable.  Si une instance d'une classe est transmise √† un tiers et que la r√©f√©rence √† <code>_action</code> delegate sera perdue au cours de ce processus, nous la mettrons √† z√©ro et le tiers sera inform√© de la destruction de l'instance et supprimera la r√©f√©rence √† celle-ci . <br>  Le deuxi√®me danger du code qui s'ex√©cute sur les d√©l√©gu√©s est le principe de fonctionnement de l' <code>event</code> .  Voyons ce qu'ils entra√Ænent: </p><br><pre> <code class="plaintext hljs"> // a private field of a handler private Action&lt;Secondary&gt; _event; // add/remove methods are marked as [MethodImpl(MethodImplOptions.Synchronized)] // that is similar to lock(this) public event Action&lt;Secondary&gt; OnDisposed { add { lock(this) { _event += value; } } remove { lock(this) { _event -= value; } } }</code> </pre> <br><p>  La messagerie C # masque les √©l√©ments internes des √©v√©nements et contient tous les objets qui se sont abonn√©s pour se mettre √† jour via l' <code>event</code> .  Si quelque chose se passe mal, une r√©f√©rence √† un objet sign√© reste dans <code>OnDisposed</code> et contiendra l'objet.  C'est une situation √©trange car en termes d'architecture, nous obtenons un concept de ¬´source d'√©v√©nements¬ª qui ne devrait rien contenir logiquement.  Mais en fait, les objets abonn√©s √† la mise √† jour sont conserv√©s implicitement.  De plus, nous ne pouvons pas changer quelque chose √† l'int√©rieur de ce tableau de d√©l√©gu√©s bien que l'entit√© nous appartienne.  La seule chose que nous pouvons faire est de supprimer cette liste en affectant null √† une source d'√©v√©nements. </p><br><p>  La deuxi√®me fa√ßon consiste √† impl√©menter explicitement les m√©thodes d' <code>add</code> / <code>remove</code> , afin que nous puissions contr√¥ler une collection de d√©l√©gu√©s. </p><br><blockquote>  Une autre situation implicite peut appara√Ætre ici.  Il peut sembler que si vous attribuez null √† une source d'√©v√©nements, l'abonnement suivant aux √©v√©nements provoquera <code>NullReferenceException</code> .  Je pense que ce serait plus logique. </blockquote><p>  Mais ce n'est pas vrai.  Si le code externe s'abonne aux √©v√©nements apr√®s la <code>OnDisposed</code> une source d'√©v√©nements, FCL cr√©era une nouvelle instance de la classe Action et la stockera dans <code>OnDisposed</code> .  Cette implicitation en C # peut induire en erreur un programmeur: traiter des champs nuls devrait produire une sorte de vigilance plut√¥t que de calme.  Ici, nous d√©montrons √©galement une approche lorsque l'insouciance d'un programmeur peut entra√Æner des fuites de m√©moire. </p><br><h3 id="lambdas-closures">  Fermetures Lambdas </h3><br><p>  L'utilisation de sucre syntaxique comme les lambdas est particuli√®rement dangereuse. </p><br><blockquote>  Je voudrais aborder le sucre syntaxique dans son ensemble.  Je pense que vous devriez l'utiliser plut√¥t soigneusement et seulement si vous connaissez exactement le r√©sultat.  Les exemples avec des expressions lambda sont les fermetures, les fermetures dans les expressions et de nombreuses autres mis√®res que vous pouvez vous infliger. </blockquote><p>  Bien s√ªr, vous pouvez dire que vous savez qu'une expression lambda cr√©e une fermeture et peut entra√Æner un risque de fuite de ressources.  Mais il est si soign√©, si agr√©able qu'il est difficile d'√©viter d'utiliser lambda au lieu d'allouer la m√©thode enti√®re, qui sera d√©crite √† un endroit diff√©rent de celui o√π elle sera utilis√©e.  En fait, vous ne devriez pas adh√©rer √† cette provocation, bien que tout le monde ne puisse pas r√©sister.  Regardons l'exemple: </p><br><pre> <code class="plaintext hljs"> button.Clicked += () =&gt; service.SendMessageAsync(MessageType.Deploy);</code> </pre> <br><p>  D'accord, cette ligne semble tr√®s s√ªre.  Mais cela cache un gros probl√®me: maintenant, la variable <code>button</code> implicitement r√©f√©rence au <code>service</code> et le maintient.  M√™me si nous d√©cidons que nous n'avons plus besoin de <code>service</code> , le <code>button</code> conservera la r√©f√©rence tant que cette variable sera active.  L'une des fa√ßons de r√©soudre ce probl√®me consiste √† utiliser un mod√®le pour cr√©er <code>IDisposable</code> partir de n'importe quelle <code>Action</code> ( <code>System.Reactive.Disposables</code> ): </p><br><pre> <code class="plaintext hljs">// Here we create a delegate from a lambda Action action = () =&gt; service.SendMessageAsync(MessageType.Deploy); // Here we subscribe button.Clicked += action; // We unsubscribe var subscription = Disposable.Create(() =&gt; button.Clicked -= action); // where it is necessary subscription.Dispose();</code> </pre> <br><p>  Admettez, cela semble un peu long et nous perdons tout le but d'utiliser des expressions lambda.  Il est beaucoup plus s√ªr et plus simple d'utiliser des m√©thodes priv√©es communes pour capturer implicitement des variables. </p><br><h3 id="threadabort-protection">  Protection Threadabort </h3><br><p>  Lorsque vous cr√©ez une biblioth√®que pour un d√©veloppeur tiers, vous ne pouvez pas pr√©dire son comportement dans une application tierce.  Parfois, vous ne pouvez que deviner ce qu'un programmeur a fait √† votre biblioth√®que qui a provoqu√© un r√©sultat particulier.  Un exemple est le fonctionnement dans un environnement multithread lorsque la coh√©rence du nettoyage des ressources peut devenir un probl√®me critique.  Notez que lorsque nous √©crivons la m√©thode <code>Dispose()</code> , nous pouvons garantir l'absence d'exceptions.  Cependant, nous ne pouvons pas garantir que lors de l'ex√©cution de la m√©thode <code>Dispose()</code> aucune <code>ThreadAbortException</code> ne se produira qui d√©sactivera notre thread d'ex√©cution.  Ici, nous devons nous rappeler que lorsque <code>ThreadAbortException</code> se produit, tous les blocs catch / finally sont ex√©cut√©s de toute fa√ßon (√† la fin d'un bloc catch / finally, ThreadAbort se produit plus loin).  Donc, pour assurer l'ex√©cution d'un certain code en utilisant Thread.Abort, vous devez encapsuler une section critique dans <code>try { ... } finally { ... }</code> , voir l'exemple ci-dessous: </p><br><pre> <code class="plaintext hljs">void Dispose() { if(_disposed) return; _someInstance.Unsubscribe(this); _disposed = true; }</code> </pre> <br><p>  On peut abandonner cela √† tout moment en utilisant <code>Thread.Abort</code> .  Il d√©truit partiellement un objet, bien que vous puissiez toujours travailler avec lui √† l'avenir.  Dans le m√™me temps, le code suivant: </p><br><pre> <code class="plaintext hljs">void Dispose() { if(_disposed) return; // ThreadAbortException protection try {} finally { _someInstance.Unsubscribe(this); _disposed = true; } }</code> </pre> <br><p>  est prot√©g√© contre un tel abandon et fonctionnera sans probl√®me et √† coup s√ªr, m√™me si <code>Thread.Abort</code> appara√Æt entre l'appel de la m√©thode <code>Thread.Abort</code> et l'ex√©cution de ses instructions. </p><br><h2 id="results">  R√©sultats </h2><br><h3 id="advantages">  Les avantages </h3><br><p>  Eh bien, nous avons beaucoup appris sur ce mod√®le le plus simple.  D√©terminons ses avantages: </p><br><ol><li>  Le principal avantage du mod√®le est la capacit√© de lib√©rer des ressources de fa√ßon d√©terminante, c'est-√†-dire lorsque vous en avez besoin. </li><li>  Le deuxi√®me avantage est l'introduction d'un moyen √©prouv√© de v√©rifier si une instance sp√©cifique n√©cessite de d√©truire ses instances apr√®s utilisation. </li><li>  Si vous impl√©mentez le mod√®le correctement, un type con√ßu fonctionnera en toute s√©curit√© en termes d'utilisation par des composants tiers ainsi qu'en termes de d√©chargement et de destruction de ressources lorsqu'un processus se bloque (par exemple en raison d'un manque de m√©moire).  C'est le dernier avantage. </li></ol><br><h3 id="disadvantages">  Inconv√©nients </h3><br><p>  √Ä mon avis, ce mod√®le pr√©sente plus d'inconv√©nients que d'avantages. </p><br><ol><li>  D'une part, tout type qui impl√©mente ce mod√®le indique aux autres parties que s'il l'utilise, il prend une sorte d'offre publique.  Ceci est tellement implicite que, comme dans le cas d'offres publiques, un utilisateur d'un type ne sait pas toujours que le type a cette interface.  Vous devez donc suivre les invites IDE (tapez un point, Dis ... et v√©rifiez s'il existe une m√©thode dans la liste des membres filtr√©s d'une classe).  Si vous voyez un mod√®le Dispose, vous devez l'impl√©menter dans votre code.  Parfois, cela ne se produit pas imm√©diatement et dans ce cas, vous devez impl√©menter un mod√®le via un syst√®me de types qui ajoute des fonctionnalit√©s.  Un bon exemple est que <code>IEnumerator&lt;T&gt;</code> implique <code>IDisposable</code> . </li><li>  Habituellement, lorsque vous concevez une interface, il est n√©cessaire d'ins√©rer IDisposable dans le syst√®me des interfaces d'un type lorsqu'une des interfaces doit h√©riter d'IDisposable.  √Ä mon avis, cela endommage les interfaces que nous avons con√ßues.  Je veux dire que lorsque vous concevez une interface, vous cr√©ez d'abord un protocole d'interaction.  Il s'agit d'un ensemble d'actions que vous pouvez effectuer avec <em>quelque chose</em> cach√© derri√®re l'interface.  <code>Dispose()</code> est une m√©thode pour d√©truire une instance d'une classe.  Cela contredit l'essence d'un <em>protocole d'interaction</em> .  En fait, ce sont les d√©tails de l'impl√©mentation qui se sont infiltr√©s dans l'interface. </li><li>  Bien qu'il soit d√©termin√©, Dispose () ne signifie pas la destruction directe d'un objet.  L'objet existera toujours apr√®s sa <em>destruction</em> mais dans un autre √©tat.  Pour que cela soit vrai, CheckDisposed () doit √™tre la premi√®re commande de chaque m√©thode publique.  Cela ressemble √† une solution temporaire que quelqu'un nous a donn√©e en disant: ¬´Allez-y et multipliez-vous¬ª; </li><li>  Il existe √©galement une petite chance d'obtenir un type qui impl√©mente <code>IDisposable</code> via <em>une</em> impl√©mentation <em>explicite</em> .  Ou vous pouvez obtenir un type qui impl√©mente ID isposable sans avoir la possibilit√© de d√©terminer qui doit le d√©truire: vous ou la partie qui vous l'a donn√©.  Cela a abouti √† un contre-mod√®le d'appels multiples de Dispose () qui permet de d√©truire un objet d√©truit; </li><li>  L'impl√©mentation compl√®te est difficile et diff√©rente pour les ressources g√©r√©es et non g√©r√©es.  Ici, la tentative de faciliter le travail des d√©veloppeurs via GC semble maladroite.  Vous pouvez remplacer <code>virtual void Dispose()</code> m√©thode <code>virtual void Dispose()</code> et introduire un type DisposableObject qui impl√©mente l'ensemble du mod√®le, mais cela ne r√©sout pas les autres probl√®mes li√©s au mod√®le; </li><li>  En r√®gle g√©n√©rale, la m√©thode Dispose () est impl√©ment√©e √† la fin d'un fichier tandis que '.ctor' est d√©clar√© au d√©but.  Si vous modifiez une classe ou introduisez de nouvelles ressources, il est facile d'oublier d'ajouter une √©limination pour elles. </li><li>  Enfin, il est difficile de d√©terminer l'ordre de <em>destruction</em> dans un environnement multithread lorsque vous utilisez un mod√®le pour les graphiques d'objets o√π les objets impl√©mentent enti√®rement ou partiellement ce mod√®le.  Je veux dire des situations o√π Dispose () peut commencer √† diff√©rentes extr√©mit√©s d'un graphique.  Ici, il est pr√©f√©rable d'utiliser d'autres mod√®les, par exemple le mod√®le Lifetime. </li><li>  Le souhait des d√©veloppeurs de plates-formes d'automatiser le contr√¥le de la m√©moire combin√© aux r√©alit√©s: les applications interagissent tr√®s souvent avec du code non manag√© + vous devez contr√¥ler la publication des r√©f√©rences aux objets afin que Garbage Collector puisse les collecter.  Cela ajoute une grande confusion dans la compr√©hension de questions telles que: ¬´Comment devrions-nous impl√©menter correctement un mod√®le¬ª?  ¬´Existe-t-il un mod√®le fiable du tout¬ª?  Peut-√™tre en appelant <code>delete obj; delete[] arr;</code> <code>delete obj; delete[] arr;</code>  est plus simple? </li></ol><br><h2 id="domain-unloading-and-exit-from-an-application">  D√©chargement de domaine et sortie d'une application </h2><br><p>  Si vous arrivez √† cette partie, vous √™tes devenu plus confiant dans le succ√®s des futurs entretiens d'embauche.  Cependant, nous n'avons pas discut√© de toutes les questions li√©es √† ce mod√®le aussi simple que cela puisse para√Ætre.  La derni√®re question est de savoir si le comportement d'une application diff√®re en cas de garbage collection simple et lorsque les d√©chets sont collect√©s lors du d√©chargement de domaine et lors de la fermeture de l'application.  Cette question touche simplement <code>Dispose()</code> ... Cependant <code>Dispose()</code> et la finalisation vont de pair et nous rencontrons rarement une impl√©mentation d'une classe qui a la finalisation mais n'a pas la m√©thode <code>Dispose()</code> .  D√©crivons donc la finalisation dans une section distincte.  Ici, nous ajoutons juste quelques d√©tails importants. </p><br><p>  Lors du d√©chargement du domaine d'application, vous d√©chargez les assemblys charg√©s dans le domaine d'application et tous les objets cr√©√©s dans le cadre du domaine √† d√©charger.  En fait, cela signifie le nettoyage (collecte par GC) de ces objets et l'appel de finaliseurs pour eux.  Si la logique d'un finaliseur attend que la finalisation d'autres objets soit d√©truite dans le bon ordre, vous pouvez pr√™ter attention √† <code>Environment.HasShutdownStarted</code> propri√©t√© <code>Environment.HasShutdownStarted</code> indiquant qu'une application est d√©charg√©e de la m√©moire et √† la m√©thode <code>AppDomain.CurrentDomain.IsFinalizingForUnload()</code> indiquant que cela le domaine est d√©charg√©, ce qui est la raison de la finalisation.  Si ces √©v√©nements se produisent, l'ordre de finalisation des ressources devient g√©n√©ralement sans importance.  Nous ne pouvons pas retarder le d√©chargement de domaine ou d'une application car nous devons tout faire le plus rapidement possible. </p><br><p>  C'est ainsi que cette t√¢che est r√©solue dans le cadre d'une classe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LoaderAllocatorScout</a> </p><br><pre> <code class="plaintext hljs">// Assemblies and LoaderAllocators will be cleaned up during AppDomain shutdown in // an unmanaged code // So it is ok to skip reregistration and cleanup for finalization during appdomain shutdown. // We also avoid early finalization of LoaderAllocatorScout due to AD unload when the object was inside DelayedFinalizationList. if (!Environment.HasShutdownStarted &amp;&amp; !AppDomain.CurrentDomain.IsFinalizingForUnload()) { // Destroy returns false if the managed LoaderAllocator is still alive. if (!Destroy(m_nativeLoaderAllocator)) { // Somebody might have been holding a reference on us via weak handle. // We will keep trying. It will be hopefully released eventually. GC.ReRegisterForFinalize(this); } }</code> </pre> <br><h2 id="typical-implementation-faults">  Erreurs d'impl√©mentation typiques </h2><br><p>  Comme je vous l'ai montr√©, il n'y a pas de mod√®le universel pour impl√©menter IDisposable.  De plus, une certaine d√©pendance au contr√¥le automatique de la m√©moire induit les gens en erreur et prend des d√©cisions confuses lors de la mise en ≈ìuvre d'un mod√®le.  L'ensemble du .NET Framework est truff√© d'erreurs dans sa mise en ≈ìuvre.  Pour prouver mon point, examinons ces erreurs en utilisant exactement l'exemple de .NET Framework.  Toutes les impl√©mentations sont disponibles via: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IDisposable Usages</a> </p><br><p>  <strong>Classe</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FileEntry cmsinterop.cs</a> </p><br><blockquote>  Ce code est √©crit √† la h√¢te juste pour fermer le probl√®me.  De toute √©vidence, l'auteur voulait faire quelque chose mais a chang√© d'avis et a gard√© une solution d√©fectueuse </blockquote><br><pre> <code class="plaintext hljs">internal class FileEntry : IDisposable { // Other fields // ... [MarshalAs(UnmanagedType.SysInt)] public IntPtr HashValue; // ... ~FileEntry() { Dispose(false); } // The implementation is hidden and complicates calling the *right* version of a method. void IDisposable.Dispose() { this.Dispose(true); } // Choosing a public method is a serious mistake that allows for incorrect destruction of // an instance of a class. Moreover, you CANNOT call this method from the outside public void Dispose(bool fDisposing) { if (HashValue != IntPtr.Zero) { Marshal.FreeCoTaskMem(HashValue); HashValue = IntPtr.Zero; } if (fDisposing) { if( MuiMapping != null) { MuiMapping.Dispose(true); MuiMapping = null; } System.GC.SuppressFinalize(this); } } }</code> </pre> <br><p>  <a href="">Syst√®me de</a> <strong>classe SemaphoreSlim</strong> <a href="">/ Filetage / SemaphoreSlim.cs</a> </p><br><blockquote>  Cette erreur se trouve en haut des erreurs de .NET Framework concernant IDisposable: SuppressFinalize pour les classes o√π il n'y a pas de finaliseur.  C'est tr√®s courant. </blockquote><br><pre> <code class="plaintext hljs">public void Dispose() { Dispose(true); // As the class doesn't have a finalizer, there is no need in GC.SuppressFinalize GC.SuppressFinalize(this); } // The implementation of this pattern assumes the finalizer exists. But it doesn't. // It was possible to do with just public virtual void Dispose() protected virtual void Dispose(bool disposing) { if (disposing) { if (m_waitHandle != null) { m_waitHandle.Close(); m_waitHandle = null; } m_lockObj = null; m_asyncHead = null; m_asyncTail = null; } }</code> </pre> <br><p>  <strong>Appel de Close + Dispose</strong> <a href="">Some Code de projet NativeWatcher</a> </p><br><blockquote>  Parfois, les gens appellent √† la fois Close et Dispose.  C'est faux mais cela ne produira pas d'erreur car le deuxi√®me Dispose ne g√©n√®re pas d'exception. </blockquote><p>  En fait, Close est un autre mod√®le pour rendre les choses plus claires pour les gens.  Cependant, cela rendait tout plus flou. </p><br><pre> <code class="plaintext hljs">public void Dispose() { if (MainForm != null) { MainForm.Close(); MainForm.Dispose(); } MainForm = null; }</code> </pre> <br><h2 id="general-results">  R√©sultats g√©n√©raux </h2><br><ol><li>  IDposable est un standard de la plateforme et la qualit√© de sa mise en ≈ìuvre influence la qualit√© de l'ensemble de l'application.  De plus, dans certaines situations, cela influence la s√©curit√© de votre application qui peut √™tre attaqu√©e via des ressources non g√©r√©es. </li><li>  La mise en ≈ìuvre d'IDisposable doit √™tre au maximum productive.  Cela est particuli√®rement vrai pour la section de finalisation, qui fonctionne en parall√®le avec le reste du code, en chargeant Garbage Collector. </li><li>  Lorsque vous impl√©mentez IDisposable, vous ne devez pas utiliser Dispose () simultan√©ment avec les m√©thodes publiques d'une classe.  La destruction ne peut pas aller de pair avec l'usage.  Cela doit √™tre pris en compte lors de la conception d'un type qui utilisera un objet IDisposable. </li><li>  Cependant, il devrait y avoir une protection contre l'appel simultan√© de ¬´Dispose ()¬ª √† partir de deux threads.  Cela r√©sulte de l'instruction que Dispose () ne doit pas produire d'erreurs. </li><li>  Les types qui contiennent des ressources non g√©r√©es doivent √™tre s√©par√©s des autres types.  Je veux dire que si vous encapsulez une ressource non g√©r√©e, vous devez lui allouer un type distinct.  Ce type doit contenir la finalisation et doit √™tre h√©rit√© de <code>SafeHandle / CriticalHandle / CriticalFinalizerObject</code> .  Cette s√©paration des responsabilit√©s se traduira par une meilleure prise en charge du syst√®me de types et simplifiera l'impl√©mentation pour d√©truire les instances de types via Dispose (): les types avec cette impl√©mentation n'auront pas besoin d'impl√©menter un finaliseur. </li><li>  En g√©n√©ral, ce mod√®le n'est pas confortable √† utiliser ainsi que dans la maintenance du code.  Probablement, nous devrions utiliser l'approche d'inversion de contr√¥le lorsque nous d√©truisons l'√©tat des objets via le mod√®le <code>Lifetime</code> .  Cependant, nous en parlerons dans la section suivante. </li></ol><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Ce chapitre a √©t√© traduit du russe conjointement par l'auteur et par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des traducteurs professionnels</a> .  Vous pouvez nous aider avec la traduction du russe ou de l'anglais dans n'importe quelle autre langue, principalement en chinois ou en allemand. <br><br>  Aussi, si vous voulez nous remercier, la meilleure fa√ßon de le faire est de nous donner une √©toile sur github ou sur fork repository <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr443962/">https://habr.com/ru/post/fr443962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr443952/index.html">Internet souverain - pour notre argent</a></li>
<li><a href="../fr443954/index.html">Singularit√© technologique: le mythe moderne de la fin du monde sous le couvert de l'hypoth√®se du progr√®s</a></li>
<li><a href="../fr443956/index.html">R√©seau social en 2019: Yandex lance Aura</a></li>
<li><a href="../fr443958/index.html">Mod√®le jetable (principe de conception jetable) pt.1</a></li>
<li><a href="../fr443960/index.html">Mod√®le jetable (principe de conception jetable) pt.2</a></li>
<li><a href="../fr443964/index.html">Kolesa Conf est la plus grande conf√©rence informatique au Kazakhstan. Annonce des rapports</a></li>
<li><a href="../fr443966/index.html">Google Docs - un chat pr√©f√©r√© des √©tudiants</a></li>
<li><a href="../fr443968/index.html">Comment nous avons achet√© une maison avec des panneaux solaires et ce qui en est arriv√©</a></li>
<li><a href="../fr443972/index.html">Yandex recherchera des pirates √† l'aide d'un robot</a></li>
<li><a href="../fr443974/index.html">M√©moire et √©tendue pt.1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>