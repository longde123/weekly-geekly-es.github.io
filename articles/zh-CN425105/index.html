<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌲 💩 🈶 英特尔ME制造模式-隐藏的威胁或MacBook中漏洞CVE-2018-4251的原因 👎 🤵🏾 👑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="多年来，专家一直批评“ 模糊不清 ”的原则，但这并不能阻止大型电子制造商以保护知识产权为借口，要求签署保密协议以获取技术文档。 由于微电路的复杂性不断增加以及各种专有固件的集成，这种情况正在恶化。 实际上，这使得不可能为独立研究人员分析此类平台，从而使普通用户和设备制造商都面临风险。 

 一个示例...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>英特尔ME制造模式-隐藏的威胁或MacBook中漏洞CVE-2018-4251的原因</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pt/blog/425105/"><img src="https://habrastorage.org/webt/mk/ba/-i/mkba-izexq1vhigp76l3sbepw50.png"><br><br> 多年来，专家一直批评“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">模糊不清</a> ”的原则，但这并不能阻止大型电子制造商以保护知识产权为借口，要求签署保密协议以获取技术文档。 由于微电路的复杂性不断增加以及各种专有固件的集成，这种情况正在恶化。 实际上，这使得不可能为独立研究人员分析此类平台，从而使普通用户和设备制造商都面临风险。 <br><br> 一个示例是英特尔管理引擎（Intel ME）技术，以及其用于服务器（Intel SPS）和移动（Intel TXE）平台的版本（有关此技术的更多信息，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">[5]</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">[6]</a> 。在本文中，我们将介绍如何使用未记录的命令（如果术语“已记录”通常适用于Intel ME），则可以覆盖SPI闪存并实现最坏的情况-对ME中的漏洞进行本地利用（INTEL-SA-00086）。 -制造模式。 <a name="habracut"></a><br><br><h2> 什么是制造模式 </h2><br> 英特尔ME制造模式-设计用于在生产阶段配置，配置和测试最终平台的服务操作模式； 在设备开始销售并交付给用户之前必须将其关闭。 英特尔公共文档中没有描述此模式及其潜在风险。 普通用户无法自己关闭它，因为从英特尔ME系统工具包管理他的实用程序尚未正式提供。 请注意，如果打开此模式，或者至少将其通知用户，则没有软件保护可以保护用户。 即使是专门用于在UEFI固件级别检测芯片组和处理器配置错误（特别是对SPI闪存区域的访问权限的配置不正确）的Chipsec实用程序<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">[2]</a> ，也对英特尔制造模式一无所知。 <br><br> 此模式允许您设置存储在一次写入存储器（FUSES）中的关键平台参数。 在FUSES中“连接”的此类参数的一个示例是BootGuard参数（ACM和UEFI模块的模式，策略，数字签名密钥校验和）。 其中一些被称为FPF（现场可编程保险丝）。 可以通过Intel ME System Tools软件包中的FPT（闪存编程工具）实用程序获取可以写入FUSES的FPF列表（实际上，不完整，不能直接设置许多FPF）。 <br><br><img src="https://habrastorage.org/webt/vy/lm/wt/vylmwtru_w7skhyv8wjp_r8bw-e.png"><br><br>  <i>图1. FPT实用程序的–FPFs选项的结果</i> <br><br> 应该注意的是，FPF仅占整个FUSE阵列的一部分，并且该内存的大部分被Intel自己用来存储许多平台参数。 例如，此阵列的部分空间称为IP保险丝，用于存储各个硬件模块的配置参数（智能属性）。 因此，特殊的DFx Aggregator设备在FUSE中存储平台是串行的还是测试的标志。 <br><br> 除FPF外，在制造模式下，设备制造商还可以设置Intel ME固件参数，这些参数存储在SPI闪存介质上的内部固件文件系统MFS中。 重新编程SPI闪存时，可以更改这些参数。 它们被称为CVAR（可配置NVAR，命名变量）。 <br><br> 为了安装CVAR，负责Intel ME固件模块mca_server。  MCA是生产线配置体系结构的缩写，是制造阶段平台配置过程的通用名称。 可以像FPF一样定义CVAR，并使用FPT读取。 <br><br><img src="https://habrastorage.org/webt/yb/m_/4r/ybm_4ruf778k-z4hfdufqjsyuxq.png"><br><br>  <i>图2. FPT实用程序为Broxton P平台输出的CVAR列表</i> <br><br>  CVAR的列表因平台和Intel ME固件版本而异。 对于支持Intel AMT技术的芯片组，这些变量之一是用于输入MEBx（ME BIOS扩展名）的密码。 <br><br> 仅当Intel ME固件在制造模式下运行时，才可以安装FPF和几乎所有CVAR变量。  FPF的安装过程本身分为两个阶段：设置FPF（存储在临时存储器中）和将FPF传输到保险丝阵列。 同时，只有在“制造”模式下才可以进行第一阶段，并且在离开“制造”模式后，如果制造商在此模式下操作时设置了FPF值并且同时从未在融合阵列中记录相应的范围，则真正的“燃烧”会自动发生。 因此，如果系统在制造模式下运行，则很可能未初始化FPF变量。 <br><br> 禁用制造模式的迹象存储在MFS上的文件/ home / mca / eom中，因此，当使用带有基本文件系统的固件重写SPI闪存时（有关更多详细信息，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">[9]</a> ），该平台可以再次在制造模式下运行（但无法覆盖保险丝） 。 <br><br><h2>  OEM公钥 </h2><br> 因此，配置英特尔平台的过程非常复杂，包括几个阶段。 如果设备制造商违反或更改了顺序，则平台存在严重风险。 即使完成了制造模式，制造商也无法编写FUSES，这将允许攻击者为他编写FUSES，写下其值而不是用于签名BootGuard（ACM）和UEFI模块的引导代码的密钥，从而仅允许平台使用其恶意代码进行引导，并且在持续的基础上。 这将导致无法挽回的设备损失，因为欺诈密钥将永远被注册在永久性存储器中（有关这种攻击的详细信息，请参阅《安全防护rootkit：Alexander Ermolov撰写的Intel BootGuard <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">[8]</a> ）。 <br><br> 在FPF中的新系统（Apollo Lake，Gemini Lake，Cannon Point）中，不仅存储了BootGuard的密钥，而且还存储了OEM公钥（或者更确切地说，是RSA OEM公钥中的SHA-256），而ME公钥保护机制则基于该公钥。 例如，一个特殊的SPI闪存部分（称为签名主映像配置文件（SMIP））存储制造商特定的PCH带（PCH硬件配置）。 本部分在密钥SHA-256上签名，密钥SHA-256被放置在SPI闪存的特殊文件中。 该文件称为oem.key，位于FTPR部分，其中包含OEM提供的用于签名各种数据的各种公共密钥。 这是制造商签署的Cannon Point平台数据集的完整列表，每个都有唯一的密钥： <br><br><img src="https://habrastorage.org/webt/82/cu/nv/82cunvku9stjop0mwasr983sb9i.png"><br><br>  <i>图3.已签名的OEM CNP平台数据列表</i> <br><br>  oem.key文件本身是由OEM共享根密钥签名的，该哈希根数必须记录在FPF中。 <br><br><img src="https://habrastorage.org/webt/13/3j/2a/133j2ab9jyihflrux_pqznov7r8.png"><br><br>  <i>图4. OEM签名</i> <br><br><h2> 在ME区域中绕过写锁定 </h2><br> 直到最近（在Intel Apollo Lake之前），Intel ME固件仍在单独的SPI区域中，该区域具有对CPU，GBE和ME的独立访问权限。 因此，如果在CPU（主系统）部分上正确配置了访问属性，则无法读写ME固件。 但是，现代英特尔芯片组SPI控制器具有特殊的“主授权”机制。 该技术为每个SPI主机分配了一个严格定义的SPI闪存部分，该主机拥有其区域，而不管SPI描述符中指定的访问权限如何。 每个主控者都有机会根据自己的意愿提供（仅用于他或他的）区域的访问权限（用于读取或写入）。 <br><br><img src="https://habrastorage.org/webt/zk/rb/2q/zkrb2q_edrdhx2akun6qlvvctay.png"><br><br>  <i>图5.描述SPI Master Grant的英特尔文档摘录</i> <br><br> 因此，即使主机指定禁止从主机访问ME SPI区域，ME仍然可以提供对其数据的访问。 我们认为，这样做是为了绕过标准算法来更新Intel ME固件。 <br><br><h2> 主机ME区域闪存保护覆盖 </h2><br> 在Intel ME固件中，实现了特殊的HECI命令，该命令允许您打开从CPU对SPI ME区域的写访问。 它称为HMR FPO（主机ME区域闪存保护替代）。 在之前的一项研究中，我们详细描述了此命令[5]。 她有几个特点。 <br><br> 收到HMR FPO命令后，固件<i><b>仅在</b></i>重新引导<i><b>后才</b></i>打开对其区域的访问。  ME本身也提供保护：仅在UEFI BIOS执行期间接受命令，直到所谓的过帐结束（EOP）时刻为止。  EOP是UEFI BIOS在将控制权转移到操作系统（ExitBootServices）之前发送的另一条HECI命令。 在某些BIOS设置中，您可以找到使HMRFPO命令发送到EOP的选项。 <br><br><img src="https://habrastorage.org/webt/ig/mx/0x/igmx0x3qbpm8pgwwki1tv_bpe80.png"><br><br>  <i>图6.在BIOS中打开ME区域</i> <br><br> 收到EOP后，ME固件将忽略HMR FPO，返回相应状态。  <b>但这仅在制造模式完成后才发生</b> 。 因此，处于制造模式的ME固件在<b>任何时候都</b>接受HMR FPO <b>，而与发布结束无关</b> 。 如果制造商尚未关闭制造模式，则攻击者（通常来说，这需要管理员权限，但即使OS内核最初也无法覆盖ME固件）可以随时更改ME固件。 在此阶段，攻击者可以覆盖ME映像，例如，以利用INTEL-SA-00086漏洞。 这增加了重新启动的必要，但这并不是除MacBook之外几乎所有平台上的障碍。  <b>在Apple计算机上，UEFI中还有一个附加检查，该检查在启动时执行，如果使用HMRFPO打开了ME区域，则会阻止系统启动。</b> 但是，正如我们稍后将说明的那样，如果ME固件在制造模式下运行，则可以克服这种保护机制。 <br><br><h2> 重启我而不重启主CPU </h2><br> 在现代计算机中，有几种重新启动平台的选项。 其中记录如下：全局重启和仅重启主CPU（不重启ME）。 但是，如果有一种方法可以在<b>不</b>重启主CPU的<b>情况下</b>重启ME（也要执行HMRFPO命令），则将打开对该区域的访问，并且主系统将继续运行。 <br><br><img src="https://habrastorage.org/webt/u3/af/7t/u3af7trk0vcnkhg-rcoo-rxo2h8.png"><br><br>  <i>图7.重新启动类型控制</i> <br><br> 检查内部ME固件模块后，我们发现有一条HECI命令（ <b>“ 80 06 00 07 00 00 0b 00 00 00 03 00”</b> ，有关发送命令的更多详细信息，请参见[ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">5</a> ]）仅重启（！）英特尔ME内核，即使在EOP之后，也可以随时发送处于“制造模式”的邮件。 <br><br><img src="https://habrastorage.org/webt/md/j6/xq/mdj6xqacvwhhwpfhdllxkchsobe.png"><br><br>  <i>图8.处理ME HECI重载命令的函数的反汇编程序列表</i> <br><br>  <b>因此，发送了这两个HECI命令的攻击者可以打开ME区域，并且可以在不重新启动平台的情况下在其中写入任何数据</b> 。 在这种情况下，SPI描述符包含的内容无关紧要，也就是说，如果系统在制造模式下运行，则SPI区域的正确保护属性不会保护ME固件免受更改。 <br><br><h2> 案例<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">研究</a> ：漏洞<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CVE-2018-4251</a> </h2><br> 我们分析了来自不同制造商的几种平台。 其中包括联想笔记本电脑和苹果MacBookPr®。 在经Yoga和ThinkPad生产线检查的计算机中，我们没有发现与制造模式相关的任何问题，但是<b>基于Intel芯片组的Apple笔记本电脑在制造模式下运行</b> 。 将这些信息传输到Apple后，此错误（CVE-2018-4251）已在macOS High Sierra 10.13.5 OS更新中修复。 <br><br><h2> 本地操作INTEL-SA-00086 </h2><br> 因此，利用CVE-2018-4251漏洞，攻击者可以编写包含INTEL-SA-00086漏洞的ME固件的旧版本，并且同时不需要SPI编程器或访问HDA_SDO跳线（即物理访问）。 因此，实现了此漏洞的最危险的本地向量（在ME固件中执行任意代码）。 值得注意的是，在INTEL-SA-00086安全公告的解释中，英特尔没有提及开放制造模式作为在没有物理访问的情况下本地利用此漏洞的方法，而只是说只有在对SPI区域的访问配置不正确的情况下，才可以进行本地利用那是不对的。 为了保护用户，我们决定描述如何检查制造模式的可用性以及如何禁用它。 <br><br><h2> 如何保护自己 </h2><br> 针对基于芯片组和英特尔处理器的设备开发人员的系统实用程序软件包（英特尔系统工具）包括MEInfo实用程序（分别用于移动和服务器平台的TXEInfo，SPSInfo），该实用程序旨在接收有关管理引擎固件和当前状态的高级诊断信息。整个平台。 我们在以前的一项关于禁用ME和未记录的HAP（高保证平台）模式的研究中证明了此实用程序[ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">6</a> ]。 用–FWSTS标志调用的该实用程序提供了HECI状态寄存器的详细说明，并报告了制造模式状态（FWSTS状态寄存器的第4位被设置为指示制造模式处于活动状态）。 <br><br><img src="https://habrastorage.org/webt/g8/o0/uz/g8o0uzpd71issucllayfbxrd8rq.png"><br><br>  <i>图9. MEInfo实用程序的示例输出</i> <br><br> 我们还开发了程序[ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">7</a> ]，如果用户由于任何原因无法访问英特尔®ME系统工具，您可以使用该程序检查“制造模式”的状态。 <br><br><img src="https://habrastorage.org/webt/nf/wh/ln/nfwhlnhef2gt6wgk1wi45g50h_w.png"><br><br>  <i>图10. mmdetect脚本的示例</i> <br><br> 问题是，如果事实证明制造商没有这样做，如何独立完成制造模式。 为了完成制造模式，FPT实用程序有一个特殊选项–CLOSEMNF，除了其主要用途外，它还允许您为描述符中的SPI闪存区域设置建议的访问权限。 <br><br><img src="https://habrastorage.org/webt/k-/k_/cc/k-k_ccj8vtqnp0p7pbn6rzhe00o.png"><br><br>  <i>图11.使用–CLOSEMNF选项的FTP实用程序结果</i> <br><br> 在此示例中，我们使用–CLOSEMNF选项的NO参数，以便不重新启动平台，默认情况下，在完成制造模式后立即执行该操作。 <br><br><h2> 结论 </h2><br> 我们的研究表明，存在英特尔®ME固件制造模​​式问题，即使是大型制造商（如Apple）也能够在配置英特尔平台时犯错误。 最糟糕的是，没有关于此主题的公共信息，最终用户甚至都不意识到可能导致机密信息丢失，不可移动的rootkit出现以及设备不可撤销的报废的严重问题。 <br><br> 此外，我们怀疑，由于BIOS / UEFI和ME状态不同步，不重启主CPU而重启ME的能力可能会导致其他安全问题。 <br><br>  <b>作者：</b>马克·埃莫洛夫（Mark Ermolov）和马克西姆·高立奇（Maxim Goryachiy） <br><br>  [1] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">英特尔管理引擎关键固件更新，英特尔-SA-00086</a> <br>  [2] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub-chipsec / chipsec：平台安全评估框架</a> <br>  [4] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">快速，安全和灵活的开源固件Coreboot</a> <br>  [5] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Mark Ermolov，Maxim Goryachy，《如何成为PC的唯一所有者》，PHDays VI，2016年</a> <br>  [6] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Mark Ermolov，Maxim Goryachy，通过非文档模式禁用Intel ME 11，Positive Technologies的博客</a> <br>  [7] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">英特尔ME制造模式检测工具</a> <br>  [8] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Alexander Ermolov，保护rootkit：英特尔BootGuard</a> <br>  [9] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Dmitry Sklyarov，Intel ME：闪存文件系统。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">解释</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN425105/">https://habr.com/ru/post/zh-CN425105/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN425093/index.html">用于住房和公共服务的物联网解决方案：智能电表将是什么？谁为它们提供服务？</a></li>
<li><a href="../zh-CN425095/index.html">打开网络研讨会“游戏” 204​​8</a></li>
<li><a href="../zh-CN425099/index.html">创建Hacker News克隆时我了解了什么以及遇到了什么问题</a></li>
<li><a href="../zh-CN425101/index.html">Docker + Laravel =❤</a></li>
<li><a href="../zh-CN425103/index.html">停止Google掠食者追逐孩子</a></li>
<li><a href="../zh-CN425107/index.html">金融科技摘要：移动生物识别问题，三星手机租赁，区块链上的证券</a></li>
<li><a href="../zh-CN425109/index.html">《云中的Java》一书。 Spring Boot，Spring Cloud，Cloud Foundry»</a></li>
<li><a href="../zh-CN425111/index.html">广告招数可能会浪费您的金钱和声誉</a></li>
<li><a href="../zh-CN425113/index.html">“数字印刷术”或我在书籍移动数字化方面的经验</a></li>
<li><a href="../zh-CN425115/index.html">成熟的DevOps：三幕希腊悲剧</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>