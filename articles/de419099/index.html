<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✍🏻 🤐 ✊ WebSockets in Angular. Teil 2. Produktlösungen 👰🏾 🤰🏽 🚝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In einem früheren Artikel haben wir über eine allgemeine Lösung für Web-Sockets in Angular gesprochen, bei der wir einen auf WebSocketSubject basieren...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WebSockets in Angular. Teil 2. Produktlösungen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419099/"><img src="https://habrastorage.org/webt/hf/xh/dl/hfxhdlv7katnrbytwzqmhjy3xom.png" alt="Bild"><br><br>  In einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">früheren Artikel haben</a> wir über eine allgemeine Lösung für Web-Sockets in Angular gesprochen, bei der wir einen auf WebSocketSubject basierenden Bus mit Wiederverbindung und Service für die Verwendung in Komponenten erstellt haben.  Eine solche Implementierung eignet sich für die meisten einfachen Fälle, z. B. zum Empfangen und Senden von Chat-Nachrichten usw., aber ihre Funktionen reichen möglicherweise nicht aus, wenn Sie etwas Flexibleres und Kontrollierteres erstellen müssen.  In diesem Artikel werde ich einige Funktionen beim Arbeiten mit Web-Sockets aufzeigen und über die Anforderungen sprechen, auf die Sie selbst gestoßen sind und auf die Sie möglicherweise stoßen werden. <br><a name="habracut"></a><br>  Bei großen Projekten mit hoher Besucherzahl steht das Front-End häufig vor Aufgaben, die unter anderen Umständen häufiger im Back-End zu sehen sind.  Unter den Bedingungen der Sparsamkeit der Serverressourcen wird ein Teil der Probleme in das Front-End-Gebiet migriert. Aus diesem Grund wird im Projekt ein Maximum an Erweiterbarkeit und Kontrolle festgelegt. <br><br>  Hier ist eine Liste der grundlegenden Anforderungen für einen Web-Socket-Client, die in diesem Artikel behandelt werden: <br><br><ul><li>  Automatische „intelligente“ Wiederverbindung; </li><li>  Debug-Modus; </li><li>  Event-Abonnement-System basierend auf RxJs; </li><li>  Empfang und Analyse von Binärdaten; </li><li>  Projektion (Mapping) der empfangenen Informationen auf das Modell; </li><li>  Kontrolle über Modelländerungen bei Eintreffen neuer Ereignisse; </li><li>  Ignorieren Sie beliebige Ereignisse und brechen Sie das Ignorieren ab. </li></ul><br>  Betrachten Sie jeden Punkt genauer. <br><br><h2>  Erneut verbinden / debaggen </h2><br>  Ich habe in einem früheren Artikel über das Wiederverbinden geschrieben, daher zitiere ich nur einen Teil des Textes: <br><br><blockquote>  Die erneute Verbindung oder die Organisation der erneuten Verbindung zum Server ist ein wichtiger Faktor bei der Arbeit mit Web-Sockets  Netzwerkbrüche, Serverabstürze oder andere Fehler, die einen Verbindungsbruch verursachen, können zum Absturz der Anwendung führen. <br>  Es ist wichtig zu beachten, dass Wiederverbindungsversuche nicht zu häufig sein und nicht auf unbestimmte Zeit fortgesetzt werden sollten  Dieses Verhalten kann den Client anhalten. </blockquote><br>  Der Web-Socket selbst weiß nicht, wie er die Verbindung wiederherstellen soll, wenn die Verbindung getrennt wird.  Wenn der Server neu gestartet oder der Server abgestürzt ist oder der Benutzer das Internet erneut verbunden hat, müssen Sie den Web-Socket erneut verbinden, um weiterarbeiten zu können. <br><br>  In diesem Artikel verwenden wir zum erneuten Verbinden und Debuggen das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reconnecting WebSocket</a> , das die erforderlichen Funktionen und andere Optionen enthält, z. B. das Ändern der URL des Web-Sockets zwischen erneuten Verbindungen, die Auswahl eines beliebigen WebSocket-Konstruktors usw.  Andere Alternativen sind ebenfalls geeignet.  Eine erneute Verbindung aus dem vorherigen Artikel ist nicht geeignet, da  Es ist unter WebSocketSubject geschrieben, was diesmal nicht gilt. <br><br><h2>  RxJs Event-Abonnement-System </h2><br>  Um Web-Sockets in Komponenten zu verwenden, müssen Sie Ereignisse abonnieren und bei Bedarf abbestellen.  Verwenden Sie dazu das beliebte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pub / Sub-</a> Designmuster. <br><blockquote>  "Publisher-Subscriber (engl. Publisher-Subscriber oder eng. Pub / sub) - eine Verhaltensentwurfsvorlage für die Übertragung von Nachrichten, bei der Absender von Nachrichten, sogenannte Publisher (eng. Publishers), nicht direkt an den Programmcode gebunden sind, um Nachrichten an Abonnenten (eng. Subscribers) zu senden )  Stattdessen sind die Nachrichten in Klassen unterteilt und enthalten keine Informationen über ihre Abonnenten, falls vorhanden.  In ähnlicher Weise befassen sich Abonnenten mit einer oder mehreren Klassen von Nachrichten, die von bestimmten Herausgebern abstrahiert werden. “ </blockquote><br>  Der Abonnent kontaktiert den Verlag nicht direkt, sondern über den Zwischenbus - den Website-Service.  Es sollte auch möglich sein, mehrere Ereignisse mit demselben Rückgabetyp zu abonnieren.  Jedes Abonnement erstellt einen eigenen Betreff, der dem Listener-Objekt hinzugefügt wird, sodass Sie Web-Socket-Ereignisse an die erforderlichen Abonnements adressieren können.  Bei der Arbeit mit RxJs Subject treten einige Probleme beim Abbestellen auf. Daher erstellen wir einen einfachen Garbage Collector, der Subjekte aus dem Listener-Objekt entfernt, wenn sie keine Beobachter haben. <br><br><h2>  Empfang und Analyse von Binärdaten </h2><br>  WebSocket unterstützt die Übertragung von Binärdaten, Dateien oder Streams, die häufig in großen Projekten verwendet wird.  Es sieht ungefähr so ​​aus: <br><blockquote>  0x80, &lt;Länge - ein oder mehrere Bytes&gt;, &lt;Nachrichtentext&gt; </blockquote><br>  Um die Länge der übertragenen Nachricht nicht einzuschränken und gleichzeitig keine irrationalen Bytes auszugeben, verwendeten die Protokollentwickler den folgenden Algorithmus.  Jedes Byte in der Längenangabe wird separat betrachtet: Das höchste gibt an, ob es das letzte Byte (0) ist oder die anderen (1) folgen, und die unteren 7 Bits enthalten die übertragenen Daten.  Wenn daher das Vorzeichen des binären Datenrahmens 0x80 erscheint, wird das nächste Byte genommen und in einem separaten "Sparschwein" gespeichert.  Dann wird das nächste Byte, wenn das höchstwertige Bit gesetzt ist, ebenfalls an das "Sparschwein" usw. übertragen, bis das Byte mit dem höchstwertigen Bit Null angetroffen wird.  Dieses Byte ist das letzte im Längenindikator und wird auch dem „Sparschwein“ hinzugefügt.  Jetzt werden die hohen Bits aus den Bytes im Sparschwein entfernt und der Rest kombiniert.  Dies ist die Länge des Nachrichtentexts - 7-Bit-Zahlen ohne das höchstwertige Bit. <br><br>  Der Front-End-Parsing- und Binär-Stream-Mechanismus ist komplex und mit der Datenzuordnung im Modell verbunden.  Diesem kann ein separater Artikel gewidmet werden.  Dieses Mal werden wir eine einfache Option analysieren und schwierige Fälle für die folgenden Veröffentlichungen belassen, wenn Interesse an dem Thema besteht. <br><br><h2>  Projektion (Mapping) der empfangenen Informationen auf das Modell </h2><br>  Unabhängig von der Art der empfangenen Übertragung ist es erforderlich, sicher zu lesen und zu ändern.  Es gibt keinen Konsens darüber, wie dies besser gemacht werden kann. Ich halte mich an die Theorie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eines Datenmodells</a> , da ich es für logisch und zuverlässig halte, um im OOP-Stil zu programmieren. <br><blockquote>  „Ein Datenmodell ist eine abstrakte, autarke, logische Definition von Objekten, Operatoren und anderen Elementen, die zusammen eine abstrakte Datenzugriffsmaschine bilden, mit der der Benutzer interagiert.  "Mit diesen Objekten können Sie die Datenstruktur und die Operatoren modellieren - das Verhalten der Daten." </blockquote><br>  Alle Arten von populären Reifen, die keine Vorstellung von einem Objekt als einer Klasse vermitteln, in der Verhalten, Struktur usw. definiert sind, sorgen für Verwirrung, sind weniger gut kontrolliert und manchmal mit etwas bewachsen, das für sie nicht typisch ist.  Zum Beispiel sollte eine Hundeklasse einen Hund unter allen Bedingungen beschreiben.  Wenn der Hund als eine Reihe von Feldern wahrgenommen wird: Schwanz, Farbe, Gesicht usw., kann der Hund eine zusätzliche Pfote wachsen lassen und ein anderer Hund erscheint anstelle des Kopfes. <br><br><img src="https://habrastorage.org/webt/sq/fa/xu/sqfaxulbeyaffws-46gxho3-dcg.jpeg" alt="Bild"><br><br><h2>  Kontrolle über Modelländerungen bei Eintreffen neuer Ereignisse </h2><br>  In diesem Abschnitt werde ich das Problem beschreiben, auf das ich bei der Arbeit an der Weboberfläche der mobilen Sportwettenanwendung gestoßen bin.  Die Anwendungs-API arbeitete über Web-Sockets, über die sie empfangen wurden: Aktualisieren von Quoten, Hinzufügen und Entfernen neuer Arten von Wetten, Benachrichtigungen über den Beginn oder das Ende eines Spiels usw.  - Insgesamt etwa dreihundert Ereignisse des Web-Sockets.  Während des Spiels werden Wetten und Informationen ständig aktualisiert, manchmal 2-3 Mal pro Sekunde. Das Problem war also, dass die Benutzeroberfläche danach ohne Zwischenkontrolle aktualisiert wurde. <br><br>  Wenn der Benutzer das Gebot von einem mobilen Gerät aus überwachte und gleichzeitig die Listen auf seinem Display aktualisiert wurden, verschwand das Gebot aus dem Sichtfeld, sodass der Benutzer erneut nach dem nachverfolgten Gebot suchen musste.  Dieses Verhalten wurde für jedes Update wiederholt. <br><br><img src="https://habrastorage.org/webt/tq/5p/e8/tq5pe8qxiepdjj7dx5-jry10bjs.gif" alt="Bild"><br><br>  Die Lösung erforderte Unveränderlichkeit für die Objekte, die auf dem Bildschirm angezeigt wurden, aber gleichzeitig mussten sich die Wettkoeffizienten ändern, irrelevante Gebote wurden inaktiv und neue wurden erst hinzugefügt, nachdem der Benutzer den Bildschirm gescrollt hatte.  Veraltete Optionen wurden nicht im Backend gespeichert, daher mussten solche Zeilen gespeichert und mit dem Flag "Gelöscht" gekennzeichnet werden, für das ein Zwischendatenspeicher zwischen dem Web-Socket und dem Abonnement erstellt wurde, der die Kontrolle über die Änderungen sicherstellte. <br><br>  In dem neuen Dienst werden wir auch eine Ersatzschicht erstellen und dieses Mal <a href="">Dexie.js verwenden</a> - einen Wrapper über die IndexedDB-API, aber jede andere virtuelle oder Browser-Datenbank wird dies tun.  Redux ist akzeptabel. <br><br><h2>  Ignorieren Sie beliebige Ereignisse und brechen Sie das Ignorieren ab </h2><br>  In derselben Firma gibt es häufig mehrere Projekte desselben Typs gleichzeitig: Mobil- und Webversionen, Versionen mit unterschiedlichen Einstellungen für unterschiedliche Benutzergruppen, erweiterte und abgeschnittene Versionen derselben Anwendung. <br><br>  Oft verwenden alle eine einzige Codebasis, so dass Sie manchmal unnötige Ereignisse zur Laufzeit oder während der DI deaktivieren müssen, ohne das Abonnement zu löschen und erneut zu aktivieren, d. H.  Ignorieren Sie einige von ihnen, um unnötige Ereignisse nicht zu verarbeiten.  Dies ist eine einfache, aber nützliche Funktion, die dem Pub / Sub-Bus mehr Flexibilität verleiht. <br><br>  Beginnen wir mit einer Beschreibung der Schnittstellen: <br><br><pre><code class="hljs cmake"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> interface IWebsocketService { //    addEventListener&lt;T&gt;(topics: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[], id?: number): Observable&lt;T&gt;; runtimeIgnore(topics: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[]): void; runtimeRemoveIgnore(topics: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[]): void; sendMessage(event: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, data: any): void; } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> interface WebSocketConfig { //   DI url: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; ignore?: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[]; garbageCollectInterval?: number; options?: Options; } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> interface ITopic&lt;T&gt; { //   Pub/Sub [hash: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]: MessageSubject&lt;T&gt;; } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> interface IListeners { //    [topic: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]: ITopic&lt;any&gt;; } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> interface IBuffer { //    ws.<span class="hljs-keyword"><span class="hljs-keyword">message</span></span> type: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; data: number[]; } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> interface IWsMessage { // ws.<span class="hljs-keyword"><span class="hljs-keyword">message</span></span> event: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; buffer: IBuffer; } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> interface IMessage { //   id: number; text: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> type ITopicDataType = IMessage[] | number | <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[]; //  callMessage  </code> </pre> <br>  Wir werden Subject erben, um einen Garbage Collector zu erstellen: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MessageSubject</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subject</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( private listeners: IListeners, //    private topic: string, //   private id: string // id  ) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); } <span class="hljs-comment"><span class="hljs-comment">/* *   next, *       , *   garbageCollect */</span></span> public next(value?: T): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.closed) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectUnsubscribedError(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isStopped) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {observers} = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> len = observers.length; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> copy = observers.slice(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; i++) { copy[i].next(value); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!len) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.garbageCollect(); <span class="hljs-comment"><span class="hljs-comment">//   } } } /* * garbage collector * */ private garbageCollect(): void { delete this.listeners[this.topic][this.id]; //  Subject if (!Object.keys(this.listeners[this.topic]).length) { //    delete this.listeners[this.topic]; } } }</span></span></code> </pre> <br>  Im Gegensatz zur vorherigen Implementierung ist websocket.events.ts Teil des Web-Socket-Moduls <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> WS_API = { <span class="hljs-attr"><span class="hljs-attr">EVENTS</span></span>: { <span class="hljs-attr"><span class="hljs-attr">MESSAGES</span></span>: <span class="hljs-string"><span class="hljs-string">'messages'</span></span>, <span class="hljs-attr"><span class="hljs-attr">COUNTER</span></span>: <span class="hljs-string"><span class="hljs-string">'counter'</span></span>, <span class="hljs-attr"><span class="hljs-attr">UPDATE_TEXTS</span></span>: <span class="hljs-string"><span class="hljs-string">'update-texts'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">COMMANDS</span></span>: { <span class="hljs-attr"><span class="hljs-attr">SEND_TEXT</span></span>: <span class="hljs-string"><span class="hljs-string">'set-text'</span></span>, <span class="hljs-attr"><span class="hljs-attr">REMOVE_TEXT</span></span>: <span class="hljs-string"><span class="hljs-string">'remove-text'</span></span> } };</code> </pre> <br>  Erstellen Sie zur Konfiguration beim Anschließen des Moduls die Datei websocket.config: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { InjectionToken } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> config: InjectionToken&lt;string&gt; = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InjectionToken(<span class="hljs-string"><span class="hljs-string">'websocket'</span></span>);</code> </pre> <br>  Erstellen Sie ein Modell für Proxy: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Dexie <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'dexie'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { IMessage, IWsMessage } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./websocket.interfaces'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { WS_API } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./websocket.events'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MessagesDatabase extends Dexie { //    Dexie  typescript <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> messages!: Dexie.<span class="hljs-keyword"><span class="hljs-keyword">Table</span></span>&lt;IMessage, number&gt;; // id <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> number <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> this <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> constructor() { super(<span class="hljs-string"><span class="hljs-string">'MessagesDatabase'</span></span>); //   this.version(<span class="hljs-number"><span class="hljs-number">1</span></span>).stores({ //   messages: <span class="hljs-string"><span class="hljs-string">'++id,text'</span></span> }); } }</code> </pre> <br>  Als einfacher Modellparser ist es unter realen Bedingungen besser, ihn in mehrere Dateien aufzuteilen: <br><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">export</span></span> const modelParser = (message: <span class="hljs-type"><span class="hljs-type">IWsMessage</span></span>) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (message &amp;&amp; message.buffer) { /*  */ const encodeUint8Array = <span class="hljs-type"><span class="hljs-type">String</span></span>.fromCharCode .apply(<span class="hljs-type"><span class="hljs-type">String</span></span>, new <span class="hljs-type"><span class="hljs-type">Uint8Array</span></span>(message.buffer.<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">)); const parseData = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">JSON</span></span></span><span class="hljs-class">.parse(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">encodeUint8Array</span></span></span><span class="hljs-class">); let </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MessagesDB</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MessagesDatabase</span></span></span><span class="hljs-class">; // </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IndexedDB</span></span></span><span class="hljs-class"> if (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">message</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class"> === </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WS_API</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EVENTS</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MESSAGES</span></span></span><span class="hljs-class">) { // </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IMessage</span></span></span><span class="hljs-class">[] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">if</span></span></span><span class="hljs-class"> (!</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MessagesDB</span></span></span><span class="hljs-class">) { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MessagesDB</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MessagesDatabase</span></span></span><span class="hljs-class">(); } parseData.forEach((</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">messageData</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IMessage</span></span></span><span class="hljs-class">) =&gt; { /*   */ </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MessagesDB</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">transaction</span></span></span><span class="hljs-class">('</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rw'</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MessagesDB</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">messages</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">async</span></span></span><span class="hljs-class"> () =&gt; { /* ,    */ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">if</span></span></span><span class="hljs-class"> ((</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">await</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MessagesDB</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">messages</span></span></span><span class="hljs-class"> .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class">({</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">messageData</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">}).count()) === 0) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">await</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MessagesDB</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">messages</span></span></span><span class="hljs-class"> .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">add</span></span></span><span class="hljs-class">({</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">messageData</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">text</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">messageData</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">text</span></span></span><span class="hljs-class">}); console.log(`</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addded</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">message</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class"> ${</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">}`); } }).catch(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">e</span></span></span><span class="hljs-class"> =&gt; { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">console</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">error</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">e</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack</span></span></span><span class="hljs-class"> || </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">e</span></span></span><span class="hljs-class">); }); }); return </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MessagesDB</span></span></span><span class="hljs-class">.messages.toArray(); //   </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IMessage</span></span></span><span class="hljs-class">[] } if (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">message</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class"> === </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WS_API</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EVENTS</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">COUNTER</span></span></span><span class="hljs-class">) { // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">counter</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Promise</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class"> =&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parseData</span></span></span><span class="hljs-class">)); //    } if (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">message</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class"> === </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WS_API</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EVENTS</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UPDATE_TEXTS</span></span></span><span class="hljs-class">) { // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">text</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">texts</span></span></span><span class="hljs-class"> = []; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parseData</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">forEach</span></span></span><span class="hljs-class">((</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">textData</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">) =&gt; { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">texts</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">push</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">textData</span></span></span><span class="hljs-class">); }); return new </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Promise</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class"> =&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">texts</span></span></span><span class="hljs-class">)); //     } } else { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">console</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">log</span></span></span><span class="hljs-class">(`[${</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Date</span></span></span><span class="hljs-class">()}] </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Buffer</span></span></span><span class="hljs-class"> is "undefined"`); } };</span></span></code> </pre> <br>  WebsocketModule: <br><br><pre> <code class="hljs powershell">@NgModule({ imports: [ <span class="hljs-type"><span class="hljs-type">CommonModule</span></span> ] }) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WebsocketModule</span></span></span></span> { public <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> config(wsConfig: WebSocketConfig): ModuleWithProviders { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ngModule: WebsocketModule, providers: [{<span class="hljs-type"><span class="hljs-type">provide</span></span>: <span class="hljs-type"><span class="hljs-type">config</span></span>, <span class="hljs-type"><span class="hljs-type">useValue</span></span>: <span class="hljs-type"><span class="hljs-type">wsConfig</span></span>}] }; } }</code> </pre> <br>  Beginnen wir mit der Erstellung eines Dienstes: <br><br><pre> <code class="hljs ruby">private <span class="hljs-symbol"><span class="hljs-symbol">listeners:</span></span> IListeners; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   private <span class="hljs-symbol"><span class="hljs-symbol">uniqueId:</span></span> number; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   id  private <span class="hljs-symbol"><span class="hljs-symbol">websocket:</span></span> ReconnectingWebSocket; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   constructor(@Inject(config) private <span class="hljs-symbol"><span class="hljs-symbol">wsConfig:</span></span> WebSocketConfig) { this.uniqueId = -<span class="hljs-number"><span class="hljs-number">1</span></span>; this.listeners = {}; this.wsConfig.ignore = wsConfig.ignore ? wsConfig.ignore : []; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  this.connect(); } ngOnDestroy() { this.websocket.close(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     }</code> </pre> <br>  Verbindungsmethode: <br><br><pre> <code class="hljs coffeescript">private connect(): void { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ReconnectingWebSocket config const options = { connectionTimeout: <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,    maxRetries: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,    ...<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wsConfig.options }; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.websocket = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReconnectingWebSocket(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wsConfig.url, [], options); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.websocket.addEventListener(<span class="hljs-string"><span class="hljs-string">'open'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: Event)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(`<span class="javascript"><span class="javascript">[${</span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">Date</span></span></span><span class="javascript">()}] WebSocket connected!</span></span>`); }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.websocket.addEventListener(<span class="hljs-string"><span class="hljs-string">'close'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: CloseEvent)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(`<span class="javascript"><span class="javascript">[${</span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">Date</span></span></span><span class="javascript">()}] WebSocket close!</span></span>`); }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.websocket.addEventListener(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: ErrorEvent)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(`<span class="javascript"><span class="javascript">[${</span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">Date</span></span></span><span class="javascript">()}] WebSocket error!</span></span>`); }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.websocket.addEventListener(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: MessageEvent)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onMessage(event); }); setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.garbageCollect(); }, (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wsConfig.garbageCollectInterval || <span class="hljs-number"><span class="hljs-number">10000</span></span>)); }</code> </pre> <br>  Wenn Sie den Garbage Collector duplizieren, wird nach Zeitüberschreitung nach Abonnements gesucht: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">garbageCollect</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>): </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listeners) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listeners.hasOwnProperty(<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> topic = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listeners[<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> topic) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (topic.hasOwnProperty(key)) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> subject = topic[key]; <span class="hljs-comment"><span class="hljs-comment">//  Subject    if (!subject.observers.length) { delete topic[key]; } } }  ,   if (!Object.keys(topic).length) { delete this.listeners[event]; } } } }</span></span></code> </pre> <br>  Wir prüfen, welches Abonnement die Veranstaltung senden soll: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> onMessage(event: MessageEvent): void { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> message = JSON.parse(event.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listeners) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listeners.hasOwnProperty(name) &amp;&amp; !<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wsConfig.ignore.includes(name)) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> topic = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listeners[name]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> keys = name.split(<span class="hljs-string"><span class="hljs-string">'/'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      const isMessage = keys.includes(message.event); const model = modelParser(message); //     if (isMessage &amp;&amp; typeof model !== 'undefined') { model.then((data: ITopicDataType) =&gt; { //   Subject this.callMessage&lt;ITopicDataType&gt;(topic, data); }); } } } }</span></span></code> </pre> <br>  Helmveranstaltung im Betreff: <br><br><pre> <code class="hljs powershell">private callMessage&lt;T&gt;(topic: ITopic&lt;T&gt;, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: T): void { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (const key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> topic) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (topic.hasOwnProperty(key)) { const subject = topic[<span class="hljs-type"><span class="hljs-type">key</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (subject) { //   subject.next(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { console.log(`[<span class="hljs-variable"><span class="hljs-variable">$</span></span>{Date()}] Topic Subject is <span class="hljs-string"><span class="hljs-string">"undefined"</span></span>`); } } } }</code> </pre> <br>  Pub / Unterthema erstellen: <br><br><pre> <code class="hljs markdown">private addTopic<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>(topic: string, id?: number): MessageSubject<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> { const token = (++this.uniqueId).toString(); const key = id ? token + id : token; //  id   const hash = sha256.hex(key); // SHA256-   id  if (!this.listeners[<span class="hljs-string"><span class="hljs-string">topic</span></span>]) { this.listeners[<span class="hljs-string"><span class="hljs-string">topic</span></span>] = <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">any</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>{}; } return this.listeners[<span class="hljs-string"><span class="hljs-string">topic</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">hash</span></span>] = new MessageSubject<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>(this.listeners, topic, hash); }</code> </pre> <br>  Abonnieren einer oder mehrerer Veranstaltungen: <br><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> addEventListener&lt;T&gt;(topics: string | string[], id?: number): Observable&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (topics) { //       const topicsKey = typeof topics === <span class="hljs-string"><span class="hljs-string">'string'</span></span> ? topics : topics.<span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(<span class="hljs-string"><span class="hljs-string">'/'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.addTopic&lt;T&gt;(topicsKey, id).asObservable(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { console.log(`[${<span class="hljs-type"><span class="hljs-type">Date</span></span>()}] Can<span class="hljs-string"><span class="hljs-string">'t add EventListener. Type of event is "undefined".`); } }</span></span></code> </pre> <br>  Alles hier ist absichtlich vereinfacht, kann aber wie beim Server in binäre Entitäten konvertiert werden.  Senden von Befehlen an den Server: <br><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> sendMessage(event: string, data: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> = {}): <span class="hljs-type"><span class="hljs-type">void</span></span> { //   ,      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event &amp;&amp; this.websocket.readyState === <span class="hljs-number"><span class="hljs-number">1</span></span>) { this.websocket.send(<span class="hljs-type"><span class="hljs-type">JSON</span></span>.stringify({event, data})); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { console.log(<span class="hljs-string"><span class="hljs-string">'Send error!'</span></span>); } }</code> </pre> <br>  Hinzufügen von Ereignissen zur Ignorierliste zur Laufzeit: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runtimeIgnore</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">topics: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[]</span></span></span><span class="hljs-function">): </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (topics &amp;&amp; topics.length) { <span class="hljs-comment"><span class="hljs-comment">//    this.wsConfig.ignore.push(...topics); } }</span></span></code> </pre> <br>  Ereignisse aus der Ignorierliste löschen: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runtimeRemoveIgnore</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">topics: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[]</span></span></span><span class="hljs-function">): </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (topics &amp;&amp; topics.length) { topics.forEach((topic: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) =&gt; { <span class="hljs-comment"><span class="hljs-comment">//      const topicIndex = this.wsConfig.ignore.findIndex(t =&gt; t === topic); if (topicIndex &gt; -1) { //    this.wsConfig.ignore.splice(topicIndex, 1); } }); } }</span></span></code> </pre> <br>  Wir verbinden das Modul der Web-Sockets: <br><br><pre> <code class="hljs powershell">@NgModule({ declarations: [ <span class="hljs-type"><span class="hljs-type">AppComponent</span></span> ], imports: [ <span class="hljs-type"><span class="hljs-type">BrowserModule</span></span>, <span class="hljs-type"><span class="hljs-type">ReactiveFormsModule</span></span>, <span class="hljs-type"><span class="hljs-type">WebsocketModule.config</span></span>({ <span class="hljs-type"><span class="hljs-type">url</span></span>: <span class="hljs-type"><span class="hljs-type">environment.ws</span></span>, //  <span class="hljs-string"><span class="hljs-string">"ws://mywebsocketurl"</span></span> //    <span class="hljs-type"><span class="hljs-type">ignore</span></span>: [<span class="hljs-type"><span class="hljs-type">WS_API.EVENTS.ANY_1</span></span>, <span class="hljs-type"><span class="hljs-type">WS_API.EVENTS.ANY_2</span></span>], <span class="hljs-type"><span class="hljs-type">garbageCollectInterval</span></span>: <span class="hljs-number"><span class="hljs-number">60</span></span> * <span class="hljs-number"><span class="hljs-number">1000</span></span>, //    <span class="hljs-type"><span class="hljs-type">options</span></span>: { <span class="hljs-type"><span class="hljs-type">connectionTimeout</span></span>: <span class="hljs-number"><span class="hljs-number">1000</span></span>, //   <span class="hljs-type"><span class="hljs-type">maxRetries</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span> //   } }) ], providers: [], bootstrap: [<span class="hljs-type"><span class="hljs-type">AppComponent</span></span>] }) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span></span> { }</code> </pre> <br>  Wir verwenden in den Komponenten: <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'app-root'</span></span></span><span class="hljs-meta">, templateUrl: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'./app.component.html'</span></span></span><span class="hljs-meta">, styleUrls: [</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'./app.component.css'</span></span></span><span class="hljs-meta">] })</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnInit</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">OnDestroy { private messages$: Observable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IMessage[]</span></span></span><span class="hljs-class">&gt;; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">private</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">messagesMulti</span></span></span><span class="hljs-class">$: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Observable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IMessage[]</span></span></span><span class="hljs-class">&gt;; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">private</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">counter</span></span></span><span class="hljs-class">$: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Observable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">number</span></span></span><span class="hljs-class">&gt;; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">private</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">texts</span></span></span><span class="hljs-class">$: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Observable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">string[]</span></span></span><span class="hljs-class">&gt;; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">public</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">form</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FormGroup; constructor</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> fb: FormBuilder, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> wsService: WebsocketService) { } ngOnInit() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.form = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fb.group({ text: [<span class="hljs-literal"><span class="hljs-literal">null</span></span>, [ Validators.required ]] }); <span class="hljs-comment"><span class="hljs-comment">// get messages this.messages$ = this.wsService .addEventListener&lt;IMessage[]&gt;(WS_API.EVENTS.MESSAGES); // get messages multi this.messagesMulti$ = this.wsService .addEventListener&lt;IMessage[]&gt;([ WS_API.EVENTS.MESSAGES, WS_API.EVENTS.MESSAGES_1 ]); // get counter this.counter$ = this.wsService .addEventListener&lt;number&gt;(WS_API.EVENTS.COUNTER); // get texts this.texts$ = this.wsService .addEventListener&lt;string[]&gt;(WS_API.EVENTS.UPDATE_TEXTS); } ngOnDestroy() { } public sendText(): void { if (this.form.valid) { this.wsService .sendMessage(WS_API.COMMANDS.SEND_TEXT, this.form.value.text); this.form.reset(); } } public removeText(index: number): void { this.wsService.sendMessage(WS_API.COMMANDS.REMOVE_TEXT, index); } }</span></span></code> </pre> <br>  Der Dienst ist einsatzbereit. <br><br><hr><br>  Obwohl das Beispiel aus dem Artikel nicht für jedes Projekt eine universelle Lösung darstellt, zeigt es einen der Ansätze für die Arbeit mit Web-Sockets in großen und komplexen Anwendungen.  Sie können es in Betrieb nehmen und je nach aktuellen Aufgaben ändern. <br><br>  Die Vollversion des Dienstes finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> . <br><br>  Bei allen Fragen können Sie sich in den Kommentaren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">an mich</a> per Telegramm oder auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den dortigen Angular-Kanal</a> wenden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de419099/">https://habr.com/ru/post/de419099/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de419085/index.html">Die Idee der Singularität vor dem Urknall ist veraltet</a></li>
<li><a href="../de419087/index.html">Den Verstand eines anderen zu verstehen, ist ein Mythos</a></li>
<li><a href="../de419091/index.html">Radioaktive Objekte unter uns</a></li>
<li><a href="../de419095/index.html">Wir schreiben CSS besser und schöner</a></li>
<li><a href="../de419097/index.html">Mambot - ein Bot im Telegramm für schwangere Frauen</a></li>
<li><a href="../de419101/index.html">Erstelle ein Spiel bei Nacht Hackathon</a></li>
<li><a href="../de419103/index.html">Schreiben eines einfachen Übersetzers in Lisp - I.</a></li>
<li><a href="../de419105/index.html">Link zur Slurm-Sendung (Kubernetes Intensive)</a></li>
<li><a href="../de419107/index.html">Beispiele für die Übersicht und Konfiguration von Dell EMC Unity-Dateien</a></li>
<li><a href="../de419109/index.html">Erklären Sie die Pony in Android P. Was tun mit Android Cutout?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>