<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🚀 💭 🤛🏿 Mon expérience dans la création d'une application multi-thread pour travailler avec des sauvegardes 🙀 🙎 💀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pour le moment, vous ne surprendrez personne avec des applications multithreads, mais je pense que dans cet article, vous pouvez trouver des idées int...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mon expérience dans la création d'une application multi-thread pour travailler avec des sauvegardes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459478/"><p>  Pour le moment, vous ne surprendrez personne avec des applications multithreads, mais je pense que dans cet article, vous pouvez trouver des idées intéressantes.  Mon étude de Java a commencé avec ce projet, donc peut-être qu'à certains endroits je me tromperai ou je construirai un gros vélo, mais j'espère que quelqu'un sera intéressé par l'expérience d'un débutant en Java.  Je vais vous donner plusieurs fonctionnalités de l'application: </p><br><ul><li>  Il fonctionne avec des sauvegardes exclusivement en mémoire, quelle que soit la taille de la sauvegarde </li><li>  Ne charge pas la sauvegarde entière en mémoire </li><li>  Les opérations de sauvegarde / restauration peuvent être annulées </li></ul><br><p>  Sous la coupe sera considérée l'architecture de l'application, ainsi que les principaux problèmes rencontrés et leur solution. </p><a name="habracut"></a><br><h2 id="obzor-prilozheniya">  Présentation de l'application </h2><br><p>  La communication avec l'application se fait via l'interface utilisateur Web, mais à l'avenir, il sera possible d'ajouter une API REST si nécessaire. </p><br><p>  L'application peut: </p><br><ol><li>  Créez des sauvegardes et téléchargez-les sur un ou plusieurs stockages </li><li>  Restaurez les sauvegardes en les chargeant du stockage </li><li>  Supprimer les sauvegardes de tous les stockages </li><li>  Créez périodiquement des sauvegardes </li></ol><br><p>  Référentiels actuellement pris en charge: </p><br><ul><li>  Système de fichiers local (non pris en charge par Docker) </li><li>  Dropbox </li></ul><br><p>  Bases de données actuellement prises en charge: </p><br><ul><li>  PostgreSQL </li></ul><br><p>  A partir d'une application spéciale, je peux noter: </p><br><ol><li>  Travail correct dans une configuration de cluster </li><li>  Une sauvegarde n'est jamais entièrement chargée en mémoire, quelle que soit la taille de la sauvegarde.  Le système de fichiers pour le stockage de sauvegarde temporaire n'est pas non plus impliqué.  La création d'une sauvegarde et la restauration, et donc le chargement / déchargement d'une sauvegarde, se produisent exclusivement en mémoire. </li><li>  Multiplateforme - fonctionne sur Windows et Linux. </li><li>  Nous pouvons surveiller toutes les tâches en cours d'exécution et les annuler si nécessaire. </li></ol><br><p>  Vous trouverez ci-dessous des captures d'écran de l'interface utilisateur Web qui décrivent clairement les fonctionnalités de l'application. </p><br><div class="spoiler">  <b class="spoiler_title">Gestion du stockage</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/vl/qg/n5/vlqgn5f58ub5jhxixeeg2uq-oa8.png" title="Ajout de stockage"></a> <br> <a href=""><img src="https://habrastorage.org/webt/oj/o5/uj/ojo5uj_raxkwd1btsjrktiowifo.png" title="Liste de stockage"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Gestion de base de données</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/wn/6p/bk/wn6pbkcqg4qu_9btgrvnqm3l7x0.png" title="Ajout d'une base de données"></a> <br> <a href=""><img src="https://habrastorage.org/webt/wu/9a/4k/wu9a4ky7icuiyqdxeiii9xbu5d8.png" title="Liste des bases de données"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Création de sauvegarde</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/1d/zb/6s/1dzb6scvtua5v3m_3l11lch4rgm.png" title="Création de sauvegarde"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Récupération de sauvegarde</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/gj/9f/w0/gj9fw0onqw7f0lf7ycw05aphinc.png" title="Récupération de sauvegarde"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Gérer les sauvegardes créées</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/sy/jz/y6/syjzy68wqxgi8smgq74giqstgu0.png" title="Liste des sauvegardes créées"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Sauvegardes périodiques</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/hk/pw/tg/hkpwtg3kf7c5ho3f7ae7_uos7v0.png" title="Créer une tâche périodique"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Suivre les tâches en cours</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/al/dt/su/aldtsuel4amtjlvbbbusccxddh0.png" title="Liste des tâches en cours d'exécution"></a> </p></div></div><br><hr><br><h2 id="arhitektura">  L'architecture </h2><br><p>  Le travail principal se déroulera dans 3 services - <em>DatabaseBackup</em> , <em>Processor</em> , <em>Storage</em> , et nous les relierons ensemble en utilisant le <em>concept de tâches</em> .  À propos de tout cela plus loin. </p><br><h3 id="databasebackup">  Sauvegarde de la base de données </h3><br><p>  Ce service est responsable de la création et de la restauration des sauvegardes en texte brut. </p><br><p>  Interface de service: </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DatabaseBackup</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">InputStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createBackup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DatabaseSettings databaseSettings, Integer id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restoreBackup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputStream in, DatabaseSettings databaseSettings, Integer id)</span></span></span></span>; }</code> </pre> <br><p>  Les deux méthodes d'interface fonctionnent sur les instances <strong>InputStream</strong> , car nous avons besoin que la sauvegarde entière ne soit pas chargée en mémoire, ce qui signifie que la sauvegarde doit être lue / écrite en mode streaming.  L'entité <em>DatabaseSettings</em> est pré-créée à partir de l'interface utilisateur Web et stocke les différents paramètres nécessaires pour accéder à la base de données.  Quel est ce paramètre - <code>id</code> - sera expliqué un peu plus loin. </p><br><p>  Les exigences de service sont les suivantes: </p><br><ol><li>  Les deux méthodes ne doivent pas lire l'intégralité de la sauvegarde en mémoire. </li><li>  La méthode <code>restoreBackup()</code> doit restaurer la sauvegarde en une seule transaction, afin qu'en cas d'erreur, ne laissez pas la base de données dans un état incohérent. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Implémentation pour PostgreSQL (description textuelle)</b> <div class="spoiler_text"><p>  Plus précisément, dans l'implémentation de PostgreSQL, le service est implémenté comme suit: </p><br><ol><li>  <code>createBackup()</code> : un processus <em>pg_dump</em> est créé qui créera une sauvegarde et l'écrira dans le flux de sortie standard.  Le flux de sortie de processus standard est renvoyé par la méthode (voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://docs.oracle.com/javase/8/docs/api/java/lang/Process.html#getInputStream--</a> ).  Les flux d'E / S dans le système sont basés sur un tampon d'une certaine taille, et lorsqu'un processus écrit dans le flux de sortie, il écrit réellement dans le tampon en mémoire.  La chose la plus importante ici est que le thread de processus n'écrira pas dans le tampon <em>rempli</em> jusqu'à ce que ce dernier ait été lu par l'autre côté, ce qui signifie que le thread sera dans un état verrouillé et que la sauvegarde ne sera pas complètement chargée en mémoire.  Vous avez peut-être rencontré une situation dans laquelle votre programme Java a rencontré un blocage lors de l'utilisation de processus en raison du fait que vous n'avez pas lu la stdout ou la stderr du processus.  Il est extrêmement important de surveiller cela, car le processus ne peut pas continuer s'il est bloqué sur un appel de blocage d'E / S lors de l'écriture dans un tampon complet et que personne ne lit ce tampon. </li><li>  <code>restoreBackup()</code> : un processus <em>psql</em> est créé, la sauvegarde est lue à partir du <code>restoreBackup()</code> transmis à la méthode et est simultanément écrite dans le flux d'entrée standard psql (voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://docs.oracle.com/javase/8/docs/api/java/lang/Process. html # getOutputStream--</a> ).  Cela fonctionne parce que la sauvegarde PostgreSQL en texte brut n'est qu'une collection de commandes DDL et DML faciles à comprendre psql. </li></ol><br><p>  Il y a beaucoup de code, donc je ne le donnerai pas ici, mais vous pouvez le voir sur GitHub en utilisant le lien à la fin de l'article. </p></div></div><br><h3 id="processor">  Processeur </h3><br><p>  Ce service est responsable de l'utilisation des processeurs et du retraitement des sauvegardes inversées.  Les processeurs sont utilisés avant le téléchargement vers le stockage ou après le déchargement du stockage.  Exemple de processeur: compresseur, cryptage. </p><br><p>  Interface de service: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Processor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">InputStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputStream in)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">InputStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deprocess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputStream in)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">ProcessorType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ProcessorType -  Enum,     int getPrecedence(); //   }</span></span></code> </pre> <br><p>  Chaque processeur a la priorité - si plusieurs processeurs sont spécifiés, ils seront appliqués par ordre décroissant de priorité.  En appliquant la fonction inverse dans le même ordre dans lequel les processeurs ont été appliqués, nous obtenons la sauvegarde d'origine. </p><br><h3 id="storage">  Stockage </h3><br><p>  Ce service est responsable du chargement et du déchargement d'une sauvegarde, ainsi que de sa suppression du stockage.  Exemple de stockage: Dropbox, système de fichiers local. </p><br><p>  Interface de service: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Storage</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uploadBackup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputStream in, StorageSettings storageSettings, String backupName, Integer id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">InputStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBackup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StorageSettings storageSettings, String backupName, Integer id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deleteBackup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StorageSettings storageSettings, String backupName, Integer id)</span></span></span></span>; }</code> </pre> <br><p>  Chaque sauvegarde créée se voit attribuer un nom unique - afin que nous puissions la trouver sur l'un des stockages sur lesquels elle a été téléchargée.  La façon dont la sauvegarde est présentée au stockage dépend exclusivement de la mise en œuvre du service, mais lors du transfert du nom de la sauvegarde vers l'une des fonctions, nous devons nous attendre au comportement correct.  L'entité <em>StorageSettings</em> est pré-créée à partir de l'interface utilisateur Web et stocke les paramètres nécessaires pour accéder au stockage. </p><br><hr><br><h3 id="koncepciya-taskov">  Concept de tâche </h3><br><p>  Nous aimerions pouvoir suivre l'état de nos tâches, gérer les erreurs possibles en fonction de l'avancement de la tâche et également annuler les tâches.  Par conséquent, nous continuerons à fonctionner uniquement avec des tâches.  Chaque tâche sera représentée dans la base de données par un enregistrement dans le tableau et par programme par l'instance <strong>Future</strong> (voir Java <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Future</a> ).  Chaque enregistrement de la table est associé à son propre Future (de plus, si plusieurs serveurs sont en cours d'exécution, les instances Future peuvent être dans la mémoire de différents serveurs). </p><br><p>  Allons séquentiellement.  Tout d'abord, nous avons besoin d'un service pour lancer des tâches - création, restauration et suppression de sauvegardes. </p><br><h4 id="zapusk-zadach">  Lancement de la tâche </h4><br><p>  <strong>Création d'une sauvegarde:</strong> </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startBackupTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Task.RunType runType, @NotNull List&lt;String&gt; storageSettingsNameList, @Nullable List&lt;ProcessorType&gt; processors, @NotNull DatabaseSettings databaseSettings)</span></span></span><span class="hljs-function"> </span></span>{ Objects.requireNonNull(runType); Objects.requireNonNull(storageSettingsNameList); Objects.requireNonNull(processors); Objects.requireNonNull(databaseSettings); BackupProperties backupProperties = backupPropertiesManager.initNewBackupProperties(storageSettingsNameList, processors, databaseSettings.getName()); Task task = tasksManager.initNewTask(Task.Type.CREATE_BACKUP, runType, backupProperties.getId()); Integer taskId = task.getId(); Future future = tasksStarterExecutorService.submit(() -&gt; { tasksManager.updateTaskState(taskId, Task.State.CREATING); logger.info(<span class="hljs-string"><span class="hljs-string">"Creating backup..."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream backupStream = databaseBackupManager.createBackup(databaseSettings, taskId)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.APPLYING_PROCESSORS); logger.info(<span class="hljs-string"><span class="hljs-string">"Applying processors on created backup. Processors: {}"</span></span>, processors); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream processedBackupStream = backupProcessorManager.process(backupStream, processors)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.UPLOADING); logger.info(<span class="hljs-string"><span class="hljs-string">"Uploading backup..."</span></span>); backupLoadManager.uploadBackup(processedBackupStream, backupProperties, taskId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.COMPLETED); logger.info(<span class="hljs-string"><span class="hljs-string">"Creating backup completed. Backup properties: {}"</span></span>, backupProperties); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException ex) { logger.error(<span class="hljs-string"><span class="hljs-string">"Error occurred while closing input stream of created backup"</span></span>, ex); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (RuntimeException ex) { logger.error(<span class="hljs-string"><span class="hljs-string">"Error occurred while creating backup. Backup properties: {}"</span></span>, backupProperties, ex); errorTasksManager.addErrorTask(taskId); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException ex) { tasksManager.setInterrupted(taskId); logger.error(<span class="hljs-string"><span class="hljs-string">"Backup creating task was interrupted. Task ID: {}"</span></span>, taskId); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { futures.remove(taskId); } }); futures.put(taskId, future); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> task; }</code> </pre> <br><p>  La création d'une sauvegarde passe par 3 étapes principales dans l'ordre suivant: création d'une sauvegarde -&gt; application des processeurs -&gt; téléchargement vers le stockage.  Dans presque toutes les méthodes de service, nous transmettons l'ID de la tâche en cours afin que le service puisse signaler une erreur à partir d'un thread qui fonctionne en arrière-plan.  À propos de la gestion des erreurs, pourquoi <em>InterruptedException</em> est ici et ce qui se passe avec une erreur après avoir reçu une <em>RuntimeException</em> sera discuté plus tard. </p><br><p>  Et voici comment nous allons exécuter la tâche de création d'une sauvegarde: </p><br><pre> <code class="java hljs">tasksStarterService.startBackupTask(Task.RunType.USER, storageSettingsNameList, processors, databaseSettings);</code> </pre> <br><p>  Le premier paramètre que nous transmettons à l'initiateur de la tâche: l'utilisateur ou la tâche serveur interne (un exemple de tâche interne est une sauvegarde périodique).  La connaissance de l'initiateur de tâche nous permet d'afficher dans l'interface utilisateur Web uniquement les tâches qui ont été lancées par l'utilisateur.  Les paramètres restants sont nécessaires pour créer directement une sauvegarde - une liste des stockages, des processeurs à utiliser, une base de données dont vous devez créer le vidage. </p><br><p>  Lors de la création d'une sauvegarde, un enregistrement est également créé dans la base de données appelé <strong>BackupProperties</strong> .  Cette entité stockera les propriétés de sauvegarde telles que le nom, les processeurs utilisés et la liste des référentiels dans lesquels la sauvegarde a été téléchargée.  De plus, pour restaurer ou supprimer la sauvegarde, nous fonctionnerons avec cette entité particulière. </p><br><p>  La tâche dans la base de données est stockée sous la forme suivante: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"backup_tasks"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Identifier of each backup task. Identifier is generated by PostgreSQL database after saving of entity. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(insertable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span>(strategy = GenerationType.IDENTITY) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer id; <span class="hljs-comment"><span class="hljs-comment">/** * Backup task type. * &lt;p&gt; * Type is set at the very start of any task and can't be changed. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> Type */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Enumerated</span></span>(EnumType.STRING) <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Type type; <span class="hljs-comment"><span class="hljs-comment">/** * Who initiated a task: user or server. * &lt;p&gt; * We need to know it to show on front only these tasks that was started by user. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> RunType */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Enumerated</span></span>(EnumType.STRING) <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> RunType runType; <span class="hljs-comment"><span class="hljs-comment">/** * Backup task state. * &lt;p&gt; * State is updated with every new step in task being executed. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> Task.State */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Enumerated</span></span>(EnumType.STRING) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> State state; <span class="hljs-comment"><span class="hljs-comment">/** * Whether task has been interrupted or not. * &lt;p&gt; * Default is {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@literal</span></span></span><span class="hljs-comment"> false}. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(insertable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> interrupted; <span class="hljs-comment"><span class="hljs-comment">/** * Identifier of {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> BackupProperties}. * &lt;p&gt; * We need to know backup ID to be able to handle occurred errors. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer backupPropertiesId; <span class="hljs-comment"><span class="hljs-comment">/** * Start time of the task. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> LocalDateTime date; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> RunType { USER, INTERNAL } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> State { PLANNED, CREATING, RESTORING, DELETING, APPLYING_PROCESSORS, APPLYING_DEPROCESSORS, DOWNLOADING, UPLOADING, COMPLETED, } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Type { CREATE_BACKUP { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"CREATE BACKUP"</span></span>; } }, RESTORE_BACKUP { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"RESTORE BACKUP"</span></span>; } }, DELETE_BACKUP { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"DELETE BACKUP"</span></span>; } } } <span class="hljs-comment"><span class="hljs-comment">// getters &amp; setters... }</span></span></code> </pre> <br><p>  Ainsi, vous pouvez décrire le processus de création d'une sauvegarde sous la forme d'un diagramme comme suit: <br><img src="https://habrastorage.org/webt/bm/um/cy/bmumcyhyapjg4ono73qo8kiquom.png" alt="Processus de sauvegarde" title="Processus de sauvegarde"></p><br><hr><br><p>  D'autres types de tâches sont lancés par analogie.  Afin de ne pas encombrer l'article avec une énorme quantité de code, pour les curieux, je donnerai le code pour lancer les tâches de restauration et de suppression de la sauvegarde séparément dans le spoiler. </p><br><div class="spoiler">  <b class="spoiler_title">Récupération de sauvegarde</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startRestoreTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Task.RunType runType, @NotNull BackupProperties backupProperties, @NotNull String storageSettingsName, @NotNull DatabaseSettings databaseSettings)</span></span></span><span class="hljs-function"> </span></span>{ Objects.requireNonNull(runType); Objects.requireNonNull(backupProperties); Objects.requireNonNull(storageSettingsName); Objects.requireNonNull(databaseSettings); Task task = tasksManager.initNewTask(Task.Type.RESTORE_BACKUP, runType, backupProperties.getId()); Integer taskId = task.getId(); Future future = tasksStarterExecutorService.submit(() -&gt; { tasksManager.updateTaskState(taskId, Task.State.DOWNLOADING); logger.info(<span class="hljs-string"><span class="hljs-string">"Downloading backup..."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream downloadedBackup = backupLoadManager.downloadBackup(backupProperties.getBackupName(), storageSettingsName, taskId)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted() || downloadedBackup == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.APPLYING_DEPROCESSORS); logger.info(<span class="hljs-string"><span class="hljs-string">"Deprocessing backup..."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream deprocessedBackup = backupProcessorManager.deprocess(downloadedBackup, backupProperties.getProcessors())) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.RESTORING); logger.info(<span class="hljs-string"><span class="hljs-string">"Restoring backup..."</span></span>); databaseBackupManager.restoreBackup(deprocessedBackup, databaseSettings, taskId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.COMPLETED); logger.info(<span class="hljs-string"><span class="hljs-string">"Restoring backup completed. Backup properties: {}"</span></span>, backupProperties); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException ex) { logger.error(<span class="hljs-string"><span class="hljs-string">"Error occurred while closing input stream of downloaded backup"</span></span>, ex); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (RuntimeException ex) { logger.info(<span class="hljs-string"><span class="hljs-string">"Error occurred while restoring backup. Backup properties: {}"</span></span>, backupProperties, ex); errorTasksManager.addErrorTask(taskId); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException ex) { tasksManager.setInterrupted(taskId); logger.error(<span class="hljs-string"><span class="hljs-string">"Task was interrupted. Task ID: {}"</span></span>, taskId); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { futures.remove(taskId); } }); futures.put(taskId, future); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> task; }</code> </pre> <br><p>  La restauration d'une sauvegarde passe par 3 étapes principales dans l'ordre suivant: déchargement d'une sauvegarde du stockage -&gt; utilisation des déprocesseurs pour obtenir la sauvegarde en texte brut d'origine -&gt; restauration d'une sauvegarde. </p><br><p>  Démarrez la récupération comme suit: </p><br><pre> <code class="java hljs">tasksStarterService.startRestoreTask(Task.RunType.USER, backupProperties, storageSettingsName, databaseSettings);</code> </pre> <br><p>  Processus de restauration d'une sauvegarde sous forme de diagramme: <br><img src="https://habrastorage.org/webt/hr/_m/bk/hr_mbkvfkszhyhj6ebi1q_wa1nc.png" alt="  " title="Processus de récupération de sauvegarde"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Supprimer la sauvegarde</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startDeleteTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Task.RunType runType, @NotNull BackupProperties backupProperties)</span></span></span><span class="hljs-function"> </span></span>{ Objects.requireNonNull(runType); Objects.requireNonNull(backupProperties); Task task = tasksManager.initNewTask(Task.Type.DELETE_BACKUP, runType, backupProperties.getId()); Integer taskId = task.getId(); Future future = tasksStarterExecutorService.submit(() -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { logger.info(<span class="hljs-string"><span class="hljs-string">"Deleting backup started. Backup properties: {}"</span></span>, backupProperties); tasksManager.updateTaskState(taskId, Task.State.DELETING); backupLoadManager.deleteBackup(backupProperties, taskId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.COMPLETED); logger.info(<span class="hljs-string"><span class="hljs-string">"Deleting backup completed. Backup properties: {}"</span></span>, backupProperties); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (RuntimeException ex) { logger.error(<span class="hljs-string"><span class="hljs-string">"Error occurred while deleting backup. Backup properties: {}"</span></span>, backupProperties, ex); errorTasksManager.addErrorTask(taskId); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException ex) { tasksManager.setInterrupted(taskId); logger.error(<span class="hljs-string"><span class="hljs-string">"Task was interrupted. Task ID: {}"</span></span>, taskId); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { futures.remove(taskId); } }); futures.put(taskId, future); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> task; }</code> </pre> <br><p>  Le processus de suppression d'une sauvegarde est assez simple: une sauvegarde est simplement supprimée de tous les stockages sur lesquels elle a été téléchargée. </p><br><p>  Exécutez la désinstallation comme suit: </p><br><pre> <code class="java hljs">tasksStarterService.startDeleteTask(Task.RunType.USER, backupProperties);</code> </pre> <br><p>  Processus de suppression d'une sauvegarde sous forme de diagramme: <br><img src="https://habrastorage.org/webt/y4/ca/yp/y4cayp76w4v0tx8umvzcp6flzd4.png" alt="  " title="Processus de suppression de sauvegarde"></p></div></div><br><hr><br><h3 id="otmena-taskov">  Annuler la tâche </h3><br><p>  Qu'est-ce que l'annulation de tâche?  Bien sûr, ce n'est rien de plus qu'une terminaison de thread.  Vous pouvez voir que tout le code principal exécuté dans Future est encapsulé dans la construction try-catch suivante: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException ex) { ... tasksManager.setInterrupted(taskId); }</code> </pre> <br><p>  Et également après chaque méthode importante, dont nous contrôlons le flux, la construction suivante est installée: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); }</code> </pre> <br><p>  Avant de poursuivre, une brève théorie des interruptions et des états des threads JVM doit être donnée. </p><br><p>  Les threads dans la JVM peuvent avoir les états suivants: </p><br><ol><li>  Nouveau </li><li>  Runnable </li><li>  Attente chronométrée </li><li>  En attente </li><li>  Bloqué </li><li>  Terminé </li></ol><br><p>  Nous ne sommes intéressés que par les états d'attente et d'attente.  Le <code>Object.wait()</code> dans l'état <em>Waiting</em> par les méthodes <code>Object.wait()</code> , <code>Thread.join()</code> et autres.  Le thread est placé dans l'état d' <em>attente Timed</em> (c'est-à-dire une attente qui dure une certaine période de temps) en utilisant les méthodes <code>Object.wait(timeout)</code> , <code>Thread.join(timeout)</code> , <code>Thread.sleep(sleeping)</code> et autres. </p><br><p>  La chose la plus importante ici est que si vous interrompez le thread <em>avant d'entrer dans l'état d'</em> attente En attente ou Timed ou lorsque le thread <em>est dans cet état</em> , le thread se réveille, lançant une <strong>InterruptedException</strong> . </p><br><p>  Mais ce n'est pas tout.  Ce n'est pas du tout un fait qu'un thread entrera jamais dans les données d'état en créant, en restaurant ou en supprimant une sauvegarde.  Comment alors informer le fil qu'il a été interrompu? </p><br><p>  La première façon consiste à vérifier indépendamment l'indicateur d'interruption avec le thread en utilisant les méthodes Thread.interrupted <code>Thread.interrupted()</code> ou <code>Thread.currentThread.isInterrupted()</code> .  La différence entre eux est que la première appelle la méthode native privée <code>currentThread.isInterrupted(boolean ClearInterrupted)</code> , la passant <code>true</code> , indiquant que le drapeau d'interruption sera effacé, et le second passant <code>false</code> , laissant le drapeau d'interruption intact.  Le choix entre ces deux méthodes dépend entièrement de la situation.  Lorsqu'une InterruptedException est levée, l'indicateur d'interruption est également effacé - cela mérite d'être rappelé. </p><br><p>  Mais il doit y avoir un moyen plus facile - et c'est le cas.  Dans l'application, il y a énormément de travail avec les flux d'E / S, et donc avec les méthodes d'E / S.  Notre tâche consiste à garantir que lors de l'appel des méthodes <code>read()</code> ou <code>write(int b)</code> sur le flux d'E / S, une erreur est générée lors de l'interruption, informant que l'appel d'E / S de blocage a été interrompu.  Heureusement, Java a une telle exception - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">InterruptedIOException</a> .  Cependant, toutes les méthodes de lecture / écriture de flux ne surveillent pas les interruptions de threads, et en particulier seul <em>PipedInputStream le</em> surveille.  Par conséquent, dans les endroits où ce flux n'est pas impliqué, nous devons étendre la méthode de lecture / écriture de sorte qu'en cas d'interruption, une InterruptedIOException soit levée.  En fait, l'extension de la méthode read () ne me suffisait dans l'application qu'à un seul endroit - lorsque InputStream revenait de la méthode de téléchargement de sauvegarde.  C'est ainsi que nous pouvons découvrir l'origine d'une interruption sans avoir à placer des vérifications de modèle sur le drapeau partout.  Cependant, il est important d'attraper cette exception séparément de l'exception IOException et de la gérer séparément.  Bien sûr, vous ne pouvez pas vous passer de l'aide d'un modèle de vérification du drapeau à certains endroits, mais c'est déjà mieux. </p><br><p>  Il est également important de noter que si l'indicateur a été effacé pendant le traitement d'interruption, il est toujours nécessaire de définir à nouveau l'indicateur d'interruption afin qu'après le retour de la méthode, nous puissions découvrir l'interruption qui s'est produite. </p><br><p>  Permettez-moi d'expliquer avec un exemple pourquoi c'est important.  Supposons que nous téléchargions une sauvegarde vers le stockage dans la méthode upload () et qu'une interruption se produise.  L'interruption est traitée, le travail est arrêté et la méthode revient.  L'interruption ne se produit pas avec désinvolture - cela signifie que soit une erreur s'est produite quelque part, soit que l'utilisateur a annulé la tâche.  Quelle que soit la raison, nous devons arrêter tout travail dans cet avenir.  Mais si vous ne définissez pas à nouveau l'indicateur d'interruption avant de revenir de la méthode de démarrage, nous ne saurons jamais dans le bloc Future principal l'interruption qui s'est produite. <br>  Le même exemple de code: </p><br><pre> <code class="java hljs">backupLoadManager.uploadBackup(processedBackupStream, backupProperties, taskId); &lt;-   ,       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-comment"><span class="hljs-comment">//      ,      - ,    throw new InterruptedException(); }</span></span></code> </pre> <br><p>  Par conséquent, il est recommandé de gérer une <strong>exception InterruptedException</strong> ou <strong>InterruptedIOException</strong> comme suit: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { <span class="hljs-comment"><span class="hljs-comment">//  InterruptedIOException ... // re-interrupt the thread Thread.currentThread().interrupt(); }</span></span></code> </pre> <br><p>  Eh bien, nous pouvons gérer l'interruption, mais qui va réellement interrompre les threads? <br>  Pour ce faire, nous allons créer une autre entité appelée <em>CancelTask</em> , qui stockera l'ID de la tâche à annuler, et rédigera également une veille qui tentera d'interrompre les tâches.  Pourquoi essayer?  Parce que: </p><br><ol><li>  Impossible de terminer le thread dans la mémoire d'un autre serveur.  Plusieurs serveurs peuvent fonctionner pour nous, ce qui signifie que Future est dispersé sur différents serveurs.  Ainsi, lorsqu'une demande d'annulation d'une tâche arrive sur l'un des serveurs, le Future souhaité peut se trouver dans la mémoire d'un autre serveur. </li><li>  La tâche ne peut pas être annulée car Future a été perdu en raison d'une panne de serveur. </li></ol><br><p>  Décrivez brièvement l'algorithme d'annulation le soir: <br>  Watercher supprime tous les enregistrements de la table <em>cancel_tasks</em> (le verrou n'est pas défini en même temps), parcourt chacun d'eux et essaie d'obtenir le futur correspondant de sa mémoire.  Si Future est reçu avec succès, le thread correspondant est interrompu, la tâche est annulée et la demande est supprimée de la table.  Si la demande de délai d'expiration pour annuler la tâche est dépassée (ce qui signifie que le serveur est tombé en panne et que Future a été perdu) - la demande est simplement supprimée de la table.  Si plusieurs serveurs remarquent un timeout et suppriment l'enregistrement de la table, rien de mauvais ne se produira, car la suppression dans PostgreSQL est idempotente. </p><br><p>  <strong>CancelTasksWatcher Code:</strong> </p><br><div class="spoiler">  <b class="spoiler_title">Texte masqué</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * This class scans for tasks to cancel and tries to cancel them. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CancelTasksWatcher</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger logger = LoggerFactory.getLogger(CancelTasksWatcher.class); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Duration cancelTimeout = Duration.ofMinutes(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CancelTasksManager cancelTasksManager; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TasksStarterService tasksStarterService; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TasksManager tasksManager; <span class="hljs-comment"><span class="hljs-comment">// spring setters... /** * This watcher wakes up every time 10 seconds passed from the last completion, checks if there are any tasks to cancel and tries to * cancel each task. * &lt;p&gt; * Since there are can be working more that one instance of the program, {@literal Future} instance of task can belong to different * servers. We can't get access to {@literal Future} if it's not in memory of the server where task cancellation request was accepted. * So the purpose of this watcher is to be able cancel tasks that works in the other instance of program. Each server has this watcher * checking for available cancellation requests and if any, the watcher tries to cancel corresponding {@literal Future}. * If cancellation is successful task will be also reverted. * &lt;p&gt; * If task cancellation request timeout exceeded, then it means a server that had requested {@literal Future} instances has been * shutdown, so all {@literal Future} instances lost and task can't be canceled. In such case task cancellation request will be ignored. * * @see TasksStarterService#getFuture(Integer) * @see TasksManager#revertTask(Task) */ @Scheduled(fixedDelay = 10 * 1000) @Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRES_NEW) public void watchTasksToCancel() { Iterable&lt;CancelTask&gt; cancelTasks = cancelTasksManager.findAll(); Iterable&lt;Task&gt; tasks = tasksManager.findAllById(StreamSupport.stream(cancelTasks.spliterator(), false) .map(CancelTask::getTaskId).collect(Collectors.toList())); Map&lt;Integer, Task&gt; tasksAsMap = StreamSupport.stream(tasks.spliterator(), false) .collect(Collectors.toMap(Task::getId, Function.identity())); List&lt;Integer&gt; taskIdsForDeleting = new ArrayList&lt;&gt;(); for (CancelTask cancelTask : cancelTasks) { Integer taskId = cancelTask.getTaskId(); Task task = tasksAsMap.get(taskId); if (task == null) { logger.error("Can't cancel task: no such entity with ID {}", taskId); taskIdsForDeleting.add(taskId); continue; } // timeout exceeded, that is server shutdown and lost all Future instances, so task can't be canceled if (LocalDateTime.now(ZoneOffset.UTC).isAfter(cancelTask.getPutTime().plus(cancelTimeout))) { logger.error("Can't cancel task: timeout exceed. Task ID: {}", taskId); taskIdsForDeleting.add(taskId); continue; } tasksStarterService.getFuture(taskId).ifPresent(future -&gt; { logger.info("Canceling task with ID {}", taskId); boolean canceled = future.cancel(true); if (canceled) { try { // give time to properly handle interrupt Thread.sleep(10000); } catch (InterruptedException e) { // should not happen } tasksManager.revertTask(task); } taskIdsForDeleting.add(taskId); logger.info("Task canceled: {}. Task ID: {}", canceled, taskId); }); } cancelTasksManager.deleteByTaskIdIn(taskIdsForDeleting); } }</span></span></code> </pre> </div></div><br><hr><br><h4 id="obrabotka-oshibok">  Gestion des erreurs </h4><br><p>  Ci-dessus, vous pouvez voir que tout le code principal en cours d'exécution dans Future est encapsulé dans la construction try-catch suivante: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (RuntimeException e) { ... errorTasksManager.addErrorTask(taskId); }</code> </pre> <br><p>     <em>RuntimeException</em>   ,     Future  ,         . </p><br><p>  <code>addErrorTask(taskId)</code>        ,   ID ,    . <br>      ?       ,    ,        ,   . </p><br><p>      : <br>                  ,        ,       .  —  PostgreSQL <code>select for update</code> ,   select   <code>skip locked</code>      . ,  ,    <code>revertTask()</code> ,               . </p><br><p> <strong> ErrorTasksWatcher</strong> : </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * This class scans for erroneous tasks and handles them depending on their state. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ErrorTasksWatcher</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger logger = LoggerFactory.getLogger(ErrorTasksWatcher.class); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Integer nRows = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TasksManager tasksManager; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ErrorTasksManager errorTasksManager; <span class="hljs-comment"><span class="hljs-comment">// spring setters... /** * This watcher wakes up every time 1 minute passed from the last completion, checks backup states periodically and handles erroneous * tasks if any. * &lt;p&gt; * The watcher handles at most N tasks as described by {@link #nRows} constant and skips already locked tasks. * When retrieving error tasks from database pessimistic lock is set. It allows safely run more than one copy of program, as no other * watcher can pick up already being handled error tasks. * &lt;p&gt; * If the server shutdowns while rows was locked, transaction will be rolled back and lock released, so these entities can be picked * up by the other running server. */ @Scheduled(fixedDelay = 60 * 1000) @Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRES_NEW) public void watchErrorTasks() { for (ErrorTask errorTask : errorTasksManager.findFirstNAndLock(nRows)) { if (!errorTask.isErrorHandled()) { Integer backupTaskId = errorTask.getTaskId(); Optional&lt;Task&gt; optionalTask = tasksManager.findById(backupTaskId); if (!optionalTask.isPresent()) { logger.info("Can't handle erroneous task: no corresponding backup task entity. Backup task ID: {}", backupTaskId); continue; } tasksManager.revertTask(optionalTask.get()); errorTask.setErrorHandled(true); } } } }</span></span></code> </pre> </div></div><br><p> <strong> <code>revertTask(Task)</code> :</strong> </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * This function reverts erroneous task by its entity. * &lt;p&gt; * Use this function only after canceling related {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@literal</span></span></span><span class="hljs-comment"> Future}. * &lt;p&gt; * If the task was of the type {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> Task.Type#CREATE_BACKUP} then related {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> BackupProperties} will be deleted. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> task the entity */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">revertTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Task task)</span></span></span><span class="hljs-function"> </span></span>{ Objects.requireNonNull(task); Task.State state = task.getState(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DOWNLOADING: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> APPLYING_DEPROCESSORS: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RESTORING: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DELETING: { logger.info(<span class="hljs-string"><span class="hljs-string">"Handling broken operation. Operation: {}. No extra actions required"</span></span>, state.toString()); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CREATING: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> APPLYING_PROCESSORS: { logger.info(<span class="hljs-string"><span class="hljs-string">"Handling broken operation. Operation: {}. Delete backup properties..."</span></span>, state.toString()); Integer backupPropertiesID = task.getBackupPropertiesId(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!backupPropertiesManager.existsById(backupPropertiesID)) { logger.error(<span class="hljs-string"><span class="hljs-string">"Can't revert task: no related backup properties. Task info: {}"</span></span>, task); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } backupPropertiesManager.deleteById(backupPropertiesID); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> UPLOADING: { logger.info(<span class="hljs-string"><span class="hljs-string">"Handling broken operation. Operation: {}. Deleting backup from storage..."</span></span>, state); Integer backupPropertiesId = task.getBackupPropertiesId(); Optional&lt;BackupProperties&gt; optionalBackupProperties = backupPropertiesManager.findById(backupPropertiesId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!optionalBackupProperties.isPresent()) { logger.error(<span class="hljs-string"><span class="hljs-string">"Can't revert task: no related backup properties. Task info: {}"</span></span>, task); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } tasksStarterService.startDeleteTask(Task.RunType.INTERNAL, optionalBackupProperties.get()); backupPropertiesManager.deleteById(backupPropertiesId); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: { logger.error(<span class="hljs-string"><span class="hljs-string">"Can't revert task: unknown state. Task info: {}"</span></span>, task); } } }</code> </pre> <br><p>   : </p><br><ol><li>     <em>DOWNLOADING</em> , <em>APPLYING_DEPROCESSORS</em> , <em>RESTORING</em> , <em>DELETING</em> —    .      ,       . </li><li>     <em>CREATING</em> , <em>APPLYING_PROCESSORS</em> —  ,       .      BackupProperties  ,       ( BackupProperties   Web UI    ). </li><li>     <em>UPLOADING</em> —       .        BackupProperties   ,       .       . </li></ol></div></div><br><p> ,    .         ,    ? ,   ,    Future (  1),     ,          InputStream (  2). ,      2,   1            2    ? </p><br><p>  ,     ,    ,       .      Future (    1)     : </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Throwable t, @NotNull Integer taskId)</span></span></span><span class="hljs-function"> </span></span>{ logger.error(<span class="hljs-string"><span class="hljs-string">"Exception caught. Task ID: {}"</span></span>, taskId, t); Optional&lt;Future&gt; optionalFuture = tasksStarterService.getFuture(taskId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!optionalFuture.isPresent()) { logger.error(<span class="hljs-string"><span class="hljs-string">"Can't cancel the Future of task with ID {}: no such Future instance"</span></span>, taskId); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> canceled = optionalFuture.get().cancel(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!canceled) { logger.error(<span class="hljs-string"><span class="hljs-string">"Error canceling the Future of task with ID {}"</span></span>, taskId); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { logger.info(<span class="hljs-string"><span class="hljs-string">"Task canceled. Task ID: {}"</span></span>, taskId); errorTasksManager.setError(taskId); } } }</code> </pre> <br><p>   ,     ,      ID  ,   ,    Future   -  ,  ID     . </p><br><p>    ,          ,     ,     ,         ,          . </p><br><p> <strong>  ,   :</strong> </p><br><p> ,   ,        ,    .       —       Future. </p><br><p>   ,      ,    ,      I/O ,          —     /   .     ,      .       : </p><br><ol><li>  ,  .     ,      —     . </li><li>     —     Future   ,   .  , /   ,  ,     (  ,     —    IOException  ,        ,   ). </li></ol><br><p>  ,   —            (   ID       ,  ,    ),        . </p><br><hr><br><p>  ,    ,        .      ,    ,             . </p><br><h3 id="plany-na-buduschee">    </h3><br><ol><li>  Web UI:   ,   .     ,      </li><li>     </li><li>      </li><li>     </li><li>     </li></ol><br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>   : </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>Github</strong></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>Docker Hub</strong></a> </li></ul><br><p>   ,   !           ,       GitHub! <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr459478/">https://habr.com/ru/post/fr459478/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr459464/index.html">Lua à Moscou 2019: entretien avec Roberto Jérusalem</a></li>
<li><a href="../fr459466/index.html">Lua à Moscou 2019: entretien avec Roberto Ierusalimschy</a></li>
<li><a href="../fr459470/index.html">Partie 4: Toujours en cours d'exécution Linux sur RISC-V RISC-V</a></li>
<li><a href="../fr459472/index.html">Heroku + Docker + Spring Boot</a></li>
<li><a href="../fr459474/index.html">Comment faire du texte parfaitement tapé en une seconde: une macro dans Word pour ceux qui écrivent beaucoup</a></li>
<li><a href="../fr459480/index.html">Vivaldi: Comment le navigateur gagne-t-il de l'argent?</a></li>
<li><a href="../fr459482/index.html">Comment nous avons vaincu l'arbre des catégories</a></li>
<li><a href="../fr459484/index.html">Génération Arduino. Ce que les étudiants modernes inventent</a></li>
<li><a href="../fr459488/index.html">Modes de jeu spéciaux dans le contexte de Roguelike</a></li>
<li><a href="../fr459490/index.html">Trucs sales des vendeurs de CRM: achèteriez-vous une voiture sans roues?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>