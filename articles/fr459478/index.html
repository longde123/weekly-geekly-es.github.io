<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚ÄçüöÄ üí≠ ü§õüèø Mon exp√©rience dans la cr√©ation d'une application multi-thread pour travailler avec des sauvegardes üôÄ üôé üíÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pour le moment, vous ne surprendrez personne avec des applications multithreads, mais je pense que dans cet article, vous pouvez trouver des id√©es int...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mon exp√©rience dans la cr√©ation d'une application multi-thread pour travailler avec des sauvegardes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459478/"><p>  Pour le moment, vous ne surprendrez personne avec des applications multithreads, mais je pense que dans cet article, vous pouvez trouver des id√©es int√©ressantes.  Mon √©tude de Java a commenc√© avec ce projet, donc peut-√™tre qu'√† certains endroits je me tromperai ou je construirai un gros v√©lo, mais j'esp√®re que quelqu'un sera int√©ress√© par l'exp√©rience d'un d√©butant en Java.  Je vais vous donner plusieurs fonctionnalit√©s de l'application: </p><br><ul><li>  Il fonctionne avec des sauvegardes exclusivement en m√©moire, quelle que soit la taille de la sauvegarde </li><li>  Ne charge pas la sauvegarde enti√®re en m√©moire </li><li>  Les op√©rations de sauvegarde / restauration peuvent √™tre annul√©es </li></ul><br><p>  Sous la coupe sera consid√©r√©e l'architecture de l'application, ainsi que les principaux probl√®mes rencontr√©s et leur solution. </p><a name="habracut"></a><br><h2 id="obzor-prilozheniya">  Pr√©sentation de l'application </h2><br><p>  La communication avec l'application se fait via l'interface utilisateur Web, mais √† l'avenir, il sera possible d'ajouter une API REST si n√©cessaire. </p><br><p>  L'application peut: </p><br><ol><li>  Cr√©ez des sauvegardes et t√©l√©chargez-les sur un ou plusieurs stockages </li><li>  Restaurez les sauvegardes en les chargeant du stockage </li><li>  Supprimer les sauvegardes de tous les stockages </li><li>  Cr√©ez p√©riodiquement des sauvegardes </li></ol><br><p>  R√©f√©rentiels actuellement pris en charge: </p><br><ul><li>  Syst√®me de fichiers local (non pris en charge par Docker) </li><li>  Dropbox </li></ul><br><p>  Bases de donn√©es actuellement prises en charge: </p><br><ul><li>  PostgreSQL </li></ul><br><p>  A partir d'une application sp√©ciale, je peux noter: </p><br><ol><li>  Travail correct dans une configuration de cluster </li><li>  Une sauvegarde n'est jamais enti√®rement charg√©e en m√©moire, quelle que soit la taille de la sauvegarde.  Le syst√®me de fichiers pour le stockage de sauvegarde temporaire n'est pas non plus impliqu√©.  La cr√©ation d'une sauvegarde et la restauration, et donc le chargement / d√©chargement d'une sauvegarde, se produisent exclusivement en m√©moire. </li><li>  Multiplateforme - fonctionne sur Windows et Linux. </li><li>  Nous pouvons surveiller toutes les t√¢ches en cours d'ex√©cution et les annuler si n√©cessaire. </li></ol><br><p>  Vous trouverez ci-dessous des captures d'√©cran de l'interface utilisateur Web qui d√©crivent clairement les fonctionnalit√©s de l'application. </p><br><div class="spoiler">  <b class="spoiler_title">Gestion du stockage</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/vl/qg/n5/vlqgn5f58ub5jhxixeeg2uq-oa8.png" title="Ajout de stockage"></a> <br> <a href=""><img src="https://habrastorage.org/webt/oj/o5/uj/ojo5uj_raxkwd1btsjrktiowifo.png" title="Liste de stockage"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Gestion de base de donn√©es</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/wn/6p/bk/wn6pbkcqg4qu_9btgrvnqm3l7x0.png" title="Ajout d'une base de donn√©es"></a> <br> <a href=""><img src="https://habrastorage.org/webt/wu/9a/4k/wu9a4ky7icuiyqdxeiii9xbu5d8.png" title="Liste des bases de donn√©es"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Cr√©ation de sauvegarde</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/1d/zb/6s/1dzb6scvtua5v3m_3l11lch4rgm.png" title="Cr√©ation de sauvegarde"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">R√©cup√©ration de sauvegarde</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/gj/9f/w0/gj9fw0onqw7f0lf7ycw05aphinc.png" title="R√©cup√©ration de sauvegarde"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">G√©rer les sauvegardes cr√©√©es</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/sy/jz/y6/syjzy68wqxgi8smgq74giqstgu0.png" title="Liste des sauvegardes cr√©√©es"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Sauvegardes p√©riodiques</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/hk/pw/tg/hkpwtg3kf7c5ho3f7ae7_uos7v0.png" title="Cr√©er une t√¢che p√©riodique"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Suivre les t√¢ches en cours</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/al/dt/su/aldtsuel4amtjlvbbbusccxddh0.png" title="Liste des t√¢ches en cours d'ex√©cution"></a> </p></div></div><br><hr><br><h2 id="arhitektura">  L'architecture </h2><br><p>  Le travail principal se d√©roulera dans 3 services - <em>DatabaseBackup</em> , <em>Processor</em> , <em>Storage</em> , et nous les relierons ensemble en utilisant le <em>concept de t√¢ches</em> .  √Ä propos de tout cela plus loin. </p><br><h3 id="databasebackup">  Sauvegarde de la base de donn√©es </h3><br><p>  Ce service est responsable de la cr√©ation et de la restauration des sauvegardes en texte brut. </p><br><p>  Interface de service: </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DatabaseBackup</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">InputStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createBackup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DatabaseSettings databaseSettings, Integer id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restoreBackup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputStream in, DatabaseSettings databaseSettings, Integer id)</span></span></span></span>; }</code> </pre> <br><p>  Les deux m√©thodes d'interface fonctionnent sur les instances <strong>InputStream</strong> , car nous avons besoin que la sauvegarde enti√®re ne soit pas charg√©e en m√©moire, ce qui signifie que la sauvegarde doit √™tre lue / √©crite en mode streaming.  L'entit√© <em>DatabaseSettings</em> est pr√©-cr√©√©e √† partir de l'interface utilisateur Web et stocke les diff√©rents param√®tres n√©cessaires pour acc√©der √† la base de donn√©es.  Quel est ce param√®tre - <code>id</code> - sera expliqu√© un peu plus loin. </p><br><p>  Les exigences de service sont les suivantes: </p><br><ol><li>  Les deux m√©thodes ne doivent pas lire l'int√©gralit√© de la sauvegarde en m√©moire. </li><li>  La m√©thode <code>restoreBackup()</code> doit restaurer la sauvegarde en une seule transaction, afin qu'en cas d'erreur, ne laissez pas la base de donn√©es dans un √©tat incoh√©rent. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Impl√©mentation pour PostgreSQL (description textuelle)</b> <div class="spoiler_text"><p>  Plus pr√©cis√©ment, dans l'impl√©mentation de PostgreSQL, le service est impl√©ment√© comme suit: </p><br><ol><li>  <code>createBackup()</code> : un processus <em>pg_dump</em> est cr√©√© qui cr√©era une sauvegarde et l'√©crira dans le flux de sortie standard.  Le flux de sortie de processus standard est renvoy√© par la m√©thode (voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://docs.oracle.com/javase/8/docs/api/java/lang/Process.html#getInputStream--</a> ).  Les flux d'E / S dans le syst√®me sont bas√©s sur un tampon d'une certaine taille, et lorsqu'un processus √©crit dans le flux de sortie, il √©crit r√©ellement dans le tampon en m√©moire.  La chose la plus importante ici est que le thread de processus n'√©crira pas dans le tampon <em>rempli</em> jusqu'√† ce que ce dernier ait √©t√© lu par l'autre c√¥t√©, ce qui signifie que le thread sera dans un √©tat verrouill√© et que la sauvegarde ne sera pas compl√®tement charg√©e en m√©moire.  Vous avez peut-√™tre rencontr√© une situation dans laquelle votre programme Java a rencontr√© un blocage lors de l'utilisation de processus en raison du fait que vous n'avez pas lu la stdout ou la stderr du processus.  Il est extr√™mement important de surveiller cela, car le processus ne peut pas continuer s'il est bloqu√© sur un appel de blocage d'E / S lors de l'√©criture dans un tampon complet et que personne ne lit ce tampon. </li><li>  <code>restoreBackup()</code> : un processus <em>psql</em> est cr√©√©, la sauvegarde est lue √† partir du <code>restoreBackup()</code> transmis √† la m√©thode et est simultan√©ment √©crite dans le flux d'entr√©e standard psql (voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://docs.oracle.com/javase/8/docs/api/java/lang/Process. html # getOutputStream--</a> ).  Cela fonctionne parce que la sauvegarde PostgreSQL en texte brut n'est qu'une collection de commandes DDL et DML faciles √† comprendre psql. </li></ol><br><p>  Il y a beaucoup de code, donc je ne le donnerai pas ici, mais vous pouvez le voir sur GitHub en utilisant le lien √† la fin de l'article. </p></div></div><br><h3 id="processor">  Processeur </h3><br><p>  Ce service est responsable de l'utilisation des processeurs et du retraitement des sauvegardes invers√©es.  Les processeurs sont utilis√©s avant le t√©l√©chargement vers le stockage ou apr√®s le d√©chargement du stockage.  Exemple de processeur: compresseur, cryptage. </p><br><p>  Interface de service: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Processor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">InputStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputStream in)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">InputStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deprocess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputStream in)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">ProcessorType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ProcessorType -  Enum,     int getPrecedence(); //   }</span></span></code> </pre> <br><p>  Chaque processeur a la priorit√© - si plusieurs processeurs sont sp√©cifi√©s, ils seront appliqu√©s par ordre d√©croissant de priorit√©.  En appliquant la fonction inverse dans le m√™me ordre dans lequel les processeurs ont √©t√© appliqu√©s, nous obtenons la sauvegarde d'origine. </p><br><h3 id="storage">  Stockage </h3><br><p>  Ce service est responsable du chargement et du d√©chargement d'une sauvegarde, ainsi que de sa suppression du stockage.  Exemple de stockage: Dropbox, syst√®me de fichiers local. </p><br><p>  Interface de service: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Storage</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uploadBackup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputStream in, StorageSettings storageSettings, String backupName, Integer id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">InputStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBackup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StorageSettings storageSettings, String backupName, Integer id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deleteBackup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StorageSettings storageSettings, String backupName, Integer id)</span></span></span></span>; }</code> </pre> <br><p>  Chaque sauvegarde cr√©√©e se voit attribuer un nom unique - afin que nous puissions la trouver sur l'un des stockages sur lesquels elle a √©t√© t√©l√©charg√©e.  La fa√ßon dont la sauvegarde est pr√©sent√©e au stockage d√©pend exclusivement de la mise en ≈ìuvre du service, mais lors du transfert du nom de la sauvegarde vers l'une des fonctions, nous devons nous attendre au comportement correct.  L'entit√© <em>StorageSettings</em> est pr√©-cr√©√©e √† partir de l'interface utilisateur Web et stocke les param√®tres n√©cessaires pour acc√©der au stockage. </p><br><hr><br><h3 id="koncepciya-taskov">  Concept de t√¢che </h3><br><p>  Nous aimerions pouvoir suivre l'√©tat de nos t√¢ches, g√©rer les erreurs possibles en fonction de l'avancement de la t√¢che et √©galement annuler les t√¢ches.  Par cons√©quent, nous continuerons √† fonctionner uniquement avec des t√¢ches.  Chaque t√¢che sera repr√©sent√©e dans la base de donn√©es par un enregistrement dans le tableau et par programme par l'instance <strong>Future</strong> (voir Java <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Future</a> ).  Chaque enregistrement de la table est associ√© √† son propre Future (de plus, si plusieurs serveurs sont en cours d'ex√©cution, les instances Future peuvent √™tre dans la m√©moire de diff√©rents serveurs). </p><br><p>  Allons s√©quentiellement.  Tout d'abord, nous avons besoin d'un service pour lancer des t√¢ches - cr√©ation, restauration et suppression de sauvegardes. </p><br><h4 id="zapusk-zadach">  Lancement de la t√¢che </h4><br><p>  <strong>Cr√©ation d'une sauvegarde:</strong> </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startBackupTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Task.RunType runType, @NotNull List&lt;String&gt; storageSettingsNameList, @Nullable List&lt;ProcessorType&gt; processors, @NotNull DatabaseSettings databaseSettings)</span></span></span><span class="hljs-function"> </span></span>{ Objects.requireNonNull(runType); Objects.requireNonNull(storageSettingsNameList); Objects.requireNonNull(processors); Objects.requireNonNull(databaseSettings); BackupProperties backupProperties = backupPropertiesManager.initNewBackupProperties(storageSettingsNameList, processors, databaseSettings.getName()); Task task = tasksManager.initNewTask(Task.Type.CREATE_BACKUP, runType, backupProperties.getId()); Integer taskId = task.getId(); Future future = tasksStarterExecutorService.submit(() -&gt; { tasksManager.updateTaskState(taskId, Task.State.CREATING); logger.info(<span class="hljs-string"><span class="hljs-string">"Creating backup..."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream backupStream = databaseBackupManager.createBackup(databaseSettings, taskId)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.APPLYING_PROCESSORS); logger.info(<span class="hljs-string"><span class="hljs-string">"Applying processors on created backup. Processors: {}"</span></span>, processors); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream processedBackupStream = backupProcessorManager.process(backupStream, processors)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.UPLOADING); logger.info(<span class="hljs-string"><span class="hljs-string">"Uploading backup..."</span></span>); backupLoadManager.uploadBackup(processedBackupStream, backupProperties, taskId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.COMPLETED); logger.info(<span class="hljs-string"><span class="hljs-string">"Creating backup completed. Backup properties: {}"</span></span>, backupProperties); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException ex) { logger.error(<span class="hljs-string"><span class="hljs-string">"Error occurred while closing input stream of created backup"</span></span>, ex); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (RuntimeException ex) { logger.error(<span class="hljs-string"><span class="hljs-string">"Error occurred while creating backup. Backup properties: {}"</span></span>, backupProperties, ex); errorTasksManager.addErrorTask(taskId); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException ex) { tasksManager.setInterrupted(taskId); logger.error(<span class="hljs-string"><span class="hljs-string">"Backup creating task was interrupted. Task ID: {}"</span></span>, taskId); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { futures.remove(taskId); } }); futures.put(taskId, future); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> task; }</code> </pre> <br><p>  La cr√©ation d'une sauvegarde passe par 3 √©tapes principales dans l'ordre suivant: cr√©ation d'une sauvegarde -&gt; application des processeurs -&gt; t√©l√©chargement vers le stockage.  Dans presque toutes les m√©thodes de service, nous transmettons l'ID de la t√¢che en cours afin que le service puisse signaler une erreur √† partir d'un thread qui fonctionne en arri√®re-plan.  √Ä propos de la gestion des erreurs, pourquoi <em>InterruptedException</em> est ici et ce qui se passe avec une erreur apr√®s avoir re√ßu une <em>RuntimeException</em> sera discut√© plus tard. </p><br><p>  Et voici comment nous allons ex√©cuter la t√¢che de cr√©ation d'une sauvegarde: </p><br><pre> <code class="java hljs">tasksStarterService.startBackupTask(Task.RunType.USER, storageSettingsNameList, processors, databaseSettings);</code> </pre> <br><p>  Le premier param√®tre que nous transmettons √† l'initiateur de la t√¢che: l'utilisateur ou la t√¢che serveur interne (un exemple de t√¢che interne est une sauvegarde p√©riodique).  La connaissance de l'initiateur de t√¢che nous permet d'afficher dans l'interface utilisateur Web uniquement les t√¢ches qui ont √©t√© lanc√©es par l'utilisateur.  Les param√®tres restants sont n√©cessaires pour cr√©er directement une sauvegarde - une liste des stockages, des processeurs √† utiliser, une base de donn√©es dont vous devez cr√©er le vidage. </p><br><p>  Lors de la cr√©ation d'une sauvegarde, un enregistrement est √©galement cr√©√© dans la base de donn√©es appel√© <strong>BackupProperties</strong> .  Cette entit√© stockera les propri√©t√©s de sauvegarde telles que le nom, les processeurs utilis√©s et la liste des r√©f√©rentiels dans lesquels la sauvegarde a √©t√© t√©l√©charg√©e.  De plus, pour restaurer ou supprimer la sauvegarde, nous fonctionnerons avec cette entit√© particuli√®re. </p><br><p>  La t√¢che dans la base de donn√©es est stock√©e sous la forme suivante: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"backup_tasks"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Identifier of each backup task. Identifier is generated by PostgreSQL database after saving of entity. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(insertable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span>(strategy = GenerationType.IDENTITY) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer id; <span class="hljs-comment"><span class="hljs-comment">/** * Backup task type. * &lt;p&gt; * Type is set at the very start of any task and can't be changed. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> Type */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Enumerated</span></span>(EnumType.STRING) <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Type type; <span class="hljs-comment"><span class="hljs-comment">/** * Who initiated a task: user or server. * &lt;p&gt; * We need to know it to show on front only these tasks that was started by user. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> RunType */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Enumerated</span></span>(EnumType.STRING) <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> RunType runType; <span class="hljs-comment"><span class="hljs-comment">/** * Backup task state. * &lt;p&gt; * State is updated with every new step in task being executed. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> Task.State */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Enumerated</span></span>(EnumType.STRING) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> State state; <span class="hljs-comment"><span class="hljs-comment">/** * Whether task has been interrupted or not. * &lt;p&gt; * Default is {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@literal</span></span></span><span class="hljs-comment"> false}. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(insertable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> interrupted; <span class="hljs-comment"><span class="hljs-comment">/** * Identifier of {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> BackupProperties}. * &lt;p&gt; * We need to know backup ID to be able to handle occurred errors. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer backupPropertiesId; <span class="hljs-comment"><span class="hljs-comment">/** * Start time of the task. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> LocalDateTime date; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> RunType { USER, INTERNAL } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> State { PLANNED, CREATING, RESTORING, DELETING, APPLYING_PROCESSORS, APPLYING_DEPROCESSORS, DOWNLOADING, UPLOADING, COMPLETED, } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Type { CREATE_BACKUP { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"CREATE BACKUP"</span></span>; } }, RESTORE_BACKUP { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"RESTORE BACKUP"</span></span>; } }, DELETE_BACKUP { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"DELETE BACKUP"</span></span>; } } } <span class="hljs-comment"><span class="hljs-comment">// getters &amp; setters... }</span></span></code> </pre> <br><p>  Ainsi, vous pouvez d√©crire le processus de cr√©ation d'une sauvegarde sous la forme d'un diagramme comme suit: <br><img src="https://habrastorage.org/webt/bm/um/cy/bmumcyhyapjg4ono73qo8kiquom.png" alt="Processus de sauvegarde" title="Processus de sauvegarde"></p><br><hr><br><p>  D'autres types de t√¢ches sont lanc√©s par analogie.  Afin de ne pas encombrer l'article avec une √©norme quantit√© de code, pour les curieux, je donnerai le code pour lancer les t√¢ches de restauration et de suppression de la sauvegarde s√©par√©ment dans le spoiler. </p><br><div class="spoiler">  <b class="spoiler_title">R√©cup√©ration de sauvegarde</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startRestoreTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Task.RunType runType, @NotNull BackupProperties backupProperties, @NotNull String storageSettingsName, @NotNull DatabaseSettings databaseSettings)</span></span></span><span class="hljs-function"> </span></span>{ Objects.requireNonNull(runType); Objects.requireNonNull(backupProperties); Objects.requireNonNull(storageSettingsName); Objects.requireNonNull(databaseSettings); Task task = tasksManager.initNewTask(Task.Type.RESTORE_BACKUP, runType, backupProperties.getId()); Integer taskId = task.getId(); Future future = tasksStarterExecutorService.submit(() -&gt; { tasksManager.updateTaskState(taskId, Task.State.DOWNLOADING); logger.info(<span class="hljs-string"><span class="hljs-string">"Downloading backup..."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream downloadedBackup = backupLoadManager.downloadBackup(backupProperties.getBackupName(), storageSettingsName, taskId)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted() || downloadedBackup == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.APPLYING_DEPROCESSORS); logger.info(<span class="hljs-string"><span class="hljs-string">"Deprocessing backup..."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream deprocessedBackup = backupProcessorManager.deprocess(downloadedBackup, backupProperties.getProcessors())) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.RESTORING); logger.info(<span class="hljs-string"><span class="hljs-string">"Restoring backup..."</span></span>); databaseBackupManager.restoreBackup(deprocessedBackup, databaseSettings, taskId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.COMPLETED); logger.info(<span class="hljs-string"><span class="hljs-string">"Restoring backup completed. Backup properties: {}"</span></span>, backupProperties); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException ex) { logger.error(<span class="hljs-string"><span class="hljs-string">"Error occurred while closing input stream of downloaded backup"</span></span>, ex); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (RuntimeException ex) { logger.info(<span class="hljs-string"><span class="hljs-string">"Error occurred while restoring backup. Backup properties: {}"</span></span>, backupProperties, ex); errorTasksManager.addErrorTask(taskId); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException ex) { tasksManager.setInterrupted(taskId); logger.error(<span class="hljs-string"><span class="hljs-string">"Task was interrupted. Task ID: {}"</span></span>, taskId); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { futures.remove(taskId); } }); futures.put(taskId, future); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> task; }</code> </pre> <br><p>  La restauration d'une sauvegarde passe par 3 √©tapes principales dans l'ordre suivant: d√©chargement d'une sauvegarde du stockage -&gt; utilisation des d√©processeurs pour obtenir la sauvegarde en texte brut d'origine -&gt; restauration d'une sauvegarde. </p><br><p>  D√©marrez la r√©cup√©ration comme suit: </p><br><pre> <code class="java hljs">tasksStarterService.startRestoreTask(Task.RunType.USER, backupProperties, storageSettingsName, databaseSettings);</code> </pre> <br><p>  Processus de restauration d'une sauvegarde sous forme de diagramme: <br><img src="https://habrastorage.org/webt/hr/_m/bk/hr_mbkvfkszhyhj6ebi1q_wa1nc.png" alt="  " title="Processus de r√©cup√©ration de sauvegarde"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Supprimer la sauvegarde</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startDeleteTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Task.RunType runType, @NotNull BackupProperties backupProperties)</span></span></span><span class="hljs-function"> </span></span>{ Objects.requireNonNull(runType); Objects.requireNonNull(backupProperties); Task task = tasksManager.initNewTask(Task.Type.DELETE_BACKUP, runType, backupProperties.getId()); Integer taskId = task.getId(); Future future = tasksStarterExecutorService.submit(() -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { logger.info(<span class="hljs-string"><span class="hljs-string">"Deleting backup started. Backup properties: {}"</span></span>, backupProperties); tasksManager.updateTaskState(taskId, Task.State.DELETING); backupLoadManager.deleteBackup(backupProperties, taskId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.COMPLETED); logger.info(<span class="hljs-string"><span class="hljs-string">"Deleting backup completed. Backup properties: {}"</span></span>, backupProperties); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (RuntimeException ex) { logger.error(<span class="hljs-string"><span class="hljs-string">"Error occurred while deleting backup. Backup properties: {}"</span></span>, backupProperties, ex); errorTasksManager.addErrorTask(taskId); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException ex) { tasksManager.setInterrupted(taskId); logger.error(<span class="hljs-string"><span class="hljs-string">"Task was interrupted. Task ID: {}"</span></span>, taskId); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { futures.remove(taskId); } }); futures.put(taskId, future); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> task; }</code> </pre> <br><p>  Le processus de suppression d'une sauvegarde est assez simple: une sauvegarde est simplement supprim√©e de tous les stockages sur lesquels elle a √©t√© t√©l√©charg√©e. </p><br><p>  Ex√©cutez la d√©sinstallation comme suit: </p><br><pre> <code class="java hljs">tasksStarterService.startDeleteTask(Task.RunType.USER, backupProperties);</code> </pre> <br><p>  Processus de suppression d'une sauvegarde sous forme de diagramme: <br><img src="https://habrastorage.org/webt/y4/ca/yp/y4cayp76w4v0tx8umvzcp6flzd4.png" alt="  " title="Processus de suppression de sauvegarde"></p></div></div><br><hr><br><h3 id="otmena-taskov">  Annuler la t√¢che </h3><br><p>  Qu'est-ce que l'annulation de t√¢che?  Bien s√ªr, ce n'est rien de plus qu'une terminaison de thread.  Vous pouvez voir que tout le code principal ex√©cut√© dans Future est encapsul√© dans la construction try-catch suivante: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException ex) { ... tasksManager.setInterrupted(taskId); }</code> </pre> <br><p>  Et √©galement apr√®s chaque m√©thode importante, dont nous contr√¥lons le flux, la construction suivante est install√©e: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); }</code> </pre> <br><p>  Avant de poursuivre, une br√®ve th√©orie des interruptions et des √©tats des threads JVM doit √™tre donn√©e. </p><br><p>  Les threads dans la JVM peuvent avoir les √©tats suivants: </p><br><ol><li>  Nouveau </li><li>  Runnable </li><li>  Attente chronom√©tr√©e </li><li>  En attente </li><li>  Bloqu√© </li><li>  Termin√© </li></ol><br><p>  Nous ne sommes int√©ress√©s que par les √©tats d'attente et d'attente.  Le <code>Object.wait()</code> dans l'√©tat <em>Waiting</em> par les m√©thodes <code>Object.wait()</code> , <code>Thread.join()</code> et autres.  Le thread est plac√© dans l'√©tat d' <em>attente Timed</em> (c'est-√†-dire une attente qui dure une certaine p√©riode de temps) en utilisant les m√©thodes <code>Object.wait(timeout)</code> , <code>Thread.join(timeout)</code> , <code>Thread.sleep(sleeping)</code> et autres. </p><br><p>  La chose la plus importante ici est que si vous interrompez le thread <em>avant d'entrer dans l'√©tat d'</em> attente En attente ou Timed ou lorsque le thread <em>est dans cet √©tat</em> , le thread se r√©veille, lan√ßant une <strong>InterruptedException</strong> . </p><br><p>  Mais ce n'est pas tout.  Ce n'est pas du tout un fait qu'un thread entrera jamais dans les donn√©es d'√©tat en cr√©ant, en restaurant ou en supprimant une sauvegarde.  Comment alors informer le fil qu'il a √©t√© interrompu? </p><br><p>  La premi√®re fa√ßon consiste √† v√©rifier ind√©pendamment l'indicateur d'interruption avec le thread en utilisant les m√©thodes Thread.interrupted <code>Thread.interrupted()</code> ou <code>Thread.currentThread.isInterrupted()</code> .  La diff√©rence entre eux est que la premi√®re appelle la m√©thode native priv√©e <code>currentThread.isInterrupted(boolean ClearInterrupted)</code> , la passant <code>true</code> , indiquant que le drapeau d'interruption sera effac√©, et le second passant <code>false</code> , laissant le drapeau d'interruption intact.  Le choix entre ces deux m√©thodes d√©pend enti√®rement de la situation.  Lorsqu'une InterruptedException est lev√©e, l'indicateur d'interruption est √©galement effac√© - cela m√©rite d'√™tre rappel√©. </p><br><p>  Mais il doit y avoir un moyen plus facile - et c'est le cas.  Dans l'application, il y a √©norm√©ment de travail avec les flux d'E / S, et donc avec les m√©thodes d'E / S.  Notre t√¢che consiste √† garantir que lors de l'appel des m√©thodes <code>read()</code> ou <code>write(int b)</code> sur le flux d'E / S, une erreur est g√©n√©r√©e lors de l'interruption, informant que l'appel d'E / S de blocage a √©t√© interrompu.  Heureusement, Java a une telle exception - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">InterruptedIOException</a> .  Cependant, toutes les m√©thodes de lecture / √©criture de flux ne surveillent pas les interruptions de threads, et en particulier seul <em>PipedInputStream le</em> surveille.  Par cons√©quent, dans les endroits o√π ce flux n'est pas impliqu√©, nous devons √©tendre la m√©thode de lecture / √©criture de sorte qu'en cas d'interruption, une InterruptedIOException soit lev√©e.  En fait, l'extension de la m√©thode read () ne me suffisait dans l'application qu'√† un seul endroit - lorsque InputStream revenait de la m√©thode de t√©l√©chargement de sauvegarde.  C'est ainsi que nous pouvons d√©couvrir l'origine d'une interruption sans avoir √† placer des v√©rifications de mod√®le sur le drapeau partout.  Cependant, il est important d'attraper cette exception s√©par√©ment de l'exception IOException et de la g√©rer s√©par√©ment.  Bien s√ªr, vous ne pouvez pas vous passer de l'aide d'un mod√®le de v√©rification du drapeau √† certains endroits, mais c'est d√©j√† mieux. </p><br><p>  Il est √©galement important de noter que si l'indicateur a √©t√© effac√© pendant le traitement d'interruption, il est toujours n√©cessaire de d√©finir √† nouveau l'indicateur d'interruption afin qu'apr√®s le retour de la m√©thode, nous puissions d√©couvrir l'interruption qui s'est produite. </p><br><p>  Permettez-moi d'expliquer avec un exemple pourquoi c'est important.  Supposons que nous t√©l√©chargions une sauvegarde vers le stockage dans la m√©thode upload () et qu'une interruption se produise.  L'interruption est trait√©e, le travail est arr√™t√© et la m√©thode revient.  L'interruption ne se produit pas avec d√©sinvolture - cela signifie que soit une erreur s'est produite quelque part, soit que l'utilisateur a annul√© la t√¢che.  Quelle que soit la raison, nous devons arr√™ter tout travail dans cet avenir.  Mais si vous ne d√©finissez pas √† nouveau l'indicateur d'interruption avant de revenir de la m√©thode de d√©marrage, nous ne saurons jamais dans le bloc Future principal l'interruption qui s'est produite. <br>  Le m√™me exemple de code: </p><br><pre> <code class="java hljs">backupLoadManager.uploadBackup(processedBackupStream, backupProperties, taskId); &lt;-   ,       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-comment"><span class="hljs-comment">//      ,      - ,    throw new InterruptedException(); }</span></span></code> </pre> <br><p>  Par cons√©quent, il est recommand√© de g√©rer une <strong>exception InterruptedException</strong> ou <strong>InterruptedIOException</strong> comme suit: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { <span class="hljs-comment"><span class="hljs-comment">//  InterruptedIOException ... // re-interrupt the thread Thread.currentThread().interrupt(); }</span></span></code> </pre> <br><p>  Eh bien, nous pouvons g√©rer l'interruption, mais qui va r√©ellement interrompre les threads? <br>  Pour ce faire, nous allons cr√©er une autre entit√© appel√©e <em>CancelTask</em> , qui stockera l'ID de la t√¢che √† annuler, et r√©digera √©galement une veille qui tentera d'interrompre les t√¢ches.  Pourquoi essayer?  Parce que: </p><br><ol><li>  Impossible de terminer le thread dans la m√©moire d'un autre serveur.  Plusieurs serveurs peuvent fonctionner pour nous, ce qui signifie que Future est dispers√© sur diff√©rents serveurs.  Ainsi, lorsqu'une demande d'annulation d'une t√¢che arrive sur l'un des serveurs, le Future souhait√© peut se trouver dans la m√©moire d'un autre serveur. </li><li>  La t√¢che ne peut pas √™tre annul√©e car Future a √©t√© perdu en raison d'une panne de serveur. </li></ol><br><p>  D√©crivez bri√®vement l'algorithme d'annulation le soir: <br>  Watercher supprime tous les enregistrements de la table <em>cancel_tasks</em> (le verrou n'est pas d√©fini en m√™me temps), parcourt chacun d'eux et essaie d'obtenir le futur correspondant de sa m√©moire.  Si Future est re√ßu avec succ√®s, le thread correspondant est interrompu, la t√¢che est annul√©e et la demande est supprim√©e de la table.  Si la demande de d√©lai d'expiration pour annuler la t√¢che est d√©pass√©e (ce qui signifie que le serveur est tomb√© en panne et que Future a √©t√© perdu) - la demande est simplement supprim√©e de la table.  Si plusieurs serveurs remarquent un timeout et suppriment l'enregistrement de la table, rien de mauvais ne se produira, car la suppression dans PostgreSQL est idempotente. </p><br><p>  <strong>CancelTasksWatcher Code:</strong> </p><br><div class="spoiler">  <b class="spoiler_title">Texte masqu√©</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * This class scans for tasks to cancel and tries to cancel them. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CancelTasksWatcher</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger logger = LoggerFactory.getLogger(CancelTasksWatcher.class); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Duration cancelTimeout = Duration.ofMinutes(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CancelTasksManager cancelTasksManager; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TasksStarterService tasksStarterService; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TasksManager tasksManager; <span class="hljs-comment"><span class="hljs-comment">// spring setters... /** * This watcher wakes up every time 10 seconds passed from the last completion, checks if there are any tasks to cancel and tries to * cancel each task. * &lt;p&gt; * Since there are can be working more that one instance of the program, {@literal Future} instance of task can belong to different * servers. We can't get access to {@literal Future} if it's not in memory of the server where task cancellation request was accepted. * So the purpose of this watcher is to be able cancel tasks that works in the other instance of program. Each server has this watcher * checking for available cancellation requests and if any, the watcher tries to cancel corresponding {@literal Future}. * If cancellation is successful task will be also reverted. * &lt;p&gt; * If task cancellation request timeout exceeded, then it means a server that had requested {@literal Future} instances has been * shutdown, so all {@literal Future} instances lost and task can't be canceled. In such case task cancellation request will be ignored. * * @see TasksStarterService#getFuture(Integer) * @see TasksManager#revertTask(Task) */ @Scheduled(fixedDelay = 10 * 1000) @Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRES_NEW) public void watchTasksToCancel() { Iterable&lt;CancelTask&gt; cancelTasks = cancelTasksManager.findAll(); Iterable&lt;Task&gt; tasks = tasksManager.findAllById(StreamSupport.stream(cancelTasks.spliterator(), false) .map(CancelTask::getTaskId).collect(Collectors.toList())); Map&lt;Integer, Task&gt; tasksAsMap = StreamSupport.stream(tasks.spliterator(), false) .collect(Collectors.toMap(Task::getId, Function.identity())); List&lt;Integer&gt; taskIdsForDeleting = new ArrayList&lt;&gt;(); for (CancelTask cancelTask : cancelTasks) { Integer taskId = cancelTask.getTaskId(); Task task = tasksAsMap.get(taskId); if (task == null) { logger.error("Can't cancel task: no such entity with ID {}", taskId); taskIdsForDeleting.add(taskId); continue; } // timeout exceeded, that is server shutdown and lost all Future instances, so task can't be canceled if (LocalDateTime.now(ZoneOffset.UTC).isAfter(cancelTask.getPutTime().plus(cancelTimeout))) { logger.error("Can't cancel task: timeout exceed. Task ID: {}", taskId); taskIdsForDeleting.add(taskId); continue; } tasksStarterService.getFuture(taskId).ifPresent(future -&gt; { logger.info("Canceling task with ID {}", taskId); boolean canceled = future.cancel(true); if (canceled) { try { // give time to properly handle interrupt Thread.sleep(10000); } catch (InterruptedException e) { // should not happen } tasksManager.revertTask(task); } taskIdsForDeleting.add(taskId); logger.info("Task canceled: {}. Task ID: {}", canceled, taskId); }); } cancelTasksManager.deleteByTaskIdIn(taskIdsForDeleting); } }</span></span></code> </pre> </div></div><br><hr><br><h4 id="obrabotka-oshibok">  Gestion des erreurs </h4><br><p>  Ci-dessus, vous pouvez voir que tout le code principal en cours d'ex√©cution dans Future est encapsul√© dans la construction try-catch suivante: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (RuntimeException e) { ... errorTasksManager.addErrorTask(taskId); }</code> </pre> <br><p>     <em>RuntimeException</em>   ,     Future  ,         . </p><br><p>  <code>addErrorTask(taskId)</code>        ,   ID ,    . <br>      ?       ,    ,        ,   . </p><br><p>      : <br>                  ,        ,       .  ‚Äî  PostgreSQL <code>select for update</code> ,   select   <code>skip locked</code>      . ,  ,    <code>revertTask()</code> ,               . </p><br><p> <strong> ErrorTasksWatcher</strong> : </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * This class scans for erroneous tasks and handles them depending on their state. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ErrorTasksWatcher</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger logger = LoggerFactory.getLogger(ErrorTasksWatcher.class); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Integer nRows = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TasksManager tasksManager; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ErrorTasksManager errorTasksManager; <span class="hljs-comment"><span class="hljs-comment">// spring setters... /** * This watcher wakes up every time 1 minute passed from the last completion, checks backup states periodically and handles erroneous * tasks if any. * &lt;p&gt; * The watcher handles at most N tasks as described by {@link #nRows} constant and skips already locked tasks. * When retrieving error tasks from database pessimistic lock is set. It allows safely run more than one copy of program, as no other * watcher can pick up already being handled error tasks. * &lt;p&gt; * If the server shutdowns while rows was locked, transaction will be rolled back and lock released, so these entities can be picked * up by the other running server. */ @Scheduled(fixedDelay = 60 * 1000) @Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRES_NEW) public void watchErrorTasks() { for (ErrorTask errorTask : errorTasksManager.findFirstNAndLock(nRows)) { if (!errorTask.isErrorHandled()) { Integer backupTaskId = errorTask.getTaskId(); Optional&lt;Task&gt; optionalTask = tasksManager.findById(backupTaskId); if (!optionalTask.isPresent()) { logger.info("Can't handle erroneous task: no corresponding backup task entity. Backup task ID: {}", backupTaskId); continue; } tasksManager.revertTask(optionalTask.get()); errorTask.setErrorHandled(true); } } } }</span></span></code> </pre> </div></div><br><p> <strong> <code>revertTask(Task)</code> :</strong> </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * This function reverts erroneous task by its entity. * &lt;p&gt; * Use this function only after canceling related {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@literal</span></span></span><span class="hljs-comment"> Future}. * &lt;p&gt; * If the task was of the type {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> Task.Type#CREATE_BACKUP} then related {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> BackupProperties} will be deleted. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> task the entity */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">revertTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Task task)</span></span></span><span class="hljs-function"> </span></span>{ Objects.requireNonNull(task); Task.State state = task.getState(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DOWNLOADING: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> APPLYING_DEPROCESSORS: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RESTORING: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DELETING: { logger.info(<span class="hljs-string"><span class="hljs-string">"Handling broken operation. Operation: {}. No extra actions required"</span></span>, state.toString()); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CREATING: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> APPLYING_PROCESSORS: { logger.info(<span class="hljs-string"><span class="hljs-string">"Handling broken operation. Operation: {}. Delete backup properties..."</span></span>, state.toString()); Integer backupPropertiesID = task.getBackupPropertiesId(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!backupPropertiesManager.existsById(backupPropertiesID)) { logger.error(<span class="hljs-string"><span class="hljs-string">"Can't revert task: no related backup properties. Task info: {}"</span></span>, task); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } backupPropertiesManager.deleteById(backupPropertiesID); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> UPLOADING: { logger.info(<span class="hljs-string"><span class="hljs-string">"Handling broken operation. Operation: {}. Deleting backup from storage..."</span></span>, state); Integer backupPropertiesId = task.getBackupPropertiesId(); Optional&lt;BackupProperties&gt; optionalBackupProperties = backupPropertiesManager.findById(backupPropertiesId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!optionalBackupProperties.isPresent()) { logger.error(<span class="hljs-string"><span class="hljs-string">"Can't revert task: no related backup properties. Task info: {}"</span></span>, task); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } tasksStarterService.startDeleteTask(Task.RunType.INTERNAL, optionalBackupProperties.get()); backupPropertiesManager.deleteById(backupPropertiesId); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: { logger.error(<span class="hljs-string"><span class="hljs-string">"Can't revert task: unknown state. Task info: {}"</span></span>, task); } } }</code> </pre> <br><p>   : </p><br><ol><li>     <em>DOWNLOADING</em> , <em>APPLYING_DEPROCESSORS</em> , <em>RESTORING</em> , <em>DELETING</em> ‚Äî    .      ,       . </li><li>     <em>CREATING</em> , <em>APPLYING_PROCESSORS</em> ‚Äî  ,       .      BackupProperties  ,       ( BackupProperties   Web UI    ). </li><li>     <em>UPLOADING</em> ‚Äî       .        BackupProperties   ,       .       . </li></ol></div></div><br><p> ,    .         ,    ? ,   ,    Future (  1),     ,          InputStream (  2). ,      2,   1            2    ? </p><br><p>  ,     ,    ,       .      Future (    1)     : </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Throwable t, @NotNull Integer taskId)</span></span></span><span class="hljs-function"> </span></span>{ logger.error(<span class="hljs-string"><span class="hljs-string">"Exception caught. Task ID: {}"</span></span>, taskId, t); Optional&lt;Future&gt; optionalFuture = tasksStarterService.getFuture(taskId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!optionalFuture.isPresent()) { logger.error(<span class="hljs-string"><span class="hljs-string">"Can't cancel the Future of task with ID {}: no such Future instance"</span></span>, taskId); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> canceled = optionalFuture.get().cancel(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!canceled) { logger.error(<span class="hljs-string"><span class="hljs-string">"Error canceling the Future of task with ID {}"</span></span>, taskId); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { logger.info(<span class="hljs-string"><span class="hljs-string">"Task canceled. Task ID: {}"</span></span>, taskId); errorTasksManager.setError(taskId); } } }</code> </pre> <br><p>   ,     ,      ID  ,   ,    Future   -  ,  ID     . </p><br><p>    ,          ,     ,     ,         ,          . </p><br><p> <strong>  ,   :</strong> </p><br><p> ,   ,        ,    .       ‚Äî       Future. </p><br><p>   ,      ,    ,      I/O ,          ‚Äî     /   .     ,      .       : </p><br><ol><li>  ,  .     ,      ‚Äî     . </li><li>     ‚Äî     Future   ,   .  , /   ,  ,     (  ,     ‚Äî    IOException  ,        ,   ). </li></ol><br><p>  ,   ‚Äî            (   ID       ,  ,    ),        . </p><br><hr><br><p>  ,    ,        .      ,    ,             . </p><br><h3 id="plany-na-buduschee">    </h3><br><ol><li>  Web UI:   ,   .     ,      </li><li>     </li><li>      </li><li>     </li><li>     </li></ol><br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>   : </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>Github</strong></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>Docker Hub</strong></a> </li></ul><br><p>   ,   !           ,       GitHub! <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr459478/">https://habr.com/ru/post/fr459478/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr459464/index.html">Lua √† Moscou 2019: entretien avec Roberto J√©rusalem</a></li>
<li><a href="../fr459466/index.html">Lua √† Moscou 2019: entretien avec Roberto Ierusalimschy</a></li>
<li><a href="../fr459470/index.html">Partie 4: Toujours en cours d'ex√©cution Linux sur RISC-V RISC-V</a></li>
<li><a href="../fr459472/index.html">Heroku + Docker + Spring Boot</a></li>
<li><a href="../fr459474/index.html">Comment faire du texte parfaitement tap√© en une seconde: une macro dans Word pour ceux qui √©crivent beaucoup</a></li>
<li><a href="../fr459480/index.html">Vivaldi: Comment le navigateur gagne-t-il de l'argent?</a></li>
<li><a href="../fr459482/index.html">Comment nous avons vaincu l'arbre des cat√©gories</a></li>
<li><a href="../fr459484/index.html">G√©n√©ration Arduino. Ce que les √©tudiants modernes inventent</a></li>
<li><a href="../fr459488/index.html">Modes de jeu sp√©ciaux dans le contexte de Roguelike</a></li>
<li><a href="../fr459490/index.html">Trucs sales des vendeurs de CRM: ach√®teriez-vous une voiture sans roues?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>