<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛹🏿 📈 ✍🏾 Pixelnebel mit Rauschen und Medianschnitt erstellen 💉 🚵🏿 🏢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich wollte einen Nebel in meinem Spiel The Last Boundary . Sie sehen fantastisch aus und Raum ohne sie ist kein Raum, sondern einfach weiße Pixel, die...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pixelnebel mit Rauschen und Medianschnitt erstellen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464203/">  Ich wollte einen Nebel in meinem Spiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">The Last Boundary</a> .  Sie sehen fantastisch aus und Raum ohne sie ist kein Raum, sondern einfach weiße Pixel, die über den Hintergrund verstreut sind.  Aber da ich das Spiel im Stil von "Pixel Art" mache, musste ich meine Rauschbibliothek irgendwie dazu bringen, pixelige Bilder zu erzeugen. <br><br>  Hier einige Beispiele: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2e/65f/7fd/f2e65f7fd23c0fe2fcfafcc0fcf62a3e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/665/358/ef9/665358ef9f488bb63d7ced8ea7dfd45d.png"></div><br><div class="spoiler">  <b class="spoiler_title">Weitere Beispiele</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b88/d6e/4ab/b88d6e4ab783d2d67f0f0f6e7e38536f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/705/d13/40b/705d1340be1c918a6a6e9b22d3ae416f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/daa/1c7/1ba/daa1c71bade101b11ec6025a87ca30a4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00b/d8c/5f9/00bd8c5f9fa01ef5a90282a2d2897de3.png"></div><br></div></div><br>  In einfarbigen Beispielen werden 8 Farben und in anderen 16 Farben verwendet.  In diesem Artikel werde ich darüber sprechen, wie ich einen pixeligen Nebel für The Last Boundary erstellt habe. <br><a name="habracut"></a><br>  Wenn wir mit einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rauschbibliothek</a> wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LibNoise arbeiten</a> , werden die Werte normalerweise im Bereich von <code>-1</code> bis <code>1</code> verteilt, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unabhängig davon,</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">welche</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Engine</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie</a> verwenden (oder Ihre eigene schreiben).  Es ist theoretisch wahrscheinlicher, dass 2D-Rauschen im Bereich von <code>-0.7</code> bis <code>0.7</code> , aber einige Implementierungen skalieren das Ergebnis und übersetzen es in das Intervall von <code>-1</code> bis <code>1</code> .  Um mit 2D-Texturen zu arbeiten, wird es normalerweise in ein Intervall von <code>0</code> bis <code>1</code> konvertiert und <code>RGB(255,255,255)</code> in den Bereich von <code>RGB(0,0,0)</code> bis <code>RGB(255,255,255)</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cac/df6/434/cacdf6434a755a3ae5dd27afbffc8ce2.png"></div><br>  <i>Perlin-Rauschen, das aus der <code>x,y</code> Koordinate jedes auf <code>0.3f</code> skalierten Pixels <code>0.3f</code></i> <br><br>  Dann können Sie eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gebrochene Brownsche Bewegung verwenden</a> , um dem Bild ein Gefühl von Wolkenpracht zu verleihen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aed/910/a74/aed910a745d77af8d1cfa816990276a5.png"></div><br>  <i>Perlin-Rauschen wurde einer fraktionierten Brownschen Bewegung mit <code>8</code> Oktaven, einer Frequenz von <code>0.01</code> , einer Regelmäßigkeit von <code>0.5</code> und einer Lakunarität von <code>2.0</code> ausgesetzt.</i> <br><br><blockquote>  Ich habe festgestellt, dass es im Internet viele falsche Implementierungen von Perlin-Rauschen, Simplex-Rauschen und fraktionierter Brownscher Bewegung (fBm) gibt.  Es scheint viel Verwirrung darüber zu geben, was was ist.  Stellen Sie sicher, dass Sie die richtige Implementierung verwenden. Wenn Sie die oben beschriebene Kette erstellen möchten, erhalten Sie bei einer falschen Implementierung möglicherweise nicht die erforderlichen Ergebnisse. </blockquote><br>  Stellen wir uns vor, wir wollen einen Raucheffekt erzeugen, das heißt, eine solche Lösung passt zu uns.  Aber unser Pixelkunstspiel würde seltsam aussehen, wenn eine ganze Reihe neuer Farben von <code>RGB(0,0,0)</code> bis <code>RGB(255,255,255)</code> .  Plötzlich erscheinen 255 neue Graustufen im Spiel. <br><br>  Wir müssen sie in eine begrenzte Anzahl von Farben konvertieren.  Das werden wir später tun.  In der Zwischenzeit ... <br><br><h2>  Zufälligen Nebel erzeugen </h2><br>  Ich wiederholte dies für vorgefertigte Tutorials zum Erzeugen zufälliger Nebel, fügte jedoch einige meiner Schritte hinzu und wandte meine eigene Geräuschbibliothek an.  Ich habe es vor einigen Jahren geschrieben, weil ich ein gutes Verständnis für Perlins Rauschen haben wollte und wie Sie es zusammen mit anderen Konzepten verwenden können, um Texturen und dergleichen zu erstellen. <br><br>  Vielleicht können Sie nach mir Schritt für Schritt wiederholen, oder Sie müssen den Code ergänzen, der sich auf Ihr Rauschen auswirkt.  Ich werde alles außer der anfänglichen Rauschgenerierung und fBm erklären, damit Sie den Code selbst schreiben können.  Ich denke, es kann davon ausgegangen werden, dass Sie bereits in der Lage sind, Rauschen und fBm zu erzeugen. <br><br>  Zu Beginn werde ich das Ergebnis der Erzeugung des Nebels zeigen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/389/0b5/319/3890b53197b3d0e6fff931569bd330f4.png"></div><br>  <i>Fertiges Ergebnis</i> <br><br>  Es ist wichtig zu beachten, dass es noch nicht pixelig ist.  Es hat eine breite Palette von Farben mit einem pixeligen Sternenhimmel.  Den Nebel werden wir später pixelig machen. <br><br>  Als erstes müssen fünf verschiedene Texturen generiert werden: Rot, Grün, Blau, Alpha und Maske.  Die roten, grünen und blauen Texturen werden für die entsprechenden endgültigen Farbkanäle benötigt.  Tatsächlich generiere ich nur einen oder zwei Farbkanäle, weil sich herausstellte, dass die Verwendung aller drei einen unglaublich bunten Nebel erzeugt, der hässlich aussieht.  Jede einzelne Farbe oder eine Kombination aus zwei Farben ist gut geeignet. <br><br>  Der Alpha-Kanal ist wichtig, da es davon abhängt, ob die unteren Sterne durch den Nebel scheinen.  Ich werde dies veranschaulichen, indem ich den Alpha-Kanal des oben gezeigten Beispiels anzeige. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/ee7/ba4/ee2ee7ba42267152dd2c6495828b5f17.png"></div><br>  <i>Bereit Alpha-Kanal aus unserem Beispiel</i> <br><br>  Je weißer die Fläche ist, desto näher liegt der Wert an <code>1.0</code> , was einen Alpha-Wert von <code>255</code> ergibt.  Je schwärzer der Bereich, desto transparenter ist er.  Wenn Sie sich ein Beispiel ansehen, können Sie sehen, dass die schwarzen Bereiche Bereichen entsprechen, in denen der Sternenhimmel sichtbar ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de9/7d2/7ad/de97d27adeaaebdbfc8a5b5857bab02f.png"></div><br>  <i>Sternenhimmel Beispiel</i> <br><br>  Dies sind nicht die gleichen Sterne wie im Beispiel, da sie in jedem Screenshot zufällig generiert werden.  Ich hoffe, dies hindert Sie nicht daran zu verstehen, wie der Nebel erzeugt wird. <br><br>  Meine Rauschbibliothek besteht aus Modulen, die dem Beispiel von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lib Noise</a> folgen.  Alles in dieser Bibliothek sind „Module“, die miteinander verkettet werden können.  Einige Module generieren neue Werte (Perlin-Modul, konstanter Wert), andere verbinden sie (Multiplizieren, Addieren) und einige führen einfach Operationen an dem Wert aus (Lerp, Clamp). <br><br><h3>  Farbkanäle </h3><br>  Es spielt keine Rolle, ob wir mit einer, zwei oder drei Farben arbeiten - die Kanäle Rot, Grün und Blau werden auf dieselbe Weise generiert.  Ich benutze nur einen anderen Startwert für sie.  Meine Startwerte hängen von der aktuellen Systemzeit ab. <br><br>  Im Folgenden werden sie alle in Graustufen dargestellt, aber theoretisch sind sie einfach Werte für einen der drei Kanäle.  Graustufen dienen nur zur Veranschaulichung der Ergebnisse. <br><br><h4>  1. Perlins Lärm </h4><br>  Wie oben wird Perlins Lärm der Ausgangspunkt sein.  Wenn Sie möchten, können Sie Simplex-Rauschen verwenden. Es scheint, dass die 2D-Implementierung nicht Ken Perlin gehört, aber ich könnte mich irren.  Aus mathematischer Sicht benötigt Simplex-Rauschen weniger Anweisungen, sodass die Erzeugung eines ähnlichen Nebels schneller erfolgt.  Da es Simplexe anstelle eines Gitters verwendet, erzeugt es ein etwas schöneres Rauschen, aber wir werden nicht viel damit arbeiten, daher ist dies nicht besonders wichtig. <br><br>  Der reale Code wird unten nicht gezeigt, da in realen Quellen die <code>x,y</code> Werte in Schritt 3 um fBm geändert wurden. Dies ist nur die <code>x,y</code> Koordinate des Bildes, multipliziert mit dem statischen Skalierungsfaktor. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cac/df6/434/cacdf6434a755a3ae5dd27afbffc8ce2.png"></div><br>  <i>Perlin-Rauschen, das aus der <code>x,y</code> Koordinate jedes auf <code>0.3f</code> skalierten Pixels <code>0.3f</code> .</i>  <i>Das heißt,</i> <i><code>PixelValue = PerlinNoise(x * 0.3f, y * 0.3f)</code></i> <br><br>  Die durch Perlin-Rauschen erzeugten Werte liegen ungefähr im Bereich von <code>-1</code> bis <code>1</code> Um das oben gezeigte übliche Graustufenbild zu erstellen, konvertieren wir sie in das Intervall von <code>0</code> bis <code>1</code> .  Ich habe den Umfang der Werte getestet, damit die Konvertierung den größten Kontrast erzeugt (der niedrigste Wert entspricht <code>0</code> , der größte - <code>1</code> ). <br><br><h4>  2. Multiplikation </h4><br>  Das nächste verwendete Modul multipliziert das erzeugte Rauschen mit <code>5</code> .  Dies kann als Kontrastanpassung angesehen werden.  Negative Werte sind dunkler, positive Werte sind heller. <br><br>  Ich habe hier nichts zu zeigen, da sich beim Konvertieren von Werten aus dem Intervall von <code>-5</code> bis <code>5</code> in das Intervall von <code>0</code> nach <code>1</code> Ergebnis nicht ändert. <br><br><h4>  3. Fractional Brownian Motion (fBM) </h4><br>  Diese Phase verwandelt Lärm in das, was viele Menschen als echten „Lärm-Effekt“ betrachten.  Hier führen wir Oktaven von immer kleineren Samples aus der Rauschfunktion aus (in unserem Fall ist die Funktion <code>perlin(x,y)</code> ), um <code>perlin(x,y)</code> hinzuzufügen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/388/634/15b/38863415ba86694f3acc86618e7173d2.png"></div><br>  <i>Fraktionierte Brownsche Bewegung des oben gezeigten Perlin-Rauschens.</i>  <i><code>8</code> Oktaven, Frequenz <code>.01f</code> , Regelmäßigkeit <code>.5f</code> und <code>2.5f</code></i> <br><br>  Sie können bereits den Ursprung von etwas Interessantem erkennen.  Das oben gezeigte Bild wird nicht durch Skalieren der <code>x,y</code> Koordinaten der Pixel erzeugt, fBM tut dies.  Wiederum werden diese Werte umgekehrt in ein Intervall von <code>0</code> bis <code>1</code> in ein mögliches Intervall von <code>-5</code> bis <code>5</code> . <br><br><h4>  4. Einschränkung (Klemme) </h4><br>  Jetzt werde ich die Werte auf einen Bereich von <code>-1</code> bis <code>1</code> .  Alles außerhalb dieses Intervalls wird vollständig verworfen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/623/f7a/b80/623f7ab80bc886e62d416726bcb63a09.png"></div><br>  <i>Das gleiche fBm, begrenzt auf <code>-1</code> bis <code>1</code></i> <br><br>  Die Aufgabe dieser Operation besteht darin, die Werte in ein kürzeres Intervall umzuwandeln, während schärfere Verläufe erzeugt und der Bereich in vollem Weiß oder Schwarz vergrößert wird.  Diese toten oder leeren Bereiche sind wichtig für den Nebeleffekt, auf den wir später noch eingehen werden.  Wenn wir zuerst nicht mit <code>5</code> multipliziert hätten, hätte die Klemme nichts geändert. <br><br><h4>  5. Fügen Sie 1 hinzu </h4><br>  Jetzt nehmen wir die Werte aus der Klemme und addieren 1. zu ihnen. Somit übertragen wir die Werte in das Intervall von <code>0</code> bis <code>2</code> .  Nach der Konvertierung sehen die Ergebnisse genauso aus wie zuvor. <br><br><h4>  6. Teilen Sie durch 2 </h4><br>  Sie wissen wahrscheinlich, was passieren wird, wenn ich das Ergebnis durch <code>2</code> dividiere (multipliziere mit <code>.5</code> ).  Im Bild ändert sich nichts mehr. <br><br>  Die Schritte 5 und 6 konvertieren die Werte in einen Bereich von <code>0</code> bis <code>1</code> . <br><br><h4>  7. Erstellen Sie eine Verzerrungstextur </h4><br>  Der nächste Schritt besteht darin, eine Verzerrungstextur zu erstellen.  Ich werde dies mit Perlin-Rauschen (mit dem neuen Startwert) tun&gt; mit 4 multiplizieren&gt; fBm ausführen.  In diesem Fall verwendet fBm <code>5</code> Oktaven, eine Frequenz von <code>0.025</code> , eine Regelmäßigkeit von <code>0.5</code> und eine Lücke von <code>1.5</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b34/937/748/b34937748b4e87736c9f09f464bc99dd.png"></div><br>  <i>Verzerrungstextur</i> <br><br>  Diese Textur wird benötigt, um mehr Details als in der vorhandenen Textur des Nebels zu erzeugen.  Der Nebel ist eine ziemlich große Wellenwolke, und diese Textur wird kleine Änderungen daran vornehmen.  Dadurch wird die Gitternatur von Perlins Lärm sichtbar. <br><br><h4>  8. Versetzen Sie die Farbtextur mit der versetzten Textur </h4><br>  Als nächstes nehme ich diese beiden Texturen und verwende eine, um die Koordinaten der anderen um einen Faktor zu versetzen.  In unserem Fall sieht die Kombination folgendermaßen aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93f/44c/0ea/93f44c0ea7e040e0141925eede2673fd.png"></div><br>  <i>Vorspannungsergebnis</i> <br><br>  Die Verzerrungstextur wird verwendet, um die <code>x,y</code> Koordinaten zu ändern <code>x,y</code> wir in den Quellrauschdaten suchen. <br><br>  Denken Sie daran, dass die oben gezeigten Bilder nur zu Illustrationszwecken dienen.  In jeder Phase haben wir eigentlich nur eine Rauschfunktion.  Wir übergeben ihm den Wert <code>x,y</code> und es wird eine Zahl zurückgegeben.  In bestimmten Phasen kann das Intervall dieser Zahl unterschiedlich sein, aber oben haben wir es wieder in Graustufen konvertiert, um ein Bild zu erstellen.  Das Bild wird erstellt, indem jede <code>x,y</code> Koordinate des Bildes als <code>x,y</code> , die von der Rauschfunktion übertragen wird. <br><br>  Das heißt, wenn wir sagen: <br><br><blockquote>  Geben Sie mir den Wert für das Pixel der oberen linken Ecke mit X = 0 und Y = 0 </blockquote><br>  Funktion gibt uns eine Nummer zurück.  Wenn wir Perlin danach fragen, wissen wir, dass es zwischen <code>-1</code> und <code>1</code> wird. Wenn wir wie oben Clamp, Addition und Multiplikation anwenden, erhalten wir einen Wert zwischen <code>0</code> und <code>1</code> . <br><br>  Nachdem wir dies verstanden haben, lernen wir, dass die Verzerrungsrauschfunktion Werte im Bereich von <code>-1</code> bis <code>1</code> .  Um die Verzerrung durchzuführen, wenn wir sagen: <br><br><blockquote>  Geben Sie mir den Wert für das Pixel in der oberen linken Ecke mit Pixel X = 0 und Y = 0 </blockquote><br>  Das Offset-Modul fragt zuerst die Offset-Funktion nach den <code>x,y</code> Koordinaten.  Das Ergebnis liegt zwischen <code>-1</code> und <code>1</code> (wie oben).  Dann wird es mit <code>40</code> multipliziert (dies ist der <em>Koeffizient, den</em> ich ausgewählt habe).  Das Ergebnis ist ein Wert zwischen <code>-40</code> und <code>40</code> . <br><br>  Dann nehmen wir diesen Wert und addieren ihn zu den Koordinaten des gesuchten <code>x,y</code> und verwenden dieses Ergebnis, um die Farbtextur zu durchsuchen.  Wir schneiden negative Werte mit der Klemme auf 0 ab, da es unmöglich ist, negative <code>x,y</code> Koordinaten in Rauschfunktionen zu suchen (zumindest in meiner Rauschbibliothek). <br><br>  Das heißt, im Allgemeinen sieht es so aus: <br><br><pre> <code class="cpp hljs">ColourFunction(x,y) =     <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> DisplaceFunction(x,y) =     <span class="hljs-number"><span class="hljs-number">-1</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> DoDisplace(x,y) = { v = DisplaceFunction(x,y) * factor clamp(v,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">40</span></span>) x = x + v; y = y + v; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> then x = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> y &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> then y = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ColourFunction(x,y) }</code> </pre> <br>  Ich hoffe du verstehst das.  Tatsächlich betrachten wir nicht das <code>x,y</code> , in dem wir uns befanden, sondern den Versatz.  Und da die <em>Größe</em> auch ein glatter Gradient ist, verschiebt sie sich reibungslos. <br><br>  Es gibt andere Möglichkeiten, den Offset durchzuführen.  Meine Rauschbibliothek hat ein Modul, das eine Spiralverschiebung erzeugt.  Es kann verwendet werden, um Texturen zu zeichnen, die allmählich auf eine Anzahl von Punkten abnehmen.  <a href="">Hier ist ein Beispiel</a> . <br><br>  Das ist alles.  Wir wiederholen die obigen Vorgänge dreimal und verwenden für jeden Farbkanal neue Startwerte.  Sie können einen oder zwei Kanäle erstellen.  Ich denke nicht, dass es sich lohnt, ein drittes zu schaffen. <br><br><h3>  Alpha-Kanal </h3><br>  Ein Alphakanal wird ähnlich wie Farbkanäle erstellt: <br><br><ol><li>  Wir beginnen mit Perlins Lärm </li><li>  Mit <code>5</code> multiplizieren </li><li>  fBM mit <code>8</code> Oktaven, Frequenz <code>0.005</code> , Regelmäßigkeit <code>0.5</code> und Lakunarität <code>2.5</code> </li><li>  Wir begrenzen die Ergebnisse mit Clamp auf das Intervall von <code>-1</code> bis <code>1</code> , addieren <code>1</code> , dividieren durch <code>2</code> (d. H. Wir verschieben das Intervall von <code>-1</code> bis <code>1</code> auf das Intervall von <code>0</code> bis <code>1</code> . </li><li>  Wir verschieben das Ergebnis um einen kleinen Betrag in die negative Richtung.  Ich versetze um <code>0.4</code> .  Dadurch wird alles etwas dunkler. </li><li>  Wir beschränken die Ergebnisse auf ein Intervall von <code>0</code> bis <code>1</code> .  Da wir alles verschoben haben, wodurch es etwas dunkler wurde, haben wir tatsächlich mehr Bereiche mit <code>0</code> , und einige Bereiche haben negative Werte angenommen. </li></ol><br>  Das Ergebnis ist eine Alpha-Kanal-Textur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/ee7/ba4/ee2ee7ba42267152dd2c6495828b5f17.png"></div><br>  <i>Alpha-Textur</i> <br><br>  Wie gesagt, schwarze Bereiche sind transparent und weiße Bereiche undurchsichtig. <br><br><h3>  Kanalmasken </h3><br>  Dies ist die letzte Textur, die verwendet wird, um Schatten zu erzeugen, die über allem anderen liegen.  Es beginnt wie alle anderen Texturen: <br><br><ol><li>  Noise Perlin </li><li>  Mit <code>5</code> multiplizieren </li><li>  Wir spielen fBm, <code>5</code> Oktaven, Frequenz <code>0.01</code> , Regelmäßigkeit <code>0.1</code> , Lakunarität <code>0.1</code> .  Die Regelmäßigkeit ist gering, daher ist die Wolke weniger dicht </li><li>  Führen Sie eine Intervallverschiebung von <code>-1</code> nach <code>1</code> zu einem Intervall von <code>0</code> nach <code>1</code> </li></ol><br>  Wir erstellen jedoch zwei solche Texturen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/630/11f/862/63011f8620c86a9bbf2f80d038a7c157.png"></div><br>  <i>Maske a</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/271/ae6/62e/271ae662e2038e09afba52bb2725d8cb.png"></div><br>  <i>Maske B.</i> <br><br>  Wir setzen diese beiden Texturen dem so genannten <em>Select-</em> Modul aus.  Tatsächlich verwenden wir den Wert aus Modul A oder Modul B. Die Auswahl hängt vom Wert von Modul C ab. Es sind zwei weitere Werte erforderlich - <em>Select Point</em> und <em>Falloff</em> . <br><br>  Wenn der Wert am Punkt <code>x,y</code> Modul C größer oder gleich <code>SelectPoint</code> , verwenden wir den Wert an Punkt <code>x,y</code> Modul B. Wenn der Wert kleiner oder gleich <code>SelectPoint - Falloff</code> , verwenden wir den Wert an <code>x,y</code> Modul A. <br><br>  Wenn es zwischen <code>SelectPoint - Falloff</code> und <code>SelectPoint</code> , führen wir eine lineare Interpolation zwischen den <code>x,y</code> Werten von Modul A und Modul B durch. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">select</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y, moduleA, moduleB, moduleC, selectPoint, falloff)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> s = moduleC(x,y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(s &gt;= selectPoint) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> moduleB(x,y); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(s &lt;= selectPoint - falloff) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> moduleA(x,y); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = moduleA(x,y); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = moduleB(x,y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lerp(a, b, (<span class="hljs-number"><span class="hljs-number">1.0</span></span> / ((selectPoint - (selectPoint-falloff)) / (selectPoint - s))); } }</code> </pre> <br>  In unserem Fall ist Modul A ein <em>Konstantenmodul</em> mit dem Wert <code>0</code> .  Modul B ist die erste Textur von Maske A und <em>Selector</em> (Modul C) ist die zweite Maske von B. <code>SelectPoint</code> ist <code>0.4</code> und <code>Falloff</code> ist <code>0.1</code> .  Als Ergebnis erhalten wir: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93a/46a/265/93a46a265f690650dec24eb5c56bcf32.png"></div><br>  <i>Ultimative Maske</i> <br><br>  Durch Erhöhen oder Verringern von <code>SelectPoint</code> verringern oder erhöhen wir die Schwarzmenge in der Maske.  Durch Erhöhen oder Verringern des <code>falloff</code> erhöhen oder verringern wir die weichen Kanten der Masken.  Anstelle einer der Masken könnte ich das <em>Konstantenmodul</em> mit dem Wert <code>1</code> , aber ich wollte den "nicht maskierten" Bereichen etwas Zufälligkeit hinzufügen. <br><br><h3>  Farbkanal und Maske mischen </h3><br>  Jetzt müssen wir auf jeden der Farbkanäle eine Maske anwenden.  Dies erfolgt über das <em>Mischmodul</em> .  Es kombiniert die Prozentsätze der Werte aus zwei Modulen, sodass die Summe der Werte 100% beträgt. <br><br>  Das heißt, wir können 50% des Wertes in <code>x,y</code> Modul A und 50% des Wertes in <code>x,y</code> Modul B oder 75% und 25% usw. nehmen.  Der Prozentsatz, den wir von jedem Modul nehmen, hängt von einem anderen Modul ab - Modul C. Wenn der Wert in <code>x,y</code> Modul C <code>0</code> , nehmen wir 100% von Modul A und 0% von Modul B. Wenn es <code>1</code> , nehmen wir inverse Werte. <br><br>  Kombinieren Sie für jede Farbtextur. <br><br><ul><li>  Modul A - Konstanter Wert 0 </li><li>  Modul B ist der Farbkanal, den wir bereits gesehen haben </li><li>  Modul C - Maskenergebnis </li></ul><br>  Dies bedeutet, dass das Rauschen des Farbkanals nur dort angezeigt wird, wo die Maske Werte über <code>0</code> (Bereiche, die näher an Weiß liegen), und die Größe ihrer Sichtbarkeit vom Wert der Maske abhängt. <br><br>  Hier ist das Ergebnis für unser Beispiel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4da/f7e/e06/4daf7ee0635972da36bbb611250fb52d.png"></div><br>  <i>Endergebnis</i> <br><br>  Vergleichen Sie dies mit dem Original, bevor Sie eine Mischung mit einer Maske auftragen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93f/44c/0ea/93f44c0ea7e040e0141925eede2673fd.png"></div><br>  <i>Vor dem Mischen mit einer Maske</i> <br><br>  Vielleicht ist dieses Beispiel nicht sehr offensichtlich, aber aufgrund des Zufalls ist es schwierig, ein gutes Beispiel auszuwählen.  Durch die Maske werden dunklere Bereiche erzeugt.  Natürlich können Sie die Maske so anpassen, dass sie stärker ausgeprägt ist. <br><br>  Hierbei ist es wichtig, dass dieselbe Maske auf den gesamten Farbkanal angewendet wird, dh, dieselben Bereiche erscheinen im Schatten. <br><br><h3>  Wir kombinieren alles miteinander </h3><br>  Unser erstes fertiges Beispiel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/389/0b5/319/3890b53197b3d0e6fff931569bd330f4.png"></div><br>  <i>Bereites Beispiel</i> <br><br>  Es verwendet die Kanäle Rot, Grün und Alpha: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4da/f7e/e06/4daf7ee0635972da36bbb611250fb52d.png"></div><br>  <i>Roter Kanal</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/001/8fb/c26/0018fbc263e0ae9983386f78428a0088.png"></div><br>  <i>Grüner Kanal</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/ee7/ba4/ee2ee7ba42267152dd2c6495828b5f17.png"></div><br>  <i>Alpha-Kanal</i> <br><br>  Und dann legen wir sie einfach über unseren Sternenhimmel. <br><br>  Alles sieht jetzt ziemlich gut aus, ist aber für ein Pixel-Art-Spiel nicht sehr geeignet.  Wir müssen die Anzahl der Farben reduzieren ... <br><br><h2>  Medianschnitt </h2><br>  Dieser Teil des Artikels kann auf alles angewendet werden.  Angenommen, Sie erzeugen eine Marmortextur und möchten die Anzahl der Farben reduzieren.  Hier bietet sich der Median-Cut-Algorithmus an.  Wir werden es verwenden, um die Anzahl der Farben im oben gezeigten Nebel zu reduzieren. <br><br>  Dies geschieht, <em>bevor</em> es dem Sternenhimmel überlagert wird.  Die Anzahl der Farben ist völlig beliebig. <br><br>  Der Median Cut-Algorithmus wie in Wikipedia beschrieben: <br><br><blockquote>  Angenommen, wir haben ein Bild mit einer beliebigen Anzahl von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pixeln</a> und möchten eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Palette</a> mit 16 Farben erzeugen.  Legen Sie alle Pixel im Bild (d. H. Ihre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RGB-Werte</a> ) in den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Papierkorb</a> .  Finden Sie heraus, welcher Farbkanal (rot, grün oder blau) unter allen Pixeln im Warenkorb den größten Wertebereich aufweist, und sortieren Sie die Pixel dann nach den Werten dieses Kanals.  Wenn der blaue Kanal beispielsweise den größten Wertebereich hat, ist das Pixel mit dem RGB-Wert (32, 8, 16) kleiner als das Pixel mit dem RGB-Wert (1, 2, 24), da 16 &lt;24. Platzieren Sie nach dem Sortieren des Korbs die obere Hälfte der Pixel in einen neuen Korb.  (Dieser Schritt gab dem Medianschnitt-Algorithmus den Namen. Körbe werden durch den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Median der</a> Pixelliste in zwei Hälften geteilt.) Wiederholen Sie den Vorgang für beide Körbe, wodurch wir 4 Körbe erhalten. Wiederholen Sie diesen Vorgang für alle 4 Körbe, erhalten Sie 8 Körbe und wiederholen Sie für 8 Körbe. Wir erhalten 16 Körbe.  Wir mitteln die Pixel in jedem der Körbe und erhalten eine Palette von 16 Farben.  Da sich die Anzahl der Körbe bei jeder Iteration verdoppelt, kann der Algorithmus nur solche Paletten erzeugen, wobei die Anzahl der Farben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine Zweierpotenz ist</a> .  Um beispielsweise eine 12-Farben-Palette zu erstellen, müssen Sie zuerst eine 16-Farben-Palette erstellen und dann einige Farben irgendwie kombinieren. <br><br>  Quelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://en.wikipedia.org/wiki/Median_cut</a> </blockquote><br>  Diese Erklärung erschien mir eher schlecht und nicht besonders nützlich.  Bei der Implementierung des Algorithmus werden auf diese Weise ziemlich hässliche Bilder erhalten.  Ich habe es mit einigen Änderungen implementiert: <br><br><ol><li>  Wir speichern den <code>boxes</code> zusammen mit dem Wert, der das Intervall angibt (mehr dazu weiter unten).  In der <code>box</code> einfach eine dynamische Anzahl von Pixeln aus dem Originalbild gespeichert. </li><li>  Fügen Sie alle Pixel des Originalbilds als erstes <code></code> und verwenden Sie das Intervall <code>0</code> </li><li>  Während die Gesamtzahl der <code></code> geringer ist als die erforderliche Anzahl von Farben, fahren wir mit den folgenden Schritten fort. </li><li>  Wenn der Intervallwert <code>0</code> , bestimmen wir für jedes aktuelle Feld den Hauptfarbkanal dieses <code>box</code> und sortieren dann die Pixel in diesem <code>box</code> nach dieser Farbe.   —    Red, Green, Blue  Alpha,     . , <code>redRange = Max(Red) - Min(Red)</code> .           ,      . </li><li>           <code>box</code>   <code>boxes</code> .   ,        <code>box</code> . </li><li>  ,     4  5   <code>box</code> ,   <code>boxes</code>   .      ,         ,    ,     .     ,           ,      . </li><li>    <code>box</code> ( ==   )      <code>boxes</code> .               <code>0</code> (    ).  ,         ,       ,    — .            . </li></ol><br>     ,    ,        ,    ,     .     ,     ,       . <br><br>  ,    .      RGB,     . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f3e/bb8/3fa/f3ebb83fa6aa4d15c0422ef3d66fd9ed.png"></div><br>        . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/389/0b5/319/3890b53197b3d0e6fff931569bd330f4.png"></div><br>  <i>Das Original</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/453/617/875/453617875c9eb3c9ae389c74aaeb97da.png"></div><br> <i>Median Cut  16 </i> <br><br>  ,           16 .  ,      -,        .       ,      .    median cut,            (    ),       . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/70c/32e/828/70c32e82884077298e54db439472c866.gif"></div><br> <i> 16  2 </i> <br><br>      <code>box</code> ,    .     .   ,          .    ,       ,    .      1, 2  3          .     16 ,    13       . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce6/48f/382/ce648f382b0be2409b25d24d682a528b.png"></div><br> <i>     </i> <br><br>     ,    .       .     . <br><br><h2>  </h2><br>     ,    (dithering),         -. ,           ,   . <br><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> -</a> .       .     .     : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/389/0b5/319/3890b53197b3d0e6fff931569bd330f4.png"></div><br>  <i>Das Original</i> <br><br>      16 : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/453/617/875/453617875c9eb3c9ae389c74aaeb97da.png"></div><br> <i>   16- </i> <br><br>        : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/84f/fa0/d82/84ffa0d82eb90de9f0e59c7ef718f753.png"></div><br> <i>   </i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464203/">https://habr.com/ru/post/de464203/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464189/index.html">So erstellen Sie ein Open Source-Projekt</a></li>
<li><a href="../de464191/index.html">So lösen Sie Probleme mit der Aggregator-Site mithilfe residenter Proxys</a></li>
<li><a href="../de464193/index.html">Ein offenes Mikrofon von DevOps Deflope, Geschichten über die Infrastruktur von Skyeng und Nvidia und nicht nur</a></li>
<li><a href="../de464195/index.html">Die Erfolgsgeschichte des Spiels Last Day on Earth aus dem Wolgograder Studio Kefir</a></li>
<li><a href="../de464197/index.html">Was wird auf TechTrain passieren und warum sollte ich dorthin gehen?</a></li>
<li><a href="../de464205/index.html">Wie KI und Neurowissenschaften sich gegenseitig voranbringen</a></li>
<li><a href="../de464207/index.html">Vom Homo sapiens sapiens bis zum Homo, der für die Homo-Wissenschaft oder das Sicherheitsbewusstsein als Erwachsener anfällig ist</a></li>
<li><a href="../de464209/index.html">Gutenberg Editor, wie man Editoren und Schriftsetzer bequem macht</a></li>
<li><a href="../de464217/index.html">So visualisieren Sie Sound im Web: Eine Auswahl thematischer Materialien und Videovorträge mit Theorie und Praxis</a></li>
<li><a href="../de464219/index.html">Timlid-Toolkit von E-Mail an Kanban-Boards</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>