<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🚀 😟 💼 ClickHouse Product Analytics VKontakte 👩‍👩‍👦‍👦 👨🏿‍🌾 😔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En développant n'importe quel produit, qu'il s'agisse d'un service vidéo ou d'une bande, d'histoires ou d'articles, je veux pouvoir mesurer le "bonheu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ClickHouse Product Analytics VKontakte</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/vk/blog/445284/"><img src="https://habrastorage.org/webt/0f/oi/nf/0foinfaynjgjrh11h6w55fr5510.jpeg"><br><br>  En développant n'importe quel produit, qu'il s'agisse d'un service vidéo ou d'une bande, d'histoires ou d'articles, je veux pouvoir mesurer le "bonheur" conditionnel de l'utilisateur.  Pour comprendre si nous apportons des changements meilleurs ou pires, pour ajuster la direction du développement du produit, en fonction non pas de l'intuition et de nos propres sentiments, mais des métriques et des chiffres auxquels vous pouvez croire. <br><br>  Dans cet article, je vais vous expliquer comment nous avons réussi à lancer des statistiques et des analyses de produits sur un service avec une audience mensuelle de 97 millions de dollars, tout en obtenant des requêtes analytiques extrêmement performantes.  Nous parlerons de ClickHouse, des moteurs utilisés et des fonctionnalités des requêtes.  Je vais décrire une approche de l'agrégation de données, qui nous permet d'obtenir des métriques complexes en une fraction de seconde, et parler de la conversion et des tests de données. <br><br>  Maintenant, nous avons environ 6 milliards d'événements alimentaires par jour, dans un avenir proche, nous atteindrons 20 à 25 milliards.  Et puis - pas à un rythme aussi rapide, nous atteindrons 40 à 50 milliards d'ici la fin de l'année, lorsque nous décrirons tous les événements alimentaires qui nous intéressent. <br><br>  <b>1 rangs en jeu.</b>  <b>Écoulé: 0,287 s.</b>  <b>59,85 milliards de lignes traitées, 59,85 Go (208,16 milliards de lignes / s., 208,16 Go / s.)</b> <br><br>  Détails sous la coupe. <br><a name="habracut"></a><br><h1>  Préface </h1><br>  Les outils analytiques étaient VKontakte avant.  Des utilisateurs uniques ont été pris en compte, il a été possible de construire des plannings d'événements par tranches et ainsi de tomber dans les profondeurs du service.  Il s'agissait cependant de tranches fixes d'avance, de données agrégées, de HLL pour les uniques, d'une certaine rigidité et incapacité à répondre rapidement à des questions un peu plus compliquées que "combien?" <br><br>  Bien sûr, il y avait, il y a et aura hadoop, il a également été écrit, écrit et sera écrit beaucoup, beaucoup de journaux d'utilisation des services.  Malheureusement, hdfs n'a été utilisé que par certaines équipes pour implémenter leurs propres tâches.  Encore plus tristement, hdfs ne concerne pas les requêtes analytiques rapides: il y avait des questions dans de nombreux domaines, dont les réponses devaient être trouvées dans le code, et non dans la documentation accessible à tous. <br><br>  Nous sommes arrivés à la conclusion qu'il n'est plus possible de vivre comme ça.  Chaque équipe doit disposer de données, les requêtes doivent être rapides et les données elles-mêmes doivent être précises et riches en paramètres utiles. <br><br>  Par conséquent, nous avons formulé des exigences claires pour le nouveau système de statistiques / analytiques: <br><br><ul><li>  les requêtes analytiques doivent être rapides; </li><li>  les données sont assez précises, idéalement ce sont des événements d'interaction utilisateur bruts avec le service; </li><li>  la structure des événements doit être décrite, comprise et accessible; </li><li>  stockage fiable des données, garantie de livraison unique; </li><li>  il est possible de compter les uniques, l'audience (quotidienne, hebdomadaire, mensuelle), les mesures de rétention, le temps passé par l'utilisateur dans le service, les actions quantifiées sur les mesures uniques et autres par l'ensemble de tranches; </li><li>  les tests, la conversion des données et la visualisation sont en cours. </li></ul><br><h1>  Dans la cuisine </h1><br>  L'expérience a suggéré que nous avions besoin de deux bases de données: une lente, où nous agrégerions et enrichirions les données, et une rapide, où nous pourrions travailler avec ces données et construire des graphiques par-dessus.  C'est l'une des approches les plus courantes, dans laquelle dans une base de données lente, par exemple, dans hdfs, différentes projections sont construites - sur des uniques et sur le nombre d'événements par tranches pendant une certaine période de temps. <br><br>  Par une chaude journée de septembre, en discutant autour d'une tasse de thé dans la cuisine donnant sur la cathédrale de Kazan, nous avons eu l'idée d'essayer ClickHouse comme base rapide - à cette époque, nous l'utilisions déjà pour stocker des journaux techniques.  De nombreux doutes étaient liés principalement à la vitesse et à la fiabilité: les tests de performances déclarés semblaient irréalistes et les nouvelles versions de la base de données interrompaient périodiquement les fonctionnalités existantes.  Par conséquent, la proposition était simple - à essayer. <br><br><h1>  Premiers échantillons </h1><br>  Nous avons déployé un cluster de deux machines avec cette configuration: <br>  2xE5-2620 v4 (32 cœurs au total), 256 Go de RAM, 28 places (raid10 avec ext4). <br><br>  Au départ, c'était proche de la mise en page, mais nous sommes passés à loin.  ClickHouse possède de nombreux moteurs de table différents, mais les principaux sont de la famille MergeTree.  Nous avons choisi ReplicatedReplacingMergeTree avec à peu près les paramètres suivants: <br><br><pre><code class="sql hljs">PARTITION BY dt ORDER BY (toStartOfHour(time), cityHash64(user_id), event_microsec, event_id) SAMPLE BY cityHash64(user_id) SETTINGS index_granularity = 8192;</code> </pre> <br>  <b>Répliqué</b> - signifie que la table est répliquée, ce qui résout l'une de nos exigences de fiabilité. <br><br>  <b>Remplacement</b> - le tableau prend en charge la déduplication par la clé primaire: par défaut, la clé primaire correspond à la clé de tri, donc la section ORDER BY vous indique simplement quelle est la clé primaire. <br><br>  <b>SAMPLE BY</b> - Je voulais également essayer d'échantillonner: sample renvoie un échantillon uniformément pseudo-aléatoire. <br><br>  <b>index_granularity = 8192</b> est le nombre magique de lignes de données entre les empattements d'index (oui, c'est rare), qui est utilisé par défaut.  Nous ne l'avons pas changé. <br><br>  Le partitionnement a été effectué le jour (bien que par défaut - par mois).  De nombreuses demandes de données étaient censées être intrajournalières - par exemple, créer un graphique minute des vues vidéo pour un jour donné. <br><br>  Ensuite, nous avons pris un morceau de journaux techniques et rempli la table avec environ un milliard de lignes.  Excellente compression, regroupement par type de colonne Int *, comptage de valeurs uniques - tout a fonctionné incroyablement vite! <br><br>  En parlant de vitesse, je veux dire que pas une seule requête n'a duré plus de 500 ms, et la plupart d'entre elles tiennent dans 50-100 ms.  Et cela se fait sur deux machines - et, en fait, une seule a été impliquée dans les calculs. <br><br>  Nous avons examiné tout cela et imaginé qu'au lieu de la colonne UInt8, il y aurait un identifiant du pays, et la colonne Int8 serait remplacée par des données, par exemple, sur l'âge de l'utilisateur.  Et ils ont réalisé que ClickHouse nous convenait parfaitement, si tout était fait correctement. <br><br><h1>  Saisie forte des données </h1><br>  L'avantage de ClickHouse commence exactement lorsque le schéma de données correct est formé.  Exemple: plateforme String - mauvaise, plateforme Int8 + dictionnaire - bonne, LowCardinality (String) - pratique et bonne (je parlerai de LowCardinality un peu plus tard). <br><br>  Nous avons créé une classe de générateur spéciale en php, qui, sur demande, crée des classes wrapper sur des événements basés sur des tables dans ClickHouse, et un point d'entrée unique pour la journalisation.  Je vais expliquer l'exemple du schéma qui s'est avéré: <br><br><ol><li>  L'analyste / ingénieur / développeur de données décrit la documentation: quels champs, valeurs possibles, événements doivent être enregistrés. </li><li>  Un tableau est créé dans ClickHouse conformément à la structure de données du paragraphe précédent. </li><li>  Des classes d'habillage pour les événements basés sur une table sont générées. </li><li>  L'équipe produit implémente le remplissage des champs d'un objet de cette classe, l'envoi. </li></ol><br>  Changer le schéma au niveau php et le type de données enregistrées ne fonctionnera pas sans d'abord changer la table dans ClickHouse.  Et cela, à son tour, ne peut se faire sans coordination avec l'équipe, modifications de la documentation et description des événements. <br><br>  Pour chaque événement, vous pouvez définir deux paramètres qui contrôlent respectivement le pourcentage d'événements envoyés à ClickHouse et hadoop.  Les paramètres sont nécessaires principalement pour un roulement progressif avec la possibilité de réduire la journalisation en cas de problème.  Avant hadoop, les données sont livrées de manière standard à l'aide de Kafka.  Et dans ClickHouse, ils volent à travers un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">schéma avec KittenHouse</a> en mode persistant, ce qui garantit au moins une livraison d'événement unique. <br><br>  L'événement est remis à la table tampon dans le fragment souhaité, sur la base du reste de la division du hachage de user_id par le nombre de fragments dans le cluster.  Ensuite, la table tampon vide les données dans le ReplicatedReplacingMergeTree local.  Et au-dessus des tables locales, une table distribuée est extraite avec le moteur distribué, qui vous permet d'accéder aux données de tous les fragments. <br><br><h1>  Dénormalisation </h1><br>  ClickHouse est un SGBD en colonnes.  Il ne s'agit pas de formulaires normaux, ce qui signifie qu'il vaut mieux avoir toutes les informations sur l'événement que de se joindre.  Il y a aussi Join, mais si la bonne table ne tient pas en mémoire, la douleur commence.  Par conséquent, nous avons pris une décision ferme: toutes les informations qui nous intéressent doivent être stockées dans l'événement lui-même.  Par exemple, le sexe, l'âge de l'utilisateur, le pays, la ville, l'anniversaire - toutes ces informations publiques peuvent être utiles pour l'analyse d'audience, ainsi que toutes les informations utiles sur l'objet d'interaction.  Si, par exemple, nous parlons de vidéo, il s'agit de video_id, video_owner_id, la date de mise en ligne de la vidéo, la durée, la qualité au moment de l'événement, la qualité maximale, etc. <br><br>  Au total, dans chaque table, nous avons de 50 à 200 colonnes, tandis que dans toutes les tables, il y a des champs de service.  Par exemple, le journal des erreurs est error_log - en fait, nous appelons une erreur hors de portée du type.  Au cas où des valeurs étranges dépasseraient la taille du type dans le champ avec l'âge. <br><br><h2>  Type LowCardinality (T) </h2><br>  ClickHouse a la possibilité d'utiliser des dictionnaires externes.  Ils sont stockés en mémoire, mis à jour périodiquement, peuvent être efficacement utilisés dans divers scénarios, y compris comme des ouvrages de référence classiques.  Par exemple, vous souhaitez enregistrer le système d'exploitation et vous avez deux alternatives: une chaîne ou un nombre + un répertoire.  Bien sûr, sur de grandes quantités de données et pour les requêtes analytiques hautes performances, il est logique d'écrire un nombre et d'obtenir une représentation sous forme de chaîne à partir du dictionnaire lorsque vous avez besoin: <br><br><pre> <code class="sql hljs">dictGetString('os', 'os_name', toUInt64(os_id))</code> </pre> <br>  Mais il existe un moyen beaucoup plus pratique - d'utiliser le type LowCardinality (String), qui crée automatiquement un dictionnaire.  La performance avec LowCardinality sous la condition de faible cardinalité de l'ensemble de valeurs est radicalement plus élevée qu'avec String. <br><br>  Par exemple, nous utilisons LowCardinality (String) pour les types d'événements 'play', 'pause', 'rewind'.  Ou pour la plateforme: 'web', 'android', 'iphone': <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> vk_platform, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> dt = yesterday() <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> vk_platform Elapsed: <span class="hljs-number"><span class="hljs-number">0.145</span></span> sec. Processed <span class="hljs-number"><span class="hljs-number">1.98</span></span> billion <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>, <span class="hljs-number"><span class="hljs-number">5.96</span></span> GB (<span class="hljs-number"><span class="hljs-number">13.65</span></span> billion <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>/s., <span class="hljs-number"><span class="hljs-number">41.04</span></span> GB/s.)</code> </pre> <br>  La fonctionnalité est encore expérimentale, donc pour l'utiliser, vous devez effectuer: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> allow_experimental_low_cardinality_type = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Mais on a le sentiment qu’après un certain temps, elle ne sera plus sous le décor. <br><br><h1>  Agrégation de données VKontakte </h1><br>  Puisqu'il y a beaucoup de colonnes et qu'il y a beaucoup d'événements, le désir naturel est de couper les «vieilles» partitions, mais d'abord - d'assembler les unités.  Parfois, il est nécessaire d'analyser les événements bruts (il y a un mois ou un an), afin de ne pas couper les données en hdfs - tout analyste peut contacter le parquet souhaité pour n'importe quelle date. <br><br>  En règle générale, lors de l'agrégation dans un intervalle de temps, nous nous appuyons toujours sur le fait que le nombre de lignes par unité de temps est égal au produit de la puissance de coupure.  Cela impose des restrictions: les pays commencent à se regrouper en groupes tels que `` Russie '', `` Asie '', `` Europe '', `` Le reste du monde '', et les âges - à intervalles pour réduire la dimension à un million de lignes conditionnelles par date. <br><br><h2>  Agrégation par <b>dt, user_id</b> </h2><br>  Mais nous avons un ClickHouse réactif!  Pouvons-nous accélérer à 50-100 millions de lignes à une date? <br>  Des tests rapides ont montré que nous pouvions, et à ce moment une idée simple a surgi - laisser l'utilisateur dans la machine.  À savoir, pour agréger non pas par «date, tranches» à l'aide d'outils spark, mais par «date, utilisateur» signifie par ClickHouse, tout en faisant une «transposition» des données. <br><br>  Avec cette approche, nous stockons les utilisateurs dans des données agrégées, ce qui signifie que nous pouvons toujours prendre en compte les indicateurs d'audience, la rétention et les mesures de fréquence.  Nous pouvons connecter des unités, en comptant les audiences communes de plusieurs services jusqu'à l'audience VKontakte entière.  Tout cela peut être fait par n'importe quelle tranche qui est présente dans le tableau pour le même temps conditionnellement. <br><br>  Je vais illustrer avec un exemple: <br><br><img src="https://habrastorage.org/webt/1n/zq/23/1nzq23ia7micv91mecw0kqzxgrm.jpeg"><br><br>  Après agrégation (beaucoup plus de colonnes à droite): <br><br><img src="https://habrastorage.org/webt/nx/ol/xl/nxolxl2vmnnlsxlx6svuaklh9go.jpeg"><br><br>  Dans ce cas, l'agrégation se produit précisément par (dt, user_id).  Pour les champs contenant des informations utilisateur, avec une telle agrégation, vous pouvez utiliser les fonctions any, anyHeavy (sélectionne une valeur fréquente).  Vous pouvez, par exemple, collecter anyHeavy (plateforme) dans un agrégat pour savoir quelle plateforme l'utilisateur utilise pour la plupart à partir d'événements vidéo.  Si vous le souhaitez, vous pouvez utiliser groupUniqArray (plateforme) et stocker un tableau de toutes les plateformes à partir desquelles l'utilisateur a déclenché l'événement.  Si cela ne suffit pas, vous pouvez créer des colonnes distinctes pour la plateforme et stocker, par exemple, le nombre de vidéos uniques visionnées à la moitié à partir d'une plateforme spécifique: <br><br><pre> <code class="sql hljs">uniqCombinedIf(cityHash64(video_owner_id, video_id), (platform = 'android') AND (event = '50p')) as uniq_videos_50p_android</code> </pre> <br>  Avec cette approche, on obtient un agrégat assez large dans lequel chaque ligne est un utilisateur unique, et chaque colonne contient des informations soit sur l'utilisateur, soit sur son interaction avec le service. <br><br>  Il s'avère que pour calculer la DAU d'un service, il suffit d'exécuter une telle demande au-dessus de son agrégat: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> dt, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> DAU <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> agg <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> dt Elapsed: <span class="hljs-number"><span class="hljs-number">0.078</span></span> sec.</code> </pre> <br>  Ou calculez combien de jours les utilisateurs ont été dans le service pour la semaine: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> days_in_service, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> uniques <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> uniqUpTo(<span class="hljs-number"><span class="hljs-number">7</span></span>)(dt) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> days_in_service <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> agg2 <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> dt &gt; (yesterday() - <span class="hljs-number"><span class="hljs-number">7</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> user_id ) <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> days_in_service <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> days_in_service <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> set. Elapsed: <span class="hljs-number"><span class="hljs-number">2.922</span></span> sec.</code> </pre> <br>  Nous pouvons accélérer par échantillonnage, tout en perdant presque toute précision: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> days_in_service, <span class="hljs-number"><span class="hljs-number">10</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> uniques <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> uniqUpTo(<span class="hljs-number"><span class="hljs-number">7</span></span>)(dt) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> days_in_service <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> agg2 <span class="hljs-keyword"><span class="hljs-keyword">SAMPLE</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> dt &gt; (yesterday() - <span class="hljs-number"><span class="hljs-number">7</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> user_id ) <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> days_in_service <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> days_in_service <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> set. Elapsed: <span class="hljs-number"><span class="hljs-number">0.454</span></span> sec.</code> </pre> <br>  Il convient de noter tout de suite que l'échantillonnage n'est pas basé sur le pourcentage d'événements, mais sur le pourcentage d'utilisateurs - et en conséquence, il devient un outil incroyablement puissant. <br><br>  Ou la même chose pendant 4 semaines avec 1/100 d'échantillonnage - environ 1% de résultats moins précis sont obtenus. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> days_in_service, <span class="hljs-number"><span class="hljs-number">100</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> uniques <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> uniqUpTo(<span class="hljs-number"><span class="hljs-number">7</span></span>)(dt) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> days_in_service <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> agg2 <span class="hljs-keyword"><span class="hljs-keyword">SAMPLE</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> dt &gt; (yesterday() - <span class="hljs-number"><span class="hljs-number">28</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> user_id ) <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> days_in_service <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> days_in_service <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span> <span class="hljs-number"><span class="hljs-number">28</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> set. Elapsed: <span class="hljs-number"><span class="hljs-number">0.287</span></span> sec.</code> </pre> <br><h2>  Agrégation d'autre part </h2><br>  Lors de l'agrégation par (dt, user_id), nous ne perdons pas l'utilisateur, nous ne manquons pas d'informations sur son interaction avec le service, mais, bien sûr, nous perdons les métriques sur un objet d'interaction spécifique.  Mais vous ne pouvez pas perdre cela non plus - construisons l'unité en <br>  (dt, video_owner_id, video_id), en adhérant aux mêmes idées.  Nous conservons autant que possible les informations sur la vidéo, nous ne manquons pas de données sur l'interaction de la vidéo avec l'utilisateur et nous manquons complètement les informations sur l'utilisateur spécifique. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> starts <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> agg3 <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> (dt = yesterday()) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> (video_id = ...) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> (video_owner_id = ...) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> set. Elapsed: <span class="hljs-number"><span class="hljs-number">0.030</span></span> sec</code> </pre> <br>  Ou le top 10 des vidéos vues hier: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> video_id, video_owner_id, watches <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> video_agg_video_d1 <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> dt = yesterday() <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> watches <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> set. Elapsed: <span class="hljs-number"><span class="hljs-number">0.035</span></span> sec.</code> </pre> <br>  En conséquence, nous avons un schéma d'agrégats de la forme: <br><br><ul><li>  agrégation par «date, utilisateur» dans le produit; </li><li>  agrégation par «date, objet d'interaction» au sein du produit; </li><li>  parfois d'autres projections surgissent. </li></ul><br><h1>  Azkaban et TeamCity </h1><br>  Enfin, quelques mots sur l'infrastructure.  Notre collecte d'agrégats commence la nuit, en commençant par OPTIMISER sur chacune des tables avec des données brutes pour déclencher une fusion de données extraordinaire dans ReplicatedReplacingMergeTree.  L'opération peut durer assez longtemps, cependant, il est nécessaire de retirer les prises, si elles se produisent.  Il convient de noter que, jusqu'à présent, je n'ai jamais rencontré de doublons, mais rien ne garantit qu'ils n'apparaîtront pas à l'avenir. <br><br>  L'étape suivante est la création d'agrégats.  Ce sont des scripts bash dans lesquels les événements suivants se produisent: <br><br><ul><li>  nous obtenons d'abord le nombre de fragments et un hôte du fragment: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> shard_num, <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>(host_name) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> host <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> system.clusters <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> shard_num</code> </pre> </li><li>  puis le script exécute séquentiellement pour chaque fragment (clickhouse-client -h $ host) une requête du formulaire (pour les agrégats par utilisateurs): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">SAMPLE</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>/$shards_count <span class="hljs-keyword"><span class="hljs-keyword">OFFSET</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>/$shard_num</code> </pre> </li></ul><br>  Ce n'est pas entièrement optimal et peut générer de nombreuses interactions réseau entre les hôtes.  Cependant, lors de l'ajout de nouveaux fragments, tout continue à fonctionner, la localité des données pour les unités est conservée, nous avons donc décidé de ne pas trop nous en préoccuper. <br><br>  Nous avons Azkaban comme planificateur de tâches.  Je ne dirais pas que c'est un outil super pratique, mais il fait parfaitement face à sa tâche, y compris lorsqu'il s'agit de construire des pipelines légèrement plus complexes et lorsqu'un script doit attendre que plusieurs autres se terminent. <br><br>  Le temps total consacré à la conversion des événements existants en agrégats est de 15 minutes. <br><br><h2>  Test </h2><br>  Chaque matin, nous effectuons des tests automatisés qui répondent aux questions concernant les données brutes, ainsi que la disponibilité et la qualité des agrégats: «Vérifiez que pour hier il n'y avait pas plus d'un demi pour cent de données en moins ou des données uniques sur les données brutes ou dans les agrégats par rapport au même jour il y a une semaine. " <br><br>  Technologiquement, ce sont des tests unitaires ordinaires utilisant JUnit et implémentant le pilote jdbc pour ClickHouse.  L'exécution de tous les tests est lancée dans TeamCity et prend environ 30 secondes dans 1 thread, et en cas d'échecs, nous recevons des notifications VKontakte de notre merveilleux bot TeamCity. <br><br><h1>  Conclusion </h1><br>  Utilisez uniquement des versions stables de ClickHouse et vos cheveux seront doux et soyeux.  Il convient d'ajouter que <b><i>ClickHouse ne ralentit pas</i></b> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr445284/">https://habr.com/ru/post/fr445284/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr445272/index.html">JavaScript est le meilleur langage de programmation pour les débutants. C'est vrai ou pas?</a></li>
<li><a href="../fr445274/index.html">Lorsque "Zoë"! == "Zoë", ou pourquoi vous devez normaliser les chaînes Unicode</a></li>
<li><a href="../fr445276/index.html">Guide d'utilisation complet</a></li>
<li><a href="../fr445278/index.html">Comment créer un jeu si vous n'êtes jamais artiste</a></li>
<li><a href="../fr445280/index.html">Rentabilité des sites et des services</a></li>
<li><a href="../fr445286/index.html">Repose-pieds pour le cerveau: Hedera Hashgraph Distributed Registry Platform</a></li>
<li><a href="../fr445288/index.html">Tous vos prêts à la consommation et vos données personnelles «en un seul endroit» ...</a></li>
<li><a href="../fr445290/index.html">Comment mettre en œuvre des processus unifiés prenant en compte toutes les fonctionnalités de l'entreprise?</a></li>
<li><a href="../fr445292/index.html">Ce qu'on ne m'a jamais dit sur CSS</a></li>
<li><a href="../fr445294/index.html">Et encore une fois sur le deuxième moniteur de la tablette ...</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>