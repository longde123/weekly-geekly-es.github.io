<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍✈️ 🌕 👨‍💻 Kesalahan logging umum ↘️ 🛬 👧🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! 


 Saya pikir hampir setiap program memiliki pencatatan. Selain itu, di sejumlah aplikasi yang sudah baru (yang berarti dengan kondisi la...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kesalahan logging umum</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458436/"><p>  Halo, Habr! </p><br><p>  Saya pikir hampir setiap program memiliki pencatatan.  Selain itu, di sejumlah aplikasi yang sudah baru (yang berarti dengan kondisi laut nontrivial), log sering menjadi vital di server tempur. </p><br><p>  Namun, terlepas dari pentingnya dan prevalensi teknologi semacam itu, saya perhatikan bahwa orang sering membuat kesalahan standar ketika bekerja dengan mereka.  Artikel ini menjelaskan perilaku. Net dalam banyak hal, namun, saya membuat sisipan kecil dari dunia Jawa, hanya untuk perbandingan. </p><a name="habracut"></a><br><h1 id="allokacii-vydelenie-pamyati">  Alokasi (alokasi memori) </h1><br><p> Kesalahan paling umum (menurut pengamatan saya) adalah kelalaian dalam kaitannya dengan alokasi memori kecil di dekat tempat panggilan ke fungsi <code>log.Debug(...)</code> . </p><br><p>  Jadi, kode standar kami di .Net: </p><br><pre> <code class="plaintext hljs">private static readonly ILog Log4NetLog = LogManager.GetLogger(typeof(Program)); private static readonly Logger NLogLog = NLog.LogManager.GetCurrentClassLogger(); private static void PublishData(int id, string name, EMail email, decimal amount) { Log4NetLog.Debug($"Id={id}"); // 1 Log4NetLog.DebugFormat("Id={0}", id); // 2 Log4NetLog.Debug($"Id={id}; name={name}; email={email.Normalize()}; amount={amount}"); // 3 Log4NetLog.DebugFormat("Id={0}; name={1}; email={2}; amount={3}", id, name, email.Normalize(), amount); // 4 NLogLog.Debug($"Id={id}"); // 5 NLogLog.Debug("Id={0}", id); // 6 NLogLog.Debug($"Id={id}; name={name}; email={email.Normalize()}; amount={amount}"); // 7 NLogLog.Debug("Id={0}; name={1}; email={2}; amount={3}", id, name, email.Normalize(), amount); // 8 }</code> </pre> <br><p>  Dalam banyak hal, saya hanya melihat perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">log4net</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NLog</a> , dan karena itu saya akan menggunakannya dalam contoh. </p><br><p>  Jadi pertanyaannya adalah: </p><br><ul><li>  Di baris mana memori akan dialokasikan bahkan jika Debug dimatikan? </li><li>  Jika memori dialokasikan, seberapa mudahnya untuk mendeteksi dalam dotTrace yang sama yang secara khusus dipersalahkan oleh para penebang karena alokasi memori ini? </li></ul><br><p>  Jawaban yang benar untuk pertanyaan pertama: memori tidak hanya dialokasikan dalam paragraf "6".  Dan jawaban untuk pertanyaan kedua: sangat sulit ditangkap, karena kode seperti itu sering tersebar di proyek.  Anda mungkin mengingat aplikasi .Net yang khas.  Sering kali akan memiliki kode serupa yang membuat GC berfungsi. </p><br><p>  Namun, mari kita lihat detail teknis untuk memahami dengan tepat di mana kita akan berdampak pada kinerja. </p><br><p>  Jadi poin pertama: </p><br><pre> <code class="plaintext hljs">Log4NetLog.Debug($"Id={id}"); // 1</code> </pre> <br><p>  Faktanya, kompiler akan mengubahnya menjadi: </p><br><pre> <code class="plaintext hljs">var temp = string.Format("Id={0}", id); // &lt;--       Log4NetLog.Debug(temp);</code> </pre> <br><p>  Artinya, ekspresi pertama pada dasarnya akan memaksa prosesor untuk membuat string, meneruskannya ke logger.  Dia akan dengan cepat memeriksa bahwa Anda tidak perlu login, dan oleh karena itu baris baru saja dibuat di memori.  Dan, yang penting, jika Anda menyalin lebih banyak kode seperti itu, maka baris akan dibuat di banyak tempat program, yaitu, program akan bekerja sedikit lebih lambat.  Di mana-mana. </p><br><p>  Contoh kedua sedikit lebih efisien, karena baris tidak dibuat di dalamnya: </p><br><pre> <code class="plaintext hljs">Log4NetLog.DebugFormat("Id={0}", id);</code> </pre> <br><p>  Namun, memori masih dialokasikan di sini, karena tinju akan terjadi.  Biarkan saya mengingatkan Anda tanda tangan dari metode DebugFormat: </p><br><pre> <code class="plaintext hljs">void DebugFormat(string format, object arg0)</code> </pre> <br><p>  Seperti yang Anda lihat, input membutuhkan tipe referensi.  Namun, kami mencoba untuk melewati tipe <code>int</code> berarti.  Akibatnya, setiap panggilan akan menghasilkan <code>id</code> parameter tumpukan yang diteruskan untuk meneruskannya ke metode.  Dan izinkan saya mengingatkan Anda bahwa parameter itu sendiri tidak diperlukan dalam metode itu sendiri, karena <code>Debug</code> dimatikan oleh kondisi tugas. </p><br><p>  Contoh berikut ini dimuat dan sederhana: </p><br><pre> <code class="plaintext hljs">Log4NetLog.Debug($"Id={id}; name={name}; email={email.Normalize()}; amount={amount}"); // 3</code> </pre> <br><p>  Saya yakin Anda sudah mengerti bahwa sekali lagi garis akan menonjol di tumpukan dan seterusnya.  Karena itu, segera lewati contoh ini.  Metode panggilan berikut terlihat lebih efisien: </p><br><pre> <code class="plaintext hljs">Log4NetLog.DebugFormat("Id={0}; name={1}; email={2}; amount={3}", id, name, email.Normalize(), amount); // 4</code> </pre> <br><p>  Namun demikian, mari kita hitung berapa kali perlu mengalokasikan sepotong memori: </p><br><ul><li>  <code>email.Normalize()</code> mengarah ke pembuatan beberapa jenis objek.  Oleh karena itu, objek ini akan dialokasikan pada heap (atau pada stack - itu tidak masalah, karena tinju akan membuatnya perlu untuk memilih semua yang ada di heap) </li><li>  <code>id</code> akan menuju heap, seperti yang sudah kita bahas sebelumnya. </li><li>  Log4net memiliki antarmuka berikut untuk panggilan panjang yang diformat: <code>void DebugFormat(string format, params object[] args)</code> .  Seperti yang Anda lihat, .Net akan membuat array di heap untuk meneruskannya ke metode <code>DebugFormat</code> . </li></ul><br><p>  Akibatnya, panggilan yang cukup tipikal untuk operasi logging akan mengarah pada penciptaan tumpukan objek dalam memori.  Yang agak mengecewakan, karena logging itu sendiri sering dimatikan.  Namun, mari kita beralih ke NLog. </p><br><p>  Baris ini akan memancing alokasi objek pada heap: </p><br><pre> <code class="plaintext hljs">NLogLog.Debug($"Id={id}");</code> </pre> <br><p>  Semuanya jelas di sini, tetapi garis di bawah tidak lagi memiliki kelemahan seperti itu: </p><br><pre> <code class="plaintext hljs">NLogLog.Debug("Id={0}", id);</code> </pre> <br><p>  Dan alasannya adalah NLog memiliki tanda tangan khusus untuk ints: <code>void Debug(string message, int argument)</code> .  Selain itu, bahkan jika Anda mentransfer struktur yang berbeda, metode <code>void Debug&lt;TArgument&gt;([Localizable(false)] string message, TArgument argument)</code> .  Dan metode ini tidak memerlukan tinju, karena setelah JIT fungsi terpisah akan dibuat untuk setiap jenis (tentu saja, ini tidak sepenuhnya benar, tetapi poin pentingnya adalah: tidak akan ada tinju). </p><br><p>  Saya akan melewati skrip yang mudah dipahami dengan jalur input besar dan langsung ke: </p><br><pre> <code class="plaintext hljs">NLogLog.Debug("Id={0}; name={1}; email={2}; amount={3}", id, name, email.Normalize(), amount);</code> </pre> <br><p>  Anehnya, NLog tidak menambah jumlah parameter Generik untuk metode, dan oleh karena itu tanda tangan akan digunakan: <code>void Debug([Localizable(false)] string message, params object[] args)</code> .  Dan itu lagi akan mengarah pada penciptaan objek di tumpukan dan seterusnya. </p><br><h2 id="vyvody-i-uluchsheniya">  Kesimpulan dan Perbaikan </h2><br><p>  Kesimpulan utama: jika Anda memiliki banyak panggilan ke metode logging di program yang tidak mengarah ke penulisan fisik ke file, maka Anda bisa tiba-tiba mulai mengalokasikan banyak objek yang tidak perlu pada heap.  Dan dengan demikian menghambat kerja program. </p><br><p>  Kesimpulan 2: Jika Anda melewatkan tidak banyak objek ke suatu metode, gunakan NLog.  Karena faktanya memperhatikan parameter Generic, Anda bisa lebih santai tentang kinerjanya. </p><br><p>  Namun, agar benar-benar aman, lebih logis untuk melakukan ini: </p><br><pre> <code class="plaintext hljs">if (NLogLog.IsDebugEnabled) { NLogLog.Debug($"Id={id}; name={name}; email={email.Normalize()}; amount={amount}"); }</code> </pre> <br><p>  Di sini metode logging tidak akan dipanggil jika tidak perlu.  Namun, jika Anda masih harus membuang data ke log, maka Interpolasi String yang nyaman akan digunakan.  Di dalam, logger (setidaknya NLog yang sama) memiliki optimisasi untuk menulis baris ke log secara langsung (mis. Pemformatan akan muncul segera di <code>Stream</code> , alih-alih membuat garis dalam memori).  Namun, pengoptimalan NLog ini memudar dengan fakta bahwa Anda harus mengatur ulang data ke file. </p><br><h2 id="primer-iz-kotlin">  Contoh Kotlin </h2><br><p>  Untuk mencairkan deskripsi karya para penebang populer di .Net, saya akan memberikan cara yang menarik untuk melakukan panggilan di kotlin.  Idenya didasarkan pada satu fitur bahasa yang menarik: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">metode inline</a> .  Jadi, kode sederhana untuk mengeluarkan sesuatu ke debug: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeService</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : KLogging() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">publishData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ logger.debug { <span class="hljs-string"><span class="hljs-string">"Identity: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$id</span></span></span><span class="hljs-string">"</span></span> } } }</code> </pre> <br><p>  Dan itu akan dikonversi oleh kompiler menjadi sesuatu seperti ini: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeService</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : KLogging() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">publishData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(logger.isDebugEnabled){ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> message = <span class="hljs-string"><span class="hljs-string">"Identity: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$id</span></span></span><span class="hljs-string">"</span></span> logger.debug(message) }<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception){ <span class="hljs-comment"><span class="hljs-comment">/*handle*/</span></span> } } } }</code> </pre> <br><p>  Ini penting di sini: semua yang ada di dalam kawat gigi dekat <code>debug</code> adalah lambda.  Namun, itu akan tertanam dalam metode Anda, yaitu, objek fungsi tidak akan dibuat di heap.  Dengan demikian, Anda dapat menyembunyikan operasi besar di dalam, yang akan dipanggil hanya jika Anda ingin menampilkan hasilnya ke <code>debug</code> .  Sebagai contoh: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeService</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : KLogging() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">publishData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ logger.debug { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> idList = getIdList() <span class="hljs-string"><span class="hljs-string">"Identity: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$idList</span></span></span><span class="hljs-string">"</span></span> } } }</code> </pre> <br><p>  Di sini <code>getIdList</code> akan dipanggil hanya jika Anda perlu mengirim sesuatu ke file.  Dan semua itu karena kode tersebut dikonversi menjadi: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeService</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : KLogging() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">publishData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(logger.isDebugEnabled){ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> idList = getIdList() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> message = <span class="hljs-string"><span class="hljs-string">"Identity: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$idList</span></span></span><span class="hljs-string">"</span></span> logger.debug(message) }<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (){ <span class="hljs-comment"><span class="hljs-comment">/*handle*/</span></span> } } logger.debug { <span class="hljs-string"><span class="hljs-string">"Identity: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$id</span></span></span><span class="hljs-string">"</span></span> } } }</code> </pre> <br><h1 id="large-object--large-object-heap">  Obyek Besar ==&gt; Tumpukan Objek Besar </h1><br><p>  Selain contoh sebelumnya.  Saya yakin banyak orang tahu bahwa .Net / JVM memiliki konsep "Large Object Heap".  Lebih tepatnya, tidak ada definisi khusus di Jawa, namun, pengalokasi akan sering membuat objek besar segera di generasi terbaru (untuk meminimalkan pergerakan objek dan meratakan masalah penetrasi memori cepat untuk pengalokasi streaming). </p><br><p>  Kembali ke contoh: </p><br><pre> <code class="plaintext hljs">NLogLog.Debug($"Id={id}");</code> </pre> <br><p>  Seperti yang Anda pahami, jika objek <code>id</code> memiliki implementasi <code>ToString</code> , yang membuat string seukuran megabyte, maka klik berikut di wajah LOH: </p><br><ul><li>  Panggilan <code>ToString</code> sendiri </li><li>  Memformat <code>$"Id={id}"</code> </li><li>  Dan jika pengembang logger tidak menangkap semua hal ini (dan sangat sulit untuk menulis tes untuk ketiadaan objek di LOH), maka logger akan menambah masalah. </li></ul><br><p>  Dan di sini Anda dapat menggunakan tiga metode logging hal-hal seperti: </p><br><ul><li>  Gunakan tata letak khusus dan tidak memerlukan panggilan ke <code>ToString</code> .  Misalnya, NLog memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JsonLayout</a> .  Dengan demikian, Anda dapat dengan mudah mentransfer objek ke logger, yang akan segera diserialisasi ke aliran yang dihasilkan (misalnya, ke file). </li><li>  Tulis sendiri ke file.  Atau dengan kata lain - jangan gunakan logger.  Saya hanya bisa memberi saran tentang bagaimana saya mencari tahu file NLog mana yang akan menulis: <code>var filePath = NLog.LogManager.Configuration.AllTargets.OfType&lt;FileTarget&gt;().First().FileName.Render(LogEventInfo.CreateNullEvent())</code> .  Jelas, fungsi ini akan mengembalikan <code>FileTarget</code> pertama yang muncul, tetapi jika semua orang menulis ke folder yang sama, dengan cara yang sama Anda dapat mengetahui folder untuk direkam, dan kemudian langsung mengirim dump objek Anda ke file. </li><li>  Jika Anda memiliki log4j2 (yang kedua penting), maka Anda dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">StringBuilderFormattable</a> .  Itu baru saja dibuat untuk menampilkan data ke dalam logger dalam potongan-potongan (apalagi, agar tidak mengalokasikan bagian dari potongan-potongan di tumpukan, karena mereka sudah dipilih). </li></ul><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilderFormattable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Writes a text representation of this object into the specified {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> StringBuilder}, ideally without allocating * temporary objects. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> buffer the StringBuilder to write into */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">formatTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StringBuilder buffer)</span></span></span></span>; }</code> </pre> <br><h1 id="sinhronnost-i-problemy-asinhronnosti">  Sinkronisasi (dan masalah sinkronisasi) </h1><br><p>  Suatu ketika, dalam satu program, saya perhatikan bahwa selama operasi yang dimuat, sekitar setengah waktu tunggu UI dicatat oleh operasi logging.  Sekali lagi: setengah dari waktu program dihabiskan untuk panggilan ke <code>logger.Debug</code> atau sesuatu seperti itu.  Dan alasannya sederhana: kami menggunakan log4net, yang hanya dapat menulis file secara sinkron. </p><br><p>  Dari sini saya menyimpulkan <strong>aturan 1</strong> : logger harus selalu bekerja di utas lainnya.  Anda tidak boleh memblokir kode aplikasi demi jejak, karena ini sangat aneh.  Dengan kata lain - menggunakan NLog - Anda selalu harus memasukkan <code>async=true</code> di tag <code>nlog</code> (ini yang utama).  Atau, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contohnya</a> : </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">targets</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">async</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag">&gt;</span></span> ... your targets go here ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">targets</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Jika Anda menggunakan log4net, maka arahkan dari NLog, atau buat AsyncFileAppender. </p><br><p>  Untuk dunia Java: Logback dan Log4J2 memiliki kemampuan untuk melakukan logging asinkron.  Berikut ini adalah perbandingan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs resmi</a> : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b9b/924/cb3/b9b924cb3725252b98aae0c6ffdc8aa0.png" alt="Gambar"></p><br><p>  Namun, ketika semuanya ditulis secara tidak sinkron, muncul masalah lain - apa yang harus dilakukan jika terjadi kesalahan kritis?  Setelah semua, itu terjadi bahwa suatu program tidak keluar karena telah meninggalkan utas <code>Main</code> (misalnya, suatu program dapat keluar dengan memanggil <code>Application.Exit</code> atau <code>Environment.FailFast</code> , yang tidak terlalu indah, tetapi memang terjadi).  Dalam hal ini, Anda harus selalu memanggil <code>Flush</code> sebelum mematikan proses Anda.  Kalau tidak, jika Anda jatuh di server pertempuran, informasi yang paling berharga akan terlewatkan. </p><br><h1 id="vyvod">  Kesimpulan </h1><br><p>  Saya harap artikel ini membantu Anda menulis program cepat dengan pencatatan yang nyaman.  Saya menyoroti hanya sebagian dari masalah yang saya lihat bagian dalam kode.  Semuanya bukan yang paling jelas, tetapi bukan yang paling sulit. </p><br><p>  Bagaimanapun, seperti yang saya katakan di awal, bekerja dengan penebang hampir di setiap aplikasi.  Selain itu, menurut catatan saya, sekitar setengah dari kelas itu sendiri mengeluarkan sesuatu ke log.  Dengan demikian, operasi yang benar dengan fungsi-fungsi ini mempengaruhi hampir seluruh aplikasi. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458436/">https://habr.com/ru/post/id458436/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458424/index.html">Drone Show: Tampilan Dalam</a></li>
<li><a href="../id458426/index.html">Proyeksi peta: apa yang sebenarnya bercanda xkcd</a></li>
<li><a href="../id458428/index.html">Google membuka kode sumber pengurai robots.txt</a></li>
<li><a href="../id458432/index.html">Menggabungkan beberapa paket menjadi satu namespace Python</a></li>
<li><a href="../id458434/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 11. Dasar-Dasar VLAN</a></li>
<li><a href="../id458440/index.html">Dukungan teknis di hari kerja: cerita tentang apa yang terjadi ketika Anda tidak dapat menjangkau pengguna</a></li>
<li><a href="../id458442/index.html">Mengapa LLVM dapat memanggil fungsi yang tidak pernah dipanggil?</a></li>
<li><a href="../id458444/index.html">Internet untuk penduduk musim panas. Bagian 4. Satu kartu SIM sudah cukup</a></li>
<li><a href="../id458446/index.html">Pusat data Hyperscale: siapa yang membangunnya dan berapa biayanya</a></li>
<li><a href="../id458450/index.html">Karakteristik komputer kuantum</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>