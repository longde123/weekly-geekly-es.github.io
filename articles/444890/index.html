<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游꺂 游녡游 游똂游낕 Docena de trucos con Linux Shell que podr칤an ahorrarle tiempo 游닔 游꽂 游꼛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="- En primer lugar, puedes leer este art칤culo en ruso aqu칤 . 
 Una tarde, mientras le칤a Dominando las expresiones regulares de Jeffrey Friedl , me di c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Docena de trucos con Linux Shell que podr칤an ahorrarle tiempo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444890/"><div style="text-align:center;"><img width="90%" src="https://habrastorage.org/webt/fs/43/05/fs4305wjukd5umg71ochqeqxxek.png"></div><br><br><ul><li>  <i>En primer lugar, puedes leer este art칤culo en ruso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu칤</a> .</i> </li></ul><br>  Una tarde, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mientras</a> le칤a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dominando las expresiones regulares de Jeffrey Friedl</a> , me di cuenta de que incluso si tiene toda la documentaci칩n y mucha experiencia, podr칤a haber muchos trucos desarrollados por diferentes personas y encarcelados por ellos mismos.  Todas las personas son diferentes.  Y las t칠cnicas que son obvias para ciertas personas pueden no ser obvias para otros y parecer una especie de magia extra침a para una tercera persona.  Por cierto, ya describ칤 varios de estos momentos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu칤 (en ruso)</a> . <br><br>  Para el administrador o el usuario, la l칤nea de comandos no es solo una herramienta que puede hacer todo, sino tambi칠n una herramienta altamente personalizada que podr칤a desarrollarse para siempre.  Recientemente hubo un art칤culo traducido sobre algunos trucos 칰tiles en CLI.  Pero siento que el traductor no tiene suficiente experiencia con CLI y no sigui칩 los trucos descritos, por lo que muchas cosas importantes podr칤an perderse o malinterpretarse. <br><br>  Under the cut: una docena de trucos en el shell de Linux desde mi experiencia personal. <br><a name="habracut"></a><br>  Nota: Todos los scripts y ejemplos en el art칤culo se simplificaron especialmente tanto como sea posible, por lo que quiz치s pueda encontrar varios trucos que parecen completamente in칰tiles, tal vez esta sea la raz칩n.  Pero, en cualquier caso, 춰comparte tu opini칩n en los comentarios! <br><br><h4>  1. Cadena dividida con expansiones variables </h4><br>  La gente a menudo usa <b>cut</b> o incluso <b>awk</b> solo para restar una parte de la cuerda por patr칩n o con separadores. <br>  Adem치s, muchas personas usan la operaci칩n de subcadena bash usando $ {VARIABLE: start_position: length}, que funciona muy r치pido. <br><br>  Pero bash proporciona una forma poderosa de manipular cadenas de texto usando #, ##,% y %%: se llama <i>expansiones de variables bash</i> . <br>  Con esta sintaxis, puede cortar lo necesario por el patr칩n sin ejecutar comandos externos, por lo que funcionar치 realmente r치pido. <br><br>  El siguiente ejemplo muestra c칩mo obtener la tercera columna (shell) de la cadena donde los valores est치n separados por dos puntos "username: homedir: shell" usando <b>cut</b> o usando expansiones variables (usamos la m치scara <u>*:</u> y el comando ##, que significa: cut todos los caracteres a la izquierda hasta el 칰ltimo colon encontrado): <br><br><pre><code class="bash hljs">$ STRING=<span class="hljs-string"><span class="hljs-string">"username:homedir:shell"</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$STRING</span></span></span><span class="hljs-string">"</span></span>|cut -d <span class="hljs-string"><span class="hljs-string">":"</span></span> -f 3 shell $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${STRING##*:}</span></span></span><span class="hljs-string">"</span></span> shell</code> </pre> <br>  La segunda opci칩n no inicia el proceso secundario ( <b>corte</b> ) y no utiliza tuber칤as en absoluto, lo que deber칤a funcionar mucho m치s r치pido.  Y si est치 utilizando el subsistema bash en ventanas, donde las tuber칤as apenas se mueven, la diferencia de velocidad ser치 <u>significativa</u> . <br><br>  Veamos un ejemplo en Ubuntu: ejecute nuestro comando en un bucle 1000 veces <br><br><pre> <code class="bash hljs">$ cat test.sh <span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash STRING="Name:Date:Shell" echo "using cut" time for A in {1..1000} do cut -d ":" -f 3 &gt; /dev/null &lt;&lt;&lt;"$STRING" done echo "using ##" time for A in {1..1000} do echo "${STRING##*:}" &gt; /dev/null done</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Resultados</b> <div class="spoiler_text"><pre> <code class="bash hljs">$ ./test.sh using cut real 0m0.950s user 0m0.012s sys 0m0.232s using <span class="hljs-comment"><span class="hljs-comment">## real 0m0.011s user 0m0.008s sys 0m0.004s</span></span></code> </pre></div></div><br>  춰La diferencia es varias docenas de veces! <br><br>  Por supuesto, el ejemplo anterior es demasiado artificial.  En el ejemplo real no trabajaremos con una cadena est치tica, queremos leer un archivo real.  Y para el comando ' <b>cortar</b> ', simplemente redirigimos / etc / passwd a 칠l.  En el caso de ##, tenemos que crear un bucle y leer el archivo usando el comando interno ' <b>leer</b> '.  Entonces, 쯤ui칠n ganar치 este caso? <br><br><pre> <code class="bash hljs">$ cat test.sh <span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash echo "using cut" time for count in {1..1000} do cut -d ":" -f 7 &lt;/etc/passwd &gt; /dev/null done echo "using ##" time for count in {1..1000} do while read do echo "${REPLY##*:}" &gt; /dev/null done &lt;/etc/passwd done</span></span></code> </pre><div class="spoiler">  <b class="spoiler_title">Resultado</b> <div class="spoiler_text"><pre> <code class="bash hljs">$ ./test.sh $ ./test.sh using cut real 0m0.827s user 0m0.004s sys 0m0.208s using <span class="hljs-comment"><span class="hljs-comment">## real 0m0.613s user 0m0.436s sys 0m0.172s</span></span></code> </pre>  No hay comentarios =) </div></div><br>  Un par de ejemplos m치s: <br><br>  Extraiga el valor despu칠s del car치cter igual: <br><br><pre> <code class="bash hljs">$ VAR=<span class="hljs-string"><span class="hljs-string">"myClassName = helloClass"</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">${VAR##*= }</span></span> helloClass</code> </pre><br>  Extraer texto entre corchetes: <br><br><pre> <code class="bash hljs">$ VAR=<span class="hljs-string"><span class="hljs-string">"Hello my friend (enemy)"</span></span> $ TEMP=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${VAR##*\(}</span></span></span><span class="hljs-string">"</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${TEMP%\)}</span></span></span><span class="hljs-string">"</span></span> enemy</code> </pre><br><h4>  2. Autocompletar Bash con pesta침a </h4><br>  El paquete bash-complete es parte de casi todos los distributivos de Linux.  Puede habilitarlo en /etc/bash.bashrc o /etc/profile.d/bash_completion.sh, pero generalmente ya est치 habilitado de forma predeterminada.  En general, el autocompletado es uno de los primeros momentos convenientes en el shell de Linux que un reci칠n llegado conoce en primer lugar. <br><br>  Pero el hecho de que no todos usen todas las funciones de finalizaci칩n de bash, y en mi opini칩n es completamente en vano.  Por ejemplo, no todo el mundo sabe que el autocompletado funciona no solo con nombres de archivos, sino tambi칠n con alias, nombres de variables, nombres de funciones y para algunos comandos, incluso con argumentos.  Si profundiza en los scripts de autocompletado, que en realidad son scripts de shell, incluso puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">agregar el autocompletado</a> para su propia aplicaci칩n o script. <br>  Pero volvamos a los alias. <br><br>  No necesita editar la variable PATH o crear archivos en el directorio especificado para ejecutar el alias.  Solo necesita agregarlos al perfil o script de inicio y ejecutarlos desde cualquier lugar. <br><br>  Por lo general, estamos usando letras min칰sculas para archivos y directorios en * nix, por lo que podr칤a ser muy c칩modo crear alias en may칰sculas; en ese caso, bash-complete <s>adivinar치</s> su comando casi con una sola letra: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> TAsteriskLog=<span class="hljs-string"><span class="hljs-string">"tail -f /var/log/asteriks.log"</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> TMailLog=<span class="hljs-string"><span class="hljs-string">"tail -f /var/log/mail.log"</span></span> $ TA[tab]steriksLog $ TM[tab]ailLog</code> </pre> <br><h4>  3. Autocompletar Bash con pesta침a - parte 2 </h4><br>  Para casos m치s complicados, probablemente le gustar칤a poner sus scripts personales en $ HOME / bin. <br>  Pero tenemos funciones en bash. <br><br>  Las funciones no requieren ruta o archivos separados.  Y (atenci칩n) bash-complete tambi칠n funciona con funciones. <br><br>  Creemos la funci칩n LastLogin en <b>.profile</b> (no olvide volver a cargar .profile): <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> LastLogin { STRING=$(last | head -n 1 | tr -s <span class="hljs-string"><span class="hljs-string">" "</span></span> <span class="hljs-string"><span class="hljs-string">" "</span></span>) USER=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$STRING</span></span></span><span class="hljs-string">"</span></span>|cut -d <span class="hljs-string"><span class="hljs-string">" "</span></span> -f 1) IP=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$STRING</span></span></span><span class="hljs-string">"</span></span>|cut -d <span class="hljs-string"><span class="hljs-string">" "</span></span> -f 3) SHELL=$( grep <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$USER</span></span></span><span class="hljs-string">"</span></span> /etc/passwd | cut -d <span class="hljs-string"><span class="hljs-string">":"</span></span> -f 7) <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"User: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$USER</span></span></span><span class="hljs-string">, IP: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$IP</span></span></span><span class="hljs-string">, SHELL=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$SHELL</span></span></span><span class="hljs-string">"</span></span> }</code> </pre> <br>  <i>(En realidad, no es importante lo que est치 haciendo esta funci칩n, es solo un script de ejemplo que podemos poner en el script separado o incluso en el alias, pero la funci칩n podr칤a ser mejor)</i> . <br><br>  En la consola (tenga en cuenta que el nombre de la funci칩n tiene una primera letra may칰scula para acelerar la finalizaci칩n de bash): <br><br><pre> <code class="bash hljs">$ L[tab]astLogin User: saboteur, IP: 10.0.2.2, SHELL=/bin/bash</code> </pre> <br><h4>  4.1.  Datos sensibles </h4><br>  Si pone espacio antes de cualquier comando en la consola, no aparecer치 en el historial de comandos, por lo que si necesita poner una contrase침a de texto sin formato en el comando, es una buena manera de usar esta funci칩n; consulte el ejemplo a continuaci칩n, <i>repita "hola" 2 "</i> no aparecer치 en la historia: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"hello"</span></span> hello $ <span class="hljs-built_in"><span class="hljs-built_in">history</span></span> 2 2011 <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"hello"</span></span> 2012 <span class="hljs-built_in"><span class="hljs-built_in">history</span></span> 2 $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"my password secretmegakey"</span></span> <span class="hljs-comment"><span class="hljs-comment"># there are two spaces before 'echo' my password secretmegakey $ history 2 2011 echo "hello" 2012 history 2</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Es opcional</b> <div class="spoiler_text">  Por lo general, est치 habilitado de manera predeterminada, pero puede configurar este comportamiento en la siguiente variable: <br><br>  export HISTCONTROL = ignoreboth </div></div><br><br><h4>  4.2.  Datos confidenciales en argumentos de l칤nea de comando </h4><br>  Desea almacenar algunos scripts de shell en git para compartirlos entre servidores, o puede ser parte del script de inicio de la aplicaci칩n.  Y desea que este script se conecte a la base de datos o haga cualquier otra cosa que requiera credenciales. <br><br>  Por supuesto, es una mala idea almacenar las credenciales en el script en s칤, porque git no es seguro. <br><br>  Por lo general, puede usar variables, que ya se definieron en los entornos de destino, y su secuencia de comandos no contendr치 las contrase침as en s칤. <br><br>  Por ejemplo, puede crear un script peque침o en cada entorno con 700 permisos y llamarlo usando el comando de origen del script principal: <br><br><pre> <code class="bash hljs">secret.sh PASSWORD=LOVESEXGOD</code> </pre><br><pre> <code class="bash hljs">myapp.sh <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> ~/secret.sh sqlplus -l user/<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$PASSWORD</span></span></span><span class="hljs-string">"</span></span>@database:port/sid @mysqfile.sql</code> </pre> <br>  Pero no es seguro. <br><br>  Si alguien m치s puede iniciar sesi칩n en su host, puede ejecutar el comando <b>ps</b> y ver su proceso sqlplus con todos los argumentos de la l칤nea de comando, incluidas las contrase침as.  Por lo tanto, las herramientas seguras generalmente deber칤an poder leer contrase침as / claves / datos confidenciales directamente de los archivos. <br><br>  Por ejemplo, secure <b>ssh</b> simplemente no tiene opciones para proporcionar una contrase침a en la l칤nea de comandos.  Pero 칠l puede leer la clave ssh del archivo (y usted puede establecer permisos seguros en el archivo de clave ssh). <br><br>  Y wget no seguro tiene una opci칩n "- contrase침a" que le permite proporcionar una contrase침a en la l칤nea de comandos.  Y todo el tiempo wget se ejecutar치, todos pueden ejecutar el comando ps y ver la contrase침a que ha proporcionado. <br><br>  Adem치s, si tiene muchos datos confidenciales y desea controlarlos desde git, la 칰nica forma es el cifrado.  Por lo tanto, coloca en cada entorno de destino solo la contrase침a maestra y todos los dem치s datos que puede cifrar y poner en git.  Y puede trabajar con datos cifrados desde la l칤nea de comandos, utilizando la interfaz CLI de openssl.  Aqu칤 hay un ejemplo para cifrar y descifrar desde la l칤nea de comandos: <br><br>  El archivo secret.key contiene la clave maestra: una sola l칤nea: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"secretpassword"</span></span> &gt; secret.key; chmod 600 secret.key</code> </pre> <br>  Usemos aes-256-cbc para encriptar una cadena: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"string_to_encrypt"</span></span> | openssl enc -pass file:secret.key -e -aes-256-cbc -a U2FsdGVkX194R0GmFKCL/krYCugS655yLhf8aQyKNcUnBs30AE5lHN5MXPjjSFML</code> </pre> <br>  Puede colocar esta cadena encriptada en cualquier archivo de configuraci칩n almacenado en git, o en cualquier otro lugar, sin secret.key es casi imposible descifrarlo. <br>  Para descifrar ejecute el mismo comando simplemente reemplace -e con -d: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'U2FsdGVkX194R0GmFKCL/krYCugS655yLhf8aQyKNcUnBs30AE5lHN5MXPjjSFML'</span></span> | openssl enc -pass file:secret.key -d -aes-256-cbc -a string_to_encrypt</code> </pre> <br><h4>  5. El comando grep </h4><br>  Todos deber칤an saber el comando grep.  Y s칠 amigable con las expresiones regulares.  Y a menudo puedes escribir algo como: <br><br><pre> <code class="bash hljs">tail -f application.log | grep -i error</code> </pre> <br>  O incluso as칤: <br><br><pre> <code class="bash hljs">tail -f application.log | grep -i -P <span class="hljs-string"><span class="hljs-string">"(error|warning|failure)"</span></span></code> </pre> <br>  Pero no olvide que grep tiene muchas opciones maravillosas.  Por ejemplo -v, que revierte su b칰squeda y muestra todos excepto los mensajes de "informaci칩n": <br><br><pre> <code class="bash hljs">tail -f application.log | grep -v -i <span class="hljs-string"><span class="hljs-string">"info"</span></span></code> </pre> <br>  Cosas adicionales: <br><br>  La opci칩n -P es muy 칰til, porque por defecto grep usa una "expresi칩n regular b치sica:" bastante desactualizada, y -P habilita PCRE que incluso no sabe acerca de la agrupaci칩n. <br>  -I ignora el caso. <br>  --line-buffer almacena la l칤nea inmediatamente en lugar de esperar a alcanzar el buffer est치ndar de 4k (칰til para tail -f | grep). <br><br>  Si conoce bien la expresi칩n regular, con --only-matching / -o realmente puede hacer grandes cosas al cortar texto.  Simplemente compare los siguientes dos comandos para extraer el shell de myuser: <br><br><pre> <code class="bash hljs">$ grep myuser /etc/passwd| cut -d <span class="hljs-string"><span class="hljs-string">":"</span></span> -f 7 $ grep -Po <span class="hljs-string"><span class="hljs-string">"^myuser(:.*){5}:\K.*"</span></span> /etc/passwd</code> </pre> <br>  El segundo comando parece m치s compilado, pero solo ejecuta <b>grep en</b> lugar de <b>grep</b> and <b>cut</b> , por lo que tomar치 menos tiempo ejecutarlo. <br><br><h4>  6. C칩mo reducir el tama침o del archivo de registro </h4><br>  En * nix, si elimina el archivo de registro, que actualmente utiliza una aplicaci칩n, no solo puede eliminar todos los registros, sino que puede evitar que la aplicaci칩n escriba nuevos registros hasta que se reinicie. <br><br>  Debido a que el descriptor de archivo no abre el nombre del archivo, sino la estructura iNode, y la aplicaci칩n continuar치 escribiendo en el descriptor de archivo en el archivo, que no tiene entrada de directorio, y dicho archivo se eliminar치 autom치ticamente despu칠s de que la aplicaci칩n se detenga por el sistema de archivos ( <i>su aplicaci칩n puede abrir y cerrar el archivo de registro cada vez que quiera escribir algo para evitar tal problema, pero afecta el rendimiento</i> ). <br><br>  Entonces, c칩mo borrar el archivo de registro sin eliminarlo: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> &gt; application.log</code> </pre> <br>  O podemos usar el comando truncar: <br><br><pre> <code class="bash hljs">truncate --size=1M application.log</code> </pre> <br>  Mencione que el comando <b>truncar</b> eliminar치 el resto del archivo, por lo que perder치 los 칰ltimos eventos de registro.  Consulte otro ejemplo de c칩mo almacenar las 칰ltimas 1000 l칤neas: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(tail -n 1000 application.log)</span></span></span><span class="hljs-string">"</span></span> &gt; application.log</code> </pre> <br>  <i>PD En Linux tenemos el servicio est치ndar rotatelog.</i>  <i>Puede agregar sus registros para truncar / rotar autom치ticamente o usar las bibliotecas de registros existentes que pueden hacerlo por usted (como log4j en java).</i> <br><br><h4>  7. 춰 <b>Watch te</b> est치 mirando! </h4><br>  Hay una situaci칩n en la que est치 esperando que se termine alg칰n evento.  Por ejemplo, mientras otro usuario inicia sesi칩n en el shell (ejecutas continuamente <b>qui칠n</b> manda), o alguien debe copiar el archivo a tu m치quina usando scp o ftp y est치s esperando que se complete (repitiendo ls docenas de veces). <br><br>  En tales casos, puede usar <br><br><pre> <code class="bash hljs">watch &lt;<span class="hljs-built_in"><span class="hljs-built_in">command</span></span>&gt;</code> </pre> <br>  Por defecto, se ejecutar치 cada 2 segundos con un borrado previo de pantalla hasta que se presione Ctrl + C.  Puede configurar con qu칠 frecuencia se debe ejecutar. <br><br>  Es muy 칰til cuando desea ver registros en vivo. <br><br><h4>  8. Secuencia bash </h4><br>  Hay una construcci칩n muy 칰til para crear rangos.  Por ejemplo, en lugar de algo como esto: <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> srv <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> 1 2 3 4 5; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"server</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${srv}</span></span></span><span class="hljs-string">"</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">done</span></span> server1 server2 server3 server4 server5</code> </pre> <br>  Puedes escribir lo siguiente: <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> srv <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> server{1..5}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$srv</span></span></span><span class="hljs-string">"</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">done</span></span> server1 server2 server3 server4 server5</code> </pre> <br>  Tambi칠n puede usar el comando <b>seq</b> para generar rangos formateados.  Por ejemplo, podemos usar <b>seq</b> para crear valores que se ajustar치n autom치ticamente por ancho (00, 01 en lugar de 0, 1): <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> srv <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> $(seq -w 5 10); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"server</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${srv}</span></span></span><span class="hljs-string">"</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">done</span></span> server05 server06 server07 server08 server09 server10</code> </pre> <br>  Otro ejemplo con la sustituci칩n de comandos: renombrar archivos.  Para obtener un nombre de archivo sin extensi칩n, estamos usando el comando ' <b>basename</b> ': <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> file <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> *.txt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> name=$(basename <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$file</span></span></span><span class="hljs-string">"</span></span> .txt);mv <span class="hljs-variable"><span class="hljs-variable">$name</span></span>{.txt,.lst}; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br>  Tambi칠n a칰n m치s corto con '%': <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> file <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> *.txt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> mv <span class="hljs-variable"><span class="hljs-variable">${file%.txt}</span></span>{.txt,.lst}; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br>  PD En realidad, para cambiar el nombre de los archivos, puedes probar la herramienta ' <b>cambiar nombre</b> ' que tiene muchas opciones. <br><br>  Otro ejemplo: permite crear una estructura para un nuevo proyecto de Java: <br><br><pre> <code class="bash hljs">mkdir -p project/src/{main,<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>}/{java,resources}</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Resultado</b> <div class="spoiler_text"><pre> <code class="python hljs">project/ !--- src/ |--- main/ | |-- java/ | !-- resources/ !--- test/ |-- java/ !-- resources/</code> </pre> </div></div><br><h4>  9. cola, m칰ltiples archivos, m칰ltiples usuarios ... </h4><br>  He mencionado <b>multitail</b> para leer archivos y ver m칰ltiples registros en vivo.  Pero no se proporciona de manera predeterminada, y los permisos para instalar algo no siempre est치n disponibles. <br><br>  Pero la cola est치ndar tambi칠n puede hacerlo: <br><br><pre> <code class="bash hljs">tail -f /var/logs/*.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span></code> </pre> <br>  Tambi칠n recordemos acerca de los usuarios, que usan alias 'tail -f' para ver los registros de las aplicaciones. <br>  Varios usuarios pueden ver archivos de registro simult치neamente usando 'tail -f'.  Algunos de ellos no son muy precisos con sus sesiones.  Podr칤an dejar 'tail -f' en segundo plano por alguna raz칩n y olvidarse de eso. <br><br>  Si se reinici칩 la aplicaci칩n, hay estos procesos en ejecuci칩n 'tail -f' que observan que el archivo de registro inexistente puede bloquearse durante varios d칤as o incluso meses. <br><br>  Por lo general, no es un gran problema, pero no claramente. <br><br>  En caso de que est칠 utilizando un alias para ver el registro, puede modificar este alias con la opci칩n --pid: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> TFapplog=<span class="hljs-string"><span class="hljs-string">'tail -f --pid=$(cat /opt/app/tmp/app.pid) /opt/app/logs/app.log'</span></span></code> </pre> <br>  En ese caso, todas las <b>colas</b> se terminar치n autom치ticamente cuando se reinicie la aplicaci칩n de destino. <br><br><h4>  10. Crear archivo con tama침o especificado </h4><br>  <b>dd</b> fue una de las herramientas m치s populares para trabajar con datos de bloque y binarios.  Por ejemplo, crear un archivo de 1 MB lleno de cero ser치: <br><br><pre> <code class="bash hljs">dd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=/dev/zero of=out.txt bs=1M count=10</code> </pre> <br>  Pero recomiendo usar <b>Falocate</b> : <br><br><pre> <code class="bash hljs">fallocate -l 10M file.txt</code> </pre> <br>  En los sistemas de archivos, que admiten la funci칩n de asignaci칩n (xfs, ext4, Btrfs ...), <b>Fallocate</b> se ejecutar치 instant치neamente, a diferencia de la herramienta dd.  Adem치s, asignar significa asignaci칩n real de bloques, no crear un archivo de reserva. <br><br><h4>  11. xargs </h4><br>  Mucha gente conoce el comando popular <b>xargs</b> .  Pero no todos ellos usan las siguientes dos opciones, que podr칤an mejorar enormemente su script. <br><br>  Primero: puede obtener una lista muy larga de argumentos para procesar, y podr칤a exceder la longitud de la l칤nea de comando (por defecto ~ 4 kb). <br><br>  Pero puede limitar la ejecuci칩n utilizando la opci칩n -n, por lo que <b>xargs</b> ejecutar치 el comando varias veces, enviando un n칰mero espec칤fico de argumentos a la vez: <br><br><pre> <code class="bash hljs">$ <span class="hljs-comment"><span class="hljs-comment"># lets print 5 arguments and send them to echo with xargs: $ echo 1 2 3 4 5 | xargs echo 1 2 3 4 5 $ # now let's repeat, but limit argument processing by 3 per execution $ echo 1 2 3 4 5 | xargs -n 3 echo 1 2 3 4 5</span></span></code> </pre> <br>  Adelante  Procesar una lista larga puede llevar mucho tiempo, ya que se ejecuta en un solo hilo.  Pero si tenemos varios n칰cleos, podemos decirle a <b>xargs</b> que se ejecute en paralelo: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 1 2 3 4 5 6 7 8 9 10| xargs -n 2 -P 3 <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span></code> </pre> <br>  En el ejemplo anterior, le decimos a <b>xargs</b> que procese la lista en 3 hilos;  cada hilo tomar치 y procesar치 2 argumentos por ejecuci칩n.  Si no sabe cu치ntos n칰cleos tiene, optimicemos esto usando " <b>nproc</b> ": <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 1 2 3 4 5 6 7 8 9 10 | xargs -n 2 -P $(nproc) <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span></code> </pre> <br><h4>  12. dormir?  mientras?  leer! </h4><br>  En alg칰n momento debes esperar varios segundos.  O espere la entrada del usuario con lectura: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">read</span></span> -p <span class="hljs-string"><span class="hljs-string">"Press any key to continue "</span></span> -n 1</code> </pre> <br>  Pero solo puede agregar la opci칩n de tiempo de espera para <b>leer el</b> comando, y su secuencia de comandos se pausar치 durante una cantidad espec칤fica de segundos, pero en caso de ejecuci칩n interactiva, el usuario puede omitir f치cilmente la espera. <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">read</span></span> -p <span class="hljs-string"><span class="hljs-string">"Press any key to continue (auto continue in 30 seconds) "</span></span> -t 30 -n 1</code> </pre> <br>  Entonces puedes olvidarte del comando sleep. <br><br>  Sospecho que no todos mis trucos parecen interesantes, pero me pareci칩 que una docena es un buen n칰mero para completar. <br><br>  En este momento, me despido y agradecer칠 participar en la encuesta. <br><br>  Por supuesto, si칠ntase libre de discutir lo anterior y compartir sus trucos geniales en los comentarios. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/444890/">https://habr.com/ru/post/444890/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444880/index.html">Una interpretaci칩n multimundo de la mec치nica cu치ntica.</a></li>
<li><a href="../444882/index.html">Los bancos comenzaron a bloquear cuentas independientes</a></li>
<li><a href="../444884/index.html">Groovy dej칩 a C칠dric Champeau</a></li>
<li><a href="../444886/index.html">Aplicaciones de ingenier칤a inversa despu칠s de la ofuscaci칩n</a></li>
<li><a href="../444888/index.html">Ingl칠s y TI: 쮹칰ho ingl칠s en un globo ruso?</a></li>
<li><a href="../444892/index.html">Fraude estadounidense gan칩 millones de d칩lares pretendiendo ser soporte t칠cnico de Microsoft</a></li>
<li><a href="../444894/index.html">Zabbix 4.2 lanzado</a></li>
<li><a href="../444896/index.html">Reciclaje de discos duros como basura electr칩nica: soluci칩n parcial de iNEMI</a></li>
<li><a href="../444898/index.html">C칩mo elegir un m칩dem de banda ancha para un veh칤culo a칠reo no tripulado (UAV) o rob칩tica</a></li>
<li><a href="../444900/index.html">Validaci칩n de formulario en Vue.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>