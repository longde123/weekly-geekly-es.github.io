<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîΩ üë®‚Äçüç≥ üêº Hacia QUIC: lo que subyace a HTTP / 3 üë≥üèø üôèüèº üÖæÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Un nuevo hito en la historia de Internet comienza ante nuestros propios ojos: podemos suponer que HTTP / 3 ya ha sido anunciado. A finales de octubre,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hacia QUIC: lo que subyace a HTTP / 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/Voximplant/blog/430436/"> Un nuevo hito en la historia de Internet comienza ante nuestros propios ojos: podemos suponer que HTTP / 3 ya ha sido anunciado.  A finales de octubre, Mark Nottingham del IETF <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sugiri√≥ que ya se decidiera un nombre</a> para el nuevo protocolo sobre el cual el IETF ha estado construyendo desde 2015.  Entonces, en lugar de nombres similares a QUIC, apareci√≥ HTTP / 3 ruidoso.  Las publicaciones occidentales ya han <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://daniel.haxx.se/blog/tag/">escrito sobre esto</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://www.zdnet.com/article/http-over-quic-to-be-renamed-">m√°s de una vez</a> .  La historia de QUIC comenz√≥ en las entra√±as de Good Corporation en 2012, desde entonces solo los servidores de Google admit√≠an conexiones HTTP sobre QUIC, pero el tiempo pasa y Facebook ya comenz√≥ a implementar esta tecnolog√≠a (7 de noviembre, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Facebook</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LiteSpeed</a> hicieron la primera interacci√≥n a trav√©s de HTTP / 3 );  Actualmente, la proporci√≥n de sitios que admiten QUIC es del 1,2%.  Finalmente, el grupo de trabajo de WebRTC <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tambi√©n</a> est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mirando hacia QUIC</a> (adem√°s de ver la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">API de QUIC</a> ), por lo que en el futuro previsible, el video / audio en tiempo real pasar√° a trav√©s de QUIC en lugar de RTP / RTCP.  Por lo tanto, decidimos que ser√≠a genial revelar los detalles del IETF QUIC: especialmente para Habr, preparamos una traducci√≥n del hilo largo punteando i.  ¬°A disfrutar! <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/r4/ee/3s/r4ee3svcbqzrlxwfzuajri7go04.png"></div><a name="habracut"></a><br>  QUIC (Quick UDP Internet Connections) es un nuevo protocolo de capa de transporte predeterminado cifrado que tiene muchas mejoras HTTP: tanto para acelerar el tr√°fico como para aumentar la seguridad.  QUIC tambi√©n tiene un objetivo a largo plazo: eventualmente reemplazar TCP y TLS.  En este art√≠culo, analizaremos los chips QUIC clave y por qu√© la web se beneficiar√° de ellos, as√≠ como los problemas de soportar este protocolo completamente nuevo. <br><br>  De hecho, hay dos protocolos con el mismo nombre: Google QUIC (gQUIC), el protocolo original desarrollado por ingenieros de Google hace varios a√±os, que, despu√©s de una serie de experimentos, fue adoptado por el Grupo de trabajo de ingenier√≠a de Internet (IETF) para estandarizar. <br><br>  IETF QUIC (en adelante, simplemente QUIC) ya tiene diferencias tan fuertes con gQUIC que puede considerarse un protocolo separado.  Desde el formato del paquete hasta el protocolo de enlace y el mapeo HTTP, QUIC ha mejorado la arquitectura original de gQUIC al colaborar con muchas organizaciones y desarrolladores que tienen un objetivo com√∫n: hacer que Internet sea m√°s r√°pido y seguro. <br><br>  Entonces, ¬øqu√© mejoras ofrece QUIC? <br><br><h2>  Seguridad integrada (y rendimiento) </h2><br>  Una de las diferencias m√°s notables entre QUIC y TCP venerable es el objetivo originalmente establecido de ser un protocolo de transporte <b>seguro de forma predeterminada</b> .  QUIC logra esto mediante el uso de autenticaci√≥n y cifrado, que generalmente ocurre en un nivel superior (por ejemplo, en TLS), y no en el protocolo de transporte en s√≠. <br><br>  El protocolo de enlace QUIC original combina la comunicaci√≥n tripartita habitual a trav√©s de TCP con el protocolo de enlace TLS 1.3, que proporciona autenticaci√≥n de los participantes, as√≠ como la coordinaci√≥n de los par√°metros criptogr√°ficos.  Para aquellos que est√°n familiarizados con TLS: QUIC reemplaza el nivel de grabaci√≥n TLS con su propio formato de trama, pero al mismo tiempo usa apretones de manos TLS. <br><br>  Esto no solo permite que la conexi√≥n est√© siempre encriptada y autenticada, sino que tambi√©n es m√°s r√°pida para realizar la conexi√≥n inicial: un apret√≥n de manos QUIC normal hace el intercambio entre el cliente y el servidor en una pasada, mientras que TCP + TLS 1.3 realiza dos pasadas. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h2/lq/o4/h2lqo4o2itthtb_h7qopgt7kbc4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/g6/ne/vg/g6nevg964eqgvmzillfvnet3lus.png"></div><br>  Sin embargo, QUIC va m√°s all√° y tambi√©n cifra los metadatos de conexi√≥n que pueden ser f√°cilmente comprometidos por un tercero.  Por ejemplo, los atacantes pueden usar n√∫meros de paquetes para dirigir a los usuarios a trav√©s de m√∫ltiples rutas de red cuando se usa la migraci√≥n de conexi√≥n (ver m√°s abajo).  QUIC cifra los n√∫meros de paquete, por lo que no pueden ser corregidos por nadie m√°s que los verdaderos participantes en la conexi√≥n. <br><br>  El cifrado tambi√©n puede ser efectivo contra el "estancamiento", un fen√≥meno que no permite que la flexibilidad del protocolo se use en la pr√°ctica debido a suposiciones incorrectas en las implementaciones (osificaci√≥n: esta es la raz√≥n por la que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TLS 1.3 present√≥</a> durante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mucho tiempo</a> . Lo publicamos solo despu√©s de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">algunos cambios</a> que evitar bloqueos no deseados para nuevas revisiones de TLS). <br><br><h2>  Bloquear el comienzo de la cola (bloqueo de encabezado de l√≠nea) </h2><br>  Una de las principales mejoras que nos trajo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://blog.cloudflare.com/introducing-">HTTP / 2</a> es la capacidad de combinar diferentes solicitudes HTTP en una conexi√≥n TCP.  Esto permite que las aplicaciones HTTP / 2 procesen solicitudes en paralelo y hagan un mejor uso del canal de red. <br><br>  Por supuesto, este fue un importante paso adelante.  Porque las aplicaciones anteriores necesitaban iniciar muchas conexiones TCP + TLS si quer√≠an procesar varias solicitudes HTTP al mismo tiempo (por ejemplo, cuando el navegador necesita recibir CSS y JavaScript para representar la p√°gina).  Crear nuevas conexiones requiere m√∫ltiples apretones de manos, as√≠ como inicializar la ventana de sobrecarga: esto significa ralentizar el procesamiento de la p√°gina.  Las solicitudes HTTP combinadas evitan esto. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lj/rc/lb/ljrclbypotymwhoajopsze57jry.jpeg"></div><br><br>  Sin embargo, existe un inconveniente: dado que se transmiten m√∫ltiples solicitudes / respuestas a trav√©s de la misma conexi√≥n TCP, todas dependen igualmente de la p√©rdida de paquetes, incluso si los datos perdidos se refieren solo a una de las solicitudes.  Esto se llama "bloquear el comienzo de la cola". <br><br>  QUIC va m√°s all√° y proporciona soporte de primera clase para combinar solicitudes, por ejemplo, diferentes solicitudes HTTP pueden considerarse diferentes solicitudes de transporte QUIC, pero al mismo tiempo todas usar√°n la misma conexi√≥n QUIC, es decir, no se necesitan apretones de manos adicionales, hay uno estado de congesti√≥n, las solicitudes QUIC se entregan de forma independiente; como resultado, en la mayor√≠a de los casos, la p√©rdida de paquetes afecta solo a una solicitud. <br><br>  Por lo tanto, es posible reducir significativamente el tiempo para, por ejemplo, la representaci√≥n completa de una p√°gina web (CSS, JavaScript, im√°genes y otros recursos), especialmente en el caso de una red sobrecargada con alta p√©rdida de paquetes. <br><br><h2>  Tan simple, ¬øeh? </h2><br>  Para cumplir su promesa, el protocolo QUIC debe superar algunos de los supuestos que muchas aplicaciones de red han dado por sentado.  Esto puede complicar la implementaci√≥n y la implementaci√≥n de QUIC. <br><br>  QUIC est√° dise√±ado para ser entregado a trav√©s de datagramas UDP para facilitar el desarrollo y evitar problemas con los dispositivos de red que descartan paquetes de protocolos desconocidos (porque la mayor√≠a de los dispositivos son compatibles con UDP).  Tambi√©n permite que QUIC viva en el espacio del usuario, por lo que, por ejemplo, los navegadores podr√°n implementar nuevas funciones de protocolo y transmitirlas a los usuarios finales, sin esperar las actualizaciones del sistema operativo. <br><br>  Sin embargo, el buen objetivo de reducir los problemas de red hace que sea m√°s dif√≠cil proteger los paquetes y enrutarlos adecuadamente. <br><br><h2>  Un NAT para reunir a todos juntos y unirse con una sola voluntad negra </h2><br>  Por lo general, los enrutadores NAT funcionan con conexiones TCP utilizando una tupla de 4 valores (IP de origen y puerto m√°s IP y puerto de destino), adem√°s de monitorear los paquetes TCP SYN, ACK y FIN transmitidos por la red;  los enrutadores pueden determinar cu√°ndo se establece una nueva conexi√≥n y cu√°ndo finaliza.  Por lo tanto, es posible una gesti√≥n precisa de los enlaces NAT (comunicaciones entre IP y puertos internos y externos). <br><br>  En el caso de QUIC, esto a√∫n no es posible, porque  Los enrutadores NAT modernos a√∫n no conocen QUIC, por lo que generalmente degradan al procesamiento UDP predeterminado y menos preciso, lo que significa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tiempos de espera de duraci√≥n arbitraria (a veces corta)</a> , que pueden afectar las conexiones a largo plazo. <br><br>  Cuando se produce un nuevo enlace (por ejemplo, debido a un tiempo de espera), el dispositivo fuera del per√≠metro NAT comienza a recibir paquetes de otra fuente, lo que hace que sea imposible mantener la conexi√≥n utilizando solo una tupla de 4 valores. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xg/ze/kz/xgzekzn8kq0nhe9--wkbotrxxmq.png"></div><br><br>  ¬°Y no es solo NAT!  Una caracter√≠stica QUIC se llama migraci√≥n de conexi√≥n y permite a los dispositivos transferir conexiones a otras direcciones / rutas IP a su discreci√≥n.  Por ejemplo, un cliente m√≥vil podr√° transferir una conexi√≥n QUIC de una red m√≥vil a una red WiFi ya conocida (el usuario ha ingresado a una cafeter√≠a favorita, etc.). <br><br>  QUIC intenta resolver este problema con el concepto de ID de conexi√≥n: una informaci√≥n de longitud arbitraria, transmitida en paquetes QUIC y que permite identificar la conexi√≥n.  Los dispositivos de punto final pueden usar esta ID para rastrear sus conexiones sin reconciliarse con la tupla.  En la pr√°ctica, debe haber muchas ID que indiquen la misma conexi√≥n, por ejemplo, para evitar conectar diferentes rutas cuando se migra la conexi√≥n, porque todo el proceso est√° controlado solo por los dispositivos finales, no por los middleboxes. <br><br>  Sin embargo, puede haber un problema para los operadores de telecomunicaciones que usan enrutamiento anycast y ECMP, donde una IP puede identificar cientos o miles de servidores.  Dado que los enrutadores fronterizos en estas redes a√∫n no saben c√≥mo procesar el tr√°fico QUIC, puede ocurrir que los paquetes UDP de la misma conexi√≥n QUIC, pero con diferentes tuplas, se env√≠en a diferentes servidores, lo que significa desconexi√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d4/vq/us/d4vqusefrkw1ideoglo-_heq8py.png"></div><br><br>  Para evitar esto, los operadores pueden necesitar implementar un equilibrador de nivel m√°s inteligente.  Esto se puede lograr mediante programaci√≥n sin afectar a los enrutadores fronterizos (por ejemplo, vea el proyecto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Katran</a> de Facebook). <br><br><h2>  Qpack </h2><br>  Otra caracter√≠stica √∫til de HTTP / 2 fue la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://blog.cloudflare.com/hpack-the-silent-killer-feature-of-">compresi√≥n de encabezado (HPACK)</a> , que permite a los dispositivos finales reducir el tama√±o de los datos que se env√≠an al descartar solicitudes y respuestas innecesarias. <br><br>  En particular, entre otras t√©cnicas, HPACK utiliza tablas din√°micas con encabezados que ya se han enviado / recibido de solicitudes / respuestas HTTP anteriores, lo que permite que los dispositivos remitan nuevas solicitudes / respuestas a encabezados encontrados anteriormente (en lugar de enviarlos nuevamente) . <br><br>  Las tablas HPACK deben sincronizarse entre el codificador (la parte que env√≠a la solicitud / respuesta) y el decodificador (el lado receptor), de lo contrario, el decodificador simplemente no puede decodificar lo que recibe. <br><br>  En el caso de HTTP / 2 sobre TCP, esta sincronizaci√≥n es transparente porque la capa de transporte (TCP) entrega solicitudes / respuestas en el mismo orden en que fueron enviadas.  Es decir, puede enviar instrucciones al decodificador para actualizar las tablas en una simple solicitud / respuesta.  Pero con QUIC, las cosas son mucho m√°s complicadas. <br><br>  QUIC puede entregar m√∫ltiples solicitudes / respuestas HTTP en diferentes direcciones al mismo tiempo, lo que significa que QUIC garantiza el pedido de entrega en una direcci√≥n, mientras que no existe tal garant√≠a en el caso de m√∫ltiples direcciones. <br><br>  Por ejemplo, si un cliente env√≠a una solicitud HTTP A en la secuencia A de QUIC, as√≠ como una solicitud B en la secuencia B, entonces, debido a la permutaci√≥n de paquetes o p√©rdidas de red, el servidor recibir√° la solicitud B antes de la solicitud A. Y si la solicitud B se codific√≥ como se indic√≥ en el encabezado de la solicitud A, entonces el servidor simplemente no podr√° decodificar la solicitud B, ya que a√∫n no ha visto la solicitud A. <br><br>  El protocolo gQUIC resolvi√≥ este problema simplemente haciendo que todos los encabezados (pero no los cuerpos) de las solicitudes / respuestas HTTP fueran <b>secuenciales</b> dentro de una sola secuencia gQUIC.  Esto asegur√≥ que todos los encabezados vengan en el orden correcto, pase lo que pase.  Este es un esquema muy simple, con su ayuda, las soluciones existentes pueden continuar usando c√≥digo que se afina bajo HTTP / 2;  Por otro lado, esto aumenta la probabilidad de bloquear el comienzo de la cola, que QUIC est√° dise√±ado para reducir.  Por lo tanto, el grupo de trabajo IETF QUIC desarroll√≥ una nueva asignaci√≥n entre HTTP y QUIC (HTTP / QUIC), as√≠ como un nuevo principio de compresi√≥n de encabezado, QPACK. <br><br>  En el borrador final de las especificaciones HTTP / QUIC y QPACK, cada intercambio de solicitud / respuesta HTTP utiliza su propio flujo QUIC bidireccional, por lo que no se produce el bloqueo del inicio de la cola.  Adem√°s, para admitir QPACK, cada participante crea dos secuencias QUIC unidireccionales adicionales, una para enviar actualizaciones de la tabla y la otra para confirmar su recepci√≥n.  Por lo tanto, el codificador QPACK puede usar el enlace a la tabla din√°mica solo despu√©s de que el decodificador haya confirmado su recepci√≥n. <br><br><h2>  Reflejo refractor </h2><br>  Un problema com√∫n con los protocolos basados ‚Äã‚Äãen UDP es su susceptibilidad a los ataques de reflexi√≥n, cuando el atacante obliga a un servidor a enviar una gran cantidad de datos a la v√≠ctima.  El atacante falsifica su IP para que el servidor piense que la solicitud de datos proviene de la direcci√≥n de la v√≠ctima. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4e/ee/ov/4eeeovjfl-9or5j0uq-9he0btrg.png"></div><br>  Este tipo de ataque puede ser muy efectivo cuando la respuesta del servidor es incomparablemente mayor que la solicitud.  En este caso, hablan de "ganancia". <br><br>  El TCP generalmente no se usa para tales ataques, porque los paquetes en el protocolo de enlace original (SYN, SYN + ACK, ...) tienen la misma longitud, por lo que no tienen potencial de "amplificaci√≥n". <br><br>  Por otro lado, el protocolo de enlace QUIC es muy asim√©trico: como en TLS, primero el servidor QUIC env√≠a su cadena de certificados, que puede ser bastante grande, a pesar de que el cliente debe enviar solo unos pocos bytes (un mensaje del cliente ClientHello TLS est√° integrado en el paquete QUIC )  Por esta raz√≥n, el paquete QUIC original debe aumentarse a una cierta longitud m√≠nima, incluso si el contenido del paquete es mucho m√°s peque√±o.  Sea como fuere, esta medida a√∫n no es muy efectiva, ya que una respuesta t√≠pica del servidor contiene varios paquetes y, por lo tanto, puede ser m√°s que un paquete de cliente ampliado. <br><br>  El protocolo QUIC tambi√©n define un mecanismo de verificaci√≥n de origen expl√≠cito: el servidor, en lugar de dar una respuesta grande, env√≠a solo un paquete de reintento con un token √∫nico, que el cliente luego env√≠a al servidor en un nuevo paquete.  Por lo tanto, el servidor tiene m√°s confianza en que el cliente no tiene una direcci√≥n IP sustituta y puede finalizar el apret√≥n de manos.  Menos de la decisi√≥n: el tiempo del apret√≥n de manos aumenta, en lugar de una pasada, ya se requieren dos. <br><br>  Una soluci√≥n alternativa es reducir la respuesta del servidor a un tama√±o en el que el ataque de reflexi√≥n se vuelve menos efectivo, por ejemplo, utilizando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">certificados ECDSA</a> (generalmente son mucho m√°s peque√±os que RSA).  Tambi√©n experimentamos con un mecanismo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">compresi√≥n de certificados TLS</a> utilizando algoritmos de compresi√≥n est√°ndar como zlib y brotli;  Esta es una caracter√≠stica que apareci√≥ por primera vez en gQUIC pero actualmente no es compatible con TLS. <br><br><h2>  Rendimiento UDP </h2><br>  Uno de los problemas constantes de QUIC es el hardware y software existentes que no pueden funcionar con QUIC.  Ya hemos examinado c√≥mo QUIC intenta lidiar con los middleboxes de red como enrutadores, pero otra √°rea potencialmente problem√°tica es el rendimiento de enviar / recibir datos entre dispositivos QUIC a trav√©s de UDP.  Durante muchos a√±os, se han realizado esfuerzos para optimizar las implementaciones de TCP tanto como sea posible, incluidas las capacidades de descarga integradas en software (por ejemplo, sistemas operativos) y en hardware (interfaces de red), pero nada de esto concierne a UDP. <br><br>  Sin embargo, es solo cuesti√≥n de tiempo antes de que las implementaciones de QUIC superen estas mejoras y beneficios.  Eche un vistazo a los esfuerzos recientes para implementar la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">descarga UDP en Linux</a> , lo que permitir√≠a que las aplicaciones combinen y transmitan m√∫ltiples segmentos UDP entre la pila de la red del espacio del usuario y el espacio del n√∫cleo a un costo de aproximadamente un segmento;  otro ejemplo es el soporte de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">zerocopy para sockets en Linux</a> , gracias al cual las aplicaciones podr√≠an evitar el costo de copiar la memoria del espacio del usuario en el espacio del kernel. <br><br><h2>  Conclusi√≥n </h2><br>  Al igual que HTTP / 2 y TLS 1.3, el protocolo QUIC deber√≠a aportar un mont√≥n de nuevas caracter√≠sticas que mejorar√°n el rendimiento y la seguridad de los sitios web y otros participantes en la infraestructura de Internet.  El grupo de trabajo de IETF tiene la intenci√≥n de implementar la primera versi√≥n de las especificaciones de QUIC para fin de a√±o, por lo que es hora de pensar en c√≥mo podemos aprovechar al m√°ximo los beneficios de QUIC. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es430436/">https://habr.com/ru/post/es430436/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es430426/index.html">Rebranding Western Digital Products: ¬øQu√© ha cambiado?</a></li>
<li><a href="../es430428/index.html">El sitio "Escher II" en la nominaci√≥n "Proyecto People's Internet" Premios Runet 2018</a></li>
<li><a href="../es430430/index.html">Fullstack: ¬øpor qu√© es genial o c√≥mo disfrutar del trabajo?</a></li>
<li><a href="../es430432/index.html">La ventana modal que estabas esperando. O c√≥mo llamar una ventana emergente desde diferentes botones en JS puro</a></li>
<li><a href="../es430434/index.html">Lanzar el visor de im√°genes desde Windows XP en Windows moderno</a></li>
<li><a href="../es430438/index.html">Sombras realistas para roguelike</a></li>
<li><a href="../es430446/index.html">Una vez m√°s sobre las ventajas de la "esclavitud m√≥vil"</a></li>
<li><a href="../es430448/index.html">Lo que le da al aprendizaje autom√°tico minorista: un ejemplo de proyecto</a></li>
<li><a href="../es430450/index.html">Modelo de desarrollo utilizando CPU basada en pila como ejemplo</a></li>
<li><a href="../es430452/index.html">Fuego, agua y spray fino. C√≥mo los residentes y visitantes del Centro Lakhta estar√°n protegidos del fuego</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>