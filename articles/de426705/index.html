<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙎🏽 👩🏼‍💼 🙆🏾 Entwicklung und Testen intelligenter Verträge für Hyperledger Fabric 🤘🏽 💌 👩🏿‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hyperledger Fabric (HLF) ist eine Open-Source-Plattform, die DLT-Technologie (Distributed Ledger Technology) verwendet, um Anwendungen zu entwickeln, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entwicklung und Testen intelligenter Verträge für Hyperledger Fabric</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426705/"><p>  Hyperledger Fabric (HLF) ist eine Open-Source-Plattform, die DLT-Technologie (Distributed Ledger Technology) verwendet, um Anwendungen zu entwickeln, die in einer Unternehmensnetzwerkumgebung funktionieren, die von einem Konsortium von Organisationen mithilfe von Zugriffsregeln erstellt und gesteuert wird (mit Berechtigung). </p><br><p>  Die Plattform unterstützt intelligente Verträge in HLF-Begriffen - Kettencodes, die in allgemeinen Sprachen wie Golang, JavaScript, Java erstellt wurden, im Gegensatz zu beispielsweise Ethereum, das eine vertragsorientierte Solidity-Sprache mit eingeschränkter Funktionalität verwendet (LLL, Viper usw.). </p><br><p><img src="https://habrastorage.org/webt/w4/em/ps/w4empss606_8k1h8tvkcmfim4c8.png"></p><br><p>  Das Entwickeln und Testen von Kettencodes kann aufgrund der Notwendigkeit, eine erhebliche Anzahl von Komponenten des Blockchain-Netzwerks bereitzustellen, ein ziemlich langwieriger Prozess sein, bei dem viel Zeit für das Testen von Änderungen aufgewendet wird.  Dieser Artikel beschreibt einen Ansatz zur schnellen Entwicklung und zum Testen von HLF Golang-Smart-Verträgen mithilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CCKit-</a> Bibliothek. </p><a name="habracut"></a><br><h2 id="prilozhenie-na-baze-hlf">  HLF-basierte Anwendung </h2><br><p>  Aus Sicht des Entwicklers besteht die Blockchain-Anwendung aus zwei Hauptteilen: </p><br><ul><li>  <strong>On-Chain</strong> - Intelligente Verträge (Programme), die in einer isolierten Umgebung des Blockchain-Netzwerks ausgeführt werden und die Regeln für die Erstellung und Zusammensetzung von Transaktionsattributen festlegen.  In einem intelligenten Vertrag sind die Hauptaktionen das Lesen, Aktualisieren und Löschen von Daten aus dem Status des Blockchain-Netzwerks.  Es sollte betont werden, dass beim Löschen von Daten aus einem Status Informationen darüber verbleiben, dass diese Daten vorhanden waren. </li><li>  <strong>Off-Chain</strong> ist eine Anwendung (z. B. eine API), die über das SDK mit der Blockchain-Umgebung interagiert.  Unter Interaktion versteht man das Aufrufen von Smart Contract-Funktionen und das Überwachen von Smart Contract-Ereignissen. Externe Ereignisse können Datenänderungen im Smart Contract verursachen, während Ereignisse im Smart Contract Aktionen in externen Systemen auslösen können. </li></ul><br><p>  Daten werden normalerweise über den Blockchain-Netzwerkknoten „Home“ gelesen.  Um Daten aufzuzeichnen, sendet die Anwendung Anforderungen an die Knoten von Organisationen, die an der „Genehmigungsrichtlinie“ eines bestimmten Smart-Vertrags teilnehmen. </p><br><p>  Zur Entwicklung von Off-Chain-Code (API usw.) wird ein spezielles SDK verwendet, das die Interaktion mit Blockchain-Knoten, das Sammeln von Antworten usw. kapselt.  Für HLF gibt es SDK-Implementierungen für Go ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2</a> ), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node.Js</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java</a> </p><br><h2 id="komponenty-hyperledger-fabric">  Hyperledger Fabric-Komponenten </h2><br><h3 id="kanal">  Kanal </h3><br><p>  Ein Kanal ist ein separates Subnetz von Knoten, das eine isolierte Blockkette (Ledger) sowie den aktuellen Status (Schlüsselwert) der Blockkette (Weltstatus) unterstützt, die für den Betrieb intelligenter Verträge verwendet wird.  Ein Host kann auf eine beliebige Anzahl von Kanälen zugreifen. </p><br><h3 id="tranzakciya">  Transaktion </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eine Transaktion in Hyperledger Fabric</a> ist eine atomare Aktualisierung des Status einer Blockkette, das Ergebnis der Ausführung der Chaincode-Methode.  Eine Transaktion besteht aus einer Anforderung zum Aufrufen einer Chaincode-Methode mit einigen vom aufrufenden Knoten signierten Argumenten (Transaktionsvorschlag) und einer Reihe von Antworten (Transaktionsvorschlagsantwort) von den Knoten, auf denen die Transaktion „bestätigt“ wurde (Bestätigung).  Die Antworten enthalten Informationen zu den sich ändernden Schlüssel-Wert-Paaren des Status der Blockkette des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lese- / Schreibsatzes</a> und Dienstinformationen (Signaturen und Zertifikate von Knoten, die die Transaktion bestätigen).  Weil  Blockketten einzelner Kanäle sind physisch getrennt, eine Transaktion kann nur im Kontext eines Kanals durchgeführt werden. </p><br><p>  Die "klassischen" Blockchain-Plattformen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bitcoin</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ethereum</a> verwenden den von allen Knoten ausgeführten Ordering-Execution-Transaktionszyklus, wodurch die Skalierbarkeit des Blockchain-Netzwerks eingeschränkt wird. </p><br><p><img src="https://habrastorage.org/webt/ad/-b/ud/ad-budtoazz80tcc2vcgmzyahve.png"></p><br><p>  Hyperledger Fabric verwendet eine Transaktionsausführungs- und -verteilungsarchitektur mit drei Hauptoperationen: </p><br><ul><li><p>  Ausführung ( <strong>Ausführung</strong> ) - Erstellung durch einen intelligenten Vertrag, der auf einem oder mehreren Netzwerkknoten ausgeführt wird, Transaktionen - atomare Änderungen im Status einer verteilten Registrierung ( <em>Bestätigung</em> ) </p><br></li><li><p>  Bestellung - Bestellung und Gruppierung von Transaktionen in Blöcken durch den spezialisierten Bestellservice unter Verwendung eines steckbaren Konsensalgorithmus. </p><br></li><li><p>  Validieren - Überprüfung der vom <em>Besteller stammenden</em> Transaktionen durch Netzwerkknoten, bevor Informationen von diesen in ihre Kopie der verteilten Registrierung aufgenommen werden </p><br></li></ul><br><p><img src="https://habrastorage.org/webt/xw/ss/xj/xwssxjcfyfmsydsfnyl4oey_coe.png"></p><br><p>  Mit diesem Ansatz können Sie die Transaktionsausführungsphase vor dem Eintritt in das Blockchain-Netzwerk ausführen und den Betrieb von Netzwerkknoten horizontal skalieren. </p><br><h3 id="cheynkod">  Kettencode </h3><br><p>  Ein Kettencode, der auch als Smart Contract bezeichnet werden kann, ist ein in Golang, JavaScript (HLF 1.1+) oder Java (HLF 1.3+) geschriebenes Programm, das die Regeln zum Erstellen von Transaktionen definiert, die den Status einer Blockkette ändern.  Das Programm wird gleichzeitig auf mehreren unabhängigen Knoten eines verteilten Netzwerks von Blockchain-Knoten ausgeführt, wodurch eine neutrale Umgebung für die Ausführung intelligenter Verträge geschaffen wird, indem die Ergebnisse der Programmausführung auf allen Knoten abgeglichen werden, die für die "Bestätigung" der Transaktion erforderlich sind. </p><br><p>  Der Code muss eine Schnittstelle implementieren, die aus Methoden besteht: </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Chaincode <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Init is called during Instantiate transaction Init(stub ChaincodeStubInterface) pb.Response // Invoke is called to update or query the ledger Invoke(stub ChaincodeStubInterface) pb.Response }</span></span></code> </pre> <br><ul><li>  Die <strong>Init-</strong> Methode wird beim Instanziieren oder Aktualisieren des Codecodes aufgerufen.  Diese Methode führt die erforderliche Initialisierung des Status des Codecodes durch.  Es ist wichtig, im Methodencode zu unterscheiden, ob es sich bei dem Aufruf um eine Instanziierung oder ein Upgrade handelt, damit Sie versehentlich nicht die Daten initialisieren (zurücksetzen), die während des Betriebs des Codecodes bereits einen Status ungleich Null erhalten haben. </li><li>  Die <strong>Invoke-</strong> Methode wird aufgerufen, wenn auf eine Funktion des Codecodes zugegriffen wird.  Diese Methode funktioniert mit dem Status intelligenter Verträge. </li></ul><br><p>  Der Kettencode wird auf den Peers des Blockchain-Netzwerks installiert.  Auf Systemebene entspricht jede Instanz des Codes einem separaten Docker-Container, der an einen bestimmten Netzwerkknoten angeschlossen ist und Dispatching-Aufrufe zur Ausführung des Codes ausführt. <br>  Im Gegensatz zu intelligenten Ethereum-Verträgen kann die Verkettungslogik aktualisiert werden. Dies erfordert jedoch, dass alle Knoten, auf denen sich der Codecode befindet, eine aktualisierte Version installieren. </p><br><p>  In Reaktion auf einen Aufruf der Kettencodefunktion von außen über das SDK erzeugt der Kettencode eine Änderung des Status der Blockkette ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lese- / Schreibsatz</a> ) sowie Ereignisse.  Ein Kettencode bezieht sich auf einen bestimmten Kanal und kann Daten in nur einem Kanal ändern.  Wenn der Host, auf dem der Code installiert ist, auch Zugriff auf andere Kanäle hat, kann gleichzeitig in der Logik des Codes Daten von diesen Kanälen gelesen werden. </p><br><p>  Spezielle Kettencodes zum Verwalten verschiedener Aspekte des Betriebs eines Blockchain-Netzwerks werden als Systemkettencodes bezeichnet. </p><br><h3 id="politika-odobreniya-endorsement-policy">  Endorsement Policy </h3><br><p>  Eine Genehmigungsrichtlinie definiert Konsensregeln auf der Ebene der Transaktionen, die von einem bestimmten Kettencode generiert werden.  Die Richtlinie legt die Regeln fest, die bestimmen, welche Kanalknoten eine Transaktion erstellen sollen.  Zu diesem Zweck muss jeder der in der Genehmigungsrichtlinie angegebenen Knoten die Verkettungsmethode (Schritt "Ausführen") ausführen und eine "Simulation" durchführen. Anschließend werden die signierten Ergebnisse vom SDK gesammelt und überprüft, das die Transaktion initiiert hat (alle Simulationsergebnisse müssen identisch sein.) Signaturen aller für die Richtlinie erforderlichen Knoten müssen vorhanden sein.  Als nächstes sendet das SDK die Transaktion an den <em>Besteller.</em> Danach empfangen alle Knoten, die Zugriff auf den Kanal haben, die Transaktion über den <em>Besteller</em> und führen den Schritt "Validieren" aus.  Es ist wichtig zu betonen, dass nicht alle Kanalknoten am Schritt "Ausführen" teilnehmen müssen. </p><br><p>  Die Genehmigungsrichtlinie wird zum Zeitpunkt der Instanziierung oder Aktualisierung des Codes festgelegt.  In Version 1.3 wurde es möglich, Richtlinien nicht nur auf der Ebene des Kettencodes, sondern auch auf der Ebene der einzelnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zustandsbasierten Endorsement-Schlüssel</a> festzulegen.  Beispiele für Genehmigungsrichtlinien: </p><br><ul><li>  Knoten A, B, C, D. </li><li>  Die meisten Kanalknoten </li><li>  Mindestens 3 Knoten von A, B, C, D, E, F. </li></ul><br><h3 id="sobytie">  Ereignis </h3><br><p>  Ein Ereignis ist ein benannter Datensatz, mit dem Sie einen „Update-Feed“ des Status der Blockchain-Kette veröffentlichen können.  Der Satz von Ereignisattributen definiert den Kettencode. </p><br><h2 id="infrastruktura-seti">  Netzwerkinfrastruktur </h2><br><h3 id="uzel-seti-peer">  Host (Peer) </h3><br><p>  Ein Host ist mit einer beliebigen Anzahl von Kanälen verbunden, für die er Zugriffsrechte hat.  Der Host verwaltet seine Version der Blockkette und den Status der Blockkette und bietet auch eine Umgebung zum Ausführen von Kettencodes.  Wenn der Host nicht Teil der Genehmigungsrichtlinie ist, muss er nicht mit Kettencodes eingerichtet werden. </p><br><p>  Auf der Ebene der Host-Software kann der aktuelle Status der Blockkette (Weltstatus) in LevelDB oder in CouchDB gespeichert werden.  Der Vorteil von CouchDB ist die Unterstützung umfangreicher Abfragen mit MongoDB-Syntax. </p><br><h3 id="orderer">  Besteller </h3><br><p>  Der Transaktionsverwaltungsdienst akzeptiert signierte Transaktionen als Eingabe und stellt sicher, dass die Transaktionen in der richtigen Reihenfolge auf die Netzwerkknoten verteilt werden. </p><br><p>  Der Besteller führt keine intelligenten Verträge aus und enthält keine Blockketten und Blockkettenzustände.  Im Moment (1.3) gibt es zwei Implementierungen von <em>orderer</em> - ein Development <em>Solo</em> und eine auf Kafka basierende Version, die Crash-Fehlertoleranz bietet.  Eine Implementierung des <em>Auftraggebers</em> , der den Widerstand gegen das falsche Verhalten eines bestimmten Teils der Teilnehmer unterstützt (byzantinische Fehlertoleranz), wird Ende 2018 erwartet. </p><br><h3 id="servis-identifikacii-membership-services">  Identitätsdienste </h3><br><p>  In einem Hyperledger Fabric-Netzwerk haben alle Mitglieder Identitäten, die anderen Mitgliedern bekannt sind (Identität).  Zur Identifizierung wird die Public-Key-Infrastruktur (PKI) verwendet, über die X.509-Zertifikate für Organisationen, Infrastrukturelemente (Knoten, Besteller), Anwendungen und Endbenutzer erstellt werden.  Infolgedessen kann der Zugriff auf Lese- und Änderungsdaten durch Zugriffsregeln auf Netzwerkebene, auf einem einzelnen Kanal oder in der Logik eines intelligenten Vertrags gesteuert werden.  Im selben Blockchain-Netzwerk können mehrere Identifikationsdienste verschiedener Typen gleichzeitig arbeiten. </p><br><h1 id="realizaciya-cheynkoda">  Implementierung des Codecodes </h1><br><p>  Chaincode kann als ein Objekt betrachtet werden, das über Methoden verfügt, die eine bestimmte Geschäftslogik implementieren.  Im Gegensatz zum klassischen OOP kann ein Kettencode keine Attributfelder haben.  Um mit dem Status zu arbeiten, dessen Speicher von der HLF-Blockchain-Plattform bereitgestellt wird, wird die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ebene ChaincodeStubInterface verwendet</a> , die beim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufruf</a> der Methoden <em>Init</em> und <em>Invoke übergeben</em> wird.  Es bietet die Möglichkeit, Funktionsaufrufargumente zu empfangen und Änderungen am Status der Blockkette vorzunehmen: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ChaincodeStubInterface <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { <span class="hljs-comment"><span class="hljs-comment">// GetArgs returns the arguments intended for the chaincode Init and Invoke GetArgs() [][]byte // InvokeChaincode locally calls the specified chaincode InvokeChaincode(chaincodeName string, args [][]byte, channel string) pb.Response // GetState returns the value of the specified `key` from the ledger. GetState(key string) ([]byte, error) // PutState puts the specified `key` and `value` into the transaction's writeset as a data-write proposal. PutState(key string, value []byte) error // DelState records the specified `key` to be deleted in the writeset of the transaction proposal. DelState(key string) error // GetStateByRange returns a range iterator over a set of keys in the ledger. GetStateByRange(startKey, endKey string) (StateQueryIteratorInterface, error) // CreateCompositeKey combines the given `attributes` to form a composite key. CreateCompositeKey(objectType string, attributes []string) (string, error) // GetCreator returns `SignatureHeader.Creator` (eg an identity of the agent (or user) submitting the transaction. GetCreator() ([]byte, error) // and many more methods }</span></span></code> </pre> <br><p>  In dem auf Solidity entwickelten Ethereum-Smart-Vertrag hat jede Methode eine öffentliche Funktion.  Im Hyperledger Fabric-Kettencode in den Methoden <em>Init</em> und <em>Invoke</em> mit der Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ChaincodeStubInterface</a> .  <em>GetArgs () können</em> Sie die Argumente des Funktionsaufrufs in Form eines Arrays von Byte-Arrays abrufen, während das erste Element des Arrays beim Aufruf von <em>Invoke</em> den Namen der Chaincode-Funktion enthält.  Weil  Der Aufruf einer beliebigen Chaincode-Methode durchläuft die Invoke-Methode. Wir können sagen, dass dies eine Implementierung des Front-Controller-Musters ist. </p><br><p>  Wenn wir beispielsweise die Implementierung der Standard-Ethereum-Schnittstelle für das <a href="">ERC-20-</a> Token in Betracht ziehen, sollte der Smart Contract die folgenden Methoden implementieren: </p><br><ul><li>  totalSupply () </li><li>  balanceOf (Adresse _Besitzer) </li><li>  Übertragung (Adresse _to, uint256 _Wert) </li></ul><br><p>  und andere. Bei der HLF-Implementierung muss der Funktionscode <em>Invoke</em> in der Lage sein, Fälle zu behandeln, in denen das erste Argument zum <em>Aufrufen von</em> Aufrufen den Namen der erwarteten Methoden enthält (z. B. "totalSupply" oder "balanceOf").  Ein Beispiel für die Implementierung des ERC-20-Standards ist hier zu sehen. </p><br><h2 id="primery-cheynkodov">  Chaincode-Beispiele </h2><br><p>  Neben der Dokumentation zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hyperledger Fabric gibt</a> es einige weitere Beispiele für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kettencodes</a> : </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blockchain Versicherungs App (2018)</a> </li><li>  <a href="">Murmeln</a> </li><li>  <a href="">Car-Lease-Demo (2017)</a> s </li></ul><br><p>  Die Implementierung der Kettencodes in diesen Beispielen ist ziemlich ausführlich und enthält eine Menge sich wiederholender Logik zur Auswahl der aufgerufenen Routing-Funktionen. Überprüfen der Anzahl der Argumente, json marshalling / unmarshalling: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *SimpleChaincode)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stub shim.ChaincodeStubInterface)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pb</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Response</span></span></span></span> { function, args := stub.GetFunctionAndParameters() fmt.Println(<span class="hljs-string"><span class="hljs-string">"invoke is running "</span></span> + function) <span class="hljs-comment"><span class="hljs-comment">// Handle different functions if function == "initMarble" { //create a new marble return t.initMarble(stub, args) } else if function == "transferMarble" { //change owner of a specific marble return t.transferMarble(stub, args) } else if function == "readMarble" { //read a marble return t.readMarble(stub, args) } else ...</span></span></code> </pre><br><p>  Eine solche Organisation des Codes führt zu einer Verschlechterung der Lesbarkeit des Codes und möglichen Fehlern wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen</a> , wenn Sie einfach vergessen haben, die Eingabedaten zu entfernen.  In den Präsentationen zu den HLF-Entwicklungsplänen wird eine Überarbeitung des Ansatzes zur Entwicklung von Kettencodes erwähnt, insbesondere die Einführung von Anmerkungen in Java-Kettencodes usw. Die Pläne beziehen sich jedoch auf die Version, die erst 2019 erwartet wird.  Die Erfahrung mit der Entwicklung intelligenter Verträge hat zu dem Schluss geführt, dass das Entwickeln und Testen von Kettencodes einfacher ist, wenn Sie die Grundfunktionen in einer separaten Bibliothek auswählen. </p><br><h1 id="cckit---biblioteka-dlya-razrabotki-i-testirovaniya-cheynkodov">  CCKit - eine Bibliothek zum Entwickeln und Testen von Kettencodes </h1><br><p>  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CCKit-</a> Bibliothek fasst die Praxis des Entwickelns und Testens von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kettencodes</a> zusammen.  Im Rahmen der Entwicklung von Chaincode- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erweiterungen</a> wurde als Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die</a> OpenZeppelin-Erweiterungsbibliothek für Ethereum-Smart-Verträge verwendet.  CCKit verwendet die folgenden Architekturlösungen: </p><br><h2 id="marshrutizaciya-routing-obrascheniy-k-funkciyam-smart-kontrakta">  Weiterleiten von Anrufen an intelligente Vertragsfunktionen </h2><br><p>  Routing bezieht sich auf den Algorithmus, mit dem die Anwendung auf eine Clientanforderung reagiert.  Dieser Ansatz wird beispielsweise in fast allen http-Frameworks verwendet.  Der Router verwendet bestimmte Regeln, um die Anforderung und den Anforderungshandler zu binden.  In Bezug auf einen Kettencode dient dies dazu, den Namen der Kettencodefunktion mit der Handlerfunktion zu verknüpfen. </p><br><p>  In den neuesten Beispielen für intelligente Verträge, beispielsweise in der <a href="">Versicherungs-App</a> , wird die Zuordnung zwischen dem Namen der Kettencodefunktion und der Funktion im Golang-Code des Formulars verwendet: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bcFunctions = <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(shim.ChaincodeStubInterface, []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pb</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Response</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Insurance Peer "contract_type_ls": listContractTypes, "contract_type_create": createContractType, ... "theft_claim_process": processTheftClaim, }</span></span></code> </pre> <br><p>  Der CCKit-Router verwendet einen ähnlichen Ansatz wie der http-Router sowie die Möglichkeit, den Anforderungskontext für die Chaincode-Funktion und die Middleware-Funktionen zu verwenden </p><br><h2 id="kontekst-obrascheniya-k-funkcii-cheynkoda">  Der Kontext des Aufrufs der Funktion des Codes </h2><br><p>  Ähnlich wie der http-Anforderungskontext, der normalerweise Zugriff auf die http-Anforderungsparameter hat, verwendet der CCKit-Router den Kontext des Aufrufs der <a href="">Smart Contract-</a> Funktion, die eine Abstraktion über <em>shim.ChaincodeStubInterface darstellt</em> .  Der Kontext kann das einzige Argument für den Handler der Verkettungsfunktion sein. Über ihn kann der Handler die Argumente des Funktionsaufrufs sowie Zugriff auf Hilfsfunktionen für die Arbeit mit dem Status des intelligenten Vertrags (Status), das Erstellen von Antworten (Antwort) usw. erhalten. </p><br><pre> <code class="go hljs">Context <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Stub() shim.ChaincodeStubInterface Client() (cid.ClientIdentity, error) Response() Response Logger() *shim.ChaincodeLogger Path() <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> State() State Time() (time.Time, error) Args() InterfaceMap Arg(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} ArgString(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ArgBytes(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> SetArg(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) Get(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} Set(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) SetEvent(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) error }</code> </pre> <br><p>  Weil  Der Kontext ist eine Schnittstelle, in bestimmten Kettencodes kann er erweitert werden. </p><br><h2 id="funkcii-promezhutochnoy-obrabotki-middleware">  Middleware-Funktionen </h2><br><p>  Funktionen der Zwischenverarbeitung (Middleware) werden vor dem Aufruf des Handlers der Codemethode aufgerufen, haben Zugriff auf den Kontext des Aufrufs der Codemethode und auf die nächste Zwischenfunktion oder direkt auf den Handler der Methode des nächsten (next).  Middleware kann verwendet werden für: </p><br><ul><li>  Konvertieren von Eingabedaten (im folgenden Beispiel sind <em>p.String</em> und <em>p.Struct</em> Middleware) </li><li>  Einschränkungen beim Zugriff auf die Funktion (z. B. <em>Eigentümer. Nur</em> ) </li><li>  Abschluss des Anforderungsverarbeitungszyklus </li><li>  Aufruf der nächsten Zwischenverarbeitungsfunktion vom Stapel </li></ul><br><h2 id="konvertaciya-struktur-dannyh">  Datenstrukturkonvertierung </h2><br><p>  Die Kettencode-Schnittstelle nimmt an, dass der Eingabe ein Array von Byte-Arrays zugeführt wird, deren Elemente jeweils ein Attribut der Kettencode-Funktion sind.  Um zu verhindern, dass aus den Funktionsaufrufargumenten in jedem Handler der Verkettungsfunktion ein manuelles Daten-Marshalling vom Byte-Array zum Golang-Datentyp (int, string, struct, array) erfolgt, werden die erwarteten Datentypen zum Zeitpunkt der Erstellung der Routing-Regel im CCKit-Router festgelegt und der Typ wird automatisch konvertiert .  Im <em>folgenden</em> Beispiel erwartet die <em>carGet-</em> Funktion ein Argument vom Typ string, und die <em>carRegister-</em> Funktion <em>erwartet eine CarPayload-</em> Struktur.  Das Argument wird auch benannt, wodurch der Handler seinen Wert aus dem Kontext anhand des Namens abrufen kann.  Ein Beispiel für einen Handler wird unten angegeben.  Protobuf kann auch verwendet werden, um das Verkettungsdatenschema zu beschreiben. </p><br><pre> <code class="go hljs">r.Group(<span class="hljs-string"><span class="hljs-string">`car`</span></span>). Query(<span class="hljs-string"><span class="hljs-string">`List`</span></span>, cars). <span class="hljs-comment"><span class="hljs-comment">// chain code method name is carList Query(`Get`, car, p.String(`id`)). // chain code method name is carGet, method has 1 string argument "id" Invoke(`Register`, carRegister, p.Struct(`car`, &amp;CarPayload{}), // 1 struct argument owner.Only) // allow access to method only for chaincode owner (authority)</span></span></code> </pre> <br><p>  Die automatische Konvertierung (Marshalling) wird auch beim Schreiben von Daten in den Status eines intelligenten Vertrags und beim Erstellen von Ereignissen verwendet (der Golang-Typ wird in ein Array von Bytes serialisiert). </p><br><h2 id="sredstva-otladki-i-loggirovaniya-cheynkodov">  Tools zum Debuggen und Protokollieren von Kettencodes </h2><br><p>  Zum Debuggen des Codes können Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Debug-</a> Erweiterung verwenden, die intelligente Vertragsmethoden implementiert, mit denen Sie das Vorhandensein von Schlüsseln im Status des intelligenten Vertrags überprüfen und den Wert direkt nach Schlüssel lesen / ändern / löschen können. </p><br><p>  Für die Protokollierung im Kontext eines Aufrufs einer Chaincode-Funktion kann die Log () -Methode verwendet werden, die eine Instanz des in HLF verwendeten Loggers zurückgibt. </p><br><h2 id="metody-upravleniya-dostupa-k-metodam-smart-kontrakta">  Intelligente Vertragsmethoden Zugriffskontrollmethoden </h2><br><p>  Im Rahmen der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eigentümererweiterung</a> werden grundlegende Grundelemente zum Speichern von Informationen über den Eigentümer des instanziierten Kettencodes und Zugriffsmodifikatoren (Middleware) für intelligente Vertragsmethoden implementiert. </p><br><h2 id="sredstva-testirovaniya-smart-kontraktov">  Intelligente Tools zum Testen von Verträgen </h2><br><p>  Das Bereitstellen des Blockchain-Netzwerks, das Installieren und Initialisieren von Kettencodes ist eine ziemlich komplizierte Einrichtung und ein langwieriger Vorgang.  Die Zeit für die Neuinstallation / Aktualisierung des Smart-Vertragscodes kann durch Verwendung des DEV-Modus des Smart-Vertrags verkürzt werden. Die Aktualisierung des Codes ist jedoch weiterhin langsam. </p><br><p>  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shim-</a> Paket enthält eine Implementierung von <a href="">MockStub</a> , die Aufrufe des Codes für den Code <a href="">umschließt</a> und dessen Betrieb in der HLF-Blockchain-Umgebung simuliert.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mit MockStub erhalten</a> Sie fast sofort Testergebnisse und können die Entwicklungszeit verkürzen.  Wenn wir das allgemeine Funktionsschema des Codes in HLF berücksichtigen, ersetzt MockStub im Wesentlichen das SDK, sodass Sie die Funktionen des Codes aufrufen können, und ahmt die Startumgebung des Codes auf dem Host nach. </p><br><p><img src="https://habrastorage.org/webt/3y/ed/z2/3yedz22nfldc41jmcnpjqyto3x0.png"></p><br><p>  Der MockStub aus der HLF-Lieferung enthält die Implementierung fast aller Methoden der <em>shim.ChaincodeStubInterface-</em> Schnittstelle. In der aktuellen Version (1.3) fehlen jedoch einige wichtige Methoden wie GetCreator.  Weil  Kettencode kann diese Methode verwenden, um ein Zertifikat eines Transaktionserstellers für die Zugriffskontrolle zu erhalten. Für eine maximale Abdeckung in Tests ist die Fähigkeit, einen Stub dieser Methode zu haben, wichtig. </p><br><p>  Die CCKit-Bibliothek enthält eine erweiterte Version von <a href="">MockStub</a> , die die Implementierung der fehlenden Methoden sowie Methoden zum Arbeiten mit Ereigniskanälen usw. enthält. </p><br><h2 id="primer-cheynkoda">  Beispiel für einen Kettencode </h2><br><p>  Erstellen wir beispielsweise einen einfachen Kettencode zum Speichern von Informationen über zugelassene Autos </p><br><h3 id="model-dannyh">  Datenmodell </h3><br><p>  Der Status des Codecodes ist der Schlüsselwertspeicher, in dem der Schlüssel eine Zeichenfolge und der Wert ein Array von Bytes ist.  Die grundlegende Praxis besteht darin, jonalisierte Golang-Datenstrukturinstanzen als Werte zu speichern.  Um mit Daten im Kettencode zu arbeiten, müssen Sie nach dem Lesen aus dem Status das Byte-Array entfernen. </p><br><p>  Um über das Auto aufzuzeichnen, verwenden wir die folgenden Attribute: </p><br><ul><li>  Kennung (Autonummer) </li><li>  Automodell </li><li>  Informationen zum Fahrzeughalter </li><li>  Informationen zur Datenänderungszeit </li></ul><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Car struct for chaincode state type Car struct { Id string Title string Owner string UpdatedAt time.Time // set by chaincode method }</span></span></code> </pre> <br><p>  Um Daten in den Kettencode zu übertragen, erstellen Sie eine separate Struktur, die nur die Felder enthält, die von außerhalb des Kettencodes stammen: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// CarPayload chaincode method argument type CarPayload struct { Id string Title string Owner string }</span></span></code> </pre> <br><h3 id="rabota-s-klyuchami">  Mit Schlüsseln arbeiten </h3><br><p>  Datensatzschlüssel in einem intelligenten Vertragsstatus sind eine Zeichenfolge.  Es unterstützt auch die Möglichkeit, zusammengesetzte Schlüssel zu erstellen, bei denen Teile des Schlüssels durch ein Null-Byte ( <em>U + 0000</em> ) getrennt sind. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCompositeKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(objectType </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, attributes []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span></code> </pre> <br><p>  In <em>CCKit können die</em> Funktionen zum Arbeiten mit dem Status eines intelligenten Vertrags automatisch Schlüssel für Datensätze erstellen, wenn die übertragenen Strukturen die <em>Keyer-</em> Schnittstelle unterstützen </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Keyer interface for entity containing logic of its key creation type Keyer interface { Key() ([]string, error) }</span></span></code> </pre> <br><p>  Um ein Auto aufzuzeichnen, lautet die Schlüsselgenerierungsfunktion wie folgt: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CarEntity = <span class="hljs-string"><span class="hljs-string">`CAR`</span></span> <span class="hljs-comment"><span class="hljs-comment">// Key for car entry in chaincode state func (c Car) Key() ([]string, error) { return []string{CarEntity, c.Id}, nil }</span></span></code> </pre> <br><h3 id="deklaraciya-funkciy-smart-kontrakta-marshrutizaciya">  Intelligente Vertragsfunktionsdeklaration (Routing) </h3><br><p>  In der Konstruktormethode des Kettencodes können wir die Funktionen des Kettencodes und ihre Argumente definieren.  Der Autokennzeichen enthält 3 Funktionen </p><br><ul><li>  carList gibt ein Array von Car-Strukturen zurück </li><li>  carGet akzeptiert eine Fahrzeugkennung und gibt eine Fahrzeugstruktur zurück </li><li>  carRegister akzeptiert eine serialisierte Instanz der CarPayload-Struktur und gibt das Registrierungsergebnis zurück.  Der Zugriff auf diese Methode ist nur für den Eigentümer des Kettencodes möglich, der mithilfe der Middleware aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eigentümerpaket</a> gespeichert wird </li></ul><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">New</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">router</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Chaincode</span></span></span></span> { r := router.New(<span class="hljs-string"><span class="hljs-string">`cars`</span></span>) <span class="hljs-comment"><span class="hljs-comment">// also initialized logger with "cars" prefix r.Init(invokeInit) r.Group(`car`). Query(`List`, queryCars). // chain code method name is carList Query(`Get`, queryCar, p.String(`id`)). // chain code method name is carGet, method has 1 string argument "id" Invoke(`Register`, invokeCarRegister, p.Struct(`car`, &amp;CarPayload{}), // 1 struct argument owner.Only) // allow access to method only for chaincode owner (authority) return router.NewChaincode(r) }</span></span></code> </pre> <br><p>  Im obigen Beispiel wird die <a href="">Chaincode-</a> Struktur verwendet, in der die Verarbeitung der Methoden <em>Init</em> und <em>Invoke</em> an den Router delegiert wird: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> router <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"github.com/hyperledger/fabric/core/chaincode/shim"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/hyperledger/fabric/protos/peer"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// Chaincode default chaincode implementation with router type Chaincode struct { router *Group } // NewChaincode new default chaincode implementation func NewChaincode(r *Group) *Chaincode { return &amp;Chaincode{r} } //======== Base methods ==================================== // // Init initializes chain code - sets chaincode "owner" func (cc *Chaincode) Init(stub shim.ChaincodeStubInterface) peer.Response { // delegate handling to router return cc.router.HandleInit(stub) } // Invoke - entry point for chain code invocations func (cc *Chaincode) Invoke(stub shim.ChaincodeStubInterface) peer.Response { // delegate handling to router return cc.router.Handle(stub) }</span></span></code> </pre> <br><p>  Die Verwendung eines Routers und der grundlegenden Chaincode-Struktur ermöglicht die Wiederverwendung von Handlerfunktionen.  Um beispielsweise Chaincode zu implementieren, ohne den Zugriff auf die <code>carRegister</code> Funktion zu <code>carRegister</code> , reicht <code>carRegister</code> aus, eine neue <a href="">Konstruktormethode</a> zu erstellen </p><br><h3 id="realizaciya-funkciy-smart-kontrakta">  Implementierung der Funktionen eines Smart Contract </h3><br><p>  Golang-Funktionen - <strong>Es</strong> gibt drei Arten von intelligenten Vertragsfunktionshandlern im <strong>CCKit-</strong> Router: </p><br><ul><li>  <em>StubHandlerFunc</em> - Die Standard-Handler-Schnittstelle akzeptiert <em>shim.ChaincodeStubInterface</em> und gibt die Standardantwort <em>Peer.Response zurück</em> </li><li>  <em>ContextHandlerFunc</em> - nimmt einen Kontext und gibt <em>peer.Response zurück</em> </li><li>  <em>HandlerFunc</em> - akzeptiert den Kontext, gibt die Schnittstelle und den Fehler zurück.  Ein Byte-Array kann zurückgegeben werden oder ein beliebiger Golang-Typ, der automatisch in ein Byte-Array konvertiert wird, basierend darauf, welche <em>Peer.Response</em> erstellt wird.  Der Antwortstatus <em>lautet</em> je nach übergebenem Fehler <em>shim.Ok</em> oder <em>shim.Error</em> . </li></ul><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// StubHandlerFunc acts as raw chaincode invoke method, accepts stub and returns peer.Response StubHandlerFunc func(shim.ChaincodeStubInterface) peer.Response // ContextHandlerFunc use stub context as input parameter ContextHandlerFunc func(Context) peer.Response // HandlerFunc returns result as interface and error, this is converted to peer.Response via response.Create HandlerFunc func(Context) (interface{}, error)</span></span></code> </pre> <br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Argumente der im Router beschriebenen Kettencodefunktionen werden automatisch von Bytearrays in Zieldatentypen (eine Zeichenfolge oder eine CarPayload-Struktur) konvertiert. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Kettencodefunktion verwendet Statusmethoden, die das Extrahieren und Speichern von Daten in einen Kettencodestatus vereinfachen, indem automatisch Schlüssel erstellt und die übertragenen Daten in Arrays konvertiert werden Byte (im Bytecode wird ein Array von Bytes geschrieben)</font></font></p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// car get info chaincode method handler func car(c router.Context) (interface{}, error) { return c.State().Get( // get state entry Key(c.ArgString(`id`)), // by composite key using CarKeyPrefix and car.Id &amp;Car{}) // and unmarshal from []byte to Car struct } // cars car list chaincode method handler func cars(c router.Context) (interface{}, error) { return c.State().List( CarKeyPrefix, // get list of state entries of type CarKeyPrefix &amp;Car{}) // unmarshal from []byte and append to []Car slice } // carRegister car register chaincode method handler func carRegister(c router.Context) (interface{}, error) { // arg name defined in router method definition p := c.Arg(`car`).(CarPayload) t, _ := c.Time() // tx time car := &amp;Car{ // data for chaincode state Id: p.Id, Title: p.Title, Owner: p.Owner, UpdatedAt: t, } return car, // peer.Response payload will be json serialized car data c.State().Insert( //put json serialized data to state Key(car.Id), // create composite key using CarKeyPrefix and car.Id car) }</span></span></code> </pre> <br><h3 id="testy-smart-kontrakta"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Intelligente Vertragstests </font></font></h3><br><p>    -       —        ,     .      BDD – Behavior Driven Development,          . </p><br><p>  , , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- Ethereum</a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ganache-cli</a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">truffle</a> .   golang -  Mockstub. </p><br><h3 id="primer-testa">   </h3><br><p>    ,     .     <a href=""></a> . </p><br><p>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ginkgo</a> ,     Go,      <code>go test</code> .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gomega</a>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">expect</a> ,    ,     . </p><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"testing"</span></span> . <span class="hljs-string"><span class="hljs-string">"github.com/onsi/ginkgo"</span></span> . <span class="hljs-string"><span class="hljs-string">"github.com/onsi/gomega"</span></span> examplecert <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/examples/cert"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/extensions/owner"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/identity"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/state"</span></span> testcc <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/testing"</span></span> expectcc <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/testing/expect"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestCars</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { RegisterFailHandler(Fail) RunSpecs(t, <span class="hljs-string"><span class="hljs-string">"Cars Suite"</span></span>) }</code> </pre> <br><p>      ,   <em>CarPayload</em> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Payloads = []*Car{{ Id: <span class="hljs-string"><span class="hljs-string">`A777MP77`</span></span>, Title: <span class="hljs-string"><span class="hljs-string">`VAZ`</span></span>, Owner: <span class="hljs-string"><span class="hljs-string">`victor`</span></span>, }, { Id: <span class="hljs-string"><span class="hljs-string">`O888OO77`</span></span>, Title: <span class="hljs-string"><span class="hljs-string">`YOMOBIL`</span></span>, Owner: <span class="hljs-string"><span class="hljs-string">`alexander`</span></span>, }, { Id: <span class="hljs-string"><span class="hljs-string">`O222OO177`</span></span>, Title: <span class="hljs-string"><span class="hljs-string">`Lambo`</span></span>, Owner: <span class="hljs-string"><span class="hljs-string">`hodl`</span></span>, }}</code> </pre> <br><p>     MockStub   Cars. </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//Create chaincode mock cc := testcc.NewMockStub(`cars`, New())</span></span></code> </pre> <br><p>  Weil   cars      ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> . </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// load actor certificates actors, err := identity.ActorsFromPemFile(`SOME_MSP`, map[string]string{ `authority`: `s7techlab.pem`, `someone`: `victor-nosov.pem`}, examplecert.Content)</span></span></code> </pre> <br><p>   <em>BeforeSuite</em>    <em>Car</em>      <em>authority</em>     <em>Init</em>    .  ,    <em>Cars</em>   Init       <em>Init</em> ,    . </p><br><pre> <code class="go hljs">BeforeSuite(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// init chaincode expectcc.ResponseOk(cc.From(actors[`authority`]).Init()) // init chaincode from authority })</span></span></code> </pre> <br><p>          . ,          <em>CarRegister</em> ,              . </p><br><pre> <code class="go hljs">It(<span class="hljs-string"><span class="hljs-string">"Allow authority to add information about car"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//invoke chaincode method from authority actor expectcc.ResponseOk(cc.From(actors[`authority`]).Invoke(`carRegister`, Payloads[0])) }) It("Disallow non authority to add information about car", func() { //invoke chaincode method from non authority actor expectcc.ResponseError( cc.From(actors[`someone`]).Invoke(`carRegister`, Payloads[0]), owner.ErrOwnerOnly) // expect "only owner" error })</span></span></code> </pre> <br><p>             : </p><br><pre> <code class="go hljs">It(<span class="hljs-string"><span class="hljs-string">"Disallow authority to add duplicate information about car"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { expectcc.ResponseError( cc.From(actors[<span class="hljs-string"><span class="hljs-string">`authority`</span></span>]).Invoke(<span class="hljs-string"><span class="hljs-string">`carRegister`</span></span>, Payloads[<span class="hljs-number"><span class="hljs-number">0</span></span>]), state.ErrKeyAlreadyExists) <span class="hljs-comment"><span class="hljs-comment">//expect car id already exists })</span></span></code> </pre> <br><h1 id="zaklyuchenie">  Fazit </h1><br><p> - HLF        Go, Java, JavaScript, ,    , -  (Solidity)     /   -.      /       . </p><br><p>    HLF  ,  ,      (     .).  Hypeledger Fabric        , ..     . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426705/">https://habr.com/ru/post/de426705/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426695/index.html">Bildverarbeitungskameras für Enthusiasten. Wie verwende ich die Kamera für die Offline-Navigation?</a></li>
<li><a href="../de426697/index.html">Arbeiten mit LibUsb-Geräten unter Android</a></li>
<li><a href="../de426699/index.html">Python-Test mit Pytest. Einfach, schnell, effizient und skalierbar. Vorwort und Einführung</a></li>
<li><a href="../de426701/index.html">Flattern - ein neuer Blick auf die plattformübergreifende Entwicklung</a></li>
<li><a href="../de426703/index.html">Was war am DataVizDay in Minsk interessant?</a></li>
<li><a href="../de426707/index.html">Genehmigungssystem. Wie wir das Fahrrad erfunden haben</a></li>
<li><a href="../de426709/index.html">JavaScript-Timer: alles was Sie wissen müssen</a></li>
<li><a href="../de426713/index.html">Intel Xeon W-3175X: 28 Kerne für zu Hause</a></li>
<li><a href="../de426717/index.html">Die Illusion der Täuschung: Eine visuelle optische Täuschung basierend auf Retro-Prognosen</a></li>
<li><a href="../de426719/index.html">Hackathon über Data Science in SIBUR: wie es war</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>