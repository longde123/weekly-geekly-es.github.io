<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôéüèΩ üë©üèº‚Äçüíº üôÜüèæ Entwicklung und Testen intelligenter Vertr√§ge f√ºr Hyperledger Fabric ü§òüèΩ üíå üë©üèø‚Äç‚úàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hyperledger Fabric (HLF) ist eine Open-Source-Plattform, die DLT-Technologie (Distributed Ledger Technology) verwendet, um Anwendungen zu entwickeln, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entwicklung und Testen intelligenter Vertr√§ge f√ºr Hyperledger Fabric</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426705/"><p>  Hyperledger Fabric (HLF) ist eine Open-Source-Plattform, die DLT-Technologie (Distributed Ledger Technology) verwendet, um Anwendungen zu entwickeln, die in einer Unternehmensnetzwerkumgebung funktionieren, die von einem Konsortium von Organisationen mithilfe von Zugriffsregeln erstellt und gesteuert wird (mit Berechtigung). </p><br><p>  Die Plattform unterst√ºtzt intelligente Vertr√§ge in HLF-Begriffen - Kettencodes, die in allgemeinen Sprachen wie Golang, JavaScript, Java erstellt wurden, im Gegensatz zu beispielsweise Ethereum, das eine vertragsorientierte Solidity-Sprache mit eingeschr√§nkter Funktionalit√§t verwendet (LLL, Viper usw.). </p><br><p><img src="https://habrastorage.org/webt/w4/em/ps/w4empss606_8k1h8tvkcmfim4c8.png"></p><br><p>  Das Entwickeln und Testen von Kettencodes kann aufgrund der Notwendigkeit, eine erhebliche Anzahl von Komponenten des Blockchain-Netzwerks bereitzustellen, ein ziemlich langwieriger Prozess sein, bei dem viel Zeit f√ºr das Testen von √Ñnderungen aufgewendet wird.  Dieser Artikel beschreibt einen Ansatz zur schnellen Entwicklung und zum Testen von HLF Golang-Smart-Vertr√§gen mithilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CCKit-</a> Bibliothek. </p><a name="habracut"></a><br><h2 id="prilozhenie-na-baze-hlf">  HLF-basierte Anwendung </h2><br><p>  Aus Sicht des Entwicklers besteht die Blockchain-Anwendung aus zwei Hauptteilen: </p><br><ul><li>  <strong>On-Chain</strong> - Intelligente Vertr√§ge (Programme), die in einer isolierten Umgebung des Blockchain-Netzwerks ausgef√ºhrt werden und die Regeln f√ºr die Erstellung und Zusammensetzung von Transaktionsattributen festlegen.  In einem intelligenten Vertrag sind die Hauptaktionen das Lesen, Aktualisieren und L√∂schen von Daten aus dem Status des Blockchain-Netzwerks.  Es sollte betont werden, dass beim L√∂schen von Daten aus einem Status Informationen dar√ºber verbleiben, dass diese Daten vorhanden waren. </li><li>  <strong>Off-Chain</strong> ist eine Anwendung (z. B. eine API), die √ºber das SDK mit der Blockchain-Umgebung interagiert.  Unter Interaktion versteht man das Aufrufen von Smart Contract-Funktionen und das √úberwachen von Smart Contract-Ereignissen. Externe Ereignisse k√∂nnen Daten√§nderungen im Smart Contract verursachen, w√§hrend Ereignisse im Smart Contract Aktionen in externen Systemen ausl√∂sen k√∂nnen. </li></ul><br><p>  Daten werden normalerweise √ºber den Blockchain-Netzwerkknoten ‚ÄûHome‚Äú gelesen.  Um Daten aufzuzeichnen, sendet die Anwendung Anforderungen an die Knoten von Organisationen, die an der ‚ÄûGenehmigungsrichtlinie‚Äú eines bestimmten Smart-Vertrags teilnehmen. </p><br><p>  Zur Entwicklung von Off-Chain-Code (API usw.) wird ein spezielles SDK verwendet, das die Interaktion mit Blockchain-Knoten, das Sammeln von Antworten usw. kapselt.  F√ºr HLF gibt es SDK-Implementierungen f√ºr Go ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2</a> ), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node.Js</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java</a> </p><br><h2 id="komponenty-hyperledger-fabric">  Hyperledger Fabric-Komponenten </h2><br><h3 id="kanal">  Kanal </h3><br><p>  Ein Kanal ist ein separates Subnetz von Knoten, das eine isolierte Blockkette (Ledger) sowie den aktuellen Status (Schl√ºsselwert) der Blockkette (Weltstatus) unterst√ºtzt, die f√ºr den Betrieb intelligenter Vertr√§ge verwendet wird.  Ein Host kann auf eine beliebige Anzahl von Kan√§len zugreifen. </p><br><h3 id="tranzakciya">  Transaktion </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eine Transaktion in Hyperledger Fabric</a> ist eine atomare Aktualisierung des Status einer Blockkette, das Ergebnis der Ausf√ºhrung der Chaincode-Methode.  Eine Transaktion besteht aus einer Anforderung zum Aufrufen einer Chaincode-Methode mit einigen vom aufrufenden Knoten signierten Argumenten (Transaktionsvorschlag) und einer Reihe von Antworten (Transaktionsvorschlagsantwort) von den Knoten, auf denen die Transaktion ‚Äûbest√§tigt‚Äú wurde (Best√§tigung).  Die Antworten enthalten Informationen zu den sich √§ndernden Schl√ºssel-Wert-Paaren des Status der Blockkette des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lese- / Schreibsatzes</a> und Dienstinformationen (Signaturen und Zertifikate von Knoten, die die Transaktion best√§tigen).  Weil  Blockketten einzelner Kan√§le sind physisch getrennt, eine Transaktion kann nur im Kontext eines Kanals durchgef√ºhrt werden. </p><br><p>  Die "klassischen" Blockchain-Plattformen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bitcoin</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ethereum</a> verwenden den von allen Knoten ausgef√ºhrten Ordering-Execution-Transaktionszyklus, wodurch die Skalierbarkeit des Blockchain-Netzwerks eingeschr√§nkt wird. </p><br><p><img src="https://habrastorage.org/webt/ad/-b/ud/ad-budtoazz80tcc2vcgmzyahve.png"></p><br><p>  Hyperledger Fabric verwendet eine Transaktionsausf√ºhrungs- und -verteilungsarchitektur mit drei Hauptoperationen: </p><br><ul><li><p>  Ausf√ºhrung ( <strong>Ausf√ºhrung</strong> ) - Erstellung durch einen intelligenten Vertrag, der auf einem oder mehreren Netzwerkknoten ausgef√ºhrt wird, Transaktionen - atomare √Ñnderungen im Status einer verteilten Registrierung ( <em>Best√§tigung</em> ) </p><br></li><li><p>  Bestellung - Bestellung und Gruppierung von Transaktionen in Bl√∂cken durch den spezialisierten Bestellservice unter Verwendung eines steckbaren Konsensalgorithmus. </p><br></li><li><p>  Validieren - √úberpr√ºfung der vom <em>Besteller stammenden</em> Transaktionen durch Netzwerkknoten, bevor Informationen von diesen in ihre Kopie der verteilten Registrierung aufgenommen werden </p><br></li></ul><br><p><img src="https://habrastorage.org/webt/xw/ss/xj/xwssxjcfyfmsydsfnyl4oey_coe.png"></p><br><p>  Mit diesem Ansatz k√∂nnen Sie die Transaktionsausf√ºhrungsphase vor dem Eintritt in das Blockchain-Netzwerk ausf√ºhren und den Betrieb von Netzwerkknoten horizontal skalieren. </p><br><h3 id="cheynkod">  Kettencode </h3><br><p>  Ein Kettencode, der auch als Smart Contract bezeichnet werden kann, ist ein in Golang, JavaScript (HLF 1.1+) oder Java (HLF 1.3+) geschriebenes Programm, das die Regeln zum Erstellen von Transaktionen definiert, die den Status einer Blockkette √§ndern.  Das Programm wird gleichzeitig auf mehreren unabh√§ngigen Knoten eines verteilten Netzwerks von Blockchain-Knoten ausgef√ºhrt, wodurch eine neutrale Umgebung f√ºr die Ausf√ºhrung intelligenter Vertr√§ge geschaffen wird, indem die Ergebnisse der Programmausf√ºhrung auf allen Knoten abgeglichen werden, die f√ºr die "Best√§tigung" der Transaktion erforderlich sind. </p><br><p>  Der Code muss eine Schnittstelle implementieren, die aus Methoden besteht: </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Chaincode <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Init is called during Instantiate transaction Init(stub ChaincodeStubInterface) pb.Response // Invoke is called to update or query the ledger Invoke(stub ChaincodeStubInterface) pb.Response }</span></span></code> </pre> <br><ul><li>  Die <strong>Init-</strong> Methode wird beim Instanziieren oder Aktualisieren des Codecodes aufgerufen.  Diese Methode f√ºhrt die erforderliche Initialisierung des Status des Codecodes durch.  Es ist wichtig, im Methodencode zu unterscheiden, ob es sich bei dem Aufruf um eine Instanziierung oder ein Upgrade handelt, damit Sie versehentlich nicht die Daten initialisieren (zur√ºcksetzen), die w√§hrend des Betriebs des Codecodes bereits einen Status ungleich Null erhalten haben. </li><li>  Die <strong>Invoke-</strong> Methode wird aufgerufen, wenn auf eine Funktion des Codecodes zugegriffen wird.  Diese Methode funktioniert mit dem Status intelligenter Vertr√§ge. </li></ul><br><p>  Der Kettencode wird auf den Peers des Blockchain-Netzwerks installiert.  Auf Systemebene entspricht jede Instanz des Codes einem separaten Docker-Container, der an einen bestimmten Netzwerkknoten angeschlossen ist und Dispatching-Aufrufe zur Ausf√ºhrung des Codes ausf√ºhrt. <br>  Im Gegensatz zu intelligenten Ethereum-Vertr√§gen kann die Verkettungslogik aktualisiert werden. Dies erfordert jedoch, dass alle Knoten, auf denen sich der Codecode befindet, eine aktualisierte Version installieren. </p><br><p>  In Reaktion auf einen Aufruf der Kettencodefunktion von au√üen √ºber das SDK erzeugt der Kettencode eine √Ñnderung des Status der Blockkette ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lese- / Schreibsatz</a> ) sowie Ereignisse.  Ein Kettencode bezieht sich auf einen bestimmten Kanal und kann Daten in nur einem Kanal √§ndern.  Wenn der Host, auf dem der Code installiert ist, auch Zugriff auf andere Kan√§le hat, kann gleichzeitig in der Logik des Codes Daten von diesen Kan√§len gelesen werden. </p><br><p>  Spezielle Kettencodes zum Verwalten verschiedener Aspekte des Betriebs eines Blockchain-Netzwerks werden als Systemkettencodes bezeichnet. </p><br><h3 id="politika-odobreniya-endorsement-policy">  Endorsement Policy </h3><br><p>  Eine Genehmigungsrichtlinie definiert Konsensregeln auf der Ebene der Transaktionen, die von einem bestimmten Kettencode generiert werden.  Die Richtlinie legt die Regeln fest, die bestimmen, welche Kanalknoten eine Transaktion erstellen sollen.  Zu diesem Zweck muss jeder der in der Genehmigungsrichtlinie angegebenen Knoten die Verkettungsmethode (Schritt "Ausf√ºhren") ausf√ºhren und eine "Simulation" durchf√ºhren. Anschlie√üend werden die signierten Ergebnisse vom SDK gesammelt und √ºberpr√ºft, das die Transaktion initiiert hat (alle Simulationsergebnisse m√ºssen identisch sein.) Signaturen aller f√ºr die Richtlinie erforderlichen Knoten m√ºssen vorhanden sein.  Als n√§chstes sendet das SDK die Transaktion an den <em>Besteller.</em> Danach empfangen alle Knoten, die Zugriff auf den Kanal haben, die Transaktion √ºber den <em>Besteller</em> und f√ºhren den Schritt "Validieren" aus.  Es ist wichtig zu betonen, dass nicht alle Kanalknoten am Schritt "Ausf√ºhren" teilnehmen m√ºssen. </p><br><p>  Die Genehmigungsrichtlinie wird zum Zeitpunkt der Instanziierung oder Aktualisierung des Codes festgelegt.  In Version 1.3 wurde es m√∂glich, Richtlinien nicht nur auf der Ebene des Kettencodes, sondern auch auf der Ebene der einzelnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zustandsbasierten Endorsement-Schl√ºssel</a> festzulegen.  Beispiele f√ºr Genehmigungsrichtlinien: </p><br><ul><li>  Knoten A, B, C, D. </li><li>  Die meisten Kanalknoten </li><li>  Mindestens 3 Knoten von A, B, C, D, E, F. </li></ul><br><h3 id="sobytie">  Ereignis </h3><br><p>  Ein Ereignis ist ein benannter Datensatz, mit dem Sie einen ‚ÄûUpdate-Feed‚Äú des Status der Blockchain-Kette ver√∂ffentlichen k√∂nnen.  Der Satz von Ereignisattributen definiert den Kettencode. </p><br><h2 id="infrastruktura-seti">  Netzwerkinfrastruktur </h2><br><h3 id="uzel-seti-peer">  Host (Peer) </h3><br><p>  Ein Host ist mit einer beliebigen Anzahl von Kan√§len verbunden, f√ºr die er Zugriffsrechte hat.  Der Host verwaltet seine Version der Blockkette und den Status der Blockkette und bietet auch eine Umgebung zum Ausf√ºhren von Kettencodes.  Wenn der Host nicht Teil der Genehmigungsrichtlinie ist, muss er nicht mit Kettencodes eingerichtet werden. </p><br><p>  Auf der Ebene der Host-Software kann der aktuelle Status der Blockkette (Weltstatus) in LevelDB oder in CouchDB gespeichert werden.  Der Vorteil von CouchDB ist die Unterst√ºtzung umfangreicher Abfragen mit MongoDB-Syntax. </p><br><h3 id="orderer">  Besteller </h3><br><p>  Der Transaktionsverwaltungsdienst akzeptiert signierte Transaktionen als Eingabe und stellt sicher, dass die Transaktionen in der richtigen Reihenfolge auf die Netzwerkknoten verteilt werden. </p><br><p>  Der Besteller f√ºhrt keine intelligenten Vertr√§ge aus und enth√§lt keine Blockketten und Blockkettenzust√§nde.  Im Moment (1.3) gibt es zwei Implementierungen von <em>orderer</em> - ein Development <em>Solo</em> und eine auf Kafka basierende Version, die Crash-Fehlertoleranz bietet.  Eine Implementierung des <em>Auftraggebers</em> , der den Widerstand gegen das falsche Verhalten eines bestimmten Teils der Teilnehmer unterst√ºtzt (byzantinische Fehlertoleranz), wird Ende 2018 erwartet. </p><br><h3 id="servis-identifikacii-membership-services">  Identit√§tsdienste </h3><br><p>  In einem Hyperledger Fabric-Netzwerk haben alle Mitglieder Identit√§ten, die anderen Mitgliedern bekannt sind (Identit√§t).  Zur Identifizierung wird die Public-Key-Infrastruktur (PKI) verwendet, √ºber die X.509-Zertifikate f√ºr Organisationen, Infrastrukturelemente (Knoten, Besteller), Anwendungen und Endbenutzer erstellt werden.  Infolgedessen kann der Zugriff auf Lese- und √Ñnderungsdaten durch Zugriffsregeln auf Netzwerkebene, auf einem einzelnen Kanal oder in der Logik eines intelligenten Vertrags gesteuert werden.  Im selben Blockchain-Netzwerk k√∂nnen mehrere Identifikationsdienste verschiedener Typen gleichzeitig arbeiten. </p><br><h1 id="realizaciya-cheynkoda">  Implementierung des Codecodes </h1><br><p>  Chaincode kann als ein Objekt betrachtet werden, das √ºber Methoden verf√ºgt, die eine bestimmte Gesch√§ftslogik implementieren.  Im Gegensatz zum klassischen OOP kann ein Kettencode keine Attributfelder haben.  Um mit dem Status zu arbeiten, dessen Speicher von der HLF-Blockchain-Plattform bereitgestellt wird, wird die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ebene ChaincodeStubInterface verwendet</a> , die beim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufruf</a> der Methoden <em>Init</em> und <em>Invoke √ºbergeben</em> wird.  Es bietet die M√∂glichkeit, Funktionsaufrufargumente zu empfangen und √Ñnderungen am Status der Blockkette vorzunehmen: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ChaincodeStubInterface <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { <span class="hljs-comment"><span class="hljs-comment">// GetArgs returns the arguments intended for the chaincode Init and Invoke GetArgs() [][]byte // InvokeChaincode locally calls the specified chaincode InvokeChaincode(chaincodeName string, args [][]byte, channel string) pb.Response // GetState returns the value of the specified `key` from the ledger. GetState(key string) ([]byte, error) // PutState puts the specified `key` and `value` into the transaction's writeset as a data-write proposal. PutState(key string, value []byte) error // DelState records the specified `key` to be deleted in the writeset of the transaction proposal. DelState(key string) error // GetStateByRange returns a range iterator over a set of keys in the ledger. GetStateByRange(startKey, endKey string) (StateQueryIteratorInterface, error) // CreateCompositeKey combines the given `attributes` to form a composite key. CreateCompositeKey(objectType string, attributes []string) (string, error) // GetCreator returns `SignatureHeader.Creator` (eg an identity of the agent (or user) submitting the transaction. GetCreator() ([]byte, error) // and many more methods }</span></span></code> </pre> <br><p>  In dem auf Solidity entwickelten Ethereum-Smart-Vertrag hat jede Methode eine √∂ffentliche Funktion.  Im Hyperledger Fabric-Kettencode in den Methoden <em>Init</em> und <em>Invoke</em> mit der Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ChaincodeStubInterface</a> .  <em>GetArgs () k√∂nnen</em> Sie die Argumente des Funktionsaufrufs in Form eines Arrays von Byte-Arrays abrufen, w√§hrend das erste Element des Arrays beim Aufruf von <em>Invoke</em> den Namen der Chaincode-Funktion enth√§lt.  Weil  Der Aufruf einer beliebigen Chaincode-Methode durchl√§uft die Invoke-Methode. Wir k√∂nnen sagen, dass dies eine Implementierung des Front-Controller-Musters ist. </p><br><p>  Wenn wir beispielsweise die Implementierung der Standard-Ethereum-Schnittstelle f√ºr das <a href="">ERC-20-</a> Token in Betracht ziehen, sollte der Smart Contract die folgenden Methoden implementieren: </p><br><ul><li>  totalSupply () </li><li>  balanceOf (Adresse _Besitzer) </li><li>  √úbertragung (Adresse _to, uint256 _Wert) </li></ul><br><p>  und andere. Bei der HLF-Implementierung muss der Funktionscode <em>Invoke</em> in der Lage sein, F√§lle zu behandeln, in denen das erste Argument zum <em>Aufrufen von</em> Aufrufen den Namen der erwarteten Methoden enth√§lt (z. B. "totalSupply" oder "balanceOf").  Ein Beispiel f√ºr die Implementierung des ERC-20-Standards ist hier zu sehen. </p><br><h2 id="primery-cheynkodov">  Chaincode-Beispiele </h2><br><p>  Neben der Dokumentation zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hyperledger Fabric gibt</a> es einige weitere Beispiele f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kettencodes</a> : </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blockchain Versicherungs App (2018)</a> </li><li>  <a href="">Murmeln</a> </li><li>  <a href="">Car-Lease-Demo (2017)</a> s </li></ul><br><p>  Die Implementierung der Kettencodes in diesen Beispielen ist ziemlich ausf√ºhrlich und enth√§lt eine Menge sich wiederholender Logik zur Auswahl der aufgerufenen Routing-Funktionen. √úberpr√ºfen der Anzahl der Argumente, json marshalling / unmarshalling: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *SimpleChaincode)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stub shim.ChaincodeStubInterface)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pb</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Response</span></span></span></span> { function, args := stub.GetFunctionAndParameters() fmt.Println(<span class="hljs-string"><span class="hljs-string">"invoke is running "</span></span> + function) <span class="hljs-comment"><span class="hljs-comment">// Handle different functions if function == "initMarble" { //create a new marble return t.initMarble(stub, args) } else if function == "transferMarble" { //change owner of a specific marble return t.transferMarble(stub, args) } else if function == "readMarble" { //read a marble return t.readMarble(stub, args) } else ...</span></span></code> </pre><br><p>  Eine solche Organisation des Codes f√ºhrt zu einer Verschlechterung der Lesbarkeit des Codes und m√∂glichen Fehlern wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen</a> , wenn Sie einfach vergessen haben, die Eingabedaten zu entfernen.  In den Pr√§sentationen zu den HLF-Entwicklungspl√§nen wird eine √úberarbeitung des Ansatzes zur Entwicklung von Kettencodes erw√§hnt, insbesondere die Einf√ºhrung von Anmerkungen in Java-Kettencodes usw. Die Pl√§ne beziehen sich jedoch auf die Version, die erst 2019 erwartet wird.  Die Erfahrung mit der Entwicklung intelligenter Vertr√§ge hat zu dem Schluss gef√ºhrt, dass das Entwickeln und Testen von Kettencodes einfacher ist, wenn Sie die Grundfunktionen in einer separaten Bibliothek ausw√§hlen. </p><br><h1 id="cckit---biblioteka-dlya-razrabotki-i-testirovaniya-cheynkodov">  CCKit - eine Bibliothek zum Entwickeln und Testen von Kettencodes </h1><br><p>  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CCKit-</a> Bibliothek fasst die Praxis des Entwickelns und Testens von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kettencodes</a> zusammen.  Im Rahmen der Entwicklung von Chaincode- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erweiterungen</a> wurde als Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die</a> OpenZeppelin-Erweiterungsbibliothek f√ºr Ethereum-Smart-Vertr√§ge verwendet.  CCKit verwendet die folgenden Architekturl√∂sungen: </p><br><h2 id="marshrutizaciya-routing-obrascheniy-k-funkciyam-smart-kontrakta">  Weiterleiten von Anrufen an intelligente Vertragsfunktionen </h2><br><p>  Routing bezieht sich auf den Algorithmus, mit dem die Anwendung auf eine Clientanforderung reagiert.  Dieser Ansatz wird beispielsweise in fast allen http-Frameworks verwendet.  Der Router verwendet bestimmte Regeln, um die Anforderung und den Anforderungshandler zu binden.  In Bezug auf einen Kettencode dient dies dazu, den Namen der Kettencodefunktion mit der Handlerfunktion zu verkn√ºpfen. </p><br><p>  In den neuesten Beispielen f√ºr intelligente Vertr√§ge, beispielsweise in der <a href="">Versicherungs-App</a> , wird die Zuordnung zwischen dem Namen der Kettencodefunktion und der Funktion im Golang-Code des Formulars verwendet: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bcFunctions = <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(shim.ChaincodeStubInterface, []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pb</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Response</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Insurance Peer "contract_type_ls": listContractTypes, "contract_type_create": createContractType, ... "theft_claim_process": processTheftClaim, }</span></span></code> </pre> <br><p>  Der CCKit-Router verwendet einen √§hnlichen Ansatz wie der http-Router sowie die M√∂glichkeit, den Anforderungskontext f√ºr die Chaincode-Funktion und die Middleware-Funktionen zu verwenden </p><br><h2 id="kontekst-obrascheniya-k-funkcii-cheynkoda">  Der Kontext des Aufrufs der Funktion des Codes </h2><br><p>  √Ñhnlich wie der http-Anforderungskontext, der normalerweise Zugriff auf die http-Anforderungsparameter hat, verwendet der CCKit-Router den Kontext des Aufrufs der <a href="">Smart Contract-</a> Funktion, die eine Abstraktion √ºber <em>shim.ChaincodeStubInterface darstellt</em> .  Der Kontext kann das einzige Argument f√ºr den Handler der Verkettungsfunktion sein. √úber ihn kann der Handler die Argumente des Funktionsaufrufs sowie Zugriff auf Hilfsfunktionen f√ºr die Arbeit mit dem Status des intelligenten Vertrags (Status), das Erstellen von Antworten (Antwort) usw. erhalten. </p><br><pre> <code class="go hljs">Context <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Stub() shim.ChaincodeStubInterface Client() (cid.ClientIdentity, error) Response() Response Logger() *shim.ChaincodeLogger Path() <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> State() State Time() (time.Time, error) Args() InterfaceMap Arg(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} ArgString(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ArgBytes(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> SetArg(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) Get(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} Set(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) SetEvent(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) error }</code> </pre> <br><p>  Weil  Der Kontext ist eine Schnittstelle, in bestimmten Kettencodes kann er erweitert werden. </p><br><h2 id="funkcii-promezhutochnoy-obrabotki-middleware">  Middleware-Funktionen </h2><br><p>  Funktionen der Zwischenverarbeitung (Middleware) werden vor dem Aufruf des Handlers der Codemethode aufgerufen, haben Zugriff auf den Kontext des Aufrufs der Codemethode und auf die n√§chste Zwischenfunktion oder direkt auf den Handler der Methode des n√§chsten (next).  Middleware kann verwendet werden f√ºr: </p><br><ul><li>  Konvertieren von Eingabedaten (im folgenden Beispiel sind <em>p.String</em> und <em>p.Struct</em> Middleware) </li><li>  Einschr√§nkungen beim Zugriff auf die Funktion (z. B. <em>Eigent√ºmer. Nur</em> ) </li><li>  Abschluss des Anforderungsverarbeitungszyklus </li><li>  Aufruf der n√§chsten Zwischenverarbeitungsfunktion vom Stapel </li></ul><br><h2 id="konvertaciya-struktur-dannyh">  Datenstrukturkonvertierung </h2><br><p>  Die Kettencode-Schnittstelle nimmt an, dass der Eingabe ein Array von Byte-Arrays zugef√ºhrt wird, deren Elemente jeweils ein Attribut der Kettencode-Funktion sind.  Um zu verhindern, dass aus den Funktionsaufrufargumenten in jedem Handler der Verkettungsfunktion ein manuelles Daten-Marshalling vom Byte-Array zum Golang-Datentyp (int, string, struct, array) erfolgt, werden die erwarteten Datentypen zum Zeitpunkt der Erstellung der Routing-Regel im CCKit-Router festgelegt und der Typ wird automatisch konvertiert .  Im <em>folgenden</em> Beispiel erwartet die <em>carGet-</em> Funktion ein Argument vom Typ string, und die <em>carRegister-</em> Funktion <em>erwartet eine CarPayload-</em> Struktur.  Das Argument wird auch benannt, wodurch der Handler seinen Wert aus dem Kontext anhand des Namens abrufen kann.  Ein Beispiel f√ºr einen Handler wird unten angegeben.  Protobuf kann auch verwendet werden, um das Verkettungsdatenschema zu beschreiben. </p><br><pre> <code class="go hljs">r.Group(<span class="hljs-string"><span class="hljs-string">`car`</span></span>). Query(<span class="hljs-string"><span class="hljs-string">`List`</span></span>, cars). <span class="hljs-comment"><span class="hljs-comment">// chain code method name is carList Query(`Get`, car, p.String(`id`)). // chain code method name is carGet, method has 1 string argument "id" Invoke(`Register`, carRegister, p.Struct(`car`, &amp;CarPayload{}), // 1 struct argument owner.Only) // allow access to method only for chaincode owner (authority)</span></span></code> </pre> <br><p>  Die automatische Konvertierung (Marshalling) wird auch beim Schreiben von Daten in den Status eines intelligenten Vertrags und beim Erstellen von Ereignissen verwendet (der Golang-Typ wird in ein Array von Bytes serialisiert). </p><br><h2 id="sredstva-otladki-i-loggirovaniya-cheynkodov">  Tools zum Debuggen und Protokollieren von Kettencodes </h2><br><p>  Zum Debuggen des Codes k√∂nnen Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Debug-</a> Erweiterung verwenden, die intelligente Vertragsmethoden implementiert, mit denen Sie das Vorhandensein von Schl√ºsseln im Status des intelligenten Vertrags √ºberpr√ºfen und den Wert direkt nach Schl√ºssel lesen / √§ndern / l√∂schen k√∂nnen. </p><br><p>  F√ºr die Protokollierung im Kontext eines Aufrufs einer Chaincode-Funktion kann die Log () -Methode verwendet werden, die eine Instanz des in HLF verwendeten Loggers zur√ºckgibt. </p><br><h2 id="metody-upravleniya-dostupa-k-metodam-smart-kontrakta">  Intelligente Vertragsmethoden Zugriffskontrollmethoden </h2><br><p>  Im Rahmen der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eigent√ºmererweiterung</a> werden grundlegende Grundelemente zum Speichern von Informationen √ºber den Eigent√ºmer des instanziierten Kettencodes und Zugriffsmodifikatoren (Middleware) f√ºr intelligente Vertragsmethoden implementiert. </p><br><h2 id="sredstva-testirovaniya-smart-kontraktov">  Intelligente Tools zum Testen von Vertr√§gen </h2><br><p>  Das Bereitstellen des Blockchain-Netzwerks, das Installieren und Initialisieren von Kettencodes ist eine ziemlich komplizierte Einrichtung und ein langwieriger Vorgang.  Die Zeit f√ºr die Neuinstallation / Aktualisierung des Smart-Vertragscodes kann durch Verwendung des DEV-Modus des Smart-Vertrags verk√ºrzt werden. Die Aktualisierung des Codes ist jedoch weiterhin langsam. </p><br><p>  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shim-</a> Paket enth√§lt eine Implementierung von <a href="">MockStub</a> , die Aufrufe des Codes f√ºr den Code <a href="">umschlie√üt</a> und dessen Betrieb in der HLF-Blockchain-Umgebung simuliert.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mit MockStub erhalten</a> Sie fast sofort Testergebnisse und k√∂nnen die Entwicklungszeit verk√ºrzen.  Wenn wir das allgemeine Funktionsschema des Codes in HLF ber√ºcksichtigen, ersetzt MockStub im Wesentlichen das SDK, sodass Sie die Funktionen des Codes aufrufen k√∂nnen, und ahmt die Startumgebung des Codes auf dem Host nach. </p><br><p><img src="https://habrastorage.org/webt/3y/ed/z2/3yedz22nfldc41jmcnpjqyto3x0.png"></p><br><p>  Der MockStub aus der HLF-Lieferung enth√§lt die Implementierung fast aller Methoden der <em>shim.ChaincodeStubInterface-</em> Schnittstelle. In der aktuellen Version (1.3) fehlen jedoch einige wichtige Methoden wie GetCreator.  Weil  Kettencode kann diese Methode verwenden, um ein Zertifikat eines Transaktionserstellers f√ºr die Zugriffskontrolle zu erhalten. F√ºr eine maximale Abdeckung in Tests ist die F√§higkeit, einen Stub dieser Methode zu haben, wichtig. </p><br><p>  Die CCKit-Bibliothek enth√§lt eine erweiterte Version von <a href="">MockStub</a> , die die Implementierung der fehlenden Methoden sowie Methoden zum Arbeiten mit Ereigniskan√§len usw. enth√§lt. </p><br><h2 id="primer-cheynkoda">  Beispiel f√ºr einen Kettencode </h2><br><p>  Erstellen wir beispielsweise einen einfachen Kettencode zum Speichern von Informationen √ºber zugelassene Autos </p><br><h3 id="model-dannyh">  Datenmodell </h3><br><p>  Der Status des Codecodes ist der Schl√ºsselwertspeicher, in dem der Schl√ºssel eine Zeichenfolge und der Wert ein Array von Bytes ist.  Die grundlegende Praxis besteht darin, jonalisierte Golang-Datenstrukturinstanzen als Werte zu speichern.  Um mit Daten im Kettencode zu arbeiten, m√ºssen Sie nach dem Lesen aus dem Status das Byte-Array entfernen. </p><br><p>  Um √ºber das Auto aufzuzeichnen, verwenden wir die folgenden Attribute: </p><br><ul><li>  Kennung (Autonummer) </li><li>  Automodell </li><li>  Informationen zum Fahrzeughalter </li><li>  Informationen zur Daten√§nderungszeit </li></ul><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Car struct for chaincode state type Car struct { Id string Title string Owner string UpdatedAt time.Time // set by chaincode method }</span></span></code> </pre> <br><p>  Um Daten in den Kettencode zu √ºbertragen, erstellen Sie eine separate Struktur, die nur die Felder enth√§lt, die von au√üerhalb des Kettencodes stammen: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// CarPayload chaincode method argument type CarPayload struct { Id string Title string Owner string }</span></span></code> </pre> <br><h3 id="rabota-s-klyuchami">  Mit Schl√ºsseln arbeiten </h3><br><p>  Datensatzschl√ºssel in einem intelligenten Vertragsstatus sind eine Zeichenfolge.  Es unterst√ºtzt auch die M√∂glichkeit, zusammengesetzte Schl√ºssel zu erstellen, bei denen Teile des Schl√ºssels durch ein Null-Byte ( <em>U + 0000</em> ) getrennt sind. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCompositeKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(objectType </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, attributes []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span></code> </pre> <br><p>  In <em>CCKit k√∂nnen die</em> Funktionen zum Arbeiten mit dem Status eines intelligenten Vertrags automatisch Schl√ºssel f√ºr Datens√§tze erstellen, wenn die √ºbertragenen Strukturen die <em>Keyer-</em> Schnittstelle unterst√ºtzen </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Keyer interface for entity containing logic of its key creation type Keyer interface { Key() ([]string, error) }</span></span></code> </pre> <br><p>  Um ein Auto aufzuzeichnen, lautet die Schl√ºsselgenerierungsfunktion wie folgt: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CarEntity = <span class="hljs-string"><span class="hljs-string">`CAR`</span></span> <span class="hljs-comment"><span class="hljs-comment">// Key for car entry in chaincode state func (c Car) Key() ([]string, error) { return []string{CarEntity, c.Id}, nil }</span></span></code> </pre> <br><h3 id="deklaraciya-funkciy-smart-kontrakta-marshrutizaciya">  Intelligente Vertragsfunktionsdeklaration (Routing) </h3><br><p>  In der Konstruktormethode des Kettencodes k√∂nnen wir die Funktionen des Kettencodes und ihre Argumente definieren.  Der Autokennzeichen enth√§lt 3 Funktionen </p><br><ul><li>  carList gibt ein Array von Car-Strukturen zur√ºck </li><li>  carGet akzeptiert eine Fahrzeugkennung und gibt eine Fahrzeugstruktur zur√ºck </li><li>  carRegister akzeptiert eine serialisierte Instanz der CarPayload-Struktur und gibt das Registrierungsergebnis zur√ºck.  Der Zugriff auf diese Methode ist nur f√ºr den Eigent√ºmer des Kettencodes m√∂glich, der mithilfe der Middleware aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eigent√ºmerpaket</a> gespeichert wird </li></ul><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">New</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">router</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Chaincode</span></span></span></span> { r := router.New(<span class="hljs-string"><span class="hljs-string">`cars`</span></span>) <span class="hljs-comment"><span class="hljs-comment">// also initialized logger with "cars" prefix r.Init(invokeInit) r.Group(`car`). Query(`List`, queryCars). // chain code method name is carList Query(`Get`, queryCar, p.String(`id`)). // chain code method name is carGet, method has 1 string argument "id" Invoke(`Register`, invokeCarRegister, p.Struct(`car`, &amp;CarPayload{}), // 1 struct argument owner.Only) // allow access to method only for chaincode owner (authority) return router.NewChaincode(r) }</span></span></code> </pre> <br><p>  Im obigen Beispiel wird die <a href="">Chaincode-</a> Struktur verwendet, in der die Verarbeitung der Methoden <em>Init</em> und <em>Invoke</em> an den Router delegiert wird: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> router <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"github.com/hyperledger/fabric/core/chaincode/shim"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/hyperledger/fabric/protos/peer"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// Chaincode default chaincode implementation with router type Chaincode struct { router *Group } // NewChaincode new default chaincode implementation func NewChaincode(r *Group) *Chaincode { return &amp;Chaincode{r} } //======== Base methods ==================================== // // Init initializes chain code - sets chaincode "owner" func (cc *Chaincode) Init(stub shim.ChaincodeStubInterface) peer.Response { // delegate handling to router return cc.router.HandleInit(stub) } // Invoke - entry point for chain code invocations func (cc *Chaincode) Invoke(stub shim.ChaincodeStubInterface) peer.Response { // delegate handling to router return cc.router.Handle(stub) }</span></span></code> </pre> <br><p>  Die Verwendung eines Routers und der grundlegenden Chaincode-Struktur erm√∂glicht die Wiederverwendung von Handlerfunktionen.  Um beispielsweise Chaincode zu implementieren, ohne den Zugriff auf die <code>carRegister</code> Funktion zu <code>carRegister</code> , reicht <code>carRegister</code> aus, eine neue <a href="">Konstruktormethode</a> zu erstellen </p><br><h3 id="realizaciya-funkciy-smart-kontrakta">  Implementierung der Funktionen eines Smart Contract </h3><br><p>  Golang-Funktionen - <strong>Es</strong> gibt drei Arten von intelligenten Vertragsfunktionshandlern im <strong>CCKit-</strong> Router: </p><br><ul><li>  <em>StubHandlerFunc</em> - Die Standard-Handler-Schnittstelle akzeptiert <em>shim.ChaincodeStubInterface</em> und gibt die Standardantwort <em>Peer.Response zur√ºck</em> </li><li>  <em>ContextHandlerFunc</em> - nimmt einen Kontext und gibt <em>peer.Response zur√ºck</em> </li><li>  <em>HandlerFunc</em> - akzeptiert den Kontext, gibt die Schnittstelle und den Fehler zur√ºck.  Ein Byte-Array kann zur√ºckgegeben werden oder ein beliebiger Golang-Typ, der automatisch in ein Byte-Array konvertiert wird, basierend darauf, welche <em>Peer.Response</em> erstellt wird.  Der Antwortstatus <em>lautet</em> je nach √ºbergebenem Fehler <em>shim.Ok</em> oder <em>shim.Error</em> . </li></ul><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// StubHandlerFunc acts as raw chaincode invoke method, accepts stub and returns peer.Response StubHandlerFunc func(shim.ChaincodeStubInterface) peer.Response // ContextHandlerFunc use stub context as input parameter ContextHandlerFunc func(Context) peer.Response // HandlerFunc returns result as interface and error, this is converted to peer.Response via response.Create HandlerFunc func(Context) (interface{}, error)</span></span></code> </pre> <br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Argumente der im Router beschriebenen Kettencodefunktionen werden automatisch von Bytearrays in Zieldatentypen (eine Zeichenfolge oder eine CarPayload-Struktur) konvertiert. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Kettencodefunktion verwendet Statusmethoden, die das Extrahieren und Speichern von Daten in einen Kettencodestatus vereinfachen, indem automatisch Schl√ºssel erstellt und die √ºbertragenen Daten in Arrays konvertiert werden Byte (im Bytecode wird ein Array von Bytes geschrieben)</font></font></p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// car get info chaincode method handler func car(c router.Context) (interface{}, error) { return c.State().Get( // get state entry Key(c.ArgString(`id`)), // by composite key using CarKeyPrefix and car.Id &amp;Car{}) // and unmarshal from []byte to Car struct } // cars car list chaincode method handler func cars(c router.Context) (interface{}, error) { return c.State().List( CarKeyPrefix, // get list of state entries of type CarKeyPrefix &amp;Car{}) // unmarshal from []byte and append to []Car slice } // carRegister car register chaincode method handler func carRegister(c router.Context) (interface{}, error) { // arg name defined in router method definition p := c.Arg(`car`).(CarPayload) t, _ := c.Time() // tx time car := &amp;Car{ // data for chaincode state Id: p.Id, Title: p.Title, Owner: p.Owner, UpdatedAt: t, } return car, // peer.Response payload will be json serialized car data c.State().Insert( //put json serialized data to state Key(car.Id), // create composite key using CarKeyPrefix and car.Id car) }</span></span></code> </pre> <br><h3 id="testy-smart-kontrakta"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Intelligente Vertragstests </font></font></h3><br><p>    -       ‚Äî        ,     .      BDD ‚Äì Behavior Driven Development,          . </p><br><p>  , , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- Ethereum</a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ganache-cli</a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">truffle</a> .   golang -  Mockstub. </p><br><h3 id="primer-testa">   </h3><br><p>    ,     .     <a href=""></a> . </p><br><p>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ginkgo</a> ,     Go,      <code>go test</code> .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gomega</a>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">expect</a> ,    ,     . </p><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"testing"</span></span> . <span class="hljs-string"><span class="hljs-string">"github.com/onsi/ginkgo"</span></span> . <span class="hljs-string"><span class="hljs-string">"github.com/onsi/gomega"</span></span> examplecert <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/examples/cert"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/extensions/owner"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/identity"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/state"</span></span> testcc <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/testing"</span></span> expectcc <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/testing/expect"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestCars</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { RegisterFailHandler(Fail) RunSpecs(t, <span class="hljs-string"><span class="hljs-string">"Cars Suite"</span></span>) }</code> </pre> <br><p>      ,   <em>CarPayload</em> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Payloads = []*Car{{ Id: <span class="hljs-string"><span class="hljs-string">`A777MP77`</span></span>, Title: <span class="hljs-string"><span class="hljs-string">`VAZ`</span></span>, Owner: <span class="hljs-string"><span class="hljs-string">`victor`</span></span>, }, { Id: <span class="hljs-string"><span class="hljs-string">`O888OO77`</span></span>, Title: <span class="hljs-string"><span class="hljs-string">`YOMOBIL`</span></span>, Owner: <span class="hljs-string"><span class="hljs-string">`alexander`</span></span>, }, { Id: <span class="hljs-string"><span class="hljs-string">`O222OO177`</span></span>, Title: <span class="hljs-string"><span class="hljs-string">`Lambo`</span></span>, Owner: <span class="hljs-string"><span class="hljs-string">`hodl`</span></span>, }}</code> </pre> <br><p>     MockStub   Cars. </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//Create chaincode mock cc := testcc.NewMockStub(`cars`, New())</span></span></code> </pre> <br><p>  Weil   cars      ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> . </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// load actor certificates actors, err := identity.ActorsFromPemFile(`SOME_MSP`, map[string]string{ `authority`: `s7techlab.pem`, `someone`: `victor-nosov.pem`}, examplecert.Content)</span></span></code> </pre> <br><p>   <em>BeforeSuite</em>    <em>Car</em>      <em>authority</em>     <em>Init</em>    .  ,    <em>Cars</em>   Init       <em>Init</em> ,    . </p><br><pre> <code class="go hljs">BeforeSuite(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// init chaincode expectcc.ResponseOk(cc.From(actors[`authority`]).Init()) // init chaincode from authority })</span></span></code> </pre> <br><p>          . ,          <em>CarRegister</em> ,              . </p><br><pre> <code class="go hljs">It(<span class="hljs-string"><span class="hljs-string">"Allow authority to add information about car"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//invoke chaincode method from authority actor expectcc.ResponseOk(cc.From(actors[`authority`]).Invoke(`carRegister`, Payloads[0])) }) It("Disallow non authority to add information about car", func() { //invoke chaincode method from non authority actor expectcc.ResponseError( cc.From(actors[`someone`]).Invoke(`carRegister`, Payloads[0]), owner.ErrOwnerOnly) // expect "only owner" error })</span></span></code> </pre> <br><p>             : </p><br><pre> <code class="go hljs">It(<span class="hljs-string"><span class="hljs-string">"Disallow authority to add duplicate information about car"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { expectcc.ResponseError( cc.From(actors[<span class="hljs-string"><span class="hljs-string">`authority`</span></span>]).Invoke(<span class="hljs-string"><span class="hljs-string">`carRegister`</span></span>, Payloads[<span class="hljs-number"><span class="hljs-number">0</span></span>]), state.ErrKeyAlreadyExists) <span class="hljs-comment"><span class="hljs-comment">//expect car id already exists })</span></span></code> </pre> <br><h1 id="zaklyuchenie">  Fazit </h1><br><p> - HLF        Go, Java, JavaScript, ,    , -  (Solidity)     /   -.      /       . </p><br><p>    HLF  ,  ,      (     .).  Hypeledger Fabric        , ..     . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426705/">https://habr.com/ru/post/de426705/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426695/index.html">Bildverarbeitungskameras f√ºr Enthusiasten. Wie verwende ich die Kamera f√ºr die Offline-Navigation?</a></li>
<li><a href="../de426697/index.html">Arbeiten mit LibUsb-Ger√§ten unter Android</a></li>
<li><a href="../de426699/index.html">Python-Test mit Pytest. Einfach, schnell, effizient und skalierbar. Vorwort und Einf√ºhrung</a></li>
<li><a href="../de426701/index.html">Flattern - ein neuer Blick auf die plattform√ºbergreifende Entwicklung</a></li>
<li><a href="../de426703/index.html">Was war am DataVizDay in Minsk interessant?</a></li>
<li><a href="../de426707/index.html">Genehmigungssystem. Wie wir das Fahrrad erfunden haben</a></li>
<li><a href="../de426709/index.html">JavaScript-Timer: alles was Sie wissen m√ºssen</a></li>
<li><a href="../de426713/index.html">Intel Xeon W-3175X: 28 Kerne f√ºr zu Hause</a></li>
<li><a href="../de426717/index.html">Die Illusion der T√§uschung: Eine visuelle optische T√§uschung basierend auf Retro-Prognosen</a></li>
<li><a href="../de426719/index.html">Hackathon √ºber Data Science in SIBUR: wie es war</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>