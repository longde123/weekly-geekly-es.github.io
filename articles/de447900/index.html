<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍋 🌫️ 🍝 Schließen Sie ADL-Kontakte 👩🏽‍🚒 📥 🦋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wie schreibe ich deinen Namen für immer in die Geschichte? Der erste, der zum Mond fliegt? Der erste, der einen fremden Geist trifft? Wir haben einen ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schließen Sie ADL-Kontakte</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/447900/"><p><img src="https://habrastorage.org/webt/zb/i1/7h/zbi17hhfyu9_oqqmwgpzijon0d8.jpeg"></p><br><p>  Wie schreibe ich deinen Namen für immer in die Geschichte?  Der erste, der zum Mond fliegt?  Der erste, der einen fremden Geist trifft?  Wir haben einen einfacheren Weg - Sie können sich in den C ++ - Sprachstandard einfügen. </p><br><p>  Eric Nibler, Autor von C ++ Ranges, liefert ein gutes Beispiel.  „Denk dran.  Der 19. Februar 2019 ist der Tag, an dem der Begriff „Nibloid“ beim WG21-Treffen zum ersten Mal gesprochen wurde “, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schrieb er</a> auf Twitter. </p><br><p>  Wenn Sie zu CppReference gehen, finden Sie dort im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abschnitt cpp / algorithm / Bereichscpp / Algorithmus / Bereiche</a> viele Referenzen (niebloid).  Zu diesem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zweck</a> wurde sogar eine separate <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dsc_niebloid-</a> Wiki-Vorlage erstellt. </p><br><p>  Leider habe ich keinen offiziellen vollständigen Artikel zu diesem Thema gefunden und beschlossen, meinen eigenen zu schreiben.  Dies ist eine kleine, aber faszinierende Reise in die Abgründe der architektonischen Astronautik, auf der wir in den Abgrund des ADL-Wahnsinns eintauchen und Nibloide kennenlernen können. </p><br><p>  Wichtig: Ich bin kein echter Schweißer, sondern ein Javist, der manchmal Fehler im C ++ - Code nach Bedarf korrigiert.  Wenn Sie sich etwas Zeit nehmen, um Denkfehler zu finden, wäre das schön.  "Hilf Dasha, dem Reisenden, etwas Vernünftiges zu sammeln." </p><a name="habracut"></a><br><h2 id="lookup">  Nachschlagen </h2><br><p>  Zuerst müssen Sie sich für die Bedingungen entscheiden.  Dies sind bekannte Dinge, aber „das Explizite ist besser als das Implizite“, daher werden wir sie separat diskutieren.  Ich verwende keine echte russischsprachige Terminologie, sondern Englisch.  Dies ist notwendig, da sogar das Wort "Einschränkung" im Kontext dieses Artikels mit mindestens drei englischen Versionen verknüpft werden kann, deren Unterschied für das Verständnis wichtig ist. </p><br><p>  In C ++ gibt es beispielsweise das Konzept einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Namenssuche</a> oder mit anderen Worten eine Suche: Wenn ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Name</a> in einem Programm gefunden wird, wird er während der Kompilierung mit seiner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Deklaration</a> kompiliert. </p><br><p> Eine Suche kann <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">qualifiziert werden</a> (wenn der Name rechts vom Berechtigungsoperator des Bereichs steht <code>::</code> :) und in anderen Fällen nicht qualifiziert sein.  Wenn die Suche qualifiziert ist, umgehen wir die entsprechenden Mitglieder der Klasse, des Namespace oder der Aufzählung.  Man könnte dies die "vollständige" Version des Datensatzes nennen (wie es in der Übersetzung von Straustrup zu tun scheint), aber es ist besser, die ursprüngliche Schreibweise zu belassen, da dies auf eine ganz bestimmte Art von Vollständigkeit verweist. </p><br><h2 id="adl">  ADL </h2><br><p>  Wenn die Suche nicht qualifiziert ist, müssen wir genau wissen, wo nach dem Namen gesucht werden muss.  Und hier ist eine Besonderheit namens ADL enthalten: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">argumentabhängige Suche</a> oder auch die Suche nach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Koenig</a> (derjenige, der den Begriff „Anti-Pattern“ geprägt hat, der im Lichte des folgenden Textes etwas symbolisch ist).  Nicolai Josuttis beschreibt es in seinem Buch „Die C ++ - Standardbibliothek: Ein Tutorial und eine Referenz“ wie folgt: „Der Punkt ist, dass Sie den Namespace der Funktion nicht qualifizieren müssen, wenn mindestens einer der Argumenttypen im Namespace dieser Funktion definiert ist.“ </p><br><p>  Wie soll es aussehen? </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; int main() { //  . //   , operator&lt;&lt;    ,  ADL , //    std    std::operator&lt;&lt;(std::ostream&amp;, const char*) std::cout &lt;&lt; "Test\n"; //    .      -     . operator&lt;&lt;(std::cout, "Test\n"); // same, using function call notation //    : // Error: 'endl' is not declared in this namespace. //      endl(),  ADL  . std::cout &lt;&lt; endl; //  . //    ,       ADL. //     std,   endl      std. endl(std::cout); //    : // Error: 'endl' is not declared in this namespace. //  ,  - (endl) -     . (endl)(std::cout); }</span></span></span></span></code> </pre> <br><h2 id="spuskaemsya-v-ad-s-adl">  Komm mit ADL zur Hölle </h2><br><p>  Es würde einfach erscheinen.  Oder nicht?  Erstens arbeitet ADL je nach Art des Arguments auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">neun verschiedene Arten</a> , um mit einem Besen zu töten. </p><br><p>  Stellen Sie sich zweitens rein praktisch vor, wir hätten eine Art Swap-Funktion.  Es stellt sich heraus, dass <code>std::swap(obj1,obj2);</code>  und <code>using std::swap; swap(obj1, obj2);</code> <code>using std::swap; swap(obj1, obj2);</code>  kann sich ganz anders verhalten.  Wenn ADL aktiviert ist, wird aus mehreren verschiedenen Swaps der gewünschte bereits anhand der Namespaces der Argumente ausgewählt!  Je nach Sichtweise kann diese Redewendung sowohl als positives als auch als negatives Beispiel angesehen werden :-) </p><br><p>  Wenn es Ihnen nicht ausreicht, können Sie das Brennholz in den Ofen des Hutes fallen lassen.  Dies wurde kürzlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von Arthur O'Dwyer</a> gut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">geschrieben</a> .  Ich hoffe, er bestraft mich nicht dafür, dass ich sein Beispiel benutze. </p><br><p>  Stellen Sie sich vor, Sie haben ein Programm dieser Art: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; namespace A { struct A {}; void call(void (*f)()) { f(); } } void f() { puts("Hello world"); } int main() { call(f); }</span></span></span></span></code> </pre> <br><p>  Natürlich wird es nicht mit einem Fehler kompiliert: </p><br><pre> <code class="plaintext hljs">error: use of undeclared identifier 'call'; did you mean 'A::call'? call(f); ^~~~ A::call</code> </pre> <br><p>  Wenn Sie dort jedoch eine <strong>völlig unbenutzte Überladung der</strong> Funktion <code>f</code> hinzufügen, funktioniert alles! </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; namespace A { struct A {}; void call(void (*f)()) { f(); } } void f() { puts("Hello world"); } void f(A::A); // UNUSED int main() { call(f); }</span></span></span></span></code> </pre> <br><p>  In Visual Studio wird es immer noch kaputt gehen, aber das ist ihr Schicksal, das nicht funktioniert. </p><br><p>  Wie kam es dazu?  Lassen Sie uns <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in den Standard</a> eintauchen (ohne Übersetzung, da eine solche Übersetzung ein außergewöhnlich monströses Durcheinander von Schlagworten wäre): </p><br><blockquote>  Wenn das Argument der Name oder die Adresse eines Satzes überladener Funktionen und / oder Funktionsvorlagen ist, sind seine zugeordneten Entitäten und Namespaces die Vereinigung derjenigen, die jedem der Mitglieder des Satzes zugeordnet sind, d. H. Die Entitäten und Namespaces, die seinem Parameter zugeordnet sind Typen und Rückgabetyp.  [...] Wenn der oben genannte Satz überladener Funktionen mit einer Vorlagen-ID benannt wird, enthalten die zugehörigen Entitäten und Namespaces auch diejenigen des Typs Vorlagenargumente und der Vorlagenvorlagenargumente. </blockquote><p>  Nehmen Sie nun einen Code wie folgt: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; namespace B { struct B {}; void call(void (*f)()) { f(); } } template&lt;class T&gt; void f() { puts("Hello world"); } int main() { call(f&lt;B::B&gt;); }</span></span></span></span></code> </pre> <br><p>  In beiden Fällen werden Argumente erhalten, die keinen Typ haben.  <code>f</code> und <code>f&lt;B::B&gt;</code> sind die Namen der Mengen überladener Funktionen (aus der obigen Definition), und eine solche Menge hat keinen Typ.  Um eine Überlastung in eine einzelne Funktion zu reduzieren, müssen Sie wissen, welcher Typ von Funktionszeiger für die beste Aufrufüberlastung am besten geeignet ist.  Sie müssen also eine Reihe von Kandidaten für einen <code>call</code> sammeln, was bedeutet, dass Sie einen Suchanruf ausführen müssen.  Und dafür startet ADL! </p><br><p>  Aber normalerweise sollten wir für ADL die Arten von Argumenten kennen!  Und hier brechen Clang, ICC und MSVC fälschlicherweise wie folgt (GCC jedoch nicht): </p><br><pre> <code class="cpp hljs">[build] ..\..\main.cpp(<span class="hljs-number"><span class="hljs-number">15</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>): error: use of undeclared identifier <span class="hljs-string"><span class="hljs-string">'call'</span></span>; did you mean <span class="hljs-string"><span class="hljs-string">'B::call'</span></span>? [build] call(f&lt;B::B&gt;); [build] ^~~~ [build] B::call [build] ..\..\main.cpp(<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>): note: <span class="hljs-string"><span class="hljs-string">'B::call'</span></span> declared here [build] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*f)())</span></span></span><span class="hljs-function"> </span></span>{ [build] ^</code> </pre> <br><p>  Sogar die Entwickler von Compilern mit ADL haben eine etwas angespannte Beziehung. </p><br><p>  Scheint ADL immer noch eine gute Idee zu sein?  Einerseits müssen wir einen solchen sklavischen Code nicht mehr höflich schreiben: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>, <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>), <span class="hljs-string"><span class="hljs-string">"\n"</span></span>);</code> </pre> <br><p>  Auf der anderen Seite haben wir der Kürze halber die Tatsache gehandelt, dass es jetzt ein System gibt, das auf völlig unmenschliche Weise funktioniert.  Eine tragische und majestätische Geschichte darüber, wie die Leichtigkeit, Halloworld zu schreiben, die gesamte Sprache über Jahrzehnte hinweg beeinflussen kann. </p><br><h2 id="renzhi-i-koncepty">  Bereiche und Konzepte </h2><br><p>  Wenn Sie die Beschreibung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Nibler Rangers-Bibliothek</a> öffnen, werden Sie bereits vor der Erwähnung von Nibloiden auf viele andere Marker stoßen, die als <strong>(Konzept) bezeichnet werden</strong> .  Dies ist bereits ein hübsches Zeug, aber nur für den Fall (für Alte und Javisten) werde ich Sie daran erinnern, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">was es ist</a> . </p><br><p>  Konzepte werden als benannte Sätze von Einschränkungen bezeichnet, die für Vorlagenargumente gelten, um die besten Funktionsüberladungen und die am besten geeigneten Vorlagenspezialisierungen auszuwählen. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; concept <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasStringFunc = requires(T a) { { to_string(a) } -&gt; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HasStringFunc a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; to_string(a) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br><p>  Hier haben wir eine Einschränkung auferlegt, dass das Argument eine <code>to_string</code> Funktion haben muss, die einen <code>to_string</code> zurückgibt.  Wenn wir versuchen, ein Spiel in den <code>print</code> , das nicht unter die Einschränkungen fällt, wird dieser Code einfach nicht kompiliert. </p><br><p>  Dies vereinfacht den Code erheblich.  Sehen Sie sich beispielsweise an, wie Nibler in range <a href="">-v3 sortiert hat</a> , was in C ++ vom 14.11.17 funktioniert.  Es gibt einen wunderbaren Code wie diesen: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCEPT_PP_CAT_(X, Y) X ## Y #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCEPT_PP_CAT(X, Y) CONCEPT_PP_CAT_(X, Y) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/// \addtogroup group-concepts /// @{ #define CONCEPT_REQUIRES_(...) \ int CONCEPT_PP_CAT(_concept_requires_, __LINE__) = 42, \ typename std::enable_if&lt; \ (CONCEPT_PP_CAT(_concept_requires_, __LINE__) == 43) || (__VA_ARGS__), \ int \ &gt;::type = 0 \ /**/</span></span></span></span></code> </pre> <br><p>  Damit Sie später Folgendes tun können: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sortable_</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Rng, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> C = ordered_less, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P = ident, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> I = <span class="hljs-keyword"><span class="hljs-keyword">iterator_t</span></span>&lt;Rng&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> requires_() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>( concepts::valid_expr( concepts::model_of&lt;concepts::ForwardRange, Rng&gt;(), concepts::is_true(ranges::Sortable&lt;I, C, P&gt;()) )); }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Sortable = concepts::models&lt;Sortable_, Rng, C, P&gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Rng, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> C = ordered_less, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P = ident, CONCEPT_REQUIRES_(!Sortable&lt;Rng, C, P&gt;())&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>()(Rng &amp;&amp;, C &amp;&amp; = C{}, P &amp;&amp; = P{}) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { ...</code> </pre> <br><p>  Ich hoffe, Sie wollten das alles schon sehen und nur vorbereitete Konzepte in einem neuen Compiler verwenden. </p><br><h2 id="tochki-kastomizacii">  Anpassungspunkte </h2><br><p>  Das nächste interessante Element im Standard ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">customization.point.object</a> .  Sie werden aktiv in der Nibler Ranges-Bibliothek verwendet. </p><br><p>  Der Anpassungspunkt ist eine Funktion, die von der Standardbibliothek verwendet wird, damit er für Benutzertypen im Namespace des Benutzers überladen werden kann. Diese Überladungen können mithilfe von ADL gefunden werden. </p><br><p>  Anpassungspunkte werden unter <code>cust</code> der folgenden Architekturprinzipien <code>cust</code> ( <code>cust</code> ist der Name für einen imaginären Anpassungspunkt): </p><br><ul><li>  Der Code, der <code>cust</code> entweder in der qualifizierten Form <code>std::cust(a)</code> oder in nicht qualifizierter Form geschrieben: <code>using std::cust; cust(a);</code> <code>using std::cust; cust(a);</code>  .  Beide Einträge müssen sich identisch verhalten.  Insbesondere müssen sie Benutzerüberladungen im Namespace finden, der den Argumenten zugeordnet ist. </li><li>  Code, der <code>cust</code> in Form eines <code>std::cust; cust(a);</code> <code>std::cust; cust(a);</code>  sollte nicht in der Lage sein, die Beschränkungen für <code>std::cust</code> zu umgehen. </li><li>  Benutzerdefinierte Punktaufrufe sollten auf jedem relativ modernen Compiler effizient und optimal funktionieren. </li><li>  Die Entscheidung sollte keine neuen Verstöße gegen die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Single Definition Rule (ODR) hervorrufen</a> . </li></ul><br><p>  Um zu verstehen, was es ist, können Sie sich den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">N4381 ansehen</a> .  Auf den ersten Blick scheinen sie eine Möglichkeit zu sein, eigene Versionen von <code>begin</code> , <code>swap</code> , <code>data</code> und dergleichen zu schreiben, und die Standardbibliothek nimmt sie mit ADL auf. </p><br><p>  Die Frage ist, wie sich dies von der alten Praxis unterscheidet, wenn der Benutzer eine Überladung für einige <code>begin</code> für seinen eigenen Typ und Namespace beginnen.  Und warum sind sie überhaupt Objekte? </p><br><p>  Tatsächlich sind dies Instanzen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionsobjekten</a> im <code>std</code> .  Ihr Zweck besteht darin, zuerst Typprüfungen (als Konzepte konzipiert) für alle Argumente in einer Reihe durchzuführen und dann den Aufruf an die richtige Funktion im <code>std</code> oder ihn in ADL zum Verkauf anzubieten. </p><br><p>  In der Tat ist dies nicht die Art von Dingen, die Sie in einem regulären Nicht-Bibliotheksprogramm verwenden würden.  Dies ist eine Funktion der Standardbibliothek, mit der Sie an zukünftigen Erweiterungspunkten eine Konzeptprüfung hinzufügen können, die wiederum dazu führt, dass schönere und verständlichere Fehler angezeigt werden, wenn Sie etwas in den Vorlagen durcheinander gebracht haben. </p><br><p>  Der derzeitige Ansatz für Anpassungspunkte weist einige Probleme auf.  Erstens ist es sehr einfach, alles zu zerbrechen.  Stellen Sie sich diesen Code vor: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t2</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap; swap(t1, t2); }</code> </pre> <br><p>  Wenn wir versehentlich einen qualifizierten Aufruf von <code>std::swap(t1, t2)</code> tätigen <code>std::swap(t1, t2)</code> wird unsere eigene Version von <code>swap</code> niemals gestartet, egal was wir dort ablegen.  Noch wichtiger ist jedoch, dass es keine Möglichkeit gibt, Konzeptprüfungen zentral an solche benutzerdefinierten Funktionsimplementierungen anzuhängen.  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">N4381</a> schreiben sie: </p><br><p>  „Stellen Sie sich vor, dass <code>std::begin</code> eines Tages in Zukunft erfordern wird, dass sein Argument als <code>Range</code> Konzept modelliert wird.  Das Hinzufügen einer solchen Einschränkung hat einfach keine Auswirkung auf den Code, der idiomatisch mit <code>std::begin</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::begin; begin(a);</code> </pre> <br><p>  Wenn der Startaufruf an die vom Benutzer erstellte überladene Version gesendet wird, werden die Einschränkungen für <code>std::begin</code> einfach ignoriert. “ </p><br><p>  Die im Propozal beschriebene Lösung löst beide Probleme. Dazu verwenden wir den Ansatz dieser spekulativen Implementierung von <code>std::begin</code> (Sie können sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Godbolt ansehen</a> ): </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;utility&gt; namespace my_std { namespace detail { struct begin_fn { /*   ,         begin(arg)  arg.begin().  -   . */ template &lt;class T&gt; auto operator()(T&amp;&amp; arg) const { return impl(arg, 1L); } template &lt;class T&gt; auto impl(T&amp;&amp; arg, int) const requires requires { begin(std::declval&lt;T&gt;()); } { return begin(arg); } // ADL template &lt;class T&gt; auto impl(T&amp;&amp; arg, long) const requires requires { std::declval&lt;T&gt;().begin(); } { return arg.begin(); } // ... }; } //        inline constexpr detail::begin_fn begin{}; }</span></span></span></span></code> </pre> <br><p>  Ein qualifizierter Aufruf von <code>my_std::begin(someObject)</code> geht immer über <code>my_std::detail::begin_fn</code> - und das ist gut so.  Was passiert mit einem unqualifizierten Anruf?  Lesen wir noch einmal unsere Zeitung: </p><br><p>  „Wenn begin unmittelbar nach dem Erscheinen von <code>my_std::begin</code> innerhalb des Bereichs ohne <code>my_std::begin</code> , ändert sich die Situation etwas.  In der ersten Phase der Suche wird der Name <code>begin</code> in das globale Objekt <code>my_std::begin</code> .  Da die Suche ein Objekt und keine Funktion gefunden hat, wird die zweite Phase der Suche nicht ausgeführt.  Mit anderen Worten, wenn <code>my_std::begin</code> ein Objekt ist, dann verwenden Sie die Konstruktion <code>my_std::detail::begin_fn begin; begin(a);</code> <code>my_std::detail::begin_fn begin; begin(a);</code>  einfach äquivalent zu <code>std::begin(a);</code>  "Und wie wir gesehen haben, startet dies benutzerdefinierte ADL." </p><br><p>  Aus diesem Grund kann die Konzeptüberprüfung in einem Funktionsobjekt im <code>std</code> bevor ADL die vom Benutzer bereitgestellte Funktion aufruft.  Es gibt keine Möglichkeit, dieses Verhalten auszutricksen. </p><br><h2 id="kak-kastomiziruyut-tochki-kastomizacii">  Wie werden Anpassungspunkte angepasst? </h2><br><p>  Tatsächlich ist „Anpassungspunktobjekt“ (CPO) kein guter Name.  Aus dem Namen ist nicht ersichtlich, wie sie sich ausdehnen, welche Mechanismen sich unter der Haube befinden, welche Funktionen sie bevorzugen ... </p><br><p>  Was uns zum Begriff "nibloid" führt.  Ein Nibloid ist ein solcher CPO, der die Funktion X aufruft, wenn sie in der Klasse definiert ist, andernfalls die Funktion X aufruft, wenn eine geeignete freie Funktion vorhanden ist, andernfalls versucht er, einen Fallback der Funktion X auszuführen. </p><br><p>  So versuchen beispielsweise die nibloiden <code>ranges::swap</code> beim Aufrufen von <code>ranges::swap(a, b)</code> zuerst, <code>a.swap(b)</code> .  Wenn es keine solche Methode gibt, wird versucht, <code>swap(a, b)</code> mit ADL aufzurufen.  Wenn dies nicht funktioniert, versuchen Sie <code>auto tmp = std::move(a); a = std::move(b); b = std::move(tmp)</code> <code>auto tmp = std::move(a); a = std::move(b); b = std::move(tmp)</code>  <code>auto tmp = std::move(a); a = std::move(b); b = std::move(tmp)</code> . </p><br><h1 id="itogi">  Zusammenfassung </h1><br><p>  Wie Matt auf Twitter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">scherzte</a> , schlug <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dave</a> aus Gründen der Konsistenz einmal vor, funktionale Objekte mit ADL "funktionieren" zu lassen, genau wie reguläre Funktionen.  Die Ironie ist, dass ihre Fähigkeit, ADL zu deaktivieren und für ihn unsichtbar zu sein, nun zu ihren Hauptvorteilen geworden ist. </p><br><p>  Dieser gesamte Artikel war eine Vorbereitung dafür. </p><br><p>  " <i><b>Ich habe einfach alles verstanden, das ist alles. Wirst du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zuhören</a> ?</b></i> </p><br><p>  <i><b>Haben Sie jemals etwas angeschaut, und es schien verrückt und dann in einem anderen Licht auf</b></i> <i><b><br></b></i>  <i><b>verrückte Dinge, die sie normal sehen?</b></i> </p><br><p><img src="https://habrastorage.org/webt/-f/us/rh/-fusrhpdssngql8nlfx2qn0gdd8.jpeg"></p><br><p>  <i><b>Fürchte dich nicht.</b></i>  <i><b>Fürchte dich nicht.</b></i>  <i><b>Ich fühle mich im Herzen so gut.</b></i>  <i><b>Alles wird gut.</b></i>  <i><b>Ich habe mich seit vielen Jahren nicht mehr so ​​gut gefühlt.</b></i>  <i><b>Alles wird gut.</b></i> </p><br><p><img src="https://habrastorage.org/webt/pe/ca/az/pecaazhixdkr6dsdxv67ewlvte8.jpeg"></p><br><blockquote>  Minute der Werbung.  Bereits in <b>dieser Woche</b> , vom 19. bis 20. April, findet die C ++ Russia 2019 statt - eine Konferenz mit Hardcore-Präsentationen sowohl zur Sprache selbst als auch zu praktischen Themen wie Multithreading und Performance.  Die Konferenz wird übrigens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von</a> Nicolai Josuttis eröffnet, dem Autor der im Artikel erwähnten C ++ - Standardbibliothek: Ein Tutorial und eine Referenz.  Sie können sich mit dem Programm vertraut machen und Tickets <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf der offiziellen Website</a> kaufen.  Es bleibt nur noch sehr wenig Zeit, dies ist die letzte Chance. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de447900/">https://habr.com/ru/post/de447900/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de447890/index.html">Gott sei Dank bin ich kein Manager</a></li>
<li><a href="../de447892/index.html">Zwei neue PHDays-Wettbewerbe: IDS-Bypass und Factory-Hacking</a></li>
<li><a href="../de447894/index.html">MODX Digest # 3 (25. März - 8. April 2019)</a></li>
<li><a href="../de447896/index.html">Bilder aus groben Skizzen: Genau so funktioniert das neuronale Netzwerk NVIDIA GauGAN</a></li>
<li><a href="../de447898/index.html">Gut genährte Philosophen oder wettbewerbsfähige .NET-Programmierung</a></li>
<li><a href="../de447902/index.html">GitHub hat das Repository-Dienstprogramm-Repository und das gesamte Erstellerkonto vollständig "gelöscht"</a></li>
<li><a href="../de447904/index.html">Experten von Positive Technologies identifizieren Versuche, kritische Schwachstellen in Confluence massenhaft auszunutzen</a></li>
<li><a href="../de447906/index.html">Aktuelle Innovationen: Was erwartet Sie 2019 vom Rechenzentrumsmarkt?</a></li>
<li><a href="../de447908/index.html">Es sollten zwei Möglichkeiten funktionieren, Belohnungen für Werbung in Handyspielen oder Robotern zu sammeln</a></li>
<li><a href="../de447910/index.html">Das "Öl" der modernen Wirtschaft und der Krieg um das Personal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>