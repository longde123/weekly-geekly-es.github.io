<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçã üå´Ô∏è üçù Schlie√üen Sie ADL-Kontakte üë©üèΩ‚Äçüöí üì• ü¶ã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wie schreibe ich deinen Namen f√ºr immer in die Geschichte? Der erste, der zum Mond fliegt? Der erste, der einen fremden Geist trifft? Wir haben einen ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schlie√üen Sie ADL-Kontakte</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/447900/"><p><img src="https://habrastorage.org/webt/zb/i1/7h/zbi17hhfyu9_oqqmwgpzijon0d8.jpeg"></p><br><p>  Wie schreibe ich deinen Namen f√ºr immer in die Geschichte?  Der erste, der zum Mond fliegt?  Der erste, der einen fremden Geist trifft?  Wir haben einen einfacheren Weg - Sie k√∂nnen sich in den C ++ - Sprachstandard einf√ºgen. </p><br><p>  Eric Nibler, Autor von C ++ Ranges, liefert ein gutes Beispiel.  ‚ÄûDenk dran.  Der 19. Februar 2019 ist der Tag, an dem der Begriff ‚ÄûNibloid‚Äú beim WG21-Treffen zum ersten Mal gesprochen wurde ‚Äú, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schrieb er</a> auf Twitter. </p><br><p>  Wenn Sie zu CppReference gehen, finden Sie dort im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abschnitt cpp / algorithm / Bereichscpp / Algorithmus / Bereiche</a> viele Referenzen (niebloid).  Zu diesem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zweck</a> wurde sogar eine separate <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dsc_niebloid-</a> Wiki-Vorlage erstellt. </p><br><p>  Leider habe ich keinen offiziellen vollst√§ndigen Artikel zu diesem Thema gefunden und beschlossen, meinen eigenen zu schreiben.  Dies ist eine kleine, aber faszinierende Reise in die Abgr√ºnde der architektonischen Astronautik, auf der wir in den Abgrund des ADL-Wahnsinns eintauchen und Nibloide kennenlernen k√∂nnen. </p><br><p>  Wichtig: Ich bin kein echter Schwei√üer, sondern ein Javist, der manchmal Fehler im C ++ - Code nach Bedarf korrigiert.  Wenn Sie sich etwas Zeit nehmen, um Denkfehler zu finden, w√§re das sch√∂n.  "Hilf Dasha, dem Reisenden, etwas Vern√ºnftiges zu sammeln." </p><a name="habracut"></a><br><h2 id="lookup">  Nachschlagen </h2><br><p>  Zuerst m√ºssen Sie sich f√ºr die Bedingungen entscheiden.  Dies sind bekannte Dinge, aber ‚Äûdas Explizite ist besser als das Implizite‚Äú, daher werden wir sie separat diskutieren.  Ich verwende keine echte russischsprachige Terminologie, sondern Englisch.  Dies ist notwendig, da sogar das Wort "Einschr√§nkung" im Kontext dieses Artikels mit mindestens drei englischen Versionen verkn√ºpft werden kann, deren Unterschied f√ºr das Verst√§ndnis wichtig ist. </p><br><p>  In C ++ gibt es beispielsweise das Konzept einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Namenssuche</a> oder mit anderen Worten eine Suche: Wenn ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Name</a> in einem Programm gefunden wird, wird er w√§hrend der Kompilierung mit seiner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Deklaration</a> kompiliert. </p><br><p> Eine Suche kann <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">qualifiziert werden</a> (wenn der Name rechts vom Berechtigungsoperator des Bereichs steht <code>::</code> :) und in anderen F√§llen nicht qualifiziert sein.  Wenn die Suche qualifiziert ist, umgehen wir die entsprechenden Mitglieder der Klasse, des Namespace oder der Aufz√§hlung.  Man k√∂nnte dies die "vollst√§ndige" Version des Datensatzes nennen (wie es in der √úbersetzung von Straustrup zu tun scheint), aber es ist besser, die urspr√ºngliche Schreibweise zu belassen, da dies auf eine ganz bestimmte Art von Vollst√§ndigkeit verweist. </p><br><h2 id="adl">  ADL </h2><br><p>  Wenn die Suche nicht qualifiziert ist, m√ºssen wir genau wissen, wo nach dem Namen gesucht werden muss.  Und hier ist eine Besonderheit namens ADL enthalten: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">argumentabh√§ngige Suche</a> oder auch die Suche nach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Koenig</a> (derjenige, der den Begriff ‚ÄûAnti-Pattern‚Äú gepr√§gt hat, der im Lichte des folgenden Textes etwas symbolisch ist).  Nicolai Josuttis beschreibt es in seinem Buch ‚ÄûDie C ++ - Standardbibliothek: Ein Tutorial und eine Referenz‚Äú wie folgt: ‚ÄûDer Punkt ist, dass Sie den Namespace der Funktion nicht qualifizieren m√ºssen, wenn mindestens einer der Argumenttypen im Namespace dieser Funktion definiert ist.‚Äú </p><br><p>  Wie soll es aussehen? </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; int main() { //  . //   , operator&lt;&lt;    ,  ADL , //    std    std::operator&lt;&lt;(std::ostream&amp;, const char*) std::cout &lt;&lt; "Test\n"; //    .      -     . operator&lt;&lt;(std::cout, "Test\n"); // same, using function call notation //    : // Error: 'endl' is not declared in this namespace. //      endl(),  ADL  . std::cout &lt;&lt; endl; //  . //    ,       ADL. //     std,   endl      std. endl(std::cout); //    : // Error: 'endl' is not declared in this namespace. //  ,  - (endl) -     . (endl)(std::cout); }</span></span></span></span></code> </pre> <br><h2 id="spuskaemsya-v-ad-s-adl">  Komm mit ADL zur H√∂lle </h2><br><p>  Es w√ºrde einfach erscheinen.  Oder nicht?  Erstens arbeitet ADL je nach Art des Arguments auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">neun verschiedene Arten</a> , um mit einem Besen zu t√∂ten. </p><br><p>  Stellen Sie sich zweitens rein praktisch vor, wir h√§tten eine Art Swap-Funktion.  Es stellt sich heraus, dass <code>std::swap(obj1,obj2);</code>  und <code>using std::swap; swap(obj1, obj2);</code> <code>using std::swap; swap(obj1, obj2);</code>  kann sich ganz anders verhalten.  Wenn ADL aktiviert ist, wird aus mehreren verschiedenen Swaps der gew√ºnschte bereits anhand der Namespaces der Argumente ausgew√§hlt!  Je nach Sichtweise kann diese Redewendung sowohl als positives als auch als negatives Beispiel angesehen werden :-) </p><br><p>  Wenn es Ihnen nicht ausreicht, k√∂nnen Sie das Brennholz in den Ofen des Hutes fallen lassen.  Dies wurde k√ºrzlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von Arthur O'Dwyer</a> gut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">geschrieben</a> .  Ich hoffe, er bestraft mich nicht daf√ºr, dass ich sein Beispiel benutze. </p><br><p>  Stellen Sie sich vor, Sie haben ein Programm dieser Art: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; namespace A { struct A {}; void call(void (*f)()) { f(); } } void f() { puts("Hello world"); } int main() { call(f); }</span></span></span></span></code> </pre> <br><p>  Nat√ºrlich wird es nicht mit einem Fehler kompiliert: </p><br><pre> <code class="plaintext hljs">error: use of undeclared identifier 'call'; did you mean 'A::call'? call(f); ^~~~ A::call</code> </pre> <br><p>  Wenn Sie dort jedoch eine <strong>v√∂llig unbenutzte √úberladung der</strong> Funktion <code>f</code> hinzuf√ºgen, funktioniert alles! </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; namespace A { struct A {}; void call(void (*f)()) { f(); } } void f() { puts("Hello world"); } void f(A::A); // UNUSED int main() { call(f); }</span></span></span></span></code> </pre> <br><p>  In Visual Studio wird es immer noch kaputt gehen, aber das ist ihr Schicksal, das nicht funktioniert. </p><br><p>  Wie kam es dazu?  Lassen Sie uns <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in den Standard</a> eintauchen (ohne √úbersetzung, da eine solche √úbersetzung ein au√üergew√∂hnlich monstr√∂ses Durcheinander von Schlagworten w√§re): </p><br><blockquote>  Wenn das Argument der Name oder die Adresse eines Satzes √ºberladener Funktionen und / oder Funktionsvorlagen ist, sind seine zugeordneten Entit√§ten und Namespaces die Vereinigung derjenigen, die jedem der Mitglieder des Satzes zugeordnet sind, d. H. Die Entit√§ten und Namespaces, die seinem Parameter zugeordnet sind Typen und R√ºckgabetyp.  [...] Wenn der oben genannte Satz √ºberladener Funktionen mit einer Vorlagen-ID benannt wird, enthalten die zugeh√∂rigen Entit√§ten und Namespaces auch diejenigen des Typs Vorlagenargumente und der Vorlagenvorlagenargumente. </blockquote><p>  Nehmen Sie nun einen Code wie folgt: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; namespace B { struct B {}; void call(void (*f)()) { f(); } } template&lt;class T&gt; void f() { puts("Hello world"); } int main() { call(f&lt;B::B&gt;); }</span></span></span></span></code> </pre> <br><p>  In beiden F√§llen werden Argumente erhalten, die keinen Typ haben.  <code>f</code> und <code>f&lt;B::B&gt;</code> sind die Namen der Mengen √ºberladener Funktionen (aus der obigen Definition), und eine solche Menge hat keinen Typ.  Um eine √úberlastung in eine einzelne Funktion zu reduzieren, m√ºssen Sie wissen, welcher Typ von Funktionszeiger f√ºr die beste Aufruf√ºberlastung am besten geeignet ist.  Sie m√ºssen also eine Reihe von Kandidaten f√ºr einen <code>call</code> sammeln, was bedeutet, dass Sie einen Suchanruf ausf√ºhren m√ºssen.  Und daf√ºr startet ADL! </p><br><p>  Aber normalerweise sollten wir f√ºr ADL die Arten von Argumenten kennen!  Und hier brechen Clang, ICC und MSVC f√§lschlicherweise wie folgt (GCC jedoch nicht): </p><br><pre> <code class="cpp hljs">[build] ..\..\main.cpp(<span class="hljs-number"><span class="hljs-number">15</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>): error: use of undeclared identifier <span class="hljs-string"><span class="hljs-string">'call'</span></span>; did you mean <span class="hljs-string"><span class="hljs-string">'B::call'</span></span>? [build] call(f&lt;B::B&gt;); [build] ^~~~ [build] B::call [build] ..\..\main.cpp(<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>): note: <span class="hljs-string"><span class="hljs-string">'B::call'</span></span> declared here [build] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*f)())</span></span></span><span class="hljs-function"> </span></span>{ [build] ^</code> </pre> <br><p>  Sogar die Entwickler von Compilern mit ADL haben eine etwas angespannte Beziehung. </p><br><p>  Scheint ADL immer noch eine gute Idee zu sein?  Einerseits m√ºssen wir einen solchen sklavischen Code nicht mehr h√∂flich schreiben: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>, <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>), <span class="hljs-string"><span class="hljs-string">"\n"</span></span>);</code> </pre> <br><p>  Auf der anderen Seite haben wir der K√ºrze halber die Tatsache gehandelt, dass es jetzt ein System gibt, das auf v√∂llig unmenschliche Weise funktioniert.  Eine tragische und majest√§tische Geschichte dar√ºber, wie die Leichtigkeit, Halloworld zu schreiben, die gesamte Sprache √ºber Jahrzehnte hinweg beeinflussen kann. </p><br><h2 id="renzhi-i-koncepty">  Bereiche und Konzepte </h2><br><p>  Wenn Sie die Beschreibung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Nibler Rangers-Bibliothek</a> √∂ffnen, werden Sie bereits vor der Erw√§hnung von Nibloiden auf viele andere Marker sto√üen, die als <strong>(Konzept) bezeichnet werden</strong> .  Dies ist bereits ein h√ºbsches Zeug, aber nur f√ºr den Fall (f√ºr Alte und Javisten) werde ich Sie daran erinnern, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">was es ist</a> . </p><br><p>  Konzepte werden als benannte S√§tze von Einschr√§nkungen bezeichnet, die f√ºr Vorlagenargumente gelten, um die besten Funktions√ºberladungen und die am besten geeigneten Vorlagenspezialisierungen auszuw√§hlen. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; concept <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasStringFunc = requires(T a) { { to_string(a) } -&gt; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HasStringFunc a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; to_string(a) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br><p>  Hier haben wir eine Einschr√§nkung auferlegt, dass das Argument eine <code>to_string</code> Funktion haben muss, die einen <code>to_string</code> zur√ºckgibt.  Wenn wir versuchen, ein Spiel in den <code>print</code> , das nicht unter die Einschr√§nkungen f√§llt, wird dieser Code einfach nicht kompiliert. </p><br><p>  Dies vereinfacht den Code erheblich.  Sehen Sie sich beispielsweise an, wie Nibler in range <a href="">-v3 sortiert hat</a> , was in C ++ vom 14.11.17 funktioniert.  Es gibt einen wunderbaren Code wie diesen: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCEPT_PP_CAT_(X, Y) X ## Y #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCEPT_PP_CAT(X, Y) CONCEPT_PP_CAT_(X, Y) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/// \addtogroup group-concepts /// @{ #define CONCEPT_REQUIRES_(...) \ int CONCEPT_PP_CAT(_concept_requires_, __LINE__) = 42, \ typename std::enable_if&lt; \ (CONCEPT_PP_CAT(_concept_requires_, __LINE__) == 43) || (__VA_ARGS__), \ int \ &gt;::type = 0 \ /**/</span></span></span></span></code> </pre> <br><p>  Damit Sie sp√§ter Folgendes tun k√∂nnen: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sortable_</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Rng, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> C = ordered_less, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P = ident, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> I = <span class="hljs-keyword"><span class="hljs-keyword">iterator_t</span></span>&lt;Rng&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> requires_() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>( concepts::valid_expr( concepts::model_of&lt;concepts::ForwardRange, Rng&gt;(), concepts::is_true(ranges::Sortable&lt;I, C, P&gt;()) )); }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Sortable = concepts::models&lt;Sortable_, Rng, C, P&gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Rng, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> C = ordered_less, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P = ident, CONCEPT_REQUIRES_(!Sortable&lt;Rng, C, P&gt;())&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>()(Rng &amp;&amp;, C &amp;&amp; = C{}, P &amp;&amp; = P{}) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { ...</code> </pre> <br><p>  Ich hoffe, Sie wollten das alles schon sehen und nur vorbereitete Konzepte in einem neuen Compiler verwenden. </p><br><h2 id="tochki-kastomizacii">  Anpassungspunkte </h2><br><p>  Das n√§chste interessante Element im Standard ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">customization.point.object</a> .  Sie werden aktiv in der Nibler Ranges-Bibliothek verwendet. </p><br><p>  Der Anpassungspunkt ist eine Funktion, die von der Standardbibliothek verwendet wird, damit er f√ºr Benutzertypen im Namespace des Benutzers √ºberladen werden kann. Diese √úberladungen k√∂nnen mithilfe von ADL gefunden werden. </p><br><p>  Anpassungspunkte werden unter <code>cust</code> der folgenden Architekturprinzipien <code>cust</code> ( <code>cust</code> ist der Name f√ºr einen imagin√§ren Anpassungspunkt): </p><br><ul><li>  Der Code, der <code>cust</code> entweder in der qualifizierten Form <code>std::cust(a)</code> oder in nicht qualifizierter Form geschrieben: <code>using std::cust; cust(a);</code> <code>using std::cust; cust(a);</code>  .  Beide Eintr√§ge m√ºssen sich identisch verhalten.  Insbesondere m√ºssen sie Benutzer√ºberladungen im Namespace finden, der den Argumenten zugeordnet ist. </li><li>  Code, der <code>cust</code> in Form eines <code>std::cust; cust(a);</code> <code>std::cust; cust(a);</code>  sollte nicht in der Lage sein, die Beschr√§nkungen f√ºr <code>std::cust</code> zu umgehen. </li><li>  Benutzerdefinierte Punktaufrufe sollten auf jedem relativ modernen Compiler effizient und optimal funktionieren. </li><li>  Die Entscheidung sollte keine neuen Verst√∂√üe gegen die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Single Definition Rule (ODR) hervorrufen</a> . </li></ul><br><p>  Um zu verstehen, was es ist, k√∂nnen Sie sich den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">N4381 ansehen</a> .  Auf den ersten Blick scheinen sie eine M√∂glichkeit zu sein, eigene Versionen von <code>begin</code> , <code>swap</code> , <code>data</code> und dergleichen zu schreiben, und die Standardbibliothek nimmt sie mit ADL auf. </p><br><p>  Die Frage ist, wie sich dies von der alten Praxis unterscheidet, wenn der Benutzer eine √úberladung f√ºr einige <code>begin</code> f√ºr seinen eigenen Typ und Namespace beginnen.  Und warum sind sie √ºberhaupt Objekte? </p><br><p>  Tats√§chlich sind dies Instanzen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionsobjekten</a> im <code>std</code> .  Ihr Zweck besteht darin, zuerst Typpr√ºfungen (als Konzepte konzipiert) f√ºr alle Argumente in einer Reihe durchzuf√ºhren und dann den Aufruf an die richtige Funktion im <code>std</code> oder ihn in ADL zum Verkauf anzubieten. </p><br><p>  In der Tat ist dies nicht die Art von Dingen, die Sie in einem regul√§ren Nicht-Bibliotheksprogramm verwenden w√ºrden.  Dies ist eine Funktion der Standardbibliothek, mit der Sie an zuk√ºnftigen Erweiterungspunkten eine Konzeptpr√ºfung hinzuf√ºgen k√∂nnen, die wiederum dazu f√ºhrt, dass sch√∂nere und verst√§ndlichere Fehler angezeigt werden, wenn Sie etwas in den Vorlagen durcheinander gebracht haben. </p><br><p>  Der derzeitige Ansatz f√ºr Anpassungspunkte weist einige Probleme auf.  Erstens ist es sehr einfach, alles zu zerbrechen.  Stellen Sie sich diesen Code vor: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t2</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap; swap(t1, t2); }</code> </pre> <br><p>  Wenn wir versehentlich einen qualifizierten Aufruf von <code>std::swap(t1, t2)</code> t√§tigen <code>std::swap(t1, t2)</code> wird unsere eigene Version von <code>swap</code> niemals gestartet, egal was wir dort ablegen.  Noch wichtiger ist jedoch, dass es keine M√∂glichkeit gibt, Konzeptpr√ºfungen zentral an solche benutzerdefinierten Funktionsimplementierungen anzuh√§ngen.  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">N4381</a> schreiben sie: </p><br><p>  ‚ÄûStellen Sie sich vor, dass <code>std::begin</code> eines Tages in Zukunft erfordern wird, dass sein Argument als <code>Range</code> Konzept modelliert wird.  Das Hinzuf√ºgen einer solchen Einschr√§nkung hat einfach keine Auswirkung auf den Code, der idiomatisch mit <code>std::begin</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::begin; begin(a);</code> </pre> <br><p>  Wenn der Startaufruf an die vom Benutzer erstellte √ºberladene Version gesendet wird, werden die Einschr√§nkungen f√ºr <code>std::begin</code> einfach ignoriert. ‚Äú </p><br><p>  Die im Propozal beschriebene L√∂sung l√∂st beide Probleme. Dazu verwenden wir den Ansatz dieser spekulativen Implementierung von <code>std::begin</code> (Sie k√∂nnen sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Godbolt ansehen</a> ): </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;utility&gt; namespace my_std { namespace detail { struct begin_fn { /*   ,         begin(arg)  arg.begin().  -   . */ template &lt;class T&gt; auto operator()(T&amp;&amp; arg) const { return impl(arg, 1L); } template &lt;class T&gt; auto impl(T&amp;&amp; arg, int) const requires requires { begin(std::declval&lt;T&gt;()); } { return begin(arg); } // ADL template &lt;class T&gt; auto impl(T&amp;&amp; arg, long) const requires requires { std::declval&lt;T&gt;().begin(); } { return arg.begin(); } // ... }; } //        inline constexpr detail::begin_fn begin{}; }</span></span></span></span></code> </pre> <br><p>  Ein qualifizierter Aufruf von <code>my_std::begin(someObject)</code> geht immer √ºber <code>my_std::detail::begin_fn</code> - und das ist gut so.  Was passiert mit einem unqualifizierten Anruf?  Lesen wir noch einmal unsere Zeitung: </p><br><p>  ‚ÄûWenn begin unmittelbar nach dem Erscheinen von <code>my_std::begin</code> innerhalb des Bereichs ohne <code>my_std::begin</code> , √§ndert sich die Situation etwas.  In der ersten Phase der Suche wird der Name <code>begin</code> in das globale Objekt <code>my_std::begin</code> .  Da die Suche ein Objekt und keine Funktion gefunden hat, wird die zweite Phase der Suche nicht ausgef√ºhrt.  Mit anderen Worten, wenn <code>my_std::begin</code> ein Objekt ist, dann verwenden Sie die Konstruktion <code>my_std::detail::begin_fn begin; begin(a);</code> <code>my_std::detail::begin_fn begin; begin(a);</code>  einfach √§quivalent zu <code>std::begin(a);</code>  "Und wie wir gesehen haben, startet dies benutzerdefinierte ADL." </p><br><p>  Aus diesem Grund kann die Konzept√ºberpr√ºfung in einem Funktionsobjekt im <code>std</code> bevor ADL die vom Benutzer bereitgestellte Funktion aufruft.  Es gibt keine M√∂glichkeit, dieses Verhalten auszutricksen. </p><br><h2 id="kak-kastomiziruyut-tochki-kastomizacii">  Wie werden Anpassungspunkte angepasst? </h2><br><p>  Tats√§chlich ist ‚ÄûAnpassungspunktobjekt‚Äú (CPO) kein guter Name.  Aus dem Namen ist nicht ersichtlich, wie sie sich ausdehnen, welche Mechanismen sich unter der Haube befinden, welche Funktionen sie bevorzugen ... </p><br><p>  Was uns zum Begriff "nibloid" f√ºhrt.  Ein Nibloid ist ein solcher CPO, der die Funktion X aufruft, wenn sie in der Klasse definiert ist, andernfalls die Funktion X aufruft, wenn eine geeignete freie Funktion vorhanden ist, andernfalls versucht er, einen Fallback der Funktion X auszuf√ºhren. </p><br><p>  So versuchen beispielsweise die nibloiden <code>ranges::swap</code> beim Aufrufen von <code>ranges::swap(a, b)</code> zuerst, <code>a.swap(b)</code> .  Wenn es keine solche Methode gibt, wird versucht, <code>swap(a, b)</code> mit ADL aufzurufen.  Wenn dies nicht funktioniert, versuchen Sie <code>auto tmp = std::move(a); a = std::move(b); b = std::move(tmp)</code> <code>auto tmp = std::move(a); a = std::move(b); b = std::move(tmp)</code>  <code>auto tmp = std::move(a); a = std::move(b); b = std::move(tmp)</code> . </p><br><h1 id="itogi">  Zusammenfassung </h1><br><p>  Wie Matt auf Twitter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">scherzte</a> , schlug <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dave</a> aus Gr√ºnden der Konsistenz einmal vor, funktionale Objekte mit ADL "funktionieren" zu lassen, genau wie regul√§re Funktionen.  Die Ironie ist, dass ihre F√§higkeit, ADL zu deaktivieren und f√ºr ihn unsichtbar zu sein, nun zu ihren Hauptvorteilen geworden ist. </p><br><p>  Dieser gesamte Artikel war eine Vorbereitung daf√ºr. </p><br><p>  " <i><b>Ich habe einfach alles verstanden, das ist alles. Wirst du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zuh√∂ren</a> ?</b></i> </p><br><p>  <i><b>Haben Sie jemals etwas angeschaut, und es schien verr√ºckt und dann in einem anderen Licht auf</b></i> <i><b><br></b></i>  <i><b>verr√ºckte Dinge, die sie normal sehen?</b></i> </p><br><p><img src="https://habrastorage.org/webt/-f/us/rh/-fusrhpdssngql8nlfx2qn0gdd8.jpeg"></p><br><p>  <i><b>F√ºrchte dich nicht.</b></i>  <i><b>F√ºrchte dich nicht.</b></i>  <i><b>Ich f√ºhle mich im Herzen so gut.</b></i>  <i><b>Alles wird gut.</b></i>  <i><b>Ich habe mich seit vielen Jahren nicht mehr so ‚Äã‚Äãgut gef√ºhlt.</b></i>  <i><b>Alles wird gut.</b></i> </p><br><p><img src="https://habrastorage.org/webt/pe/ca/az/pecaazhixdkr6dsdxv67ewlvte8.jpeg"></p><br><blockquote>  Minute der Werbung.  Bereits in <b>dieser Woche</b> , vom 19. bis 20. April, findet die C ++ Russia 2019 statt - eine Konferenz mit Hardcore-Pr√§sentationen sowohl zur Sprache selbst als auch zu praktischen Themen wie Multithreading und Performance.  Die Konferenz wird √ºbrigens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von</a> Nicolai Josuttis er√∂ffnet, dem Autor der im Artikel erw√§hnten C ++ - Standardbibliothek: Ein Tutorial und eine Referenz.  Sie k√∂nnen sich mit dem Programm vertraut machen und Tickets <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf der offiziellen Website</a> kaufen.  Es bleibt nur noch sehr wenig Zeit, dies ist die letzte Chance. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de447900/">https://habr.com/ru/post/de447900/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de447890/index.html">Gott sei Dank bin ich kein Manager</a></li>
<li><a href="../de447892/index.html">Zwei neue PHDays-Wettbewerbe: IDS-Bypass und Factory-Hacking</a></li>
<li><a href="../de447894/index.html">MODX Digest # 3 (25. M√§rz - 8. April 2019)</a></li>
<li><a href="../de447896/index.html">Bilder aus groben Skizzen: Genau so funktioniert das neuronale Netzwerk NVIDIA GauGAN</a></li>
<li><a href="../de447898/index.html">Gut gen√§hrte Philosophen oder wettbewerbsf√§hige .NET-Programmierung</a></li>
<li><a href="../de447902/index.html">GitHub hat das Repository-Dienstprogramm-Repository und das gesamte Erstellerkonto vollst√§ndig "gel√∂scht"</a></li>
<li><a href="../de447904/index.html">Experten von Positive Technologies identifizieren Versuche, kritische Schwachstellen in Confluence massenhaft auszunutzen</a></li>
<li><a href="../de447906/index.html">Aktuelle Innovationen: Was erwartet Sie 2019 vom Rechenzentrumsmarkt?</a></li>
<li><a href="../de447908/index.html">Es sollten zwei M√∂glichkeiten funktionieren, Belohnungen f√ºr Werbung in Handyspielen oder Robotern zu sammeln</a></li>
<li><a href="../de447910/index.html">Das "√ñl" der modernen Wirtschaft und der Krieg um das Personal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>