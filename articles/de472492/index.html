<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôà üåò üòï Analyse des ROOT-Codes, Scientific Data Analysis Framework üôãüèª üöñ üôÖüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="W√§hrend Stockholm die 118. Nobelwoche abhielt, sa√ü ich in unserem B√ºro, wo wir den statischen Analysator PVS-Studio entwickelten und an einer Analyse√º...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analyse des ROOT-Codes, Scientific Data Analysis Framework</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/472492/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df2/7f4/bcd/df27f4bcd139790b322570ee2f48e1ab.png" alt="Bild 3"></div>  W√§hrend Stockholm die 118. Nobelwoche abhielt, sa√ü ich in unserem B√ºro, wo wir den statischen Analysator PVS-Studio entwickelten und an einer Analyse√ºberpr√ºfung des ROOT-Projekts arbeiteten, einem Rahmen f√ºr die Verarbeitung gro√üer Datenmengen, der in der wissenschaftlichen Forschung verwendet wird.  Dieser Code w√ºrde nat√ºrlich keinen Preis gewinnen, aber die Autoren k√∂nnen sich definitiv auf eine detaillierte √úberpr√ºfung der interessantesten M√§ngel sowie eine kostenlose Lizenz verlassen, um das Projekt selbst gr√ºndlich zu √ºberpr√ºfen. <br><br><h2>  Einf√ºhrung </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a89/187/f04/a89187f045bbcb2b5b8d5ab7c9dc7da1.png" alt="Bild 1"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ROOT</a> ist ein modulares wissenschaftliches Software-Toolkit.  Es bietet alle Funktionen, die f√ºr die Verarbeitung, statistische Analyse, Visualisierung und Speicherung von Big Data erforderlich sind.  Es ist haupts√§chlich in C ++ geschrieben.  ROOT wurde am <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CERN geboren</a> , im Zentrum der Forschung zur Hochenergiephysik.  T√§glich verwenden Tausende von Physikern ROOT-Anwendungen, um ihre Daten zu analysieren oder Simulationen durchzuf√ºhren. <br><a name="habracut"></a><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PVS-Studio</a> ist ein Tool zum Erkennen von Softwarefehlern und potenziellen Schwachstellen im Quellcode von Programmen, die in C, C ++, C # und Java geschrieben wurden.  Es l√§uft unter 64-Bit-Windows, Linux und MacOS und kann Quellcode analysieren, der f√ºr 32-Bit-, 64-Bit- und eingebettete ARM-Plattformen geschrieben wurde. <br><br><h2>  Das Deb√ºt einer neuen Diagnose </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V1046</a> Unsichere Verwendung der Typen bool 'und' int 'zusammen in der Operation' &amp; = '.  GSLMultiRootFinder.h 175 <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ROOT::Math::IMultiGenFunction &amp; func)</span></span></span><span class="hljs-function"> </span></span>{ ROOT::Math::IMultiGenFunction * f = func.Clone(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!f) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; fFunctions.push_back(f); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fFunctions.size(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FuncIterator</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SetFunctionList</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FuncIterator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">begin</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FuncIterator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ret = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (FuncIterator itr = begin; itr != end; ++itr) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ROOT::Math::IMultiGenFunction * f = *itr; ret &amp;= AddFunction(*f); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre> <br>  Zun√§chst einmal ist hier ein wunderbarer Fehler, der von der Beta-Version von PVS-Studio gefunden wurde, die ich f√ºr diesen Test verwendet habe. <br><br>  <b>Erwartungen</b>  Die <i>SetFunctionList-</i> Funktion durchl√§uft eine Iteratorliste.  Wenn mindestens ein Iterator ung√ºltig ist, gibt die Funktion <i>false</i> oder andernfalls <i>true zur√ºck</i> . <br><br>  <b>Realit√§t</b>  Die <i>SetFunctionList-</i> Funktion kann auch f√ºr g√ºltige Iteratoren <i>false zur√ºckgeben</i> .  Lassen Sie uns herausfinden, warum.  Die <i>AddFunction-</i> Funktion gibt die Anzahl der g√ºltigen Iteratoren in der <i>fFunctions-</i> Liste zur√ºck.  Das hei√üt, das Hinzuf√ºgen von Nicht-Null-Iteratoren f√ºhrt dazu, dass die Liste schrittweise gr√∂√üer wird: 1, 2, 3, 4 usw.  Hier kommt der Fehler ins Spiel: <br><br><pre> <code class="cpp hljs">ret &amp;= AddFunction(*f);</code> </pre> <br>  Da die Funktion einen Wert vom Typ <i>int</i> anstelle von <i>bool</i> zur√ºckgibt, gibt die Operation '&amp; =' f√ºr gerade Werte <i>false zur√ºck</i> , da das niedrigstwertige Bit einer geraden Zahl immer auf Null gesetzt wird.  Auf diese Weise kann ein subtiler Fehler den R√ºckgabewert von <i>SetFunctionsList</i> auch dann <i>aufheben</i> , wenn seine Argumente g√ºltig sind. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa4/c23/64f/aa4c2364f5205b526db1625aeebd32ff.png" alt="Bild 2"></div><br><h2>  Fehler in bedingten Ausdr√ºcken </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V501</a> Links und rechts vom Operator '&amp;&amp;' befinden sich identische Unterausdr√ºcke: Modul &amp;&amp; Modul rootcling_impl.cxx 3650 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleDiagnostic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> override </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isROOTSystemModuleDiag = <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> &amp;&amp; ....; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isSystemModuleDiag = <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>-&gt;IsSystem; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isROOTSystemModuleDiag &amp;&amp; !isSystemModuleDiag) fChild-&gt;HandleDiagnostic(DiagLevel, Info); .... }</code> </pre> <br>  Beginnen wir mit dem am wenigsten sch√§dlichen Fehler.  Der Modulzeiger wird zweimal √ºberpr√ºft.  Eine der √úberpr√ºfungen ist wahrscheinlich √ºberfl√ºssig, es w√§re jedoch ratsam, sie zu beheben, um k√ºnftige Verwirrung zu vermeiden. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V501</a> Links und rechts vom '||' befinden sich identische Unterausdr√ºcke 'strchr (fHostAuth-&gt; GetHost (),' * ')'.  Betreiber.  TAuthenticate.cxx 300 <br><br><pre> <code class="cpp hljs">TAuthenticate::TAuthenticate(TSocket *sock, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *remote, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *proto, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *user) { .... <span class="hljs-comment"><span class="hljs-comment">// If generic THostAuth (ie with wild card or user == any) // make a personalized memory copy of this THostAuth if (strchr(fHostAuth-&gt;GetHost(),'*') || strchr(fHostAuth-&gt;GetHost(),'*') || fHostAuth-&gt;GetServer() == -1 ) { fHostAuth = new THostAuth(*fHostAuth); fHostAuth-&gt;SetHost(fqdn); fHostAuth-&gt;SetUser(checkUser); fHostAuth-&gt;SetServer(servtype); } .... }</span></span></code> </pre> <br>  Die <i>Zeichenfolge fHostAuth-&gt; GetHost ()</i> wird zweimal nach dem Zeichen '*' durchsucht.  Eine dieser √úberpr√ºfungen sollte wahrscheinlich nach dem '?'  Zeichen, da diese beiden Zeichen normalerweise zum Angeben verschiedener Platzhaltermasken verwendet werden. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V517</a> Die Verwendung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Musters</a> 'if (A) {...} else if (A) {...}' wurde erkannt.  Es besteht die Wahrscheinlichkeit eines logischen Fehlers.  √úberpr√ºfen Sie die Zeilen: 163, 165. TProofMonSenderML.cxx 163 <br><br><pre> <code class="cpp hljs">Int_t TProofMonSenderML::SendSummary(TList *recs, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *id) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fSummaryVrs == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((dsn = recs-&gt;FindObject(<span class="hljs-string"><span class="hljs-string">"dataset"</span></span>))) recs-&gt;Remove(dsn); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fSummaryVrs == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Only the first records xrecs = new TList; xrecs-&gt;SetOwner(kFALSE); TIter nxr(recs); TObject *o = 0; while ((o = nxr())) { if (!strcmp(o-&gt;GetName(), "vmemmxw")) break; xrecs-&gt;Add(o); } } .... }</span></span></code> </pre> <br>  Die Variable <i>fSummaryVrs</i> wird zweimal mit Null verglichen, sodass die Ausf√ºhrung niemals den Code im Zweig <i>else-if erreicht</i> .  Und da ist ziemlich viel Code ... <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V523</a> Die Anweisung 'then' entspricht der Anweisung 'else'.  TKDTree.cxx 805 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Index, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Value&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TKDTree&lt;Index, Value&gt;::UpdateRange(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (point[fAxis[inode]]&lt;=fValue[inode]){ <span class="hljs-comment"><span class="hljs-comment">//first examine the node that contains the point UpdateRange(GetLeft(inode),point, range, res); UpdateRange(GetRight(inode),point, range, res); } else { UpdateRange(GetLeft(inode),point, range, res); UpdateRange(GetRight(inode),point, range, res); } .... }</span></span></code> </pre> <br>  Der gleiche Codeblock, bei dem es sich um einen Copy-Paste-Klon handelt, wird unabh√§ngig von der Bedingung ausgef√ºhrt.  Ich denke, es gibt eine Verwechslung zwischen den W√∂rtern <i>links</i> und <i>rechts</i> . <br><br>  Das Projekt ist voll von solchen verd√§chtigen Stellen: <br><br><ul><li>  V523 Die Anweisung 'then' entspricht der Anweisung 'else'.  TContainerConverters.cxx 51 </li><li>  V523 Die Anweisung 'then' entspricht der Anweisung 'else'.  TWebFile.cxx 1310 </li><li>  V523 Die Anweisung 'then' entspricht der Anweisung 'else'.  MethodMLP.cxx 423 </li><li>  V523 Die Anweisung 'then' entspricht der Anweisung 'else'.  RooAbsCategory.cxx 394 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V547</a> Ausdruck '! File_name_value.empty ()' ist immer falsch.  SelectionRules.cxx 1423 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> SelectionRules::AreAllSelectionRulesUsed() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; rule : fClassSelectionRules){ .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file_name_value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!rule.GetAttributeValue(<span class="hljs-string"><span class="hljs-string">"file_name"</span></span>, file_name_value)) file_name_value.clear(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!file_name_value.empty()) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= // don't complain about defined_in rules continue; } const char* attrName = nullptr; const char* attrVal = nullptr; if (!file_name_value.empty()) { // &lt;= attrName = "file name"; attrVal = file_name_value.c_str(); } else { attrName = "class"; if (!name.empty()) attrVal = name.c_str(); } ROOT::TMetaUtils::Warning(0,"Unused %s rule: %s\n", attrName, attrVal); } .... }</span></span></code> </pre> <br>  Dies ist wahrscheinlich kein Fehler;  Der Analysator hat gerade einen Code gefunden, der vereinfacht werden kann.  Da der R√ºckgabewert von <i>file_name_value.empty ()</i> bereits zu Beginn der Schleife √ºberpr√ºft wird, kann die zweite doppelte Pr√ºfung entfernt werden, wodurch eine gro√üe Menge unn√∂tigen Codes <i>weggeworfen</i> wird. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V590</a> √úberpr√ºfen Sie die '! File1 ||  c &lt;= 0 ||  c == '*' ||  c! = '(' 'Ausdruck. Der Ausdruck ist √ºberm√§√üig oder enth√§lt einen Druckfehler. TTabCom.cxx 840 <br><br><pre> <code class="cpp hljs">TString TTabCom::DetermineClass(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> varName[]) { .... c = file1.get(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!file1 || c &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || c == <span class="hljs-string"><span class="hljs-string">'*'</span></span> || c != <span class="hljs-string"><span class="hljs-string">'('</span></span>) { Error(<span class="hljs-string"><span class="hljs-string">"TTabCom::DetermineClass"</span></span>, <span class="hljs-string"><span class="hljs-string">"variable \"%s\" not defined?"</span></span>, varName); <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> cleanup; } .... }</code> </pre> <br>  Hier ist der Problemteil des vom Analysator gemeldeten bedingten Ausdrucks: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (.... || c == <span class="hljs-string"><span class="hljs-string">'*'</span></span> || c != <span class="hljs-string"><span class="hljs-string">'('</span></span>) { .... }</code> </pre> <br>  Die Pr√ºfung auf das Sternchen wirkt sich nicht auf das Ergebnis der Bedingung aus.  Dieser Teil gilt immer f√ºr andere Zeichen als '('. Sie k√∂nnen ihn leicht selbst √ºberpr√ºfen, indem Sie eine Wahrheitstabelle zeichnen. <br><br>  Zwei weitere Warnungen vor Zust√§nden mit seltsamer Logik: <br><br><ul><li>  V590 √úberpr√ºfen Sie diesen Ausdruck.  Der Ausdruck ist √ºbertrieben oder enth√§lt einen Druckfehler.  TFile.cxx 3963 </li><li>  V590 √úberpr√ºfen Sie diesen Ausdruck.  Der Ausdruck ist √ºbertrieben oder enth√§lt einen Druckfehler.  TStreamerInfoActions.cxx 3084 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V593</a> √úberpr√ºfen Sie den Ausdruck der Art 'A = B &lt;C'.  Der Ausdruck wird wie folgt berechnet: 'A = (B &lt;C)'.  TProofServ.cxx 1903 <br><br><pre> <code class="cpp hljs">Int_t TProofServ::HandleSocketInput(TMessage *mess, Bool_t all) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Int_t ret = fProof-&gt;AddWorkers(workerList) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Error(<span class="hljs-string"><span class="hljs-string">"HandleSocketInput:kPROOF_GETSLAVEINFO"</span></span>, <span class="hljs-string"><span class="hljs-string">"adding a list of worker nodes returned: %d"</span></span>, ret); } .... }</code> </pre> <br>  Dieser Fehler zeigt sich nur bei fehlerhaftem Verhalten des Programms.  Die Variable <i>ret</i> soll den R√ºckkehrcode der <i>AddWorkers-</i> Funktion <i>speichern</i> und diesen Wert im Fehlerfall in das Protokoll schreiben.  Aber es funktioniert nicht wie beabsichtigt.  Der Bedingung fehlen zus√§tzliche Klammern, die die gew√ºnschte Reihenfolge der Bewertung erzwingen.  Was die Variable <i>ret</i> tats√§chlich speichert, ist nicht der R√ºckkehrcode, sondern das Ergebnis des logischen Vergleichs, dh entweder 0 oder 1. <br><br>  Ein weiteres √§hnliches Problem: <br><br><ul><li>  V593 √úberpr√ºfen Sie den Ausdruck der Art 'A = B &lt;C'.  Der Ausdruck wird wie folgt berechnet: 'A = (B &lt;C)'.  TProofServ.cxx 3897 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V768</a> Die Aufz√§hlungskonstante 'kCostComplexityPruning' wird als Variable eines Booleschen Typs verwendet.  MethodDT.cxx 283 <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> EPruneMethod {kExpectedErrorPruning=<span class="hljs-number"><span class="hljs-number">0</span></span>, kCostComplexityPruning, kNoPruning}; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TMVA::MethodDT::ProcessOptions() { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fPruneStrength &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) fAutomatic = kTRUE; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> fAutomatic = kFALSE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fAutomatic &amp;&amp; fPruneMethod==!DecisionTree::kCostComplexityPruning){ Log() &lt;&lt; kFATAL &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Sorry automatic pruning strength determination is ...."</span></span> &lt;&lt; Endl; } .... }</code> </pre> <br>  Hm ... Warum den konstanten Wert <i>kCostComplexityPruning</i> negieren?  Ich vermute, dass das Negationszeichen ein Tippfehler ist, der jetzt die Ausf√ºhrungslogik verzerrt. <br><br><h2>  Zeigerhandhabungsfehler </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V522 Eine</a> Dereferenzierung des Nullzeigers 'pre' kann stattfinden.  TSynapse.cxx 61 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TSynapse::SetPre(TNeuron * pre) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pre) { Error(<span class="hljs-string"><span class="hljs-string">"SetPre"</span></span>,<span class="hljs-string"><span class="hljs-string">"this synapse is already assigned to a pre-neuron."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } fpre = pre; pre-&gt;AddPost(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  Ich habe mein Bestes getan, um diesen seltsamen Code zu verstehen, und es scheint, dass die Idee darin bestand, dem Feld <i>fpre</i> keinen neuen Wert <i>zuzuweisen</i> .  In diesem Fall √ºberpr√ºft der Programmierer versehentlich den falschen Zeiger.  Die aktuelle Implementierung f√ºhrt zur Dereferenzierung eines Nullzeigers, wenn Sie den <i>Nullptr-</i> Wert an die <i>SetPre-</i> Funktion √ºbergeben. <br><br>  Ich denke, dieses Snippet sollte wie folgt repariert werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TSynapse::SetPre(TNeuron * pre) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fpre) { Error(<span class="hljs-string"><span class="hljs-string">"SetPre"</span></span>,<span class="hljs-string"><span class="hljs-string">"this synapse is already assigned to a pre-neuron."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } fpre = pre; pre-&gt;AddPost(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  Dies w√ºrde jedoch die √úbergabe eines Nullzeigers an die Funktion nicht verhindern, aber zumindest ist diese Version logisch konsistenter als die urspr√ºngliche. <br><br>  Ein leicht modifizierter Klon dieses Codes befindet sich an einer anderen Stelle: <br><br><ul><li>  V522 Es kann zu einer Dereferenzierung des Nullzeigers 'post' kommen.  TSynapse.cxx 74 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V595</a> Der ' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">N'</a> -Zeiger wurde verwendet, bevor er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 484, 488. Scanner.cxx 484 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> RScanner::shouldVisitDecl(clang::NamedDecl *D) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> M = D-&gt;getOwningModule()) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= 2 return fInterpreter.getSema().isModuleVisible(M); } return true; } bool RScanner::VisitNamespaceDecl(clang::NamespaceDecl* N) { if (fScanType == EScanType::kOnePCM) return true; if (!shouldVisitDecl(N)) // &lt;= 1 return true; if((N &amp;&amp; N-&gt;isImplicit()) || !N){ // &lt;= 3 return true; } .... }</span></span></code> </pre> <br>  Dies ist ein √§u√üerst gef√§hrlicher Code!  Der <i>N-</i> Zeiger wird nicht auf Null gepr√ºft, bevor er beim ersten Mal dereferenziert wird.  <i>Dar√ºber hinaus</i> k√∂nnen Sie dies hier nicht sehen, da die Dereferenzierung innerhalb der Funktion <i>shouldVisitDecl stattfindet</i> . <br><br>  Diese Diagnose generiert traditionell eine Reihe relevanter Warnungen.  Hier nur einige Beispiele: <br><br><ul><li>  V595 Der 'Datei'-Zeiger wurde verwendet, bevor er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 141, 153. TFileCacheRead.cxx 141 </li><li>  V595 Der Zeiger 'fFree' wurde verwendet, bevor er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 2029, 2038. TFile.cxx 2029 </li><li>  V595 Der Zeiger 'tbuf' wurde verwendet, bevor er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 586, 591. TGText.cxx 586 </li><li>  V595 Der Zeiger 'fPlayer' wurde verwendet, bevor er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 3425, 3430. TProof.cxx 3425 </li><li>  V595 Der Zeiger 'gProofServ' wurde verwendet, bevor er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 1192, 1194. TProofPlayer.cxx 1192 </li><li>  V595 Der Zeiger 'projDataTmp' wurde verwendet, bevor er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 791, 804. RooSimultaneous.cxx 791 </li></ul><br>  Der n√§chste ist kein Fehler, aber ein weiteres Beispiel daf√ºr, wie Makros <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das</a> Schreiben von fehlerhaftem oder redundantem Code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">f√∂rdern</a> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V571</a> Wiederkehrende Pr√ºfung.  Die Bedingung 'if (fCanvasImp)' wurde bereits in Zeile 799 √ºberpr√ºft. TCanvas.cxx 800 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SafeDelete(p) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (p) { delete p; p = 0; } } void TCanvas::Close(Option_t *option) { .... </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (fCanvasImp) SafeDelete(fCanvasImp); .... }</span></span></code> </pre> <br>  Der <i>fCanvasImp-</i> Zeiger wird zweimal √ºberpr√ºft, wobei eine der √úberpr√ºfungen bereits im <i>SafeDelete-</i> Makro implementiert ist.  Eines der Probleme mit Makros besteht darin, dass es schwierig ist, innerhalb des Codes zu navigieren. Dies ist der Grund, warum viele Programmierer ihren Inhalt vor der Verwendung nicht untersuchen. <br><br><h2>  Fehler bei der Array-Behandlung </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V519</a> Der Variablen 'Line [Cursor]' werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 352, 353. Editor.cpp 353 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> find_last_non_alnum(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;str, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::size_type index = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos) { .... <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> tmp = Line.GetText()[Cursor]; Line[Cursor] = Line[Cursor - <span class="hljs-number"><span class="hljs-number">1</span></span>]; Line[Cursor] = tmp; .... }</code> </pre> <br>  Dem Element <i>Zeile [Cursor]</i> wird ein neuer Wert zugewiesen, der dann sofort √ºberschrieben wird.  Das sieht nicht richtig aus ... <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V557</a> Array-√úberlauf ist m√∂glich.  Der 'ivar'-Index zeigt √ºber die Array-Grenze hinaus.  BasicMinimizer.cxx 130 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> BasicMinimizer::SetVariableValue(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ivar, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> val) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ivar &gt; fValues.size() ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; fValues[ivar] = val; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Dieser Fehler beim √úberpr√ºfen von Array-Indizes ist ein aktueller Trend.  Wir sehen es in fast jedem dritten Projekt.  W√§hrend die Indizierung in ein Array innerhalb einer Schleife einfach ist - normalerweise verwenden Sie den Operator '&lt;', um den Index mit der Gr√∂√üe des Arrays zu vergleichen - erfordern √úberpr√ºfungen wie die oben gezeigte den Operator '&gt; =', nicht '&gt;'.  Andernfalls besteht die Gefahr, dass Sie ein Element √ºber die Grenzen des Arrays hinaus indizieren. <br><br>  Dieser Fehler wurde einige Male im gesamten Code geklont: <br><br><ul><li>  V557 Array-√úberlauf ist m√∂glich.  Der 'ivar'-Index zeigt √ºber die Array-Grenze hinaus.  BasicMinimizer.cxx 186 </li><li>  V557 Array-√úberlauf ist m√∂glich.  Der 'ivar'-Index zeigt √ºber die Array-Grenze hinaus.  BasicMinimizer.cxx 194 </li><li>  V557 Array-√úberlauf ist m√∂glich.  Der 'ivar'-Index zeigt √ºber die Array-Grenze hinaus.  BasicMinimizer.cxx 209 </li><li>  V557 Array-√úberlauf ist m√∂glich.  Der 'ivar'-Index zeigt √ºber die Array-Grenze hinaus.  BasicMinimizer.cxx 215 </li><li>  V557 Array-√úberlauf ist m√∂glich.  Der 'ivar'-Index zeigt √ºber die Array-Grenze hinaus.  BasicMinimizer.cxx 230 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V621</a> √úberpr√ºfen Sie den ' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">for'</a> -Operator.  Es ist m√∂glich, dass die Schleife falsch oder gar nicht ausgef√ºhrt wird.  TDataMember.cxx 554 <br><br><pre> <code class="cpp hljs">Int_t TDataMember::GetArrayDim() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fArrayDim&lt;<span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; fInfo) { R__LOCKGUARD(gInterpreterMutex); TDataMember *dm = <span class="hljs-keyword"><span class="hljs-keyword">const_cast</span></span>&lt;TDataMember*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); dm-&gt;fArrayDim = gCling-&gt;DataMemberInfo_ArrayDim(fInfo); <span class="hljs-comment"><span class="hljs-comment">// fArrayMaxIndex should be zero if (dm-&gt;fArrayDim) { dm-&gt;fArrayMaxIndex = new Int_t[fArrayDim]; for(Int_t dim = 0; dim &lt; fArrayDim; ++dim) { dm-&gt;fArrayMaxIndex[dim] = gCling-&gt;DataMemberInfo_MaxIndex(fInfo,dim); } } } return fArrayDim; }</span></span></code> </pre> <br>  In der <i>for-</i> Schleife <i>wollten</i> die Entwickler anscheinend die <i>dim-</i> Variable mit <i>dm-&gt; fArrayDim</i> und nicht mit <i>fArrayDim vergleichen</i> .  Der Wert von <i>fArrayDim</i> ist negativ, was durch die Bedingung am Anfang der Funktion garantiert wird.  Folglich wird diese Schleife niemals ausgef√ºhrt. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V767</a> Verd√§chtiger Zugriff auf das Element des 'aktuellen' Arrays durch einen konstanten Index innerhalb einer Schleife.  TClingUtils.cxx 3082 <br><br><pre> <code class="cpp hljs">llvm::StringRef ROOT::TMetaUtils::DataMemberInfo__ValidArrayIndex(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current!=<span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Check the token if (isdigit(current[0])) { for(i=0;i&lt;strlen(current);i++) { if (!isdigit(current[0])) { if (errstr) *errstr = current; if (errnum) *errnum = NOT_INT; return llvm::StringRef(); } } } else { // current token is not a digit .... } .... } .... }</span></span></code> </pre> <br>  Dieser Code analysiert und √ºberpr√ºft eine Zeichenfolge.  Wenn das erste Zeichen der <i>aktuellen</i> Zeichenfolge (dh bei Index 0) als Zahl erkannt wurde, durchl√§uft die Schleife alle √ºbrigen Zeichen, um sicherzustellen, dass es sich bei allen um Zahlen handelt.  Zumindest ist das die Idee.  Das Problem ist, dass der <i>i-</i> Z√§hler in der Schleife nicht verwendet wird.  Die Bedingung sollte so umgeschrieben werden, dass sie <i>aktuell [i]</i> und nicht <i>aktuell [0]</i> pr√ºft. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16e/c09/97a/16ec0997a4c29ce4a257d4124cf63ce2.png" alt="Bild 4"></div><br><h2>  Speicherverlust </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V773</a> Die Funktion wurde beendet, ohne den Zeiger 'Optionsliste' loszulassen.  Ein Speicherverlust ist m√∂glich.  TDataMember.cxx 355 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TDataMember::Init(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> afterReading) { .... TList *optionlist = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TList(); <span class="hljs-comment"><span class="hljs-comment">//storage for options strings for (i=0;i&lt;token_cnt;i++) { if (strstr(tokens[i],"Items")) { ptr1 = R__STRTOK_R(tokens[i], "()", &amp;rest); if (ptr1 == 0) { Fatal("TDataMember","Internal error, found \"Items....",GetTitle()); return; } ptr1 = R__STRTOK_R(nullptr, "()", &amp;rest); if (ptr1 == 0) { Fatal("TDataMember","Internal error, found \"Items....",GetTitle()); return; } .... } .... } .... // dispose of temporary option list... delete optionlist; .... }</span></span></code> </pre> <br>  Der <i>optionList-</i> Zeiger wird vor der R√ºckkehr von der Funktion nicht freigegeben.  Ich wei√ü nicht, ob eine solche Freigabe in diesem speziellen Fall erforderlich ist, aber wenn wir solche Fehler melden, beheben Entwickler sie normalerweise.  Es h√§ngt alles davon ab, ob Ihr Programm im Fehlerfall weiter ausgef√ºhrt werden soll oder nicht.  ROOT weist eine Reihe solcher M√§ngel auf, daher w√ºrde ich den Autoren raten, das Projekt selbst zu √ºberpr√ºfen. <br><br><h2>  wieder memset </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V597</a> Der Compiler k√∂nnte den Funktionsaufruf 'memset' l√∂schen, mit dem der 'x'-Puffer geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu l√∂schen.  TMD5.cxx 366 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TMD5::Transform(UInt_t buf[<span class="hljs-number"><span class="hljs-number">4</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UChar_t in[<span class="hljs-number"><span class="hljs-number">64</span></span>]) { UInt_t a, b, c, d, x[<span class="hljs-number"><span class="hljs-number">16</span></span>]; .... <span class="hljs-comment"><span class="hljs-comment">// Zero out sensitive information memset(x, 0, sizeof(x)); }</span></span></code> </pre> <br>  Viele denken, dass der Kommentar nach der Kompilierung nicht in die Bin√§rdatei gelangt, und sie sind absolut korrekt: D.  Einige wissen m√∂glicherweise nicht, dass der Compiler auch die <i>Memset-</i> Funktion entfernt.  Und das wird sicher passieren.  Wenn der betreffende Puffer im Code nicht mehr weiter verwendet wird, optimiert der Compiler den Funktionsaufruf.  Technisch gesehen ist es eine vern√ºnftige Entscheidung, aber wenn der Puffer private Daten gespeichert hat, bleiben diese Daten dort.  Dies ist eine klassische Sicherheitsschw√§che <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CWE-14</a> . <br><br><h2>  Verschiedenes </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V591</a> Non-void-Funktion sollte einen Wert zur√ºckgeben.  LogLikelihoodFCN.h 108 <br><br><pre> <code class="cpp hljs">LogLikelihoodFCN &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> LogLikelihoodFCN &amp; rhs) { SetData(rhs.DataPtr() ); SetModelFunction(rhs.ModelFunctionPtr() ); fNEffPoints = rhs.fNEffPoints; fGrad = rhs.fGrad; fIsExtended = rhs.fIsExtended; fWeight = rhs.fWeight; fExecutionPolicy = rhs.fExecutionPolicy; }</code> </pre> <br>  Der √ºberladene Operator hat keinen R√ºckgabewert.  Dies ist ein weiterer aktueller Trend. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V596</a> Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Das Schl√ºsselwort 'throw' k√∂nnte fehlen: throw runtime_error (FOO);  RTensor.hxx 363 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Value_t, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Container_t&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> RTensor&lt;Value_t, Container_t&gt; RTensor&lt;Value_t, Container_t&gt;::Transpose() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fLayout == MemoryLayout::RowMajor) { fLayout = MemoryLayout::ColumnMajor; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fLayout == MemoryLayout::ColumnMajor) { fLayout = MemoryLayout::RowMajor; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-string"><span class="hljs-string">"Memory layout is not known."</span></span>); } .... }</code> </pre> <br>  Das Problem ist, dass der Programmierer das Schl√ºsselwort <i>throw versehentlich</i> weggelassen hat, wodurch das Ausl√∂sen einer Ausnahme im Fehlerfall verhindert wird. <br><br>  Es gab nur zwei Warnungen dieses Typs.  Hier ist der zweite: <br><br><ul><li>  V596 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Das Schl√ºsselwort 'throw' k√∂nnte fehlen: throw runtime_error (FOO);  Forest.hxx 137 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V609</a> Durch Null teilen.  Nennerbereich [0..100].  TGHtmlImage.cxx 340 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *TGHtml::GetPctWidth(TGHtmlElement *p, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *opt, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ret) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, m, val; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || n &gt; <span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> z; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (opt[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'h'</span></span>) { val = fCanvas-&gt;GetHeight() * <span class="hljs-number"><span class="hljs-number">100</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { val = fCanvas-&gt;GetWidth() * <span class="hljs-number"><span class="hljs-number">100</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!fInTd) { <span class="hljs-built_in"><span class="hljs-built_in">snprintf</span></span>(ret, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-string"><span class="hljs-string">"%d"</span></span>, val / n); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } else { .... } .... }</span></span></code> </pre> <br>  Dieser √§hnelt den zuvor diskutierten Beispielen f√ºr die Array-Behandlung.  Die Variable <i>n</i> ist auf den Bereich von 0 bis 100 begrenzt. Aber dann gibt es einen Zweig, der eine Division durch die Variable <i>n durchf√ºhrt</i> , die den Wert 0 haben kann. Ich denke, die Bereichsgrenzen von <i>n</i> sollten wie folgt festgelegt werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || n &gt; <span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> z;</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V646</a> √úberpr√ºfen Sie die Logik der Anwendung.  M√∂glicherweise fehlt das Schl√ºsselwort "else".  TProofServ.cxx 729 <br><br><pre> <code class="cpp hljs">TProofServ::TProofServ(Int_t *argc, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **argv, FILE *flog) : TApplication(<span class="hljs-string"><span class="hljs-string">"proofserv"</span></span>, argc, argv, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!logmx.IsDigit()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (logmx.EndsWith(<span class="hljs-string"><span class="hljs-string">"K"</span></span>)) { xf = <span class="hljs-number"><span class="hljs-number">1024</span></span>; logmx.Remove(TString::kTrailing, <span class="hljs-string"><span class="hljs-string">'K'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (logmx.EndsWith(<span class="hljs-string"><span class="hljs-string">"M"</span></span>)) { xf = <span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>; logmx.Remove(TString::kTrailing, <span class="hljs-string"><span class="hljs-string">'M'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (logmx.EndsWith(<span class="hljs-string"><span class="hljs-string">"G"</span></span>)) { xf = <span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>; logmx.Remove(TString::kTrailing, <span class="hljs-string"><span class="hljs-string">'G'</span></span>); } } .... }</code> </pre> <br>  Der Analysator meldet eine seltsam formatierte <i>if-</i> Anweisung mit dem fehlenden <i>else-</i> Schl√ºsselwort.  Die Art und Weise, wie dieser Code aussieht, deutet darauf hin, dass er behoben werden muss. <br><br>  Noch ein paar Warnungen dieses Typs: <br><br><ul><li>  V646 √úberpr√ºfen Sie die Logik der Anwendung.  M√∂glicherweise fehlt das Schl√ºsselwort "else".  TFormula_v5.cxx 3702 </li><li>  V646 √úberpr√ºfen Sie die Logik der Anwendung.  M√∂glicherweise fehlt das Schl√ºsselwort "else".  RooAbsCategory.cxx 604 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V663</a> Endlosschleife ist m√∂glich.  Die Bedingung 'cin.eof ()' reicht nicht aus, um die Schleife zu verlassen.  F√ºgen Sie dem bedingten Ausdruck m√∂glicherweise den Funktionsaufruf 'cin.fail ()' hinzu.  MethodKNN.cxx 602 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TMVA::MethodKNN::ReadWeightsFromStream(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream&amp; is) { .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!is.eof()) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> line; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::getline(is, line); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (line.empty() || line.find(<span class="hljs-string"><span class="hljs-string">"#"</span></span>) != <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } .... } .... }</code> </pre> <br>  Wenn Sie mit der Klasse <i>std :: istream arbeiten</i> , <i>reicht</i> es nicht aus, die Funktion <i>eof () aufzurufen</i> , um die Schleife zu beenden.  Die Funktion <i>eof ()</i> gibt immer <i>false zur√ºck,</i> wenn die Daten nicht gelesen werden k√∂nnen und dieser Code keine anderen Endpunkte enth√§lt.  Um die Beendigung der Schleife zu gew√§hrleisten, ist eine zus√§tzliche √úberpr√ºfung des von der Funktion <i>fail () zur√ºckgegebenen</i> Werts erforderlich: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!is.eof() &amp;&amp; !is.fail()) { .... }</code> </pre> <br>  Alternativ kann es wie folgt umgeschrieben werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (is) { .... }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V678</a> Ein Objekt wird als Argument f√ºr seine eigene Methode verwendet.  √úberpr√ºfen Sie das erste tats√§chliche Argument der Funktion 'Kopieren'.  TFormLeafInfo.cxx 2414 <br><br><pre> <code class="cpp hljs">TFormLeafInfoMultiVarDim::TFormLeafInfoMultiVarDim( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TFormLeafInfoMultiVarDim&amp; orig) : TFormLeafInfo(orig) { fNsize = orig.fNsize; fSizes.Copy(fSizes); <span class="hljs-comment"><span class="hljs-comment">// &lt;= fCounter2 = orig.fCounter2?orig.fCounter2-&gt;DeepCopy():0; fSumOfSizes = orig.fSumOfSizes; fDim = orig.fDim; fVirtDim = orig.fVirtDim; fPrimaryIndex = orig.fPrimaryIndex; fSecondaryIndex = orig.fSecondaryIndex; }</span></span></code> </pre> <br>  Beenden wir den Artikel mit diesem netten kleinen Tippfehler.  Die <i>Kopierfunktion</i> sollte mit <i>orig.fSizes aufgerufen werden</i> , nicht mit <i>fSizes</i> . <br><br><h2>  Fazit </h2><br>  Vor ungef√§hr einem Jahr haben wir das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NCBI Genome Workbench-</a> Projekt √ºberpr√ºft, ein weiteres Programm, das in der wissenschaftlichen Forschung zur Genomanalyse eingesetzt wird.  Ich erw√§hne dies, weil die Qualit√§t wissenschaftlicher Software √§u√üerst wichtig ist, Entwickler sie jedoch tendenziell untersch√§tzen. <br><br>  MacOS 10.15 Catalina wurde √ºbrigens neulich ver√∂ffentlicht, wo die Unterst√ºtzung von 32-Bit-Anwendungen eingestellt wurde.  Gl√ºcklicherweise bietet PVS-Studio eine Vielzahl von Diagnosen, die speziell zur Erkennung von Fehlern entwickelt wurden, die mit der Portierung von Programmen auf 64-Bit-Systeme einhergehen.  Weitere Informationen finden Sie in diesem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beitrag</a> des PVS-Studio-Teams. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472492/">https://habr.com/ru/post/de472492/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472482/index.html">Radioaktiver Unfall: Entdeckung einer festen stabilen Phase von Plutonium</a></li>
<li><a href="../de472484/index.html">L√ºcken in einem Kubernetes-Cluster schlie√üen. Bericht und Transkription mit DevOpsConf</a></li>
<li><a href="../de472486/index.html">Langzeitdatenspeicherung. (Artikel - Diskussion)</a></li>
<li><a href="../de472488/index.html">Drei√üig Berichte von DevOops 2019: Tim Lister, Hadi Hariri, Roman Shaposhnik und andere Stars der internationalen DevOps</a></li>
<li><a href="../de472490/index.html">Wie ich mithilfe der Verarbeitung nat√ºrlicher Sprache nach einem Sch√∂nheitsstandard gesucht habe (und ihn nicht gefunden habe)</a></li>
<li><a href="../de472496/index.html">Erstellen eines Sammelalbum-Layouts in CSS Grid</a></li>
<li><a href="../de472502/index.html">SOC ist Menschen: der harte Alltag des Service Managers des Zentrums zur √úberwachung und Reaktion auf Cyber-Angriffe</a></li>
<li><a href="../de472504/index.html">PHP Microservice Framework Swoft: Verwenden Sie die Datenbank Teil 1</a></li>
<li><a href="../de472506/index.html">Wo ist der Fehler, Billy? Wir brauchen einen Fehler ...</a></li>
<li><a href="../de472508/index.html">Flash-Zuverl√§ssigkeit: erwartet und unerwartet. Teil 3. XIV. Konferenz der USENIX Association. Dateispeichertechnologien</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>