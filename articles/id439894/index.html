<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆒 🌙 💅🏻 Cara cukup memantau status situs 🔛 🤮 🚴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Untuk memantau kinerja server dari jarak jauh, para profesional menggunakan sistem perangkat lunak khusus, seperti Zabbix atau Icinga . Tetapi, jika A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara cukup memantau status situs</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439894/"> Untuk memantau kinerja server dari jarak jauh, para profesional menggunakan sistem perangkat lunak khusus, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Zabbix</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Icinga</a> .  Tetapi, jika Anda adalah pemilik pemula atau administrator dari satu atau dua situs web dengan beban kecil, maka tidak perlu untuk sistem pemantauan besar.  Parameter utama adalah apakah situs dengan cepat melayani pengguna.  Oleh karena itu, Anda dapat memantau pekerjaan situs menggunakan program sederhana dari komputer mana pun yang terhubung ke Internet. <br><br><img src="https://habrastorage.org/webt/qx/fj/tq/qxfjtqd07g37gx2eq8ksz80wtfm.jpeg" alt="Foto oleh Mikhail Vasiliev, Unsplash.Com" title="Foto oleh Mikhail Vasiliev, Unsplash.Com"><br><br>  Mari tulis skrip ini sekarang - pemantauan paling sederhana atas ketersediaan dan kecepatan situs.  Program ini bisa dijalankan di komputer rumah, smartphone, dan sebagainya.  Program ini hanya memiliki dua fungsi: <br><br><ul><li>  menunjukkan pada layar waktu di mana situs Anda memberikan halaman kepada pengguna, </li><li>  dalam hal respons lambat dari situs atau kesalahan, program menulis data ke file ("log", atau file log).  Data ini layak diperiksa dari waktu ke waktu untuk memperbaiki masalah ketika mereka baru memulai.  Oleh karena itu, kami akan berhati-hati untuk mencatat log ini dalam bentuk yang jelas dan mudah untuk dilihat cepat. </li></ul><br>  Saya akan menjelaskan setiap langkah secara terperinci sehingga bahkan seorang pemula yang hanya sedikit terbiasa dengan menulis file batch (bat dan cmd pada DOS dan Windows, sh pada sistem seperti UNIX) dapat mengetahuinya tanpa masalah dan dapat menyesuaikan skrip dengan kebutuhannya.  <b>Tetapi saya meminta Anda untuk tidak menggunakan skrip ini tanpa berpikir, karena jika digunakan secara tidak benar, ini mungkin tidak memberikan hasil yang tepat dan, di samping itu, menelan banyak lalu lintas</b> . <br><br>  Saya akan menjelaskan skrip untuk sistem operasi seperti Linux dan penggunaannya pada komputer di rumah.  Dengan prinsip yang sama, ini bisa dilakukan pada platform lain.  Dan bagi mereka yang hanya melihat kemungkinan Linux, satu contoh lagi mungkin menarik, betapa sederhana dan kuatnya skripnya. <br><a name="habracut"></a><br><h3>  1. Organisasi dulu </h3><br>  Kami akan membuat folder terpisah untuk program ini dan membuat 3 file di dalamnya.  Sebagai contoh, saya memiliki folder ini / home / me / Progs / iNet / monitor (di sini saya adalah nama pengguna saya, Progs / iNet adalah folder saya untuk program yang berhubungan dengan Internet, dan monitor adalah nama program ini, dari kata monitor, yaitu. Karena saya adalah satu-satunya pengguna komputer ini, saya menyimpan file-file tersebut di antara folder pribadi saya (/ home) di bagian terpisah dari disk, yang memungkinkan saya untuk menyimpannya ketika menginstal ulang sistem).  Di folder ini akan ada file: <br><br><ul><li>  README.txt - di sini adalah deskripsi (dalam kasus sklerosis): program apa, latar belakang informasi untuk itu, dll. </li><li>  mon.sh - akan ada program yang polling situs. </li><li>  server.log - ini dia akan mencatat indikator status situs.  Dalam kasus kami, ini hanyalah tanggal, waktu, dan durasi respons situs (ditambah informasi tambahan jika server merespons dengan kesalahan dengan permintaan kami). </li></ul><br>  (Untuk kenyamanan mengedit dan, jika ada, memulihkan file, Anda dapat memasukkan folder ini dalam sistem kontrol versi Git; di sini saya tidak akan menjelaskannya). <br><br><h3>  2. Terus-menerus dan santai </h3><br>  Kami akan menjalankan file mon.sh dengan interval kecil reguler, misalnya, 60 detik.  Saya menggunakan alat standar yang disediakan oleh sistem operasi (lebih tepatnya, lingkungan desktop). <br><br>  Lingkungan Desktop saya adalah Xfce.  Ini adalah salah satu opsi paling populer untuk Linux.  Saya suka Xfce karena memungkinkan Anda untuk hampir sepenuhnya menyesuaikan seluruh lingkungan - seperti yang Anda suka.  Pada saat yang sama, Xfce agak lebih kompak dan lebih cepat daripada dua sistem terkenal lainnya - Gnome dan KDE.  (Pilihan lain juga menarik - misalnya, lingkungan LXDE bahkan lebih cepat dan lebih mudah daripada Xfce, tetapi sejauh ini tidak begitu kaya fitur). <br><br>  Alat yang kami butuhkan, dalam kasus Xfce, adalah plug-in untuk panel kerja Generic Monitor.  Biasanya sudah terinstal, tetapi jika tidak, Installer akan dengan mudah menemukannya: "Genmon" (deskripsi: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">xfce4-genmon-plugin</a> ).  Ini adalah plugin yang dapat ditambahkan ke panel dan diatur dalam pengaturan: (1) perintah yang akan dieksekusi dan (2) frekuensi eksekusi dalam hitungan detik.  Dalam kasus saya, perintah: <br><br>  /home/me/Progs/iNet/monitor/mon.sh <br><br>  (atau, yang setara, ~ / Progs / iNet / monitor / mon.sh). <br><br><img src="https://habrastorage.org/webt/2w/pc/sz/2wpcszhqlfhyao4_qg6bpkrillw.png" alt="Genmon" title="Genmon"><br><br><h3>  3. Ketika program belum ada kesalahan </h3><br>  Jika Anda telah menyelesaikan semua langkah ini sekarang - membuat file dan meluncurkan plug-in di panel - maka Anda melihat hasil dari peluncuran program kami di sana (pesan kesalahan: file mon.sh bukan program).  Kemudian, untuk membuat file dapat dieksekusi, buka folder kami dan atur izin untuk menjalankan - <ul><li>  atau pengelola file: Properti - Izin - Izinkan file ini dijalankan sebagai program; </li><li>  atau perintah dari terminal: <b>chmod 755 mon.sh</b> </li></ul><br>  Dan dalam file itu sendiri, kita menulis baris pertama: <br><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # Monitor server responses (run this every 60 seconds): # info=$(curl -I -o /dev/stdout -w '%{time_total}' --url https://example.ru/ -m 9 -s) errr=$(echo $?)</span></span></code> </pre> <br>  Alih-alih "example.ru" menggantikan nama situs Anda, negara yang akan Anda amati.  Dan jika itu bekerja di http, masukkan http bukan https.  Baris #! / Bin / bash berarti ini adalah skrip yang akan diluncurkan oleh program Bash ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bash</a> mungkin yang paling umum untuk mengeksekusi skrip di Linux).  Untuk bekerja melalui shell lain, ini ditunjukkan sebagai ganti Bash.  Baris yang tersisa dengan tajam di awal adalah komentar.  Baris pertama dari kode itu sendiri adalah <b>info = $ ()</b> dan dalam tanda kurung ini adalah perintah curl dengan parameter.  Konstruksi seperti itu - something = $ (something) - berarti "jalankan perintah dalam tanda kurung dan tetapkan hasilnya ke variabel di sebelah kiri."  Dalam hal ini, saya menamakan variabel "info".  Perintah ini dalam tanda kurung - curl (dalam jargon disebut oleh beberapa orang sebagai "Kurl") - mengirimkan permintaan ke jaringan di alamat yang ditentukan dan mengembalikan respons server kepada kami.  (Kenalan saya berkata, menjelaskan: "Bagaimana derek itu mendengus - dan menerima respons dari beberapa derek lain di langit.")  Pertimbangkan opsi: <br><br><pre> <code class="bash hljs">curl -I -o /dev/stdout -w <span class="hljs-string"><span class="hljs-string">'%{time_total}'</span></span> --url https://example.ru/ -m 9 -s</code> </pre><br>  <b>-Aku</b> berarti bahwa kami tidak meminta seluruh halaman, tetapi hanya "HTTP header" -nya.  Setiap kali kami tidak membutuhkan seluruh teks halaman untuk memastikan bahwa situs tersebut berfungsi.  Karena kita akan sering memeriksa situs, penting untuk membuat ukuran data yang dikirimkan sekecil mungkin.  Ini menghemat lalu lintas, dan listrik, dan beban di server - dan satwa liar. <br><br>  Omong-omong, perhatikan berapa banyak lalu lintas cadangan yang Anda miliki (tidak digunakan per bulan) di hosting.  Di bawah ini Anda akan melihat berapa banyak data yang dikirimkan dan Anda dapat menghitung jika Anda memiliki cadangan yang cukup;  jika ada, periode verifikasi situs dapat ditingkatkan menjadi 5, 10, atau bahkan 30-60 menit.  Meskipun dalam hal ini gambar tidak akan begitu lengkap - dan gangguan kecil mungkin tidak diperhatikan;  tetapi, secara umum, saat memantau situs, lebih penting untuk mendeteksi masalah jangka panjang daripada gangguan tunggal.  Juga, lalu lintas apa yang dapat Anda beli di komputer pemanggil?  Dalam kasus saya - PC desktop dengan lalu lintas tanpa batas - ini tidak begitu penting;  tetapi untuk perangkat seluler atau tarif dengan batasan, ada baiknya menghitung dan, mungkin, meningkatkan interval inspeksi. <br><br><h3>  4. Langkah mengikuti langkah kecuali langkah pertama </h3><br>  Mari kita melangkah lebih jauh: <b>-o / dev / stdout</b> berarti "mengirim respons yang diterima oleh Kurl dari server ke file ini dan itu."  Dan dalam hal ini, ini bukan file pada disk, tetapi / dev / stdout - Perangkat output standar.  Biasanya "perangkat output standar" adalah layar kita di mana kita dapat melihat hasil program.  Namun dalam skrip, kita sering mengarahkan "output standar" ini untuk diproses lebih lanjut (sekarang - simpan ke variabel info).  Dan kemudian kita akan, paling sering, mengirim hasil tim ke variabel, atau meneruskannya ke tim berikutnya dalam sebuah rantai.  Untuk membuat rantai dari perintah, gunakan operator pipa ("Pipa"), ditampilkan sebagai bilah vertikal ("|"). <br><br>  <b>-w '% {time_total} eyayu'</b> : di sini -w berarti "memformat dan memberikan informasi tambahan ini dan itu ke perangkat output standar."  Secara khusus, kami tertarik pada time_total - berapa lama waktu yang dibutuhkan oleh permintaan-tanggapan antara kami dan server.  Anda mungkin tahu bahwa ada perintah yang lebih sederhana, ping, untuk dengan cepat meminta server dan mendapatkan respons darinya, pong.  Tetapi Ping hanya memeriksa apakah server hostingnya hidup, dan sinyalnya bolak-balik begitu lama.  Ini menunjukkan kecepatan akses maksimum, tetapi masih tidak memberi tahu kami apa pun tentang seberapa cepat situs menghasilkan konten nyata.  Ping dapat bekerja dengan cepat, dan pada saat yang sama, situs dapat melambat atau tidak berfungsi sama sekali - karena beban tinggi atau beberapa masalah internal.  Oleh karena itu, kami menggunakan Kurla persis dan mendapatkan waktu aktual server menampilkan konten kami. <br><br>  (Dan dengan parameter ini Anda dapat menilai apakah server bekerja dengan efisien untuk tugas Anda, apakah waktu respons tipikalnya nyaman bagi pengguna. Apakah ada masalah - misalnya, situs saya di banyak situs hosting telah melambat dari waktu ke waktu, dan saya harus mencari hosting lain). <br><br>  Pernahkah Anda memperhatikan huruf aneh "eyu" setelah {time_total}?  Saya menambahkannya sebagai label unik, yang mungkin tidak akan berada di tajuk yang dikirimkan kepada kami dari server (walaupun dengan asumsi bahwa pengguna program Anda akan dan tidak akan buruk dan jalan menuju jurang. Jangan lakukan ini! .. Atau, ketika Anda melakukannya , setidaknya malu pada Anda).  Dengan label ini (saya harap) kita dapat dengan mudah menarik potongan informasi yang kita butuhkan dari sejumlah baris dalam variabel info.  Jadi, <b>curl -w '% {time_total} ehayu'</b> (dengan parameter yang tersisa benar) akan memberi kita sesuatu seperti: <br><br>  0.215238eyayu <br><br>  Ini adalah jumlah detik yang diperlukan untuk mengakses situs, ditambah label kami.  (Selain parameter ini, dalam variabel info, kami akan lebih tertarik pada "Kode status" - kode status, atau, sederhana saja, kode respons server. Biasanya, ketika server mengeluarkan file yang diminta, kode itu adalah "200". Ketika halaman tidak ditemukan , ini adalah 404 yang terkenal. Ketika ada kesalahan pada server, paling sering 500 dengan sesuatu). <br><br><img src="https://habrastorage.org/webt/ka/rc/nk/karcnk8ggbptl5raex3j67k_aea.jpeg" alt="404" title="404"><br><br><h3>  5. Kreativitas - bapak pengujian diri </h3><br>  Parameter yang tersisa dari curl kami adalah sebagai berikut: <br><br><pre> <code class="bash hljs">--url https://example.ru/ -m 9 -s</code> </pre> <br>  apa artinya: untuk meminta alamat ini dan itu;  waktu respons maksimum adalah 9 detik (Anda dapat menetapkan lebih sedikit, karena pengguna yang jarang akan menunggu respons dari situs begitu lama, ia akan dengan cepat menemukan situs tidak berfungsi).  Dan "-s" berarti diam, yaitu, ikal tidak akan memberi tahu kami detail yang tidak perlu. <br><br>  Ngomong-ngomong, biasanya tidak ada banyak ruang pada panel desktop, oleh karena itu, untuk debugging skrip, lebih baik untuk menjalankannya dari terminal (dalam foldernya menggunakan perintah ./mon.sh).  Dan untuk plugin panel kami, kami akan memberi jeda yang lama antara peluncuran perintah - katakanlah, 3600 detik. <br><br>  Untuk debugging, kita dapat menjalankan ikal ini tanpa membingkai tanda kurung dan melihat apa yang dihasilkannya.  (Dari ini dan hitung konsumsi lalu lintas).  Kita akan melihat terutama satu set header HTTP, seperti: <br><br><pre> <code class="plaintext hljs">HTTP/1.1 302 Found Server: QRATOR Date: Sun, 11 Feb 2019 08:06:57 GMT Content-Type: text/html; charset=UTF-8 Connection: keep-alive Keep-Alive: timeout=15 X-Powered-By: PHP/7.2.14-1+ubuntu16.04.1+deb.sury.org+1 Location: https://habr.com/ru/ X-Frame-Options: SAMEORIGIN X-Content-Type-Options: nosniff Strict-Transport-Security: max-age=63072000; includeSubDomains; preload X-Cache-Status: HIT 0.033113</code> </pre><br>  Baris pertama di sini kita melihat "HTTP / 1.1 302 Found" - yang berarti: protokol transfer data adalah "HTTP / 1.1", kode respons server adalah "302 Found".  Saat meminta halaman lain, ini mungkin kode "301 Pindah Permanen", dll.  Dalam contoh lebih lanjut, respons normal server saya adalah "HTTP / 2 200".  Jika server Anda biasanya merespons secara berbeda, gantikan jawaban ini alih-alih “HTTP / 2 200” dalam skrip ini. <br><br>  Baris terakhir, seperti yang kita lihat, Kurl memberi, dalam berapa detik kita menerima respons server, dengan label yang ditugaskan kepada kita. <br><br>  Menarik: kami dapat mengonfigurasi situs sehingga melaporkan permintaan kami (dan hanya pada mereka!) Informasi tambahan tentang kondisinya - misalnya, di header HTTP "buatan sendiri".  Katakanlah apa beban pada prosesor situs, berapa banyak memori bebas dan ruang disk yang dimilikinya, dan seberapa cepat database berfungsi.  (Tentu saja, untuk ini situs harus dinamis, yaitu, permintaan harus diproses oleh program - dalam PHP, Node.JS, dll. Pilihan lain adalah menggunakan perangkat lunak khusus di server).  Tapi mungkin kita belum benar-benar membutuhkan detail ini.  Tujuan dari skrip ini adalah hanya untuk secara teratur memantau kinerja situs secara keseluruhan.  Dalam hal terjadi masalah - kami akan menangani diagnostik dengan cara lain.  Oleh karena itu, sekarang kami menulis skrip paling sederhana yang akan berfungsi untuk situs mana pun, bahkan yang statis, dan tanpa pengaturan tambahan di server.  Di masa depan, jika diinginkan, dimungkinkan untuk memperluas kemampuan skrip;  sementara itu, jadikan dasar. <br><br>  String <b>errr = $ (echo $?)</b> Berarti: tulis hasil dari perintah "echo $?" Ke variabel errr.  Perintah echo berarti mencetak beberapa teks pada perangkat keluaran standar (stdout), dan karakter "$?"  - Ini adalah kode kesalahan saat ini (tersisa dari perintah sebelumnya).  Jadi, jika curl kami tiba-tiba tidak dapat mencapai server, itu akan memberikan kode kesalahan non-nol, dan kami akan mengetahuinya dengan memeriksa variabel errr. <br><br><h3>  6. Kegunaan </h3><br>  Di sini saya ingin membuat penyimpangan kecil dari masalah teknis untuk membuat membaca teks lebih menarik.  (Jika Anda tidak setuju, lewati tiga paragraf).  Saya akan mengatakan bahwa semua aktivitas manusia sesuai dengan caranya sendiri.  Bahkan ketika seseorang dengan sengaja memukul dahinya ke dinding (atau di lantai ... pada keyboard ...), ini memiliki kebijaksanaannya sendiri.  Misalnya, ia menyediakan jalan keluar bagi energi emosional - mungkin bukan dengan cara "terbaik", tetapi bagaimana ia bisa.  (Ya, dan konsep "terbaik" tidak ada gunanya dari sudut pandang <i>saat ini di tempat ini</i> - karena yang terbaik dan terburuk hanya mungkin dibandingkan dengan yang lain). <br><br>  Saya menulis teks ini sekarang, daripada kasus yang tampaknya lebih penting bagi saya - mengapa?  Pertama, untuk mengambil stok, meninjau dan secara internal memilah-milah rak dari apa yang saya pelajari dalam menulis skrip selama dua hari ini ... Hapus dari RAM dan simpan.  Kedua, dengan cara ini saya sedikit istirahat ... Ketiga, saya berharap penjelasan yang dikunyah ini bermanfaat bagi orang lain (dan saya sendiri, mungkin suatu hari nanti).  Bagaimana, tidak masalah jika yang terbaik, tetapi pengingat yang berbeda pada subjek skrip dan permintaan server. <br><br>  Seseorang, mungkin, akan mengoreksi saya dalam sesuatu, dan hasilnya akan menjadi lebih baik.  Seseorang akan mendapatkan informasi yang bermanfaat.  Apakah ini pantas?  Mungkin ... inilah yang bisa saya lakukan sekarang dan saya sedang melakukannya.  Besok, mungkin saya akan bangun dan mengevaluasi kembali tindakan saat ini ... tetapi penilaian ulang ini juga akan memberikan sesuatu yang berguna untuk kehidupan selanjutnya. <br><br>  Jadi, setelah memenuhi permintaan, kami memiliki dua bagian data: <br><br><ul><li>  blok utama informasi dari server (jika, tentu saja, respons server datang), kami menulisnya ke dalam variabel info; </li><li>  kode kesalahan perintah curl (0, jika tidak ada kesalahan) - ditulis ke variabel errr. </li></ul><br>  Tepatnya karena kedua total - baik info dan kode kesalahan - diperlukan, saya menulisnya ke dalam variabel, dan tidak segera meneruskan total Kurl ke tim lain melalui Pipe.  Tapi sekarang dalam skrip ini saatnya untuk memanjat pipa: <br><br><pre> <code class="bash hljs">code=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$info</span></span></span><span class="hljs-string">"</span></span> | grep HTTP | grep -v <span class="hljs-string"><span class="hljs-string">'HTTP/2 200'</span></span>) date=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$info</span></span></span><span class="hljs-string">"</span></span> | grep -i <span class="hljs-string"><span class="hljs-string">'date:'</span></span>) dlay=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$info</span></span></span><span class="hljs-string">"</span></span> | grep  | sed -e <span class="hljs-string"><span class="hljs-string">'s///'</span></span>)</code> </pre><br>  Di setiap baris ini kita menulis variabel lain - kita menyimpan hasil dari eksekusi perintah.  Dan dalam setiap kasus itu bukan satu tim, tetapi sebuah rantai;  tautan pertama adalah sama di mana-mana: <b>echo "$ info"</b> - mengembalikan ke aliran perangkat keluaran standar (stdout) blok informasi yang kami simpan, terima dari curl.  Lebih jauh ke bawah pipa, aliran ini diteruskan ke perintah grep.  Grep memilih dari semua garis hanya yang cocok dengan pola.  (Opsi -i berarti "tidak sensitif huruf").  Seperti yang Anda lihat, dalam kasus pertama kita memilih baris yang berisi "HTTP".  Baris ini, ditarik dari tumpukan yang lain, dilewatkan melalui pipa ke perintah <b>grep -v 'HTTP / 2 200'</b> .  Di sini, <b>opsi -v</b> adalah kebalikan dari opsi <b>-e</b> , itu menyaring garis di mana pola seperti itu ditemukan.  Total, dalam variabel kode akan ada garis dengan kode respons server (seperti "HTTP / 1.1 302 Found"), tetapi hanya jika bukan 'HTTP / 2 200'.  Jadi saya menyaring baris yang dikirim situs saya dalam kasus normal, dan hanya menyimpan jawaban "tidak normal".  (Jika Anda memiliki respons server normal, gantikan di sana). <br><br>  Demikian pula, pada tanggal variabel kita menulis baris di mana server mengeluarkan tanggal dan waktu saat ini.  Ini adalah sesuatu seperti " <b>date: Sun, 11 Feb 2019 08:06:57 GMT</b> " (biasanya di zona waktu GMT, alias UTC).  Kita perlu menulis tanggal (tetapi hanya sekali sehari!) Dalam file log kita ("server status log") - server.log.  Dan pada saat yang sama kami akan menampilkan waktu ini di layar.  Anda dapat menulis tanggal-waktu ke log dari komputer Anda, tetapi untuk kenyamanan kami mengambilnya, karena server tetap mengirimkannya. <br><br>  Ini mirip dengan variabel ketiga kami, dlay (dari kata Inggris delay - delay).  Kami memilih baris di label tender kami "eeyu" di mana kami menyimpan durasi menunggu jawaban dari server.  Kami menghapus label ini, yang tidak lagi diperlukan, menggunakan perintah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sed</a> - dan menyimpan hasilnya. <br><br>  Sekarang, jika kita mencetak variabel-variabel ini untuk verifikasi - misalnya, menambahkan baris ke skrip kita: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'errr: %s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$errr</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'code: %s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$code</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$date</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'dlay: %s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dlay</span></span></span><span class="hljs-string">"</span></span></code> </pre><br>  Anda harus mendapatkan sesuatu seperti: <br><br><pre> <code class="plaintext hljs">errr: 0 code: date: Mon, 11 Feb 2019 12:46:18 GMT dlay: 0.236549</code> </pre><br>  Total: kode kesalahan curl adalah nol (yang berarti itu berfungsi dengan baik).  Kode status server - tidak direkam (seperti biasa).  Tanggal dan waktu.  Durasi respons.  Tetap menampilkan dengan benar apa yang Anda butuhkan di layar dan, jika perlu, menulis ke file. <br><br>  Ini yang paling menarik: apa, dalam kondisi apa dan bagaimana cara merekam? <br><br><h3>  7. Kesimpulan yang rumit </h3><br>  Agar tidak membuat Anda bosan dengan lebih banyak detail, saya akan memberi tahu Anda secara singkat (dan ada cukup <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">direktori yang bagus</a> pada semua perintah ini di Internet).  Omong-omong, singkatnya adalah salah satu tujuan utama yang akan kita capai ketika menulis ke log ini.  Maka akan nyaman untuk dilihat, dan tidak akan pernah mengambil banyak ruang disk (tidak seperti log lain yang tumbuh dalam megabyte per hari). <br><br>  Pertama: kami pastikan untuk menulis tanggal hanya sekali, dan tidak pada setiap baris.  Untuk melakukan ini, pilih dari tanggal variabel kami secara individual tanggal saat ini (arus) dan waktu (waktu): <br><br><pre> <code class="bash hljs">curr=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$date</span></span></span><span class="hljs-string">"</span></span> | sed -e <span class="hljs-string"><span class="hljs-string">'s/\(20[0-9][0-9]\).*$/\1/'</span></span>) time=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$date</span></span></span><span class="hljs-string">"</span></span> | sed -e <span class="hljs-string"><span class="hljs-string">'s/^.*\ \([0-9][0-9]:.*\)\ GMT\r$/\1/'</span></span>)</code> </pre><br>  Dan kami juga mempertimbangkan baris dengan tanggal dari file log dan mengambil tanggal terakhir (sebelumnya): <br><br><pre> <code class="bash hljs">prev=$(cat /home/me/Progs/iNet/monitor/site.log | grep -e <span class="hljs-string"><span class="hljs-string">'date:'</span></span> | tail -1)</code> </pre><br>  Jika tanggal kami saat ini (arus) tidak sama dengan yang sebelumnya (dari file, sebelumnya), maka hari baru telah datang (atau, katakanlah, file log kosong);  kemudian tulis tanggal baru ke file: <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">$curr</span></span> != <span class="hljs-variable"><span class="hljs-variable">$prev</span></span> ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$curr</span></span></span><span class="hljs-string">"</span></span> &gt;&gt;/home/me/Progs/iNet/monitor/site.log <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s %s %s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$time</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dlay</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$code</span></span></span><span class="hljs-string">"</span></span> &gt;&gt;/home/me/Progs/iNet/monitor/site.log</code> </pre><br>  ... dan pada saat yang sama kami mencatat informasi saat ini: waktu, keterlambatan dalam menerima respons dari situs, kode respons situs (jika tidak biasa): <br><br><pre> <code class="bash hljs"> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s %s %s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$time</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dlay</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$code</span></span></span><span class="hljs-string">"</span></span> &gt;&gt;/home/me/Progs/iNet/monitor/site.log</code> </pre><br>  Ini akan membantu menavigasi: hari ini dan itu dimulai dengan kecepatan situs ini dan itu.  Dalam kasus lain, jangan mengacaukan file dengan entri yang tidak perlu.  Tentu saja, kami akan menuliskannya jika kami mendapatkan kode status server yang tidak biasa: <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> [[ -n <span class="hljs-variable"><span class="hljs-variable">$code</span></span> ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s %s %s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$time</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dlay</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$code</span></span></span><span class="hljs-string">"</span></span> &gt;&gt;/home/me/Progs/iNet/monitor/site.log</code> </pre><br>  Dan juga tulis jika waktu respons server lebih lama dari biasanya.  Situs saya biasanya bertanggung jawab untuk 0,23-0,25 detik, jadi saya mencatat jawaban yang membutuhkan waktu lebih dari 0,3 detik: <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> (( $(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dlay</span></span></span><span class="hljs-string"> &gt; 0.3"</span></span> | bc -l) )); <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s %s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$time</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dlay</span></span></span><span class="hljs-string">"</span></span> &gt;&gt;/home/me/Progs/iNet/monitor/site.log</code> </pre><br>  Akhirnya, sekali satu jam, saya hanya merekam waktu yang diterima dari server - sebagai tanda bahwa itu hidup, dan pada saat yang sama sebagai semacam markup file: <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$time</span></span></span><span class="hljs-string">"</span></span> | grep -e :00: | cat &gt;&gt;/home/me/Progs/iNet/monitor/site.log <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre><br>  Kami mendapatkan konten file di mana markup dengan catatan per jam membantu secara visual, tanpa membaca, untuk melihat kapan beban lebih tinggi atau lebih rendah (lebih banyak catatan per jam): <br><br><pre> <code class="plaintext hljs">19:42:28 0.461214 19:53:29 0.443956 20:00:29 20:09:30 2.156462 20:10:29 0.358294 20:45:29 0.313378 20:51:30 0.563886 20:54:30 0.307219 21:00:30 0.722343 21:01:30 0.310284 21:09:30 0.379662 21:10:31 1.305779 21:12:35 5.799455 21:23:31 1.054537 21:24:31 1.230391 21:40:31 0.461266 21:42:37 7.140093 22:00:31 22:12:37 5.724768 22:14:31 0.303500 22:42:37 5.735173 23:00:32 23:10:32 0.318207 date: Mon, 11 Feb 2019 00:00:34 0.235298 00:01:33 0.315093 01:00:34 01:37:41 5.741847 02:00:36 02:48:37 0.343234 02:56:37 0.647698 02:57:38 1.670538 02:58:39 2.327980 02:59:37 0.663547 03:00:37 03:40:38 0.331613 04:00:38 04:11:38 0.217022 04:50:39 0.313566 04:55:45 5.719911 05:00:39</code> </pre><br>  Dan akhirnya, kami menampilkan informasi di layar.  Dan juga, jika curl gagal, kami menampilkan dan menulis pesan tentang hal itu (dan pada saat yang sama menjalankan Ping dan masuk untuk memeriksa apakah server masih hidup sama sekali): <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s\n%s\n%s'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$time</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dlay</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$code</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (( <span class="hljs-variable"><span class="hljs-variable">$errr</span></span> != 0 )); <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> date &gt;&gt;/home/me/Progs/iNet/monitor/site.log date <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'CURL Request failed. Error: %s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$errr</span></span></span><span class="hljs-string">"</span></span> &gt;&gt;/home/me/Progs/iNet/monitor/site.log <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'CURL Request failed. Error: %s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$errr</span></span></span><span class="hljs-string">"</span></span> pung=$(ping -c 1 178.248.237.68) <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'Ping: %s\n----\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pung</span></span></span><span class="hljs-string">"</span></span> &gt;&gt;/home/me/Progs/iNet/monitor/site.log <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'Ping: %s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pung</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre><br>  Ganti alamat IP dalam string ping dengan alamat IP asli situs Anda. <br><br><h3>  8. Kata Penutup </h3><br>  Hasil pekerjaan: <br><br><img src="https://habrastorage.org/webt/hk/zs/v-/hkzsv-3j9g-cv-wqklt2szu37hk.jpeg" alt="Monitor situs web paling sederhana" title="Monitor situs web paling sederhana"><br><br>  Di sebelah kiri pada panel Anda dapat melihat waktu dalam UTC dan respon situs saat ini.  Di sebelah kanan adalah log: itu terlihat oleh reli, bahkan dengan bergulir sepintas, selama jam berapa beban lebih atau kurang.  Anda juga dapat melihat respons lambat yang tidak normal (puncak; meskipun belum jelas dari mana asalnya). <br><br>  Itu saja.  Skripnya ternyata sederhana, ek, dan dapat ditingkatkan: bekerja pada pengoptimalan, portabilitas, peningkatan pemberitahuan dan tampilan, dengan mempertimbangkan proksi dan cache ... <br><br>  Namun sudah dalam jenis program ini, mungkin dapat memberikan gambaran tentang kondisi situs Anda.  Dan biarlah itu menjadi situs yang sesuai dengan bijak, berguna untuk orang dan semua makhluk! <br><br><div class="spoiler">  <b class="spoiler_title">Teks lengkap skrip dengan komentar.</b>  <b class="spoiler_title">Jangan lupa untuk melakukan perubahan yang diperlukan!</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # Monitor server responses (run this every 60 seconds): info=$(curl -I -o /dev/stdout -w '%{time_total}' --url https://example.ru/ -m 9 -s) errr=$(echo $?) # errr = CURL error code https://curl.haxx.se/libcurl/c/libcurl-errors.html code=$(echo "$info" | grep HTTP | grep -v 'HTTP/2 200') date=$(echo "$info" | grep -i 'date:') dlay=$(echo "$info" | grep  | sed -e 's///') # code = Response code = 200? # =&gt; empty, otherwise response code string # # date = from HTTP Header of the server responded, like: # Date: Sun, 10 Feb 2019 05:01:50 GMT # # dlay = Response delay ("time_total") from CURL, like: # 0.25321 #printf 'errr: %s\n' "$errr" #printf 'code: %s\n' "$code" #printf '%s\n' "$date" #printf 'dlay: %s\n' "$dlay" curr=$(echo "$date" | sed -e 's/\(20[0-9][0-9]\).*$/\1/') time=$(echo "$date" | sed -e 's/^.*\ \([0-9][0-9]:.*\)\ GMT\r$/\1/') prev=$(cat /home/me/Progs/iNet/monitor/site.log | grep -e 'date:' | tail -1) # = Previously logged date, like: # date: Sun, 10 Feb 2019 # Day logged before vs day returned by the server; usually the same if [[ $curr != $prev ]]; then # Write date etc., at the beginning of every day: printf '%s\n' "$curr" &gt;&gt;/home/me/Progs/iNet/monitor/site.log printf '%s %s %s\n' "$time" "$dlay" "$code" &gt;&gt;/home/me/Progs/iNet/monitor/site.log elif [[ -n $code ]]; then # If the response had HTTP error code - log it: printf '%s %s ? %s\n' "$time" "$dlay" "$code" &gt;&gt;/home/me/Progs/iNet/monitor/site.log elif (( $(echo "$dlay &gt; 0.3" | bc -l) )); then # If the response delay was large - log it: printf '%s %s %s\n' "$time" "$dlay" "$code" &gt;&gt;/home/me/Progs/iNet/monitor/site.log else # If it's the start of an hour - just log the time echo "$time" | grep -e :00: | cat &gt;&gt;/home/me/Progs/iNet/monitor/site.log fi # To screen: printf '%s\n%s\n%s' "$time" "$dlay" "$code" # On CURL error: if (( $errr != 0 )); then date &gt;&gt;/home/me/Progs/iNet/monitor/site.log date printf 'CURL Request failed. Error: %s\n' "$errr" &gt;&gt;/home/me/Progs/iNet/monitor/site.log printf 'CURL Request failed. Error: %s\n' "$errr" pung=$(ping -c 1 178.248.237.68) printf 'Ping: %s\n----\n' "$pung" &gt;&gt;/home/me/Progs/iNet/monitor/site.log printf 'Ping: %s\n' "$pung" fi</span></span></code> </pre><br></div></div><br><br>  <b>PS.</b>  <b>Mengikuti diskusi</b> (pada 02/12/2019): <br><br>  Seperti yang saya harapkan, para ahli menulis banyak komentar menarik. <br><br>  Setelah memikirkannya, saya dapat menjawab pertanyaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">rsashka</a> , apa keuntungan dari skrip ini. <br><br>  Alat-alat lain, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NetData</a> (terima kasih kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">tchspprt</a> untuk tipnya!), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Menyediakan</a> sejumlah besar data yang tidak akan disimpan lama.  NetData adalah alat yang baik ketika Anda bekerja setiap hari, mengelola situs web secara profesional.  Baik untuk mendiagnosis masalah saat ini. <br><br>  Script seperti milik saya adalah untuk mengawasi saat melakukan hal-hal lain.  Script tidak memerlukan studi dan pengaturan khusus.  Ini tidak buruk bagi orang awam.  Dan log-nya mengambil ruang sangat sedikit sehingga mereka tidak bisa dihapus sama sekali.  Mereka dapat terakumulasi selama bertahun-tahun, dan pada tahun N +1 Anda dapat melihat: "Wow, pada 2019, waktu respons saya satu setengah kali lebih rendah! .." <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artinya, solusi semacam itu memiliki ceruk tersendiri - terutama untuk administrator non-sistem yang terus-menerus. (Seperti yang dikatakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tchspprt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : "Ini tentang cara memberi makan kucing tetangga saat liburan"). </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">andreymal</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menyarankan cara yang menarik untuk memperhitungkan dan kemudian melihat beban situs, tanpa dana tambahan, cukup melalui log akses di situs. Dan Anda dapat membangun grafik yang indah di atasnya. Saya mungkin akan mencoba opsi ini dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memposting</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">Github</font></a><font style="vertical-align: inherit;"> apa yang terjadi. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unfforgiven</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menyarankan solusi lain yang menarik - mungkin solusi sederhana (instal prometheus, blackbox dan alermanager via docker composer). Pada VPS saya yang sederhana dan murah tidak cukup untuk memori ini; dan Linux dengan kernel lama - Docker tidak akan mulai. Tapi terima kasih untuk opsinya! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tip lain</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tchspprt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Grafit + Prometheus + Grafana. </font><font style="vertical-align: inherit;">Atau sediakan skrip dengan grafis yang indah (gnuplot atau rrdtool). </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mcalexvrn</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> merekomendasikan alat sederhana: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uptimerobot</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font> Terima kasih <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya berterima kasih kepada semua orang atas sederetan informasi! </font><font style="vertical-align: inherit;">Biarkan itu bermanfaat bagi orang ...</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id439894/">https://habr.com/ru/post/id439894/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id439882/index.html">Petualangan dengan ptrace (2)</a></li>
<li><a href="../id439884/index.html">Bagaimana menolak buletin yang tidak perlu dengan satu tombol. Pengalaman Tim Yandex.Mail</a></li>
<li><a href="../id439886/index.html">Bagaimana saya mengajar jaringan saraf untuk mengimplementasikan fungsi penilaian posisi di Russian AI Cup CodeBall 2018</a></li>
<li><a href="../id439890/index.html">Keterampilan 100% atau kurang.</a></li>
<li><a href="../id439892/index.html">Cara merencanakan selama satu tahun. Studi kasus perusahaan TI 120 orang dan dua praktik untuk tim kecil</a></li>
<li><a href="../id439896/index.html">Etika kontribusi otomatis</a></li>
<li><a href="../id439898/index.html">VBA dan Python untuk otomatisasi Excel dan MS Office</a></li>
<li><a href="../id439900/index.html">Julia dan metode penurunan koordinat</a></li>
<li><a href="../id439902/index.html">Penjelasan sifat fisik dari fenomena "Lift Force of the Wing" tanpa menggunakan persamaan Bernoulli. Bagian 2</a></li>
<li><a href="../id439906/index.html">Kerentanan Penting dalam Produk Antivirus Zemana dan Banyak Lagi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>