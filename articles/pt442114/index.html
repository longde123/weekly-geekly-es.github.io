<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë≤üèº üìõ üë®üèæ‚Äçüè´ Guia para a auditoria autom√°tica de contratos inteligentes. Parte 3: Mitrilo üññüèæ üîç üë©üèª‚Äçü§ù‚Äçüë®üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Advert√™ncia 


 Este artigo n√£o √© uma classifica√ß√£o da efic√°cia dos analisadores autom√°ticos. Eu os aplico aos meus pr√≥prios contratos, intencionalmen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guia para a auditoria autom√°tica de contratos inteligentes. Parte 3: Mitrilo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442114/"><h2 id="warning">  <strong>Advert√™ncia</strong> </h2><br><p>  Este artigo n√£o √© uma classifica√ß√£o da efic√°cia dos analisadores autom√°ticos.  Eu os aplico aos meus pr√≥prios contratos, intencionalmente sintetizando erros e estudo as rea√ß√µes.  Esse estudo n√£o pode ser a base para determinar ‚Äúmelhor ou pior‚Äù; para isso, faz sentido realizar um estudo cego em uma grande amostra de contratos, o que, dada a natureza caprichosa desse tipo de software, √© extremamente dif√≠cil.  √â bem poss√≠vel que um pequeno erro no contrato possa desabilitar uma grande parte da l√≥gica do analisador, e um simples sinal heur√≠stico pode adicionar uma quantidade enorme de pontos ao analisador, encontrando um bug generalizado que os concorrentes simplesmente n√£o conseguiram adicionar.  Erros na prepara√ß√£o e compila√ß√£o de contratos tamb√©m podem desempenhar um papel.  Todo o software em quest√£o √© bastante jovem e est√° sendo constantemente desenvolvido, portanto, n√£o tome coment√°rios cr√≠ticos como problemas irrepar√°veis. </p><br><p> O objetivo do artigo √© fornecer ao leitor uma compreens√£o de como os m√©todos de an√°lise de c√≥digo em diferentes analisadores funcionam e a capacidade de us√°-los corretamente, em vez de "fazer uma escolha".  Uma escolha razo√°vel √© usar v√°rias ferramentas ao mesmo tempo, com foco nas mais adequadas para o contrato analisado. </p><a name="habracut"></a><br><h2 id="nastroyka-i-podgotovka-k-zapusku">  <strong>Configura√ß√£o e prepara√ß√£o para o lan√ßamento</strong> </h2><br><p>  O Mythril usa v√°rios tipos de an√°lise de uma s√≥ vez, eis alguns bons artigos sobre o assunto: o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mais importante</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">isto</a> ou aquilo.  Antes de continuar, faz sentido l√™-los. </p><br><p>  Primeiro, vamos criar nossa pr√≥pria imagem do Mythril no Docker (n√£o importa o que queremos mudar?): </p><br><pre><code class="plaintext hljs">git clone https://github.com/ConsenSys/mythril-classic.git cd mythril-classic docker build -t myth .</code> </pre> <br><p>  Agora tente execut√°-lo em nossos <code>contracts/flattened.sol</code> (eu uso o mesmo contrato discutido na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">introdu√ß√£o</a> ), no qual existem dois contratos principais, <code>Ownable</code> pelo Zeppelin e nosso <code>Booking</code> .  Ainda temos um problema com a vers√£o do compilador, eu a corrigi da mesma maneira que no artigo anterior, adicionando linhas ao Dockerfile que substituir√° a vers√£o do compilador: </p><br><pre> <code class="plaintext hljs">COPY --from=ethereum/solc:0.4.20 /usr/bin/solc /usr/bin</code> </pre> <br><p>  Ap√≥s reconstruir a imagem, voc√™ pode tentar executar a an√°lise de contrato.  Imediatamente vamos usar os sinalizadores <code>-v4</code> e <code>--verbose-report</code> para ver todos os avisos.  Vamos l√°: </p><br><pre> <code class="plaintext hljs">docker run -v $(pwd):/tmp \ -w /tmp myth:latest \ -v4 \ --verbose-report \ -x contracts/flattened.sol</code> </pre> <br><p>  Aqui trabalhamos com um contrato achatado sem depend√™ncias.  Para analisar um contrato <code>Booking.sol</code> separado e fazer com que o Mythril selecione todas as depend√™ncias, voc√™ pode usar algo como isto: </p><br><pre> <code class="plaintext hljs">docker run -v $(pwd):/tmp \ -w /tmp myth:latest \ --solc-args="--allow-paths /tmp/node_modules/zeppelin-solidity/ zeppelin-solidity=/tmp/node_modules/zeppelin-solidity" \ -v4 \ --verbose-report \ -x contracts/Booking.sol</code> </pre> <br><p>  Prefiro trabalhar com a op√ß√£o achatada, pois  modificaremos muito no c√≥digo.  Mas o Mythril tamb√©m possui um modo extremamente conveniente - <code>--truffle</code> , que simplesmente <code>--truffle</code> tudo o que a <code>truffle</code> , verificando todo o projeto quanto a vulnerabilidades.  Outra caracter√≠stica importante √© a capacidade de especificar o nome do contrato a ser analisado por dois pontos; caso contr√°rio, o Mythril analisar√° todos os contratos que encontrar.  Acreditamos que o <code>Ownable</code> do OpenZeppelin √© um contrato seguro e s√≥ vamos analisar o <code>Booking</code> , portanto a linha final a ser executada √©: </p><br><pre> <code class="plaintext hljs">docker run -v $(pwd):/tmp -w /tmp myth:latest -x contracts/flattened.sol:Booking -v4 --verbose-report</code> </pre> <br><h2 id="zapusk-i-deploy-kontrakta">  <strong>Iniciar e implantar contrato</strong> </h2><br><p>  Iniciamos o analisador com a linha acima, examinamos a sa√≠da e obtemos, entre outras coisas, esta linha: </p><br><pre> <code class="plaintext hljs">mythril.laser.ethereum.svm [WARNING]: No contract was created during the execution of contract creation Increase the resources for creation execution (--max-depth or --create-timeout) The analysis was completed successfully. No issues were detected.</code> </pre> <br><p>  Acontece que nosso contrato n√£o foi criado e "corrigido" no emulador.  √â por isso que recomendo usar o sinalizador <code>-v4</code> para todos os tipos de an√°lise para ver todas as mensagens e n√£o perder uma √∫nica importante.  Vamos descobrir o que h√° de errado.  A solu√ß√£o para esse problema pr√°tico √© bastante importante para entender como usar o Mythril corretamente. </p><br><p>  Portanto, estamos lendo sobre o Mythril: <code>It uses concolic analysis, taint analysis and control flow checking to detect a variety of security vulnerabilities</code> .  Se voc√™ n√£o conhece muito esses termos, recomendo o wiki sobre testes conc√≥licos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> , mas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui est√° uma</a> boa apresenta√ß√£o sobre a verifica√ß√£o de contamina√ß√£o do x86.  Resumindo: Mythril emula a execu√ß√£o de um contrato, corrige as ramifica√ß√µes pelas quais a execu√ß√£o pode ir e tenta alcan√ßar um estado "quebrado" do contrato, classificando v√°rias combina√ß√µes de par√¢metros e tentando contornar todos os caminhos poss√≠veis.  Aqui est√° um exemplo de diagrama de a√ß√£o do artigo acima: </p><br><pre> <code class="plaintext hljs">1.      .   symbolic-,        . 2.      ,     ,   trace .    ,      ,    . 3.     . 4.       trace-. 5.  symbolic execution   trace,   symbolic ,    ,     ,     . 6.     ,          .    , . 7.   :   ,   ,   input-,     ,      .   input-   ,   .6    . 8.   .4</code> </pre> <br><p>  Se voc√™ simplific√°-lo bastante, o Mythril, tendo encontrado uma ramifica√ß√£o no c√≥digo, pode entender sob quais conjuntos de vari√°veis ‚Äã‚Äã√© poss√≠vel entrar em uma e na outra ramifica√ß√£o.  Em cada ramo, o Mythril sabe se leva a <code>assert</code> , <code>transfer</code> , <code>selfdestruct</code> e outros c√≥digos de opera√ß√£o relevantes √† seguran√ßa.  Portanto, o Mythril analisa quais conjuntos de par√¢metros e transa√ß√µes podem levar a uma viola√ß√£o de seguran√ßa.  E a maneira como o Mythril corta ramos que nunca obt√™m controle e analisa o fluxo de controle √© seu truque principal.  Mais detalhes sobre o intestino Mythril e a caminhada nos galhos est√£o escritos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p><br><p>  Devido √† natureza determin√≠stica da execu√ß√£o inteligente de contratos, a mesma sequ√™ncia de instru√ß√µes sempre leva estritamente a um conjunto de altera√ß√µes de estado, independentemente da plataforma, arquitetura ou ambiente.  Al√©m disso, as fun√ß√µes nos contratos inteligentes s√£o bastante curtas e os recursos s√£o extremamente limitados; portanto, analisadores como o Mythril, combinando execu√ß√£o simb√≥lica e nativa, podem funcionar de maneira extremamente eficiente para contratos inteligentes. </p><br><p>  No processo, o Mythril usa o conceito de "estado" - este √© o c√≥digo do contrato, seu ambiente, um ponteiro para o comando atual, armazenamento do contrato e o estado da pilha.  Aqui est√° a documenta√ß√£o: </p><br><pre> <code class="plaintext hljs">The machine state Œº is defined as the tuple (g, pc, m, i, s) which are the gas available, the program counter pc ‚àà P256, the memory contents, the active number of words in memory (counting continuously from position 0), and the stack contents. The memory contents Œºm are a series of zeroes of size 256.</code> </pre> <br><p>  O gr√°fico de transi√ß√£o entre estados √© o principal objeto de estudo.  No caso de uma inicializa√ß√£o bem-sucedida da an√°lise, as informa√ß√µes sobre este gr√°fico s√£o exibidas no log de an√°lise.  Al√©m disso, o Mythril pode criar esse gr√°fico de forma leg√≠vel por humanos, usando a op√ß√£o <code>--graph</code> . </p><br><p>  Agora, entendendo mais ou menos o que o Mythril far√°, continuaremos a entender por que o contrato n√£o √© analisado e de onde veio <code>[WARNING]: No contract was created during the execution of contract creation</code> .  Para come√ßar, torci as <code>--create-timeout</code> e <code>--max-depth</code> (conforme recomendado) e, n√£o obtendo o resultado, pensei que o construtor fosse o culpado - algo nele n√£o funcionava.  Aqui est√° o c√≥digo dele: </p><br><pre> <code class="plaintext hljs">function Booking( string _description, string _fileUrl, bytes32 _fileHash, uint256 _price, uint256 _cancellationFee, uint256 _rentDateStart, uint256 _rentDateEnd, uint256 _noCancelPeriod, uint256 _acceptObjectPeriod ) public payable { require(_price &gt; 0); require(_price &gt; _cancellationFee); require(_rentDateStart &gt; getCurrentTime()); require(_rentDateEnd &gt; _rentDateStart); require(_rentDateStart+_acceptObjectPeriod &lt; _rentDateEnd); require(_rentDateStart &gt; _noCancelPeriod); m_description = _description; m_fileUrl = _fileUrl; m_fileHash = _fileHash; m_price = _price; m_cancellationFee = _cancellationFee; m_rentDateStart = _rentDateStart; m_rentDateEnd = _rentDateEnd; m_noCancelPeriod = _noCancelPeriod; m_acceptObjectPeriod = _acceptObjectPeriod; }</code> </pre> <br><p>  Lembre-se do algoritmo de a√ß√£o do Mythril.  Para executar o rastreio, √© necess√°rio chamar o construtor do contrato, porque toda a execu√ß√£o subsequente depender√° de quais par√¢metros o construtor foi chamado.  Por exemplo, se voc√™ chamar o construtor com <code>_price == 0</code> , o construtor lan√ßar√° uma exce√ß√£o ao <code>require(_price &gt; 0)</code> .  Mesmo que o Mythril itere sobre os muitos valores de <code>_price</code> , o construtor ainda ser√° interrompido se, por exemplo, <code>_price &lt;= _cancellationFee</code> .  Neste contrato, h√° uma d√∫zia de par√¢metros associados a restri√ß√µes estritas, e o Mythril, √© claro, n√£o consegue adivinhar as combina√ß√µes v√°lidas de par√¢metros.  Ele tenta ir para o pr√≥ximo ramo de execu√ß√£o, classificando os par√¢metros do construtor, mas ele praticamente n√£o tem chance de adivinhar - h√° muitas combina√ß√µes de par√¢metros.  Portanto, o c√°lculo do contrato n√£o d√° certo - todas as formas <code>require(...)</code> de algum tipo de <code>require(...)</code> , e obtemos o problema acima. </p><br><p>  Agora, temos duas maneiras: a primeira √© desativar todos os <code>require</code> no construtor, comentando-os.  O Mythril poder√° chamar o construtor com qualquer conjunto de par√¢metros e tudo funcionar√°.  Mas isso significa que, examinando um contrato com esses par√¢metros, o Mythril encontrar√° erros poss√≠veis com valores incorretos passados ‚Äã‚Äãao construtor.  Simplificando, se o Mythril encontrar um erro que surgir, se o criador do contrato especificar <code>_cancellationFee</code> um bilh√£o de vezes o pre√ßo do aluguel do <code>_mprice</code> , n√£o haver√° utilidade nesse erro - esse contrato nunca ser√° bloqueado e os recursos para encontrar erros ser√£o gastos.  Implicamos que o contrato ainda est√° preso a par√¢metros mais ou menos consistentes; portanto, para an√°lises posteriores, faz sentido especificar par√¢metros construtores mais realistas para que o Mythril n√£o procure por erros que nunca ocorrer√£o se o contrato for fechado corretamente. </p><br><p>  Passei muitas horas tentando entender exatamente onde a implanta√ß√£o √© interrompida, incluindo e desativando v√°rias partes do construtor.  Al√©m dos meus problemas, o construtor usa <code>getCurrentTime()</code> , que retorna a hora atual, e n√£o est√° claro como essa chamada lida com o Mythril.  N√£o vou descrever essas aventuras aqui, porque  provavelmente com o uso regular, essas sutilezas ser√£o conhecidas pelo auditor.  Portanto, escolhi a segunda maneira: limitar os dados de entrada e simplesmente remover todos os par√¢metros do construtor, mesmo <code>getCurrentTime()</code> , simplesmente codificou os par√¢metros necess√°rios diretamente no construtor (idealmente, esses par√¢metros devem ser obtidos do cliente): </p><br><pre> <code class="plaintext hljs"> function Booking( ) public payable { m_description = "My very long booking text about hotel and beautiful sea view!"; m_fileUrl = "https://ether-airbnb.bam/some-url/"; m_fileHash = 0x1628f3170cc16d40aad2e8fa1ab084f542fcb12e75ce1add62891dd75ba1ffd7; m_price = 1000000000000000000; // 1 ETH m_cancellationFee = 100000000000000000; // 0.1 ETH m_rentDateStart = 1550664800 + 3600 * 24; // current time + 1 day m_rentDateEnd = 1550664800 + 3600 * 24 * 4; // current time + 4 days m_acceptObjectPeriod = 3600 * 8; // 8 hours m_noCancelPeriod = 3600 * 24; // 1 day require(m_price &gt; 0); require(m_price &gt; m_cancellationFee); require(m_rentDateStart &gt; 1550664800); require(m_rentDateEnd &gt; m_rentDateStart); require((m_rentDateStart + m_acceptObjectPeriod) &lt; m_rentDateEnd); require(m_rentDateStart &gt; m_noCancelPeriod); }</code> </pre> <br><p>  Al√©m disso, para que tudo comece, voc√™ tamb√©m deve definir o par√¢metro <code>max-depth</code> .  Funcionou para mim com esse construtor com <code>--max-depth=34</code> na inst√¢ncia do AWS t2.medium.  Ao mesmo tempo, no meu laptop, que √© mais poderoso, tudo come√ßa sem nenhuma <code>max-depth</code> .  A julgar pelo uso desse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">par√¢metro</a> , √© necess√°rio construir ramifica√ß√µes para an√°lise, e seu valor padr√£o √© infinito ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">c√≥digo</a> ).  Portanto, gire este par√¢metro com rota√ß√£o, mas garanta que o contrato desejado seja analisado.  Voc√™ pode entender isso por mensagens como: </p><br><pre> <code class="plaintext hljs">mythril.laser.ethereum.svm [INFO]: 248 nodes, 247 edges, 2510 total states mythril.laser.ethereum.svm [INFO]: Achieved 59.86% coverage for code: .............</code> </pre> <br><p>  A primeira linha descreve apenas o gr√°fico que ser√° analisado, leia o resto das linhas voc√™ mesmo.  Recursos computacionais s√©rios s√£o necess√°rios para analisar as v√°rias ramifica√ß√µes que podem ser executadas; portanto, ao analisar contratos grandes, voc√™ ter√° que esperar at√© em um computador r√°pido. </p><br><h2 id="poisk-oshibok">  <strong>Procure por erros</strong> </h2><br><p>  Agora vamos procurar erros e adicionar os nossos.  O Mythril procura ramifica√ß√µes nas quais a transmiss√£o, a autodestrui√ß√£o, a afirma√ß√£o e outras a√ß√µes importantes do ponto de vista da seguran√ßa ocorrem.  Se uma das instru√ß√µes acima for encontrada em algum lugar do c√≥digo do contrato, o Mythril estuda as maneiras pelas quais √© poss√≠vel chegar a essa ag√™ncia e, al√©m disso, exibe a sequ√™ncia de transa√ß√µes que levam a essa ag√™ncia! </p><br><p>  Primeiro, vamos ver o que o Mythril emitiu para o contrato de <code>Booking</code> longa dura√ß√£o.  Primeiro aviso: </p><br><pre> <code class="plaintext hljs">==== Dependence on predictable environment variable ==== SWC ID: 116 Severity: Low Contract: Booking Function name: fallback PC address: 566 Estimated Gas Usage: 17908 - 61696 Sending of Ether depends on a predictable variable. The contract sends Ether depending on the values of the following variables: - block.timestamp Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and/or can be manipulated by a malicious miner. Don't use them for random number generation or to make critical decisions. -------------------- In file: contracts/flattened.sol:142 msg.sender.transfer(msg.value-m_price)</code> </pre> <br><p>  e surge porque </p><br><pre> <code class="plaintext hljs">require(m_rentDateStart &gt; getCurrentTime());</code> </pre> <br><p>  na fun√ß√£o de fallback. </p><br><p>  Observe que o Mythril percebeu que <code>getCurrentTime()</code> oculto em <code>getCurrentTime()</code> .  Apesar do significado do contrato n√£o ser um erro, o fato de o Mythril associar <code>block.timestamp</code> √† transmiss√£o √© excelente!  Nesse caso, o programador deve entender que a decis√£o √© tomada com base no valor que o mineiro pode controlar.  E, se no futuro surgir um leil√£o ou outro leil√£o de um servi√ßo neste local do contrato, √© preciso levar em considera√ß√£o a possibilidade de ataques anteriores. </p><br><p>  Vamos ver se o Mythril v√™ uma depend√™ncia do <code>block.timestamp</code> se escondermos a vari√°vel em uma chamada aninhada como esta: </p><br><pre> <code class="plaintext hljs">function getCurrentTime() public view returns (uint256) { - return now; + return getCurrentTimeInner(); } + function getCurrentTimeInner() internal returns (uint256) { + return now; + }</code> </pre> <br><p>  E sim!  O Mythril continua vendo a conex√£o entre block.timestamp e a transfer√™ncia da transmiss√£o, isso √© extremamente importante para o auditor.  A conex√£o entre a vari√°vel controlada pelo invasor e a decis√£o tomada ap√≥s v√°rias altera√ß√µes no estado do contrato pode ser muito mascarada pela l√≥gica, e o Mythril permite que voc√™ rastreie.  Embora n√£o valha a pena confiar no fato de que todas as conex√µes poss√≠veis entre todas as vari√°veis ‚Äã‚Äãposs√≠veis ser√£o <code>getCurrentTime()</code> para voc√™: se voc√™ continuar zombando da fun√ß√£o <code>getCurrentTime()</code> e fizer uma profundidade de aninhamento tripla, o aviso desaparecer√°.  Cada chamada de fun√ß√£o para o Mythril requer a cria√ß√£o de novas ramifica√ß√µes de estado, portanto, analisar n√≠veis muito profundos de aninhamento exigir√° recursos enormes. </p><br><p>  √â claro que h√° uma chance bastante s√©ria de eu simplesmente usar incorretamente os par√¢metros de an√°lise ou o ponto de corte ocorrer em algum lugar nas profundezas do analisador.  Como eu disse, o produto est√° em desenvolvimento ativo, no momento em que escrevo, vejo confirma√ß√µes no reposit√≥rio com a men√ß√£o de <code>max-depth</code> ; portanto, n√£o leve a s√©rio os problemas atuais, j√° encontramos evid√™ncias suficientes de que o Mythril pode efetivamente procurar conex√µes impl√≠citas entre vari√°veis. </p><br><p>  Primeiro, adicione ao contrato uma fun√ß√£o que transmita a transmiss√£o a qualquer pessoa, mas somente ap√≥s o cliente enviar a transmiss√£o ao contrato.  <code>State.PAID</code> que qualquer pessoa pegasse 1/5 do √©ter, mas somente quando o contrato estiver no estado <code>State.PAID</code> (ou seja, somente depois que o cliente pagou o n√∫mero alugado com o √©ter).  Aqui est√° a fun√ß√£o: </p><br><pre> <code class="plaintext hljs">function collectTaxes() external onlyState(State.PAID) { msg.sender.transfer(address(this).balance / 5); }</code> </pre> <br><p>  Mythril encontrou o problema: </p><br><pre> <code class="plaintext hljs">==== Unprotected Ether Withdrawal ==== SWC ID: 105 Severity: High Contract: Booking Function name: collectTaxes() PC address: 2492 Estimated Gas Usage: 2135 - 2746 Anyone can withdraw ETH from the contract account. Arbitrary senders other than the contract creator can withdraw ETH from the contract account without previously having sent a equivalent amount of ETH to it. This is likely to be a vulnerability. -------------------- In file: contracts/flattened.sol:149 msg.sender.transfer(address(this).balance / 5) -------------------- -------------------- Transaction Sequence: { "2": { "calldata": "0x", "call_value": "0xde0b6b3a7640000", "caller": "0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef" }, "3": { "calldata": "0x01b613a5", "call_value": "0x0", "caller": "0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef" } }</code> </pre> <br><p>  √ìtimo, ou seja,  Mythril chegou a realizar duas transa√ß√µes, que levam ao fato de que voc√™ pode retirar o √©ter do contrato.  Agora altere o requisito <code>State.RENT</code> para <code>State.RENT</code> , desta forma: </p><br><pre> <code class="plaintext hljs">- function collectTaxes() external onlyState(State.PAID){ + function collectTaxes() external onlyState(State.RENT) {</code> </pre> <br><p>  Agora <code>collectTaxes()</code> pode ser chamado apenas quando o contrato estiver no estado <code>State.RENT</code> e, neste momento, n√£o h√° nada na balan√ßa, porque  o contrato j√° enviou a transmiss√£o inteira ao propriet√°rio.  E o importante aqui √© que o Mythril desta vez <strong>N√ÉO gera</strong> o erro <code>==== Unprotected Ether Withdrawal ====</code> !  Sob a condi√ß√£o <code>onlyState(State.RENT)</code> , o analisador n√£o chegou √† ramifica√ß√£o de c√≥digo que envia √©ter do contrato com um saldo diferente de zero.  O Mythril passou por op√ß√µes diferentes para os par√¢metros, mas voc√™ pode entrar no <code>State.RENT</code> apenas enviando toda a transmiss√£o ao locador.  Portanto, √© imposs√≠vel chegar a esse ramo do c√≥digo com um saldo diferente de zero, e o Mythril absolutamente n√£o incomoda o auditor! </p><br><p>  Da mesma forma, o Mythril encontrar√° <code>selfdestruct</code> e <code>assert</code> , mostrando ao auditor quais a√ß√µes podem levar √† destrui√ß√£o do contrato ou √† quebra de uma fun√ß√£o importante.  N√£o darei esses exemplos, apenas tentarei criar uma fun√ß√£o semelhante √† acima, apenas chamando <code>selfdestruct</code> - <code>selfdestruct</code> e distorcer sua l√≥gica. </p><br><p>  Al√©m disso, n√£o esque√ßa que uma das partes do Mythril √© a execu√ß√£o simb√≥lica, e essa abordagem, por si s√≥, sem emular a execu√ß√£o, pode determinar muitas vulnerabilidades.  Por exemplo, qualquer uso de "+", "-" e outros operadores aritm√©ticos pode ser considerado uma vulnerabilidade de "Estouro de n√∫mero inteiro" se um dos operandos for de alguma forma controlado pelo invasor.  Mas repito novamente, o recurso mais poderoso do Mythril √© a combina√ß√£o de execu√ß√£o simb√≥lica e nativa e a determina√ß√£o de valores de par√¢metros que levam √† ramifica√ß√£o l√≥gica. </p><br><h2 id="zaklyuchenie">  <strong>Conclus√£o</strong> </h2><br><p>  Obviamente, para mostrar toda a gama de poss√≠veis problemas que o Mythril √© capaz de detectar, ser√£o necess√°rios n√£o apenas um, mas v√°rios artigos.  Para todo o resto, ele sabe fazer tudo isso em um blockchain real, encontrando os contratos e vulnerabilidades necess√°rios por assinaturas, criando belos gr√°ficos de chamadas, formatando relat√≥rios.  O Mythril tamb√©m permite que voc√™ escreva seus pr√≥prios scripts de teste, fornecendo uma interface baseada em python ao contrato e testando fun√ß√µes individuais, corrigindo valores de par√¢metros ou at√© implementando sua pr√≥pria estrat√©gia para trabalhar com c√≥digo desmontado com um grau de flexibilidade arbitr√°rio. </p><br><p>  O Mythril ainda √© um software bastante jovem, esse n√£o √© o IDA Pro e h√° muito pouca documenta√ß√£o, exceto alguns artigos.  O valor de muitos par√¢metros s√≥ pode ser lido no c√≥digo Mythril, come√ßando com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cli.py.</a>  Espero que uma descri√ß√£o completa e aprofundada da opera√ß√£o de cada par√¢metro apare√ßa na documenta√ß√£o. </p><br><p>  Al√©m disso, quando o contrato √© mais ou menos grande, a sa√≠da de v√°rios erros ocupa muito espa√ßo, mas eu gostaria de receber informa√ß√µes compactadas sobre o erro encontrado, porque  ao trabalhar com o Mythril, voc√™ deve definitivamente observar o caminho da an√°lise, ver quais contratos foram testados da melhor maneira poss√≠vel e poder desativar √† for√ßa erros espec√≠ficos que o auditor considera falso-positivos. </p><br><p>  Mas, em geral, o Mythril √© uma ferramenta excelente e extremamente poderosa para analisar contratos inteligentes e, no momento, deve estar no arsenal de qualquer auditor.  Ele permite que voc√™ preste pelo menos aten√ß√£o a partes cr√≠ticas do c√≥digo e detecte relacionamentos ocultos entre vari√°veis. </p><br><p>  Para resumir, as recomenda√ß√µes para o uso do Mythril s√£o: </p><br><ol><li>  Limitar as condi√ß√µes iniciais do contrato em estudo  Se, durante a an√°lise, o Mythril gastar muitos recursos em ramifica√ß√µes que nunca ser√£o implementadas na pr√°tica, ele perder√° a capacidade de encontrar erros realmente importantes, portanto, voc√™ deve sempre tentar diminuir a √°rea de ramifica√ß√µes em potencial. </li><li>  Verifique se a an√°lise do contrato foi iniciada, n√£o perca mensagens como <code>mythril.laser.ethereum.svm [WARNING]: No contract was created during the execution of contract creation Increase the resources for creation execution (--max-depth or --create-timeout)</code> , caso contr√°rio, voc√™ pode considerar erroneamente que n√£o h√° bugs. </li><li>  Voc√™ pode desabilitar arbitrariamente ramifica√ß√µes no c√≥digo do contrato, dando ao Mythril menos varia√ß√£o na escolha de ramifica√ß√µes e economizando recursos.  Tente fazer sem restri√ß√µes <code>max-depth</code> , para n√£o "cortar" a an√°lise, mas tome cuidado para n√£o mascarar o erro. </li><li>  Preste aten√ß√£o a cada aviso, mesmo coment√°rios leves √†s vezes valem a pena adicionar pelo menos um coment√°rio ao c√≥digo do contrato, facilitando para outros desenvolvedores. </li></ol><br><p>  No pr√≥ximo artigo, trataremos do analisador Manticore, mas aqui est√° o √≠ndice dos artigos prontos ou planejados para a escrita: </p><br><p>  Parte 1. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Introdu√ß√£o.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Compila√ß√£o, nivelamento, vers√µes do Solidity</a> <br>  Parte 2. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Slither</a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 3. Mythril (este artigo) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 4. Manticore (durante a escrita) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 5. Equidna (durante a escrita)</font></font></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt442114/">https://habr.com/ru/post/pt442114/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt442102/index.html">Para a quest√£o das baterias</a></li>
<li><a href="../pt442104/index.html">Guia do Usu√°rio Kibana. Visualiza√ß√£o. Parte 5</a></li>
<li><a href="../pt442108/index.html">Guia para desenvolvedores criarem aplicativos de IA</a></li>
<li><a href="../pt442110/index.html">Antipatterns Vim</a></li>
<li><a href="../pt442112/index.html">Novas linguagens de programa√ß√£o silenciosamente matam nossa conex√£o com a realidade</a></li>
<li><a href="../pt442116/index.html">Melhorando a funcionalidade do componente React com React.memo ()</a></li>
<li><a href="../pt442118/index.html">O pool de minera√ß√£o Coinhive para de funcionar</a></li>
<li><a href="../pt442120/index.html">Treinamento de modelos TensorFlow com o Servi√ßo de Machine Learning do Azure</a></li>
<li><a href="../pt442122/index.html">Um simples nordem moscovita: uma entrevista com o criador do duque Nukem</a></li>
<li><a href="../pt442124/index.html">O Facebook dar√° aos usu√°rios a oportunidade de limpar sua hist√≥ria</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>