<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚ÄçüöÄ ü§öüèæ üëåüèΩ Automa√ß√£o de tigelas tibetanas com a ajuda do "Arduino". Motor de passo em vez de um monge. Programa√ß√£o sem fio üë∂üèø üëãüèæ üßîüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="E TRANSFER√äNCIA DE VONTADE DIVINA DE SINAIS DE TEMPO EXATO ATRAV√âS DE ESP8266. 
 PARTE QUATRO 



 Ent√£o, tudo coincidiu. Primeiro, vi um artigo sobre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Automa√ß√£o de tigelas tibetanas com a ajuda do "Arduino". Motor de passo em vez de um monge. Programa√ß√£o sem fio</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415629/">  <b>E TRANSFER√äNCIA <s>DE VONTADE DIVINA DE</s> SINAIS DE TEMPO EXATO ATRAV√âS DE ESP8266.</b> <b><br></b>  <b>PARTE QUATRO</b> <br><br><img src="https://habrastorage.org/webt/gx/au/0j/gxau0jnutvametc-igezo5zkpvk.jpeg"><br><br>  Ent√£o, tudo coincidiu.  Primeiro, vi um artigo sobre Gytayms sobre cortinas controladas por um motor de passo.  Lembrei-me de que tinha o mesmo motor ocioso pelo segundo ano.  Ent√£o meu olhar caiu na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tigela de</a> canto, que estava acumulando poeira na prateleira h√° cinco anos.  E ent√£o v√°rios pensamentos inteligentes come√ßaram a vir √† minha cabe√ßa ... <br><br>  N√£o, √© claro, √†s vezes de acordo com o meu humor, peguei este copo em minhas m√£os e por algum tempo extra√≠ v√°rios tipos de sons fascinantes, mas n√£o era exatamente o que eu queria.  E eu queria fazer algo em paralelo, e deixar o copo soar naquele momento.  √â claro que h√° mil anos atr√°s isso exigiria um <s>escravo</s> separado, trezentos anos atr√°s, seria um mecanismo sofisticado de rel√≥gio, e agora ... Bem, agora temos um motor de passo, uma placa Arduino ProMini e outros eletr√¥nicos <s>n√£o</s> sofisticados.  Resta apenas codificar um pouco o <s>gado</s> .  E, ao mesmo tempo, certifique-se de que esse cinzel tibetano, ao mesmo tempo, lute contra a hora exata - em v√£o, ou algo que tenha produzido tantos servidores de hora exata.  E deixe o ESP8266 se comunicar com eles, ela sabe como. <br><br>  Ent√£o ... <br><a name="habracut"></a><br>  H√° uma tigela de canto com um badalo. <br><br><img src="https://habrastorage.org/webt/tk/d_/hy/tkd_hy9acctcthkplro1s8fs20k.jpeg"><br><br>  √â necess√°rio fazer o martelo bater contra a borda da tigela.  Automaticamente.  Tamb√©m com a possibilidade de controle remoto (e reprograma√ß√£o!).  E apenas para vencer o tempo como um rel√≥gio antigo, mas com precis√£o moderna. <br><br>  No futuro, mostrarei o que aconteceu no final.  Assista melhor com o som. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/0jCoLDa7Xx0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Mas vamos come√ßar em ordem.  Primeiro eu tive que entender como a mec√¢nica ficaria e funcionaria.  Em eletr√¥nica e software, fiquei calmo - atr√°s de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tr√™s artigos</a> sobre como lidar com o arduinki √† dist√¢ncia. <br><br>  O principal elemento m√≥vel era ser um simples motor de passo de 28YBJ-48 e eu precisava entender se ele podia lidar com o martelo. <br><br><img src="https://habrastorage.org/webt/vl/kt/sn/vlktsnvvvzlckt-wjpsmztiqtqs.jpeg"><br><br>  A pr√≥pria conex√£o do dvigun ao arduino n√£o √© dif√≠cil, felizmente, foi vendido com um driver ULN2003 pronto.  S√≥ era necess√°rio fornecer uma fonte de alimenta√ß√£o separada para 5 volts e uma reserva de 200-300 mA, porque voc√™ definitivamente n√£o ter√° um conversor suficiente no pr√≥prio arduino.  Ent√£o, em qualquer uma das quatro portas digitais (peguei PB1, PB2, PB3, PB4), transferimos os seguintes blocos de anota√ß√µes de bits no total de oito pe√ßas. <br><br><pre><code class="cpp hljs">PORTB=<span class="hljs-number"><span class="hljs-number">0b00000010</span></span>;<span class="hljs-comment"><span class="hljs-comment">//     PORTB=0b00000110; PORTB=0b00000100; PORTB=0b00001100; PORTB=0b00001000; PORTB=0b00011000; PORTB=0b00010000; PORTB=0b00010010;</span></span></code> </pre> <br>  Para rota√ß√£o na dire√ß√£o oposta, transferimos os mesmos notebooks, mas na ordem inversa. <br><br><pre> <code class="cpp hljs"> PORTB=<span class="hljs-number"><span class="hljs-number">0b00010010</span></span>; PORTB=<span class="hljs-number"><span class="hljs-number">0b00010000</span></span>; PORTB=<span class="hljs-number"><span class="hljs-number">0b00011000</span></span>; PORTB=<span class="hljs-number"><span class="hljs-number">0b00001000</span></span>; PORTB=<span class="hljs-number"><span class="hljs-number">0b00001100</span></span>; PORTB=<span class="hljs-number"><span class="hljs-number">0b00000100</span></span>; PORTB=<span class="hljs-number"><span class="hljs-number">0b00000110</span></span>; PORTB=<span class="hljs-number"><span class="hljs-number">0b00000010</span></span>;</code> </pre><br>  A √∫nica coisa que surge √© a velocidade com que os dados s√£o transmitidos.  √â claro que, com mais freq√º√™ncia, mais r√°pido o eixo do motor ir√° girar, mas at√© que limite?  H√° uma frequ√™ncia misteriosa de 100 Hz na descri√ß√£o, mas o que exatamente significa - o per√≠odo de um ciclo completo ou cada mordidela separadamente? <br><br>  No decorrer dos experimentos, descobriu-se que, aparentemente, a frequ√™ncia da mudan√ßa de precisos t√©trades era significada.  Ao m√°ximo, consegui acelerar essa frequ√™ncia para 147 Hz, na qual o eixo do motor fez uma revolu√ß√£o em cerca de um segundo ou dois.  N√£o medi exatamente, mas voc√™ pode julgar por si mesmo que este modelo com esta caixa de velocidades n√£o difere em agilidade especial.  Mas, para o meu martelo, parecia, em princ√≠pio, adequado. <br><br>  Afinal, n√£o √© apenas a velocidade que √© importante para n√≥s (ou melhor, nem mesmo √© muito importante), mas a for√ßa com a qual o motor pode atuar no fluido de trabalho.  Nas postagens dedicadas a esse mecanismo, argumentou-se que eles n√£o podiam parar com uma m√£o.  Como se viu, o pr√≥prio eixo, sim, voc√™ n√£o para, mas j√° uma alavanca pequena (e eu decidi usar um sistema de alavanca) com literalmente 10 cm de comprimento, para e p√°ra com muita facilidade mesmo com um pequeno impacto local. <br><br>  Portanto, a op√ß√£o mais simples inicial, quando a alavanca aparafusada ao eixo empurra o batedor na suspens√£o, que consequentemente bate na tigela, n√£o passou.  O som estava muito fraco.  Ent√£o decidi pedir ajuda √† gravidade (a "cadela sem cora√ß√£o" nas palavras de Sheldon Cooper).  Nesta modalidade, a alavanca puxou um badalo at√© um √¢ngulo de cerca de 30 graus em rela√ß√£o √† dire√ß√£o do centro da Terra e, em seguida, desengatou-se dele e enviou-o para a tigela.  Gostei muito do som, tanto de baixo como dos meus vizinhos.  O mecanismo de libera√ß√£o foi feito em um √≠m√£ montado na extremidade da alavanca.  Ao subirem, a gravidade derrotou a magn√©tica e a trava foi liberada.  Ent√£o fiz uma parada mec√¢nica de ajuda - uma barra transversal com a qual o martelo se encontrava perto do ponto extremo da ascens√£o.  O motor continuou a girar, a alavanca puxou e desengatou com for√ßa a trava magn√©tica.  Aqui, o motor foi ajudado pela gravidade; portanto, o esfor√ßo para desengatar era necess√°rio muito pouco. <br><br>  O design em si foi montado com base nos detalhes do designer infantil da Torre Eiffel.  Comprei por um longo tempo e periodicamente usei suas pe√ßas para o meu artesanato.  A torre, √© claro, n√£o acabou sendo a Eiffel, mas na minha opini√£o n√£o √© de forma alguma pior :) <br><br><div class="spoiler">  <b class="spoiler_title">Quase Torre Eiffel</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/wl/la/as/wllaasusy0nhw9s_ad0y7depa9k.jpeg"><br></div></div><br>  Tudo funcionou perfeitamente, mas com um sinal de menos - o som sempre foi o mesmo poder.  Isso √© normal para bater o tempo, mas no modo livre eu gostaria de ouvir n√£o apenas pausas diferentes no tempo, mas tamb√©m sons de diferentes for√ßas.  Portanto, era necess√°rio aplicar um eletro√≠m√£, que tamb√©m era muito √∫til.  √çm√£s convencionais tamb√©m foram √∫teis - uma coluna de cinco pequenos √≠m√£s que eu usei como amortecedor para domar as vibra√ß√µes do batedor depois de bater na tigela. <br><br><img src="https://habrastorage.org/webt/vs/yv/gb/vsyvgb5eqgcdqze2hyhxesgya9k.jpeg"><br><br>  No come√ßo, instalei-o na extremidade da alavanca, mas o design era pesado e fr√°gil e pouco confi√°vel.  Portanto, o eletro√≠m√£ mudou-se para um martelo.  Ele consumiu cerca de 300 mA e, √© claro, era imposs√≠vel control√°-lo a partir do porto do arduino.  Eu tive que colocar uma simples chave de transistor em uma pequena placa de ensaio. <br><br><img src="https://habrastorage.org/webt/sm/2j/w6/sm2jw69rz-nfepnkzp99bebnn9i.png"><br><br>  R1 - 560 Ohm, VD1 - 1N4007, VT1 - BD139 <br><br>  Montei a parte eletr√¥nica principal no m√≥dulo ‚ÄúArduino ProMini‚Äù e no ESP8266-07, cujo firmware completei completamente passo a passo, de acordo com o meu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo antigo</a> .  Como resultado, eu, como sempre, tive a oportunidade de programar o arduino sem fio e tamb√©m me comunicar remotamente com ele, trocando dados, que acabei usando com sucesso.  O diagrama mostra, no entanto, o Arduino Nano por raz√µes hist√≥ricas, mas sua conex√£o n√£o √© diferente. <br><br><img src="https://habrastorage.org/webt/ce/bu/6d/cebu6dvlctxn46bgg2cu5k6cnlc.png"><br><br>  Ent√£o, o que eu desejava e, em seguida, incorporava o c√≥digo do programa. <br><br><ol><li>  Quando voc√™ liga o sistema, deve entrar independentemente no modo de exibi√ß√£o. </li><li>  Deve haver um aplicativo no computador (smartphone) para alterar os modos operacionais e transferir os dados necess√°rios. </li><li>  Os modos devem ser simples - um rel√≥gio, murm√∫rio aleat√≥rio e controle manual. </li></ol><br>  Comecei, ao que parecia, com a coisa mais simples - horas.  De fato, qualquer r√°dio amador iniciante coleta primeiro uma sonda e depois um rel√≥gio eletr√¥nico.  E ent√£o, no entanto, ele se pergunta por que esse rel√≥gio fica para tr√°s um minuto por hora - parece que ele teoricamente calculou tudo corretamente. <br><br>  Eu j√° tinha o rel√≥gio eletr√¥nico montado. <br><br><img src="https://habrastorage.org/webt/lw/5u/eu/lw5ueutxi1xyqmu9bz8r6vpy-e0.jpeg"><br><br>  E sua principal caracter√≠stica √∫til para mim agora era a capacidade de arrastar o tempo exato dos servidores NTP usando o mesmo microcircuito ESP8266, na pessoa de sua primeira e mais simples encarna√ß√£o. <br><br>  Eu at√© queria escrever um artigo sobre esse assunto h√° alguns anos, mas depois de ver quantas vezes isso j√° foi feito, mudei de id√©ia.  Eles v√£o rir depois de tudo.  Mas, no contexto deste post, a an√°lise de seu trabalho √© bastante apropriada.  Como mencionei anteriormente nos artigos, escrevo programas para o ESP8266 na linguagem LUA.  Isso aconteceu. <br><br><div class="spoiler">  <b class="spoiler_title">Portanto, o c√≥digo carregado no m√≥dulo ESP era assim.</b> <div class="spoiler_text"><pre> <code class="lua hljs">uart.setup(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">9600</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) timezone = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-comment"><span class="hljs-comment">--  tmr.alarm(1,5000,0,function() -- try once connect to NTP-server sk=net.createUDPSocket() sk:send(123,"130.149.17.21",string.char( 227, 0, 6, 236, 0,0,0,0,0,0,0,0, 49, 78, 49, 52, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)) sk:on("receive", function(sck, payload) ntp = payload:byte(41) * 128 * 256 * 256 + payload:byte(42) * 128 * 256 + payload:byte(43) * 128 + payload:byte(44) /2 + timezone * 1800 hour =ntp % 43200 / 1800 minute = ntp % 1800 / 30 secund = ntp % 60 uart.write(0,hour) uart.write(0,minute) uart.write(0,secund) sk:close() end ) end)</span></span></code> </pre><br></div></div><br>  A linha inferior √© simples.  Uma vez (ou n√£o), √© chamada a fun√ß√£o que configura o cliente UDP, que chama o servidor de hor√°rio exato e pergunta a hora exata de acordo.  Em resposta, o servidor despeja trinta e dois bytes, dos quais √© necess√°rio buscar os quatro bytes de dados desejados.  Infelizmente, essa busca n√£o leva minutos e horas, mas o n√∫mero de segundos decorridos at√© agora desde 1¬∫ de janeiro de 1900.  Portanto, voc√™ precisar√° calcular o tempo atual dos quatro bytes desses segundos com v√°rias manipula√ß√µes complexas. <br><br>  Al√©m disso, tudo √© mais simples.  Ligue o transmissor UART e solte o tempo calculado nele em tr√™s bytes - horas, minutos e segundos. <br><br>  E novamente inseri esse c√≥digo, j√° no meu gerenciador de inicializa√ß√£o LUA (link), exatamente no local em que a conex√£o √† rede WI-FI j√° foi feita, mas ainda n√£o foram iniciados outros trabalhos. <br><br><div class="spoiler">  <b class="spoiler_title">√Ä vista completa, fica assim.</b> <div class="spoiler_text"><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InstrProgrammingEnable</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">-- instruction for MC "enable programming" p=0 while p&lt;31 do p=p+1 pin=8 gpio.write(pin, gpio.LOW) spi.send(1, 0xAC,0x53) read = spi.recv( 1, 8) spi.send(1,0,0) gpio.write(pin, gpio.HIGH) if (string.byte(read)== 83) then --print("connection established") p=33 if(p==31) then --print("no connection") end end end end function ProgrammingDisable () pin=2--END OF ESET FOR MK GPIO4 gpio.mode(pin, gpio.INPUT) pin=8 gpio.mode(pin, gpio.INPUT) -- CE chip enable not used GPIO15 pin=5--CLK MASTER for SPI GPIO14 used gpio.mode(pin, gpio.INPUT) pin=6--MISO MASTER for SPI GPIO 12 may not used gpio.mode(pin, gpio.INPUT) pin=7--MOSI MASTER for SPI //GPIO13 used gpio.mode(pin, gpio.INPUT) end --PROGRAMMING ENABLE function ProgrammingEnable () pin=2-- RESET FOR MK gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.LOW) pin=2--POZITIV FOR 4MSEC RESET FOR MK gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.HIGH) tmr.delay(4) gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.LOW) tmr.delay(25000) end function InstrFlashErase() --FFFFFFFFFFFFFFFFFF pin=8 gpio.write(pin, gpio.LOW) spi.send(1,0xAC,0x80,0,0) gpio.write(pin, gpio.HIGH) tmr.delay(15000) pin=2--RESET FOR MK gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.HIGH) tmr.delay(20000) gpio.write(pin, gpio.LOW) --print( "FLASH is erased") InstrProgrammingEnable () end function InstrStorePAGE(H, address, data) pin=8 gpio.write(pin, gpio.LOW) spi.send(1,H,0,address,data) gpio.write(pin, gpio.HIGH) tmr.delay(500) end function InstrWriteFLASH(page_address_low,page_address_high) pin=8 gpio.write(pin, gpio.LOW) spi.send(1,0x4C,page_address_high,page_address_low,0) gpio.write(pin, gpio.HIGH) tmr.delay(5000)--        end function Programming (payload) pin=8--CS MASTER for SPI gpio.mode(pin, gpio.OUTPUT, gpio.PULLUP) pin=4--LED LIGHTS ON LOW gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.LOW) --print(string.len(payload)) page_count = 7 --  1  for k =0 ,page_count ,1 do--quantity of pages for i=0 , 127, 2 do-- -1 address = i/2 data=payload:byte(i+1+128*k) if data == nil then data = 0xff end InstrStorePAGE(0x40,address,data) -- tmr.delay(100)-- otherwise not in time write data =payload:byte(i+1+1+128*k) if data == nil then data = 0xff end InstrStorePAGE(0x48,address,data) -- tmr.delay(100) end page_address_low=bit.band(k ,3)*64 -- 3   11 page_address_high=k/4+frame1024*2 tmr.delay(1000) InstrWriteFLASH(page_address_low,page_address_high) tmr.wdclr() end pin=4--LED gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.HIGH) end --MAIN BLOCK wifi.setmode(wifi.STATION) --wifi.sta.config("mixa","M1sh8111") -- set SSID and password of your access point station_cfg={} tmr.delay(30000) station_cfg.ssid="mixa" tmr.delay(30000) station_cfg.pwd="M1sh8111" tmr.delay(30000) wifi.sta.config(station_cfg) tmr.delay(30000) wifi.sta.connect() tmr.delay(1000000) --print(wifi.sta.status()) --print(wifi.sta.getip()) while ( wifi.sta.status()~=1 ) do if( wifi.sta.status()==5) then break end end uart.setup(0,9600,8,0,1,0) --     NTP      AVR timezone = 3 --  tmr.alarm(1,5000,0,function() -- try once connect to NTP-server sk=net.createUDPSocket() sk:send(123,"130.149.17.21",string.char( 227, 0, 6, 236, 0,0,0,0,0,0,0,0, 49, 78, 49, 52, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)) sk:on("receive", function(sck, payload) ntp = payload:byte(41) * 128 * 256 * 256 + payload:byte(42) * 128 * 256 + payload:byte(43) * 128 + payload:byte(44) /2 + timezone * 1800 hour =ntp % 43200 / 1800 minute = ntp % 1800 / 30 secund = ntp % 60 uart.write(0,100)-- AVR    uart.write(0,hour) uart.write(0,minute) uart.write(0,secund) sk:close() end ) end) prog_address=""; sv=net.createServer(net.TCP,30) tmr.delay(100) --print("SERVER READY") sv:listen(40000,function(c)-- ,   c:on("receive", function(c, payload) --print(payload) if (payload =="program\r\n") then c:send("ready\r\n") --print("ready for program\r\n") tmr.wdclr() spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, spi.DATABITS_8,80,spi.FULLDUPLEX) --  SPI 320  115 000  ProgrammingEnable ()---------------------------------------------------------------------  80    1  tmr.delay(100) InstrProgrammingEnable () tmr.delay(100) InstrFlashErase() tmr.delay(100) frame1024=0--   st=net.createServer(net.TCP,30)--         AWR,   stop program st:listen(40001,function(c) c:on("receive", function(c, payload) tmr.wdclr() Programming (payload) frame1024=frame1024+1 end) end) end if (payload =="data\r\n") then tmr.wdclr() c:send("ready\r\n") -- print("ready for data\r\n") c:on("receive", function(c, prog_address_payload) prog_address=prog_address_payload-- IP  UDP       -- print(prog_address) c:send(prog_address) srv=net.createUDPSocket()--     ,   data stop srv:listen(50000) -- uart.setup(0,9600,8,0,1,0) srv:on("receive", function(srv, pl) --      UDP pl=pl*1 -- print(pl) uart.write(0,pl) --    UART  AVR end) uart.on("data", 1, function(data) --    UART  AVR srv:send(50000,prog_address,data) --    UDP   end, 0) tmr.wdclr() end) end if (payload =="stop data\r\n") --      then ready = false if(srv~=nil) then srv:close() -- print("stop data") end collectgarbage() end if (payload =="stop program\r\n") then if(st~=nil) then st:close() frame1024=0 ProgrammingDisable () -- print("stop program") end collectgarbage() end end) end)</span></span></code> </pre><br></div></div><br>  Obviamente, isso vai contra o meu conceito, onde o ESP8266 √© uma ponte sem fio limpa e o microcontrolador ATMEL faz o resto, mas como eles dizem: "uma vez, n√£o ...". <br><br>  Portanto, obtivemos o tempo exato inicial (diretamente do servidor NTP ou indiretamente, atrav√©s do aplicativo no computador, n√£o importa), ent√£o gostar√≠amos de considerar o tempo.  Em primeiro lugar, n√£o h√° nada para carregar a rede e, em segundo lugar, o ATMEL teoricamente permite contar segundos com boa precis√£o.  Teoricamente, sim.  Mas, na pr√°tica, existem armadilhas. <br><br>  <b>Uma pequena digress√£o sobre o rel√≥gio em tempo real no AVR.</b> <br><br>  Em teoria, n√£o h√° nada complicado na constru√ß√£o de um rel√≥gio no microcontrolador AVR.  Os designers mais raivosos at√© enfiam um rel√≥gio de quartzo a 32768 Hz no circuito para isso.  Mas, de fato, isso n√£o √© necess√°rio.  De fato, √© necess√°rio um rel√≥gio de quartzo para formar uma interrup√ß√£o m√∫ltipla de segundo e ativar um microcontrolador <b>adormecido</b> (nota).  Se o seu dispositivo funcionar constantemente e o rel√≥gio normalmente funcionar, colocar quartzo adicional ao existente e colocar duas pernas de entrada e sa√≠da por baixo √© imprudente.  √â poss√≠vel usar um ressonador de quartzo, que j√° est√° l√°, oito ou dezesseis megahertz l√°.  Sua precis√£o de quantiza√ß√£o √© suficiente para seus olhos, e contar um segundo como contador de timer tamb√©m ser√° f√°cil. <br><br>  De fato, o microcontrolador AVR j√° tem tudo para isso.  Como voc√™ sabe, o sinal do rel√≥gio de entrada (por exemplo, 8 MHz) chega dentro do chip (por exemplo, AVRmega328P como o mais comum para o arduino) no chamado pr√©-divisor, onde pode ser dividido ainda mais pelo desejo do programador (geralmente por 8, 64, 256, 1024).  E ent√£o ele chega a algum tipo de contador de tempo (digamos T1), que imediatamente come√ßa a aumentar. <br><br>  Ent√£o, vamos pegar 8 MHz e dividir por 256. Recebemos, respectivamente, a frequ√™ncia do rel√≥gio do contador 31250 Hz.  Assim, como o contador T1 tem dezesseis d√≠gitos e pode contar de acordo com at√© 65535, ent√£o ele ter√° tempo para contar at√© 31250 em um segundo.  Do que precisamos.  Al√©m disso, nosso timer possui outro registro de compara√ß√£o muito √∫til.  Se escrevermos o n√∫mero 31250 l√°, em determinadas condi√ß√µes, ele ser√° constantemente comparado com o conte√∫do do contador T1 e, finalmente, quando for igual, o contador gerar√° um sinal de interrup√ß√£o, digamos, mantenha seu segundo. <br><br>  Acontece convenientemente, mas, infelizmente, n√£o √© totalmente preciso.  Para o nosso contador, contamos com um erro de quantiza√ß√£o de 256 / 8.000.000, o que gera um erro bastante grande no c√°lculo de um segundo em at√© 32 microssegundos.  E isso leva a um erro de 2,8 segundos por dia (0,000032 * 3600 * 24). <br>  Mas se dividirmos os 8 MHz originais por uma quantidade menor, por exemplo, por 64, a precis√£o da quantiza√ß√£o aumentar√° 4 vezes para 8 Œºs e reduzir√° o erro resultante para 0,33 segundos por dia.  Infelizmente, neste caso, o contador precisar√° ser contado at√© 125.000, e esse n√∫mero no registro de dezesseis bits n√£o ser√° inserido.  Teremos que escrever um n√∫mero menor no registro de compara√ß√£o (62500 ainda pode caber)) e adicionar um loop no pr√≥prio programa, em que um segundo ser√° contado n√£o por um, mas por duas interrup√ß√µes. <br><br>  Mas n√≥s escolhemos o case ideal, e um ressonador de quartzo real, especialmente instalado em uma placa ‚Äúfabricada na China‚Äù, pode lhe trazer muitas surpresas.  N√£o, em geral, se voc√™ observar o quartzo padr√£o nas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">folhas</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dados</a> , teoricamente nem tudo √© t√£o ruim. <br><br>  Como podemos ver, o quartzo intermedi√°rio se comporta muito bem.  Ele tem uma instabilidade de seu pr√≥prio ajuste a 25 ppm (ou seja, 25 ppm), ou seja, ele ressoa a uma frequ√™ncia n√£o de 8 MHz, mas, por exemplo, a uma frequ√™ncia de 8 0002 MHz, o que nos d√° 2,1 segundos de erro por dia.  Mas este √© um erro constante e pode ser levado em considera√ß√£o.  Esse quartzo tamb√©m pode flutuar a uma temperatura de 5 a 10 ppm por grau, mas nas condi√ß√µes operacionais do dispositivo, o erro tamb√©m ser√° pequeno.  Ainda existe um fator como o envelhecimento, mas √© muito escasso e altera as caracter√≠sticas do quartzo para um estado de pelo menos alguma visibilidade, bem, talvez cinco anos.  Ou dez. <br><br>  E aqui estamos felizes em pegar um clone chin√™s do arduino, por exemplo, ARDUINO UNO. <br><br><img src="https://habrastorage.org/webt/p0/bk/ca/p0bkca_wthxj3_9hx9ttr6ivzbw.png"><br><br>  Executamos nele um programa de teste para contar o tempo e o iniciamos.  Backlog por hora por um minuto?  F√°cil!  Segunda placa UNO Arduino?  N√£o √© melhor. <br><br>  Pegue o Arduino ProMini. <br><br><img src="https://habrastorage.org/webt/r4/b5/e6/r4b5e6ggnkxbbgmeefim9cv5-8i.jpeg"><br><br>  E aqui est√° melhor, sim.  O erro diminuiu para vinte segundos por hora.  Bem, j√° √© compar√°vel a um rel√≥gio mec√¢nico cuco. <br><br>  A √∫ltima placa que eu tinha em m√£os era o Arduino Nano. <br><br><img src="https://habrastorage.org/webt/k_/iz/iq/k_iziqqu4ag5ywb2rm39qlvi8ng.jpeg"><br><br>  E ela foi a √∫nica que mostrou resultados mais ou menos saud√°veis. <br><br>  Mas mesmo com esse quadro, usando apenas constru√ß√µes te√≥ricas, voc√™ mesmo entende que n√£o far√° uma observa√ß√£o exata.  A placa precisa ser configurada e eu, com um suspiro, subi atr√°s do oscilosc√≥pio. <br><br>  Como se viu, as placas do Arduino t√™m um recurso desagrad√°vel - a sa√≠da √† qual o ressonador de quartzo est√° conectado n√£o tem uma sa√≠da para o pente, embora corresponda √† porta PB7.  Como o porto √© ocupado por quartzo, voc√™ n√£o se apega a ele.  E bem ao p√© do microcontrolador, √© muito dif√≠cil pegar a sonda do oscilosc√≥pio, para montagem em superf√≠cie e um passo de 0,5 mm entre os terminais.  Mas at√© juntar a perna direita n√£o me deu nada.  Ou porque cutuquei incorretamente, ou cutuquei no lugar errado, porque a sa√≠da do ressonador de quartzo talvez n√£o seja a sa√≠da do gerador de clock e, em geral, est√° dentro do pr√≥prio microcontrolador.  Portanto, eu tive que contornar as solu√ß√µes alternativas - colocar o pr√©-calibrador no coeficiente de divis√£o m√≠nimo - um, escrever zero no registro de compara√ß√£o para que a interrup√ß√£o sacudisse imediatamente e entrar no microcontrolador em um modo especial no qual a perna da porta PB1 altera seu estado l√≥gico a cada interrup√ß√£o. <br>  Logicamente, quando voc√™ liga a placa Arduino Nano 16 MHz, um meandro de 8 MHz deve aparecer na sa√≠da desta porta. <br><br>  Foi o que aconteceu.  O oscilosc√≥pio mostrou uma frequ√™ncia de 8. 002 31 MHz.  Al√©m disso, a √∫ltima descarga teve vida pr√≥pria e eu ainda n√£o entendi se a precis√£o do oscilosc√≥pio est√° faltando ou se a frequ√™ncia do oscilador de cristal est√° flutuando assim.  Mais como um segundo. <br><br>  A boa estabilidade t√©rmica tamb√©m n√£o cheirava.  Se voc√™ respirar no quadro (talvez, a prop√≥sito, os recipientes ainda venham de umidade?) Ou traga um ferro de solda (de longe), o quartzo poder√° se mover imediatamente em cinquenta hertz.  E essas medidas ainda s√£o praticamente duplicadas, uma vez que a frequ√™ncia inicial √© de 16 MHz. <br><br>  Assim, em placas de arduino (pelo menos de origem chinesa) √© imposs√≠vel obter precis√£o superior a 200 Hz a uma frequ√™ncia de clock de 16 MHz.  O que nos d√° a precis√£o m√°xima dos rel√≥gios montados nessas placas, n√£o mais que um segundo por dia.  E isso √© bom. <br><br>  Porque existem clones chineses do Arduino UNO, j√° mencionados por mim anteriormente, com os quais, em geral, tudo est√° ruim.  E eles s√£o muito comuns, porque s√£o baratos e convenientes. <br><br>  Portanto, a frequ√™ncia delas pode diferir da declarada por mais de cem quilohertz!  O que √© at√© incomum at√© para o pior quartzo chin√™s. <br><br>  O enigma come√ßa com o fato de que 12 MHz s√£o escritos no pr√≥prio quartzo!  E nas descri√ß√µes dos vendedores tamb√©m. <br><br><img src="https://habrastorage.org/webt/5l/ab/pj/5labpjeqa-grafww3mkdqnnawb4.jpeg"><br><br>  Mas n√£o h√° 12 MHz, isso √© certo.  Se voc√™ ativar a porta serial UART na placa, ver√° por si mesmo.  Como o UART sintonizou essa frequ√™ncia, voc√™ n√£o funcionar√°.  E sintonizado a uma frequ√™ncia de 16 MHz - ser√°.  Al√©m disso, eu assisti pessoalmente √†s formas de onda em ambas as placas do Arduino Uno.  A primeira placa tinha uma frequ√™ncia de gerador de 15.8784 MHz e a segunda 15.8661 MHz. <br><br>  Mas, de repente, descobriu-se que o quartzo de 12 MHz n√£o est√° diretamente relacionado ao microcontrolador AVR, mas foi projetado para operar a porta serial com um computador via USB (para baixar esbo√ßos).  Portanto, a suposi√ß√£o de que n√£o havia quartzo no interior, mas uma cadeia RC mal ajustada, n√£o se materializou.  E o quartzo de que precisamos √© muito menor em tamanho e est√° localizado pr√≥ximo ao chip do microcontrolador.  Mas √© muito pequeno e n√£o h√° inscri√ß√£o. <br><br>        ,          . , ,    .  -         . ,       ,        ?   ,            . <br><br> <b> ¬´ ‚Äù AVR.</b> <br><br>  ,       ,       Arduino ProMini <br><br><div class="spoiler"> <b class="spoiler_title">     AVRmega328P</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Tibetian_Bowl.c * * Created: 07.06.2018 0:29:57 * Author: User */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> F_CPU 8000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;avr/io.h&gt; #include &lt;avr/interrupt.h&gt; #include &lt;stdint.h&gt;//    #include &lt;math.h&gt; //  #include &lt;stdio.h&gt; // - #include &lt;avr/eeprom.h&gt; #include &lt;stdbool.h&gt; #include &lt;setjmp.h&gt; #include &lt;stdlib.h&gt; volatile bool change_mode = false; volatile bool boom =false; volatile bool go_ahead=true; volatile bool go_back=false; volatile bool gerkon=false; volatile uint8_t latency=2;//     latency = 1 volatile uint8_t hour=12; volatile uint8_t hour24=12;//       12 volatile uint8_t minute=0; volatile uint8_t secund=0; volatile uint8_t power=0; volatile uint8_t pause_between_boom=0; volatile uint8_t first_byte=0; volatile uint8_t second_byte=0; volatile uint8_t third_byte=0; volatile uint8_t firth_byte=0; volatile uint8_t fifth_byte=0; volatile uint8_t cSREG; ISR(USART_RX_vect) { //     ,  //   ‚Äì  ,    . if (first_byte==0) { first_byte=UDR0; change_mode=true; goto ret; } if (second_byte==0) { second_byte=UDR0; goto ret; } if (third_byte==0) { third_byte=UDR0; goto ret; } if (firth_byte==0) { firth_byte=UDR0; goto ret; } if (fifth_byte==0) { fifth_byte=UDR0; goto ret; } cSREG=UDR0; ret: return; } ISR(PCINT1_vect )//PC2 int 10 //    { if (go_ahead) { UDR0=44; //      44 } if (go_back) { gerkon=true; } } ISR(TIMER1_COMPA_vect) { //        secund++; if (secund ==60) { secund=0; minute++; if(minute==60) { minute=0; hour++; if(hour==12) { hour=1;//     12  } hour24++; if(hour24==24) { hour24=1; } boom=true; } } } void time_delay(long dell)//       { long i; dell=dell*796;//  8  for(i=0;i&lt;dell;i++){;;}; sei();//    ,  -    .WTF ?????????????????????? } void turn_onkward()//       { uint8_t legnth=170;//    ( 0  170) for(uint16_t i =0;i&lt;=legnth;i++) { go_ahead=true; PORTB=0b00000010;//       time_delay(latency); PORTB=0b00000110; time_delay(latency); PORTB=0b00000100; time_delay(latency); PORTB=0b00001100; time_delay(latency); PORTB=0b00001000; time_delay(latency); PORTB=0b00011000; time_delay(latency); PORTB=0b00010000; time_delay(latency); PORTB=0b00010010; time_delay(latency); if (i&gt;140) { PORTD |=(1&lt;&lt;PORTD2);//     , 1 -   } } time_delay(100); go_ahead=false; } void turn_backward(uint8_t pause, uint8_t force_of_sound)//     // //       { uint8_t legnth=170;//       ( 0  170) for(uint16_t i =0;i&lt;=legnth;i++) { go_back=true; PORTB=0b00010010; time_delay(latency); PORTB=0b00010000; time_delay(latency); PORTB=0b00011000; time_delay(latency); PORTB=0b00001000; time_delay(latency); PORTB=0b00001100; time_delay(latency); PORTB=0b00000100; time_delay(latency); PORTB=0b00000110; time_delay(latency); PORTB=0b00000010;//16 ms   ,  latency = 2 time_delay(latency); if (i==force_of_sound*17) { PORTD &amp;=~(1&lt;&lt;PORTD2);//     , 0 -   } if (gerkon) { gerkon=false; break; } } time_delay(50); time_delay(pause*1000);//       go_back=false; } void sound(uint8_t force,uint8_t pause) //       1  10           { turn_onkward(); turn_backward(pause,force); } int main(void) { sei(); // UART  9600    8  time_delay(2000);//  , esp     -  UCSR0A=0; UCSR0B=0b10011000;// a UART UCSR0C=0b00000110; UBRR0L=51;// 8  9600  UART UBRR0H=0; //   INT0   2   10 //        PCICR|=(1&lt;&lt;PCIE1);//   14-8 PCMSK1|=(1&lt;&lt;PCINT10);//    INT10 DDRC&amp;=~(1&lt;&lt;PORTC2); DDRB=0b00111110;//PB1-PB4    , PB5      DDRD=0b00000100; // PD2      //SET INTERRUPT FROM TIMER1 AND SET TIMER1 GTCCR=0;//RESET PRESCALER TCCR1A=0;//I/O NORMAL WORK TCCR1C=0; TCCR1B=0B00001100;//1/256 PRESCALING AND CTC MODE TCNT1H=0;//RESET TIMER1 TCNT1L=0; TIMSK1=0B00000010;//SET COMPARE A INTERRUPT ENABLED OCR1AH=0x79;//SET TIME CONSTANT IN COMPARE REGISTER OCR1AL=0xa7;// 31143    7 972 608  TCCR0B=0b00000010;// 8        0  255 while (1) { begining: time_delay(1000); if (first_byte!=0) { UDR0=first_byte;//      .     (100,101,102)    } if (first_byte==100)//   (     NTP  { hour=second_byte;//  if (hour&gt;12)//      12  (24  ) { hour=hour-12; } if (hour==0) { hour=12; } minute=third_byte;//  secund=firth_byte;//  power=fifth_byte;//   first_byte=0;//   second_byte=0; third_byte=0; firth_byte=0; fifth_byte=0; change_mode=false; goto clock_mode; } if (first_byte==101)//   { power=second_byte; pause_between_boom=third_byte; first_byte=0; second_byte=0; third_byte=0; firth_byte=0; fifth_byte=0; change_mode=false; goto random_mode; } if (first_byte==102)//  { power=second_byte; first_byte=0; second_byte=0; third_byte=0; firth_byte=0; fifth_byte=0; change_mode=false; goto hand_mode; } //     ,      first_byte=0; second_byte=0; third_byte=0; firth_byte=0; fifth_byte=0; goto begining; clock_mode: while(change_mode==false) { if (boom)//   { for(uint8_t i =0;i&lt;hour;i++) { if ((hour24&gt;21)|(hour24&lt;10))//  { sound(3,0);//   10 (),  0  boom=false; } else { sound(power,0);//   10 (),  0  boom=false; } } } } goto begining; random_mode: while(change_mode==false) { uint8_t random_power = TCNT0;//      1 uint8_t random_pause = TCNT1L;//      1 random_pause=TCNT0;//      1 random_power=random_power/25; if (random_power&lt;5) { random_power=random_power+2;//      } random_pause=(random_pause/25)+pause_between_boom; UDR0=random_pause; time_delay(100); sound(random_power,random_pause); } goto begining; hand_mode: sound(power,0); goto begining; } }</span></span></span></span></code> </pre><br></div></div><br>   .   ,     ,    UART.   : <br><br> 100   <br> 101   <br> 102  . <br><br>  AVR  ,  ,        ESP8266.   , ESP    ,    NTP        .  ,       .   - 1  ,              -  ,   . <br><br>          ,      ,     . <br><br> <b>  .</b> <br><br>    ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> ,     . <br><br><img src="https://habrastorage.org/webt/cl/fo/k4/clfok4_1edajbwxdondtz9h9dpk.png"><br><br>       AVR  HTTP  UDP .             UDP . ,          , , -,      LUA  ,  -,     ,              UART.   ,  () AVR  .    ,   ,    ,      ,        ,        . <br><br>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">.</a> <br><br>  <br><br>          .        ,        ,    <s></s>  .     Arduino   . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt415629/">https://habr.com/ru/post/pt415629/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt415619/index.html">Apple e Samsung concluem guerra de patentes de 7 anos</a></li>
<li><a href="../pt415621/index.html">Sistema de monitoramento de minera√ß√£o</a></li>
<li><a href="../pt415623/index.html">A din√¢mica do v√¥o vertical de uma aeronave mais leve que o ar</a></li>
<li><a href="../pt415625/index.html">Kubernetes: webinar (4 de julho √†s 19:30) e intensivo (3-5 de agosto)</a></li>
<li><a href="../pt415627/index.html">Como (n√£o) voc√™ tem que ser um idiota: a hist√≥ria de um diretor t√©cnico</a></li>
<li><a href="../pt415637/index.html">Como a Yandex aplicou a tecnologia de intelig√™ncia artificial para traduzir p√°ginas da web</a></li>
<li><a href="../pt415641/index.html">Degusta√ß√£o de gaivotas. No arsenal de um hacker de r√°dio</a></li>
<li><a href="../pt415643/index.html">Magento Meetup Kharkov - reportagens em v√≠deo</a></li>
<li><a href="../pt415645/index.html">Um olhar sobre o Highload ++ da Sib√©ria</a></li>
<li><a href="../pt415647/index.html">A partir de 1¬∫ de julho, os servi√ßos de Internet s√£o necess√°rios para armazenar mensagens de usu√°rios russos por 6 meses</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>