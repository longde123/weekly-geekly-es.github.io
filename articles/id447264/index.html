<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ›€ğŸ¾ ğŸ‘¨ğŸ½â€ğŸ¤â€ğŸ‘¨ğŸ¼ ğŸ‘· Ignite Service Grid - Reboot ğŸ‘´ğŸ¾ ğŸ’‹ ğŸ¤¸ğŸ¿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada 26 Februari, kami mengadakan pertemuan Apache Ignite GreenSource, tempat kontributor open source proyek Apache Ignite melakukan. Peristiwa pentin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ignite Service Grid - Reboot</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/447264/">  Pada 26 Februari, kami mengadakan pertemuan Apache Ignite GreenSource, tempat kontributor open source proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apache Ignite</a> melakukan.  Peristiwa penting dalam kehidupan komunitas ini adalah restrukturisasi komponen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Grid Layanan Ignite</a> , yang memungkinkan Anda untuk menyebarkan layanan microsoft kustom langsung di cluster Ignite.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vyacheslav Daradur</a> , pengembang senior Yandex dan kontributor Apache Ignite selama lebih dari dua tahun, berbicara tentang proses yang sulit ini pada pertemuan tersebut. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/760/950/25c/76095025c0c68e0fd17702019d3357cc.png"><br><a name="habracut"></a><br>  Untuk mulai dengan, apa itu Apache Ignite secara umum.  Ini adalah database yang merupakan repositori Key / Value terdistribusi dengan dukungan untuk SQL, transaksional, dan caching.  Selain itu, Ignite memungkinkan Anda untuk menggunakan layanan pengguna secara langsung di cluster Ignite.  Pengembang menjadi tersedia semua alat yang Ignite menyediakan - struktur data terdistribusi, Messaging, Streaming, Compute dan Data Grid.  Misalnya, ketika menggunakan Kotak Data, masalah administrasi infrastruktur terpisah untuk gudang data dan, sebagai akibatnya, overhead yang dihasilkan dari ini menghilang. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/546/48f/754/54648f7549d3e955de20339ed49cb686.png"><br><br>  Menggunakan API Kotak Layanan, Anda dapat menggunakan layanan dengan hanya menentukan skema penyebaran dalam konfigurasi dan, karenanya, layanan itu sendiri. <br><br>  Biasanya, pola penyebaran adalah indikasi jumlah instance yang harus digunakan untuk node cluster.  Ada dua pola penyebaran yang khas.  Yang pertama adalah Cluster Singleton: kapan saja di cluster, satu contoh layanan pengguna akan dijamin akan tersedia.  Yang kedua adalah Node Singleton: satu instance dari layanan ini digunakan pada setiap node cluster. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2db/1b1/785/2db1b178520547827c39fc66e2f98b33.png"><br><br>  Pengguna juga dapat menentukan jumlah instance layanan di seluruh kluster dan menentukan predikat untuk memfilter node yang sesuai.  Dalam skenario ini, Kotak Layanan itu sendiri akan menghitung distribusi optimal untuk penyebaran layanan. <br><br>  Selain itu, ada fitur seperti Layanan Affinity.  Afinitas adalah fungsi yang mendefinisikan hubungan kunci dengan partisi dan hubungan pihak dengan simpul dalam topologi.  Dengan menggunakan kunci, Anda dapat menentukan simpul utama tempat data disimpan.  Dengan demikian, Anda dapat mengaitkan layanan Anda sendiri dengan kunci dan cache dari fungsi afinitas.  Jika fungsi afinitas berubah, operasi ulang otomatis akan terjadi.  Jadi layanan akan selalu ditempatkan di sebelah data yang harus dimanipulasi, dan, dengan demikian, mengurangi overhead akses ke informasi.  Skema semacam itu dapat disebut semacam komputasi yang ditempatkan. <br><br>  Sekarang kami telah mengetahui apa keindahan dari Service Grid, kami akan memberi tahu Anda tentang sejarah perkembangannya. <br><br><h2>  Apa yang sebelumnya </h2><br>  Implementasi sebelumnya dari Service Grid didasarkan pada cache sistem replikasi transite Ignite.  Kata "cache" di Ignite berarti penyimpanan.  Artinya, ini bukan sesuatu yang sementara, seperti yang mungkin Anda pikirkan.  Terlepas dari kenyataan bahwa cache dapat direplikasi dan setiap node berisi seluruh kumpulan data, di dalam cache ia memiliki tampilan yang dipartisi.  Ini karena optimasi penyimpanan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/93b/cff/f34/93bcfff34a86ed6da30dfdc4190600c6.png"><br><br>  Apa yang terjadi ketika pengguna ingin menggunakan layanan? <br><br><ul><li>  Semua node dalam cluster berlangganan untuk memperbarui data dalam repositori menggunakan mekanisme Continuous Query bawaan. <br></li><li>  Node yang memulai berdasarkan transaksi yang sudah dilakukan membuat catatan dalam database yang berisi konfigurasi layanan, termasuk instance serial. <br></li><li>  Setelah menerima pemberitahuan catatan baru, koordinator menghitung distribusi berdasarkan konfigurasi.  Objek yang dihasilkan ditulis kembali ke database. <br></li><li>  Node membaca informasi tentang distribusi baru dan menyebarkan layanan ke <br>  jika perlu. <br></li></ul><br><h2>  Apa yang tidak cocok untuk kita </h2><br>  Pada titik tertentu, kami sampai pada kesimpulan: tidak mungkin untuk bekerja dengan layanan.  Ada beberapa alasan. <br><br>  Jika beberapa jenis kesalahan terjadi selama penyebaran, maka Anda bisa mengetahuinya hanya dari log node di mana semuanya terjadi.  Hanya ada penyebaran yang tidak sinkron, jadi setelah mengembalikan kontrol dari metode penyebaran ke pengguna, butuh waktu ekstra untuk memulai layanan - dan pada saat itu pengguna tidak dapat mengendalikan apa pun.  Untuk mengembangkan Grid Layanan lebih lanjut, untuk melihat fitur-fitur baru, untuk menarik pengguna baru dan membuat hidup lebih mudah bagi semua orang, Anda perlu mengubah sesuatu. <br><br>  Saat merancang Grid Layanan baru, kami pertama-tama ingin memberikan jaminan penerapan yang sinkron: segera setelah pengguna mengembalikan kontrol dari API, ia dapat segera menggunakan layanan.  Saya juga ingin memberi inisiator kesempatan untuk menangani kesalahan penyebaran. <br><br>  Selain itu, saya ingin memfasilitasi implementasi, yaitu untuk menjauh dari transaksi dan penyeimbangan kembali.  Terlepas dari kenyataan bahwa cache dapat direplikasi dan tidak ada penyeimbangan, ada masalah selama penyebaran besar dengan banyak node.  Saat mengubah topologi, node perlu bertukar informasi, dan dengan penyebaran yang besar, data ini dapat banyak menimbang. <br><br>  Ketika topologi tidak stabil, koordinator perlu menghitung ulang distribusi layanan.  Dan secara umum, ketika Anda harus bekerja dengan transaksi pada topologi yang tidak stabil, ini dapat menyebabkan kesalahan yang sulit diprediksi. <br><br><h2>  Masalahnya </h2><br>  Apa perubahan global tanpa disertai masalah?  Yang pertama adalah perubahan topologi.  Anda perlu memahami bahwa kapan saja, bahkan pada saat penyebaran layanan, sebuah node dapat masuk atau keluar dari sebuah cluster.  Selain itu, jika pada saat penyebaran node memasuki cluster, akan diperlukan untuk secara konsisten mentransfer semua informasi tentang layanan ke node baru.  Dan kita berbicara tidak hanya tentang apa yang sudah dikerahkan, tetapi juga tentang penyebaran saat ini dan masa depan. <br><br>  Ini hanyalah salah satu masalah yang dapat disatukan dalam daftar terpisah: <br><br><ul><li>  Bagaimana cara menggunakan layanan yang dikonfigurasi secara statis saat memulai sebuah simpul? <br></li><li>  Node keluar dari cluster - bagaimana jika layanan host host? <br></li><li>  Apa yang harus dilakukan jika koordinator telah berubah? <br></li><li>  Apa yang harus dilakukan jika klien terhubung kembali ke kluster? <br></li><li>  Apakah saya perlu memproses permintaan aktivasi / deaktivasi dan bagaimana caranya? <br></li><li>  Tetapi bagaimana jika mereka disebut Hancurkan cache, dan kami memiliki layanan afinitas yang terikat padanya? <br></li></ul><br>  Dan itu belum semuanya. <br><br><h2>  Solusi </h2><br>  Sebagai target, kami memilih pendekatan Event Driven dengan implementasi proses komunikasi menggunakan pesan.  Ignite telah mengimplementasikan dua komponen yang memungkinkan node meneruskan pesan di antara mereka - komunikasi-spi dan penemuan-spi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11d/bf0/a76/11dbf0a76a9ec1c193af0b1037116534.png"><br><br>  Communication-spi memungkinkan node untuk berkomunikasi dan meneruskan pesan secara langsung.  Sangat cocok untuk mengirim data dalam jumlah besar.  Discovery-spi memungkinkan Anda untuk mengirim pesan ke semua node di cluster.  Dalam implementasi standar, ini dilakukan sesuai dengan topologi ring.  Ada juga integrasi dengan Zookeeper, dalam hal ini topologi bintang digunakan.  Poin penting lainnya yang perlu diperhatikan: discovery-spi menjamin bahwa pesan akan dikirim dalam urutan yang benar ke semua node. <br><br>  Pertimbangkan protokol penyebaran.  Semua permintaan pengguna untuk penyebaran dan distribusi dikirim melalui discovery-spi.  Ini memberikan <i>jaminan</i> berikut: <br><br><ul><li>  Permintaan akan diterima oleh semua node di cluster.  Ini akan memungkinkan Anda untuk terus memproses permintaan saat mengganti koordinator.  Ini juga berarti bahwa dalam satu pesan setiap node akan memiliki semua metadata yang diperlukan, seperti konfigurasi layanan dan contoh serialnya. <br></li><li>  Pesanan pengiriman pesan yang ketat memungkinkan Anda untuk menyelesaikan konflik konfigurasi dan permintaan yang bersaing. <br></li><li>  Karena input node ke topologi juga diproses oleh discovery-spi, semua data yang diperlukan untuk bekerja dengan layanan akan sampai ke node baru. <br></li></ul><br>  Setelah menerima permintaan, node dalam cluster memvalidasi dan membentuk tugas untuk diproses.  Tugas-tugas ini diantrekan dan kemudian diproses di utas lain oleh pekerja terpisah.  Ini diimplementasikan dengan cara ini, karena penyebaran bisa memakan waktu yang cukup lama dan menunda aliran penemuan yang mahal tidak dapat diterima. <br><br>  Semua permintaan dari antrian diproses oleh manajer penempatan.  Dia memiliki pekerja khusus yang menarik tugas dari antrian ini dan menginisialisasi untuk memulai penempatan.  Setelah ini, tindakan berikut terjadi: <br><br><ol><li>  Setiap node menghitung distribusi secara independen berkat fungsi penetapan deterministik baru. <br></li><li>  Node membentuk pesan dengan hasil penyebaran dan mengirimkannya ke koordinator. <br></li><li>  Koordinator mengumpulkan semua pesan dan menghasilkan hasil dari seluruh proses penyebaran, yang dikirim melalui discovery-spi ke semua node di cluster. <br></li><li>  Setelah menerima hasil, proses penyebaran selesai, setelah itu tugas dihapus dari antrian. <br></li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/6a6/add/3ef/6a6add3ef7ff9c01c4e31aa58b901171.png"><br>  <i>Desain berbasis event baru: org.apache.ignite.internal.processors.service.IgniteServiceProcessor.java</i> <br><br>  Jika kesalahan terjadi pada saat penyebaran, node segera menyertakan kesalahan ini dalam pesan, yang mengirimkannya ke koordinator.  Setelah pengumpulan pesan, koordinator akan memiliki informasi tentang semua kesalahan selama penyebaran dan akan mengirim pesan ini melalui discovery-spi.  Informasi kesalahan akan tersedia pada setiap simpul di gugus. <br><br>  Menurut algoritma ini, semua peristiwa penting di dalam Grid Layanan diproses.  Misalnya, perubahan topologi juga merupakan pesan penemuan-spi.  Dan secara umum, jika dibandingkan dengan apa itu, protokolnya ternyata cukup ringan dan dapat diandalkan.  Begitu banyak untuk menangani situasi apa pun selama penyebaran. <br><br><h2>  Apa yang akan terjadi selanjutnya? </h2><br>  Sekarang tentang rencananya.  Setiap pengembangan besar dalam proyek Ignite dilakukan sebagai inisiatif untuk meningkatkan Ignite, yang disebut IEP.  Perancangan ulang Grid Layanan juga memiliki IEP - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IEP No. 17</a> dengan nama olok-olok "Oil Change in Service Grid".  Tapi nyatanya, kami tidak mengganti oli di mesin, tapi seluruh mesin. <br><br>  Kami membagi tugas dalam IEP menjadi 2 fase.  Yang pertama adalah fase utama, yang terdiri dari mengubah protokol penempatan.  Sudah dituangkan ke panduan, Anda dapat mencoba Kotak Layanan baru, yang akan muncul di versi 2.8.  Fase kedua mencakup banyak tugas lain: <br><br><ul><li>  Penukaran panas <br></li><li>  Versi Layanan <br></li><li>  Peningkatan Resiliensi <br></li><li>  Klien yang kurus <br></li><li>  Alat untuk memantau dan menghitung berbagai metrik <br></li></ul><br>  Terakhir, kami dapat menyarankan Anda Service Grid untuk membangun sistem ketersediaan tinggi yang toleran terhadap kesalahan.  Kami juga mengundang Anda ke <a href="">dev-list</a> dan <a href="">daftar</a> <a href="">pengguna untuk</a> berbagi pengalaman Anda.  Pengalaman Anda sangat penting bagi komunitas, itu akan membantu Anda memahami ke mana harus pergi selanjutnya, bagaimana mengembangkan komponen di masa depan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id447264/">https://habr.com/ru/post/id447264/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id447254/index.html">Cara memasukkan parameter ke dalam metode tanpa parameter dalam kode aman</a></li>
<li><a href="../id447256/index.html">The Miracle of Materialize Magics: Nissan menghabiskan beberapa detik, bukannya berbulan-bulan bekerja</a></li>
<li><a href="../id447258/index.html">Security Week 15: serangan pada router dengan DNS spoofing</a></li>
<li><a href="../id447260/index.html">Live Share di Visual Studio 2019</a></li>
<li><a href="../id447262/index.html">Mempercepat situs dengan JivoSite. Unduh konsultan online tangguhan</a></li>
<li><a href="../id447266/index.html">Bahasa dan organ indera</a></li>
<li><a href="../id447268/index.html">Microsoft Azure Security Center Mengumumkan Fitur Baru</a></li>
<li><a href="../id447270/index.html">Luka perforasi BGP</a></li>
<li><a href="../id447274/index.html">Apa yang terjadi di balik layar C #: dasar-dasar bekerja dengan tumpukan</a></li>
<li><a href="../id447276/index.html">Apa perpustakaan ITIL dan mengapa perusahaan Anda membutuhkannya?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>