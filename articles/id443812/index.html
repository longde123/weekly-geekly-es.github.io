<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🤝‍👩🏽 🤳🏼 👠 Bagaimana menerapkan bahasa pemrograman dalam JavaScript. Bagian 2: Penerjemah 📦 🤽🏼 ❗️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo Saya hadir untuk Anda bagian kedua dari terjemahan saya panduan untuk menerapkan bahasa pemrograman JavaScript Anda - PL Tutorial . 
 Dari penerj...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana menerapkan bahasa pemrograman dalam JavaScript. Bagian 2: Penerjemah</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443812/"><p>  Halo  Saya hadir untuk Anda bagian kedua dari terjemahan saya panduan untuk menerapkan bahasa pemrograman JavaScript Anda - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PL Tutorial</a> . </p><br><h1 id="ot-perevodchika">  Dari penerjemah </h1><br><p>  Kami akan membuat bahasa pemrograman kami sendiri - <strong>bahasa λ</strong> (dalam bahasa asli - <strong>λ bahasa</strong> ).  Dalam proses pembuatan, kami akan menggunakan banyak teknik menarik, seperti keturunan rekursif, kontrol gaya transfer, dan teknik optimasi dasar.  Dua versi penerjemah akan dibuat - penerjemah reguler dan CPS, trans-kompiler dalam JavaScript. </p><br><p>  Penulis aslinya adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mihai Bazon</a> , penulis perpustakaan UglifyJS yang terkenal (alat untuk meminimalkan dan memformat kode JS). </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Isi</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana menerapkan bahasa pemrograman dalam JavaScript.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1: Parser</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana menerapkan bahasa pemrograman dalam JavaScript.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2: Penerjemah</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana menerapkan bahasa pemrograman dalam JavaScript.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3: juru bahasa CPS</a> </li><li>  Bagaimana menerapkan bahasa pemrograman dalam JavaScript.  Bagian 4: Kompilasi Trans dalam JS </li></ol></div></div><br><p> PS Ada bug di interpreter dan compiler: dalam ekspresi seperti <code>a() &amp;&amp; b()</code> atau <code>a() || b()</code>  <code>a() || b()</code> kedua bagian selalu dieksekusi.  Ini, tentu saja, salah karena <code>a()</code> salah untuk operator <code>&amp;&amp;</code> , atau tidak salah untuk <code>||</code>  , maka nilai <code>b()</code> tidak memainkan peran apa pun.  Ini tidak sulit untuk diperbaiki. </p><br><h1 id="prostoy-interpretator">  Penerjemah sederhana </h1><br><p>  Di bagian sebelumnya, kami menulis 3 fungsi: <code>InputStream</code> , <code>TokenStream</code> dan <code>parse</code> .  Untuk mendapatkan AST dari kode, kami menggunakan kode berikut: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ast = parse(TokenStream(InputStream(code)));</code> </pre> <br><p>  Menulis penerjemah lebih mudah daripada parser: kita hanya melintasi pohon secara rekursif dan mengeksekusi ekspresi dalam urutan normal mereka. </p><br><h2 id="kontekst-environment">  Konteks ( <code>Environment</code> ) </h2><br><p>  Untuk eksekusi kode yang tepat, kita memerlukan konteks - objek yang berisi semua variabel di lokasi tertentu.  Ini akan diteruskan sebagai argumen ke fungsi <code>evaluate</code> . </p><br><p>  Setiap kali kita memasukkan node <code>lambda</code> , kita harus menambahkan variabel baru ke argumen konteks - fungsi.  Jika argumen tumpang tindih variabel dari blok eksternal, kita harus mengembalikan nilai variabel lama setelah keluar dari fungsi. </p><br><p>  Cara termudah untuk melakukan ini adalah dengan menggunakan warisan prototipe JavaScript.  Ketika kita memasukkan fungsi baru, kita membuat konteks baru, mengatur konteks eksternal sebagai prototipe, dan memanggil fungsi dalam konteks baru.  Berkat ini, kami tidak memiliki apa-apa - dalam konteks eksternal semua variabelnya akan tetap ada. </p><br><p>  Berikut ini adalah implementasi objek <code>Environment</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Environment</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">parent</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.vars = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(parent ? parent.vars : <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.parent = parent; } Environment.prototype = { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Environment(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }, <span class="hljs-attr"><span class="hljs-attr">lookup</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (scope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.hasOwnProperty.call(scope.vars, name)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> scope; scope = scope.parent; } }, <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.vars) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.vars[name]; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Undefined variable "</span></span> + name); }, <span class="hljs-attr"><span class="hljs-attr">set</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lookup(name); <span class="hljs-comment"><span class="hljs-comment">//          if (!scope &amp;&amp; this.parent) throw new Error("Undefined variable " + name); return (scope || this).vars[name] = value; }, def: function(name, value) { return this.vars[name] = value; } };</span></span></code> </pre> <br><p>  Objek <code>Environment</code> memiliki bidang <code>parent</code> yang menunjuk ke konteks eksternal.  Ini akan menjadi <code>null</code> untuk konteks global.  Ini memiliki bidang <code>vars</code> di mana ada semua variabel yang termasuk dalam konteks ini.  Untuk konteks global, itu langsung sama dengan objek kosong ( <code>Object.create(null)</code> ) dan salinan variabel dari konteks induk ( <code>Object.create(parent.vars)</code> ) untuk yang non-global. </p><br><p>  Ini memiliki beberapa metode: </p><br><ul><li>  <code>extend()</code> - salin konteks saat ini. </li><li>  <code>lookup(name)</code> - menemukan konteks di mana variabel bernama <code>name</code> didefinisikan. </li><li>  <code>get(name)</code> - dapatkan nilai dari variabel bernama <code>name</code> .  Melempar pengecualian jika variabel belum ditentukan. </li><li>  <code>set(name, value)</code> - mengatur nilai suatu variabel.  Metode ini mencari konteks di mana variabel didefinisikan.  Jika tidak didefinisikan, dan kami tidak dalam konteks global, pengecualian akan dilemparkan. </li><li>  <code>def(name, value)</code> - membuat (atau tumpang tindih atau menimpa) variabel dalam konteks saat ini. </li></ul><br><h2 id="funkciya-evaluate">  <code>evaluate</code> fungsi </h2><br><p>  Sekarang kita memiliki objek <code>Environment</code> , kita dapat melanjutkan untuk menyelesaikan masalah utama.  Fungsi ini akan menjadi blok <code>switch</code> besar, yang akan melakukan beberapa tindakan tergantung pada jenis node yang ditransmisikan: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">exp, env</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (exp.type) {</code> </pre> <br><p>  Untuk literal, kami cukup mengembalikan nilainya: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"num"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"str"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"bool"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> exp.value;</code> </pre> <br><p>  Variabel diambil dari konteks (nama variabel terkandung dalam bidang <code>value</code> ): </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"var"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> env.get(exp.value);</code> </pre> <br><p>  Untuk menetapkan, kita harus memastikan bahwa di sisi kiri kita memiliki nama variabel (node <code>var</code> ).  Jika tidak, maka kami hanya melempar pengecualian (kami tidak mendukung penugasan ke variabel selain variabel).  Selanjutnya, kita mengatur nilai variabel menggunakan <code>env.set</code> .  Perhatikan bahwa sisi kanan ekspresi harus dihitung menggunakan panggilan rekursif untuk <code>evaluate</code> : </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"assign"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exp.left.type != <span class="hljs-string"><span class="hljs-string">"var"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Cannot assign to "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(exp.left)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> env.set(exp.left.value, evaluate(exp.right, env));</code> </pre> <br><p>  Untuk simpul tipe <code>binary</code> kita harus menerapkan operator untuk kedua operan.  Kami akan menulis fungsi <code>apply_op</code> nanti.  Juga, kami memanggil <code>evaluate</code> untuk kedua bagian ekspresi: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"binary"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> apply_op(exp.operator, evaluate(exp.left, env), evaluate(exp.right, env));</code> </pre> <br><p>  Sebuah simpul tipe <code>lambda</code> akan mengembalikan penutupan JavaScript normal, sehingga dapat disebut seperti fungsi biasa bahkan dari JavaScript.  Saya menambahkan fungsi <code>make_lambda</code> , yang akan saya tunjukkan nanti: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"lambda"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_lambda(env, exp);</code> </pre> <br><p>  Eksekusi dari simpul <code>if</code> cukup sederhana: pertama kita temukan nilai kondisinya.  Jika tidak salah, maka kembalikan nilai cabang <code>then</code> .  Kalau tidak, jika ada cabang <code>else</code> , maka nilainya, atau <code>false</code> : </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"if"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cond = evaluate(exp.cond, env); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cond !== <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluate(exp.then, env); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> exp.else ? evaluate(exp.else, env) : <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br><p>  Node <code>prog</code> adalah urutan ekspresi.  Kami cukup menjalankan semua ekspresi secara berurutan dan mengambil nilai yang terakhir (nilai urutan kosong <code>false</code> ): </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"prog"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> val = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; exp.prog.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">exp</span></span></span><span class="hljs-function">)</span></span>{ val = evaluate(exp, env) }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val;</code> </pre> <br><p>  Untuk simpul <code>call</code> tipe <code>call</code> kita perlu memanggil fungsi.  Sebelum itu, kita akan menemukan nilai fungsi itu sendiri, menemukan nilai semua argumen dan memanggil fungsi menggunakan <code>apply</code> : </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"call"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> func = evaluate(exp.func, env); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> func.apply(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, exp.args.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arg</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluate(arg, env); }));</code> </pre> <br><p>  Kami tidak akan pernah sampai di sini, tetapi jika kami menambahkan tipe simpul baru ke parser dan lupa menambahkannya ke juru bahasa: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"I don't know how to evaluate "</span></span> + exp.type); } }</code> </pre> <br><p>  Ini adalah bagian utama dari penerjemah.  Di atas, kami menggunakan dua fungsi yang belum kami implementasikan, jadi mari kita mulai: </p><br><h4 id="apply_op">  <code>apply_op</code> : </h4><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply_op</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">op, a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">num</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> x != <span class="hljs-string"><span class="hljs-string">"number"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Expected number but got "</span></span> + x); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">div</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num(x) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Divide by zero"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (op) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"+"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) + num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"-"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) - num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"*"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) * num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"/"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) / div(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"%"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) % div(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"&amp;&amp;"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a !== <span class="hljs-literal"><span class="hljs-literal">false</span></span> &amp;&amp; b; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"||"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a !== <span class="hljs-literal"><span class="hljs-literal">false</span></span> ? a : b; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) &lt; num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"&gt;"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) &gt; num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;="</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) &lt;= num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"&gt;="</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) &gt;= num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"=="</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a === b; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"!="</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a !== b; } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Can't apply operator "</span></span> + op); }</code> </pre> <br><p>  Ia menerima jenis dan argumen operator.  <code>switch</code> sederhana dan intuitif.  Tidak seperti JavaScript, yang dapat mengambil nilai apa pun, seperti variabel, bahkan yang tidak masuk akal.  Kami mengharuskan operan operator aritmatika menjadi angka dan tidak mengizinkan pembagian dengan nol.  Untuk string, kita akan menemukan sesuatu nanti. </p><br><h4 id="make_lambda">  <code>make_lambda</code> : </h4><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">env, exp</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> names = exp.vars; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = env.extend(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; names.length; ++i) scope.def(names[i], i &lt; <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.length ? <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[i] : <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluate(exp.body, scope); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lambda; }</code> </pre> <br><p>  Seperti yang Anda lihat di atas, ia mengembalikan fungsi JavaScript biasa yang menggunakan konteks yang diteruskan dan fungsi AST.  Semua pekerjaan dilakukan hanya ketika fungsi itu sendiri disebut: konteks dibuat, argumen ditetapkan (jika mereka tidak cukup, mereka menjadi <code>false</code> ).  Selanjutnya, tubuh fungsi hanya dieksekusi dalam konteks baru. </p><br><h4 id="nativnye-funkcii">  Fungsi asli </h4><br><p>  Seperti yang Anda lihat, kami tidak punya cara untuk berinteraksi dengan JavaScript dari bahasa kami.  Saya dulu menggunakan fungsi <code>print</code> dan <code>println</code> , tapi saya tidak mendefinisikannya di mana pun.  Kita perlu menulisnya dalam JavaScript dan hanya menambahkannya ke konteks global. </p><br><p>  Berikut ini contoh kode tersebut: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  -   var code = "sum = lambda(x, y) x + y; print(sum(2, 3));"; // ,  parse  TokenStream,      InputStream var ast = parse(TokenStream(InputStream(code))); //    var globalEnv = new Environment(); //  ""  "print" globalEnv.def("print", function(txt){ console.log(txt); }); //  evaluate(ast, globalEnv); //  5</span></span></code> </pre> <br><h4 id="ves-kod">  Seluruh kode </h4><br><p>  Anda dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengunduh semua kode</a> yang telah kami tulis selama ini.  Itu dapat diluncurkan menggunakan NodeJS.  Cukup berikan kode ke aliran standar: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'sum = lambda(x, y) x + y; println(sum(2, 3));'</span></span> | node lambda-eval1.js</code> </pre> <br><h1 id="primery-koda">  Contoh kode </h1><br><p>  Bahasa pemrograman kami, meskipun sederhana, dapat (secara teoritis) menyelesaikan masalah yang dapat diselesaikan oleh komputer sama sekali.  Ini karena beberapa pria lebih pintar daripada saya - Alonzo Church dan Alan Turing - pernah membuktikan bahwa λ-calculus (lambda calculus) setara dengan mesin Turing, dan bahasa kami mengimplementasikan λ-calculus. </p><br><p>  Ini berarti bahwa meskipun bahasa kita tidak memiliki peluang, kita semua dapat mewujudkannya menggunakan apa yang sudah kita miliki.  Atau, jika ini sulit dilakukan, kita dapat menulis penerjemah untuk bahasa lain di sini. </p><br><h4 id="cikly">  Siklus </h4><br><p>  Loop tidak menjadi masalah jika kita mengalami rekursi.  Saya sudah menunjukkan contoh loop diimplementasikan di atas rekursi.  Ayo kita coba lagi. </p><br><pre> <code class="python hljs">print_range = λ(a, b) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a &lt;= b { print(a); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a + <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;= b { print(<span class="hljs-string"><span class="hljs-string">", "</span></span>); print_range(a + <span class="hljs-number"><span class="hljs-number">1</span></span>, b); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> println(<span class="hljs-string"><span class="hljs-string">""</span></span>); }; print_range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre> <br><p>  Tetapi di sini kita memiliki masalah: jika kita menambah jumlah iterasi, katakanlah menjadi 1000. Sebagai contoh, saya mendapatkan kesalahan “Ukuran stack panggilan maksimum terlampaui” setelah 600. Ini terjadi karena interpreter bersifat rekursif dan rekursi mencapai kedalaman maksimum. </p><br><p>  Ini masalah serius, tetapi ada solusinya.  Saya ingin menambahkan konstruksi baru untuk iterasi ( <code>for</code> atau <code>while</code> ), tapi mari kita coba lakukan tanpa itu.  Rekursi itu terlihat indah, jadi mari kita tinggalkan.  Kita akan lihat nanti bagaimana cara mengatasi batasan ini. </p><br><h4 id="struktury-dannyh-ih-otsutstvie">  Struktur data (ketiadaan) </h4><br><p>  Ada tiga jenis data dalam bahasa λ kami: angka, string, dan tipe Boolean.  Tampaknya Anda tidak dapat membuat tipe yang kompleks, seperti array, atau objek.  Tapi ini bukan tat, kita punya satu lagi jenis: fungsi.  Ternyata jika kita mengikuti kalkulus λ, maka kita dapat membuat struktur data apa pun, termasuk objek, bahkan dengan warisan. </p><br><p>  Saya akan menunjukkannya pada contoh daftar.  Mari kita bayangkan bahwa kita memiliki fungsi <code>cons</code> yang menciptakan objek yang berisi dua nilai.  Sebut objek ini "sel" atau "pasangan."  Kami akan memberi nama salah satu nilai "mobil" dan yang lainnya "cdr".  Hanya karena mereka disebut dalam Lisp.  Sekarang, jika kita memiliki objek "sel", maka kita bisa mendapatkan nilainya menggunakan fungsi <code>car</code> dan <code>cdr</code> : </p><br><pre> <code class="python hljs">x = cons(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>); print(car(x)); <span class="hljs-comment"><span class="hljs-comment">#  10 print(cdr(x)); #  20</span></span></code> </pre> <br><p>  Sekarang kita dapat dengan mudah mendefinisikan daftar: </p><br><blockquote>  Daftar adalah pasangan yang mengandung elemen pertama di `car` dan elemen lainnya di` cdr`.  Tetapi `cdr` hanya dapat berisi satu nilai!  Nilai ini akan menjadi daftar.  Daftar adalah pasangan yang mengandung elemen pertama di `car` dan elemen lainnya di` cdr`.  Tetapi `cdr` hanya dapat berisi satu nilai!  Nilai ini akan menjadi daftar.  [...] <br></blockquote><p>  Ini adalah tipe data rekursif.  Tetapi satu masalah tetap ada: kapan Anda harus berhenti?  Secara logis, kita harus berhenti ketika <code>cdr</code> adalah daftar kosong.  Tetapi apa itu daftar kosong?  Untuk melakukan ini, mari kita tambahkan objek baru yang disebut "NIL".  Ini dapat digunakan sebagai pasangan (kita dapat menggunakan <code>car</code> dan <code>cdr</code> di atasnya, tetapi hasilnya adalah <code>NIL</code> itu sendiri).  Sekarang mari kita buat daftar item 1, 2, 3, 4, 5: </p><br><pre> <code class="python hljs">x = cons(<span class="hljs-number"><span class="hljs-number">1</span></span>, cons(<span class="hljs-number"><span class="hljs-number">2</span></span>, cons(<span class="hljs-number"><span class="hljs-number">3</span></span>, cons(<span class="hljs-number"><span class="hljs-number">4</span></span>, cons(<span class="hljs-number"><span class="hljs-number">5</span></span>, NIL))))); print(car(x)); <span class="hljs-comment"><span class="hljs-comment"># 1 print(car(cdr(x))); # 2  Lisp  . cadr print(car(cdr(cdr(x)))); # 3 caddr print(car(cdr(cdr(cdr(x))))); # 4 cadddr print(car(cdr(cdr(cdr(cdr(x)))))); # 5     .</span></span></code> </pre> <br><p>  Ini terlihat mengerikan ketika tidak ada sintaks khusus untuk ini.  Tapi saya hanya ingin menunjukkan bahwa ini dapat dilakukan dengan menggunakan fitur bahasa λ yang ada.  Berikut implementasinya: </p><br><pre> <code class="python hljs">cons = λ(a, b) λ(f) f(a, b); car = λ(cell) cell(λ(a, b) a); cdr = λ(cell) cell(λ(a, b) b); NIL = λ(f) f(NIL, NIL);</code> </pre> <br><p>  Ketika saya pertama kali melihat <code>cons</code> / <code>car</code> / <code>cdr</code> dibuat dengan cara ini, saya terkejut bahwa mereka tidak memerlukan satu <code>if</code> (tapi ini aneh mengingat fakta bahwa itu tidak ada dalam λ-calculus asli).  Tentu saja, tidak ada bahasa pemrograman yang melakukan hal ini, karena ini sangat tidak efisien, tetapi tidak membuat λ-calculi kurang indah.  Dalam bahasa yang jelas, kode ini melakukan hal berikut: </p><br><ul><li>  fungsi <code>cons</code> mengambil dua nilai ( <code>a</code> dan <code>b</code> ) dan mengembalikan fungsi yang menampungnya.  Fungsi itu adalah objek utama pasangan.  Dia mengambil argumen dan menyebutnya untuk kedua nilai pasangan. </li><li>  Fungsi <code>car</code> memanggil argumen yang diteruskan, melewati fungsi yang mengembalikan argumen pertama. </li><li>  fungsi <code>cdr</code> melakukan hal yang sama dengan fungsi <code>car</code> , tetapi dengan satu-satunya perbedaan adalah bahwa fungsi yang dikirimkan mengembalikan argumen kedua. </li><li>  fungsi <code>NIL</code> bekerja sama dengan <code>cons</code> , tetapi mengembalikan pasangan dengan dua nilai yang sama dengan NIL. </li></ul><br><pre> <code class="python hljs">cons = λ(a, b) λ(f) f(a, b); car = λ(cell) cell(λ(a, b) a); cdr = λ(cell) cell(λ(a, b) b); NIL = λ(f) f(NIL, NIL); x = cons(<span class="hljs-number"><span class="hljs-number">1</span></span>, cons(<span class="hljs-number"><span class="hljs-number">2</span></span>, cons(<span class="hljs-number"><span class="hljs-number">3</span></span>, cons(<span class="hljs-number"><span class="hljs-number">4</span></span>, cons(<span class="hljs-number"><span class="hljs-number">5</span></span>, NIL))))); println(car(x)); <span class="hljs-comment"><span class="hljs-comment"># 1 println(car(cdr(x))); # 2 println(car(cdr(cdr(x)))); # 3 println(car(cdr(cdr(cdr(x))))); # 4 println(car(cdr(cdr(cdr(cdr(x)))))); # 5</span></span></code> </pre> <br><p>  Ada banyak algoritma pada daftar yang dapat diimplementasikan secara rekursif dan terlihat logis.  Misalnya, berikut adalah fungsi yang memanggil fungsi yang diteruskan untuk setiap item daftar: </p><br><pre> <code class="python hljs">foreach = λ(list, f) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> list != NIL { f(car(list)); foreach(cdr(list), f); }; foreach(x, println);</code> </pre> <br><p>  Dan di sini ada satu lagi yang membuat daftar untuk sejumlah angka: </p><br><pre> <code class="python hljs">range = λ(a, b) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a &lt;= b then cons(a, range(a + <span class="hljs-number"><span class="hljs-number">1</span></span>, b)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> NIL; <span class="hljs-comment"><span class="hljs-comment">#     1  8 foreach(range(1, 8), λ(x) println(x * x));</span></span></code> </pre> <br><p>  Daftar yang kami terapkan di atas tidak dapat diubah (kami tidak dapat mengubah <code>car</code> atau <code>cdr</code> setelah daftar dibuat).  Sebagian besar Lisp memiliki fungsi untuk mengubah pasangan.  Dalam Skema mereka disebut <code>set-car!</code>  / <code>set-cdr!</code>  .  Dalam Common Lisp, <code>rplaca</code> / <code>rplacd</code> .  Kali ini kami menggunakan nama-nama dari Skema: </p><br><pre> <code class="python hljs">cons = λ(x, y) λ(a, i, v) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a == <span class="hljs-string"><span class="hljs-string">"get"</span></span> then <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">0</span></span> then x <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">0</span></span> then x = v <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> y = v; car = λ(cell) cell(<span class="hljs-string"><span class="hljs-string">"get"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); cdr = λ(cell) cell(<span class="hljs-string"><span class="hljs-string">"get"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); set-car! = λ(cell, val) cell(<span class="hljs-string"><span class="hljs-string">"set"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, val); set-cdr! = λ(cell, val) cell(<span class="hljs-string"><span class="hljs-string">"set"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, val); <span class="hljs-comment"><span class="hljs-comment">#  NIL     NIL = cons(0, 0); set-car!(NIL, NIL); set-cdr!(NIL, NIL); ## : x = cons(1, 2); println(car(x)); # 1 println(cdr(x)); # 2 set-car!(x, 10); set-cdr!(x, 20); println(car(x)); # 10 println(cdr(x)); # 20</span></span></code> </pre> <br><p>  Ini menunjukkan bahwa kita dapat menerapkan struktur data yang bisa berubah.  Saya tidak akan masuk jauh ke cara kerjanya, jelas dari kode. </p><br><p>  Kita dapat melangkah lebih jauh dan mengimplementasikan objek, tetapi tanpa perubahan dalam sintaks akan sulit untuk dilakukan.  Cara lain adalah dengan mengimplementasikan sintaks baru dalam tokenizer / parser dan menambahkan pemrosesan mereka dalam interpreter.  Semua bahasa pemrograman utama melakukan ini, dan perlu untuk mencapai kinerja normal.  Kami akan menambahkan sintaks baru di bagian artikel selanjutnya. </p><br><p>  [Dari penerjemah: jika Anda tertarik dengan lambda calculus, ada artikel keren tentang Habré yang didedikasikan untuk topik ini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lambda calculus dalam JavaScript</a> .] </p><br><h1 id="novye-sintaksicheskie-konstrukcii">  Konstruksi sintaksis baru </h1><br><p>  Bahasa λ kami memiliki beberapa konstruksi sintaksis.  Misalnya, tidak ada cara langsung untuk menambahkan variabel baru.  Seperti yang saya katakan sebelumnya, kita harus menggunakan IIFE, sehingga terlihat seperti ini: </p><br><pre> <code class="python hljs">(λ(x, y){ (λ(z){ <span class="hljs-comment"><span class="hljs-comment">## it gets worse when one of the vars depends on another print(x + y + z); })(x + y); })(2, 3);</span></span></code> </pre> <br><p>  Kami akan menambahkan kata kunci <code>let</code> .  Ini akan memungkinkan kami untuk menulis sesuatu seperti ini: </p><br><pre> <code class="python hljs">let (x = <span class="hljs-number"><span class="hljs-number">2</span></span>, y = <span class="hljs-number"><span class="hljs-number">3</span></span>, z = x + y) print(x + y + z);</code> </pre> <br><p>  Untuk setiap variabel di blok <code>let</code> , variabel sebelumnya harus tersedia bahkan dari blok yang sama.  Karenanya, kode di atas akan setara dengan yang berikut: </p><br><pre> <code class="python hljs">(λ(x){ (λ(y){ (λ(z){ print(x + y + z); })(x + y); })(<span class="hljs-number"><span class="hljs-number">3</span></span>); })(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br><p>  Perubahan-perubahan ini dapat dilakukan secara langsung di parser dan kemudian tidak akan membutuhkan perubahan dalam penerjemah.  Alih-alih menambahkan node <code>let</code> baru, kita dapat mengubahnya menjadi node <code>call</code> dan <code>lambda</code> .  Ini berarti bahwa kami tidak melakukan perubahan semantik dalam bahasa kami - ini disebut "gula sintaksis", dan operasi mengubah ini menjadi node AST yang ada sebelumnya disebut "tanpa gula" (asli: "desugaring"). </p><br><p>  Namun, kita harus mengganti pengurai.  Mari kita tambahkan "let" node baru karena dapat ditafsirkan lebih efisien (tidak perlu membuat penutupan dan memanggil mereka segera, kita hanya perlu menyalin dan mengubah konteksnya). </p><br><p>  Kami juga akan menambahkan dukungan untuk "beri nama", yang ada di Skema.  Itu membuatnya lebih mudah untuk membuat loop: </p><br><pre> <code class="python hljs">print(let loop (n = <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> then n + loop(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  Ini adalah loop "rekursif" yang menghitung jumlah 10 + 9 + ... + 0. Sebelumnya, kita harus melakukannya seperti ini: </p><br><pre> <code class="python hljs">print((λ(loop){ loop = λ(n) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> then n + loop(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; loop(<span class="hljs-number"><span class="hljs-number">10</span></span>); })());</code> </pre> <br><p>  Selain itu, untuk mempermudah ini, kami akan menambahkan sintaks "fungsi dengan nama".  Ini akan terlihat seperti ini: </p><br><pre> <code class="python hljs">print((λ loop (n) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> then n + loop(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-number"><span class="hljs-number">10</span></span>));</code> </pre> <br><p>  Modifikasi yang perlu dilakukan untuk ini: </p><br><ul><li>  Dukungan untuk nama opsional setelah kata kunci <code>lambda</code> .  Jika ada, maka kita harus menambahkan variabel ke konteks saat ini yang akan menunjuk ke fungsi itu sendiri.  Ini persis sama dengan fungsi dengan nama dalam JavaScript. </li><li>  Dukungan untuk kata kunci <code>let</code> baru.  Berikutnya adalah nama opsional dan daftar (mungkin kosong) definisi variabel dalam formulir ini: <code>foo = EXPRESSION</code> , dipisahkan oleh koma.  Tubuh ekspresi <code>let</code> adalah ekspresi tunggal (yang, tentu saja, dapat menjadi urutan ekspresi). </li></ul><br><h4 id="izmeneniya-v-parsere">  Perubahan Parser </h4><br><p>  Pertama, perubahan kecil dalam tokenizer, tambahkan kata kunci <code>let</code> ke daftar kata kunci: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keywords = <span class="hljs-string"><span class="hljs-string">" let if then else lambda λ true false "</span></span>;</code> </pre> <br><p>  Ubah fungsi <code>parse_lambda</code> ia membaca nama opsional: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"lambda"</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: input.peek().type == <span class="hljs-string"><span class="hljs-string">"var"</span></span> ? input.next().value : <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-comment"><span class="hljs-comment">//   vars: delimited("(", ")", ",", parse_varname), body: parse_expression() }; }</span></span></code> </pre> <br><p>  Sekarang tambahkan fungsi yang mem-parsing ekspresi <code>let</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_let</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ skip_kw(<span class="hljs-string"><span class="hljs-string">"let"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (input.peek().type == <span class="hljs-string"><span class="hljs-string">"var"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = input.next().value; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> defs = delimited(<span class="hljs-string"><span class="hljs-string">"("</span></span>, <span class="hljs-string"><span class="hljs-string">")"</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, parse_vardef); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"call"</span></span>, <span class="hljs-attr"><span class="hljs-attr">func</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"lambda"</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: name, <span class="hljs-attr"><span class="hljs-attr">vars</span></span>: defs.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">def</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> def.name }), <span class="hljs-attr"><span class="hljs-attr">body</span></span>: parse_expression(), }, <span class="hljs-attr"><span class="hljs-attr">args</span></span>: defs.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">def</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> def.def || FALSE }) }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"let"</span></span>, <span class="hljs-attr"><span class="hljs-attr">vars</span></span>: delimited(<span class="hljs-string"><span class="hljs-string">"("</span></span>, <span class="hljs-string"><span class="hljs-string">")"</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, parse_vardef), <span class="hljs-attr"><span class="hljs-attr">body</span></span>: parse_expression(), }; }</code> </pre> <br><p>  Ini menangani dua kasus.  Jika setelah <code>let</code> ada token tipe <code>var</code> , maka ini <code>let</code> dengan nama.  Selanjutnya, kami membaca daftar definisi menggunakan fungsi yang <code>delimited</code> , karena mereka berada dalam tanda kurung dan dipisahkan oleh koma, dan kami menggunakan fungsi <code>parse_vardef</code> , yang ditunjukkan di bawah ini.  Selanjutnya, kami mengembalikan simpul tipe <code>call</code> , yang segera memanggil fungsi bernama (IIFE).  Argumen untuk fungsi adalah variabel yang ditentukan oleh <code>let</code> , dan node <code>call</code> akan meneruskan nilai sebagai argumen.  Dan, tentu saja, isi fungsi dibaca menggunakan <code>parse_expression()</code> . </p><br><p>  Jika <code>let</code> sederhana, maka kita mengembalikan simpul tipe <code>let</code> dengan <code>vars</code> dan bidang isian.  Bidang <code>vars</code> berisi larik variabel dalam format berikut: <code>{ name: VARIABLE, def: AST }</code> , yang diuraikan oleh fungsi berikut: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_vardef</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = parse_varname(), def; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_op(<span class="hljs-string"><span class="hljs-string">"="</span></span>)) { input.next(); def = parse_expression(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: name, <span class="hljs-attr"><span class="hljs-attr">def</span></span>: def }; }</code> </pre> <br><p>  Selain itu, Anda perlu menambahkan tanda centang untuk jenis ekspresi baru di fungsi <code>parse_atom</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      parse_if if (is_kw("let")) return parse_let();</span></span></code> </pre> <br><h4 id="izmeneniya-v-interpretatore">  Perubahan Interpreter </h4><br><p>  Karena kami memutuskan untuk mengubah struktur AST alih-alih “memecahnya” menjadi tipe node yang lama, kami harus menambahkan pemrosesan logika baru ke interpreter. </p><br><p>  Untuk menambahkan dukungan untuk nama fungsi opsional, kami memodifikasi fungsi <code>make_lambda</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">env, exp</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exp.name) { <span class="hljs-comment"><span class="hljs-comment">//  env = env.extend(); //  env.def(exp.name, lambda); //  } //  function lambda() { var names = exp.vars; var scope = env.extend(); for (var i = 0; i &lt; names.length; ++i) scope.def(names[i], i &lt; arguments.length ? arguments[i] : false); return evaluate(exp.body, scope); } return lambda; }</span></span></code> </pre> <br><p>  Jika fungsi memiliki nama, maka saat kami membuat penutupan, kami membuat salinan konteks, dan menambahkan fungsi ke konteks.  Sisanya tetap sama. </p><br><p>  Dan akhirnya, untuk memproses sebuah simpul bertipe <code>let</code> , kita menambahkan case berikut ke interpreter: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"let"</span></span>: exp.vars.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = env.extend(); scope.def(v.name, v.def ? evaluate(v.def, env) : <span class="hljs-literal"><span class="hljs-literal">false</span></span>); env = scope; }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluate(exp.body, env);</code> </pre> <br><p>  Perhatikan bahwa untuk setiap variabel konteks baru dibuat di mana variabel baru ditambahkan.  Setelah itu, kita cukup mengeksekusi tubuh dalam konteks terakhir. </p><br><h4 id="primery">  Contohnya </h4><br><pre> <code class="python hljs">println(let loop (n = <span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> then n + loop(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>); let (x = <span class="hljs-number"><span class="hljs-number">2</span></span>, y = x + <span class="hljs-number"><span class="hljs-number">1</span></span>, z = x + y) println(x + y + z); <span class="hljs-comment"><span class="hljs-comment">#   ..     let # print(x + y + z); let (x = 10) { let (x = x * 2, y = x * x) { println(x); ## 20 println(y); ## 400 }; println(x); ## 10 };</span></span></code> </pre> <br><h4 id="proizvoditelnost-interpretatora">   </h4><br><p>   —  . </p><br><p>   .        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> , ,           ,     .        JavaScript    λ. </p><br><p>    : </p><br><pre> <code class="javascript hljs">globalEnv.def(<span class="hljs-string"><span class="hljs-string">"fibJS"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fibJS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fibJS(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) + fibJS(n - <span class="hljs-number"><span class="hljs-number">2</span></span>); }); globalEnv.def(<span class="hljs-string"><span class="hljs-string">"time"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t1 = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ret = fn(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t2 = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); println(<span class="hljs-string"><span class="hljs-string">"Time: "</span></span> + (t2 - t1) + <span class="hljs-string"><span class="hljs-string">"ms"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; });</code> </pre> <br><p>  <code>time</code>  ,       ,  ,    . </p><br><pre> <code class="python hljs">fib = λ(n) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> then n <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> fib(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) + fib(n - <span class="hljs-number"><span class="hljs-number">2</span></span>); print(<span class="hljs-string"><span class="hljs-string">"fib(10): "</span></span>); time( λ() println(fib(<span class="hljs-number"><span class="hljs-number">10</span></span>)) ); print(<span class="hljs-string"><span class="hljs-string">"fibJS(10): "</span></span>); time( λ() println(fibJS(<span class="hljs-number"><span class="hljs-number">10</span></span>)) ); println(<span class="hljs-string"><span class="hljs-string">"---"</span></span>);</code> </pre> <br><p>   ,   Google Chrome,   n (27),  λ  ,  ,   JS   4 . , ,  . </p><br><p>       λ  JavaScript.    ,      <code>for</code> / <code>while</code> ;          JS.        ?  JS   ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a>  . </p><br><p> ,         ,          <em> </em> JavaScript,    ,    JavaScript. </p><br><p>    ,  ,  .   ,     . </p><br><h4 id="zaklyuchenie">  Kesimpulan </h4><br><p>       ,       .  ,       - ;  ,       ,            ?   — JavaScript. ,         JavaScript —     ? ,       ,    JavaScript,        , ,    .  JavaScript    ( ,       ). </p><br><p>  ,    ,  Lisp —   :            //.    ,  ,        ..  Lisp  .    Lisp        <code>let</code> ,        ,                Lisp. </p><br><p>  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">     JavaScript.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3: juru bahasa CPS</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443812/">https://habr.com/ru/post/id443812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443794/index.html">Arahan utama untuk startup IT di bidang penjualan real estat</a></li>
<li><a href="../id443798/index.html">Zotero hacks: penyimpanan yang disinkronkan tanpa batas dan penggunaannya yang mulus dengan rmarkdown</a></li>
<li><a href="../id443804/index.html">C # adalah bahasa tingkat rendah?</a></li>
<li><a href="../id443808/index.html">Analisis gadis dengan tanggung jawab sosial yang rendah (Dibebankan dengan Power BI, Qlik Sense, Tableau)</a></li>
<li><a href="../id443810/index.html">Berapa penghasilan para pengembang dari berbagai kualifikasi, 2018</a></li>
<li><a href="../id443814/index.html">Memberi adalah "bekas bisnis" saya</a></li>
<li><a href="../id443816/index.html">Kementerian Komunikasi menekankan pada operator 5G tunggal</a></li>
<li><a href="../id443818/index.html">Intisari Acara IT Digest (Bagian Dua)</a></li>
<li><a href="../id443820/index.html">Bagaimana Bandara Fukuoka menemukan langkah-langkah mana yang efektif untuk mengurangi antrian</a></li>
<li><a href="../id443822/index.html">Orkestra Pertunjukan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>