<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßúüèº üë®‚Äçüëß‚Äçüë¶ üñêüèΩ C√≥mo funciona la criptograf√≠a de curva el√≠ptica en TLS 1.3 üë®‚Äç‚úàÔ∏è üìà üîù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Un par de alertas para el lector: 

 Para simplificar (un poco) el proceso de descripci√≥n y ajustar el volumen del art√≠culo que vamos a escribir, es e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo funciona la criptograf√≠a de curva el√≠ptica en TLS 1.3</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/qrator/blog/474810/"><img src="https://hsto.org/webt/qy/r5/a6/qyr5a6ywaf8vbc2kxtaazdmvgz8.png" alt="imagen"><br><br>  Un par de alertas para el lector: <br><br>  Para simplificar (un poco) el proceso de descripci√≥n y ajustar el volumen del art√≠culo que vamos a escribir, es esencial hacer un comentario significativo y establecer la restricci√≥n principal de inmediato: todo lo que vamos a decir hoy sobre la pr√°ctica El lado de la problem√°tica es viable solo en t√©rminos de TLS 1.3.  Lo que significa que, si bien su certificado ECDSA a√∫n funcionar√≠a en TLS 1.2 si lo desea, proporciona compatibilidad con versiones anteriores, la descripci√≥n del proceso de protocolo de enlace real, los trajes de cifrado y los puntos de referencia cliente-servidor solo cubre TLS 1.3.  Por supuesto, esto no se relaciona con la descripci√≥n matem√°tica de los algoritmos detr√°s de los sistemas de cifrado modernos. <br><br>  Este art√≠culo no fue escrito por un matem√°tico ni un ingeniero, aunque ayudaron a encontrar una manera de evitar las matem√°ticas aterradoras y lo revisaron.  Muchas gracias a los empleados de Qrator Labs. <br><br><h3>  ( <b>E</b> l√≠ptico <b>C</b> urve) <b>D</b> iffie- <b>H</b> ellman ( <b>E</b> phemeral) </h3> <b>The Diffie: el legado de Hellman en el siglo XXI</b> <br><br>  Por supuesto, esto no ha comenzado ni con Diffie ni con Hellman.  Pero para proporcionar una l√≠nea de tiempo correcta, necesitamos se√±alar fechas y eventos principales. <br><br>  Hubo varias personas importantes en el desarrollo de la criptograf√≠a moderna.  En particular, Alan Turing y Claud Shannon hicieron una incre√≠ble cantidad de trabajo sobre el campo de la teor√≠a de la computaci√≥n y la teor√≠a de la informaci√≥n, as√≠ como sobre el criptoan√°lisis general, y tanto Diffie como Hellman, son acreditados oficialmente por tener la idea de la clave p√∫blica. (o la llamada criptograf√≠a asim√©trica) (aunque se sabe que en el Reino Unido se hicieron avances serios en la criptograf√≠a que permanecieron en secreto durante mucho tiempo), convirtiendo a esos dos caballeros en pioneros. <br><br>  ¬øEn que exactamente? <br><a name="habracut"></a><br>  Bueno, esto puede sonar peculiar;  sin embargo, antes del 6 de noviembre de 1976, no hab√≠a conocimiento p√∫blico de los sistemas de cifrado de clave p√∫blica.  Whitfield Diffie y Martin Hellman (y, de hecho, Ralph Merkle): matem√°ticos, ingenieros inform√°ticos y entusiastas, as√≠ como cript√≥logos fueron los primeros. <br><br>  Para aquellos que no lo saben, debido al papel que desempe√±√≥ el criptoan√°lisis durante la Segunda Guerra Mundial y su enorme impacto en mantener la informaci√≥n en secreto, los dos pa√≠ses que cre√≠an que ten√≠an el conocimiento m√°s avanzado en criptograf√≠a, los EE. UU. Y el Reino Unido incluyeron el cifrado en sus listas de municiones y aprovecharon una fuerte prohibici√≥n de exportaci√≥n (debilitando simult√°neamente la implementaci√≥n de cifrado para uso privado, privado y comercial).  Por esta raz√≥n, los investigadores del Reino Unido que trabajan en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://web.archive.org/web/20141030210530/">t√©cnica de intercambio de claves asim√©tricas</a> en la sede de comunicaciones gubernamentales y desarrollan un esquema an√°logo no fueron reconocidos para esta invenci√≥n hasta 1997, cuando las restricciones en los algoritmos de criptograf√≠a y su descripci√≥n se volvieron ineficaces. <br><br>  Volviendo a nuestros inventores duales, ¬øqu√© han revolucionado Diffie y Hellman espec√≠ficamente? <br><br>  Echemos un vistazo a su trabajo original, que ilustra perfectamente el salto gigante que han introducido (incluso te√≥ricamente con su trabajo de investigaci√≥n): <br><img src="https://habrastorage.org/webt/tt/rb/ig/ttrbigv4-qiw2ugkittwgox65se.png" alt="imagen"><br>  Y el siguiente: <br><img src="https://habrastorage.org/webt/3c/n5/6g/3cn56g2moitap1tsu-dpsnspfc4.png" alt="imagen"><br>  Estas dos im√°genes ilustran perfectamente el gran cambio que Whitfield Diffie y Martin Hellman introdujeron despu√©s de siglos de evoluci√≥n de criptograf√≠a y criptoan√°lisis: el establecimiento de una clave secreta compartida como resultado de un c√°lculo criptogr√°fico. <br><br>  Echemos un vistazo a otra buena foto con colores: <br><br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/46/Diffie-Hellman_Key_Exchange.svg/375px-Diffie-Hellman_Key_Exchange.svg.png" alt="imagen"><br><br>  Explica lo que est√° pasando.  Antes de la invenci√≥n del acuerdo de clave de Diffie y Hellman, solo hab√≠a una clave sim√©trica: se usaba para cifrar y descifrar el mensaje.  Si desea darle a alguien esa "clave", debe transferirse a trav√©s de un canal "seguro".  Puede imaginar de inmediato todas las restricciones de un esquema de generaci√≥n anterior de este tipo: necesita un canal seguro ya establecido, no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">puede reutilizar la clave</a> e, idealmente, la longitud de la clave debe ser la misma que la longitud del mensaje. <br><br>  Claude Shannon en su obra clasificada en tiempos de guerra " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Teor√≠a de la comunicaci√≥n de los sistemas de secreto</a> " demostr√≥ que todos los cifrados te√≥ricamente irrompibles deben tener los mismos requisitos que el c√≥digo √∫nico, conocido como el cifrado Vernam, por el autor de este cifrado sim√©trico de flujo polialfab√©tico. <br><br>  Nuevamente, vamos a echar un vistazo al art√≠culo original: <br><img src="https://habrastorage.org/webt/p1/p0/yf/p1p0yfmprijaobfof3kb2lu4bpk.png" alt="imagen"><br><br>  Antes de continuar, pregunt√©monos: ¬øc√≥mo dos, aunque brillantes, sin embargo, los seres humanos obtuvieron una mejora tan significativa en un campo aplicado con tal historia, especialmente en el momento de la guerra? <br>  Bueno, por el: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Teor√≠a de la informaci√≥n</a> , formulada por Claude Shannon; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Teor√≠a de la computaci√≥n</a> influenciada, en particular, por Alonzo Church, John von Neumann y Alan Turing; </li><li>  Y, lo que es m√°s importante, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la teor√≠a de la computabilidad se</a> basa principalmente en el trabajo de Turing, que podr√≠amos decir que todo se desarroll√≥ y madur√≥ en el mismo per√≠odo del siglo XX.  Diffie y Hellman mencionaron a Claude Shannon como el influyente m√°s significativo de su trabajo. </li></ul><br>  La " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">seguridad universal</a> " de Lenstra ilustra la cantidad de energ√≠a necesaria para "romper" el sistema criptogr√°fico sim√©trico con varias longitudes clave.  Result√≥ que romper una clave de curva el√≠ptica de 228 bits de largo requerir√≠a la misma cantidad de energ√≠a que se necesita para hervir toda el agua en la Tierra.  Sin embargo, es v√°lido solo bajo la consideraci√≥n de algoritmos y hardware conocidos, ya que, estrictamente hablando, nadie sabe si existen algoritmos o hardware significativamente m√°s eficientes.  La clave EC de 228 bits es comparable a la clave RSA de 2380 bits, m√°s sobre eso m√°s adelante.  Aunque en esta estimaci√≥n, las claves RSA y EC se utilizan en un esquema de cifrado asim√©trico, tales longitudes de clave son algo equivalentes a una clave de cifrado sim√©trico de 128 bits. <br><br>  Es f√°cil imaginar que algo "dif√≠cil de calcular" requerir√≠a mucha energ√≠a y / o tiempo necesario para el c√°lculo.  Tendemos a pensar que las computadoras pueden "calcular todo", pero resulta que no es cierto.  Primero, existen ejemplos indecidibles, como el problema de detenci√≥n, aunque en el campo de la criptograf√≠a, podemos evitar esta trampa.  En segundo lugar, si consideramos el tiempo necesario para que se ejecute un algoritmo en particular, puede ser arbitrariamente alto.  Eso es lo que explotamos en criptograf√≠a.  Un problema se considera "f√°cil" de calcular si el tiempo requerido para ejecutar el algoritmo respectivo depende del tama√±o de entrada (medido en bits) como un polinomio: <math> </math> $ en l√≠nea $ T (n) = O (n ^ k) $ en l√≠nea $   , para alguna constante positiva <math> </math> $ en l√≠nea $ k $ en l√≠nea $   .  En el campo de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">teor√≠a de la complejidad computacional</a> , tales problemas forman la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">clase de complejidad P.</a> <br><br>  La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">clase de complejidad P</a> es casi central, ya que representa el problema para el cual existe un algoritmo de tiempo polin√≥mico determinista.  Otra clase de complejidad es el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NP</a> (los problemas que son "dif√≠ciles" de calcular), que representan un conjunto de problemas de decisi√≥n, es decir, problemas que requieren una respuesta "s√≠" o "no", que tienen una prueba verificable en tiempo polin√≥mico.  ¬øVes la palabra "prueba" aqu√≠?  Ah√≠ es donde llegamos a las funciones de trampillas, que pertenecen a la clase de complejidad NP. <br><br><img src="https://imgs.xkcd.com/comics/travelling_salesman_problem.png" alt="imagen"><br>  Cr√©ditos: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">xkcd</a> <br><br><h3>  Funciones unidireccionales;  Funciones de trampillas </h3><br>  Por definici√≥n, una funci√≥n unidireccional es una funci√≥n que es f√°cil de calcular en cada entrada pero es dif√≠cil de revertir, es decir, calcular la entrada original dada solo la salida.  "F√°cil" y "dif√≠cil" se refieren a las definiciones de la teor√≠a de la complejidad computacional anteriores.  Curiosamente, la existencia de funciones unidireccionales no est√° probada (matem√°ticamente) porque su existencia probar√≠a que las clases de complejidad P y NP no son iguales, mientras que P igual NP o no es hoy un problema abierto.  Por lo tanto, tenga en cuenta que toda la criptograf√≠a moderna se basa en hip√≥tesis no comprobadas. <br><br>  Ahora, en su art√≠culo original, Diffie y Hellman presentan otra generaci√≥n de las funciones unidireccionales que llamaron "funciones de puerta trampa".  ¬øC√≥mo se diferencian? <br>  Como explican en su documento hist√≥rico: <blockquote>  En un criptosistema de clave p√∫blica, el cifrado y el descifrado se rigen por claves distintas, E y D, de modo que calcular D a partir de E es computacionalmente inviable (por ejemplo, requiere <math> </math> $ en l√≠nea $ 10 ^ {100} $ en l√≠nea $   instrucciones).  La clave de cifrado E se puede revelar [en un directorio] sin comprometer la clave de descifrado D. Esto permite que cualquier usuario del sistema env√≠e un mensaje a cualquier otro usuario cifrado de tal manera que solo el destinatario previsto pueda descifrarlo. .. El problema de la autenticaci√≥n es quiz√°s una barrera a√∫n m√°s grave para la adopci√≥n universal de las telecomunicaciones para las transacciones comerciales que los problemas de distribuci√≥n de claves ... [it] ... est√° en el coraz√≥n de cualquier sistema que implique contratos y facturaci√≥n. </blockquote>  Por convenci√≥n, los caracteres de criptograf√≠a "Alice" y "Bob" (que buscan una comunicaci√≥n segura) se utilizan con frecuencia para explicar el concepto de clave p√∫blica.  Alice y Bob acuerdan enteros grandes <math> </math> $ en l√≠nea $ n $ en l√≠nea $   y <math> </math> $ en l√≠nea $ g $ en l√≠nea $   con <math> </math> $ en l√≠nea $ 1 &lt;g &lt;n $ en l√≠nea $   .  La selecci√≥n impacta la seguridad del sistema.  "El m√≥dulo <math> </math> $ en l√≠nea $ n $ en l√≠nea $   deber√≠a ser primo;  mas importante <math> </math> $ en l√≠nea $ (n-1) / 2 $ en l√≠nea $   tambi√©n debe ser un primo &lt;...&gt; y <math> </math> $ en l√≠nea $ g $ en l√≠nea $   deber√≠a ser un m√≥dulo ra√≠z primitivo <math> </math> $ en l√≠nea $ n $ en l√≠nea $   &lt;...&gt; [y] <math> </math> $ en l√≠nea $ n $ en l√≠nea $   debe tener &lt;...&gt; al menos 512 bits de largo ‚Äù. El protocolo Diffie - Hellman se puede establecer en forma elemental en 5 pasos. <br><br><ol><li>  Alice elige <math> </math> $ en l√≠nea $ x $ en l√≠nea $   (un gran n√∫mero entero aleatorio) y calcula <math> </math> $ en l√≠nea $ X = g ^ x \ bmod n $ en l√≠nea $ </li><li>  Bob elige <math> </math> $ en l√≠nea $ y $ en l√≠nea $   (un gran n√∫mero entero aleatorio) y calcula <math> </math> $ en l√≠nea $ Y = g ^ y \ bmod n $ en l√≠nea $ </li><li>  Alice env√≠a <math> </math> $ en l√≠nea $ X $ en l√≠nea $   a Bob, mientras Bob env√≠a <math> </math> $ en l√≠nea $ Y $ en l√≠nea $   a Alice (guardan <math> </math> $ en l√≠nea $ x $ en l√≠nea $   y <math> </math> $ en l√≠nea $ y $ en l√≠nea $   secreto el uno del otro) </li><li>  Alice calcula <math> </math> $ en l√≠nea $ k = Y ^ x \ bmod n $ en l√≠nea $ </li><li>  Bob calcula <math> </math> $ en l√≠nea $ k '= X ^ y \ bmod n $ en l√≠nea $ </li></ol><br>  Como resultado, Alice y Bob tienen el mismo valor. <math> </math> $ en l√≠nea $ k = k '$ en l√≠nea $   eso sirve como un secreto compartido. <br><br>  La funci√≥n de trampilla es una funci√≥n unidireccional que hace posible encontrar su inverso si uno tiene una informaci√≥n especial llamada "trampilla".  Suena f√°cil, aunque fue bastante dif√≠cil encontrar tales funciones: el primer m√©todo factible se encontr√≥ en la implementaci√≥n de un algoritmo de cifrado asim√©trico de criptograf√≠a de clave p√∫blica llamado RSA en honor a sus creadores: Ron Rivest, Adi Shamir y Leonard Adleman. <br><br><h3>  RSA </h3><br>  En RSA, la dureza de invertir la funci√≥n se basa en el hecho de que la factorizaci√≥n (encontrar multiplicadores primos de un n√∫mero) lleva mucho m√°s tiempo que la multiplicaci√≥n, o deber√≠amos decir aqu√≠ que ning√∫n m√©todo de tiempo polin√≥mico para factorizar n√∫meros enteros grandes en una computadora cl√°sica tiene encontrado, sin embargo, no se ha demostrado que no exista ninguno. <br><br>  En RSA, como en cualquier otro sistema de cifrado de clave p√∫blica, hay dos claves: p√∫blica y privada.  RSA toma el mensaje de entrada (representado como una cadena de bits) y le aplica una operaci√≥n matem√°tica (m√≥dulo de exponenciaci√≥n un n√∫mero entero grande) para obtener un resultado que se ve indistinguible de aleatorio.  El descifrado toma este resultado y aplica una operaci√≥n similar para recuperar el mensaje original.  En la criptograf√≠a asim√©trica, el cifrado se realiza con la clave p√∫blica y el descifrado con la clave privada. <br><br>  Como?  Porque los operandos pertenecen a un grupo c√≠clico finito (un conjunto de enteros con multiplicaci√≥n en aritm√©tica modular).  Las computadoras no se manejan muy bien con n√∫meros arbitrariamente grandes, pero, afortunadamente, nuestro grupo c√≠clico de enteros es realizar una operaci√≥n llamada "ajuste": un n√∫mero mayor que el m√°ximo permitido se ajusta a un n√∫mero en el rango v√°lido que operamos .  Esto nos permite operar con teclas de "no m√°s de" longitud.  En la criptograf√≠a de curva el√≠ptica, tambi√©n se usan grupos c√≠clicos (multiplicativos), pero se construyen de manera un poco diferente, como veremos m√°s adelante. <br><br>  B√°sicamente, lo que hace RSA es tomar dos n√∫meros primos grandes y multiplicarlos para obtener el llamado m√≥dulo.  Todos los otros n√∫meros a tratar residen entre cero y el m√≥dulo.  El m√≥dulo debe ser parte de la clave p√∫blica, y su longitud de bits determina la longitud de la clave.  La segunda parte de la clave p√∫blica es un n√∫mero elegido entre cero y el totient de Euler (la implementaci√≥n moderna de RSA toma el totient de Carmichael en lugar del Euler) del m√≥dulo con algunas restricciones adicionales.  Finalmente, la clave privada debe calcularse resolviendo alguna ecuaci√≥n modular.  Para cifrar un n√∫mero, simplemente lo elevamos a la potencia igual a la clave p√∫blica, y para descifrar un n√∫mero, lo elevamos a la potencia igual a la clave privada.  Gracias a la naturaleza c√≠clica del grupo, recuperamos el n√∫mero inicial. <br><br>  Hay dos problemas importantes con el RSA hoy en d√≠a, uno es consecuencia del otro.  A medida que crece la longitud de una clave (es decir, el n√∫mero de sus bits), el factor de complejidad no crece tan r√°pido como cabr√≠a esperar.  Esto se debe a que existe un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">algoritmo de</a> factorizaci√≥n sub-exponencial (pero a√∫n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">s√∫per polinomial</a> ).  Por lo tanto, para mantener un nivel de seguridad adecuado, la longitud de la clave RSA debe crecer algo m√°s r√°pido que la longitud de la clave ECC.  Es por eso que las claves RSA m√°s extendidas en la actualidad tienen una longitud de 2048 o 3072 bits. <br><br>  Un poco m√°s tarde, veremos en n√∫meros c√≥mo la longitud de la clave afecta la eficiencia general del sistema criptogr√°fico al comparar el certificado RSA y ECDSA firmado con la autoridad Let's Encrypt. <br><br><h3>  (C√©lvica el√≠ptica) <b>D</b> igital <b>S</b> ignature <b>A</b> lgorithm </h3><br>  La b√∫squeda de una mejor funci√≥n de trampilla eventualmente llev√≥ a los cript√≥grafos a una rama de las matem√°ticas de mediados de los 80 dedicada a las curvas el√≠pticas. <br><br>  Ser√≠a la tarea final describir la criptograf√≠a de curva el√≠ptica en un art√≠culo, por lo que no lo haremos.  En cambio, echemos un vistazo a una funci√≥n de trampilla de curva el√≠ptica basada en el problema de logaritmo discreto. <br><br>  Hay muchos iniciadores y m√°s introducciones en profundidad en la criptograf√≠a de curva el√≠ptica, y recomendamos especialmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"ECC: una introducci√≥n suave" de Andrea Corbellini</a> si est√° interesado en las matem√°ticas. <br><br>  Lo que nos interesa son par√°metros bastante "simples". <br><br>  La curva el√≠ptica se define mediante una ecuaci√≥n como esta: <math> </math> $ en l√≠nea $ y ^ 2 = x ^ 3 + ax + b $ en l√≠nea $ <br>  Dicha curva es necesaria para construir un subgrupo c√≠clico sobre un campo finito.  Por lo tanto, se est√°n utilizando los siguientes par√°metros: <br><br><ul><li>  La <b>prima</b> <math> </math> <b>$ en l√≠nea $ p $ en l√≠nea $</b>   que especifica el tama√±o del campo finito; </li><li>  Los <b>coeficientes</b> <math> </math> <b>$ en l√≠nea $ a $ en l√≠nea $</b>   <b>y</b> <math> </math> <b>$ en l√≠nea $ b $ en l√≠nea $</b>   de la ecuaci√≥n de curva el√≠ptica; </li><li>  El <b>punto base</b> <math> </math> <b>$ en l√≠nea $ g $ en l√≠nea $</b>   eso genera el subgrupo mencionado; </li><li>  El <b>orden</b> <math> </math> <b>$ en l√≠nea $ n $ en l√≠nea $</b>   del subgrupo; </li><li>  El <b>cofactor</b> <math> </math> <b>$ en l√≠nea $ h $ en l√≠nea $</b>   del subgrupo. </li></ul><br>  En conclusi√≥n, los <b>par√°metros de dominio</b> para nuestros algoritmos son el <b>sextuplet</b> <math> </math> $ en l√≠nea $ (p, a, b, G, n, h) $ en l√≠nea $   . <br>  Dichas curvas el√≠pticas funcionan sobre el campo finito. <math> </math> $ en l√≠nea $ \ mathbb {F} _p $ en l√≠nea $   donde <math> </math> $ en l√≠nea $ p $ en l√≠nea $   es un n√∫mero primo bastante grande.  Entonces tenemos un conjunto de m√≥dulos enteros <math> </math> $ en l√≠nea $ p $ en l√≠nea $   , donde las operaciones, como la suma, resta, multiplicaci√≥n, inversa aditiva, inversa multiplicativa son posibles.  La suma y la multiplicaci√≥n funcionan de manera similar a la aritm√©tica modular o llamada "reloj" que vimos en las "envolturas" de RSA. <br>  Dado que la curva es sim√©trica respecto al eje x, dado cualquier punto <math> </math> $ en l√≠nea $ P $ en l√≠nea $   podemos tomar <math> </math> $ en l√≠nea $ ‚àíP $ en l√≠nea $   ser el punto opuesto  Tomamos <math> </math> $ en l√≠nea $ ‚àíO $ en l√≠nea $   para ser justo <math> </math> $ en l√≠nea $ O $ en l√≠nea $   . <br>  La suma de puntos de curva se define de una manera que los puntos dados <math> </math> $ en l√≠nea $ P $ en l√≠nea $   y <math> </math> $ en l√≠nea $ Q $ en l√≠nea $   , podemos dibujar l√≠neas que intersectan esos puntos y la curva de intersecci√≥n en un tercer punto <math> </math> $ en l√≠nea $ R $ en l√≠nea $   para que <math> </math> $ en l√≠nea $ P + Q = -R $ en l√≠nea $   y <math> </math> $ en l√≠nea $ P + Q + R = 0 $ en l√≠nea $   . <br><br>  Echemos un vistazo a la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">explicaci√≥n de Marc Hughes</a> : <br><blockquote><img src="https://www.allaboutcircuits.com/uploads/articles/Curve_Cryptography_fig09.jpg" alt="imagen"><br><br>  Arriba se muestra una l√≠nea de pendiente constante que viaja a lo largo de la superficie del toro.  Esta l√≠nea pasa a trav√©s de dos puntos enteros seleccionados al azar en la curva. <br><br><img src="https://www.allaboutcircuits.com/uploads/articles/Curve_Cryptography_fig10.gif" alt="imagen"><br><br>  Para agregar dos puntos en el gr√°fico, dibuje una l√≠nea desde el primer punto seleccionado <math> </math> $ en l√≠nea $ P $ en l√≠nea $   hasta el segundo punto seleccionado <math> </math> $ en l√≠nea $ Q $ en l√≠nea $   y extienda la l√≠nea hasta que se cruce con otro punto en el gr√°fico <math> </math> $ en l√≠nea $ -R $ en l√≠nea $   , extendi√©ndolo a trav√©s de los l√≠mites de la trama si es necesario. <br><br>  Una vez que intercepte un punto entero, refleje el punto verticalmente a trav√©s del centro del gr√°fico (una l√≠nea de puntos anaranjada) para encontrar el nuevo punto <math> </math> $ en l√≠nea $ R $ en l√≠nea $   en el gr√°fico  Por lo tanto <math> </math> $ en l√≠nea $ P + Q = R $ en l√≠nea $   . </blockquote>  La multiplicaci√≥n por un escalar ahora es trivial: <math> </math> $ en l√≠nea $ n \ cdot P = P + P + P + \ dots + P $ en l√≠nea $   (aqu√≠ est√°n <math> </math> $ en l√≠nea $ n $ en l√≠nea $   sumandos). <br><br>  La funci√≥n de trampilla aqu√≠ se encuentra dentro del problema del logaritmo discreto (para curvas el√≠pticas), no de la factorizaci√≥n que analizamos en la secci√≥n RSA.  El problema es: si sabemos <math> </math> $ en l√≠nea $ P $ en l√≠nea $   y <math> </math> $ en l√≠nea $ Q $ en l√≠nea $   que es tal <math> </math> $ en l√≠nea $ k $ en l√≠nea $   que <math> </math> $ en l√≠nea $ Q = k \ cdot P $ en l√≠nea $   ? <br><br>  Se supone que tanto el problema de factorizaci√≥n (subyacente al RSA) como el logaritmo discreto para curvas el√≠pticas (que es la base de ECDSA y ECDH) son dif√≠ciles, es decir, no hay algoritmos conocidos para resolver este problema en tiempo polin√≥mico para una clave dada longitud <br><br>  Si bien, normalmente, cualquier persona se avergonzar√≠a de mezclar el intercambio de claves (ECDH) con el algoritmo de firma (ECDSA), debemos explicar c√≥mo funcionan juntos.  Un certificado TLS moderno contiene una clave p√∫blica, en nuestro caso, del par de claves generado por el algoritmo de curva el√≠ptica, generalmente firmado por una autoridad de nivel superior.  El cliente verifica la firma del servidor y obtiene el secreto compartido.  El secreto compartido se utiliza en un algoritmo de cifrado sim√©trico, como AES o ChaCha20.  Sin embargo, el principio sigue siendo el mismo: acuerde los par√°metros del dominio (el sextuplet), obtenga el par de claves, donde la clave privada es un entero seleccionado al azar (el multiplicando de <math> </math> $ en l√≠nea $ Q = k \ cdot P $ en l√≠nea $   ), y la clave p√∫blica es un punto en la curva.  Los algoritmos de firma usan el punto base <math> </math> $ en l√≠nea $ g $ en l√≠nea $   , que es un generador para un subgrupo de orden primo grande <math> </math> $ en l√≠nea $ n $ en l√≠nea $   tal que <math> </math> $ en l√≠nea $ n \ cdot G = 0 $ en l√≠nea $   , donde 0 es el elemento de identidad.  La firma prueba que la conexi√≥n segura se est√° estableciendo con la parte aut√©ntica: un servidor que tiene el certificado TLS (clave p√∫blica) firmado por alguna autoridad de certificaci√≥n para el nombre del servidor dado. <br><br><h3>  (EC) DH (E) + ECDSA = Forma actual de apret√≥n de manos </h3><br>  En el TLS moderno (1.3), el cliente y el servidor generan su par de claves p√∫blica-privada sobre la marcha, mientras establecen la conexi√≥n, esto se denomina versi√≥n ef√≠mera del intercambio de claves.  Las bibliotecas TLS de navegador m√°s populares lo admiten.  En su mayor√≠a, utilizan la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">curva el√≠ptica Edwards 25519</a> , introducida por Daniel J. Bernstein (djb), que ofrece seguridad de 128 bits.  Desde 2014 openssh usa esta curva para la creaci√≥n del par de claves.  Sin embargo, en 2019, los navegadores a√∫n no admiten sesiones TLS con servidores que tengan un certificado con clave p√∫blica EdDSA. <br><br>  Pero volvamos a c√≥mo funcionan las cosas a fines de 2019 con TLS 1.3. <br><br>  Los mecanismos de intercambio de claves en TLS 1.3 est√°n restringidos a (EC) basados ‚Äã‚Äãen DH (E) (con el x25519 es compatible con las bibliotecas TLS del lado del cliente de los navegadores m√°s populares, as√≠ como las bibliotecas TLS del lado del servidor, como OpenSSL, que inspeccionaremos un poco m√°s tarde), y la lista del conjunto de cifrado contiene solo tres entradas: TLS_AES_128_GCM_SHA256, TLS_AES_256_GCM_SHA384 y TLS_CHACHA20_POLY1305_SHA256.  Para aquellos de ustedes que saben c√≥mo se nombraron los conjuntos de cifrado en la versi√≥n TLS 1.2, es evidente de inmediato que el mecanismo de intercambio de claves ahora est√° "separado" del nombre del conjunto de cifrado, tambi√©n se eliminaron los modos de intercambio est√°tico RSA y Diffie est√°tico - Hellman de la especificaci√≥n por completo.  Incluso la reanudaci√≥n de la sesi√≥n basada en PSK se realiza a trav√©s de ECDHE en TLS 1.3.  Tambi√©n es cierto para los par√°metros personalizados de DH, que ahora no est√°n permitidos, dejando solo aquellos generalmente aceptados como seguros en la especificaci√≥n del protocolo final. <br><br>  Es interesante que haya una diferencia bastante significativa en c√≥mo funcionan los algoritmos de cifrado asim√©trico en la actualidad.  Con ECC (y los certificados ECDSA en particular) utilizamos claves m√°s peque√±as para llegar a niveles de seguridad "convenientes", en comparaci√≥n con RSA.  Eso permite el uso de un algoritmo de cifrado asim√©trico m√°s fuerte y mecanismos de intercambio de claves en dispositivos m√°s peque√±os y, a veces, incluso en cosas que generalmente no se consideran un dispositivo (tarjeta inteligente). <br><br>  En primer lugar, es necesario mencionar lo que significa "criptosistema h√≠brido" en t√©rminos de TLS 1.3. <br>  Un criptosistema h√≠brido es el que utiliza el cifrado asim√©trico (clave p√∫blica) para establecer un secreto compartido, que luego se utiliza como clave en una secuencia sim√©trica o cifrado de bloque. <br><br>  En segundo lugar, infraestructura de clave p√∫blica y certificados.  Es interesante que en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">su entrevista de 2004</a> Martin Hellman mencion√≥ a un "h√©roe no reconocido" Loren Kohnfelder, cuya tesis de licenciatura del MIT introdujo una estructura de √°rbol de lo que ahora conocemos como infraestructura de clave p√∫blica.  Sin embargo, volvamos a los certificados. <br><br>  El hecho de que el servidor realmente tenga la clave privada est√° garantizado por su firma, que se puede verificar con la clave p√∫blica del servidor.  Y el certificado asegura que alguna clave p√∫blica pertenece a un servidor espec√≠fico.  Significa que est√° estableciendo una comunicaci√≥n segura con la parte espec√≠fica y no con un impostor.  Tu banco, no un cibercriminal.  En TLS 1.3 hay una mejora significativa sobre el formato de negociaci√≥n anterior: el servidor firma toda la informaci√≥n que tiene hasta este momento: el saludo del cliente y el saludo del servidor, incluido el cifrado negociado.  Echemos un vistazo a la secci√≥n correspondiente del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RFC 8446</a> : <br><br><pre><code class="plaintext hljs">Client Server Key ^ ClientHello Exch | + key_share* | + signature_algorithms* | + psk_key_exchange_modes* v + pre_shared_key* --------&gt; ServerHello ^ Key + key_share* | Exch + pre_shared_key* v {EncryptedExtensions} ^ Server {CertificateRequest*} v Params {Certificate*} ^ {CertificateVerify*} | Auth {Finished} v &lt;-------- [Application Data*] ^ {Certificate*} Auth | {CertificateVerify*} v {Finished} --------&gt; [Application Data] &lt;-------&gt; [Application Data]</code> </pre> <br>  En TLS 1.3, el cliente env√≠a la clave compartida (junto con los par√°metros necesarios), algoritmos de firma de inmediato en el primer mensaje (Client Hello).  Las claves necesarias para intercambiar con el servidor se crean en segundo plano, sin que el usuario lo note.  Se intercambian a√∫n m√°s con el servidor para crear un secreto com√∫n, a partir de claves secretas pre-master que se establecieron cuando el servidor envi√≥ su mensaje (Server Hello) respondiendo al cliente. <br>  En el lado "Server Hello" puede ver que el Certificado * se transfiere al cliente, junto con la parte Certificado Verificaci√≥n * que verifica que la parte posee la clave privada para la entrada de clave p√∫blica correspondiente, y crea la clave de sesi√≥n (sim√©trica) si todo sale seg√∫n lo planeado, lo que significa que el lado que solicita los datos (cliente) verific√≥ con √©xito el lado que responde (servidor), creando a√∫n m√°s un secreto com√∫n. <br><br>  Hay dos operaciones esenciales ocultas en estas transmisiones: creaci√≥n de firma y verificaci√≥n de firma.  Estos se realizan en ambos lados de la comunicaci√≥n, ya que la "firma" es esencialmente una prueba de que la parte realmente tiene la clave privada correspondiente a la clave p√∫blica, que los datos provienen del firmante y el mensaje no fue alterado en tr√°nsito. <br><br>  Con RSA, como veremos m√°s adelante, la operaci√≥n de firma es la m√°s costosa.  Como estamos firmando con una clave larga de 2048 o 3072 bits, dicha operaci√≥n carga el servidor significativamente, mucho m√°s de lo que carga al cliente verificando dicha firma. <br><br>  Con ECDSA, tenemos claves m√°s peque√±as (vamos a ver el ECDSA con NIST P-256 (o el secp256v1)) pero operaciones m√°s complejas.  Como resultado, podr√≠a verse como el RSA "al rev√©s": el c√°lculo de verificaci√≥n de firma carga m√°s al cliente, mientras que el servidor maneja f√°cilmente la creaci√≥n de la firma.  Las mediciones verifican eso, vea la secci√≥n "Un poco de referencia". <br><br>  Este efecto escala f√°cilmente Internet hoy en d√≠a, ya que los clientes modernos son casi igual de poderosos que los servidores (teniendo en cuenta solo la frecuencia central de la CPU), por lo que podr√≠an llevar a la pr√°ctica la costosa operaci√≥n.  El servidor, a su vez, puede usar las capacidades liberadas para crear m√°s firmas y establecer m√°s sesiones. <br><br><h3>  Encriptemos la firma del certificado </h3><br>  Entonces, para proporcionar al lector un poco de instrucciones pr√°cticas y pr√°cticas sobre c√≥mo crear un servidor habilitado para TLS con el par de claves ECDSA firmado por la autoridad Let's Encrypt, decidimos ilustrar un proceso completo de creaci√≥n de un par de claves necesario para crear una CSR (solicitud de firma de certificado) para Let's Encrypt y, como resultado, obtener el certificado ECDSA necesario para nuestro servidor. <br><br>  Tenemos que generar una clave privada para continuar.  Utilizaremos la biblioteca OpenSSL. <br>  El manual de OpenSSL describe la generaci√≥n de cualquier tecla EC a trav√©s de un comando especial, designado especialmente para la rama de la curva el√≠ptica del algoritmo de generaci√≥n. <br><br><pre> <code class="plaintext hljs">openssl ecparam -genkey -name -secp256v1 -out privatekey.pem</code> </pre> <br>  Para verificar que la biblioteca OpenSSL hizo todo bien, podemos ejecutar el comando <code>ec</code> . <br><br><pre> <code class="plaintext hljs">openssl ec -in privatekey.pem -noout -text</code> </pre> <br>  La salida nos mostrar√° la curva especificada con la que se ha creado la clave. <br><br>  El siguiente paso es bastante esencial para la creaci√≥n de la CSR: para omitir el proceso de completar todos los detalles de informaci√≥n necesarios para obtener el certificado, necesitamos el archivo de configuraci√≥n.  Afortunadamente, Mozilla hizo todo el trabajo por nosotros, presentando el " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Generador de configuraci√≥n SSL</a> ".  All√≠, puede elegir entre las opciones de servidor disponibles.  La configuraci√≥n pura de OpenSSL, peculiarmente no presente en la p√°gina del generador, se ver√≠a as√≠: <br><br><pre> <code class="plaintext hljs">[ req ] prompt = no encrypt_key = no default_md = sha256 distinguished_name = dname req_extensions = reqext [ dname ] CN = example.com emailAddress = admin@example.com [ reqext ] subjectAltName = DNS:example.com, DNS:*.example.com</code> </pre> <br>  <i>Nota: no es necesario tener el CNF; si no lo hace, se le solicitar√° que complete estos detalles en la l√≠nea de comando.</i> <br><br>  Ahora, siga la creaci√≥n de una CSR en s√≠.  Aqu√≠ tenemos un √∫til comando OpenSSL. <br><br><pre> <code class="plaintext hljs">openssl req -new -config -pathtoconfigfile.cnf -key privatekey.pem -out csr.pem</code> </pre> <br>  Tambi√©n podemos verificar la correcci√≥n de una CSR reci√©n creada. <br><br><pre> <code class="plaintext hljs">openssl req -in csr.pem -noout -text -verify</code> </pre> <br>  Aqu√≠ hemos llegado a una fase final: usar un cliente ACME, certbot, para pasar nuestra solicitud de firma de certificado a Let's Encrypt. <br><br>  Certbot lo ayuda a obtener el certificado necesario y tiene muchas opciones.  Aqu√≠ dijo, si eres nuevo en el cifrado de clave p√∫blica y la infraestructura PKI que tenemos en 2019, es mejor que uses <code>--dry-run</code> antes de intentar obtener el certificado para cualquier dominio tuyo. <br><br><pre> <code class="plaintext hljs">certbot certonly --dry-run --dns-somednsprovider --domain ‚Äúexample.com‚Äù --domain ‚Äú*.example.com‚Äù --csr csr.pem</code> </pre> <br>  En este caso, el cliente certbot verifica que la lista de dominios solicitados (en la l√≠nea de comando) coincida con los dominios enumerados en la solicitud de firma de certificado.  En el <code>--dns-somednsprovider</code> miente un poco, porque hay muchas maneras en que puedes probar Let's Encrypt que est√°s en posesi√≥n de una parte particular del tr√°fico de Internet.  Sin embargo, si est√° utilizando alg√∫n proveedor de alojamiento en la nube p√∫blica, digamos DigitalOcean, Hetzner, Amazon, Azure, cualquier cosa, probablemente habr√≠a una forma m√°s natural de proporcionar la informaci√≥n necesaria, porque su proveedor ya cre√≥ alguna herramienta de integraci√≥n. <br><br>  Despu√©s, si est√° seguro de la exactitud de los par√°metros que est√° utilizando para pasar su CSR a Let's Encrypt a trav√©s de un cliente certbot, excluya el par√°metro <code>--dry-run</code> de su comando y contin√∫e. <br><br>  Si tiene √©xito, el cliente producir√≠a varios certificados como salida: el certificado firmado en s√≠, los certificados ra√≠z e intermedios, y la combinaci√≥n de estos √∫ltimos como la cadena de certificados nombrada por √∫ltima vez, todo en el formato de archivo .pem. <br><br>  OpenSSL tiene un comando que podr√≠amos usar para inspeccionar los certificados: <br><br><pre> <code class="plaintext hljs">openssl x509 -in chainfilepath.pem -noout -text</code> </pre> <br>  En este punto, se hace evidente que Let's Encrypt firm√≥ el certificado utilizando el resumen SHA256.  Adem√°s, la firma de ECDSA Root and Intermediates se incluye en la secci√≥n "Pr√≥ximas funciones", lo que significa que en este momento solo obtendr√≠a intermedios de RSA.  Pero est√° bien, ya que todav√≠a est√° utilizando la clave p√∫blica ECDSA. <br><br>  Al final de esta secci√≥n, nos gustar√≠a decir algo en relaci√≥n con la longitud de las teclas.  En seguridad de la informaci√≥n, es com√∫n decir que el nivel de seguridad es 2 ^ x, donde x es la longitud de bits (RSA es una peque√±a excepci√≥n aqu√≠, ya que crece un poco m√°s lento que exponencialmente).  Para aproximar c√≥mo las teclas utilizadas para diferentes algoritmos se corresponden entre s√≠, nos referiremos a la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">p√°gina wiki de</a> OpenSSL. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Longitud de la llave sim√©trica</b> <br></td><td>  <b>Longitud de clave RSA</b> <br></td><td>  <b>Longitud de clave de curva el√≠ptica</b> <br></td></tr><tr><td>  80 <br></td><td>  1024 <br></td><td>  160 <br></td></tr><tr><td>  112 <br></td><td>  2048 <br></td><td>  224 <br></td></tr><tr><td>  128 <br></td><td>  3072 <br></td><td>  256 <br></td></tr><tr><td>  192 <br></td><td>  7680 <br></td><td>  384 <br></td></tr><tr><td>  256 <br></td><td>  15360 <br></td><td>  512 <br></td></tr></tbody></table></div>  Como puede ver, las diferencias son bastante prominentes.  Aunque con Let's Encrypt no pudimos obtener ning√∫n certificado firmado fuera de las claves de curva el√≠ptica 256 (secp256v1) y 384 (secp384r1). <br><br><h3>  Problemas conocidos y excepciones, y LA NSA </h3><br><img src="https://imgs.xkcd.com/comics/random_number.png" alt="imagen"><br>  Cr√©ditos: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">xkcd</a> <br><br>  Probablemente, el tema central del uso de la criptograf√≠a de curva el√≠ptica a trav√©s de los a√±os fue la necesidad de un generador de n√∫meros aleatorios cuidadosamente dise√±ado, para crear claves del nivel de seguridad requerido. <br><br>  Hubo un esc√°ndalo masivo alrededor del algoritmo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dual_EC_DRBG</a> (generador de bits aleatorio determinista de curva el√≠ptica dual), que tard√≥ muchos a√±os en resolverse.  Adem√°s, existe incertidumbre acerca de las patentes ECC, ya que se sabe que muchas de ellas pertenec√≠an a la empresa Certicom, que fue adquirida por Blackberry.  Tambi√©n hay compa√±√≠as que est√°n certificadas para el uso de ECC de Blackberry.  Por supuesto, existe una desconfianza simple en algunas normas del NIST, que podr√≠a verse afectada o no por la NSA o cualquier otra instituci√≥n de vigilancia y cumplimiento de los Estados Unidos. <br><br>  El lado de la implementaci√≥n de un problema es una pregunta completamente diferente.  En 2010, la consola PlayStation 3 sufri√≥ una recuperaci√≥n de clave privada de Sony debido a la implementaci√≥n inadecuada del algoritmo ECDSA: ten√≠an un est√°tico aleatorio que hac√≠a que la funci√≥n de trampilla tuviera soluci√≥n.  OpenSSL tambi√©n sufri√≥ en el a√±o siguiente, sin embargo, corrigi√≥ r√°pidamente la vulnerabilidad que permit√≠a la recuperaci√≥n de una clave privada con la ayuda de un ataque de tiempo, para obtener m√°s informaci√≥n, consulte el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documento original</a> . <br><br>  En 2013, en la conferencia RSA, un grupo de investigadores present√≥ su " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬°Fall√≥ al azar!</a>  Documento sobre las vulnerabilidades de la clase Java SecureRandom.  Medio a√±o despu√©s, se redujo a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">las</a> billeteras de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Android</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bitcoin</a> , creadas usando PRNG criptogr√°ficamente seguro insuficiente. <br><br>  Debido a serias vulnerabilidades en serie descubiertas, en el mismo agosto de 2013, IETF lanz√≥ un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RFC 6979</a> , que describe una generaci√≥n determinista de k utilizada en la creaci√≥n de claves.  Podr√≠amos decir que tal medida solucion√≥ el problema, pero no lo haremos, en cualquier momento los investigadores podr√≠an encontrar problemas en numerosas implementaciones debido a una desviaci√≥n innecesaria de las especificaciones del protocolo. <br><br>  Sobre la NSA.  Si no ha escuchado sobre la historia de Dual_EC_DRBG: reserve algo de tiempo y lea los art√≠culos correspondientes, no se arrepentir√° de entrar en detalles.  Edward Snowden es parte de esta historia porque las revelaciones de 2013 probaron las sospechas anteriores.  Como resultado, muchos cript√≥grafos prominentes perdieron la confianza en el NIST, ya que esa organizaci√≥n dise√±√≥ y describi√≥ muchas de las curvas y otros algoritmos, subyacentes a ECDSA. <br><br>  La curva 25519 de Daniel Bernstein y la funci√≥n DH es la respuesta a estos dos problemas y, como describimos anteriormente, una transici√≥n hacia EdDSA es lenta pero evidente.  Incluso con las curvas NIST, todav√≠a no se ha encontrado evidencia de su vulnerabilidad y, como ya hemos mencionado, la experiencia relacionada con el azar ha sido bastante instructiva. <br><br>  Para concluir esta parte, queremos dar la cita de John von Neumann: "Cualquiera que intente generar n√∫meros aleatorios por medios deterministas est√°, por supuesto, viviendo en un estado de pecado". <br><br><h3>  Un poco de referencia </h3><br>  Utilizamos un servidor NGINX 1.16.0 con OpenSSL 1.1.1d para ejecutar estos puntos de referencia con varios certificados.  Como mencionamos anteriormente, actualmente Let's Encrypt solo permite los algoritmos prime256v1 y secp384r1 para las solicitudes de firma de certificados, y no proporciona certificados ECDSA ra√≠z e intermedios, probablemente trabajando en esta caracter√≠stica al momento de escribir este art√≠culo. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Tipo de firma</b> </td><td>  <b>Apretones de manos por segundo</b> </td></tr><tr><td>  <b>ECDSA (prime256v1 / nistp256)</b> </td><td>  3358,6 </td></tr><tr><td>  <b>RSA 2048</b> </td><td>  972,5 </td></tr></tbody></table></div>  Como puede ver, para un solo n√∫cleo de la CPU Intel¬Æ Xeon¬Æ Silver 4114 @ 2.20GHz (lanzado Q3'17), la diferencia general en el rendimiento de ECDSA, en comparaci√≥n con el ampliamente adoptado RSA 2048 es 3.5x. <br><br>  Ahora echemos un vistazo a los resultados de velocidad de OpenSSL del mismo procesador con ECDSA y RSA. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Tipo de firma</b> <br></td><td>  <b>se√±al</b> <br></td><td>  <b>verificar</b> <br></td><td>  <b>signo / seg</b> <br></td><td>  <b>verificar / seg</b> <br></td></tr><tr><td>  <b>RSA 2048 bit</b> <br></td><td>  717 Œºs <br></td><td>  20,2 Œºs <br></td><td>  1393,9 <br></td><td>  49458,2 <br></td></tr><tr><td>  <b>256 bits ECDSA (nistp256)</b> <br></td><td>  25,7 Œºs <br></td><td>  81,8 Œºs <br></td><td>  38971,6 <br></td><td>  12227,1 <br></td></tr></tbody></table></div>  Aqu√≠ podemos ver una confirmaci√≥n de la tesis dada anteriormente de los diferentes costos computacionales para el signo y verificar las operaciones de ECC y RSA.  Como resultado, actualmente equipado con TLS 1.3 ECC proporciona un aumento significativo del rendimiento en el nivel de seguridad de bit m√°s alto, en comparaci√≥n con RSA.  Esa es la raz√≥n m√°s importante por la que en Qrator Labs alentamos a nuestros clientes a adoptar ECDSA.  Con las CPU modernas, obtienes casi la diferencia de 5 veces a favor de ECDSA. <br><br>  Si est√° interesado en c√≥mo su CPU realiza c√°lculos criptogr√°ficos, puede ejecutar un simple comando de <code>openssl speed</code> .  Los <code>-rsa</code> , <code>-ecdsa</code> y <code>-eddsa</code> le dar√≠an resultados de referencia para los algoritmos de firma correspondientes. <br><br><h3>  (Superpuesto) Futuro </h3><br><img src="https://pbs.twimg.com/media/CB4sHACVEAAYMyZ?format=jpg&amp;name=large" alt="imagen"><br>  Cr√©ditos: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">djb</a> <br><br>  Es ir√≥nico que mientras est√°bamos preparando este art√≠culo, Google anunci√≥ " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">alcanzar la supremac√≠a cu√°ntica</a> ".  ¬øSignifica esto que estamos en peligro en este momento y que todo lo desarrollado hasta este momento no proporciona ning√∫n secreto? <br><br>  Pues no. <br><br>  Como Bruce Schneier escribi√≥ en su ensayo para IEEE Security and Privacy " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Criptograf√≠a despu√©s de las tierras de los extraterrestres</a> ", se podr√≠a hacer un gran golpe con una computadora cu√°ntica lo suficientemente potente como para la criptograf√≠a de clave p√∫blica (asim√©trica).  La criptograf√≠a sim√©trica seguir√≠a siendo fuerte. <br><br>  Queremos citar a Bruce Schneier con lo siguiente: <br><blockquote>  Hay un escenario futuro m√°s a considerar, uno que no requiere una computadora cu√°ntica.  Si bien hay varias teor√≠as matem√°ticas que sustentan la unidireccionalidad que utilizamos en la criptograf√≠a, probar la validez de esas teor√≠as es, de hecho, uno de los grandes problemas abiertos en la inform√°tica.  As√≠ como es posible que un cript√≥grafo inteligente encuentre un nuevo truco que facilite romper un algoritmo en particular, podr√≠amos imaginar extraterrestres con suficiente teor√≠a matem√°tica para romper todos los algoritmos de encriptaci√≥n.  Para nosotros, hoy, esto es rid√≠culo.  La criptograf√≠a de clave p√∫blica es una teor√≠a de n√∫meros y es potencialmente vulnerable a los extraterrestres con mayor inclinaci√≥n matem√°tica.  La criptograf√≠a sim√©trica es tanto un embrollo no lineal, tan f√°cil de hacer m√°s complejo y tan f√°cil de aumentar la longitud de la clave, que este futuro es inimaginable.  Considere una variante AES con un bloque de 512 bits y un tama√±o de clave, y 128 rondas.  A menos que las matem√°ticas sean fundamentalmente diferentes de nuestra comprensi√≥n actual, eso ser√° seguro hasta que las computadoras est√©n hechas de algo diferente a la materia y ocupen algo que no sea el espacio. <br><br>  Pero si sucede lo inimaginable, eso nos dejar√≠a con una criptograf√≠a basada √∫nicamente en la teor√≠a de la informaci√≥n: los pads √∫nicos y sus variantes. </blockquote><br>  Esta es el √°rea donde, excepto en busca de fallas de implementaci√≥n, se pueden encontrar la mayor√≠a de los problemas.  Si hay un grupo de matem√°ticos, criptoanalistas / cript√≥grafos e ingenieros inform√°ticos bien financiados que trabajan para probar o refutar algunos problemas matem√°ticos complejos extraordinarios (como el P? = NP) y lograr resultados sustanciales hasta este momento, podr√≠amos estar en problemas.  Sin embargo, es poco probable que tales avances en ciencias de la computaci√≥n, informaci√≥n y teor√≠as de computabilidad se oculten, ya que ese hecho escribir√≠a los nombres de sus creadores en las p√°ginas de Historia y, espec√≠ficamente, los libros de texto de Historia de Internet, lo que no tiene precio para cualquiera que sea inteligente .  Por lo tanto, tal escenario podr√≠a considerarse casi imposible. <br><br>  No est√° claro si en los pr√≥ximos 5 a√±os habr√≠a alg√∫n √©xito con la computaci√≥n cu√°ntica, aunque ya hay varias primitivas de criptograf√≠a consideradas adecuadas para el mundo post-cu√°ntico: ret√≠culas, curvas el√≠pticas supersingulares basadas en isogenia, hashes y c√≥digos.  Por ahora, los especialistas en seguridad solo est√°n experimentando con ellos.  Sin embargo, no hay duda de que, en caso de necesidad, la humanidad emplear√≠a r√°pidamente dichos algoritmos a gran escala. <br><br>  Por ahora, la criptograf√≠a basada en la curva el√≠ptica parece ser perfecta para la d√©cada futura, ya que proporciona seguridad y rendimiento. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/474810/">https://habr.com/ru/post/474810/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../474796/index.html">¬øQu√© es el Internet de las cosas y c√≥mo ayudar√° a las empresas a ganar m√°s?</a></li>
<li><a href="../474800/index.html">Rendimiento en .NET Core</a></li>
<li><a href="../474804/index.html">El progreso tecnol√≥gico ruso en el deporte: interfaces neuronales, c√°maras IP, CRM deportivo y BigData desde un autom√≥vil de carreras</a></li>
<li><a href="../474806/index.html">UDP Flood de Google o c√≥mo no privar a todo Youtube</a></li>
<li><a href="../474808/index.html">Lanzamiento de Rust 1.39.0: as√≠ncrono / espera, atributos para par√°metros de funci√≥n, nuevas funciones constantes</a></li>
<li><a href="../474812/index.html">Shader no es m√°gico. Escribiendo sombreadores en Unity. Sombreadores de v√©rtices</a></li>
<li><a href="../474814/index.html">Antig√ºedades: el mensajero de la decadencia o la obsolescencia no planificada</a></li>
<li><a href="../474816/index.html">Proyectos de mascotas - vida peque√±a</a></li>
<li><a href="../474818/index.html">¬øHay n√∫meros aleatorios en CSS?</a></li>
<li><a href="../474822/index.html">WISE-PaaS: una plataforma en la nube para la Internet industrial de las cosas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>