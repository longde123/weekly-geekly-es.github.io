<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§Ωüèª ü§¥üèø ‚òîÔ∏è √çndices de mapa de bits en Go: velocidad de b√∫squeda incre√≠ble üÜö üîå üó°Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mi nombre es Marko y di una charla en Gophercon Rusia este a√±o sobre un tipo muy interesante de √≠ndices llamados "√≠ndices de mapa de bits". Quer√≠a com...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√çndices de mapa de bits en Go: velocidad de b√∫squeda incre√≠ble</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/455608/">  Mi nombre es Marko y di una charla en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gophercon Rusia</a> este a√±o sobre un tipo muy interesante de √≠ndices llamados "√≠ndices de mapa de bits".  Quer√≠a compartirlo con la comunidad, no solo en formato de video, sino tambi√©n como un art√≠culo.  Es una versi√≥n en ingl√©s y puedes leer ruso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .  Por favor disfruta! <br><br><img src="https://habrastorage.org/webt/of/40/tp/of40tpvu9c7ammhkuygwa6x0eos.jpeg"><br><a name="habracut"></a><br>  Materiales adicionales, diapositivas y todo el c√≥digo fuente se pueden encontrar aqu√≠: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://bit.ly/bitmapindexes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/mkevac/gopherconrussia2019</a> <br><br>  Grabaci√≥n de video original: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WvlUH6MjUuI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  ¬°Comencemos! <br><br><h2>  Introduccion </h2><br><img src="https://habrastorage.org/webt/tz/mg/ae/tzmgaeevcgq_d8x8boqjdgqxnew.png"><br>  Hoy voy a hablar sobre <br><br><ul><li>  Qu√© √≠ndices son <br></li><li>  Qu√© es un √≠ndice de mapa de bits; <br></li><li>  Donde se usa  Por qu√© no se usa donde no se usa. <br></li><li>  Vamos a ver una implementaci√≥n simple en Go y luego ir al compilador. <br></li><li>  Luego, veremos una implementaci√≥n un poco menos simple, pero notablemente m√°s r√°pida, en el ensamblaje Go. <br></li><li>  Y despu√©s de eso, voy a abordar los "problemas" de los √≠ndices de mapas de bits uno por uno. <br></li><li>  Y finalmente, veremos qu√© soluciones existentes hay. <br></li></ul><br><h2>  Entonces, ¬øqu√© son los √≠ndices? </h2><br><img src="https://habrastorage.org/webt/ig/uh/ii/iguhiixwichncqrv6gdszecwgzg.png"><br><br>  Un √≠ndice es una estructura de datos distinta que se mantiene actualizada adem√°s de los datos principales, utilizada para acelerar las solicitudes de b√∫squeda.  Sin √≠ndices, la b√∫squeda implicar√≠a revisar todos los datos (en un proceso tambi√©n conocido como "exploraci√≥n completa") y ese proceso tiene una complejidad algor√≠tmica lineal.  Pero las bases de datos generalmente contienen grandes cantidades de datos, por lo que la complejidad lineal es demasiado lenta.  Idealmente, nos gustar√≠a alcanzar velocidades de complejidad logar√≠tmica o incluso constante. <br><br>  Este es un tema enorme y complejo que involucra muchas compensaciones, pero mirando hacia atr√°s durante d√©cadas de implementaciones de bases de datos e investigaciones, argumentar√≠a que solo hay unos pocos enfoques que se usan com√∫nmente: <br><br><img src="https://habrastorage.org/webt/aa/yv/wn/aayvwnmn7tbaucc39k3x7ejolsa.png"><br><br>  Primero, est√° reduciendo el √°rea de b√∫squeda cortando el √°rea entera en partes m√°s peque√±as, jer√°rquicamente. <br><br>  En general, esto se logra utilizando √°rboles.  Es similar a tener cajas de cajas en tu armario.  Cada caja contiene materiales que se clasifican en cajas m√°s peque√±as, cada una para un uso espec√≠fico.  Si necesitamos materiales, ser√≠a mejor buscar la caja etiquetada "material" en lugar de una caja etiquetada como "cookies". <br><br><img src="https://habrastorage.org/webt/zk/oq/_3/zkoq_3s8yr3izbnqvgd9nxmtvyi.png"><br><br>  El segundo es identificar instant√°neamente un elemento espec√≠fico o un grupo de elementos como en mapas hash o √≠ndices inversos.  El uso de mapas hash es similar al del ejemplo anterior, pero utiliza muchos cuadros m√°s peque√±os que no contienen cuadros en s√≠, sino elementos finales. <br><br><img src="https://habrastorage.org/webt/kv/zh/0q/kvzh0qp0teoe7h1_ixbeum9jdne.png"><br><br>  El tercer enfoque es eliminar la necesidad de buscar en absoluto como en filtros de floraci√≥n o filtros de cuco.  Los filtros Bloom pueden darle una respuesta de inmediato y ahorrarle el tiempo que de lo contrario se dedicar√≠a a la b√∫squeda. <br><br><img src="https://habrastorage.org/webt/r2/kk/cn/r2kkcn0uvtidikhqucutgigmvey.png"><br><br>  El √∫ltimo es acelerar la b√∫squeda haciendo un mejor uso de nuestras capacidades de hardware como en los √≠ndices de mapa de bits.  Los √≠ndices de mapa de bits a veces implican revisar todo el √≠ndice, s√≠, pero se hace de una manera muy eficiente. <br><br>  Como ya dije, la b√∫squeda tiene un mont√≥n de compensaciones, por lo que a menudo usamos varios enfoques para mejorar a√∫n m√°s la velocidad o para cubrir todos nuestros tipos de b√∫squeda potenciales. <br><br>  Hoy me gustar√≠a hablar sobre uno de estos enfoques que es menos conocido: los √≠ndices de mapas de bits. <br><br><h2>  ¬øPero qui√©n soy yo para hablar sobre este tema? </h2><br><img src="https://habrastorage.org/webt/dh/i9/-r/dhi9-rzto3wlple4rympbmrdhx4.png"><br><br>  Soy un l√≠der de equipo en Badoo (tal vez conoces otra de nuestras marcas: Bumble).  ¬°Tenemos m√°s de 400 millones de usuarios en todo el mundo y muchas de las funciones que tenemos incluyen la b√∫squeda de la mejor combinaci√≥n para usted!  Para estas tareas usamos servicios personalizados que usan √≠ndices de mapas de bits, entre otros. <br><br><h2>  Ahora, ¬øqu√© es un √≠ndice de mapa de bits? </h2><br><img src="https://habrastorage.org/webt/iz/ty/tu/iztytuxzo4kzx7vyc7vwrwwslze.png"><br><br>  Como su nombre lo indica, los √≠ndices de mapa de bits utilizan mapas de bits, tambi√©n conocidos como conjuntos de bits, para implementar el √≠ndice de b√∫squeda.  Desde el punto de vista de p√°jaro, este √≠ndice consta de uno o varios mapas de bits que representan entidades (por ejemplo, personas) y sus par√°metros (por ejemplo, edad o color de ojos) y un algoritmo para responder consultas de b√∫squeda utilizando operaciones bit a bit como AND, OR, NOT, etc. . <br><br><img src="https://habrastorage.org/webt/am/ws/tt/amwsttf4ru8rv7vjrrpwncxtamm.png"><br><br>  Los √≠ndices de mapa de bits se consideran muy √∫tiles y de alto rendimiento si tiene una b√∫squeda que tiene que combinar consultas de varias columnas con baja cardinalidad (tal vez, color de ojos o estado civil) frente a algo como la distancia al centro de la ciudad que tiene una cardinalidad infinita. <br><br>  Pero m√°s adelante en el art√≠culo mostrar√© que los √≠ndices de mapas de bits incluso funcionan con columnas de alta cardinalidad. <br><br>  Veamos el ejemplo m√°s simple de un √≠ndice de mapa de bits ... <br><br><img src="https://habrastorage.org/webt/mp/av/0r/mpav0rhqmrsmaker8gzyzydwdry.png"><br><br>  Imagine que tenemos una lista de restaurantes de Mosc√∫ con caracter√≠sticas binarias: <br><br><ul><li>  cerca del metro <br></li><li>  tiene estacionamiento privado <br></li><li>  tiene terraza <br></li><li>  acepta reservas <br></li><li>  vegano amigable <br></li><li>  caro <br></li></ul><br><img src="https://habrastorage.org/webt/sg/oq/db/sgoqdbv90ujmnpkajxcc-8eg0eg.jpeg"><br>  Vamos a dar a cada restaurante un √≠ndice a partir de 0 y asignar 6 mapas de bits (uno para cada caracter√≠stica).  Luego, rellenar√≠amos estos mapas de bits seg√∫n si el restaurante tiene una caracter√≠stica espec√≠fica o no.  Si el restaurante n√∫mero 4 tiene la terraza, el bit n√∫mero 4 en el mapa de bits "terraza" se establecer√° en 1 (0 si no). <br><br><img src="https://habrastorage.org/webt/qo/-k/oo/qo-kooibnag790shhatr6q6nucy.png"><br><br>  Ahora tenemos el √≠ndice de mapa de bits m√°s simple posible que podemos usar para responder preguntas como <br><br><ul><li>  Dame restaurantes que sean veganos <br></li><li>  Dame restaurantes con una terraza que acepten reservas, pero que no sean caras. <br></li></ul><br><img src="https://habrastorage.org/webt/qq/76/fv/qq76fv2-j68ou8hvryi9t8jjoog.png"><br><br><img src="https://habrastorage.org/webt/tf/om/e8/tfome8xr_th8yazqnavjfajocwq.png"><br><br>  Como?  A ver  La primera pregunta es simple.  Simplemente tomamos un mapa de bits "apto para veganos" y devolvemos todos los √≠ndices que tienen un bit establecido. <br><br><img src="https://habrastorage.org/webt/9p/fq/j2/9pfqj2djha0-ca4vmpjfpgyogbk.png"><br><br><img src="https://habrastorage.org/webt/en/3r/co/en3rcomfemoy-arkj9qx3fqmveu.jpeg"><br><br>  La segunda pregunta es un poco m√°s complicada.  Utilizaremos la operaci√≥n bit a bit NO en mapas de bits "caros" para obtener restaurantes no caros, Y con el mapa de bits "aceptar reserva" y Y con "tiene mapa de bits de terraza".  El mapa de bits resultante consistir√° en restaurantes que tienen todas estas caracter√≠sticas que quer√≠amos.  Aqu√≠ vemos que solo Yunost tiene todas estas caracter√≠sticas. <br><br><img src="https://habrastorage.org/webt/wm/jr/f5/wmjrf5nhch2k9zriz_sfuxzqfec.jpeg"><br><br><img src="https://habrastorage.org/webt/si/sf/c2/sisfc2h6lro8nu4yctf96absj_u.jpeg"><br><br>  Esto puede parecer un poco te√≥rico, pero no se preocupe, llegaremos al c√≥digo en breve. <br><br><h2>  Donde se usan los √≠ndices de mapa de bits </h2><br><img src="https://habrastorage.org/webt/zu/sd/up/zusdupegzydvhacdl-wzmwytrbq.jpeg"><br><br>  Si busca en Google "√≠ndice de mapa de bits", el 90% de los resultados apuntar√° a Oracle DB, que tiene √≠ndices b√°sicos de mapa de bits.  Pero, seguramente, otros DBMS tambi√©n usan √≠ndices de mapa de bits, ¬øno?  No, en realidad no lo hacen.  Repasemos a los sospechosos habituales uno por uno. <br><br><img src="https://habrastorage.org/webt/eg/of/z2/egofz23p1miavmonz6oeb4xhqiw.png"><br><br><ul><li>  MySQL a√∫n no tiene √≠ndices de mapas de bits, pero hay una propuesta para agregarlos ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://dev.mysql.com/worklog/task/?id=1524</a> ) <br></li><li>  PostgreSQL no tiene √≠ndices de mapa de bits, pero utilizan mapas de bits simples y operaciones bit a bit para combinar los resultados de m√∫ltiples √≠ndices diferentes. <br></li><li>  Tarantool tiene √≠ndices de bitset y permite b√∫squedas muy simples con ellos. <br></li><li>  Redis tiene campos de bits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://redis.io/commands/bitfiel</a> d sin capacidad de b√∫squeda <br></li><li>  MongoDB a√∫n no los tiene, pero tambi√©n hay una propuesta para agregarlos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">(https://jira.mongodb.org/browse/SERVER-1723)</a> <br></li><li>  Elasticsearch utiliza mapas de bits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://www.elastic.co/blog/frame-of-reference-and-roaring-bitmaps</a> internamente <br></li></ul><br><img src="https://habrastorage.org/webt/4l/ng/4b/4lng4bvs5rnrd5qcnxyhsharkmg.png"><br><ul><li>  Pero hay un nuevo chico en la cuadra: Pilosa.  Pilosa es un nuevo DBMS escrito en Go (observe que no hay R, no es relacional) que basa todo en √≠ndices de mapas de bits.  Y hablaremos de Pilosa m√°s tarde. <br></li></ul><br><h2>  Implementaci√≥n en marcha </h2><br>  Pero por que?  ¬øPor qu√© se usan tan raramente los √≠ndices de mapa de bits?  Antes de responder a esa pregunta, me gustar√≠a guiarlo a trav√©s de la implementaci√≥n b√°sica del √≠ndice de mapa de bits en Go. <br><br><img src="https://habrastorage.org/webt/db/ua/jt/dbuajtkgolu346p22gzcufwsll4.jpeg"><br><br>  El mapa de bits se representa como un fragmento de memoria.  En Go, usemos una porci√≥n de bytes para eso. <br><br>  Tenemos un mapa de bits por caracter√≠stica de restaurante.  Cada bit en un mapa de bits representa si un restaurante en particular tiene esta caracter√≠stica o no. <br><br><img src="https://habrastorage.org/webt/j2/az/1i/j2az1inrzzj0rcdg9dajst7afhc.jpeg"><br><br>  Necesitar√≠amos dos funciones auxiliares.  Uno se usa para llenar el mapa de bits al azar, pero con una probabilidad espec√≠fica de tener la caracter√≠stica.  Por ejemplo, creo que hay muy pocos restaurantes que no aceptan reservas y aproximadamente el 20% son veganos. <br><br>  Otra funci√≥n nos dar√° la lista de restaurantes de un mapa de bits. <br><br><img src="https://habrastorage.org/webt/aj/d7/vg/ajd7vgvjt7_2ssgiw7hh2jue9vu.jpeg"><img src="https://habrastorage.org/webt/gl/nv/wv/glnvwvokatnkyd08nxslinseoyc.jpeg"><br><br>  Para responder a la pregunta "dame restaurantes con una terraza que acepten reservas pero no son caros", necesitar√≠amos dos operaciones: NO y AND. <br><br>  Podemos simplificar ligeramente el c√≥digo introduciendo operaciones complejas Y NO. <br><br>  Tenemos las funciones para cada uno de estos.  Ambas funciones pasan por nuestros segmentos tomando los elementos correspondientes de cada uno, haciendo la operaci√≥n y escribiendo el resultado en el segmento resultante. <br><br><img src="https://habrastorage.org/webt/_f/-m/wa/_f-mwakzpgavqkr_a6m3lzzo_gy.jpeg"><br><br>  Y ahora podemos usar nuestros mapas de bits y nuestras funciones para obtener la respuesta. <br><br><img src="https://habrastorage.org/webt/rp/tn/uq/rptnuqmitwu5f-ag2w4tquglhca.jpeg"><br><br>  El rendimiento no es tan bueno aqu√≠ a pesar de que nuestras funciones son realmente simples y ahorramos mucho en asignaciones al no devolver un nuevo segmento en cada invocaci√≥n de funci√≥n. <br><br>  Despu√©s de algunos perfiles con pprof, not√© que el compilador de go perdi√≥ una de las optimizaciones m√°s b√°sicas: la funci√≥n en l√≠nea. <br><br><img src="https://habrastorage.org/webt/4s/6j/vs/4s6jvsys1nnmrpxnzpyfed8myq8.jpeg"><br><br>  Ver√°, el compilador Go teme patol√≥gicamente los bucles a trav√©s de sectores y se niega a incorporar cualquier funci√≥n que tenga esos. <br><br><img src="https://habrastorage.org/webt/ok/e_/th/oke_thx54xevzrxjqc6fmqx8w5y.jpeg"><br><br>  Pero no les tengo miedo y puedo enga√±ar al compilador usando goto para mi bucle. <br><br><img src="https://habrastorage.org/webt/bx/xo/ea/bxxoeatd8s3mby2jyemkac3jyfg.jpeg"><br><br><img src="https://habrastorage.org/webt/5k/fm/2l/5kfm2let9qh2ynkerqdkkd1thao.jpeg"><br><br>  Como puede ver, la alineaci√≥n nos ahorr√≥ unos 2 microsegundos.  No esta mal! <br><br><img src="https://habrastorage.org/webt/or/tx/lw/ortxlwhbagw4oafvij-sngkxbsm.jpeg"><br><br>  Otro cuello de botella es f√°cil de detectar cuando observa de cerca la salida del ensamblaje.  Ir compilador incluy√≥ controles de rango en nuestro bucle  Go es un lenguaje seguro y el compilador teme que mis tres mapas de bits puedan tener longitudes diferentes y que pueda haber un desbordamiento del b√∫fer. <br><br>  Calmemos el compilador y demostremos que todos mis mapas de bits tienen la misma longitud.  Para hacer eso, podemos agregar una simple verificaci√≥n al comienzo de la funci√≥n. <br><br><img src="https://habrastorage.org/webt/rq/v7/en/rqv7enj1mgqnsrgwnlkwscks0ri.jpeg"><br><br>  Con esta comprobaci√≥n, go compiler saltar√° felizmente las comprobaciones de rango y ahorraremos unos pocos nanosegundos. <br><br><h2>  Implementaci√≥n en montaje </h2><br>  Muy bien, as√≠ que logramos exprimir un poco m√°s el rendimiento con nuestra implementaci√≥n simple, pero este resultado es mucho peor de lo que es posible con el hardware actual. <br><br>  Ver√°, lo que estamos haciendo son operaciones bit a bit muy b√°sicas y nuestras CPU son muy efectivas con ellas. <br><br>  Desafortunadamente, estamos alimentando nuestra CPU con muy peque√±os trozos de trabajo.  Nuestra funci√≥n realiza operaciones byte a byte.  Podemos ajustar f√°cilmente nuestra implementaci√≥n para trabajar con fragmentos de 8 bytes mediante el uso de segmentos de uint64. <br><br><img src="https://habrastorage.org/webt/-w/vl/rd/-wvlrdx24mrcvy_vovvjeouaxjs.jpeg"><br><br>  Como puede ver aqu√≠, obtuvimos un rendimiento de aproximadamente 8x para un tama√±o de lote de 8x, por lo que las ganancias de rendimiento son bastante lineales. <br><br><img src="https://habrastorage.org/webt/tf/ej/nk/tfejnkdoftg8gs7vfpgrmbxfejq.jpeg"><img src="https://habrastorage.org/webt/ii/3d/du/ii3ddup__yc_-dhzsuivs6fcpeu.jpeg"><br><br>  Pero este no es el final del camino.  Nuestras CPU tienen la capacidad de trabajar con fragmentos de 16 bytes, 32 bytes e incluso con fragmentos de 64 bytes.  Estas operaciones se denominan SIMD (Datos m√∫ltiples de instrucci√≥n √∫nica) y el proceso de uso de tales operaciones de CPU se denomina vectorizaci√≥n. <br><br>  Desafortunadamente, el compilador Go no es muy bueno con la vectorizaci√≥n.  Y lo √∫nico que podemos hacer hoy en d√≠a para vectorizar nuestro c√≥digo es usar el ensamblaje Go y agregar estas instrucciones SIMD nosotros mismos. <br><br><img src="https://habrastorage.org/webt/rs/si/_o/rssi_opod7oxo-e-jk_qepjfvic.png"><br><br>  Ir a la asamblea es una bestia extra√±a.  Se podr√≠a pensar que el ensamblaje es algo que est√° vinculado a la arquitectura para la que est√° escribiendo, pero el ensamblaje de Go es m√°s como IRL (lenguaje de representaci√≥n intermedio): es independiente de la plataforma.  Rob Pike dio una incre√≠ble charla sobre esto hace unos a√±os. <br><br>  Adem√°s, Go utiliza un formato plan9 inusual que es diferente a los formatos AT&amp;T e Intel. <br><br><img src="https://habrastorage.org/webt/g4/aq/k5/g4aqk5lflo_4rgmsktoawvsiiuw.png"><br><br>  Es seguro decir que escribir el c√≥digo de ensamblaje Go no es divertido. <br><br>  Afortunadamente para nosotros, ya hay dos herramientas de nivel superior para ayudar a escribir el ensamblaje Go: PeachPy y avo.  Ambos generan el ensamblaje go a partir de un c√≥digo de nivel superior escrito en Python y Go respectivamente. <br><br><img src="https://habrastorage.org/webt/mf/qz/zb/mfqzzbyuqtrdk06iiiw4ufe5eou.jpeg"><br><br>  Estas herramientas simplifican cosas como la asignaci√≥n de registros y los bucles y, en general, reducen la complejidad de ingresar al √°mbito de la programaci√≥n de ensamblaje para Go. <br><br>  Usaremos evitar para esta publicaci√≥n para que nuestros programas se vean casi como el c√≥digo Go normal. <br><br><img src="https://habrastorage.org/webt/qd/ij/l2/qdijl2s77ub_c1om5budqbudjx4.jpeg"><br><br>  Este es el ejemplo m√°s simple de un programa avo.  Tenemos una funci√≥n main () que define una funci√≥n llamada Add () que agrega dos n√∫meros.  Hay funciones auxiliares para obtener par√°metros por nombre y obtener uno de los registros generales disponibles.  Aqu√≠ hay funciones para cada operaci√≥n de ensamblaje como ADDQ, y hay funciones auxiliares para guardar el resultado de un registro en el valor resultante. <br><br><img src="https://habrastorage.org/webt/8q/ze/6_/8qze6_requgfy9fimtn5tiirtn8.jpeg"><br><br>  Llamar a go generate ejecutar√° este programa avo y se crear√°n dos archivos <br><br><ul><li>  add.s con c√≥digo de ensamblaje generado <br></li><li>  stub.go con encabezados de funci√≥n que son necesarios para conectar nuestro c√≥digo de inicio y ensamblaje <br></li></ul><br><img src="https://habrastorage.org/webt/mz/bk/pi/mzbkpixqbe5kygtl9vphoeak39w.jpeg"><br><br>  Ahora que hemos visto lo que hace avo, veamos nuestras funciones.  He implementado versiones escalares y SIMD (vector) de nuestras funciones. <br><br>  Veamos primero c√≥mo se ve la versi√≥n escalar. <br><br><img src="https://habrastorage.org/webt/9v/1a/gj/9v1agjswpb-wnfoyqbb1x0rb6vo.jpeg"><br><br>  Como en un ejemplo anterior, podemos solicitar un registro general y evitar darnos el correcto que est√° disponible.  No necesitamos rastrear compensaciones en bytes para nuestros argumentos, evitando esto para nosotros. <br><br><img src="https://habrastorage.org/webt/rt/yj/ju/rtyjjuzuc4ycx2au4tqohzaxsby.jpeg"><br><br>  Anteriormente cambiamos de bucles a usar goto por razones de rendimiento y para enga√±ar al compilador.  Aqu√≠, estamos usando goto (saltos) y etiquetas desde el principio porque los bucles son construcciones de nivel superior.  En montaje solo tenemos saltos. <br><br><img src="https://habrastorage.org/webt/c4/gk/ww/c4gkwwdt0to9yorwoya2jurfrj8.jpeg"><br><br>  Otro c√≥digo deber√≠a ser bastante claro.  Emulamos el ciclo con saltos y etiquetas, tomamos una peque√±a parte de nuestros datos de nuestros dos mapas de bits, lo combinamos con una de las operaciones a nivel de bits e insertamos el resultado en el mapa de bits resultante. <br><br><img src="https://habrastorage.org/webt/vw/gj/fg/vwgjfg2tkeaxec2n7qkvgneqpve.jpeg"><br><br>  Este es un c√≥digo asm resultante que obtenemos.  No tuvimos que calcular desplazamientos y tama√±os (en verde), no tuvimos que lidiar con registros espec√≠ficos (en rojo). <br><br><img src="https://habrastorage.org/webt/of/sc/4v/ofsc4vbjkv2imcihypew4_japuo.jpeg"><br><br>  Si comparamos esta implementaci√≥n en ensamblaje con la mejor versi√≥n anterior escrita, ver√≠amos que el rendimiento es el mismo que el esperado.  No hicimos nada diferente. <br><br>  Desafortunadamente, no podemos obligar al compilador Go a incorporar nuestras funciones escritas en asm.  Carece completamente de soporte y la solicitud de esta caracter√≠stica ha existido desde hace alg√∫n tiempo.  Es por eso que las funciones asm peque√±as en go no dan ning√∫n beneficio.  Necesita escribir funciones m√°s grandes, usar nuevos paquetes matem√°ticos / bits u omitir asm por completo. <br><br>  Escribamos la versi√≥n vectorial de nuestras funciones ahora. <br><br><img src="https://habrastorage.org/webt/ac/qe/bs/acqebsweofbwzmvcwt-vro9yx4m.jpeg"><br><br>  Eleg√≠ usar AVX2, por lo que vamos a usar fragmentos de 32 bytes.  Es muy similar al escalar en estructura.  Cargamos par√°metros, solicitamos registros generales, etc. <br><br><img src="https://habrastorage.org/webt/ef/5g/wa/ef5gwafb0stn7wunw8ryjcjyt_k.jpeg"><br><br>  Uno de los cambios tiene que ver con el hecho de que las operaciones vectoriales utilizan registros anchos espec√≠ficos.  Para 32 bytes tienen el prefijo Y, es por eso que ves YMM () all√≠.  Para 64 bytes habr√≠an tenido el prefijo Z. <br><br>  Otra diferencia tiene que ver con la optimizaci√≥n que realic√© llamada desenrollamiento o desenrollamiento de bucle.  Eleg√≠ desenrollar parcialmente nuestro bucle y hacer 8 operaciones de bucle en secuencia antes de regresar.  Esta t√©cnica acelera el c√≥digo al reducir las ramas que tenemos y est√° bastante limitado por la cantidad de registros que tenemos disponibles. <br><br><img src="https://habrastorage.org/webt/vj/1c/nd/vj1cndpc9uqyrzgfqrld4vfda5o.jpeg"><br><br>  En cuanto al rendimiento ... es incre√≠ble.  Obtuvimos una mejora de aproximadamente 7 veces en comparaci√≥n con la mejor anterior.  Bastante impresionante, ¬øverdad? <br><br><img src="https://habrastorage.org/webt/d_/9b/ag/d_9bag_w0set74ryc4j5oqm5slm.jpeg"><br><br>  Deber√≠a ser posible mejorar estos resultados a√∫n m√°s utilizando AVX512, captando previamente y tal vez incluso utilizando la compilaci√≥n JIT (justo a tiempo) en lugar del generador de planes de consulta "manual", pero eso ser√≠a un tema para una publicaci√≥n totalmente diferente. <br><br><h2>  Problemas de √≠ndice de mapa de bits </h2><br>  Ahora que hemos visto la implementaci√≥n b√°sica y la impresionante velocidad de implementaci√≥n de asm, hablemos del hecho de que los √≠ndices de mapa de bits no se usan mucho.  ¬øPor qu√© es eso? <br><br><img src="https://habrastorage.org/webt/bp/mr/mw/bpmrmwhfel_gbjklekgwywrj67c.png"><br><br>  Las publicaciones m√°s antiguas nos dan estas tres razones.  Pero los recientes y yo argumentamos que ya se han "arreglado" o tratado.  No voy a entrar en muchos detalles sobre esto aqu√≠ porque no tenemos mucho tiempo, pero ciertamente vale la pena echar un vistazo r√°pido. <br><br><h2>  Problema de alta cardinalidad </h2><br>  Entonces, nos han dicho que los √≠ndices de mapas de bits son factibles solo para campos de baja cardinalidad.  es decir, campos que tienen pocos valores distintos, como g√©nero o color de ojos.  La raz√≥n es que la representaci√≥n com√∫n (un bit por valor distinto) puede ser bastante grande para valores de alta cardinalidad.  Y, como resultado, el mapa de bits puede volverse enorme incluso si est√° escasamente poblado. <br><br><img src="https://habrastorage.org/webt/zf/na/lt/zfnaltbokwrnweeiwtighgvq5cm.jpeg"><br><img src="https://habrastorage.org/webt/sa/p4/mw/sap4mwjq8sslx6_zgdanmn8fcwu.jpeg"><br><br>  A veces, se puede usar una representaci√≥n diferente para estos campos, como una representaci√≥n de n√∫mero binario como se muestra aqu√≠, pero el mayor cambio de juego es una compresi√≥n.  Los cient√≠ficos han creado asombrosos algoritmos de compresi√≥n.  Casi todos se basan en algoritmos de longitud de ejecuci√≥n generalizados, pero lo que es m√°s sorprendente es que no necesitamos descomprimir mapas de bits para realizar operaciones bit a bit en ellos.  Las operaciones normales a nivel de bits funcionan en mapas de bits comprimidos. <br><br><img src="https://habrastorage.org/webt/mv/56/bt/mv56btwi703wsb0nya7ofor5lew.jpeg"><br><br>  Recientemente, hemos visto enfoques h√≠bridos que aparecen como "mapas de bits rugientes".  Los mapas de bits rugientes usan tres representaciones separadas para mapas de bits: mapas de bits, matrices y "ejecuciones de bits" y equilibran el uso de estas tres representaciones tanto para maximizar la velocidad como para minimizar el uso de memoria. <br><br>  Se pueden encontrar mapas de bits en algunas de las aplicaciones m√°s utilizadas y existen implementaciones para muchos idiomas, incluidas varias implementaciones para Go. <br><br><img src="https://habrastorage.org/webt/af/xy/wy/afxywyhipsvsfla4tuot6ir0tei.jpeg"><br><br>  Otro enfoque que puede ayudar con los campos de alta cardinalidad se llama binning.  Imagine que tenemos un campo que representa la altura de una persona.  La altura es un flotador, pero no pensamos de esa manera.  A nadie le importa si tu altura es de 185,2 o 185,3 cm.  Por lo tanto, podemos usar "contenedores virtuales" para exprimir alturas similares en el mismo contenedor: el contenedor de 1 cm, en este caso.  Y si supone que hay muy pocas personas con una altura de menos de 50 cm, o m√°s de 250 cm, podemos convertir nuestra altura en el campo con una cardinalidad de aproximadamente 200 elementos, en lugar de una cardinalidad casi infinita.  Si es necesario, podr√≠amos hacer un filtrado adicional en los resultados m√°s adelante. <br><br><h2>  Problema de alto rendimiento </h2><br>  Otra raz√≥n por la cual los √≠ndices de mapas de bits son malos es que puede ser costoso actualizar mapas de bits. <br>  Las bases de datos realizan actualizaciones y b√∫squedas en paralelo, por lo que debe poder actualizar los datos mientras puede haber cientos de subprocesos pasando por mapas de bits haciendo una b√∫squeda.  Las cerraduras ser√≠an necesarias para evitar carreras de datos o problemas de consistencia de datos.  Y donde hay una gran cerradura, hay contenci√≥n de cerradura. <br><br><img src="https://habrastorage.org/webt/xg/ju/xl/xgjuxll8jn3btfxhniispsepbmw.jpeg"><br><br>  Este problema, si lo tiene, puede solucionarse fragmentando sus √≠ndices o teniendo versiones de √≠ndice, si corresponde. <br><br>  Fragmentar es sencillo.  Los fragmentar√° como fragmentar√≠a a los usuarios en una base de datos y ahora, en lugar de un bloqueo, tiene m√∫ltiples bloqueos, lo que reduce en gran medida su contenci√≥n de bloqueo. <br><br>  Otro enfoque que a veces es factible es tener √≠ndices versionados.  Tiene el √≠ndice que usa para la b√∫squeda y tiene un √≠ndice que usa para las escrituras, para las actualizaciones.  Y los copia y los cambia a baja frecuencia, por ejemplo, 100 o 500 ms. <br><br>  Pero este enfoque solo es factible si su aplicaci√≥n puede tolerar √≠ndices de b√∫squeda obsoletos que son un poco obsoletos. <br>  Por supuesto, estos dos enfoques tambi√©n se pueden usar juntos.  Puede tener √≠ndices versionados fragmentados. <br><br><h2>  Consultas no triviales </h2><br>  Otro problema de √≠ndice de mapa de bits tiene que ver con el uso de √≠ndices de mapa de bits con consultas de rango.  Y a primera vista, las operaciones bit a bit como AND y OR no parecen ser muy √∫tiles para consultas de rango como "darme habitaciones de hotel que cuestan de 200 a 300 d√≥lares por noche". <br><br><img src="https://habrastorage.org/webt/fq/qy/en/fqqyeneeggnmx0iccptaz8eygmm.jpeg"><br><br>  Una soluci√≥n ingenua y muy ineficiente ser√≠a obtener resultados para cada punto de precio de 200 a 300 y O los resultados. <br><br><img src="https://habrastorage.org/webt/jr/du/ey/jrdueypemf_a69m1wikbjpialze.jpeg"><br><br>  Un enfoque un poco mejor ser√≠a usar binning y colocar nuestros hoteles en rangos de precios con anchos de rango de, digamos, 50 d√≥lares.  Este enfoque reducir√≠a nuestros gastos de b√∫squeda en aproximadamente 50x. <br><br>  Pero este problema tambi√©n se puede resolver muy f√°cilmente mediante el uso de una codificaci√≥n especial que hace que las consultas de rango sean posibles y r√°pidas.  En la literatura, tales mapas de bits se denominan mapas de bits codificados por rango. <br><br><img src="https://habrastorage.org/webt/vq/hx/a5/vqhxa5jyy4w9_e5lurbjhntabie.jpeg"><br><br>  En los mapas de bits codificados por rango, no solo establecemos bits espec√≠ficos para, digamos, el valor 200, sino que establecemos todos los bits en 200 y superiores.  Lo mismo para 300. <br><br>  Por lo tanto, al usar esta representaci√≥n de mapa de bits codificada por rango, la consulta de rango se puede responder con solo dos pasos a trav√©s del mapa de bits.  Obtenemos todos los hoteles que cuestan menos de, o igual a, 300 d√≥lares y eliminamos del resultado todos los hoteles que cuestan menos de, o igual a, 199 d√≥lares.  Hecho <br><br><img src="https://habrastorage.org/webt/wh/bc/hs/whbchsdcr0qrupa6jhu9fcpufke.jpeg"><br><br>  Se sorprender√°, pero incluso las consultas geogr√°ficas son posibles utilizando mapas de bits.  El truco consiste en utilizar una representaci√≥n como Google S2 o similar que encierra una coordenada en una figura geom√©trica que se puede representar como tres o m√°s l√≠neas indexadas.  Si usa dicha representaci√≥n, puede representar la consulta geogr√°fica como varias consultas de rango en estos √≠ndices de l√≠nea. <br><br><h2>  Soluciones listas </h2><br>  Bueno, espero haber despertado un poco tu inter√©s.  Ahora tiene una herramienta m√°s en su haber y si alguna vez necesita implementar algo como esto en su servicio, sabr√° d√≥nde buscar. <br><br>  Eso est√° muy bien, pero no todos tienen el tiempo, la paciencia y los recursos para implementar el √≠ndice de mapa de bits, especialmente cuando se trata de cosas m√°s avanzadas como las instrucciones SIMD. <br><br>  No temas, hay dos productos de c√≥digo abierto que pueden ayudarte en tu esfuerzo. <br><br><img src="https://habrastorage.org/webt/em/cg/km/emcgkmutgbpdj_arrdnfoub6lt0.jpeg"><br><br><h2>  Rugir </h2><br>  Primero, hay una biblioteca que ya he mencionado llamada "mapas de bits rugientes".  Esta biblioteca implementa un "contenedor" rugiente y todas las operaciones bit a bit que necesitar√≠as si implementaras un √≠ndice de mapa de bits completo. <br><br><img src="https://habrastorage.org/webt/k3/mv/yh/k3mvyhvcdb8sh7g-aejhgqeob6c.jpeg"><br><br>  Desafortunadamente, las implementaciones de go no usan SIMD, por lo que ofrecen un rendimiento algo menor que, por ejemplo, la implementaci√≥n de C. <br><br><h2>  Pilosa </h2><br>  Otro producto es un DBMS llamado Pilosa que solo tiene √≠ndices de mapa de bits.  Es un proyecto reciente, pero √∫ltimamente ha ganado mucha tracci√≥n. <br><br><img src="https://habrastorage.org/webt/uw/gs/56/uwgs563qvexzg27dd5x15zbzlto.jpeg">  E-d3BCvTn1CSSDr5Vj6W_9e5_GC1syQ9qSrwdS0 "&gt; <br><br>  Pilosa utiliza mapas de bits rugosos debajo y da, simplifica o explica casi todas las cosas que le he estado diciendo hoy: binning, mapas de bits codificados por rango, la noci√≥n de campos, etc. <br><br>  Veamos brevemente un ejemplo de Pilosa en uso ... <br><br><img src="https://habrastorage.org/webt/8d/jm/kn/8djmknf2jltazwrepy_ia4j7k_4.jpeg"><br><br>  El ejemplo que ves es muy, muy similar al que vimos anteriormente.  Creamos un cliente para el servidor pilosa, creamos un √≠ndice y campos para nuestras caracter√≠sticas.  Rellenamos los campos con datos aleatorios con algunas probabilidades como lo hicimos anteriormente y luego ejecutamos nuestra consulta de b√∫squeda. <br>  Ves el mismo patr√≥n b√°sico aqu√≠.  NO costoso intersectado o AND-ed con terraza e intersectado con reservas. <br><br>  El resultado es el esperado. <br><br><img src="https://habrastorage.org/webt/bg/bu/oi/bgbuoi1v8n8vus4einuldy4u8zu.jpeg"><br><br>  Y, por √∫ltimo, espero que en alg√∫n momento en el futuro, las bases de datos como mysql y postgresql obtengan un nuevo tipo de √≠ndice: √≠ndice de mapa de bits. <br><br><img src="https://habrastorage.org/webt/ez/h4/g1/ezh4g1de2gpbozwi8-yubjvhpp4.jpeg"><br><br><h2>  Palabras de cierre </h2><br><img src="https://habrastorage.org/webt/tp/0f/3v/tp0f3vktlhcltdxbu7fatn7qqhq.jpeg"><br><br>  Y si todav√≠a est√°s despierto, te lo agradezco.  La escasez de tiempo ha significado que tuve que leer muchas de las cosas en esta publicaci√≥n, pero espero que haya sido √∫til e incluso inspirador. <br><br>  Los √≠ndices de mapa de bits son algo √∫til para conocer y comprender, incluso si no los necesita en este momento.  Gu√°rdelos como otra herramienta m√°s en su cartera. <br><br>  Durante mi charla, hemos visto varios trucos de rendimiento que podemos usar y cosas con las que Go tiene dificultades en este momento.  Definitivamente, estas son cosas que todo programador de Go necesita saber. <br><br>  Y esto es todo lo que tengo para ti por ahora.  Muchas gracias </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/455608/">https://habr.com/ru/post/455608/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455598/index.html">Actualice urgentemente Exim a 4.92: hay una infecci√≥n activa</a></li>
<li><a href="../455600/index.html">La plataforma 3DEXPERIENCE ayuda a crear el transporte p√∫blico del futuro</a></li>
<li><a href="../455602/index.html">Provocar bloqueos del navegador con fuzzing conductual</a></li>
<li><a href="../455604/index.html">Ansible para administrar la configuraci√≥n de Windows. Historia de √©xito</a></li>
<li><a href="../455606/index.html">Aprendizaje autom√°tico y an√°lisis de datos: programa de maestr√≠a en la Escuela Superior de Econom√≠a de San Petersburgo</a></li>
<li><a href="../455610/index.html">El legendario Intel Core i7-2600K: prueba de Sandy Bridge en 2019 (parte 1)</a></li>
<li><a href="../455612/index.html">Pensamos a trav√©s de los personajes de los juegos y los di√°logos siguiendo los consejos de los escritores y el ejemplo de los partidarios de la teor√≠a de una Tierra plana.</a></li>
<li><a href="../455614/index.html">FFI: escribir en Rust en un programa PHP</a></li>
<li><a href="../455616/index.html">¬øPor qu√© ir a "Programaci√≥n industrial" en el HSE de San Petersburgo?</a></li>
<li><a href="../455618/index.html">DevOps LEGO: c√≥mo dise√±amos una tuber√≠a en cubos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>