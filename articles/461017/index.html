<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äç‚öñÔ∏è üë©üèø‚Äçüöí üè¥Û†ÅßÛ†Å¢Û†Å≥Û†Å£Û†Å¥Û†Åø Nuevo algoritmo de seguimiento de GPU: trazado de ruta de frente de onda üö¨ ü§† üöµüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este art√≠culo, exploramos el concepto importante utilizado en la plataforma Lighthouse 2. lanzada recientemente. El trazado de ruta de frente de on...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nuevo algoritmo de seguimiento de GPU: trazado de ruta de frente de onda</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461017/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/_x/t8/rw/_xt8rwehj6jymumaisqg5ehgkro.png"></div><br>  En este art√≠culo, exploramos el concepto importante utilizado en la plataforma Lighthouse 2. lanzada recientemente. El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">trazado de ruta de frente de onda</a> , como se llama Lane, Karras y Aila de NVIDIA, o el seguimiento de ruta de transmisi√≥n, como se llam√≥ originalmente en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la tesis de maestr√≠a de</a> Van Antwerp, juega un papel crucial en el desarrollo de trazadores de ruta eficientes en la GPU, y potencialmente trazadores de ruta en la CPU.  Sin embargo, es bastante contradictorio, por lo tanto, para comprenderlo, es necesario repensar los algoritmos de trazado de rayos. <br><a name="habracut"></a><br><h2>  Ocupaci√≥n </h2><br>  El algoritmo de trazado de ruta es sorprendentemente simple y puede describirse en solo unas pocas l√≠neas de pseudoc√≥digo: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Trace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( vec3 O, vec3 D )</span></span></span><span class="hljs-function"> IntersectionData i </span></span>= Scene::Intersect( O, D ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == NoHit) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec3( <span class="hljs-number"><span class="hljs-number">0</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// ray left the scene if (i == Light) return i.material.color // lights do not reflect vec3 R, pdf = RandomDirectionOnHemisphere( i.normal ), 1 / 2PI return Trace( i.position, R ) * i.BRDF * dot( i.normal, R ) / pdf</span></span></code> </pre> <br>  La entrada es el <em>rayo primario que</em> pasa desde la c√°mara a trav√©s del p√≠xel de la pantalla.  Para este haz, determinamos la intersecci√≥n m√°s cercana con la escena primitiva.  Si no hay intersecciones, la viga desaparece en el vac√≠o.  De lo contrario, si el haz llega a la fuente de luz, entonces hemos encontrado el camino de la luz entre la fuente y la c√°mara.  Si encontramos algo m√°s, entonces realizamos la reflexi√≥n y la recursi√≥n, con la esperanza de que el haz reflejado a√∫n encuentre la fuente de iluminaci√≥n.  Tenga en cuenta que este proceso se asemeja a la ruta (de retorno) de un fot√≥n que se refleja en la superficie de una escena. <br><br>  Las GPU est√°n dise√±adas para realizar esta tarea en modo multiproceso.  Al principio puede parecer que el trazado de rayos es ideal para esto.  Entonces, utilizamos OpenCL o CUDA para crear una secuencia para un p√≠xel, cada secuencia realiza un algoritmo que realmente funciona seg√∫n lo previsto, y es bastante r√°pido: solo mire algunos ejemplos con ShaderToy para comprender <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cu√°n</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">r√°pido</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">puede</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ser el</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">trazado de rayos</a> en la GPU  Pero sea como fuere, la pregunta es diferente: ¬øson estos trazadores de rayos realmente <em>tan r√°pidos como sea posible</em> ? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce5/61d/07d/ce561d07daa3437927ab8ad5a6744ec9.jpg"></div><br>  Este algoritmo tiene un problema.  El rayo primario puede encontrar la fuente de luz inmediatamente, o despu√©s de una reflexi√≥n aleatoria, o despu√©s de cincuenta reflexiones.  El programador de la CPU notar√° un posible desbordamiento de pila aqu√≠;  el programador de la GPU deber√≠a ver <em>el problema de ocupaci√≥n</em> .  El problema es causado por la recursi√≥n de la cola condicional: la ruta puede terminar en la fuente de luz o continuar.  Transfieramos esto a muchos hilos: algunos de los hilos se detendr√°n, y la otra parte continuar√° funcionando.  Despu√©s de algunas reflexiones, tendremos varios subprocesos que necesitan continuar computando, y la mayor√≠a de los subprocesos esperar√°n a que estos √∫ltimos subprocesos terminen de funcionar.  <em>El empleo</em> es una medida de la porci√≥n de hilos de GPU que hacen un trabajo √∫til. <br><br>  El problema del empleo se aplica al modelo de ejecuci√≥n de dispositivos SIMT GPU.  Las secuencias se organizan en grupos, por ejemplo, en GPU Pascal (equipo NVidia clase 10xx) 32 hilos se combinan en una <em>urdimbre</em> .  Los hilos en warp tienen un contador de programa com√∫n: se ejecutan con un paso fijo, por lo que cada instrucci√≥n de programa se ejecuta con 32 hilos simult√°neamente.  SIMT significa una <em>sola instrucci√≥n de m√∫ltiples hilos</em> , que describe bien el concepto.  Para un procesador SIMT, un c√≥digo con condiciones es complejo.  Esto se muestra claramente en la documentaci√≥n oficial de Volta: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9bb/1c0/cb0/9bb1c0cb0c4916e8a7989edeb466d3dd.jpg"></div><br>  <i>Ejecuci√≥n de c√≥digo con condiciones en SIMT.</i> <br><br>  Cuando una cierta condici√≥n es verdadera para algunos subprocesos en warp, las ramas de la <em>instrucci√≥n if se</em> serializan.  Una alternativa al enfoque de "todos los hilos hacen lo mismo" es "algunos hilos est√°n deshabilitados".  En el bloque if-then-else, la ocupaci√≥n promedio de warp ser√° del 50%, a menos que todos los hilos tengan consistencia con respecto a la condici√≥n. <br><br>  Desafortunadamente, el c√≥digo con condiciones en el trazador de rayos no es tan raro.  Los rayos de sombras se emiten solo si la fuente de luz no est√° detr√°s del punto de sombreado, diferentes caminos pueden colisionar con diferentes materiales, la integraci√≥n con el m√©todo de la ruleta rusa puede destruir o dejar el camino vivo, y as√≠ sucesivamente.  Resulta que la ocupaci√≥n se est√° convirtiendo en la principal fuente de ineficiencia, y no es tan f√°cil prevenirla sin medidas de emergencia. <br><br><h2>  Streaming Path Tracing </h2><br>  El algoritmo de rastreo de ruta de transmisi√≥n est√° dise√±ado para abordar la causa ra√≠z del problema ocupado.  El seguimiento de ruta de transmisi√≥n divide el algoritmo de seguimiento de ruta en cuatro pasos: <br><br><ol><li>  <strong>Generar</strong> </li><li>  <strong>Extender</strong> </li><li>  <strong>Sombra</strong> </li><li>  <strong>Conectar</strong> </li></ol><br>  Cada etapa se implementa como un programa separado.  Por lo tanto, en lugar de ejecutar un trazador de ruta completo como un solo programa de GPU ("kernel", kernel), tendremos que trabajar con <em>cuatro</em> n√∫cleos.  Adem√°s, como veremos pronto, se ejecutan en un bucle. <br><br>  <b>La etapa 1 ("Generar")</b> es responsable de la generaci√≥n de rayos primarios.  Este es un n√∫cleo simple que crea los puntos de partida y las direcciones de los rayos en una cantidad igual al n√∫mero de p√≠xeles.  La salida de esta etapa es un b√∫fer de rayos grande y un contador que informa a la siguiente etapa de la cantidad de rayos que deben procesarse.  Para rayos primarios, este valor es igual al <em>ancho de la pantalla</em> multiplicado por la <em>altura de la pantalla</em> . <br><br>  <strong>La etapa 2 ("Renovar")</strong> es el segundo n√∫cleo.  Se ejecuta solo despu√©s de completar la etapa 1 para todos los p√≠xeles.  El n√∫cleo lee el b√∫fer generado en el paso 1 y cruza cada rayo con la escena.  La salida de esta etapa es el resultado de la intersecci√≥n para cada rayo almacenado en el b√∫fer. <br><br>  <strong>La etapa 3 ("Sombra")</strong> se realiza despu√©s de completar la etapa 2. Recibe el resultado de la intersecci√≥n de la etapa 2 y calcula el modelo de sombreado para cada ruta.  Esta operaci√≥n puede o no generar nuevos rayos, dependiendo de si la ruta se ha completado.  Las rutas que generan el nuevo rayo (la ruta "se extiende") escribe el nuevo rayo (el "segmento de ruta") en el b√∫fer.  Las rutas que muestrean directamente fuentes de luz ("expl√≠citamente muestrean iluminaci√≥n" o "calculan el pr√≥ximo evento") escriben un haz de sombra en un segundo buffer. <br><br>  <strong>La etapa 4 ("Conectar")</strong> traza los rayos de sombra generados en la etapa 3. Esto es similar a la etapa 2, pero con una diferencia importante: los rayos de la sombra necesitan encontrar <em>cualquier</em> intersecci√≥n, mientras que los rayos que se extienden necesitan encontrar la intersecci√≥n m√°s cercana.  Por lo tanto, se ha creado un n√∫cleo separado para esto. <br><br>  Despu√©s de completar el paso 4, obtenemos un b√∫fer que contiene rayos que extienden el camino.  Despu√©s de tomar estos rayos, procedemos a la etapa 2. Continuamos haciendo esto hasta que no haya rayos de extensi√≥n o hasta que alcancemos el n√∫mero m√°ximo de iteraciones. <br><br><h2>  Fuentes de ineficiencia </h2><br>  Un programador preocupado por el rendimiento ver√° muchos momentos peligrosos en este esquema de algoritmos de rastreo de ruta de transmisi√≥n: <br><br><ul><li>  En lugar de una sola llamada al n√∫cleo, ahora tenemos <em>tres llamadas por iteraci√≥n</em> , m√°s un n√∫cleo de generaci√≥n.  Los n√∫cleos desafiantes significan un cierto aumento en la carga, por lo que esto es malo. </li><li>  Cada n√∫cleo lee un gran b√∫fer y escribe un gran b√∫fer. </li><li>  La CPU necesita saber cu√°ntos hilos generar para cada n√∫cleo, por lo que la GPU debe decirle a la CPU cu√°ntos rayos se generaron en el paso 3. Mover informaci√≥n de la GPU a la CPU es una mala idea, y debe hacerse al menos una vez por iteraci√≥n. </li><li>  ¬øC√≥mo escribe la etapa 3 los rayos en el b√∫fer sin crear espacios en todas partes?  ¬øNo usa un contador at√≥mico para esto? </li><li>  El n√∫mero de rutas activas sigue disminuyendo, entonces, ¬øc√≥mo puede ayudar este esquema? </li></ul><br>  Comencemos con la √∫ltima pregunta: si transferimos un mill√≥n de tareas a la GPU, no generar√° un mill√≥n de hilos.  El n√∫mero real de subprocesos ejecutados simult√°neamente depende del equipo, pero en el caso general, se ejecutan decenas de miles de subprocesos.  Solo cuando la carga cae por debajo de este n√∫mero notaremos problemas de empleo causados ‚Äã‚Äãpor un peque√±o n√∫mero de tareas. <br><br>  Otra preocupaci√≥n es la E / S a gran escala de las memorias intermedias.  Esto es realmente una dificultad, pero no tan grave como cabr√≠a esperar: el acceso a los datos es altamente predecible, especialmente cuando se escribe en buffers, por lo que el retraso no causa problemas.  De hecho, las GPU se desarrollaron principalmente para este tipo de procesamiento de datos. <br><br>  Otro aspecto que las GPU manejan muy bien son los contadores at√≥micos, lo cual es bastante inesperado para los programadores que trabajan en el mundo de las CPU.  El z-buffer requiere un acceso r√°pido y, por lo tanto, la implementaci√≥n de contadores at√≥micos en las GPU modernas es extremadamente efectiva.  En la pr√°ctica, una operaci√≥n de escritura at√≥mica es tan costosa como una escritura no almacenada en memoria cach√©.  En muchos casos, el retraso estar√° enmascarado por la ejecuci√≥n paralela a gran escala en la GPU. <br><br>  Quedan dos preguntas: llamadas del n√∫cleo y transferencia de datos bidireccional para contadores.  Este √∫ltimo es en realidad un problema, por lo que necesitamos otro cambio arquitect√≥nico: <em>hilos persistentes</em> . <br><br><h2>  Las consecuencias </h2><br>  Antes de profundizar en los detalles, veremos las implicaciones del uso del algoritmo de trazado de ruta de frente de onda.  Primero, digamos sobre los tampones.  Necesitamos un b√∫fer para generar los datos de la etapa 1, es decir.  rayos primarios  Para cada haz necesitamos: <br><br><ul><li>  Origen del rayo: tres valores flotantes, es decir, 12 bytes </li><li>  Direcci√≥n del rayo: tres valores flotantes, es decir, 12 bytes </li></ul><br>  En la pr√°ctica, es mejor aumentar el tama√±o del b√∫fer.  Si almacena 16 bytes para el comienzo y la direcci√≥n del haz, la GPU podr√° leerlos en una operaci√≥n de lectura de 128 bits.  Una alternativa es una operaci√≥n de lectura de 64 bits seguida de una operaci√≥n de 32 bits para obtener float3, que es casi el doble de lenta.  Es decir, para una pantalla de 1920 √ó 1080 obtenemos: 1920x1080x32 = ~ 64 MB.  Tambi√©n necesitamos un buffer para los resultados de intersecci√≥n creados por el kernel Extend.  Estos son otros 128 bits por elemento, es decir, 32 MB.  Adem√°s, el n√∫cleo "Shadow" puede crear extensiones de ruta de hasta 1920 √ó 1080 (l√≠mite superior), y no podemos escribirlas en el b√∫fer del que leemos.  Esos son otros 64 MB.  Y finalmente, si nuestro trazado de ruta emite rayos de sombra, entonces este es otro b√∫fer de 64 MB.  Una vez resumido todo, obtenemos 224 MB de datos, y esto es solo para el algoritmo de frente de onda.  O aproximadamente 1 GB en resoluci√≥n 4K. <br><br>  Aqu√≠ necesitamos acostumbrarnos a otra funci√≥n: tenemos mucha memoria.  Puede parecer.  ese 1 GB es mucho, y hay formas de reducir este n√∫mero, pero si lo aborda de manera realista, para cuando realmente necesitemos rastrear las rutas en 4K, usar 1 GB en una GPU con 8 GB ser√° el menor de nuestros problemas. <br><br>  M√°s graves que los requisitos de memoria, las consecuencias ser√°n para el algoritmo de representaci√≥n.  Hasta ahora, he sugerido que necesitamos generar un rayo de extensi√≥n y, posiblemente, un rayo de sombra para cada hilo en el n√∫cleo de Shadow.  Pero, ¬øqu√© pasa si queremos realizar una oclusi√≥n ambiental con 16 rayos por p√≠xel?  Deben almacenarse 16 rayos AO en el b√∫fer, pero, lo que es peor, aparecer√°n solo en la pr√≥xima iteraci√≥n.  Un problema similar surge cuando se trazan rayos en el estilo de Whited: es casi imposible realizar un haz de sombra para varias fuentes de luz o dividir un haz en una colisi√≥n con vidrio. <br><br>  Por otro lado, el trazado de camino de frente de onda resuelve los problemas que hemos enumerado en la secci√≥n Ocupaci√≥n: <br><br><ul><li>  En la etapa 1, todos los flujos sin condiciones crean rayos primarios y los escriben en el b√∫fer. </li><li>  En la etapa 2, todos los flujos sin condiciones cruzan los rayos con la escena y escriben los resultados de la intersecci√≥n en el b√∫fer. </li><li>  En el paso 3, comenzamos a calcular los resultados de intersecci√≥n con una ocupaci√≥n del 100%. </li><li>  En el paso 4, procesamos una lista continua de rayos de sombra sin espacios. </li></ul><br>  Cuando regresemos a la etapa 2 con los rayos supervivientes con una longitud de 2 segmentos, nuevamente tenemos un b√∫fer de rayos compacto que garantiza el pleno empleo cuando comienza el n√∫cleo. <br><br>  Adem√°s, hay una ventaja adicional que no debe subestimarse.  El c√≥digo est√° aislado en cuatro pasos separados.  Cada n√∫cleo puede usar todos los recursos de GPU disponibles (cach√©, memoria compartida, registros) sin tener en cuenta otros n√∫cleos.  Esto puede permitir que la GPU ejecute el c√≥digo de intersecci√≥n con la escena en m√°s hilos, porque este c√≥digo no requiere tantos registros como el c√≥digo del sombreador.  Cuantos m√°s subprocesos, mejor podr√° ocultar los retrasos. <br><br>  M√°scara de retraso mejorada a tiempo completo, grabaci√≥n de transmisi√≥n: todos estos beneficios est√°n directamente relacionados con el surgimiento y la naturaleza de la plataforma GPU.  Para la GPU, el algoritmo de trazado de ruta de frente de onda es muy natural. <br><br><h2>  ¬øVale la pena? </h2><br>  Por supuesto, tenemos una pregunta: ¬øel empleo optimizado justifica la E / S de las memorias intermedias y el costo de invocar n√∫cleos adicionales? <br><br>  La respuesta es s√≠, pero probar esto no es tan f√°cil. <br><br>  Si volvemos a los trazadores de ruta con ShaderToy por un segundo, veremos que la mayor√≠a de ellos usan una escena simple y codificada.  Reemplazarlo con una escena completa no es una tarea trivial: para millones de primitivas, la intersecci√≥n del haz y la escena se convierte en un problema complejo, cuya soluci√≥n a menudo se deja a NVidia ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Optix</a> ), AMD ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Radeon-Rays</a> ) o Intel ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Embree</a> ).  Ninguna de estas opciones puede reemplazar f√°cilmente la escena codificada en el trazador de rayos artificiales CUDA.  En CUDA, el an√°logo m√°s cercano (Optix) requiere control sobre la ejecuci√≥n del programa.  Embree en la CPU le permite rastrear haces individuales desde su propio c√≥digo, pero el costo de esto es una sobrecarga de rendimiento significativa: prefiere rastrear grandes grupos de haces en lugar de haces individuales. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fb4/2a2/409/fb42a240924ba04871abb70421d16cdf.png"></div><br>  <i>Pantalla de It's About Time renderizada con Brigade 1.</i> <br><br>  El trazado del camino del frente de onda ser√° m√°s r√°pido que su alternativa (el megakernel, como lo llaman Lane y sus colegas), depende del tiempo que pasen en los n√∫cleos (las escenas grandes y los sombreadores costosos reducen el exceso relativo de costos por el algoritmo del frente de onda), en la longitud m√°xima del camino , empleo mega-core y diferencias en la carga de los registros en cuatro etapas.  En una versi√≥n anterior del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Trazador de ruta de brigada</a> original <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">,</a> descubrimos que incluso una escena simple con una mezcla de superficies reflectantes y Lambert que se ejecutan en la GTX480 se benefici√≥ del uso de wavefront. <br><br><h2>  Streaming Path Tracing en el faro 2 </h2><br>  La plataforma Lighthouse 2 tiene dos trazadores de trazado de ruta de frente de onda.  El primero usa Optix Prime para la implementaci√≥n de las etapas 2 y 4 (etapas de la intersecci√≥n de rayos y escenas);  en el segundo, Optix se usa directamente para implementar esa funcionalidad. <br><br>  Optix Prime es una versi√≥n simplificada de Optix que solo se ocupa de la intersecci√≥n de un conjunto de haces con una escena que consiste en tri√°ngulos.  A diferencia de la biblioteca Optix completa, no admite c√≥digos de intersecci√≥n personalizados y solo intersecta tri√°ngulos.  Sin embargo, esto es exactamente lo que se requiere para el trazado de ruta de frente de onda. <br><br>  El trazado de ruta de frente de onda basado en Optix Prime se implementa en <code>rendercore.cpp</code> proyecto <code>rendercore.cpp</code> .  La inicializaci√≥n de Optix Prime comienza en la funci√≥n <code>Init</code> y usa <code>rtpContextCreate</code> .  La escena se crea usando <code>rtpModelCreate</code> .  Se crean varios buffers de rayos en la funci√≥n <code>rtpBufferDescCreate</code> usando <code>rtpBufferDescCreate</code> .  Tenga en cuenta que para estos b√∫feres proporcionamos los punteros habituales del dispositivo: esto significa que se pueden usar tanto en Optix como en n√∫cleos CUDA normales. <br><br>  El renderizado comienza en el m√©todo <code>Render</code> .  Para llenar el b√∫fer de rayos primario, <code>generateEyeRays</code> un n√∫cleo CUDA llamado <code>generateEyeRays</code> .  Despu√©s de llenar el b√∫fer, se llama a Optix Prime usando <code>rtpQueryExecute</code> .  Con √©l, los resultados de la intersecci√≥n se escriben en <code>extensionHitBuffer</code> .  Tenga en cuenta que todos los buffers permanecen en la GPU: con la excepci√≥n de las llamadas del kernel, no hay tr√°fico entre la CPU y la GPU.  La etapa "Shadow" se implementa en el n√∫cleo de <code>shade</code> CUDA normal.  Su implementaci√≥n est√° en <code>pathtracer.cu</code> . <br><br>  <code>optixprime_b</code> pena mencionar algunos detalles de implementaci√≥n para <code>optixprime_b</code> .  Primero, los rayos de sombra se trazan fuera del ciclo del frente de onda.  Esto es correcto: un rayo de sombra afecta a un p√≠xel solo si no est√° bloqueado, pero en todos los dem√°s casos su resultado no es necesario en ning√∫n otro lugar.  Es decir, el haz de sombra es <em>desechable</em> , se puede rastrear en cualquier momento y en cualquier orden.  En nuestro caso, usamos esto agrupando los rayos de la sombra para que el lote finalmente trazado sea lo m√°s grande posible.  Esto tiene una consecuencia desagradable: con <em>N</em> iteraciones del algoritmo de frente de onda y <em>X</em> rayos primarios, el l√≠mite superior del n√∫mero de rayos de sombra es igual a <em>XN</em> . <br><br>  Otro detalle es el procesamiento de varios contadores.  Las etapas "Renovar" y "Sombra" deben saber cu√°ntos caminos est√°n activos.  Los contadores para esto se actualizan en la GPU (at√≥micamente), lo que significa que se usan en la GPU, incluso sin volver a la CPU.  Desafortunadamente, en uno de los casos esto es imposible: la biblioteca Optix Prime necesita saber la cantidad de rayos trazados.  Para hacer esto, necesitamos devolver la informaci√≥n de los contadores una vez que se realiza una iteraci√≥n. <br><br><h2>  Conclusi√≥n </h2><br>  Este art√≠culo explica qu√© es el trazado de ruta de frente de onda y por qu√© es necesario realizar de manera efectiva el trazado de ruta en la GPU.  Su implementaci√≥n pr√°ctica se presenta en la plataforma Lighthouse 2, que es de c√≥digo abierto y est√° <a href="">disponible en Github</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/461017/">https://habr.com/ru/post/461017/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461005/index.html">Pruebas para la empresa: haciendo las preguntas correctas en la entrevista</a></li>
<li><a href="../461007/index.html">Primeros pasos con el analizador est√°tico PVS-Studio para Visual C ++</a></li>
<li><a href="../461009/index.html">C√≥mo hacer un est√°ndar en 10 d√≠as. Segunda parte Aburrido</a></li>
<li><a href="../461013/index.html">Reservando conexi√≥n a internet</a></li>
<li><a href="../461015/index.html">Vive y aprende. Parte 2. Universidad: ¬ø5 a√±os o 5 corredores?</a></li>
<li><a href="../461019/index.html">¬øC√≥mo es la vida para los desarrolladores en Ir√°n?</a></li>
<li><a href="../461027/index.html">Java REPL no hace ScriptEngine</a></li>
<li><a href="../461029/index.html">Un lago de datos de marketing: desde tablas monstruosas hasta informes y visualizaciones</a></li>
<li><a href="../461031/index.html">Conectamos mapas en l√≠nea al navegador en el tel√©fono inteligente. Parte 1 - mapas r√°ster est√°ndar</a></li>
<li><a href="../461033/index.html">¬øDe d√≥nde viene esta configuraci√≥n? [Debian / Ubuntu]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>