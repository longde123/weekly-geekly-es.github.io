<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ›ï¸ ğŸ–¥ï¸ ğŸ Python sebagai kasus akhir C ++. Bagian 2/2 ğŸ™‹ğŸ» ğŸ§‘ğŸ¿ ğŸ“±</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Untuk dilanjutkan. Dimulai dengan Python sebagai Kasus Ultimate C ++. Bagian 1/2 ". 
 Variabel dan Tipe Data 


 Sekarang setelah kita akhirnya menget...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python sebagai kasus akhir C ++. Bagian 2/2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464405/"><p>  Untuk dilanjutkan.  Dimulai dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Python sebagai Kasus Ultimate C ++.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1/2</a> ". </p><br><h1>  Variabel dan Tipe Data </h1><br><p>  Sekarang setelah kita akhirnya mengetahui matematika, mari kita putuskan variabel apa yang harus berarti dalam bahasa kita. </p><br><p>  Dalam C ++, seorang programmer memiliki pilihan: menggunakan variabel otomatis yang ditempatkan di stack, atau menyimpan nilai dalam memori data program, menempatkan hanya pointer ke nilai-nilai ini di stack.  Bagaimana jika kita memilih hanya satu dari opsi ini untuk Python? </p><br><p>  Tentu saja, kita tidak selalu bisa hanya menggunakan nilai-nilai variabel, karena struktur data yang besar tidak akan muat di stack, atau gerakan konstan mereka di stack akan membuat masalah kinerja.  Oleh karena itu, kami hanya akan menggunakan pointer dalam Python.  Ini secara konseptual akan menyederhanakan bahasa. </p><a name="habracut"></a><br><p>  Begitu ekspresinya </p><br><pre><code class="python hljs">a = <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><p>  akan berarti bahwa kami membuat objek "3" dalam memori data program (yang disebut "tumpukan") dan menjadikan nama "a" referensi untuk itu.  Dan ekspresinya </p><br><pre> <code class="python hljs">b = a</code> </pre> <br><p>  dalam hal ini, itu berarti bahwa kami memaksa variabel "b" untuk merujuk ke objek yang sama dalam memori yang "a" merujuk, dengan kata lain, kami menyalin pointer. </p><br><p>  Jika semuanya adalah pointer, lalu berapa banyak tipe daftar yang perlu kita terapkan dalam bahasa kita?  Tentu saja, hanya satu yang merupakan daftar petunjuk!  Anda dapat menggunakannya untuk menyimpan bilangan bulat, string, daftar lain, apa pun - setelah semua, ini adalah pointer. </p><br><p>  Berapa banyak jenis tabel hash yang perlu kita terapkan?  (Dalam Python, jenis ini disebut "kamus" - <code>dict</code> .) Satu!  Biarkan mengasosiasikan pointer ke kunci dengan pointer ke nilai. </p><br><p>  Jadi, kita tidak perlu mengimplementasikan dalam bahasa kita bagian besar dari spesifikasi C ++ - templat, karena kita melakukan semua operasi pada objek, dan objek selalu dapat diakses oleh pointer.  Tentu saja, program yang ditulis dengan Python tidak harus membatasi diri untuk bekerja dengan pointer: ada perpustakaan seperti NumPy yang membantu para ilmuwan bekerja dengan array data dalam memori, seperti yang mereka lakukan di Fortran.  Tetapi dasar bahasa - ekspresi seperti "a = 3" - selalu bekerja dengan pointer. </p><br><p>  Konsep "semuanya adalah sebuah penunjuk" juga menyederhanakan komposisi tipe hingga batasnya.  Ingin daftar kamus?  Cukup buat daftar dan letakkan kamus di sana!  Anda tidak perlu meminta izin Python, Anda tidak perlu mendeklarasikan tipe tambahan, semuanya berfungsi di luar kotak. </p><br><p>  Tetapi bagaimana jika kita ingin menggunakan objek majemuk sebagai kunci?  Kunci dalam kamus harus memiliki nilai yang tidak dapat diubah, jika tidak, bagaimana cara mencari nilai dengan itu?  Daftar dapat berubah, oleh karena itu mereka tidak dapat digunakan dalam kapasitas ini.  Untuk situasi seperti itu, Python memiliki tipe data yang, seperti daftar, adalah urutan objek, tetapi, tidak seperti daftar, urutan ini tidak berubah.  Jenis ini disebut tuple atau <code>tuple</code> (dilafalkan "tuple" atau "tuple"). </p><br><p>  Tuples di Python memecahkan masalah bahasa scripting yang sudah lama.  Jika Anda tidak terkesan dengan fitur ini, maka Anda mungkin belum pernah mencoba menggunakan bahasa skrip untuk pekerjaan serius dengan data, di mana Anda hanya dapat menggunakan string atau hanya tipe primitif sebagai kunci dalam tabel hash. </p><br><p>  Kemungkinan lain yang diberikan tuple kepada kami adalah mengembalikan beberapa nilai dari suatu fungsi tanpa harus mendeklarasikan tipe data tambahan untuk ini, seperti yang harus Anda lakukan dalam C dan C ++.  Selain itu, untuk membuatnya lebih mudah menggunakan fitur ini, operator penugasan diberkahi dengan kemampuan untuk secara otomatis membongkar tuple menjadi variabel yang terpisah. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> host, port host, port = get_address()</code> </pre> <br><p>  Pembongkaran memiliki beberapa efek samping yang berguna, misalnya, pertukaran nilai variabel dapat ditulis sebagai berikut: </p><br><pre> <code class="python hljs">x, y = y, x</code> </pre> <br><p>  Semuanya adalah pointer, yang berarti fungsi dan tipe data dapat digunakan sebagai data.  Jika Anda terbiasa dengan buku "Pola Desain" oleh "The Gang of Four", Anda harus ingat metode rumit dan membingungkan yang ditawarkannya untuk membuat parameter pilihan jenis objek yang dibuat oleh program Anda saat runtime.  Memang, dalam banyak bahasa pemrograman ini sulit dilakukan!  Dalam Python, semua kesulitan ini hilang, karena kita tahu bahwa suatu fungsi dapat mengembalikan tipe data, bahwa kedua fungsi dan tipe data hanyalah tautan, dan tautan dapat disimpan, misalnya, dalam kamus.  Ini menyederhanakan tugas hingga batas. </p><br><p>  David Wheeler berkata: "Semua masalah pemrograman diselesaikan dengan menciptakan tingkat tipuan tambahan."  Menggunakan tautan dalam Python adalah tingkat tipuan yang secara tradisional telah digunakan untuk memecahkan banyak masalah dalam banyak bahasa, termasuk C ++.  Tetapi jika digunakan secara eksplisit di sana, dan ini menyulitkan program, maka dalam Python digunakan secara implisit, seragam sehubungan dengan data dari semua jenis, dan ramah pengguna. </p><br><p>  Tetapi jika semuanya adalah tautan, lalu apa yang dimaksud tautan-tautan ini?  Bahasa seperti C ++ memiliki banyak jenis.  Mari kita tinggalkan Python hanya satu tipe data - sebuah objek!  Spesialis di bidang teori tipe menggelengkan kepala dengan tidak setuju, tapi saya percaya bahwa satu tipe sumber data, dari mana semua tipe lain dalam bahasa tersebut diturunkan, adalah ide bagus yang memastikan keseragaman bahasa dan kemudahan penggunaannya. </p><br><p>  Untuk konten memori tertentu, berbagai implementasi Python (PyPy, Jython, atau MicroPython) dapat mengatur memori dengan berbagai cara.  Tetapi untuk lebih memahami bagaimana kesederhanaan dan keseragaman Python diimplementasikan, untuk membentuk model mental yang benar, lebih baik beralih ke implementasi referensi Python di C yang disebut CPython, yang dapat kita unduh di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">python.org</a> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeobject</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ob_type</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* followed by object's data */</span></span> }</code> </pre> <br><p>  Apa yang akan kita lihat dalam kode sumber CPython adalah struktur yang terdiri dari pointer ke informasi tentang jenis variabel yang diberikan dan muatan yang menentukan nilai spesifik dari variabel. </p><br><p>  Bagaimana cara kerja informasi tipe?  Mari kita gali kode sumber CPython lagi. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeobject</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> getattrfunc tp_getattr; setattrfunc tp_setattr; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> newfunc tp_new; freefunc tp_free; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> binaryfunc nb_add; binaryfunc nb_subtract; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> richcmpfunc tp_richcompare; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p>  Kami melihat pointer ke fungsi yang menyediakan semua operasi yang mungkin untuk tipe tertentu: penambahan, pengurangan, perbandingan, akses ke atribut, pengindeksan, pengirisan, dll. Operasi ini tahu cara bekerja dengan muatan yang terletak di memori di bawah pointer untuk mengetik informasi, baik itu integer, string, atau objek dari tipe yang dibuat oleh pengguna. </p><br><p>  Ini sangat berbeda dari C dan C ++, di mana informasi jenis dikaitkan dengan nama, bukan nilai variabel.  Dalam Python, semua nama dikaitkan dengan tautan.  Nilai berdasarkan referensi, pada gilirannya, adalah tipe.  Ini adalah inti dari bahasa dinamis. </p><br><p>  Untuk mewujudkan semua fitur bahasa, cukup bagi kami untuk mendefinisikan dua operasi pada tautan.  Salah satu yang paling jelas adalah menyalin.  Saat kami menetapkan nilai ke variabel, slot di kamus, atau atribut objek, kami menyalin tautan.  Ini adalah operasi yang sederhana, cepat dan sepenuhnya aman: menyalin tautan tidak mengubah konten objek. </p><br><p>  Operasi kedua adalah panggilan fungsi atau metode.  Seperti yang kami tunjukkan di atas, program Python dapat berinteraksi dengan memori hanya melalui metode yang diimplementasikan pada objek bawaan.  Oleh karena itu, itu tidak dapat menyebabkan kesalahan terkait dengan akses memori. </p><br><p>  Anda mungkin memiliki pertanyaan: jika semua variabel berisi referensi, lalu bagaimana saya bisa melindungi nilai variabel dari perubahan dengan meneruskannya ke fungsi sebagai parameter? </p><br><pre> <code class="python hljs">n = <span class="hljs-number"><span class="hljs-number">3</span></span> some_function(n) <span class="hljs-comment"><span class="hljs-comment"># Q: I just passed a pointer! # Could some_function() have changed â€œ3â€?</span></span></code> </pre> <br><p>  Jawabannya adalah bahwa tipe sederhana dalam Python tidak dapat diubah: mereka tidak mengimplementasikan metode yang bertanggung jawab untuk mengubah nilainya.  <code>int</code> , immatable (immutable) <code>int</code> , <code>float</code> , <code>tuple</code> atau <code>str</code> menyediakan dalam bahasa seperti "everything is a pointer" efek semantik yang sama yang diberikan variabel otomatis dalam C. </p><br><p>  Jenis dan metode terpadu menyederhanakan penggunaan pemrograman umum, atau generik, sebanyak mungkin.  Fungsi <code>min()</code> , <code>max()</code> , <code>sum()</code> dan sejenisnya adalah bawaan, tidak perlu mengimpornya.  Dan mereka bekerja dengan tipe data apa pun di mana operasi perbandingan untuk <code>min()</code> dan <code>max()</code> diimplementasikan, penambahan untuk <code>sum()</code> , dll. </p><br><h1>  Buat Objek </h1><br><p>  Kami menemukan secara umum bagaimana benda harus berperilaku.  Sekarang kita akan menentukan bagaimana kita akan membuatnya.  Ini adalah masalah sintaksis bahasa.  C ++ mendukung setidaknya tiga cara untuk membuat objek: </p><br><ol><li>  Otomatis, dengan mendeklarasikan variabel kelas ini: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">my_class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arg)</span></span></span></span>;</code> </pre> </li><li>  Menggunakan operator <code>new</code> : <br><pre> <code class="cpp hljs">my_class *c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> my_class(arg);</code> </pre> </li><li>  Factory, dengan memanggil fungsi arbitrer yang mengembalikan pointer: <br><pre> <code class="cpp hljs">my_class *c = my_factory(arg);</code> </pre> </li></ol><br><p>  Seperti yang mungkin sudah Anda duga, setelah mempelajari cara berpikir pembuat Python dalam contoh di atas, sekarang kita harus memilih salah satunya. </p><br><p>  Dari buku yang sama, Geng Empat, kami belajar bahwa pabrik adalah cara paling fleksibel dan universal untuk membuat objek.  Oleh karena itu, hanya metode ini yang diimplementasikan dalam Python. </p><br><p>  Selain universalitas, metode ini bagus karena Anda tidak perlu membebani bahasa dengan sintaksis yang tidak perlu untuk memastikannya: pemanggilan fungsi sudah diterapkan dalam bahasa kami, dan pabrik tidak lebih dari fungsi. </p><br><p>  Aturan lain untuk membuat objek dalam Python adalah ini: semua tipe data adalah pabriknya sendiri.  Tentu saja, Anda dapat menulis sejumlah pabrik kustom tambahan (yang akan menjadi fungsi atau metode biasa, tentu saja), tetapi aturan umum akan tetap berlaku: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Let's make type objects # their own type's factories! c = MyClass() i = int('7') f = float(length) s = str(bytes)</span></span></code> </pre> <br><p>  Semua tipe disebut objek, dan semuanya mengembalikan nilai tipenya, ditentukan oleh argumen yang diteruskan dalam panggilan. </p><br><p>  Dengan demikian, hanya menggunakan sintaks dasar bahasa, setiap manipulasi saat membuat objek, seperti pola "Arena" atau "Adaptasi", dapat dienkapsulasi, karena ide bagus lain yang dipinjam dari C ++ adalah bahwa jenis itu sendiri menentukan bagaimana hal itu terjadi menelurkan objeknya, bagaimana operator <code>new</code> bekerja untuknya. </p><br><h1>  Bagaimana dengan NULL? </h1><br><p>  Menangani null pointer menambah kompleksitas pada program, jadi kami melarang NULL.  Sintaksis python tidak memungkinkan untuk membuat pointer nol.  Dua operasi dasar pada pointer, yang telah kita bicarakan sebelumnya, didefinisikan sedemikian rupa sehingga setiap variabel menunjuk ke suatu objek. </p><br><p>  Sebagai akibatnya, pengguna tidak dapat menggunakan Python untuk membuat kesalahan yang terkait dengan akses memori, seperti kesalahan segmentasi atau di luar batas buffer.  Dengan kata lain, program Python tidak terpengaruh oleh dua jenis kerentanan paling berbahaya yang mengancam keamanan Internet selama 20 tahun terakhir. </p><br><p>  Anda mungkin bertanya: "Jika struktur operasi pada objek tidak berubah, seperti yang kita lihat sebelumnya, lalu bagaimana pengguna akan membuat kelas mereka sendiri, dengan metode dan atribut yang tidak tercantum dalam struktur ini?" </p><br><p>  Ajaibnya terletak pada kenyataan bahwa untuk kelas khusus Python memiliki "persiapan" yang sangat sederhana dengan sejumlah kecil metode yang diterapkan.  Inilah yang paling penting: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeobject</span></span></span><span class="hljs-class"> {</span></span> getattrfunc tr_getattr; setattrfunc tr_setattr; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> newfunc tp_new; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p>  <code>tp_new()</code> membuat tabel hash untuk kelas pengguna, sama seperti untuk tipe <code>dict</code> .  <code>tp_getattr()</code> mengekstrak sesuatu dari tabel hash ini, dan <code>tp_setattr()</code> , sebaliknya, meletakkan sesuatu di sana.  Dengan demikian, kemampuan kelas arbitrer untuk menyimpan metode dan atribut apa pun disediakan tidak pada tingkat struktur bahasa C, tetapi pada tingkat yang lebih tinggi - tabel hash.  (Tentu saja, dengan pengecualian beberapa kasus yang terkait dengan optimalisasi kinerja.) </p><br><h1>  Akses pengubah </h1><br><p>  Apa yang kita lakukan dengan semua aturan dan konsep yang dibangun di sekitar kata kunci C ++ yang <code>private</code> dan <code>protected</code> ?  Python, sebagai bahasa scripting, tidak membutuhkannya.  Kami sudah memiliki bagian "terlindungi" dari bahasa - ini adalah data tipe bawaan.  Dalam situasi apa pun, Python tidak mengizinkan program, misalnya, untuk memanipulasi bit angka floating-point!  Level enkapsulasi ini cukup untuk menjaga integritas bahasa itu sendiri.  Kami, pencipta Python, percaya bahwa integritas bahasa adalah satu-satunya alasan yang baik untuk menyembunyikan informasi.  Semua struktur dan data program pengguna lainnya dianggap publik. </p><br><p>  Anda dapat menulis garis bawah ( <code>_</code> ) di awal nama atribut kelas untuk memperingatkan kolega: Anda tidak harus bergantung pada atribut ini.  Tetapi sisa Python belajar pelajaran dari awal 90-an: kemudian banyak yang percaya bahwa alasan utama kami menulis program kembung, tidak dapat dibaca, dan buggy adalah kurangnya variabel pribadi.  Saya pikir 20 tahun ke depan telah meyakinkan semua orang di industri pemrograman: variabel pribadi bukan satu-satunya, dan jauh dari obat yang paling efektif untuk program kembung dan buggy.  Oleh karena itu, pembuat Python memutuskan untuk tidak khawatir tentang variabel pribadi, dan, seperti yang Anda lihat, mereka tidak gagal. </p><br><h1>  Manajemen memori </h1><br><p>  Apa yang terjadi pada objek, angka, dan string kita di tingkat yang lebih rendah?  Bagaimana tepatnya mereka disimpan dalam memori, bagaimana CPython menyediakan akses bersama kepada mereka, kapan dan dalam kondisi apa mereka dihancurkan? </p><br><p>  Dan dalam hal ini, kami memilih cara yang paling umum, dapat diprediksi dan produktif untuk bekerja dengan memori: dari sisi program-C, semua objek kami adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pointer bersama</a> . </p><br><p>  Dengan pengetahuan ini dalam pikiran, struktur data yang kami periksa sebelumnya di bagian "Variabel dan tipe data" harus dilengkapi sebagai berikut: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> Py_ssize_t ob_refcnt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeobject</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ob_type</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* followed by object's data */</span></span> } }</code> </pre> <br><p>  Jadi, setiap objek dalam Python (maksud kami implementasi CPython, tentu saja) memiliki counter referensi sendiri.  Setelah menjadi nol, objek dapat dihapus. </p><br><p>  Mekanisme penghitungan tautan tidak bergantung pada perhitungan tambahan atau proses latar belakang - suatu objek dapat dihancurkan secara instan.  Selain itu, ia menyediakan lokalitas data tinggi: seringkali, memori mulai digunakan kembali segera setelah dibebaskan.  Objek yang baru saja hancur kemungkinan besar digunakan baru-baru ini, yang berarti berada di cache prosesor.  Oleh karena itu, objek yang baru dibuat akan tetap berada di cache.  Dua faktor ini - kesederhanaan dan lokalitas - menjadikan penghitungan tautan cara pengumpulan sampah yang sangat produktif. </p><br><p>  (Karena kenyataan bahwa objek dalam program nyata sering merujuk satu sama lain, penghitung referensi dalam kasus tertentu tidak dapat turun ke nol bahkan ketika objek tidak lagi digunakan dalam program. Oleh karena itu, CPython juga memiliki mekanisme pengumpulan sampah kedua - latar belakang, berdasarkan pada generasi objek. - <em>kira</em> - <em>kira terjemahan.</em> ) </p><br><h1>  Kesalahan pengembang python </h1><br><p>  Kami mencoba mengembangkan bahasa yang cukup sederhana untuk pemula, tetapi juga cukup menarik bagi para profesional.  Pada saat yang sama, kami tidak dapat menghindari kesalahan dalam memahami dan menggunakan alat yang kami buat sendiri. </p><br><p>  Python 2, karena inersia pemikiran yang terkait dengan bahasa scripting, mencoba mengkonversi tipe string, seperti yang dilakukan oleh bahasa dengan pengetikan yang lemah.  Jika Anda mencoba menggabungkan string byte dengan string di Unicode, interpreter secara implisit mengubah string byte ke Unicode menggunakan tabel kode yang tersedia pada sistem dan menyajikan hasilnya dalam Unicode: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-string"><span class="hljs-string">'byte string '</span></span> + <span class="hljs-string"><span class="hljs-string">u'unicode string'</span></span> <span class="hljs-string"><span class="hljs-string">u'byte string unicode string'</span></span></code> </pre> <br><p>  Akibatnya, beberapa situs web berfungsi dengan baik ketika pengguna mereka menggunakan bahasa Inggris, tetapi mereka menghasilkan kesalahan samar ketika menggunakan karakter dari huruf lain. </p><br><p>  Bug desain bahasa ini telah diperbaiki dalam Python 3: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-string"><span class="hljs-string">b'byte string '</span></span> + <span class="hljs-string"><span class="hljs-string">u'unicode string'</span></span> TypeError: can<span class="hljs-string"><span class="hljs-string">'t concat bytes to str</span></span></code> </pre> <br><p>  Kesalahan serupa di Python 2 terkait dengan penyortiran daftar "naif" yang terdiri dari elemen-elemen yang tak tertandingi: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>sorted([<span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]) [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>]</code> </pre> <br><p>  Python 3 dalam hal ini menjelaskan kepada pengguna bahwa ia mencoba melakukan sesuatu yang tidak terlalu berarti: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>sorted([<span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]) TypeError: unorderable types: int() &lt; str()</code> </pre> <br><h1>  Kekerasan </h1><br><p>  Pengguna sekarang dan kemudian kadang-kadang menyalahgunakan sifat dinamis dari bahasa Python, dan kemudian, di tahun 90-an, ketika praktik terbaik belum dikenal secara luas, ini sering terjadi: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Address</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, host, port)</span></span></span><span class="hljs-function">:</span></span> self.host = host self.port = port</code> </pre> <br><p>  "Tapi ini tidak optimal!"  - Beberapa mengatakan, - â€œBagaimana jika port tidak berbeda dari nilai default?  Bagaimanapun, kami menghabiskan seluruh atribut kelas pada penyimpanannya! â€  Dan hasilnya adalah sesuatu seperti </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Address</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, host, port=None)</span></span></span><span class="hljs-function">:</span></span> self.host = host <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> port <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-comment"><span class="hljs-comment"># so terrible self.port = port</span></span></code> </pre> <br><p>  Jadi, objek dengan tipe yang sama muncul dalam program, yang, bagaimanapun, tidak dapat dioperasikan secara seragam, karena beberapa dari mereka memiliki atribut tertentu, sementara yang lain tidak!  Dan kami tidak dapat menyentuh atribut ini tanpa memeriksa keberadaannya di muka: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># code was forced to use introspection # (terrible!) if hasattr(addr, 'port'): print(addr.port)</span></span></code> </pre> <br><p>  Saat ini, kelimpahan <code>hasattr()</code> , <code>isinstance()</code> dan introspeksi lainnya adalah tanda pasti dari kode yang buruk, dan itu dianggap praktik terbaik untuk membuat atribut selalu hadir dalam objek.  Ini memberikan sintaksis yang lebih sederhana ketika mengaksesnya: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># today's best practice: # every atribute always present if addr.port is not None: print(addr.port)</span></span></code> </pre> <br><p>  Jadi, percobaan awal dengan atribut yang ditambahkan dan dihapus secara dinamis berakhir, dan sekarang kita melihat kelas dalam Python dengan cara yang sama seperti di C ++. </p><br><p>  Kebiasaan buruk lain dari Python awal adalah penggunaan fungsi di mana argumen dapat memiliki tipe yang sama sekali berbeda.  Misalnya, Anda mungkin berpikir bahwa mungkin terlalu sulit bagi pengguna untuk membuat daftar nama kolom setiap kali, dan Anda harus mengizinkannya untuk meneruskannya juga sebagai satu baris, di mana nama-nama kolom terpisah dipisahkan oleh, katakanlah, koma: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dataframe</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, columns)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(columns, str): columns = columns.split(<span class="hljs-string"><span class="hljs-string">','</span></span>) self.columns = columns</code> </pre> <br><p>  Namun pendekatan ini dapat menimbulkan masalah.  Misalnya, bagaimana jika pengguna secara tidak sengaja memberi kami baris yang tidak dimaksudkan untuk digunakan sebagai daftar nama kolom?  Atau jika nama kolom harus mengandung koma? </p><br><p>  Selain itu, kode semacam itu lebih sulit untuk dipertahankan, didebug, dan terutama pengujian: dalam pengujian, dimungkinkan untuk memeriksa hanya satu dari dua jenis yang kami dukung, tetapi cakupannya masih 100%, dan kami tidak akan menguji jenis lainnya. </p><br><p>  Sebagai hasilnya, kami sampai pada kesimpulan bahwa Python memungkinkan pengguna untuk meneruskan argumen dari jenis apa pun ke fungsi, tetapi sebagian besar dari mereka dalam sebagian besar situasi akan menggunakan fungsi dengan cara yang sama seperti di C: meneruskan argumen dengan tipe yang sama dengannya. </p><br><p>  Kebutuhan untuk menggunakan <code>eval()</code> dalam suatu program dianggap salah perhitungan arsitektur eksplisit.  Kemungkinan besar, Anda tidak tahu bagaimana melakukan hal yang sama dengan cara normal.     âˆ’ ,      Jupyter notebook  -       âˆ’  <code>eval()</code>  ,      Python   ! ,     C++    . </p><br><p>     ,  ( <code>getattr()</code> , <code>hasattr()</code> , <code>isinstance()</code> )          .   ,   ,   ,      ,       : , ,  , ! </p><br><h1>   </h1><br><p>      :     ,           . 20             ,   C++  Python.   ,     ,    .         . </p><br><p>        ,    <code>shared_ptr</code>  TensorFlow   2016  2018 . </p><br><p> TensorFlow âˆ’       C++-,         Python- ( C++ âˆ’     TensorFlow, ). </p><br><p><img src="https://habrastorage.org/webt/dm/1g/zo/dm1gzovjtl2qbda7muz5wjzzjhq.png" alt="gambar"></p><br><p>         TensorFlow,  <code>shared_ptr</code> ,     .     ,     . </p><br><p>      C++?       .    ,   ?     ,     ,  C++  Python! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464405/">https://habr.com/ru/post/id464405/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464391/index.html">10 laporan menarik dari konferensi peretas</a></li>
<li><a href="../id464393/index.html">Bagaimana menemukan kursus pemrograman dan apa saja jaminan pekerjaan</a></li>
<li><a href="../id464395/index.html">Blockchain RSA berbasis acak</a></li>
<li><a href="../id464399/index.html">Pengikisan web di R, Bagian 2. Mempercepat proses dengan komputasi paralel dan menggunakan paket Rcrawler</a></li>
<li><a href="../id464403/index.html">Cara menjalankan proyek java pada shell runner saat mendorong ke repositori GitLab</a></li>
<li><a href="../id464407/index.html">Cara kerja sistem pengawasan video terbesar di dunia</a></li>
<li><a href="../id464409/index.html">Bagaimana Politik Abad 19 Mempengaruhi Lokasi Pusat Data Hari Ini</a></li>
<li><a href="../id464411/index.html">PVS-Studio: Mesin Kemajuan</a></li>
<li><a href="../id464413/index.html">PVS-Studio - mesin kemajuan</a></li>
<li><a href="../id464415/index.html">Layanan petunjuk baru untuk mencari hh.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>