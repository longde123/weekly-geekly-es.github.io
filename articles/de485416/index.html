<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍⚕️ 💨 👩🏻‍🤝‍👨🏾 Praktische Möglichkeiten zum Kartieren von Daten in Kotlin 👩🏽‍⚕️ ⛵️ 🍁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Datenzuordnung ist eine Möglichkeit, Anwendungscode in Ebenen zu unterteilen. Mapping ist in Android-Anwendungen weit verbreitet. Ein beliebtes Be...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Praktische Möglichkeiten zum Kartieren von Daten in Kotlin</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485416/"><p>  Die Datenzuordnung ist eine Möglichkeit, Anwendungscode in Ebenen zu unterteilen.  Mapping ist in Android-Anwendungen weit verbreitet.  Ein beliebtes Beispiel für die Architektur der mobilen Anwendung Android-CleanArchitecture verwendet das Mapping sowohl in der <a href="https://github.com/android10/Android-CleanArchitecture">Originalversion</a> ( <a href="">ein Beispiel für einen Mapper von CleanArchitecture</a> ) als auch in der neuen <a href="https://github.com/android10/Android-CleanArchitecture-Kotlin">Kotlin-Version</a> ( <a href="">ein Beispiel für einen Mapper</a> ). </p><br><p>  Mit der Zuordnung können Sie die Ebenen der Anwendung lösen (z. B. die API entfernen), den Code vereinfachen und visueller gestalten. </p><br><p>  Ein Beispiel für eine nützliche Zuordnung ist im Diagramm dargestellt: </p><br><p><img src="https://habrastorage.org/webt/pf/9e/ew/pf9eewmfjrsylnl1sggjcnermwa.png"></p><a name="habracut"></a><br><p> Es müssen nicht alle Felder des <code>Person</code> werden, wenn wir in dem Teil der Anwendung, der uns interessiert, nur zwei Felder benötigen: <code>login</code> und <code>password</code> .  Wenn es für uns bequemer ist, <code>Person</code> als Anwendungsbenutzer zu betrachten, können wir nach der Zuordnung problemlos ein Modell mit einem Namen verwenden, den wir verstehen. </p><br><p>  Lassen Sie uns anhand des Beispiels der Konvertierung von zwei <code>Person</code> und <code>Salary</code> von der <code>Source</code> in die <code>Destination</code> bequeme und praktische Methoden für die <code>Destination</code> . </p><br><p><img src="https://habrastorage.org/webt/ku/j5/0j/kuj50jhepd2ovlimkbldp0c1ptk.png"></p><br><p>  Zum Beispiel werden die Modelle vereinfacht.  <code>Person</code> enthält <code>Salary</code> in beiden Schichten der Anwendung. </p><br><p>  Wenn Sie in diesem Code dasselbe Modell verwenden, empfiehlt es sich möglicherweise, die Ebenen der Anwendung zu überarbeiten und keine Zuordnung zu verwenden. </p><br><h1 id="metod-1-metody-mappery">  Methode 1: Mapper-Methoden </h1><br><p>  Ein Beispiel: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonSrc</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> salary: SalarySrc ) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mapToDestination</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = PersonDst( name, salary.mapToDestination() <span class="hljs-comment"><span class="hljs-comment">//    Salary ) } class SalarySrc( private val amount: Int ) { fun mapToDestination() = SalaryDst(amount) }</span></span></code> </pre> <br><p>  Die schnellste und einfachste Methode.  Er wird in CleanArchitecture Kotlin verwendet ( <a href="">ein Beispiel für die Zuordnung</a> ). </p><br><p>  Ein Plus ist die Möglichkeit, Felder auszublenden.  Felder in <code>PersonSrc</code> können <code>private</code> . Der Code, der die <code>PersonSrc</code> Klasse verwendet, ist von diesen unabhängig. <code>PersonSrc</code> bedeutet, dass die <code>PersonSrc</code> verringert ist. </p><br><p>  Solcher Code ist schneller zu schreiben und einfacher zu ändern - Felddeklarationen und ihre Verwendung sind an einem Ort.  Es ist nicht erforderlich, das Projekt zu durchlaufen und verschiedene Dateien zu ändern, wenn Klassenfelder geändert werden. </p><br><p>  Diese Option ist jedoch schwieriger zu testen.  Die Mapper-Methode der PersonSrc-Klasse <code>PersonSrc</code> Aufruf der Mapper-Methode <code>SalarySrc</code> .  Daher ist es schwieriger, nur die Zuordnung von <code>Person</code> ohne <code>Salary</code> testen.  Sie müssen dafür Moki verwenden. </p><br><p>  Ein weiteres Problem kann auftreten, wenn gemäß den Anforderungen der Architektur die Anwendungsschichten nicht voneinander wissen können: d.h.  In der <code>Src</code> Klasse einer Ebene können Sie nicht mit einer <code>Dst</code> Ebene arbeiten und umgekehrt.  In diesem Fall kann diese Mapping-Version nicht verwendet werden. </p><br><p>  In dem betrachteten Beispiel ist die <code>Src</code> Schicht von der <code>Dst</code> Schicht abhängig und kann Klassen dieser Schicht erstellen.  Für die umgekehrte Situation (wenn <code>Dst</code> von <code>Src</code> abhängig ist) ist die Option mit statischen Factory-Methoden geeignet: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonDst</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> salary: SalaryDst ) { <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( src: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">PersonSrc</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span> = PersonDst(src.name, SalaryDst.fromSource(src.salary)) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SalaryDst</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> amount: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">SalarySrc</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = SalaryDst(src.amount) } }</code> </pre> <br><p>  Die Zuordnung erfolgt innerhalb der Klassen des <code>Dst</code> Layers. Dies bedeutet, dass diese Klassen dem Code, der sie verwendet, nicht alle ihre Eigenschaften und Strukturen offenbaren. </p><br><p>  Wenn in der Anwendung eine Ebene von der anderen abhängig ist und Daten in beide Richtungen zwischen den Anwendungsebenen übertragen werden, ist es logisch, statische Factory-Methoden zusammen mit Mapper-Methoden zu verwenden. </p><br><p>  Zusammenfassung der Zuordnungsmethode: </p><br><p>  <code>+</code> Schreiben Sie schnell Code, Mapping ist immer zur Hand <br>  <code>+</code> Einfache Änderung <br>  <code>+</code> Niedrige Code-Konnektivität <br>  <code>-</code> Schwierige Unit-Tests (Moki benötigt) <br>  <code>-</code> Nicht immer von der Architektur erlaubt </p><br><h1 id="metod-2-funkcii-mappery">  Methode 2: Mapper-Funktionen </h1><br><p>  Modelle: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonSrc</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> salary: SalarySrc ) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SalarySrc</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> amount: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonDst</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> salary: SalaryDst ) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SalaryDst</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> amount: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>)</code> </pre> <br><p>  Mapper: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mapPerson</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( src: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">PersonSrc</span></span></span></span><span class="hljs-function"><span class="hljs-params">, salaryMapper: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">SalarySrc</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; SalaryDst = ::mapSalary <span class="hljs-comment"><span class="hljs-comment">//  - ) = PersonDst( src.name, salaryMapper.invoke(src.salary) ) fun mapSalary(src: SalarySrc) = SalaryDst(src.amount)</span></span></code> </pre> <br><p>  In diesem Beispiel ist <code>mapPerson</code> eine Funktion höherer Ordnung als  Sie bekommt den Mapper für das <code>Salary</code> .  Ein interessantes Merkmal des spezifischen Beispiels ist das Standardargument für diese Funktion.  Dieser Ansatz ermöglicht es uns, den aufrufenden Code zu vereinfachen und gleichzeitig den Mapper in Komponententests einfach neu zu definieren.  Sie können diese Zuordnungsmethode ohne die Standardmethode verwenden und sie immer im aufrufenden Code übergeben. </p><br><p>  Es ist nicht immer praktisch, den Mapper und die Klassen, mit denen er arbeitet, an verschiedenen Stellen des Projekts zu platzieren.  Bei häufigen Änderungen der Klasse müssen Sie verschiedene Dateien an verschiedenen Orten suchen und ändern. </p><br><p>  Diese Zuordnungsmethode erfordert, dass alle Eigenschaften mit Klassendaten für den Mapper sichtbar sind, d. H.  <code>private</code> Visibility kann für sie nicht verwendet werden. </p><br><p>  Zusammenfassung der Zuordnungsmethode: </p><br><p>  <code>+</code> Einfaches Testen von Einheiten <br>  <code>-</code> Schwierige Änderung <br>  <code>-</code> Erfordert offene Felder für Datenklassen </p><br><h1 id="metod--3-funkcii-rasshireniya">  Methode 3: Erweiterungsfunktionen </h1><br><p>  Mapper: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> PersonSrc.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toDestination</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( salaryMapper: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">SalarySrc</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; SalaryDst = SalarySrc::toDestination ): PersonDst { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PersonDst(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name, salaryMapper.invoke(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.salary)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> SalarySrc.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toDestination</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: SalaryDst { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SalaryDst(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.amount) }</code> </pre> <br><p>  Im Allgemeinen identisch mit den Mapper-Funktionen, aber die Syntax des Mapper-Aufrufs ist einfacher: <code>.toDestination()</code> . </p><br><p>  Es ist zu beachten, dass Erweiterungsfunktionen aufgrund ihrer statischen Natur zu unerwartetem Verhalten führen können: <a href="https://kotlinlang.org/docs/reference/extensions.html">https://kotlinlang.org/docs/reference/extensions.html#extensions-are-resolved-stratic</a> </p><br><p>  Zusammenfassung der Zuordnungsmethode: </p><br><p>  <code>+</code> Einfaches Testen von Einheiten <br>  <code>-</code> Schwierige Änderung <br>  <code>-</code> Erfordert offene Felder für Datenklassen </p><br><h1 id="metod-4-klassy-mappery-s-interfeysom">  Methode 4: Mapper-Klassen mit einer Schnittstelle </h1><br><p>  Funktionsbeispiele haben einen Nachteil.  Mit ihnen können Sie jede Funktion mit einer Signatur <code>(SalarySrc) -&gt; SalaryDst</code> .  Durch das Vorhandensein der <code>Mapper&lt;SRC, DST&gt;</code> Schnittstelle <code>Mapper&lt;SRC, DST&gt;</code> wird der Code deutlicher. </p><br><p>  Ein Beispiel: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mapper</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SRC, DST</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">data</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">SRC</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: DST } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonMapper</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> salaryMapper: Mapper&lt;SalarySrc, SalaryDst&gt; ) : Mapper&lt;PersonSrc, PersonDst&gt; { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">PersonSrc</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = PersonDst( src.name, salaryMapper.transform(src.salary) ) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SalaryMapper</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Mapper</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SalarySrc, SalaryDst</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">SalarrSrc</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = SalaryDst( src.amount ) }</code> </pre> <br><p>  In diesem Beispiel ist <code>SalaryMapper</code> eine <code>PersonMapper</code> Abhängigkeit.  Auf diese Weise können Sie den <code>Salary</code> Mapper bei Unit-Tests bequem austauschen. </p><br><p>  In Bezug auf die Zuordnung in der Funktion weist dieses Beispiel nur einen Nachteil auf - die Notwendigkeit, etwas mehr Code zu schreiben. </p><br><p>  Zusammenfassung der Zuordnungsmethode: </p><br><p>  <code>+</code> Besser tippen <br>  <code>-</code> Mehr Code </p><br><p>  Wie die Mapper-Funktionen: </p><br><p>  <code>+</code> Einfaches Testen von Einheiten <br>  <code>-</code> Schwierige Änderung <br>  <code>-</code> erfordert offene Felder für Datenklassen </p><br><h1 id="metod-5-refleksiya">  Methode 5: Reflexion </h1><br><p>  Die Methode der schwarzen Magie.  Betrachten Sie diese Methode bei anderen Modellen. </p><br><p>  Modelle: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EmployeeSrc</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> age: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> <span class="hljs-comment"><span class="hljs-comment">//    ) data class EmployeeDst( val name: String, //  ,    val age: Int //    )</span></span></code> </pre> <br><p>  Mapper: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> EmployeeSrc.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mapWithRef</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = with(::EmployeeDst) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> propertiesByName = EmployeeSrc::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">memberProperties</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">associateBy</span></span></span><span class="hljs-class"> </span></span>{ it.name } callBy(parameters.associateWith { parameter -&gt; <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (parameter.name) { EmployeeDst::name.name -&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$firstName</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$lastName</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-comment"><span class="hljs-comment">//    name else -&gt; propertiesByName[parameter.name]?.get(this@mapWithRef) //     } }) }</span></span></code> </pre> <br><p>  Ein Beispiel wird <a href="https://www.baeldung.com/kotlin-data-objects">hier</a> ausspioniert. </p><br><p>  In diesem Beispiel speichern <code>EmployeeSrc</code> und <code>EmployeeDst</code> den Namen in verschiedenen Formaten.  Mapper muss lediglich einen Namen für das neue Modell vergeben.  Die restlichen Felder werden automatisch verarbeitet, ohne Code zu schreiben (die Option <code>else</code> ist <code>when</code> ). </p><br><p>  Die Methode kann beispielsweise nützlich sein, wenn Sie große Modelle mit einer Reihe von Feldern haben und die Felder im Grunde genommen für dieselben Modelle aus verschiedenen Ebenen übereinstimmen. </p><br><p>  Ein großes Problem entsteht zum Beispiel, wenn Sie die erforderlichen Felder zu Dst hinzufügen und es nicht zufällig in <code>Src</code> oder im Mapper gibt: eine <code>IllegalArgumentException</code> in der Laufzeit.  Reflexion hat auch Leistungsprobleme. </p><br><p>  Zusammenfassung der Zuordnungsmethode: </p><br><p>  <code>+</code> weniger Code <br>  <code>+</code> einfacher Unit-Test <br>  <code>-</code> gefährlich <br>  <code>-</code> kann die Leistung beeinträchtigen </p><br><h1 id="vyvody">  Schlussfolgerungen </h1><br><p>  Solche Schlussfolgerungen können aus unserer Überlegung gezogen werden: </p><br><p>  <strong>Mapper-Methoden</strong> - klarer Code, schneller zu schreiben und zu warten </p><br><p>  <strong>Mapper-</strong> <strong>Funktionen</strong> und <strong>Erweiterungsfunktionen</strong> - testen Sie einfach das Mapping. </p><br><p>  <strong>Mapper-Klassen mit Schnittstelle</strong> - testen Sie einfach das Mapping und den klareren Code. </p><br><p>  <strong>Reflexion</strong> - geeignet für Nicht-Standard-Situationen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de485416/">https://habr.com/ru/post/de485416/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de485392/index.html">Telegramm-Bot, der die Domain überwacht</a></li>
<li><a href="../de485394/index.html">Wie die Internetinfrastruktur entstand</a></li>
<li><a href="../de485396/index.html">Squad Health Check: Messung der Team-Gesundheit</a></li>
<li><a href="../de485398/index.html">PostgreSQL Antipatterns: Hit Dictionary auf Heavy JOIN</a></li>
<li><a href="../de485404/index.html">Wir realisieren den visuellen Effekt aus dem Film "The Matrix"</a></li>
<li><a href="../de485418/index.html">PHPUnit. "Wie teste ich meinen verdammten Controller?"</a></li>
<li><a href="../de485424/index.html">Wie ich Kindern Python beibringe</a></li>
<li><a href="../de485426/index.html">Autos in den Niederlanden: Statistiken und Informationen für 2019</a></li>
<li><a href="../de485428/index.html">Das mysteriöse LyX-Programm. Teil 5</a></li>
<li><a href="../de485430/index.html">Einfacher Mehrbenutzer-Texteditor mit End-to-End-Verschlüsselung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>