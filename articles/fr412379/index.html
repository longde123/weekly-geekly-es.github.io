<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òùüèº üõ∑ ‚öóÔ∏è Conception du processeur ModelSim üé¨ üë®üèæ‚Äçüöí üöÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Partie I 
 Partie II 
 Partie III 
 Partie IV 
 Partie V 

 Il s'agit de la version compl√®te de l'article pr√©c√©dent, √† laquelle des bancs d'essai ont ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Conception du processeur ModelSim</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412379/"><img align="right" src="https://habrastorage.org/webt/wc/de/un/wcdeunlviebjlcovj8ch7-tyu88.jpeg"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie I</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie II</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie III</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie IV</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie V</a> <br><br>  Il s'agit de la version compl√®te de l'article pr√©c√©dent, √† laquelle des bancs d'essai ont √©t√© ajout√©s. <br><br>  Nous concevons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Little Man Computer</a> dans Verilog. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">L'article</a> sur LMC √©tait sur Habr√©. <br><br>  Le simulateur en ligne de cet ordinateur est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  √âcrivons un module RAM, compos√© de quatre (ADDR_WIDTH = 2) mots de quatre bits (DATA_WIDTH = 4).  Les donn√©es sont charg√©es dans la RAM √† partir de data_in √† adr lorsque le signal d'horloge clk arrive. <br><br><pre><code class="plaintext hljs">module R0 #(parameter ADDR_WIDTH = 2, DATA_WIDTH = 4) ( input clk, //  input [ADDR_WIDTH-1:0] adr, // input [DATA_WIDTH-1:0] data_in, //   output [DATA_WIDTH-1:0] RAM_out //   ); reg [DATA_WIDTH-1:0] mem [2**ADDR_WIDTH-1:0]; //  mem always @(posedge clk) //    clk mem [adr] &lt;= data_in; //     data_in assign RAM_out = mem[adr]; // RAM_out    endmodule</code> </pre> <a name="habracut"></a><br>  Dans le banc d'essai, charge 0001 √† 00, 0010 √† 01, 0100 √† 10, 1000 √† 11: <br><div class="spoiler">  <b class="spoiler_title">Cr√©er un banc d'essai</b> <div class="spoiler_text">  Cr√©ez un nouveau projet, cr√©ez les fichiers R0.v et tR0.v (ces fichiers seront automatiquement ajout√©s au projet). <br>  Compilez les deux fichiers. <br>  Ex√©cuter la simulation du fichier compil√© tR0.v <br></div></div><br><pre> <code class="plaintext hljs">module tR0; reg clk; reg [1:0] adr; reg [3:0] data_in; wire [3:0] RAM_out; R0 test_R0 (clk, adr, data_in,RAM_out); initial begin clk = 0; adr[0] = 0; adr[1] = 0; data_in[0] = 0; data_in[1] = 0; data_in[2] = 0; data_in[3] = 0; #5 data_in[0] = 1; #5 clk = 1; #5 adr[0] = 1; data_in[0] = 0; data_in[1] = 1; clk = 0; #5 clk = 1; #5 adr[0] = 0; adr[1] = 1; data_in[1] = 0; data_in[2] = 1; clk = 0; #5 clk = 1; #5 adr[0] = 1; adr[1] = 1; data_in[2] = 0; data_in[3] = 1; clk = 0; #5 clk = 1; #5 adr[0] = 0; adr[1] = 0; data_in[3] = 0; clk = 0; #5 adr[0] = 1; adr[1] = 0; #5 adr[0] = 0; adr[1] = 1; #5 adr[0] = 1; adr[1] = 1; #5 adr[0] = 0; adr[1] = 0; #5 adr[0] = 1; adr[1] = 0; #5 adr[0] = 0; adr[1] = 1; #5 adr[0] = 1; adr[1] = 1; #5 adr[0] = 0; adr[1] = 0; #5 adr[0] = 1; adr[1] = 0; #5 adr[0] = 0; adr[1] = 1; #5 adr[0] = 1; adr[1] = 1; end endmodule</code> </pre><br><img src="https://habrastorage.org/webt/dn/gr/ty/dngrtyzyzto7g0fnxh6l2emzpyg.gif"><br><br>  Nous connectons le compteur √† l'entr√©e d'adresse de la RAM.  Il est n√©cessaire de connecter un g√©n√©rateur d'horloge √† l'entr√©e du compteur. <br><br>  Voici un exemple de programme utilisant le g√©n√©rateur interne ALTUFM_OSC.  Fr√©quence d'un g√©n√©rateur standard 5,5 MHz (MAX II EPM240 CPLD Minimal Development Board). <br><br><pre> <code class="plaintext hljs">module inner_Clock ( output reg LED); ALTUFM_OSC osc( .oscena(1'b1), .osc(clk)); reg signal; reg [24:0] osc_counter; reg [24:0] const_data = 25'b10110111000110110000000; initial begin signal = 1'b0; osc_counter = 25'b0; end //  6 000 000    osc_counter always @(posedge clk) begin osc_counter &lt;= osc_counter+ 1'b1; if(osc_counter == const_data) begin signal &lt;= ~signal; osc_counter &lt;= 25'b0; end LED = signal; // LED  ~1   . end endmodule</code> </pre><br>  Vous pouvez √©galement utiliser un g√©n√©rateur externe, comme une minuterie CMOS 555 (aliment√©e par 3,3 V).  Nous connectons la minuterie 555 au compteur, connectons le compteur √† l'entr√©e d'adresse de la RAM. <br><br>  T.O.  lorsqu'un signal d'horloge arrive au compteur, nous allons passer √† la cellule suivante en m√©moire.  Nous connecterons le bouton RAM_button √† l'entr√©e d'horloge RAM - les donn√©es dans la RAM seront charg√©es lorsque ce bouton sera cliqu√©. <br><br><pre> <code class="plaintext hljs">module R1 (timer555, RAM_button, data_in, RAM_out, counter); parameter ADDR_WIDTH = 2; parameter DATA_WIDTH = 4; input timer555; input RAM_button; //input [ADDR_WIDTH-1:0] adr; input [DATA_WIDTH-1:0] data_in; output [DATA_WIDTH-1:0] RAM_out; output reg [1:0] counter; // Counter always @(posedge timer555) counter &lt;= counter + 1; // RAM wire [ADDR_WIDTH-1:0] adr; assign adr = counter; reg [DATA_WIDTH-1:0] mem [2**ADDR_WIDTH-1:0]; always @(posedge RAM_button) mem [adr] &lt;= data_in; assign RAM_out = mem[adr]; endmodule</code> </pre><br>  Voici comment le circuit dans RTL Viewer <br><br><img src="https://habrastorage.org/webt/ti/nb/fh/tinbfhfwohrryqhapu_j53qcbr4.gif"><br><br>  Dans le simulateur ModelSim, ce sch√©ma ne fonctionnera pas, car le simulateur ne conna√Æt pas la valeur initiale des registres du compteur [1: 0]. <br>  Le fonctionnement du circuit peut √™tre v√©rifi√© en t√©l√©chargeant directement le programme sur le FPGA. <br><br>  Ensuite, ajoutez la fonction de t√©l√©chargement au compteur.  T√©l√©chargez depuis data_in [1: 0] en cliquant sur le bouton Counter_load <br><br><pre> <code class="plaintext hljs">module R2 (counter, timer555, Counter_load, RAM_button, data_in, RAM_out); parameter ADDR_WIDTH = 2; parameter DATA_WIDTH = 4; output [1:0] counter; input timer555, Counter_load; // input [N-1:0] adr; input RAM_button; input [DATA_WIDTH-1:0] data_in; output [DATA_WIDTH-1:0] RAM_out; // Counter reg [1:0] counter; always @ (posedge timer555 or posedge Counter_load) if (Counter_load) counter &lt;= data_in[1:0]; else counter &lt;= counter + 2'b01; // RAM wire [ADDR_WIDTH-1:0] adr; assign adr = counter; reg [DATA_WIDTH-1:0] mem [2**ADDR_WIDTH-1:0]; always @(posedge RAM_button) mem [adr] &lt;= data_in; assign RAM_out = mem[adr]; endmodule</code> </pre><br>  Voici √† quoi ressemble la connexion des boutons et des LED dans Pin Planner: <br><br><img src="https://habrastorage.org/webt/wx/bp/4e/wxbp4e5g4akkoq-fa1oryd61cni.gif"><br><br>  T√©l√©charger 0001 √† 00, 0010 √† 01, 0100 √† 10, 1000 √† 11 <br><br><pre> <code class="plaintext hljs">module tR2; parameter ADDR_WIDTH = 2; parameter DATA_WIDTH = 4; reg timer555, Counter_load, RAM_button; wire [1:0] counter; reg [DATA_WIDTH-1:0] data_in; wire [DATA_WIDTH-1:0] RAM_out; R2 test_R2(counter, timer555, Counter_load, RAM_button, data_in, RAM_out); initial // Clock generator begin timer555 = 0; forever #20 timer555 = ~timer555; end initial begin data_in[0] = 0; data_in[1] = 0; data_in[2] = 0; data_in[3] = 0; Counter_load = 0; RAM_button = 0; #5 data_in[0]=0; data_in[1]=0; Counter_load=1; RAM_button=0; #5 data_in[0]=1; data_in[1]=0; Counter_load=0; RAM_button=1; #5 data_in[0]=0; data_in[1]=0; Counter_load=0; RAM_button=0; #5 data_in[0]=1; data_in[1]=0; Counter_load=1; RAM_button=0; #5 data_in[0]=0; data_in[1]=1; Counter_load=0; RAM_button=1; #5 data_in[0]=0; data_in[1]=0; Counter_load=0; RAM_button=0; #5 data_in[0]=0; data_in[1]=1; Counter_load=1; RAM_button=0; #5 data_in[2]=1; data_in[0]=0; data_in[1]=0; Counter_load=0; RAM_button=1; #5 data_in[2]=0; data_in[0]=0; data_in[1]=0; Counter_load=0; RAM_button=0; #5 data_in[0]=1; data_in[1]=1; Counter_load=1; RAM_button=0; #5 data_in[3]=1; data_in[0]=0; data_in[1]=0; Counter_load=0; RAM_button=1; #5 data_in[3]=0; data_in[0]=0; data_in[1]=0; Counter_load=0; RAM_button=0; end endmodule</code> </pre><br><img src="https://habrastorage.org/webt/iq/6b/oz/iq6bozzaypik1sleuf4cgdl3pfg.gif"><br><br>  Dans un module s√©par√©, cr√©ez un registre 4bit'ny (batterie). <br><br>  Les donn√©es sont charg√©es dans le registre lorsque vous cliquez sur le bouton reg_button: <br><br><pre> <code class="plaintext hljs">module register4 ( input [3:0] reg_data, input reg_button, output reg [3:0] q ); always @(posedge reg_button) q &lt;= reg_data; endmodule</code> </pre><br>  Ajoutez l'accumulateur Acc, le multiplexeur MUX2 et l'additionneur de somme au circuit g√©n√©ral. <br>  L'additionneur ajoute au nombre dans les num√©ros d'accumulateur de la batterie de la m√©moire. <br>  Les entr√©es de signal du multiplexeur re√ßoivent les nombres data_in et sum. <br>  Le num√©ro de MUX2 est charg√© dans la batterie Acc en appuyant sur le bouton Acc_button. <br>  Le num√©ro de Ass est charg√© dans la RAM lorsque le bouton RAM_button est enfonc√©. <br><br><img src="https://habrastorage.org/webt/bd/hm/jb/bdhmjbihshxszwhzvi_3mqqvpus.gif"><br><br><img src="https://habrastorage.org/webt/jb/ks/k0/jbksk0dkioookg7qeskuvpsu77a.gif"><br><br><pre> <code class="plaintext hljs">module R3 (MUX_switch, Acc_button, Acc, counter, timer555, Counter_load, RAM_button, data_in, RAM_out); parameter ADDR_WIDTH = 2; parameter DATA_WIDTH = 4; input MUX_switch; input Acc_button; output [3:0] Acc; input timer555, Counter_load; output [1:0] counter; // input [N-1:0] adr; input RAM_button; input [DATA_WIDTH-1:0] data_in; output [DATA_WIDTH-1:0] RAM_out; // Counter reg [1:0] counter; always @ (posedge timer555 or posedge Counter_load) if (Counter_load) counter &lt;= data_in[1:0]; else counter &lt;= counter + 2'b01; // RAM wire [ADDR_WIDTH-1:0] adr; assign adr = counter; reg [DATA_WIDTH-1:0] mem [2**ADDR_WIDTH-1:0]; always @(posedge RAM_button) mem [adr] &lt;= Acc; assign RAM_out = mem[adr]; // sum wire [3:0] sum; assign sum = Acc + RAM_out; // MUX2 reg [3:0] MUX2; always @* MUX2 = MUX_switch ? sum : data_in; //     Acc_button /* reg Acc_dff; always @(posedge Acc_button or negedge timer555) if (!timer555) Acc_dff &lt;= 1'b0; else Acc_dff &lt;= timer555; */ //Acc register4 Acc_reg( .reg_data(MUX2), //.reg_button(Acc_dff), .reg_button(Acc_button), .q(Acc) ); endmodule</code> </pre><br>  Pour la suppression de bavardage programmatique, vous pouvez utiliser le sch√©ma simple donn√© dans les commentaires <br><blockquote>  / * reg Acc_dff; <br>  toujours @ (posedge Acc_button ou negedge timer555) <br>  si (! timer555) <br>  Acc_dff &lt;= 1'b0; <br>  d'autre <br>  Acc_dff &lt;= timer555;  * / <br></blockquote><br>  Vous pouvez √©galement lire sur la suppression des bavardages des boutons dans les commentaires de l'article. <br><br>  Ensuite, nous ajouterons les nombres, par exemple, 2 et 3. <br><br>  1. Charger des num√©ros dans la RAM <br>  2. Zero the Ass <br>  3. Commutateur MUX2 <br>  4. T√©l√©chargez le premier num√©ro de RAM vers Ass <br>  5. Ajoutez le deuxi√®me nombre de RAM au nombre dans Ass <br>  6. T√©l√©chargez le montant sur la RAM <br><br><pre> <code class="plaintext hljs">module tR3; parameter ADDR_WIDTH = 2; parameter DATA_WIDTH = 4; reg MUX_switch; reg Acc_button; wire [3:0] Acc; reg timer555, Counter_load, RAM_button; wire [1:0] counter; reg [DATA_WIDTH-1:0] data_in; wire [DATA_WIDTH-1:0] RAM_out; R3 test_R3(MUX_switch, Acc_button, Acc, counter, timer555, Counter_load, RAM_button, data_in, RAM_out); initial begin timer555 = 0; forever #20 timer555 = ~timer555; end initial begin data_in[0] = 0; data_in[1] = 0; data_in[2] = 0; data_in[3] = 0; Counter_load = 0; Acc_button = 0; RAM_button = 0; MUX_switch = 0; #5 Counter_load = 1; #5 data_in[0]=0; data_in[1]=1; Counter_load = 0; #5 Acc_button = 1; #5 RAM_button = 1; #5 data_in[0]=0; data_in[1] = 0; Acc_button = 0; RAM_button = 0; #5 data_in[0]=1; data_in[1]=1; #15 Acc_button = 1; #5 RAM_button = 1; #5 Acc_button = 0; #5 data_in[0]=0; data_in[1] = 0; RAM_button = 0; #10 Acc_button = 1; #10 Acc_button = 0; #60 MUX_switch = 1; #10 Acc_button = 1; #10 Acc_button = 0; #30 Acc_button = 1; #10 Acc_button = 0; #30 RAM_button = 1; #10 RAM_button = 0; end endmodule</code> </pre><br><img src="https://habrastorage.org/webt/ax/gl/h1/axglh1txflcvc0xjlojb57zyh3u.gif"><br><br>  Ajoutez au module principal un √©l√©ment qui soustrait du nombre dans la batterie le nombre enregistr√© dans la m√©moire. <br><br><pre> <code class="plaintext hljs">wire [3:0] subtract; assign subract = Acc - RAM_out ;</code> </pre><br><br>  Nous rempla√ßons le multiplexeur √† deux entr√©es par le multiplexeur √† quatre entr√©es <br><pre> <code class="plaintext hljs">always @* MUX4 = MUX_switch[1] ? (MUX_switch[0] ? RAM_out : subtract) : (MUX_switch[0] ? sum : data_in);</code> </pre><br>  Nous connectons le p√©riph√©rique de sortie √† la batterie (registre 4bit'ny), nous connectons √©galement 2 drapeaux √† la batterie: <br><br>  1. Le drapeau "Zero" est un journal.  √âl√©ment 4 OU NON.  Le drapeau est lev√© si le contenu de Ass est nul. <br><br>  2. Le drapeau ¬´Num√©ro z√©ro ou positif¬ª est un journal.  l'√©l√©ment n'est PAS au niveau haut de la batterie √† quatre chiffres.  Le drapeau est lev√© si le contenu de Ass est sup√©rieur ou √©gal √† z√©ro. <br><br><pre> <code class="plaintext hljs">// "" output Z_flag; assign Z_flag = ~(|Acc); //    // "   " output PZ_flag; assign PZ_flag = ~Acc[3];</code> </pre><br><img src="https://habrastorage.org/webt/mx/mv/eu/mxmveuu6yw0mzsn86w6xakho5sy.gif"><br><br>  Ajouter trois √©quipes <br><br>  1. chargement du contenu de la batterie dans le p√©riph√©rique de sortie data_out <br>  2. chargement de l'adresse dans le compteur si le drapeau "z√©ro" est lev√© (JMP si Acc = 0) <br>  3. chargement de l'adresse dans le compteur si le drapeau "z√©ro ou un nombre positif" est lev√© (JMP si Acc&gt; = 0) <br><br><pre> <code class="plaintext hljs">module R4 (JMP,Z_JMP,PZ_JMP,Z_flag,PZ_flag,Output_button,data_out,MUX_switch,Acc_button,Acc,counter,timer555,RAM_button,data_in,RAM_out); parameter ADDR_WIDTH = 2; parameter DATA_WIDTH = 4; input JMP, Z_JMP, PZ_JMP; output Z_flag, PZ_flag; input Output_button; output [3:0] data_out; input [1:0] MUX_switch; input Acc_button; output [3:0] Acc; input timer555; output [1:0] counter; input RAM_button; input [DATA_WIDTH-1:0] data_in; output [DATA_WIDTH-1:0] RAM_out; // flags wire Z,PZ; assign Z = Z_flag &amp; Z_JMP; assign PZ = PZ_flag &amp; PZ_JMP; // Counter reg [1:0] counter; always @ (posedge timer555 or posedge JMP or posedge Z or posedge PZ) if (JMP|Z|PZ) counter &lt;= data_in[1:0]; else counter &lt;= counter + 2'b01; // RAM wire [ADDR_WIDTH-1:0] adr; assign adr = counter; reg [DATA_WIDTH-1:0] mem [2**ADDR_WIDTH-1:0]; always @(posedge RAM_button) mem [adr] &lt;= Acc; assign RAM_out = mem[adr]; // sum wire [3:0] sum; assign sum = Acc + RAM_out; //subtract wire [3:0] subtract; assign subtract = Acc - RAM_out; // MUX4 reg [3:0] MUX4; always @* MUX4 = MUX_switch[1] ? (MUX_switch[0] ? RAM_out : subtract) : (MUX_switch[0] ? sum : data_in); //Acc register4 Acc_reg( .reg_data(MUX4), .reg_button(Acc_button), .q(Acc) ); //data_out register4 Output_reg( .reg_data(Acc), .reg_button(Output_button), .q(data_out) ); assign Z_flag = ~(|Acc); assign PZ_flag = ~Acc[3]; endmodule</code> </pre><br><img src="https://habrastorage.org/webt/1-/o7/bg/1-o7bggvr_5vbojs9io1tlpsv4a.gif"><br><br>  1. Charger des num√©ros dans la RAM <br>  2. Zero the Ass <br>  3. Commutateur MUX2 <br>  4. Soustrayez le premier nombre (√©crit en RAM) de Ass <br>  5. Soustrayez le deuxi√®me nombre (√©crit en RAM) de Ass <br>  6. T√©l√©chargez le montant sur RAM et data_out <br><br><pre> <code class="plaintext hljs">module tR4; parameter ADDR_WIDTH = 2; parameter DATA_WIDTH = 4; reg JMP, Z_JMP, PZ_JMP; wire Z_flag, PZ_flag; reg Output_button; wire [3:0] data_out; reg [1:0] MUX_switch; reg Acc_button; wire [3:0] Acc; reg timer555, RAM_button; wire [1:0] counter; reg [DATA_WIDTH-1:0] data_in; wire [DATA_WIDTH-1:0] RAM_out; R4 test_R4 (JMP,Z_JMP,PZ_JMP,Z_flag,PZ_flag,Output_button,data_out,MUX_switch,Acc_button,Acc, counter,timer555,RAM_button,data_in,RAM_out); initial begin timer555 = 0; forever #20 timer555 = ~timer555; end initial begin data_in[0] = 0; data_in[1] = 0; data_in[2] = 0; data_in[3] = 0; JMP = 0; Z_JMP = 0; PZ_JMP = 0; Acc_button = 0; RAM_button = 0; Output_button = 0; MUX_switch[0] = 0; MUX_switch[1] = 0; #5 JMP = 1; #5 data_in[0]=0; data_in[1]=1; JMP = 0; #5 Acc_button = 1; #5 RAM_button = 1; #5 data_in[0]=0; data_in[1] = 0; Acc_button = 0; RAM_button = 0; #5 data_in[0]=1; data_in[1]=1; #15 Acc_button = 1; #5 RAM_button = 1; #5 Acc_button = 0; #5 data_in[0]=0; data_in[1] = 0; RAM_button = 0; #10 Acc_button = 1; #10 Acc_button = 0; #60 MUX_switch[1] = 1; #10 Acc_button = 1; #10 Acc_button = 0; #30 Acc_button = 1; #10 Acc_button = 0; #30 RAM_button = 1; Output_button = 1; #10 RAM_button = 0; Output_button = 0; end endmodule</code> </pre><br><img src="https://habrastorage.org/webt/jb/fq/c4/jbfqc45piovx4besdmw0pkxz_oa.gif"><br><br>  V√©rifiez que lorsqu'un nombre positif se trouve dans Ass, la transition Z_JMP ne se produit pas: <br><br><pre> <code class="plaintext hljs">module tR4_jmp; parameter ADDR_WIDTH = 2; parameter DATA_WIDTH = 4; reg JMP, Z_JMP, PZ_JMP; wire Z_flag, PZ_flag; reg Output_button; wire [3:0] data_out; reg [1:0] MUX_switch; reg Acc_button; wire [3:0] Acc; reg timer555, RAM_button; wire [1:0] counter; reg [DATA_WIDTH-1:0] data_in; wire [DATA_WIDTH-1:0] RAM_out; R4 test_R4 (JMP,Z_JMP,PZ_JMP,Z_flag,PZ_flag,Output_button,data_out,MUX_switch,Acc_button,Acc, counter,timer555,RAM_button,data_in,RAM_out); initial begin timer555 = 0; forever #20 timer555 = ~timer555; end initial begin data_in[0] = 0; data_in[1] = 0; data_in[2] = 0; data_in[3] = 0; JMP = 0; Z_JMP = 0; PZ_JMP = 0; Acc_button = 0; RAM_button = 0; Output_button = 0; MUX_switch[0] = 0; MUX_switch[1] = 0; #5 JMP = 1; #5 data_in[0]=0; data_in[1]=1; JMP = 0; #5 Acc_button = 1; #5 data_in[0]=1; data_in[1]=1; Acc_button = 1; #5 data_in[0]=1; data_in[1]=1; Acc_button = 0; #5 Z_JMP = 1; #5 PZ_JMP = 1; Z_JMP = 0; #5 PZ_JMP = 0; end endmodule</code> </pre><br><img src="https://habrastorage.org/webt/ij/l4/sg/ijl4sgivszbp5yahbkdipb-ngwk.gif"><br><br>  Mettez la commande de saut inconditionnel dans la RAM <br><br><img src="https://habrastorage.org/webt/j-/jc/lp/j-jclpg2nixlq2dkwu2klhsgog8.gif"><br><br>  Voir la conception <br><br><pre> <code class="plaintext hljs">//wire Counter_load; always @ (posedge timer555) if (Counter_load) counter &lt;= RAM_out[3:0]; else counter &lt;= counter + 2'b01;</code> </pre><br>  ModelSim ne fonctionnera pas, nous utiliserons donc la commande reset_count suppl√©mentaire, qui initialise le compteur, le r√©initialise, c'est-√†-dire <br><br><pre> <code class="plaintext hljs">module resCount (reset_count, counter, timer555, RAM_button, data_in, RAM_out); parameter ADDR_WIDTH = 4; parameter DATA_WIDTH = 8; input reset_count; output [ADDR_WIDTH-1:0] counter; input timer555; input RAM_button; input [DATA_WIDTH-1:0] data_in; output [DATA_WIDTH-1:0] RAM_out; wire Counter_load; assign Counter_load = RAM_out[7]; reg [ADDR_WIDTH-1:0] counter; always @ (posedge timer555 or posedge reset_count) if (reset_count) counter &lt;= 4'b0000; else if (Counter_load) counter &lt;= RAM_out[3:0]; else counter &lt;= counter + 4'b0001; wire [ADDR_WIDTH-1:0] adr; assign adr = counter; reg [DATA_WIDTH-1:0] mem [2**ADDR_WIDTH-1:0]; always @(posedge RAM_button) mem [adr] &lt;= data_in; assign RAM_out = mem[adr]; endmodule</code> </pre><br>  banc d'essai <br><br><pre> <code class="plaintext hljs">module tresCount; parameter ADDR_WIDTH = 4; parameter DATA_WIDTH = 8; reg reset_count; reg timer555, RAM_button; wire [ADDR_WIDTH-1:0] counter; reg [DATA_WIDTH-1:0] data_in; wire [DATA_WIDTH-1:0] RAM_out; resCount test_resCount(reset_count, counter, timer555, RAM_button, data_in, RAM_out); initial // Clock generator begin timer555 = 0; forever #20 timer555 = ~timer555; end initial begin data_in[0] = 0; data_in[1] = 0; data_in[2] = 0; data_in[3] = 0; data_in[4] = 0; data_in[5] = 0; data_in[6] = 0; data_in[7] = 0; RAM_button = 0; reset_count =1; #5 reset_count =0; #1500 data_in[7] =1; #5 RAM_button = 1; #5 data_in[7] =0; RAM_button = 0; end endmodule</code> </pre><br><img src="https://habrastorage.org/webt/mz/an/c_/mzanc_fhk-_f1bu77t-6dmmodcg.gif"><br><br>  Ajoutez au circuit MUX2 et Ass.  Nous enregistrerons dans Ass avec la commande RAM_out [6]. <br><br><pre> <code class="plaintext hljs">assign Acc_button = RAM_out[6];</code> </pre><br>  Nous allons connecter un journal √† l'entr√©e d'horloge Ass.  √©l√©ment ET <br><br><pre> <code class="plaintext hljs">//  regiser4  (posedge reg_button)  (negedge reg_button) .reg_button(Acc_button &amp; timer555),</code> </pre><br>  Signification de la connexion d'un journal.  √©l√©ment Et √† l'entr√©e d'horloge est que maintenant sur le devant de timer555 vous pouvez commuter le multiplexeur, et sur le d√©clin pour enregistrer dans la batterie.  T.O.  nous avons mis deux √©quipes en un seul temps. <br><br>  Nous allons basculer MUX2 avec la commande RAM_out [5] <br><br><pre> <code class="plaintext hljs">assign MUX_switch = RAM_out[5];</code> </pre><br><img src="https://habrastorage.org/webt/ch/nj/29/chnj29pkt2rhfzeghs4mvfy8eaw.gif"><br><br><pre> <code class="plaintext hljs">module register4 ( input [3:0] reg_data, input reg_button, output reg [3:0] q ); always @(negedge reg_button) //  "posedge"  "negedge" q &lt;= reg_data; endmodule module R50 (reset_count, counter, timer555, RAM_button, data_in, RAM_out, mux_switch_out, mux_out,Acc_out); parameter ADDR_WIDTH = 2; parameter DATA_WIDTH = 8; input reset_count; output [ADDR_WIDTH-1:0] counter; input timer555; input RAM_button; input [DATA_WIDTH-1:0] data_in; output [DATA_WIDTH-1:0] RAM_out; output [3:0] Acc_out; output mux_switch_out; output [3:0] mux_out; wire Counter_load; assign Counter_load = RAM_out[7]; //Counter reg [ADDR_WIDTH-1:0] counter; always @ (posedge timer555 or posedge reset_count) if (reset_count) counter &lt;= 2'b00; else if (Counter_load) counter &lt;= RAM_out[1:0]; else counter &lt;= counter + 2'b01; wire [ADDR_WIDTH-1:0] adr; assign adr = counter; //RAM reg [DATA_WIDTH-1:0] mem [2**ADDR_WIDTH-1:0]; always @(posedge RAM_button) mem [adr] &lt;= data_in; assign RAM_out = mem[adr]; // MUX2 wire MUX_switch; assign MUX_switch = RAM_out[5]; reg [3:0] MUX2; always @* MUX2 = MUX_switch ? RAM_out : data_in[3:0]; //  4   data_in assign mux_out = MUX2; assign mux_switch_out = MUX_switch; wire Acc_button; assign Acc_button = RAM_out[6]; //Acc register4 Acc_reg( .reg_data(mux_out), .reg_button(Acc_button &amp; timer555), .q(Acc_out) ); endmodule</code> </pre><br>  Dans le banc de test, √©crivez le nombre 0101 dans la cellule 00 et le nombre 1010 dans la cellule 01;  charger ces num√©ros dans la batterie <br><br><pre> <code class="plaintext hljs">module tR50; parameter ADDR_WIDTH = 2; parameter DATA_WIDTH = 8; reg reset_count; reg timer555, RAM_button; wire [ADDR_WIDTH-1:0] counter; reg [DATA_WIDTH-1:0] data_in; wire [DATA_WIDTH-1:0] RAM_out; wire mux_switch_out; wire [3:0] mux_out; wire [3:0] Acc_out; R50 test_R50(reset_count, counter, timer555, RAM_button, data_in, RAM_out, mux_switch_out, mux_out,Acc_out); initial // Clock generator begin timer555 = 0; forever #20 timer555 = ~timer555; end initial begin data_in[0] = 1; data_in[1] = 0; data_in[2] = 1; data_in[3] = 0; data_in[4] = 0; data_in[5] = 1; data_in[6] = 1; data_in[7] = 0; RAM_button = 0; reset_count =1; #5 RAM_button = 1; reset_count = 0; #5 data_in[0]=0; data_in[2]=0; data_in[5]=0; data_in[6]=0; RAM_button=0; #15 data_in[1]=1; data_in[3]=1; data_in[5]=1;data_in[6]=1; #5 RAM_button=1; #5 data_in[1]=0; data_in[3]=0; data_in[5]=0; data_in[6]=0; RAM_button=0; end endmodule</code> </pre><br><img src="https://habrastorage.org/webt/nv/qt/vw/nvqtvw93g7qoemgtgb3kyxtonn0.gif"><br><br>  Nous pla√ßons la deuxi√®me RAM dans le circuit g√©n√©ral et √©crivons dans la RAM avec la commande RAM1_out [4]. <br><br><pre> <code class="plaintext hljs">assign RAM2_button = RAM1_out[4];</code> </pre><br><img src="https://habrastorage.org/webt/ks/xh/sp/ksxhspsrqxu2rnldvqt-vks0bie.gif"><br><br><pre> <code class="plaintext hljs">module register4 ( input [3:0] reg_data, input reg_button, output reg [3:0] q ); always @(negedge reg_button) q &lt;= reg_data; endmodule module R51 (reset_count, counter, timer555, RAM1_button, data_in, RAM1_out, RAM2_out, mux_switch_out, mux_out,Acc_out); parameter ADDR_WIDTH = 3; parameter DATA_WIDTH = 8; input reset_count; output [ADDR_WIDTH-1:0] counter; input timer555; input RAM1_button; input [DATA_WIDTH-1:0] data_in; output [DATA_WIDTH-1:0] RAM1_out; output [3:0] RAM2_out; output [3:0] Acc_out; output mux_switch_out; output [3:0] mux_out; wire Counter_load; assign Counter_load = RAM1_out[7]; //Counter reg [ADDR_WIDTH-1:0] counter; always @ (posedge timer555 or posedge reset_count) if (reset_count) counter &lt;= 2'b00; else if (Counter_load) counter &lt;= RAM1_out[1:0]; else counter &lt;= counter + 2'b01; wire [ADDR_WIDTH-1:0] adr1; assign adr1 = counter; //RAM1 reg [DATA_WIDTH-1:0] mem1 [2**ADDR_WIDTH-1:0]; always @(posedge RAM1_button ) mem1 [adr1] &lt;= data_in; assign RAM1_out = mem1[adr1]; wire [ADDR_WIDTH-1:0] adr2; assign adr2 = RAM1_out[3:0]; wire RAM2_button; assign RAM2_button = RAM1_out[4]; //RAM2 reg [3:0] mem2 [2**ADDR_WIDTH-1:0]; always @(posedge RAM2_button) mem2 [adr2] &lt;= Acc_out; assign RAM2_out = mem2[adr2]; // MUX2 wire MUX_switch; assign MUX_switch = RAM1_out[5]; reg [3:0] MUX2; always @* MUX2 = MUX_switch ? RAM2_out : data_in[3:0]; assign mux_out = MUX2; assign mux_switch_out = MUX_switch; wire Acc_button; assign Acc_button = RAM1_out[6]; //Acc register4 Acc_reg( .reg_data(mux_out), .reg_button(Acc_button &amp; timer555), .q(Acc_out) ); endmodule</code> </pre><br>  Dans le banc de test, chargez les nombres 0100 et 1000 de Ass √† z√©ro 0000 et la premi√®re cellule 0001 de RAM mem2 (puis chargez ces nombres dans Ass de RAM mem2) <br><br><pre> <code class="plaintext hljs">module tR51; parameter ADDR_WIDTH = 3; parameter DATA_WIDTH = 8; reg reset_count; reg timer555, RAM1_button; wire [ADDR_WIDTH-1:0] counter; reg [DATA_WIDTH-1:0] data_in; wire [DATA_WIDTH-1:0] RAM1_out; wire [3:0] RAM2_out; wire mux_switch_out; wire [3:0] mux_out; wire [3:0] Acc_out; R51 test_R51(reset_count, counter, timer555, RAM1_button, data_in, RAM1_out, RAM2_out, mux_switch_out, mux_out,Acc_out); initial // Clock generator begin timer555 = 0; forever #20 timer555 = ~timer555; end initial begin data_in[0] = 0; data_in[1] = 0; data_in[2] = 0; data_in[3] = 0; data_in[4] = 0; data_in[5] = 0; data_in[6] = 1; data_in[7] = 0; RAM1_button = 0; reset_count =1; #5 RAM1_button = 1; reset_count = 0; #5 RAM1_button = 0; data_in[6] = 0; #10 data_in[4] = 1; #5 RAM1_button = 1; #5 data_in[4] = 0; RAM1_button = 0; #30 data_in[6] = 1; #5 RAM1_button = 1; #5 data_in[6] = 0; RAM1_button = 0; #30 data_in[4] = 1; data_in[0] = 1; #5 RAM1_button = 1; #5 data_in[4] = 0; data_in[0] = 0; RAM1_button = 0; #30 data_in[6] = 1; #5 RAM1_button = 1; #5 RAM1_button = 0; data_in[6] = 0; #30 data_in[5] = 1; data_in[6] = 1; #5 RAM1_button = 1; #5 RAM1_button = 0; data_in[5] = 0; data_in[6] = 0; #30 data_in[5] = 1; data_in[6] = 1; data_in[0] = 1; #5 RAM1_button = 1; #5 RAM1_button = 0; data_in[0] = 0; data_in[5] = 0; data_in[6] = 0; #70 data_in[2] = 1; #80 data_in[2] = 0; data_in[3] = 1; #40 data_in[3] = 0; end endmodule</code> </pre><br><img src="https://habrastorage.org/webt/3k/f2/6i/3kf26ig-1py9pazz7ixfzncercq.gif"><br><br>  J'ajouterai que le sch√©ma c log.  l'√©l√©ment And √† l'entr√©e d'horloge de la batterie ne fonctionnera pas toujours correctement (selon la carte).  Remplacez le journal.  element Et sur le d√©clencheur Acc_dff, nous chargerons dans le d√©clencheur sur le front n√©gatif (sur le d√©clin) du signal d'horloge timer555, nous chargerons sur la batterie sur le front positif <br><br><pre> <code class="plaintext hljs">// Acc_dff reg Acc_dff; always @(negedge timer555) Acc_dff &lt;= Acc_button;</code> </pre><br>  Donc, en ajoutant les commandes restantes, cr√©ez le module R52 (LMC) <br><br><img src="https://habrastorage.org/webt/_l/uz/be/_luzbeu0mrsx2we-prdo3xn7lde.gif"><br><br><pre> <code class="plaintext hljs">module register4 ( input [3:0] reg_data, input reg_button, output reg [3:0] q ); always @(posedge reg_button) // negedge -&gt; posedge q &lt;= reg_data; endmodule module R52 (Z_flag, PZ_flag, reset_count, counter, timer555, RAM1_button, data_in, RAM1_out, RAM2_out, mux_switch_out, mux_out, Acc_out, data_out, Acc_dff); parameter ADDR_WIDTH = 4; parameter DATA_WIDTH = 12; input reset_count; input timer555; input RAM1_button; input [DATA_WIDTH-1:0] data_in; output [ADDR_WIDTH-1:0] counter; output [1:0] mux_switch_out; output [3:0] mux_out; output [3:0] Acc_out; output [3:0] data_out; output [DATA_WIDTH-1:0] RAM1_out; output [3:0] RAM2_out; output Z_flag, PZ_flag; output Acc_dff; wire JMP_button, Z_JMP_button,PZ_JMP_button; assign JMP_button = RAM1_out[6]; assign Z_JMP_button = RAM1_out[5]; assign PZ_JMP_button = RAM1_out[4]; wire Z_JMP,PZ_JMP; assign Z_JMP = Z_flag &amp; Z_JMP_button; assign PZ_JMP = PZ_flag &amp; PZ_JMP_button; //Counter reg [ADDR_WIDTH-1:0] counter; always @ (posedge timer555 or posedge reset_count) if (reset_count) counter &lt;= 4'b0000; else if (JMP_button|Z_JMP|PZ_JMP) counter &lt;= RAM1_out[3:0]; else counter &lt;= counter + 4'b0001; wire [ADDR_WIDTH-1:0] adr1; assign adr1 = counter; //RAM1 reg [DATA_WIDTH-1:0] mem1 [2**ADDR_WIDTH-1:0]; always @(posedge RAM1_button ) mem1 [adr1] &lt;= data_in; assign RAM1_out = mem1[adr1]; //RAM2_adr wire [ADDR_WIDTH-1:0] adr2; assign adr2 = RAM1_out[2:0]; //RAM2_button wire RAM2_button; assign RAM2_button = RAM1_out[11]; //RAM2 reg [3:0] mem2 [2**ADDR_WIDTH-1:0]; always @(posedge RAM2_button) mem2 [adr2] &lt;= Acc_out; assign RAM2_out = mem2[adr2]; // sum wire [3:0] sum; assign sum = Acc_out + RAM2_out; //subtract wire [3:0] subtract; assign subtract = Acc_out - RAM2_out; // MUX4 wire [1:0] mux_switch; assign mux_switch[0] = RAM1_out[7]; assign mux_switch[1] = RAM1_out[8]; reg [3:0] MUX4; always @* MUX4 = mux_switch[1] ? (mux_switch[0] ? RAM2_out : subtract) : (mux_switch[0] ? sum : data_in[3:0]); assign mux_out = MUX4; assign mux_switch_out[0] = mux_switch[0]; assign mux_switch_out[1] = mux_switch[1]; //Acc_button wire Acc_button; assign Acc_button = RAM1_out[10]; // Acc_dff reg Acc_dff; always @(negedge timer555) Acc_dff &lt;= Acc_button; //Acc register4 Acc_reg( .reg_data(mux_out), //.reg_button(Acc_button &amp; timer555), .reg_button(Acc_dff), .q(Acc_out) ); //data_out wire Output_button; assign Output_button = RAM1_out[9]; register4 Output_reg( .reg_data(Acc_out), .reg_button(Output_button), .q(data_out) ); // flags assign Z_flag = ~(|Acc_out); assign PZ_flag = ~Acc_out[3]; endmodule</code> </pre><br>  Dans le banc de test, nous v√©rifierons le fonctionnement de l'algorithme de recherche du nombre maximum. <br><br>  La particularit√© de charger des commandes dans la RAM est qu'apr√®s avoir charg√© toutes les commandes, nous devons retourner (340ns) √† la cellule 8 et charger une autre commande <br><br><pre> <code class="plaintext hljs">module tR52; parameter ADDR_WIDTH = 4; parameter DATA_WIDTH = 12; reg reset_count; reg timer555; reg RAM1_button; reg [DATA_WIDTH-1:0] data_in; wire [ADDR_WIDTH-1:0] counter; wire [1:0]mux_switch_out; wire [3:0] mux_out; wire [3:0] Acc_out; wire [3:0] data_out; wire [DATA_WIDTH-1:0] RAM1_out; wire [3:0] RAM2_out; wire Z_flag, PZ_flag; wire Acc_dff; R52 test_R52(Z_flag, PZ_flag, reset_count, counter, timer555, RAM1_button, data_in, RAM1_out, RAM2_out, mux_switch_out, mux_out,Acc_out, data_out, Acc_dff); initial // Clock generator begin timer555 = 0; forever #20 timer555 = ~timer555; end initial begin data_in[0] = 0; data_in[1] = 0; data_in[2] = 0; data_in[3] = 0; data_in[4] = 0; data_in[5] = 0; data_in[6] = 0; data_in[7] = 0; data_in[8] = 0; data_in[9] = 0; data_in[10] = 1; data_in[11] = 0; RAM1_button = 0; reset_count =1; //  1-    #5 RAM1_button = 1; reset_count = 0; #5 RAM1_button = 0; data_in[10] = 0; data_in[0] = 0; //  1-    0 #10 data_in[11] = 1; #5 RAM1_button = 1; #5 data_in[11] = 0; RAM1_button = 0; //  2-    #30 data_in[10] = 1; #5 RAM1_button = 1; #5 RAM1_button = 0; data_in[10] = 0; //  2-    0 #30 data_in[11] = 1;data_in[0] = 1; #5 RAM1_button = 1; #5 data_in[11] = 0;data_in[0] = 0; RAM1_button = 0; // 1-    #30 data_in[8]=1; data_in[10] = 1; #5 RAM1_button = 1; #5 RAM1_button = 0; data_in[8]=0; data_in[10] = 0; //  Acc&gt;=0,    8 #30 data_in[4]=1; data_in[3]=1; #5 RAM1_button = 1; #5 RAM1_button = 0; data_in[4]=0; data_in[3]=0; //  1-  #30 data_in[7] = 1; data_in[8] = 1; data_in[10] = 1; #5 RAM1_button = 1; #5 RAM1_button = 0; data_in[7] = 0; data_in[8] = 0; data_in[10] = 0; //     9 #30 data_in[6] = 1; data_in[3]=1; data_in[0]=1; #5 RAM1_button = 1; #5 RAM1_button = 0; data_in[6] = 0; data_in[3]=0; data_in[0]=0; //   data_out #30 data_in[9] = 1; #5 RAM1_button = 1; #5 RAM1_button = 0; data_in[9] = 0; //     8 #30 data_in[6] = 1; data_in[3]=1; data_in[0]=0; #5 RAM1_button = 1; #5 RAM1_button = 0; data_in[6] = 0; data_in[3]=0; data_in[0]=0; // 2-  #30 data_in[7] = 1; data_in[8] = 1; data_in[10] = 1; data_in[0] = 1; #5 RAM1_button = 1; #5 RAM1_button = 0; data_in[7] = 0; data_in[8] = 0; data_in[10] = 0; data_in[0] = 0; #75 RAM1_button = 1; #5 RAM1_button = 0; #230 data_in[2]=1; data_in[0]=0; //  #80 data_in[2]=0; data_in[0]=1; //   end endmodule</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lien</a> vers github avec les codes de programme. <br><br>  La version gratuite pour √©tudiants de <b>ModelSim</b> pour Windows peut √™tre t√©l√©charg√©e sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.model.com</a> . <br>  Ensuite, vous devez (en remplissant le formulaire) t√©l√©charger le fichier student_license.dat et placer ce fichier dans le r√©pertoire principal du programme <b>ModelSim</b> . <br><br>  Lien vers le fichier <b>ModelSim</b> pour Linux (Ubuntu) <a href="">ici</a> <br>  Instructions d'installation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr412379/">https://habr.com/ru/post/fr412379/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr412369/index.html">Teste un robot EduMip auto-√©quilibr√© bas√© sur BeagleBone Blue. 2e partie</a></li>
<li><a href="../fr412371/index.html">Les astronomes ont confirm√© la d√©couverte de la deuxi√®me galaxie la plus √©loign√©e de nous</a></li>
<li><a href="../fr412373/index.html">Comment la fabrication automatis√©e de semi-conducteurs</a></li>
<li><a href="../fr412375/index.html">La recharge sans fil peut-elle √™tre rapide? Parlez de Sony WCH20</a></li>
<li><a href="../fr412377/index.html">Singularit√© sentimentale: quel est le jeu "Detroit: Devenir Humain"</a></li>
<li><a href="../fr412381/index.html">Test des panneaux LED 60x60</a></li>
<li><a href="../fr412383/index.html">Des l√©sions c√©r√©brales ont sauv√© sa musique</a></li>
<li><a href="../fr412385/index.html">Islande: √Æle temp√™te</a></li>
<li><a href="../fr412387/index.html">NeoLAB lance un nouveau stylo intelligent - SmartPen M1</a></li>
<li><a href="../fr412389/index.html">Poudlard rouge. S√©rie 6. Tireur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>