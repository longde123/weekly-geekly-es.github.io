<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿 🧖🏻 👂 Winkelschemata oder wie ich meine Vorlage für Winkelkli geschrieben habe 🖊️ 👩🏻 👘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo, ich heiße Maxim. Seit einigen Jahren entwickle ich Frontends. Ich muss mich oft mit dem Layout verschiedener HTML-Vorlagen befassen. In meiner ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Winkelschemata oder wie ich meine Vorlage für Winkelkli geschrieben habe</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469509/"><p>  Hallo, ich heiße Maxim.  Seit einigen Jahren entwickle ich Frontends.  Ich muss mich oft mit dem Layout verschiedener HTML-Vorlagen befassen.  In meiner täglichen Arbeit verwende ich normalerweise den Webpack Builder mit einer angepassten Mops-Vorlagen-Engine und ich verwende auch die BEM-Methodik.  Um mein Leben leichter zu machen, benutze ich ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wunderbares Paket</a> . </p><br><p>  Vor kurzem musste ich ein kleines Projekt für Angular erstellen, und da ich es gewohnt war, mit meinen Lieblingswerkzeugen zu arbeiten, wollte ich nicht zum nackten HTML zurückkehren.  In diesem Zusammenhang stellte sich das Problem, wie man bempug-Freunde mit einem Winkel findet und nicht nur Freunde findet, sondern auch Komponenten aus cli mit der von mir benötigten Struktur generiert. </p><br><p>  Wen interessiert es, wie ich das alles gemacht habe, willkommen bei cat. </p><a name="habracut"></a><br><p>  Erstellen Sie zunächst ein Testprojekt, an dem wir unsere Vorlage testen. </p><br><p>  Wir führen in der Kommandozeile aus: </p><br><p> <code>ng g test-project</code> . </p><br><p>  In den Einstellungen habe ich den scss-Präprozessor gewählt, da ich damit besser arbeiten kann. </p><br><p>  Das Projekt wurde erstellt, aber die Standardkomponentenvorlagen in unserem HTML-Code beheben es jetzt.  Zunächst müssen Sie mit der Mops-Template-Engine eckige Cli-Freunde finden. Dazu habe ich das Paket ng-cli-pug-loader verwendet </p><br><p>  Installieren Sie das Paket, gehen Sie dazu in den Projektordner und führen Sie Folgendes aus: </p><br><p>  <code>ng add ng-cli-pug-loader</code> . </p><br><p>  Jetzt können Sie Mops-Vorlagendateien verwenden.  Als Nächstes schreiben wir den Root-Dekorator der AppComponent-Komponente wie folgt um: </p><br><pre> <code class="javascript hljs"> @Component({ <span class="hljs-attr"><span class="hljs-attr">selector</span></span>: <span class="hljs-string"><span class="hljs-string">'app-root'</span></span>, <span class="hljs-attr"><span class="hljs-attr">templateUrl</span></span>: <span class="hljs-string"><span class="hljs-string">'./app.component.pug'</span></span>, <span class="hljs-attr"><span class="hljs-attr">styleUrls</span></span>: [<span class="hljs-string"><span class="hljs-string">'./app.component.scss'</span></span>] })</code> </pre> <br><p>  Dementsprechend ändern wir die Dateierweiterung app.component.html in app.component.pug, und der Inhalt wird in der Vorlagensyntax geschrieben.  In dieser Datei habe ich alles außer dem Router gelöscht. </p><br><p>  Zum Schluss erstellen wir unseren Komponentengenerator! </p><br><p>  Um Vorlagen zu generieren, müssen wir unser eigenes Schema erstellen.  Ich verwende das schematics-cli-Paket von @ angle-devkit.  Installieren Sie das Paket global mit dem folgenden Befehl: </p><br><p>  <code>npm install -g @angular-devkit/schematics-cli</code> . </p><br><p>  Ich habe das Schema in einem separaten Verzeichnis außerhalb des Projekts mit dem folgenden Befehl erstellt: </p><br><p>  <code>schematics blank --name=bempug-component</code> . </p><br><p>  Wir gehen in das erstellte Schema, wir interessieren uns jetzt für die Datei src / collection.json.  Es sieht so aus: </p><br><pre> <code class="json hljs"> <span class="hljs-string"><span class="hljs-string">"$schema"</span></span>: <span class="hljs-string"><span class="hljs-string">"../node_modules/@angular-devkit/schematics/collection-schema.json"</span></span>, <span class="hljs-string"><span class="hljs-string">"schematics"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"bempug-component"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"A blank schematic."</span></span>, <span class="hljs-attr"><span class="hljs-attr">"factory"</span></span>: <span class="hljs-string"><span class="hljs-string">"./bempug-component/index#bempugComponent"</span></span> } } }</code> </pre> <br><p>  Dies ist eine Beschreibungsdatei unseres Schemas, in der der Parameter "factory" lautet: "./bempug-component/index#bempugComponent": Dies ist die Beschreibung der Hauptfunktion der "factory" unseres Generators. </p><br><p>  Anfangs sieht es ungefähr so ​​aus: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Rule, SchematicContext, Tree } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/schematics'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// You don't have to export the function as default. You can also have more than one rule factory // per file. export function bempugComponent(options: any): Rule { return (tree: Tree, _context: SchematicContext) =&gt; { return tree; }; }</span></span></code> </pre> <br><p>  Sie können die Funktion standardmäßig exportieren, dann kann der Parameter "factory" als "./bempug-component/index" umgeschrieben werden. </p><br><p>  Als nächstes erstellen Sie im Verzeichnis unseres Schemas die Datei schema.json, in der alle Parameter unseres Schemas beschrieben werden. </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"$schema"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://json-schema.org/schema"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"SchemanticsForMenu"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Bempug Schema"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"object"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"properties"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"$default"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"$source"</span></span>: <span class="hljs-string"><span class="hljs-string">"argv"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"index"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"path"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"format"</span></span>: <span class="hljs-string"><span class="hljs-string">"path"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"The path to create the component."</span></span>, <span class="hljs-attr"><span class="hljs-attr">"visible"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"project"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"The name of the project."</span></span>, <span class="hljs-attr"><span class="hljs-attr">"$default"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"$source"</span></span>: <span class="hljs-string"><span class="hljs-string">"projectName"</span></span> } } } }</code> </pre> <br><p>  Parameter sind in Eigenschaften, nämlich: </p><br><ul><li>  Name Name der Entität (in unserem Fall handelt es sich um eine Komponente); </li><li>  Pfad ist der Pfad, über den der Generator die Komponentendateien erstellt. </li><li>  Projekt ist das Projekt selbst, in dem die Komponente generiert wird. </li></ul><br><p>  Fügen Sie der Datei einige weitere Parameter hinzu, die in Zukunft benötigt werden. </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"module"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"The declaring module."</span></span>, <span class="hljs-attr"><span class="hljs-attr">"alias"</span></span>: <span class="hljs-string"><span class="hljs-string">"m"</span></span> }, <span class="hljs-string"><span class="hljs-string">"componentModule"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"boolean"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"default"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Patern module per Component"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"alias"</span></span>: <span class="hljs-string"><span class="hljs-string">"mc"</span></span> }, <span class="hljs-string"><span class="hljs-string">"export"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"boolean"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"default"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Export component from module?"</span></span> }</code> </pre> <br><ul><li>  Modul wird hier ein Link zu dem Modul gespeichert, in dem die Komponente enthalten sein wird, oder vielmehr das Komponentenmodul; </li><li>  componentModule gibt es ein Flag, ob für die Komponente ein eigenes Modul erstellt werden soll (dann bin ich zu dem Schluss gekommen, dass es immer erstellt wird und setzt es auf true); </li><li>  export: Dies ist das Flag, ob aus dem Modul exportiert werden soll, in das wir unser Komponentenmodul importieren. </li></ul><br><p>  Als Nächstes erstellen wir eine Schnittstelle mit den Parametern unserer Komponente, der Datei schema.d.ts. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> interface BemPugOptions { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: string; project?: string; path?: string; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>?: string; componentModule?: boolean; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>?: string; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span>?: boolean; bemPugMixinPath?: string; }</code> </pre> <br><p>  Darin duplizieren Eigenschaften Eigenschaften aus schema.json.  Als nächstes bereiten Sie unsere Fabrik vor und gehen zur Datei index.ts.  Darin erstellen wir zwei filterTemplates-Funktionen, die für das Erstellen eines Moduls für eine Komponente abhängig vom Wert von componentModule verantwortlich sind, und setupOptions, mit dem die für die Factory erforderlichen Parameter eingerichtet werden. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filterTemplates</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options: BemPugOptions</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Rule</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!options.componentModule) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">path</span></span></span><span class="hljs-function"> =&gt;</span></span> !path.match(<span class="hljs-regexp"><span class="hljs-regexp">/\.module\.ts$/</span></span>) &amp;&amp; !path.match(<span class="hljs-regexp"><span class="hljs-regexp">/-item\.ts$/</span></span>) &amp;&amp; !path.match(<span class="hljs-regexp"><span class="hljs-regexp">/\.bak$/</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">path</span></span></span><span class="hljs-function"> =&gt;</span></span> !path.match(<span class="hljs-regexp"><span class="hljs-regexp">/\.bak$/</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupOptions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options: BemPugOptions, host: Tree</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> workspace = getWorkspace(host); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!options.project) { options.project = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(workspace.projects)[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> project = workspace.projects[options.project]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (options.path === <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> projectDirName = project.projectType === <span class="hljs-string"><span class="hljs-string">'application'</span></span> ? <span class="hljs-string"><span class="hljs-string">'app'</span></span> : <span class="hljs-string"><span class="hljs-string">'lib'</span></span>; options.path = <span class="hljs-string"><span class="hljs-string">`/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${project.root}</span></span></span><span class="hljs-string">/src/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${projectDirName}</span></span></span><span class="hljs-string">`</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> parsedPath = parseName(options.path, options.name); options.name = parsedPath.name; options.path = parsedPath.path; }</code> </pre><br><p>  Als nächstes schreiben wir in die Hauptfunktion: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bempugComponent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options: BemPugOptions</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Rule</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">host: Tree, context: SchematicContext</span></span></span><span class="hljs-function">) =&gt;</span></span> { setupOptions(options, host); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> templateSource = apply(url(<span class="hljs-string"><span class="hljs-string">'./files'</span></span>), [ filterTemplates(options), template({ ...strings, ...options }), move(options.path || <span class="hljs-string"><span class="hljs-string">''</span></span>) ]); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rule = chain([ branchAndMerge(chain([ mergeWith(templateSource), ])) ]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rule(host, context); } }</code> </pre><br><p>  Die Factory ist bereit und kann bereits Komponentendateien generieren, indem Vorlagen aus dem Dateiordner verarbeitet werden, der noch nicht verfügbar ist.  Es spielt keine Rolle, in meinem Fall erstellen wir einen Ordner mit bempug-Komponentendateien in unserem Schemaordner.  Erstellen Sie im Dateiordner den Ordner <code>__name@dasherize__</code> . Während der Generierung ersetzt die Factory <code>__name@dasherize__</code> durch den Namen der Komponente. </p><br><p>  <code>__name@dasherize__</code> Dateien </p><br><ul><li>  <code>__name@dasherize__</code> .component.pug Mops Komponentenvorlage </li><li>  <code>__name@dasherize__</code> .component.spec.ts Unit-Testdatei für die Komponente </li><li>  <code>__name@dasherize__</code> .component.ts Datei der Komponente selbst </li><li>  <code>__name@dasherize__</code> Komponentenmodul </li><li>  <code>__name@dasherize__</code> Komponenten-Stylesheet </li></ul><br><p>  Jetzt werden wir unserer Factory Unterstützung für das Aktualisieren von Modulen hinzufügen. Dazu erstellen wir die Datei add-to-module-context.ts, um die Parameter zu speichern, die die Factory für die Arbeit mit dem Modul benötigt. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'typescript'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddToModuleContext</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// source of the module file source: ts.SourceFile; // the relative path that points from // the module file to the component file relativePath: string; // name of the component class classifiedName: string; }</span></span></code> </pre> <br><p>  Fügen Sie der Fabrik die Modulunterstützung hinzu. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> stringUtils = { dasherize, classify }; <span class="hljs-comment"><span class="hljs-comment">// You don't have to export the function as default. You can also have more than one rule factory // per file. function filterTemplates(options: BemPugOptions): Rule { if (!options.componentModule) { return filter(path =&gt; !path.match(/\.module\.ts$/) &amp;&amp; !path.match(/-item\.ts$/) &amp;&amp; !path.match(/\.bak$/)); } return filter(path =&gt; !path.match(/\.bak$/)); } function setupOptions(options: BemPugOptions, host: Tree): void { const workspace = getWorkspace(host); if (!options.project) { options.project = Object.keys(workspace.projects)[0]; } const project = workspace.projects[options.project]; if (options.path === undefined) { const projectDirName = project.projectType === 'application' ? 'app' : 'lib'; options.path = `/${project.root}/src/${projectDirName}`; } const parsedPath = parseName(options.path, options.name); options.name = parsedPath.name; options.path = parsedPath.path; options.module = options.module || findModuleFromOptions(host, options) || ''; } export function createAddToModuleContext(host: Tree, options: ModuleOptions, componentPath: string): AddToModuleContext { const result = new AddToModuleContext(); if (!options.module) { throw new SchematicsException(`Module not found.`); } // Reading the module file const text = host.read(options.module); if (text === null) { throw new SchematicsException(`File ${options.module} does not exist.`); } const sourceText = text.toString('utf-8'); result.source = ts.createSourceFile(options.module, sourceText, ts.ScriptTarget.Latest, true); result.relativePath = buildRelativePath(options.module, componentPath); result.classifiedName = stringUtils.classify(`${options.name}ComponentModule`); return result; } function addDeclaration(host: Tree, options: ModuleOptions, componentPath: string) { const context = createAddToModuleContext(host, options, componentPath); const modulePath = options.module || ''; const declarationChanges = addImportToModule( context.source, modulePath, context.classifiedName, context.relativePath); const declarationRecorder = host.beginUpdate(modulePath); for (const change of declarationChanges) { if (change instanceof InsertChange) { declarationRecorder.insertLeft(change.pos, change.toAdd); } } host.commitUpdate(declarationRecorder); }; function addExport(host: Tree, options: ModuleOptions, componentPath: string) { const context = createAddToModuleContext(host, options, componentPath); const modulePath = options.module || ''; const exportChanges = addExportToModule( context.source, modulePath, context.classifiedName, context.relativePath); const exportRecorder = host.beginUpdate(modulePath); for (const change of exportChanges) { if (change instanceof InsertChange) { exportRecorder.insertLeft(change.pos, change.toAdd); } } host.commitUpdate(exportRecorder); }; export function addDeclarationToNgModule(options: ModuleOptions, exports: boolean, componentPath: string): Rule { return (host: Tree) =&gt; { addDeclaration(host, options, componentPath); if (exports) { addExport(host, options, componentPath); } return host; }; } export function bempugComponent(options: BemPugOptions): Rule { return (host: Tree, context: SchematicContext) =&gt; { setupOptions(options, host); deleteCommon(host); const templateSource = apply(url('./files'), [ filterTemplates(options), template({ ...strings, ...options }), move(options.path || '') ]); const rule = chain([ branchAndMerge(chain([ mergeWith(templateSource), addDeclarationToNgModule(options, !!options.export, `${options.path}/${options.name}/${options.name}-component.module` || '') ])) ]); return rule(host, context); } }</span></span></code> </pre><br><p>  Wenn Sie nun den Parameter -m &lt;Modulreferenz&gt; zum Befehl cli hinzufügen, fügt unser Komponentenmodul dem angegebenen Modul einen Import hinzu und fügt den Export daraus hinzu, wenn Sie das Flag –export hinzufügen.  Als nächstes fügen wir BEM-Unterstützung hinzu.  Dazu habe ich die Quellen des npm bempug-Pakets genommen und den Code in einer bempugMixin.pug-Datei erstellt, die ich im allgemeinen Ordner und in einem anderen gemeinsamen Ordner abgelegt habe, damit das Mixin in den gemeinsamen Ordner im Projekt auf dem Winkel kopiert wird. </p><br><p>  Unsere Aufgabe ist es, dass dieses Mixin in jeder unserer Vorlagendateien verbunden und beim Generieren neuer Komponenten nicht dupliziert wird. Dazu werden wir diese Funktionalität unserer Fabrik hinzufügen. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Rule, SchematicContext, Tree, filter, apply, template, move, chain, branchAndMerge, mergeWith, url, SchematicsException } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/schematics'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {BemPugOptions} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./schema"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {getWorkspace} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@schematics/angular/utility/config"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {parseName} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@schematics/angular/utility/parse-name"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {normalize, strings} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular-devkit/core"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { AddToModuleContext } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./add-to-module-context'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'typescript'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {classify, dasherize} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular-devkit/core/src/utils/strings"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {buildRelativePath, findModuleFromOptions, ModuleOptions} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@schematics/angular/utility/find-module"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {addExportToModule, addImportToModule} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@schematics/angular/utility/ast-utils"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {InsertChange} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@schematics/angular/utility/change"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> stringUtils = { dasherize, classify }; <span class="hljs-comment"><span class="hljs-comment">// You don't have to export the function as default. You can also have more than one rule factory // per file. function filterTemplates(options: BemPugOptions): Rule { if (!options.componentModule) { return filter(path =&gt; !path.match(/\.module\.ts$/) &amp;&amp; !path.match(/-item\.ts$/) &amp;&amp; !path.match(/\.bak$/)); } return filter(path =&gt; !path.match(/\.bak$/)); } function setupOptions(options: BemPugOptions, host: Tree): void { const workspace = getWorkspace(host); if (!options.project) { options.project = Object.keys(workspace.projects)[0]; } const project = workspace.projects[options.project]; if (options.path === undefined) { const projectDirName = project.projectType === 'application' ? 'app' : 'lib'; options.path = `/${project.root}/src/${projectDirName}`; } const parsedPath = parseName(options.path, options.name); options.name = parsedPath.name; options.path = parsedPath.path; options.module = options.module || findModuleFromOptions(host, options) || ''; options.bemPugMixinPath = buildRelativePath(`${options.path}/${options.name}/${options.name}.component.ts`, `/src/app/common/bempugMixin.pug`); } export function createAddToModuleContext(host: Tree, options: ModuleOptions, componentPath: string): AddToModuleContext { const result = new AddToModuleContext(); if (!options.module) { throw new SchematicsException(`Module not found.`); } // Reading the module file const text = host.read(options.module); if (text === null) { throw new SchematicsException(`File ${options.module} does not exist.`); } const sourceText = text.toString('utf-8'); result.source = ts.createSourceFile(options.module, sourceText, ts.ScriptTarget.Latest, true); result.relativePath = buildRelativePath(options.module, componentPath); result.classifiedName = stringUtils.classify(`${options.name}ComponentModule`); return result; } function addDeclaration(host: Tree, options: ModuleOptions, componentPath: string) { const context = createAddToModuleContext(host, options, componentPath); const modulePath = options.module || ''; const declarationChanges = addImportToModule( context.source, modulePath, context.classifiedName, context.relativePath); const declarationRecorder = host.beginUpdate(modulePath); for (const change of declarationChanges) { if (change instanceof InsertChange) { declarationRecorder.insertLeft(change.pos, change.toAdd); } } host.commitUpdate(declarationRecorder); }; function addExport(host: Tree, options: ModuleOptions, componentPath: string) { const context = createAddToModuleContext(host, options, componentPath); const modulePath = options.module || ''; const exportChanges = addExportToModule( context.source, modulePath, context.classifiedName, context.relativePath); const exportRecorder = host.beginUpdate(modulePath); for (const change of exportChanges) { if (change instanceof InsertChange) { exportRecorder.insertLeft(change.pos, change.toAdd); } } host.commitUpdate(exportRecorder); }; export function addDeclarationToNgModule(options: ModuleOptions, exports: boolean, componentPath: string): Rule { return (host: Tree) =&gt; { addDeclaration(host, options, componentPath); if (exports) { addExport(host, options, componentPath); } return host; }; } function deleteCommon(host: Tree) { const path = `/src/app/common/bempugMixin.pug`; if(host.exists(path)) { host.delete(`/src/app/common/bempugMixin.pug`); } } export function bempugComponent(options: BemPugOptions): Rule { return (host: Tree, context: SchematicContext) =&gt; { setupOptions(options, host); deleteCommon(host); const templateSource = apply(url('./files'), [ filterTemplates(options), template({ ...strings, ...options }), move(options.path || '') ]); const mixinSource = apply(url('./common'), [ template({ ...strings, ...options }), move('/src/app/' || '') ]); const rule = chain([ branchAndMerge(chain([ mergeWith(templateSource), mergeWith(mixinSource), addDeclarationToNgModule(options, !!options.export, `${options.path}/${options.name}/${options.name}-component.module` || '') ]), 14) ]); return rule(host, context); } }</span></span></code> </pre><br><p>  Es ist Zeit, unsere Vorlagendateien auszufüllen. </p><br><p>  <code>__name@dasherize__.component.pug</code> : </p><br><pre> <code class="javascript hljs">include &lt;%= bemPugMixinPath %&gt; +b(<span class="hljs-string"><span class="hljs-string">'&lt;%= name %&gt;'</span></span>) +e(<span class="hljs-string"><span class="hljs-string">'item'</span></span>, {<span class="hljs-attr"><span class="hljs-attr">m</span></span>:<span class="hljs-string"><span class="hljs-string">'test'</span></span>}) | <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">%=</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span></span><span class="xml"><span class="hljs-tag"> %&gt;</span></span></span><span class="xml"> works</span></span></code> </pre> <br><p>  Was während der Generierung in &lt;% =%&gt; angegeben wird, wird durch den Namen der Komponente ersetzt. </p><br><p> <code>__name@dasherize__.component.spec.ts:</code> </p> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">async</span></span>, ComponentFixture, TestBed } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core/testing'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {NO_ERRORS_SCHEMA} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { &lt;%= classify(name) %&gt;ComponentModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./&lt;%= name %&gt;-component.module'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { &lt;%= classify(name) %&gt;Component } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./&lt;%= name %&gt;.component'</span></span>; describe(<span class="hljs-string"><span class="hljs-string">'&lt;%= classify(name) %&gt;Component'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> component: <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">%=</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">classify</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span></span><span class="xml"><span class="hljs-tag">) %&gt;</span></span></span><span class="xml">Component; let fixture: ComponentFixture</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt;%= </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">classify(name)</span></span></span></span><span class="xml"><span class="hljs-tag"> %&gt;</span></span></span><span class="xml">Component&gt;; beforeEach(async(() =&gt; { TestBed.configureTestingModule({ imports: [</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">%=</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">classify</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span></span><span class="xml"><span class="hljs-tag">) %&gt;</span></span></span><span class="xml">ComponentModule], declarations: [], schemas: [ NO_ERRORS_SCHEMA ] }) .compileComponents(); })); beforeEach(() =&gt; { fixture = TestBed.createComponent(</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">%=</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">classify</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span></span><span class="xml"><span class="hljs-tag">) %&gt;</span></span></span><span class="xml">Component); component = fixture.componentInstance; fixture.detectChanges(); }); it('should create', () =&gt; { expect(component).toBeTruthy(); }); });</span></span></code> </pre> <br><p>  In diesem Fall wird &lt;% = classify (name)%&gt; verwendet, um den Namen in CamelCase umzuwandeln. </p><br><p> <code>__name@dasherize__.component.ts:</code> </p> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Component, OnInit, ViewEncapsulation} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; @Component({ <span class="hljs-attr"><span class="hljs-attr">selector</span></span>: <span class="hljs-string"><span class="hljs-string">'app-&lt;%=dasherize(name)%&gt;-component'</span></span>, <span class="hljs-attr"><span class="hljs-attr">templateUrl</span></span>: <span class="hljs-string"><span class="hljs-string">'&lt;%=dasherize(name)%&gt;.component.pug'</span></span>, <span class="hljs-attr"><span class="hljs-attr">styleUrls</span></span>: [<span class="hljs-string"><span class="hljs-string">'./&lt;%=dasherize(name)%&gt;-component.scss'</span></span>], <span class="hljs-attr"><span class="hljs-attr">encapsulation</span></span>: ViewEncapsulation.None }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> &lt;%</span></span>= classify(name) %&gt;Component implements OnInit { <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {} ngOnInit(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } }</code> </pre><br><p> <code>__name@dasherize__-component.module.ts:</code> </p> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { NgModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { CommonModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/common'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {&lt;%= classify(name) %&gt;Component} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./&lt;%= name %&gt;.component'</span></span>; @NgModule({ <span class="hljs-attr"><span class="hljs-attr">declarations</span></span>: [ <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">%=</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">classify</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span></span><span class="xml"><span class="hljs-tag">) %&gt;</span></span></span><span class="xml">Component, ], imports: [ CommonModule ], exports: [ </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">%=</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">classify</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span></span><span class="xml"><span class="hljs-tag">) %&gt;</span></span></span><span class="xml">Component, ] }) export class </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">%=</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">classify</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span></span><span class="xml"><span class="hljs-tag">) %&gt;</span></span></span><span class="xml">ComponentModule { }</span></span></code> </pre> <br><p> <code>__name@dasherize__-component.scss:</code> </p> <br><pre> <code class="css hljs">.&lt;%= <span class="hljs-selector-tag"><span class="hljs-selector-tag">name</span></span> %&gt;{ }</code> </pre> <br><p>  Wir erstellen unser Schema mit dem Befehl `` npm run build``. </p><br><p>  Alles ist bereit, Komponenten im Projekt zu generieren! </p><br><p>  Um dies zu überprüfen, kehren Sie zu unserem Angular-Projekt zurück und erstellen Sie ein Modul. <br> <code>ng gm test-schema</code> <br>  Als nächstes führen wir `` npm link &lt;absoluter Pfad zum Projektordner mit unserem Schema&gt; '' aus, um unser Schema zu den node_modules des Projekts hinzuzufügen. </p><br><p>  Und wir versuchen die Schaltung mit dem <code>ng g bempug-component:bempug-component test -m /src/app/test-schema/test-schema.module.ts –export</code> . <br>  Unser Schema erstellt eine Komponente und fügt sie beim Export dem angegebenen Modul hinzu. <br>  Wenn das Schema fertig ist, können Sie die Anwendung auf vertrauten Technologien erstellen. </p><br><p>  Sie können die endgültige Version <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier sehen</a> , und auch das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Paket ist in npm verfügbar</a> . </p><br><p>  Bei der Erstellung des Schemas habe ich Artikel zu diesem Thema verwendet. Ich danke den Autoren. </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://blog.angular.io/schematics-an-introduction-dc1dfbc2a2b2</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://medium.com/@tomastrajan/total-guide-to-custom-angular-schematics-5c50cf90cdb4</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://developer.okta.com/blog/2019/02/13/angular-schematics</a> ; </li></ul><br><p>  Vielen Dank für Ihre Aufmerksamkeit, alle, die bis zum Ende lesen, Sie sind die Besten! <br>  Und ein weiteres spannendes Projekt erwartet mich.  Bis bald! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de469509/">https://habr.com/ru/post/de469509/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de469497/index.html">Erstellen Sie mit dem Tilemap-System isometrische 2D-Ebenen</a></li>
<li><a href="../de469499/index.html">Wie wir bei Parallels es geschafft haben, uns bei Apple anzumelden</a></li>
<li><a href="../de469503/index.html">Cybersicherheit: Wir schützen Teilnehmerdaten 2019 vor Lecks</a></li>
<li><a href="../de469505/index.html">3 praktische Möglichkeiten, um Geschäfte auf ausländische Märkte zu bringen: Ansätze und Techniken realer Unternehmen</a></li>
<li><a href="../de469507/index.html">Dritte Steam Windows Client-Sicherheitsanfälligkeit, jedoch nicht 0day</a></li>
<li><a href="../de469521/index.html">Ich kaufte ein Motorrad, um zu fahren, nicht um zu fallen</a></li>
<li><a href="../de469523/index.html">Abhängigkeit der Codeleistung vom Kontext der Variablendeklaration in JavaScript</a></li>
<li><a href="../de469525/index.html">Automatisiertes Steuerungssystem für einen Bergbaubagger</a></li>
<li><a href="../de469527/index.html">Ist die Gegensprechanlage ein Spionageohr?</a></li>
<li><a href="../de469529/index.html">Text-Rendering hasst dich</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>