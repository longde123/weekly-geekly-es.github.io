<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📵 👩🏿‍🚀 🕧 Zeiger in Python: Was ist der Sinn? 🤟🏻 😗 ✍🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie jemals mit einfachen Sprachen wie C oder C ++ gearbeitet haben, haben Sie wahrscheinlich von Zeigern gehört. Mit ihnen können Sie die Effekti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zeiger in Python: Was ist der Sinn?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/454324/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/_i/vd/cj/_ivdcjv0itamifffxs0i1i-mqh4.jpeg"></div><br>  Wenn Sie jemals mit einfachen Sprachen wie C oder C ++ gearbeitet haben, haben Sie wahrscheinlich von Zeigern gehört.  Mit ihnen können Sie die Effektivität verschiedener Codeteile erheblich steigern.  Sie können aber auch Anfänger - und sogar erfahrene Entwickler - verwirren und zu Fehlern bei der Speicherverwaltung führen.  Gibt es Zeiger in Python, kann ich sie irgendwie emulieren? <br><br>  Zeiger werden häufig in C und C ++ verwendet.  Tatsächlich sind dies Variablen, die die Speicheradressen enthalten, an denen sich andere Variablen befinden.  Lesen Sie diese <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rezension</a> , um Zeiger <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aufzufrischen</a> . <br><br>  Dank dieses Artikels können Sie das Objektmodell in Python besser verstehen und herausfinden, warum Zeiger in dieser Sprache nicht vorhanden sind.  Wenn Sie das Verhalten von Zeigern simulieren müssen, lernen Sie, wie Sie sie ohne den damit verbundenen Albtraum der Speicherverwaltung emulieren. <br><a name="habracut"></a><br>  Mit diesem Artikel haben Sie: <br><br><ul><li>  Erfahren Sie, warum Python keine Zeiger hat. </li><li>  Lernen Sie den Unterschied zwischen C-Variablen und Namen in Python. </li><li>  Erfahren Sie, wie Sie Zeiger in Python emulieren. </li><li> Verwenden Sie <code>ctypes</code> um mit echten Zeigern <code>ctypes</code> experimentieren. </li></ul><br>  <b>Hinweis</b> : Hier wird der Begriff „Python“ auf die Python-Implementierung in C angewendet, die als CPython bezeichnet wird.  Alle Diskussionen des Sprachgeräts gelten für CPython 3.7, entsprechen jedoch möglicherweise nicht den nachfolgenden Iterationen. <br><br><h2>  Warum gibt es in Python keine Zeiger? </h2><br>  Weiß nicht.  Können Zeiger in Python nativ vorhanden sein?  Wahrscheinlich, aber anscheinend widersprechen die Zeiger dem Konzept des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zen von Python</a> , weil sie implizite Änderungen anstelle expliziter provozieren.  Zeiger sind oft sehr komplex, besonders für Anfänger.  Darüber hinaus drängen sie Sie zu erfolglosen Entscheidungen oder zu etwas wirklich Gefährlichem, wie dem Lesen aus einem Speicherbereich, in dem Sie es nicht hätten lesen sollen. <br><br>  Python versucht, Implementierungsdetails vom Benutzer zu abstrahieren, z. B. eine Speicheradresse.  In dieser Sprache liegt der Schwerpunkt häufig auf Benutzerfreundlichkeit und nicht auf Geschwindigkeit.  Daher sind Zeiger in Python nicht sehr sinnvoll.  Aber keine Sorge, die Sprache bietet Ihnen standardmäßig einige Vorteile der Verwendung von Zeigern. <br><br>  Um die Zeiger in Python zu verstehen, gehen wir kurz auf die Funktionen der Sprachimplementierung ein.  Insbesondere müssen Sie verstehen: <br><br><ol><li>  Was sind veränderliche und unveränderliche Objekte? </li><li>  Wie sind Variablen / Namen in Python angeordnet? </li></ol><br>  Halten Sie an Ihren Speicheradressen fest, los geht's! <br><br><h2>  Objekte in Python </h2><br>  Alles in Python ist ein Objekt.  Öffnen Sie beispielsweise REPL und sehen Sie, wie <code>isinstance()</code> : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>isinstance(<span class="hljs-number"><span class="hljs-number">1</span></span>, object) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; isinstance(list(), object) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; isinstance(<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, object) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> ... &gt;&gt;&gt; isinstance(foo, object) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  Dieser Code zeigt, dass alles in Python tatsächlich ein Objekt ist.  Jedes Objekt enthält mindestens drei Datentypen: <br><br><ul><li>  Referenzzähler. <br></li><li>  Typ <br></li><li>  Wert. <br></li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein Referenzzähler wird</a> zum Verwalten des Speichers verwendet.  Details zu dieser Verwaltung finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherverwaltung in Python</a> .  Der Typ wird auf CPython-Ebene verwendet, um die Typensicherheit zur Laufzeit zu gewährleisten.  Und value ist der tatsächliche Wert, der dem Objekt zugeordnet ist. <br><br>  Aber nicht alle Objekte sind gleich.  Es gibt einen wichtigen Unterschied: Objekte sind veränderlich und unveränderlich.  Wenn Sie diese Unterscheidung zwischen Objekttypen verstehen, können Sie die erste Schicht der Zwiebel, die als "Zeiger in Python" bezeichnet wird, besser verstehen. <br><br><h2>  Veränderliche und unveränderliche Objekte </h2><br>  In Python gibt es zwei Arten von Objekten: <br><br><ol><li>  Unveränderliche Objekte (können nicht geändert werden); <br></li><li>  Änderbare Objekte (Änderungen vorbehalten). <br></li></ol><br>  Das Erkennen dieses Unterschieds ist der erste Schlüssel, um durch die Welt der Zeiger in Python zu reisen.  Hier ist eine Charakterisierung der Unveränderlichkeit einiger populärer Typen: <br><br><div class="scrollable-table"><table><tbody><tr><th width="400">  Typ <br></th><th width="400">  Unveränderlich? <br></th></tr><tr><td>  int <br></td><td>  Ja <br></td></tr><tr><td>  float <br></td><td>  Ja <br></td></tr><tr><td>  Bool <br></td><td>  Ja <br></td></tr><tr><td>  komplex <br></td><td>  Ja <br></td></tr><tr><td>  Tupel <br></td><td>  Ja <br></td></tr><tr><td>  Frozenset <br></td><td>  Ja <br></td></tr><tr><td>  str <br></td><td>  Ja <br></td></tr><tr><td>  Liste <br></td><td>  Nein <br></td></tr><tr><td>  einstellen <br></td><td>  Nein <br></td></tr><tr><td>  diktieren <br></td><td>  Nein <br></td></tr></tbody></table></div><br>  Wie Sie sehen können, sind viele der häufig verwendeten primitiven Typen unveränderlich.  Sie können dies überprüfen, indem Sie Python-Code schreiben.  Sie benötigen zwei Tools aus der Standardbibliothek: <br><br><ol><li>  <code>id()</code> gibt die Speicheradresse des Objekts zurück; <br></li><li>  <code>is</code> gibt nur dann <code>True</code> wenn zwei Objekte dieselbe Speicheradresse haben. <br></li></ol><br>  Sie können diesen Code in einer REPL-Umgebung ausführen: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">5</span></span> &gt;&gt;&gt; id(x) <span class="hljs-number"><span class="hljs-number">94529957049376</span></span></code> </pre> <br>  Hier setzen wir die Variable <code>x</code> auf <code>5</code> .  Wenn Sie versuchen, den Wert mithilfe von Addition zu ändern, erhalten Sie ein neues Objekt: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x += <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt;&gt; x <span class="hljs-number"><span class="hljs-number">6</span></span> &gt;&gt;&gt; id(x) <span class="hljs-number"><span class="hljs-number">94529957049408</span></span></code> </pre> <br>  Obwohl es den Anschein hat, dass dieser Code einfach den Wert von <code>x</code> ändert, erhalten Sie in Wirklichkeit ein <b>neues</b> Objekt als Antwort. <br><br>  Der <code>str</code> Typ ist ebenfalls unveränderlich: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>s = <span class="hljs-string"><span class="hljs-string">"real_python"</span></span> &gt;&gt;&gt; id(s) <span class="hljs-number"><span class="hljs-number">140637819584048</span></span> &gt;&gt;&gt; s += <span class="hljs-string"><span class="hljs-string">"_rocks"</span></span> &gt;&gt;&gt; s <span class="hljs-string"><span class="hljs-string">'real_python_rocks'</span></span> &gt;&gt;&gt; id(s) <span class="hljs-number"><span class="hljs-number">140637819609424</span></span></code> </pre> <br>  Und in diesem Fall erhält <code>s</code> nach Operation <code>+=</code> eine <b>andere</b> Speicheradresse. <br><br>  <b>Bonus</b> : Der Operator <code>+=</code> übersetzt in verschiedene Methodenaufrufe. <br><br>  Bei einigen Objekten, z. B. einer Liste, wird <code>+=</code> in <code>__iadd__()</code> konvertiert (lokaler Anhang).  Es ändert sich selbst und gibt dieselbe ID zurück.  <code>str</code> und <code>int</code> verfügen jedoch nicht über diese Methoden. Daher wird <code>__add__()</code> anstelle von <code>__iadd__()</code> aufgerufen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weitere Informationen finden Sie in der Dokumentation zum</a> Python- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenmodell</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.</a> <br><br>  Wenn wir versuchen, den Zeichenfolgenwert von <code>s</code> direkt zu ändern <code>s</code> wir eine Fehlermeldung: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>s[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-string"><span class="hljs-string">"R"</span></span></code> </pre> <br>  Rückverfolgung (die letzten Anrufe werden zuletzt angezeigt): <br><br><pre> <code class="python hljs"> File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;mdule&gt; TypeError: <span class="hljs-string"><span class="hljs-string">'str'</span></span> object does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> support item assignment</code> </pre> <br>  Der obige Code stürzt ab und Python meldet, dass <code>str</code> diese Änderung nicht unterstützt, was der Definition der Unveränderlichkeit vom Typ <code>str</code> . <br><br>  Vergleichen Sie mit einem veränderlichen Objekt, zum Beispiel mit einer Liste: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>my_list = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] &gt;&gt;&gt; id(my_list) <span class="hljs-number"><span class="hljs-number">140637819575368</span></span> &gt;&gt;&gt; my_list.append(<span class="hljs-number"><span class="hljs-number">4</span></span>) &gt;&gt;&gt; my_list [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] &gt;&gt;&gt; id(my_list) <span class="hljs-number"><span class="hljs-number">140637819575368</span></span></code> </pre> <br>  Dieser Code zeigt den Hauptunterschied zwischen den beiden Objekttypen.  Zu Beginn hat <code>my_list</code> eine ID.  Auch nach dem Hinzufügen von <code>4</code> zur Liste hat <code>my_list</code> <b>dieselbe</b> ID.  Der Grund ist, dass die Typliste veränderbar ist. <br><br>  Hier ist eine weitere Demonstration der Listenveränderlichkeit mithilfe der Zuweisung: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>my_list[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span> &gt;&gt;&gt; my_list [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] &gt;&gt;&gt; id(my_list) <span class="hljs-number"><span class="hljs-number">140637819575368</span></span></code> </pre> <br>  In diesem Code haben wir <code>my_list</code> geändert und als erstes Element auf <code>0</code> .  Die Liste behielt jedoch nach diesem Vorgang dieselbe ID bei.  Der nächste Schritt auf unserem Weg zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erlernen von Python</a> wird die Erforschung seines Ökosystems sein. <br><br><h2>  Wir beschäftigen uns mit Variablen </h2><br>  Variablen in Python unterscheiden sich grundlegend von Variablen in C und C ++.  Im Wesentlichen existieren sie in Python einfach nicht.  <b>Anstelle von Variablen gibt es Namen</b> . <br><br>  Es mag pedantisch klingen und ist es größtenteils.  Meistens können Sie Namen in Python als Variablen verwenden, aber Sie müssen den Unterschied verstehen.  Dies ist besonders wichtig, wenn Sie ein so schwieriges Thema wie Zeiger studieren. <br><br>  Um Ihnen das Verständnis zu erleichtern, sehen wir uns an, wie Variablen in C funktionieren, was sie darstellen, und vergleichen sie dann mit der Arbeit von Namen in Python. <br><br><h3>  Variablen in C. </h3><br>  Nehmen Sie den Code, der die Variable <code>x</code> definiert: <br><br><pre> <code class="python hljs">int x = <span class="hljs-number"><span class="hljs-number">2337</span></span>;</code> </pre> <br>  Die Ausführung dieser kurzen Zeile durchläuft verschiedene Phasen: <br><br><ol><li>  Zuweisen von genügend Speicher für eine Nummer. <br></li><li>  Zuordnung von <code>2337</code> zu diesem Speicherort. <br></li><li>  Die Zuordnung <code>x</code> gibt diesen Wert an. <br></li></ol><br>  Ein vereinfachter Speicher könnte folgendermaßen aussehen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f13/e62/d71/f13e62d71774b73aecff45931b6db57f.png"><br><br>  Hier hat die Variable <code>x</code> eine gefälschte Adresse von <code>0x7f1</code> und einen Wert von <code>2337</code> .  Wenn Sie später den Wert von <code>x</code> ändern möchten, können Sie dies tun: <br><br><pre> <code class="python hljs">x = <span class="hljs-number"><span class="hljs-number">2338</span></span>;</code> </pre> <br>  Dieser Code setzt die Variable <code>x</code> neuen Wert von <code>2338</code> , wodurch der <b>vorherige</b> Wert überschrieben wird.  Dies bedeutet, dass die Variable <code>x</code> <b>veränderbar ist</b> .  Aktualisiertes Speicherschema für den neuen Wert: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/347/491/19b/34749119bcba5c4009861aa4e7c40c45.png"><br><br>  Bitte beachten Sie, dass sich die Position von <code>x</code> nicht geändert <code>x</code> sondern nur der Wert selbst.  Es ist wichtig.  Dies sagt uns, dass <code>x</code> <b>ein Ort im Gedächtnis</b> ist und nicht nur ein Name. <br><br>  Sie können dieses Problem auch als Teil des Eigentumskonzepts betrachten.  Einerseits besitzt <code>x</code> einen Speicherplatz.  Erstens ist <code>x</code> ein leeres Feld, das nur eine Ganzzahl enthalten kann, in der Ganzzahlwerte gespeichert werden können. <br><br>  Wenn Sie <code>x</code> einen Wert zuweisen, geben Sie den Wert in ein Feld ein, das zu <code>x</code> .  Wenn Sie eine neue Variable <code>y</code> einführen möchten, können Sie diese Zeile hinzufügen: <br><br><pre> <code class="python hljs">int y = x;</code> </pre> <br>  Dieser Code erstellt ein neues Feld mit dem Namen <code>y</code> und kopiert den Wert von <code>x</code> in dieses Feld.  Jetzt sieht die Speicherschaltung folgendermaßen aus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/caa/74d/ed3/caa74ded301b1f527e1b94516f1b1196.png"><br><br>  Beachten Sie die neue Position <code>y</code> - <code>0x7f5</code> .  Obwohl der Wert <code>x</code> nach <code>x</code> kopiert wurde, besitzt die Variable <code>y</code> eine neue Adresse im Speicher.  Daher können Sie den Wert von <code>y</code> überschreiben, ohne <code>x</code> zu beeinflussen: <br><br><pre> <code class="python hljs">y = <span class="hljs-number"><span class="hljs-number">2339</span></span>;</code> </pre> <br>  Jetzt sieht die Speicherschaltung folgendermaßen aus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fcf/f8d/ed4/fcff8ded49647ad0053a45f0773cb4bb.png"><br><br>  Ich wiederhole: Sie haben den Wert von <code>y</code> geändert, aber nicht den Ort.  Außerdem haben Sie die ursprüngliche Variable <code>x</code> nicht beeinflusst. <br><br>  Bei Namen in Python ist die Situation völlig anders. <br><br><h3>  Namen in Python </h3><br>  In Python gibt es keine Variablen, stattdessen Namen.  Sie können den Begriff „Variablen“ nach eigenem Ermessen verwenden. Es ist jedoch wichtig, den Unterschied zwischen Variablen und Namen zu kennen. <br><br>  Nehmen wir den entsprechenden Code aus dem obigen C-Beispiel und schreiben ihn in Python: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">2337</span></span></code> </pre> <br>  Wie in C durchläuft der Code während der Ausführung mehrere separate Schritte: <br><br><ol><li>  PyObject wird erstellt. <br></li><li>  Der Nummer für PyObject wird ein Typcode zugewiesen. <br></li><li>  <code>2337</code> ein Wert für PyObject zugewiesen. <br></li><li>  Der Name <code>x</code> wird erstellt. </li><li>  <code>x</code> zeigt auf das neue PyObject. </li><li>  Der Referenzzähler von PyObject wird um 1 erhöht. <br></li></ol><br>  <b>Hinweis</b> : <a href="">PyObject</a> ist nicht dasselbe wie ein Objekt in Python. Diese Entität ist spezifisch für CPython und repräsentiert die Grundstruktur aller Python-Objekte. <br><br>  PyObject ist als C-Struktur definiert. Wenn Sie sich also fragen, warum Sie den Typcode oder den Referenzzähler nicht direkt aufrufen können, liegt der Grund darin, dass Sie keinen direkten Zugriff auf die Strukturen haben.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Aufrufen von</a> Methoden wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sys.getrefcount ()</a> kann dabei helfen, interne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalte abzurufen</a> . <br><br>  Wenn wir über Erinnerung sprechen, kann es so aussehen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9d9/ad7/932/9d9ad79327405315461e3880fe3db256.png"><br><br>  Hier unterscheidet sich die Speicherschaltung stark von der oben gezeigten Schaltung in C.  Anstatt <code>x</code> einen Speicherblock zu besitzen, in dem der Wert <code>2337</code> gespeichert ist, besitzt ein frisch erstelltes Python-Objekt den Speicher, in dem <code>2337</code> lebt.  Der Python-Name <code>x</code> besitzt <b>keine</b> Adresse im Speicher direkt, genau wie eine C-Variable eine statische Zelle besitzt. <br><br>  Wenn Sie <code>x</code> neuen Wert zuweisen möchten, versuchen Sie diesen Code: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">2338</span></span></code> </pre> <br>  Das Verhalten des Systems unterscheidet sich von dem in C, unterscheidet sich jedoch nicht zu stark von der ursprünglichen Bindung in Python. <br><br>  In diesem Code: <br><br><ul><li>  Ein neues PyObject wird erstellt. <br></li><li>  Der Nummer für PyObject wird ein Typcode zugewiesen. <br></li><li>  <code>2</code> ein Wert für PyObject zugewiesen. <br></li><li>  <code>x</code> zeigt auf das neue PyObject. <br></li><li>  Der Referenzzähler des neuen PyObject wird um 1 erhöht. <br></li><li>  Der Referenzzähler des alten PyObjects wird um 1 reduziert. <br></li></ul><br>  Jetzt sieht die Speicherschaltung folgendermaßen aus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/712/860/996/712860996aa37da34fdb69a466cdf5de.png"><br><br>  Diese Abbildung zeigt, dass <code>x</code> auf eine Referenz auf ein Objekt verweist und den Speicherbereich nicht wie zuvor besitzt.  Sie sehen auch, dass der Befehl <code>x = 2338</code> keine Zuweisung ist, sondern eine Bindung des Namens <code>x</code> an den Link. <br><br>  Außerdem befindet sich das vorherige Objekt (das den Wert <code>2337</code> ) jetzt mit einem Referenzzähler von 0 im Speicher und wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vom Garbage Collector entfernt</a> . <br><br>  Sie können einen neuen Namen <code>y</code> eingeben, wie im C-Beispiel: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>y = x</code> </pre> <br>  Ein neuer Name wird im Speicher angezeigt, aber nicht unbedingt ein neues Objekt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/958/adc/410/958adc41013bb5483f0526689a48a871.png"><br><br>  Jetzt sehen Sie, dass kein neues Python-Objekt erstellt wurde, <b>sondern</b> nur ein neuer Name, der auf dasselbe Objekt verweist.  Außerdem wurde der Objektreferenzzähler um 1 erhöht. Sie können die Äquivalenz der Identität von Objekten überprüfen, um deren Identität zu bestätigen: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>y <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  Dieser Code zeigt, dass <code>x</code> und <code>y</code> ein Objekt sind.  Aber machen Sie keinen Fehler: <code>y</code> ist immer noch unveränderlich.  Sie können beispielsweise eine Additionsoperation mit <code>y</code> ausführen: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>y += <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt;&gt; y <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br>  Nachdem der Zusatz aufgerufen wurde, geben Sie ein neues Python-Objekt zurück.  Jetzt sieht die Erinnerung so aus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8bd/abc/3e7/8bdabc3e7576ab86b00ba9c2b43b57b4.png"><br><br>  Ein neues Objekt wurde erstellt und <code>y</code> jetzt darauf.  Es ist merkwürdig, dass wir genau den gleichen Endzustand erhalten würden, wenn wir <code>y</code> direkt mit <code>2339</code> verknüpfen würden: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>y = <span class="hljs-number"><span class="hljs-number">2339</span></span></code> </pre> <br>  Nach diesem Ausdruck erhalten wir einen solchen endgültigen Speicherzustand wie bei der Additionsoperation.  Ich möchte Sie daran erinnern, dass Sie in Python keine Variablen zuweisen, sondern Namen an Links binden. <br><br><h3>  Über Praktikanten in Python </h3><br>  Jetzt verstehen Sie, wie neue Objekte in Python erstellt werden und wie Namen an sie angehängt werden.  Es ist Zeit, über internierte Objekte zu sprechen. <br><br>  Wir haben diesen Python-Code: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">1000</span></span> &gt;&gt;&gt; y = <span class="hljs-number"><span class="hljs-number">1000</span></span> &gt;&gt;&gt; x <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  Nach wie vor sind <code>x</code> und <code>y</code> Namen, die auf dasselbe Python-Objekt verweisen.  Dieses Objekt mit dem Wert <code>1000</code> kann jedoch nicht immer dieselbe Speicheradresse haben.  Wenn Sie beispielsweise zwei Zahlen addieren und 1000 erhalten, erhalten Sie eine andere Adresse: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">1000</span></span> &gt;&gt;&gt; y = <span class="hljs-number"><span class="hljs-number">499</span></span> + <span class="hljs-number"><span class="hljs-number">501</span></span> &gt;&gt;&gt; x <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br>  Diesmal gibt die Zeichenfolge <code>x is y</code> <code>False</code> .  Wenn Sie sich schämen, machen Sie sich keine Sorgen.  Folgendes passiert, wenn dieser Code ausgeführt wird: <br><br><ol><li>  Ein Python-Objekt wird erstellt ( <code>1000</code> ). <br></li><li>  Es wird der Name <code>x</code> . <br></li><li>  Ein Python-Objekt wird erstellt ( <code>499</code> ). <br></li><li>  Ein Python-Objekt wird erstellt ( <code>501</code> ). <br></li><li>  Diese beiden Objekte summieren sich. <br></li><li>  Ein neues Python-Objekt wird erstellt ( <code>1000</code> ). <br></li><li>  Er erhält den Namen <code>y</code> . <br></li></ol><br>  <b>Technische Erläuterungen</b> : Die beschriebenen Schritte finden nur statt, wenn dieser Code innerhalb der REPL ausgeführt wird.  Wenn Sie das obige Beispiel nehmen, es in die Datei einfügen und ausführen, gibt die Zeile <code>x is y</code> <code>True</code> . <br><br>  Der Grund ist der schnelle Verstand des CPython-Compilers, der versucht, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gucklochoptimierungen</a> durchzuführen, um die Codeausführungsschritte so weit wie möglich zu speichern.  Details finden Sie im <a href="">Quellcode des Peyphole Optimizer CPython</a> . <br><br>  Aber ist das nicht verschwenderisch?  Ja, aber Sie zahlen diesen Preis für alle Vorteile von Python.  Sie müssen nicht daran denken, solche Zwischenobjekte zu löschen, und Sie müssen nicht einmal über ihre Existenz Bescheid wissen!  Der Witz ist, dass diese Operationen relativ schnell ausgeführt werden und Sie bis zu diesem Moment nichts davon wissen würden. <br><br>  Die Entwickler von Python bemerkten diesen Aufwand mit Bedacht und beschlossen, mehrere Optimierungen vorzunehmen.  Ihr Ergebnis ist ein Verhalten, das Anfänger überraschen kann: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">20</span></span> &gt;&gt;&gt; y = <span class="hljs-number"><span class="hljs-number">19</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt;&gt; x <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  In diesem Beispiel ist der Code fast der gleiche wie oben, außer dass wir <code>True</code> .  Es geht um internierte Objekte.  Python erstellt eine bestimmte Teilmenge von Objekten im Speicher vorab und speichert sie für den täglichen Gebrauch im globalen Namespace. <br><br>  Welche Objekte hängen von der Python-Implementierung ab?  In CPython 3.7 sind Internierte: <br><br><ol><li>  Ganzzahlen im Bereich von <code>-5</code> bis <code>256</code> . <br></li><li>  Zeichenfolgen, die nur ASCII-Buchstaben, Zahlen oder Unterstriche enthalten. <br></li></ol><br>  Dies liegt daran, dass diese Variablen in vielen Programmen sehr häufig verwendet werden.  Durch das Internieren verhindert Python die Speicherzuweisung für persistente Objekte. <br><br>  Zeilen mit einer Größe von weniger als 20 Zeichen und ASCII-Buchstaben, -Zahlen oder -Unterstrichen werden interniert, da sie als Bezeichner verwendet werden sollen: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>s1 = <span class="hljs-string"><span class="hljs-string">"realpython"</span></span> &gt;&gt;&gt; id(s1) <span class="hljs-number"><span class="hljs-number">140696485006960</span></span> &gt;&gt;&gt; s2 = <span class="hljs-string"><span class="hljs-string">"realpython"</span></span> &gt;&gt;&gt; id(s2) <span class="hljs-number"><span class="hljs-number">140696485006960</span></span> &gt;&gt;&gt; s1 <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> s2 <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  Hier zeigen <code>s1</code> und <code>s2</code> auf dieselbe Adresse im Speicher.  Wenn wir keinen ASCII-Buchstaben, keine ASCII-Zahl oder keinen Unterstrich einfügen würden, würden wir ein anderes Ergebnis erhalten: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>s1 = <span class="hljs-string"><span class="hljs-string">"Real Python!"</span></span> &gt;&gt;&gt; s2 = <span class="hljs-string"><span class="hljs-string">"Real Python!"</span></span> &gt;&gt;&gt; s1 <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> s2 <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br>  In diesem Beispiel wird ein Ausrufezeichen verwendet, sodass die Zeichenfolgen nicht interniert sind und unterschiedliche Objekte im Speicher sind. <br><br>  <b>Bonus</b> : Wenn diese Objekte auf dasselbe internierte Objekt verweisen sollen, können Sie <code>sys.intern()</code> .  Eine Möglichkeit zur Verwendung dieser Funktion ist in der Dokumentation beschrieben: <br><br><blockquote>  Das Internieren von Zeichenfolgen ist nützlich, um die Leistung der Wörterbuchsuche leicht zu steigern: Wenn die Schlüssel im Wörterbuch und der zu durchsuchende Schlüssel interniert sind, können Schlüsselvergleiche (nach dem Hashing) durch Vergleichen von Zeigern anstelle von Zeichenfolgen durchgeführt werden.  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelle</a> ) </blockquote><br>  Internierte verwirren Programmierer oft.  Denken Sie daran, dass Sie im Zweifelsfall immer <code>id()</code> , um die Äquivalenz von Objekten zu bestimmen. <br><br><h2>  Python-Zeigeremulation </h2><br>  Die Tatsache, dass Zeiger in Python nativ fehlen, bedeutet nicht, dass Sie Zeiger nicht nutzen können.  Es gibt tatsächlich mehrere Möglichkeiten, Zeiger in Python zu emulieren.  Hier sehen wir uns zwei davon an: <br><br><ol><li>  Verwendung als Zeiger auf veränderbare Typen. <br></li><li>  Verwenden speziell vorbereiteter Python-Objekte. <br></li></ol><br><h3>  Verwendung als veränderbare Typzeiger </h3><br>  Sie wissen bereits, was veränderbare Typen sind.  Dank ihrer Veränderlichkeit können wir das Verhalten von Zeigern emulieren.  Angenommen, Sie müssen diesen Code replizieren: <br><br><pre> <code class="python hljs">void add_one(int *x) { *x += <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Dieser Code nimmt einen Zeiger auf eine Zahl ( <code>*x</code> ) und erhöht den Wert um 1. Hier ist die Hauptfunktion zum Ausführen des Codes: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdi.h&gt; int main(void) { int y = 2337; printf("y = %d\n", y); add_one(&amp;y); printf("y = %d\n", y); return 0; }</span></span></code> </pre> <br>  Im obigen Fragment haben wir <code>2337</code> <code>y</code> zugewiesen, den aktuellen Wert angezeigt, um 1 erhöht und dann einen neuen Wert angezeigt.  Auf dem Bildschirm wird Folgendes angezeigt: <br><br><pre> <code class="python hljs">y = <span class="hljs-number"><span class="hljs-number">2337</span></span> y = <span class="hljs-number"><span class="hljs-number">2338</span></span></code> </pre> <br>  Eine Möglichkeit, dieses Verhalten in Python zu replizieren, besteht darin, einen veränderlichen Typ zu verwenden.  Wenden Sie beispielsweise eine Liste an und ändern Sie das erste Element: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_one</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> ... x[<span class="hljs-number"><span class="hljs-number">0</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span> ... &gt;&gt;&gt; y = [<span class="hljs-number"><span class="hljs-number">2337</span></span>] &gt;&gt;&gt; add_one(y) &gt;&gt;&gt; y[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-number"><span class="hljs-number">2338</span></span></code> </pre> <br>  Hier bezieht sich <code>add_one(x)</code> auf das erste Element und erhöht seinen Wert um 1. Die Verwendung der Liste bedeutet, dass wir als Ergebnis den geänderten Wert erhalten.  Es gibt also Zeiger in Python?  Nein.  Das beschriebene Verhalten wurde möglich, weil die Liste ein veränderbarer Typ ist.  Wenn Sie versuchen, ein Tupel zu verwenden, wird folgende Fehlermeldung angezeigt: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>z = (<span class="hljs-number"><span class="hljs-number">2337</span></span>,) &gt;&gt;&gt; add_one(z)</code> </pre> <br>  Rückverfolgung (die letzten Anrufe gehen zuletzt): <br><br><pre> <code class="python hljs"> File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> add_one TypeError: <span class="hljs-string"><span class="hljs-string">'tuple'</span></span> object does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> support item assignment</code> </pre> <br>  Dieser Code demonstriert die Unveränderlichkeit des Tupels und unterstützt daher keine Elementzuweisung. <br><br>  <code>list</code> nicht der einzige veränderbare Typ, Teilzeiger werden auch mit <code>dict</code> emuliert. <br><br>  Angenommen, Sie haben eine Anwendung, die das Auftreten interessanter Ereignisse verfolgen soll.  Dies kann erreicht werden, indem ein Wörterbuch erstellt und eines seiner Elemente als Zähler verwendet wird: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>counters = {<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>} &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... counters[<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span> ... &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... counters[<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span> ... bar() ... &gt;&gt;&gt; foo() &gt;&gt;&gt; counters[<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>] <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  In diesem Beispiel verwendet das Wörterbuch Zähler, um die Anzahl der Funktionsaufrufe zu verfolgen.  Nach dem Aufruf von <code>foo()</code> erhöhte sich <code>foo()</code> Zähler erwartungsgemäß um 2.  Und das alles dank <code>dict</code> . <br><br>  Vergessen Sie nicht, dies ist nur eine <b>Emulation</b> des Zeigerverhaltens, es hat nichts mit echten Zeigern in C und C ++ zu tun.  Wir können sagen, dass diese Operationen teurer sind als wenn sie in C oder C ++ ausgeführt würden. <br><br><h3>  Verwenden von Python-Objekten </h3><br>  <code>dict</code> ist eine großartige Möglichkeit, Zeiger in Python zu emulieren, aber es ist manchmal mühsam, sich zu merken, welchen Schlüsselnamen Sie verwendet haben.  Insbesondere, wenn Sie das Wörterbuch in verschiedenen Teilen der Anwendung verwenden.  Eine benutzerdefinierte Python-Klasse kann hier helfen. <br><br>  Angenommen, Sie müssen Metriken in einer Anwendung verfolgen.  Eine gute Möglichkeit, nervige Details zu ignorieren, besteht darin, eine Klasse zu erstellen: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Metrics</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self._metrics = { <span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"cat_pictures_served"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, }</code> </pre> <br>  Dieser Code definiert die <code>Metrics</code> Klasse.  Das Wörterbuch wird weiterhin zum Speichern aktueller Daten verwendet, die in der Mitgliedsvariablen <code>_metrics</code> .  Dies gibt Ihnen die erforderliche Veränderlichkeit.  Jetzt müssen Sie nur noch auf diese Werte zugreifen.  Sie können dies mit den folgenden Eigenschaften tun: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Metrics</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... @property def func_calls(self): return self._metrics["func_calls"] @property def cat_pictures_served(self): return self._metrics["cat_pictures_served"]</span></span></code> </pre> <br>  Hier verwenden wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@property</a> .  Wenn Sie mit Dekorateuren noch nicht vertraut sind, lesen Sie den Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Primer on Python Decorators</a> .  In diesem Fall können Sie mit dem <code>@property</code> Dekorator auf <code>func_calls</code> und <code>cat_pictures_served</code> , als wären sie Attribute: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>metrics = Metrics() &gt;&gt;&gt; metrics.func_calls <span class="hljs-number"><span class="hljs-number">0</span></span> &gt;&gt;&gt; metrics.cat_pictures_served <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Die Tatsache, dass Sie diese Namen als Attribute bezeichnen können, bedeutet, dass Sie von der Tatsache abstrahiert sind, dass diese Werte im Wörterbuch gespeichert sind.  Außerdem machen Sie Attributnamen expliziter.  Natürlich sollten Sie in der Lage sein, die Werte zu erhöhen: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Metrics</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def inc_func_calls(self): self._metrics["func_calls"] += 1 def inc_cat_pics(self): self._metrics["cat_pictures_served"] += 1</span></span></code> </pre> <br>     : <br><br><ol><li> <code>inc_func_calls()</code> </li> <li> <code>inc_cat_pics()</code> </li> </ol><br>      <code>metrics</code> .     ,     ,   : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>metrics = Metrics() &gt;&gt;&gt; metrics.inc_func_calls() &gt;&gt;&gt; metrics.inc_func_calls() &gt;&gt;&gt; metrics.func_calls <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>     <code>func_calls</code>   <code>inc_func_calls()</code>         Python.    ,     -  <code>metrics</code> ,          . <br><br> <b></b> :   ,   <code>inc_func_calls()</code>  <code>inc_cat_pics()</code>   <code>@property.setter</code>        <code>int</code> ,     . <br><br>      <code>Metrics</code> : <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Metrics</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self._metrics = { <span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"cat_pictures_served"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, } @property <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func_calls</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._metrics[<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>] @property <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cat_pictures_served</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._metrics[<span class="hljs-string"><span class="hljs-string">"cat_pictures_served"</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inc_func_calls</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self._metrics[<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inc_cat_pics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self._metrics[<span class="hljs-string"><span class="hljs-string">"cat_pictures_served"</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><h2>     ctypes </h2><br>  , -    Python,   CPython?     ctypes    ,   C.      ctypes,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Extending Python With C Libraries and the «ctypes» Module</a> . <br><br>       ,     ,   .     - <code>add_one()</code> : <br><br><pre> <code class="python hljs">void add_one(int *x) { *x += <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br> ,      <code>x</code>  1.   ,      (shared) .  ,      <code>add.c</code> ,      gcc: <br><br><pre> <code class="python hljs">$ gcc -c -Wall -Werror -fpic add.c $ gcc -shared -o libadd1.so add.o</code> </pre> <br>      C   <code>add.o</code> .           <code>libadd1.so</code> . <br><br> <code>libadd1.so</code>      .    ctypes    Python: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ctypes &gt;&gt;&gt; add_lib = ctypes.CDLL(<span class="hljs-string"><span class="hljs-string">"./libadd1.so"</span></span>) &gt;&gt;&gt; add_lib.add_one &lt;_FuncPtr object at <span class="hljs-number"><span class="hljs-number">0x7f9f3b8852a0</span></span>&gt;</code> </pre> <br>  ctypes.CDLL  ,     <code>libadd1</code> .      <code>add_one()</code> ,      ,        Python-.     ,    .  Python  ,      . <br><br>         , ctypes       : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>add_one = add_lib.add_one &gt;&gt;&gt; add_one.argtypes = [ctypes.POINTER(ctypes.c_int)]</code> </pre> <br>     ,    C. ,        ,       : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>add_one(<span class="hljs-number"><span class="hljs-number">1</span></span>) Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; ctypes.ArgumentError: argument <span class="hljs-number"><span class="hljs-number">1</span></span>: &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeError</span></span></span><span class="hljs-class">'&gt;:</span></span> \ expected LP_c_int instance instead of int</code> </pre> <br> Python    ,  <code>add_one()</code>   ,     .  ,  ctypes      .       : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = ctypes.c_int() &gt;&gt;&gt; x c_int(<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>      <code>x</code>   <code>0</code> . ctypes    <code>byref()</code> ,      . <br><br> <b></b> :  <b> </b>     <b> </b> . <br><br>          ,       .         ,        . <br><br>   <code>add_one()</code>    : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>add_one(ctypes.byref(x)) <span class="hljs-number"><span class="hljs-number">998793640</span></span> &gt;&gt;&gt; x c_int(<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Großartig!     1. ,     Python  . <br><br><h2>  Fazit </h2><br>        Python  .          ,              Python. <br><br>         Python: <br><br><ul><li>          . <br></li><li>   Python-   . <br></li><li>       ctypes. <br></li></ul><br>       Python       . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454324/">https://habr.com/ru/post/de454324/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454314/index.html">10 Prinzipien der objektorientierten Programmierung, die jeder Entwickler kennen sollte</a></li>
<li><a href="../de454316/index.html">Auf den Spuren des industriellen Ninja: Wir laden Sie ein, am Online-Wettbewerb für Arbeitssicherheit teilzunehmen</a></li>
<li><a href="../de454318/index.html">Die Vergangenheit klingen lassen. Ein Leitfaden für Historiker zur Konvertierung von Daten in Ton</a></li>
<li><a href="../de454320/index.html">Arbeitsmarktanalysten und Datenwissenschaftler</a></li>
<li><a href="../de454322/index.html">Einige sagen, dass die DANE-Technologie für Browser fehlgeschlagen ist</a></li>
<li><a href="../de454326/index.html">Neben Moore - der sonst die Gesetze zur Skalierung von Computersystemen formulierte</a></li>
<li><a href="../de454330/index.html">10 Highlights von TechTrain 2018: KI für die Massen, Schnittstellen und mehr</a></li>
<li><a href="../de454332/index.html">Wie der Telegramm-Bot den Aufschub der Designer überwunden und zur Steigerung der Einnahmen aus digitalen Agenturen beigetragen hat</a></li>
<li><a href="../de454334/index.html">Moto. Weinen Sie AWS</a></li>
<li><a href="../de454336/index.html">Kunde: - Wie viel kostet eine Kopie von Facebook?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>