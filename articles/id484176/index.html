<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨â€ğŸ« ğŸ˜‚ ğŸ’¥ Menerapkan Template Status dalam Persatuan ğŸ‘²ğŸ¾ ğŸ“­ ğŸŒ²</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam proses pemrograman entitas dalam game, situasi muncul ketika mereka harus bertindak dalam kondisi yang berbeda dengan cara yang berbeda, yang me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menerapkan Template Status dalam Persatuan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484176/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4fa/bf6/c19/4fabf6c19761d028d621903401a84746.png" alt="gambar"></div><br>  Dalam proses pemrograman entitas dalam game, situasi muncul ketika mereka harus bertindak dalam kondisi yang berbeda dengan cara yang berbeda, yang menunjukkan penggunaan <i>negara</i> . <br><br>  Tetapi jika Anda memutuskan untuk menggunakan kekerasan, kode akan dengan cepat berubah menjadi kekacauan kusut dengan banyak pernyataan if-else bersarang. <br><br>  Untuk solusi anggun untuk masalah ini, Anda dapat menggunakan pola desain State.  Kami akan mendedikasikan tutorial ini untuknya! <br><br>  Dari tutorial Anda: <br><br><ul><li>  Pelajari dasar-dasar templat Negara di Unity. </li><li>  Anda akan belajar apa itu mesin negara dan kapan menggunakannya. </li><li>  Pelajari cara menggunakan konsep-konsep ini untuk mengontrol pergerakan karakter Anda. </li></ul><br><blockquote>  <em>Catatan</em> : tutorial ini untuk pengguna tingkat lanjut;  diasumsikan bahwa Anda sudah tahu cara bekerja di Unity dan memiliki tingkat rata-rata pengetahuan C #.  Selain itu, tutorial ini menggunakan Unity 2019.2 dan C # 7. </blockquote><a name="habracut"></a><br><h2>  Mulai bekerja </h2><br>  Unduh <a href="">materi proyek</a> .  Buka <em>zip file zip</em> dan buka proyek <em>starter</em> di Unity. <br><br>  Ada beberapa folder dalam proyek yang akan membantu Anda memulai.  Folder <em>Aset / RW</em> berisi folder <em>Animasi</em> , <em>Bahan</em> , <em>Model</em> , <em>Rak itan</em> , <em>Sumber Daya</em> , <em>Adegan</em> , <em>Skrip,</em> dan <em>Suara</em> , dinamai sesuai dengan sumber daya yang dikandungnya. <br><br>  Untuk menyelesaikan tutorial, kami hanya akan bekerja dengan <em>Adegan</em> dan <em>Skrip</em> . <br><br>  Pergi ke <em>RW / Adegan</em> dan buka <em>Main</em> .  Dalam mode Game, Anda akan melihat karakter di tudung di dalam kastil abad pertengahan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/478/f1b/4e1/478f1b4e1ec3a2e8702e365e4082a605.png"></div><br>  Klik <em>Play</em> dan perhatikan bagaimana <em>Kamera</em> bergerak agar sesuai dengan bingkai <em>Karakter</em> .  Saat ini, dalam permainan kecil kami tidak ada interaksi, kami akan mengerjakannya dalam tutorial. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba3/62c/536/ba362c53682371294f90576b5fd5adc6.gif"></div><br><h2>  Jelajahi karakter </h2><br>  Dalam <em>hierarki,</em> pilih <em>Karakter</em> .  Periksa <em>Inspektur</em> .  Anda akan melihat <em>komponen</em> dengan nama yang sama berisi logika kontrol <em>karakter</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/957/ffd/2ba/957ffd2ba0299d4b509b75bedb094581.png"></div><br>  Buka <em>Character.cs yang</em> terletak di <em>RW / Script</em> . <br><br>  Script melakukan banyak tindakan, tetapi sebagian besar tidak penting bagi kami.  Untuk saat ini, mari kita perhatikan metode-metode berikut. <br><br><ul><li> <code>Move</code> : bergerak karakter, menerima nilai <code>speed</code> tipe float sebagai kecepatan gerakan dan <code>rotationSpeed</code> , Kecepatan sebagai kecepatan sudut. </li><li>  <code>ResetMoveParams</code> : metode ini mengatur ulang parameter yang digunakan untuk <i>menghidupkan gerakan</i> dan kecepatan sudut karakter.  Ini digunakan hanya untuk membersihkan. </li><li>  <code>SetAnimationBool</code> : Ini mengatur <code>param</code> animasi <code>param</code> dari tipe Bool ke nilai. </li><li>  <code>CheckCollisionOverlap</code> : menerima <code></code> bertipe <code>Vector3</code> dan mengembalikan <code>bool</code> yang menentukan apakah ada colliders dalam radius yang ditentukan dari <code></code> . </li><li>  <code>TriggerAnimation</code> : <code>TriggerAnimation</code> parameter animasi parameter input. </li><li>  <code>ApplyImpulse</code> : <code>ApplyImpulse</code> pulsa ke Karakter sama dengan <code>force</code> parameter input tipe <code>Vector3</code> . </li></ul><br>  Di bawah ini Anda akan melihat metode ini.  Dalam tutorial kami, konten dan pekerjaan internal mereka tidak penting. <br><br><h2>  Apa itu mesin negara </h2><br>  Mesin negara adalah konsep di mana sebuah wadah menyimpan keadaan sesuatu pada saat tertentu.  Berdasarkan data input, ini dapat memberikan kesimpulan tergantung pada kondisi saat ini, meneruskan proses ini ke status baru.  Mesin negara dapat direpresentasikan sebagai <a href="https://www.geeksforgeeks.org/unified-modeling-language-uml-state-diagrams/" rel="noopener">diagram keadaan</a> .  Mempersiapkan diagram keadaan memungkinkan Anda untuk memikirkan semua kondisi sistem yang mungkin dan transisi di antara mereka. <br><br><h3>  Mesin negara </h3><br>  <em>Mesin negara terbatas</em> atau <em>FSM (mesin negara terbatas)</em> adalah salah satu dari empat keluarga utama <em>mesin</em> .  Automata adalah model abstrak dari mesin sederhana.  Mereka dipelajari dalam kerangka <a href="https://cs.stanford.edu/people/eroberts/courses/soco/projects/2004-05/automata-theory/basics.html" rel="noopener"><em>teori automata</em></a> - cabang teori ilmu komputer. <br><br>  Singkatnya: <br><br><ul><li>  FSM terdiri dari sejumlah <em>kondisi yang</em> terbatas.  Pada waktu tertentu <em>,</em> hanya satu dari kondisi ini yang <em>aktif</em> . </li><li>  Setiap negara menentukan ke negara mana ia akan masuk sebagai <em>output</em> berdasarkan urutan yang diterima dari <em>informasi yang masuk</em> . </li><li>  Status output menjadi status aktif baru.  Dengan kata lain, ada <em>transisi antar negara</em> . </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c43/111/f04/c43111f045f3727ab5f3b02c05c6ecc2.png"></div><br>  Untuk lebih memahami hal ini, pertimbangkan karakter permainan platform yang ada di tanah.  Karakter dalam status <i>Berdiri</i> .  Ini akan menjadi <em>status aktifnya</em> hingga pemain menekan tombol sehingga karakter melompat. <br><br>  Status <i>Berdiri</i> mengidentifikasi tombol yang ditekan sebagai <em>input</em> signifikan dan, sebagai <em>output</em> , beralih ke status <i>Jumping</i> . <br><br>  Misalkan ada sejumlah keadaan gerak tertentu dan satu karakter hanya dapat berada di salah satu keadaan pada suatu waktu.  Ini adalah contoh FSM. <br><br><h3>  Mesin negara hirarkis </h3><br>  Pertimbangkan platformer menggunakan FSM, di mana beberapa negara bagian berbagi logika fisika umum.  Misalnya, Anda bisa bergerak dan melompat di status <em>Crouching</em> dan <em>Standing</em> .  Dalam hal ini, beberapa variabel yang masuk mengarah ke perilaku yang sama dan keluaran informasi untuk dua keadaan yang berbeda. <br><br>  Dalam situasi seperti itu, adalah logis untuk mendelegasikan perilaku umum ke beberapa negara lain.  Untungnya, ini dapat dicapai dengan menggunakan mesin negara <em>hierarkis</em> . <br><br>  Dalam FSM hirarkis, ada <em>substate</em> mendelegasikan informasi masuk <i>mentah</i> ke <em>substrat</em> mereka.  Ini pada gilirannya memungkinkan Anda untuk dengan anggun mengurangi ukuran dan kompleksitas FSM, sambil mempertahankan logikanya. <br><br><h2>  Template Status </h2><br>  Dalam buku mereka <i>Design Patterns: Elements of Reusable Object-Oriented Software,</i> Erich Gamma, Richard Helm, Ralph Johnson dan John Vlissidis ( <em>Geng Empat</em> ) mendefinisikan <i>tugas</i> templat Negara sebagai berikut: <br><br>  â€œDia harus membiarkan objek mengubah perilakunya ketika keadaan internalnya berubah.  Dalam hal ini, akan terlihat bahwa objek telah mengubah kelasnya. " <br><br>  Untuk lebih memahami ini, perhatikan contoh berikut: <br><br><ul><li>  Sebuah skrip yang menerima informasi yang masuk untuk logika pergerakan dilampirkan ke entitas dalam game. </li><li>  Kelas ini menyimpan variabel <i>status saat ini</i> yang hanya merujuk ke instance kelas <i>negara</i> . </li><li>  Informasi yang masuk didelegasikan ke keadaan saat ini, yang memprosesnya dan menciptakan perilaku yang didefinisikan dalam dirinya sendiri.  Ini juga menangani transisi negara yang diperlukan. </li></ul><br>  Oleh karena itu, karena fakta bahwa pada waktu yang berbeda, variabel <i>state saat ini</i> merujuk ke state yang berbeda, akan terlihat bahwa kelas skrip yang sama berperilaku berbeda.  Ini adalah inti dari templat "Status". <br><br>  Dalam proyek kami, kelas <em>Karakter yang</em> disebutkan di atas akan berperilaku berbeda tergantung pada keadaan yang berbeda.  Tapi kita butuh dia untuk berperilaku sendiri! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d8/d20/f59/3d8d20f5921bf342b2ac84b5677e9a3b.png"></div><br>  Dalam kasus umum, ada tiga poin utama untuk setiap kelas negara yang memungkinkan perilaku negara secara keseluruhan: <br><br><ul><li>  <em>Entri</em> : ini adalah saat ketika entitas memasuki negara dan melakukan tindakan yang perlu dilakukan hanya sekali ketika memasuki negara. </li><li>  <em>Keluar</em> : mirip dengan input - semua operasi reset dilakukan di sini, yang harus dilakukan hanya sebelum keadaan berubah. </li><li>  <em>Perbarui Loop</em> : Berikut adalah <i>logika pembaruan</i> dasar yang berjalan di setiap frame.  Ini dapat dibagi menjadi beberapa bagian, misalnya, siklus untuk memperbarui fisika dan siklus untuk memproses input pemain. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a26/847/8e6/a268478e6da2566cc58d1083fefed27f.png"></div><br><h3>  Mendefinisikan state and state machine </h3><br>  Pergi ke <em>RW / Script</em> dan buka <em>StateMachine.cs</em> . <br><br>  <em>Mesin Negara</em> , seperti yang Anda duga, memberikan abstraksi untuk mesin negara.  Perhatikan bahwa <code>CurrentState</code> terletak dengan benar di dalam kelas ini.  Ini akan menyimpan tautan ke status mesin aktif saat ini. <br><br>  Sekarang, untuk mendefinisikan konsep <i>negara</i> , mari kita pergi ke <em>RW / Script</em> dan buka script <em>State.cs</em> di IDE. <br><br>  <em>State</em> adalah kelas abstrak yang akan kita gunakan sebagai <i>model</i> dari mana semua <i>kelas status</i> proyek diturunkan.  Sebagian kode dalam materi proyek sudah siap. <br><br>  <code>DisplayOnUI</code> hanya menampilkan nama status saat ini di UI di layar.  Anda tidak perlu mengetahui perangkat internalnya, cukup pahami bahwa ia menerima enumerator dari jenis <code>UIManager.Alignment</code> sebagai parameter input, yang bisa <code>Left</code> atau <code>Right</code> .  Tampilan nama status di kiri bawah atau kanan layar tergantung padanya. <br><br>  Selain itu, ada dua variabel yang dilindungi, <code>character</code> dan <code>stateMachine</code> .  Variabel <code>character</code> merujuk ke turunan dari kelas <em>Karakter</em> , dan <code>stateMachine</code> merujuk ke turunan <em>dari mesin keadaan yang</em> terkait dengan keadaan. <br><br>  Saat membuat instance keadaan, konstruktor mengikat <code>character</code> dan <code>stateMachine</code> . <br><br>  Masing-masing dari banyak contoh <code>Character</code> dalam sebuah adegan dapat memiliki set negara dan mesin negara sendiri. <br><br>  Sekarang tambahkan metode berikut ke <em>State.cs</em> dan simpan file: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { DisplayOnUI(UIManager.Alignment.Left); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogicUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PhysicsUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Exit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { }</code> </pre> <br>  Metode virtual ini menentukan poin status kunci yang dijelaskan di atas.  Ketika <em>mesin status</em> melakukan transisi antar status, kami memanggil <code>Exit</code> untuk status sebelumnya dan <code>Enter</code> <i>status aktif</i> baru. <br><br>  <code>HandleInput</code> , <code>LogicUpdate</code> dan <code>PhysicsUpdate</code> bersama-sama menentukan <i>loop pembaruan</i> .  <code>HandleInput</code> menangani input pemain.  <code>LogicUpdate</code> memproses logika dasar, sementara <code>PhyiscsUpdate</code> memproses perhitungan logika dan fisika. <br><br>  Sekarang buka <em>StateMachine.cs</em> lagi, tambahkan metode berikut dan simpan file: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">State startingState</span></span></span><span class="hljs-function">)</span></span> { CurrentState = startingState; startingState.Enter(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeState</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">State newState</span></span></span><span class="hljs-function">)</span></span> { CurrentState.Exit(); CurrentState = newState; newState.Enter(); }</code> </pre> <br>  <code>Initialize</code> mengkonfigurasi mesin keadaan dengan mengatur <code>CurrentState</code> untuk <code>CurrentState</code> dan memanggil <code>Enter</code> untuk itu.  Ini menginisialisasi mesin keadaan, untuk pertama kalinya mengatur keadaan aktif. <br><br>  <code>ChangeState</code> menangani transisi <em>keadaan</em> .  Itu panggilan <code>Exit</code> untuk <code>CurrentState</code> lama sebelum mengganti referensi dengan <code>newState</code> .  Pada akhirnya, ia memanggil <code>Enter</code> untuk <code>newState</code> . <br><br>  Jadi, kami mengatur <em>negara</em> dan <em>mesin negara</em> . <br><br><h3>  Menciptakan kondisi gerak </h3><br>  Lihatlah diagram keadaan berikut, yang menunjukkan berbagai kondisi <i>pergerakan</i> esensi dalam gim pemain.  Di bagian ini, kami menerapkan template "Status" untuk <i>gerakan yang</i> ditunjukkan pada gambar <i>FSM</i> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4fa/bf6/c19/4fabf6c19761d028d621903401a84746.png"></div><br>  Perhatikan status gerakan, yaitu <em>Standing</em> , <em>Ducking</em> dan <em>Jumping</em> , serta bagaimana data yang masuk menyebabkan transisi antar negara.  Ini adalah FSM hierarkis di mana <em>Grounded</em> adalah sub-negara bagian untuk sub-state <em>Ducking</em> dan <em>Standing</em> . <br><br>  Kembali ke Unity dan pergi ke <em>RW / Scripts / States</em> .  Di sana Anda akan menemukan beberapa file C # dengan nama yang berakhir dengan <i>Negara</i> . <br><br>  Masing-masing file ini mendefinisikan satu kelas, yang masing-masing diwarisi dari <code>State</code> .  Oleh karena itu, kelas-kelas ini mendefinisikan status yang akan kita gunakan dalam proyek. <br><br>  Sekarang buka <em>Character.cs</em> dari folder <em>RW / Scripts</em> . <br><br>  Gulir di atas file <code>#region Variables</code> dan tambahkan kode berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> StateMachine movementSM; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> StandingState standing; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DuckingState ducking; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> JumpingState jumping;</code> </pre> <br>  <code>movementSM</code> ini mengacu pada mesin keadaan yang memproses logika gerak untuk instance <code>Character</code> .  Kami juga menambahkan tautan ke tiga negara bagian yang kami terapkan untuk setiap jenis gerakan. <br><br>  Pergi ke <code>#region MonoBehaviour Callbacks</code> dalam file yang sama.  Tambahkan metode <a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.html" rel="noopener">MonoBehaviour</a> berikut dan kemudian simpan <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { movementSM = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StateMachine(); standing = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StandingState(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, movementSM); ducking = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DuckingState(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, movementSM); jumping = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JumpingState(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, movementSM); movementSM.Initialize(standing); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { movementSM.CurrentState.HandleInput(); movementSM.CurrentState.LogicUpdate(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FixedUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { movementSM.CurrentState.PhysicsUpdate(); }</code> </pre> <br><ul><li>  Dalam <code>Start</code> kode menciptakan turunan dari <em>Mesin Negara</em> dan menugaskannya untuk <code>movementSM</code> , dan juga instantiates berbagai gerak negara.  Saat membuat setiap status gerakan, kami meneruskan referensi ke instance <code>Character</code> menggunakan <code>this</code> , serta instance <code>movementSM</code> .  Pada akhirnya, kami memanggil <code>Initialize</code> untuk <code>movementSM</code> dan lulus <code>Standing</code> sebagai keadaan awal. </li><li>  Dalam metode <code>Update</code> , kami memanggil <code>HandleInput</code> dan <code>LogicUpdate</code> untuk <code>CurrentState</code> dari mesin <code>movementSM</code> .  Demikian pula, di <code>FixedUpdate</code> kami memanggil <code>PhysicsUpdate</code> untuk <code>CurrentState</code> dari mesin <code>movementSM</code> .  Intinya, ini mendelegasikan tugas ke keadaan aktif;  ini adalah arti dari templat â€œStatusâ€. </li></ul><br>  Sekarang kita perlu mengatur perilaku di dalam masing-masing kondisi gerak.  Bersiaplah, akan ada banyak kode! <br><br><h3>  Perusahaan yang Berdiri </h3><br>  Kembali ke <em>RW / Script / Negara</em> di jendela Proyek. <br><br>  Buka <em>Grounded.cs</em> dan perhatikan bahwa kelas ini memiliki konstruktor yang cocok dengan konstruktor <code>State</code> .  Ini logis karena kelas ini mewarisi darinya.  Anda akan melihat hal yang sama di semua kelas <i>negara bagian</i> lainnya. <br><br>  Tambahkan kode berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.Enter(); horizontalInput = verticalInput = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Exit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.Exit(); character.ResetMoveParams(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.HandleInput(); verticalInput = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Vertical"</span></span>); horizontalInput = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Horizontal"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PhysicsUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.PhysicsUpdate(); character.Move(verticalInput * speed, horizontalInput * rotationSpeed); }</code> </pre> <br>  Inilah yang terjadi di sini: <br><br><ul><li>  Kami mendefinisikan kembali salah satu metode virtual yang didefinisikan di kelas induk.  Untuk mempertahankan semua fungsi yang mungkin ada di induk, kami memanggil metode <code>base</code> dengan nama yang sama dari setiap metode yang diganti.  Ini adalah templat penting yang akan terus kami gunakan. </li><li>  Baris berikutnya, <code>Enter</code> set <code>horizontalInput</code> dan <code>verticalInput</code> nilai standarnya. </li><li>  Di dalam <code>Exit</code> kami, seperti yang disebutkan di atas, memanggil metode <code>ResetMoveParams</code> <code></code> untuk mengatur ulang ketika mengubah ke keadaan lain. </li><li>  Dalam metode <code>HandleInput</code> , variabel <code>horizontalInput</code> dan <code>verticalInput</code> <code>HandleInput</code> nilai <code>HandleInput</code> nilai sumbu input horisontal dan vertikal.  Berkat ini, pemain dapat mengontrol karakter menggunakan tombol <em>W</em> , <em>A</em> , <em>S</em> dan <em>D.</em> </li><li>  Di <code>PhysicsUpdate</code> kami membuat panggilan <code>Move</code> , melewati variabel <code>PhysicsUpdate</code> <code>horizontalInput</code> dan <code>verticalInput</code> dikalikan dengan kecepatan yang sesuai.  Dalam <code>speed</code> variabel <code>speed</code> kecepatan gerakan disimpan, dan dalam <code>rotationSpeed</code> , kecepatan sudut. </li></ul><br>  Sekarang buka <em>Standing.cs</em> dan perhatikan fakta bahwa ia mewarisi dari <code>Grounded</code> .  Itu terjadi karena, seperti yang kami katakan di atas, <em>Berdiri</em> adalah substrat untuk <em>Grounded</em> .  Ada berbagai cara untuk menerapkan hubungan ini, tetapi dalam tutorial ini kami menggunakan warisan. <br><br>  Tambahkan metode <code>override</code> berikut dan simpan skrip: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.Enter(); speed = character.MovementSpeed; rotationSpeed = character.RotationSpeed; crouch = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; jump = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.HandleInput(); crouch = Input.GetButtonDown(<span class="hljs-string"><span class="hljs-string">"Fire3"</span></span>); jump = Input.GetButtonDown(<span class="hljs-string"><span class="hljs-string">"Jump"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogicUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.LogicUpdate(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (crouch) { stateMachine.ChangeState(character.ducking); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (jump) { stateMachine.ChangeState(character.jumping); } }</code> </pre> <br><ul><li>  Di <code>Enter</code> kami mengonfigurasi variabel yang diwarisi dari <code>Grounded</code> .  Menerapkan <code>MovementSpeed</code> dan <code>RotationSpeed</code> karakter ke <code>speed</code> dan <code>rotationSpeed</code> .  Kemudian mereka berhubungan, masing-masing, dengan kecepatan gerakan <i>normal</i> dan kecepatan sudut yang dimaksudkan untuk esensi karakter. <br><br>  Selain itu, variabel untuk menyimpan input <code>crouch</code> dan <code>jump</code> diatur ulang ke false. </li><li>  Di dalam <code>HandleInput</code> , variabel <code>crouch</code> dan <code>jump</code> menyimpan input pemain untuk squat dan lompatan.  Jika dalam adegan Utama pemain menekan tombol <em>Shift,</em> squat diatur ke true.  Demikian pula, pemain dapat menggunakan tombol <em>Space</em> untuk <code>jump</code> . </li><li>  Di <code>LogicUpdate</code> kami memeriksa <code>crouch</code> dan <code>jump</code> variabel dari tipe <code>bool</code> .  Jika <code>crouch</code> benar, maka <code>movementSM.CurrentState</code> berubah ke <code>character.ducking</code> .  Jika <code>jump</code> benar, maka status berubah menjadi <code>character.jumping</code> . </li></ul><br>  Simpan dan rakit proyek, lalu klik <em>Play</em> .  Anda dapat bergerak di sekitar layar menggunakan tombol <em>W</em> , <em>A</em> , <em>S</em> dan <em>D.</em>  Jika Anda mencoba menekan <em>Shift</em> atau <em>Spasi</em> , perilaku tak terduga akan terjadi, karena status yang sesuai belum diterapkan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/450/89a/564/45089a5640a8d492b20ac5948e0fdf69.gif"></div><br>  Cobalah bergerak di bawah objek tabel.  Anda akan melihat bahwa karena ketinggian karakter collider ini tidak mungkin.  Agar karakter melakukan ini, tambahkan perilaku squat. <br><br><h3>  Kami memanjat di bawah meja </h3><br>  Buka skrip <em>Ducking.cs</em> .  Perhatikan bahwa <code>Ducking</code> juga mewarisi dari kelas <code>Grounded</code> untuk alasan yang sama seperti <code>Standing</code> .  Tambahkan metode <code>override</code> berikut dan simpan skrip: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.Enter(); character.SetAnimationBool(character.crouchParam, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); speed = character.CrouchSpeed; rotationSpeed = character.CrouchRotationSpeed; character.ColliderSize = character.CrouchColliderHeight; belowCeiling = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Exit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.Exit(); character.SetAnimationBool(character.crouchParam, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); character.ColliderSize = character.NormalColliderHeight; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.HandleInput(); crouchHeld = Input.GetButton(<span class="hljs-string"><span class="hljs-string">"Fire3"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogicUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.LogicUpdate(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(crouchHeld || belowCeiling)) { stateMachine.ChangeState(character.standing); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PhysicsUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.PhysicsUpdate(); belowCeiling = character.CheckCollisionOverlap(character.transform.position + Vector3.up * character.NormalColliderHeight); }</code> </pre> <br><ul><li>  Di dalam <code>Enter</code> parameter yang menyebabkan matikan animasi jongkok diatur ke jongkok, yang memungkinkan animasi jongkok.  Properti <code>character.CrouchSpeed</code> dan <code>character.CrouchRotationSpeed</code> diberi nilai <code>speed</code> dan <code>rotation</code> , yang mengembalikan gerakan karakter dan kecepatan sudut saat <i>bergerak dalam squat</i> . <br><br>  <code>character.CrouchColliderHeight</code> berikutnya.CrouchColliderHeight menetapkan ukuran collider karakter, yang mengembalikan tinggi collider yang diinginkan saat jongkok.  Pada akhirnya, <code>belowCeiling</code> direset ke false. </li><li>  Di dalam <code>Exit</code> parameter animasi jongkok diatur ke false.  Ini menonaktifkan animasi squat.  Kemudian ketinggian collider normal diatur, dikembalikan oleh <code>character.NormalColliderHeight</code> . <code>character.NormalColliderHeight</code> . </li><li>  Di dalam <code>HandleInput</code> variabel menetapkan nilai input pemain.  Di adegan <em>Utama</em> , memegang <em>Shift</em> set <code>crouchHeld</code> menjadi true. </li><li>  Di dalam <code>PhysicsUpdate</code> variabel <code>belowCeiling</code> diberi nilai dengan melewati titik dalam format <code>Vector3</code> dengan kepala objek game karakter ke metode <code>CheckCollisionOverlap</code> .  Jika ada tabrakan di dekat titik ini, maka ini berarti bahwa karakter berada di bawah semacam langit-langit. </li><li>  Secara internal, <code>LogicUpdate</code> memeriksa apakah <code>crouchHeld</code> atau <code>belowCeiling</code> benar.  Jika tidak ada yang benar, maka <code>movementSM.CurrentState</code> berubah menjadi <code>character.standing</code> . </li></ul><br>  Bangun proyek dan klik <em>Play</em> .  Sekarang Anda dapat bergerak di sekitar tempat kejadian.  Jika Anda menekan <em>Shift</em> , karakter akan duduk dan Anda dapat bergerak dalam squat. <br><br>  Anda juga bisa naik di bawah platform.  Jika Anda melepaskan <em>Shift</em> saat berada di bawah platform, karakter akan tetap berada dalam squat hingga ia meninggalkan tempat perlindungannya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee4/dce/657/ee4dce657ae6be49244106652a168a3a.gif"></div><br><h3>  Melambunglah! </h3><br>  Buka <em>Jumping.cs</em> .  Anda akan melihat metode yang disebut <code>Jump</code> .  Jangan khawatir tentang cara kerjanya;  itu cukup untuk memahami bahwa itu digunakan sehingga karakter dapat melompat dengan memperhitungkan fisika dan animasi. <br><br>  Sekarang tambahkan metode <code>override</code> biasa dan simpan skrip <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.Enter(); SoundManager.Instance.PlaySound(SoundManager.Instance.jumpSounds); grounded = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; Jump(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogicUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.LogicUpdate(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grounded) { character.TriggerAnimation(landParam); SoundManager.Instance.PlaySound(SoundManager.Instance.landing); stateMachine.ChangeState(character.standing); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PhysicsUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.PhysicsUpdate(); grounded = character.CheckCollisionOverlap(character.transform.position); }</code> </pre> <br><ul><li>  Di dalam <code>Enter</code> <code>SoundManager</code> singleton memainkan suara lompatan.  Kemudian <code>grounded</code> reset ke nilai standarnya.  Pada akhirnya, <code>Jump</code> dipanggil. </li><li>  Di dalam <code>PhysicsUpdate</code> titik <code>PhysicsUpdate</code> sebelah kaki karakter dikirim ke <code>CheckCollisionOverlap</code> , yang berarti bahwa ketika karakter berada di tanah, <code>grounded</code> akan disetel ke true. </li><li>  Di <code>LogicUpdate</code> , jika <code>grounded</code> benar, kami memanggil <code>TriggerAnimation</code> untuk mengaktifkan animasi touchdown, suara touchdown dimainkan, dan <code>movementSM.CurrentState</code> <code>TriggerAnimation</code> berubah menjadi <code>character.standing</code> . </li></ul><br>  Jadi, dalam hal ini kami telah menyelesaikan implementasi penuh perpindahan FSM menggunakan <em>templat â€œNegaraâ€</em> .  Bangun proyek dan jalankan.  Tekan <em>Spasi</em> untuk membuat karakter melompat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebd/e16/05d/ebde1605dc739588529c51509e19c0a8.gif"></div><br><h2>  Ke mana harus pergi selanjutnya? </h2><br>  <a href="">Bahan</a> - <a href="">bahan proyek</a> memiliki rancangan proyek dan proyek selesai. <br><br>  Terlepas dari kegunaannya, mesin negara memiliki keterbatasan.  Concurrent State Machines dan Pushdown Automaton machines dapat menangani beberapa batasan ini.  Anda dapat membacanya di buku oleh Robert Nystrom <a href="https://gameprogrammingpatterns.com/state.html" rel="noopener"><em>Game Programming Patterns</em></a> . <br><br>  Selain itu, topik tersebut dapat dieksplorasi lebih dalam dengan memeriksa <a href="https://en.wikipedia.org/wiki/Behavior_tree_(artificial_intelligence,_robotics_and_control)" rel="noopener"><em>pohon perilaku yang</em></a> digunakan untuk membuat entitas dalam game yang lebih kompleks. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id484176/">https://habr.com/ru/post/id484176/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id484166/index.html">VVVVVV ??? VVVVVV !!! :)</a></li>
<li><a href="../id484168/index.html">Kami menulis strategi kami untuk pengguliran virtual dari Angular CDK</a></li>
<li><a href="../id484170/index.html">Perbarui Titik Periksa dari R77.30 hingga 80.20</a></li>
<li><a href="../id484172/index.html">Integrasi berkelanjutan di Unity: cara mengurangi waktu perakitan dan menghemat sumber daya + payline sebagai hadiah</a></li>
<li><a href="../id484174/index.html">Castle minum dalam kondisi "ekstrim" atau bagaimana kami mengambil bagian dalam acara "DOZOR"</a></li>
<li><a href="../id484178/index.html">Saklar Ethernet Cerdas untuk Planet Bumi</a></li>
<li><a href="../id484180/index.html">Rostelecom virtual PBX: apa dan bagaimana bisa dilakukan melalui API</a></li>
<li><a href="../id484182/index.html">Xenobots: nanorobots hidup dari sel katak</a></li>
<li><a href="../id484186/index.html">LDAP - "otentikasi" adalah antipattern</a></li>
<li><a href="../id484188/index.html">Standar Desain Basis Data</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>