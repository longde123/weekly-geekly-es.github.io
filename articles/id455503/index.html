<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👸🏻 🧓🏽 💆 19 konsep yang perlu Anda pelajari untuk menjadi pengembang Angular yang efektif 🌙 🏯 🧑🏾‍🤝‍🧑🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aplikasi TODO front-end sama dengan "Hello world" dalam pemrograman normal. Saat membuat aplikasi TODO, Anda dapat mempelajari implementasi operasi CR...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>19 konsep yang perlu Anda pelajari untuk menjadi pengembang Angular yang efektif</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/455503/">  Aplikasi TODO front-end sama dengan "Hello world" dalam pemrograman normal.  Saat membuat aplikasi TODO, Anda dapat mempelajari implementasi operasi CRUD menggunakan satu atau beberapa kerangka kerja lainnya.  Tetapi seringkali proyek-proyek semacam itu hanya secara dangkal berhubungan dengan apa yang sebenarnya diketahui oleh kerangka kerja tersebut. <br><br>  Jika Anda melihat Angular, Anda merasa bahwa kerangka kerja ini terus berubah dan diperbarui.  Bahkan, berkenaan dengan Angular, kita dapat menyoroti beberapa ide yang tetap tidak berubah.  Bahan, terjemahan yang kami terbitkan hari ini, memberikan gambaran umum tentang konsep-konsep Angular dasar yang perlu Anda pahami agar dapat menggunakan kapabilitas kerangka kerja ini secara tepat dan efisien. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/um/16/oq/um16oqmd4_3hbbakqk5w_ofql2g.jpeg"></a> <br><br>  Untuk belajar Angular, Anda harus belajar banyak.  Banyak pengembang terjebak pada tahap awal pengembangan Angular.  Ini disebabkan oleh fakta bahwa mereka tidak tahu ke mana harus pergi, atau tidak tahu kata kunci apa yang harus mereka cari informasi yang akan memungkinkan mereka mengambil langkah maju.  Penulis materi ini mengatakan bahwa ketika dia mulai belajar Angular 2+, dia ingin dia menemukan panduan untuk kerangka kerja ini yang serupa dengan ini. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">1. Arsitektur modular Angular</font> </h2><br>  Secara teori, aplikasi Angular dapat dibuat dengan meletakkan semua kode pada satu halaman, dalam satu fungsi besar.  Tetapi untuk melakukannya, di satu sisi, tidak direkomendasikan, dan di sisi lain, pendekatan ini tidak bisa disebut efektif dari sudut pandang penataan kode.  Selain itu, ini masuk akal tentang keberadaan Angular. <br><br>  Angular, sebagai bagian dari arsitektur kerangka kerjanya, memanfaatkan konsep modul secara ekstensif.  Modul adalah sepotong kode yang keberadaannya hanya memiliki satu alasan.  Secara umum, kita dapat mengatakan bahwa aplikasi Angular dirakit dari modul.  Beberapa modul hanya digunakan di satu tempat aplikasi, beberapa di tempat yang berbeda. <br><br>  Ada banyak cara untuk menyusun modul dalam suatu aplikasi.  Selain itu, studi berbagai pola arsitektur membantu untuk memahami bagaimana mengatur struktur aplikasi dengan tujuan untuk menskalakannya selama pertumbuhannya.  Selain itu, penggunaan modul secara hati-hati membantu mengisolasi kode dan mencegah duplikasi kode dalam suatu proyek. <br>  Subbagian berikut akan memberikan contoh pertanyaan yang dengannya Anda dapat mencari materi tambahan tentang topik ini.  Subbagian tersebut akan ditemukan di bagian lain dari bahan ini. <br><br><h3>  <font color="#3AC1EF">▍ Permintaan Pencarian</font> </h3><br><ul><li>  Pola arsitektur sudut. </li><li>  Arsitektur aplikasi bersudut scalable. </li></ul><br><h2>  <font color="#3AC1EF">2. Aliran data satu arah dan kekekalan</font> </h2><br>  Banyak pengembang yang menggunakan Angular 1 menyukai konsep pengikatan dua arah.  Ini, pada kenyataannya, adalah salah satu kualitas menarik dari Angular.  Tetapi seiring berjalannya waktu, ketika aplikasi Angular menjadi lebih kompleks, menjadi jelas bahwa pengikatan dua arah menciptakan masalah kinerja. <br><br>  Ternyata mengikat dua arah, pada kenyataannya, tidak perlu begitu sering. <br>  Di Angular 2+, Anda masih dapat menggunakan penjilidan dua arah, tetapi hanya jika pengembang secara eksplisit menyatakan niatnya untuk menggunakan fitur ini.  Pendekatan ini membuat mereka yang menulis kode aplikasi berpikir tentang arah aliran data.  Ini, di samping itu, memungkinkan pekerjaan yang lebih fleksibel dengan data.  Fleksibilitas dicapai melalui kemampuan untuk menyesuaikan dengan tepat bagaimana data harus dipindahkan dalam aplikasi. <br><br><h3>  <font color="#3AC1EF">▍ Permintaan Pencarian</font> </h3><br><ul><li>  Praktik terbaik aliran data sudut. </li><li>  Alur uni-directional di Angular. </li><li>  Keuntungan mengikat satu arah. </li></ul><br><h2>  <font color="#3AC1EF">3. Atribut dan arahan struktural Angular</font> </h2><br>  Arahan adalah ekstensi HTML melalui elemen khusus.  Arahan atribut, atau atribut, memungkinkan Anda untuk mengubah properti elemen.  Arahan struktural memungkinkan Anda untuk mempengaruhi konten halaman dengan menghapus elemen dari DOM atau menambahkannya ke DOM. <br>  Misalnya, <code>ngSwitch</code> dan <code>ngIf</code> adalah arahan struktural, karena mereka mengevaluasi parameter yang diberikan kepada mereka dan menentukan apakah bagian-bagian tertentu dari DOM harus ada dalam dokumen. <br><br>  Atribut adalah mekanisme untuk mengubah perilaku standar elemen, disesuaikan oleh programmer. <br><br>  Mempelajari cara menggunakan kedua jenis arahan ini akan membantu memperluas kemampuan aplikasi Anda dan mengurangi jumlah kode duplikat.  Arahan atribut, di samping itu, dapat membantu menyoroti beberapa template untuk mengubah elemen yang digunakan di berbagai tempat aplikasi. <br><br><h3>  <font color="#3AC1EF">▍ Permintaan Pencarian</font> </h3><br><ul><li>  Arahan atribut sudut (Arahan atribut sudut). </li><li>  Arahan struktural sudut. </li><li>  Pola pengarahan struktural sudut. </li></ul><br><h2>  <font color="#3AC1EF">4. Metode siklus hidup komponen</font> </h2><br>  Setiap bagian dari kode memiliki siklus hidupnya sendiri, yang menentukan bagaimana sesuatu dibuat, ditampilkan di layar, dan kemudian menghilang.  Angular memiliki konsep yang disebut siklus hidup komponen.  Itu terlihat seperti ini: <br><br><ul><li>  Ciptaan. </li><li>  Rendering </li><li>  Rendering komponen anak. </li><li>  Periksa perubahan properti terkait data. </li><li>  Penghancuran. </li><li>  Menghapus dari DOM. </li></ul><br>  Programmer memiliki kesempatan untuk campur tangan dalam komponen pada saat-saat penting dalam siklus ini, dengan fokus, misalnya, pada peristiwa tertentu.  Ini memungkinkan Anda untuk menyesuaikan bagaimana program berperilaku di berbagai titik dalam siklus hidup komponen. <br><br>  Misalnya, Anda mungkin perlu memuat beberapa data sebelum halaman ditampilkan.  Anda dapat melakukan ini dalam metode siklus hidup komponen <code>ngOnInit()</code> .  Atau, mungkin di beberapa titik dalam aplikasi, Anda perlu memutuskan koneksi dari database.  Anda dapat melakukan ini dalam metode <code>ngOnDestroy()</code> . <br><br><h3>  <font color="#3AC1EF">▍ Permintaan Pencarian</font> </h3><br><ul><li>  Kait siklus hidup sudut. </li><li>  Siklus hidup komponen. </li></ul><br><h2>  <font color="#3AC1EF">5. Layanan HTTP dan Objek yang Dapat Diobservasi</font> </h2><br>  Apa yang kita bicarakan di sini lebih cenderung tidak terkait dengan fitur khusus Angular, tetapi untuk ES7.  Kebetulan di Angular, bekerja dengan objek yang dapat diobservasi diimplementasikan pada level framework.  Mekanisme serupa ada di React, Vue, dan pustaka dan kerangka kerja berbasis JavaScript lainnya. <br><br>  Objek yang dapat diamati adalah pola yang membantu Anda bekerja secara efisien dengan data dalam sistem berbasis peristiwa.  Agar dapat mengembangkan aplikasi Angular secara efektif, Anda perlu tahu cara menggunakan layanan HTTP dan objek yang Dapat Diobservasi. <br><br><h3>  <font color="#3AC1EF">▍ Permintaan Pencarian</font> </h3><br><ul><li>  Pola yang dapat diobservasi JavaScript (Template Objek yang Dapat Diamati JavaScript) </li><li>  HTTP sudut dan dapat diobservasi (HTTP dan objek yang dapat diobservasi dalam Angular). </li><li>  Fitur yang dapat diamati ES7 (Objek yang dapat diamati dalam ES7). </li></ul><br><h2>  <font color="#3AC1EF">6. Komponen pintar dan bodoh</font> </h2><br>  Banyak, mengembangkan aplikasi Angular, berusaha untuk memasukkan segala yang diperlukan untuk pengoperasian komponen ini.  Benar, ini bukan sesuatu yang bisa direkomendasikan untuk penggunaan praktis.  Gagasan untuk menggunakan komponen "pintar" dan "bodoh" di Angular adalah sebuah konsep yang, mungkin, harus dibicarakan lebih sering daripada yang mereka bicarakan sekarang, terutama di kalangan pengembang pemula. <br><br>  Apakah komponen itu pintar atau bodoh menentukan perannya dalam desain keseluruhan perangkat aplikasi.  Komponen "konyol" sering tidak memiliki keadaan, mereka berbeda dalam perilaku yang sederhana, dapat diprediksi dan dapat dimengerti.  Disarankan, jika memungkinkan, untuk fokus pada penciptaan dan penggunaan komponen "bodoh". <br><br>  Lebih sulit untuk bekerja dengan komponen "pintar", karena mereka, dalam pekerjaannya, menerima beberapa data input dan menghasilkan beberapa data output.  Untuk menggunakan Angular secara efektif, biasakan diri Anda dengan konsep komponen yang pintar dan bodoh.  Kenalan ini akan memberi Anda pola dan ide tentang cara mengatur fragmen kode aplikasi dan cara membangun hubungan antara fragmen ini satu sama lain. <br><br><h3>  <font color="#3AC1EF">▍ Permintaan Pencarian</font> </h3><br><ul><li>  Komponen sudut cerdas / bodoh. </li><li>  Komponen bodoh tanpa kewarganegaraan. </li><li>  Komponen presentasi. </li><li>  Komponen cerdas dalam Angular. </li></ul><br><h2>  <font color="#3AC1EF">7. Struktur aplikasi dan rekomendasi praktis untuk pembentukannya</font> </h2><br>  Jika kita berbicara tentang struktur aplikasi dan aplikasi rekomendasi praktis saat membuatnya, maka alat baris perintah Angular dapat memberikan setidaknya beberapa bantuan kepada programmer.  Mengembangkan aplikasi Angular (atau aplikasi lainnya) seperti membangun rumah.  Yaitu, kita berbicara tentang metode praktis yang telah dikembangkan dan dioptimalkan oleh komunitas pengembang selama bertahun-tahun.  Penggunaan teknik semacam itu untuk menyusun aplikasi menyebabkan munculnya proyek berkualitas tinggi.  Sebenarnya, ini berlaku untuk Angular. <br><br>  Ketika programmer pemula mencoba mempelajari Angular mengeluh tentang kerangka kerja ini, alasan untuk keluhan seperti itu biasanya adalah kurangnya pengetahuan tentang struktur aplikasi.  Pemula dengan mudah memahami sintaksis, di sini mereka tidak memiliki masalah.  Tetapi menemukan pendekatan yang tepat untuk menyusun aplikasi jauh lebih sulit bagi mereka.  Di sini Anda perlu memahami bidang subjek di mana aplikasi dibuat, Anda perlu mengetahui persyaratan untuk aplikasi, dan bagaimana realitas dan harapan terkait pada tingkat konseptual dan praktis. <br><br>  Mempelajari opsi yang mungkin untuk struktur aplikasi Angular dan rekomendasi praktis untuk menggunakan struktur ini akan memberikan programmer visi tentang cara membuat proyek sendiri. <br><br><h3>  <font color="#3AC1EF">▍ Permintaan Pencarian</font> </h3><br><ul><li>  Aplikasi sudut repo tunggal (aplikasi sudut di-host dalam repositori tunggal). </li><li>  Perpustakaan sudut (perpustakaan sudut). </li><li>  Paket sudut. </li><li>  Bundel sudut (Bundel sudut). </li><li>  Aplikasi mikro sudut. </li><li>  Monorepo (Monorepositories). </li></ul><br><h2>  <font color="#3AC1EF">8. Sintaks dan Pola Binding Data</font> </h2><br>  Binding, atau pengikatan data, mungkin merupakan fitur kerangka kerja JavaScript yang paling nyata.  Juga, ini adalah salah satu alasan kerangka kerja umumnya ada.  Pengikatan data dalam templat adalah jembatan antara HTML statis dan JavaScript.  Sintaks pengikatan data dalam template Angular memainkan peran perantara untuk membantu mengkomunikasikan entitas HTML dan JavaScript. <br><br>  Setelah Anda mempelajari bagaimana dan kapan menggunakan jangkar, Anda dapat dengan mudah mengubah halaman statis menjadi sesuatu yang interaktif.  Di bidang ini, disarankan untuk memperhatikan berbagai skenario pengikatan data.  Misalnya, ini adalah pengikatan properti, peristiwa, ini adalah interpolasi data dan pengikatan dua arah. <br><br><h3>  <font color="#3AC1EF">▍ Permintaan Pencarian</font> </h3><br><ul><li>  Pengikatan properti sudut. </li><li>  Mengikat acara sudut. </li><li>  Pengikatan dua arah sudut (Pengikatan data dua arah sudut). </li><li>  Interpolasi angular (Interpolasi dalam Angular). </li><li>  Konstanta lewat sudut (Konstanta lewat sudut). </li></ul><br><h2>  <font color="#3AC1EF">9. Modul Fitur dan Perutean</font> </h2><br>  Modul fitur dalam Angular adalah teknologi yang diremehkan.  Modul semacam itu, pada kenyataannya, menyediakan pengembang dengan cara yang fantastis untuk mengatur dan mengisolasi set persyaratan bisnis untuk aplikasi.  Mereka membantu membatasi pertanggungjawaban fragmen kode dan mencegah, dalam jangka panjang, pencemaran kode. <br><br>  Ada lima jenis modul Fitur (Domain, Routed, Routing, Layanan, Widget), masing-masing bertanggung jawab atas implementasi fungsi tertentu.  Mempelajari cara menggunakan modul Fitur bersamaan dengan perutean dapat membantu dalam membuat blok fungsi yang terpisah.  Ini akan membantu dan mengimplementasikan dalam aplikasi suatu skema pemisahan tanggung jawab yang berkualitas tinggi dan jelas. <br><br><h3>  <font color="#3AC1EF">▍ Permintaan Pencarian</font> </h3><br><ul><li>  Modul fitur sudut (Modul fitur dalam Sudut). </li><li>  Struktur fitur bersama di Angular. </li><li>  Penyedia modul fitur. </li><li>  Pemuatan malas dengan modul perutean dan fitur (Pemuatan malas dengan perutean dan modul Fitur). </li></ul><br><h2>  <font color="#3AC1EF">10. Formulir dan validasi data (formulir reaktif dan validator)</font> </h2><br>  Formulir adalah bagian yang tak terhindarkan dari setiap pengembangan front-end.  Dan di mana formulir digunakan, validasi data juga diperlukan. <br><br>  Angular memiliki berbagai cara untuk membangun formulir pintar yang digerakkan oleh data.  Bentuk reaktif sangat populer.  Namun, ada opsi lain, khususnya - ini adalah formulir yang validasinya didasarkan pada templat, serta penggunaan validator khusus. <br><br>  Mempelajari bagaimana validator dan CSS bekerja bersama akan membantu mempercepat pengembangan aplikasi dan memfasilitasi penanganan kesalahan dalam formulir. <br><br><h3>  <font color="#3AC1EF">▍ Permintaan Pencarian</font> </h3><br><ul><li>  Validasi bentuk sudut. </li><li>  Validasi yang digerakkan template </li><li>  Validasi formulir reaktif. </li><li>  Sinkronisasi dan validator async di Angular (Validator sinkron dan asinkron di Angular). </li><li>  Validator bawaan. </li><li>  Validator ubahsuaian sudut. </li><li>  Validasi lintas-bidang. </li></ul><br><h2>  <font color="#3AC1EF">11. Proyeksi konten</font> </h2><br>  Angular memiliki mekanisme yang disebut proyeksi konten.  Ini memungkinkan Anda untuk mengatur transfer data yang efisien dari komponen induk ke komponen turunan.  Meskipun gagasan memproyeksikan konten mungkin tampak rumit, esensinya terletak pada kenyataan bahwa untuk membangun beberapa elemen yang ditampilkan di layar, beberapa elemen ditempatkan pada yang lain. <br><br>  Pengembang sering mempelajari proyeksi konten pada tingkat permukaan, misalnya, membiasakan diri dengan skema di mana komponen anak tertanam dalam komponen induk.  Tetapi untuk memperluas pemahaman kita tentang konsep ini, kita juga perlu memahami bagaimana data ditransfer antara komponen visual yang berbeda.  Di sinilah pemahaman fitur proyeksi konten akan sangat membantu. <br><br>  Memahami konsep ini membantu untuk memahami fitur-fitur pergerakan aliran data dalam aplikasi, dan di mana tepatnya mutasi data ini terjadi. <br><br><h3>  <font color="#3AC1EF">▍ Permintaan Pencarian</font> </h3><br><ul><li>  Proyeksi konten sudut. </li><li>  Hubungan pandangan orang tua-anak (hubungan orang tua-anak dan komponen visual dari sudut). </li><li>  Hubungan data tampilan sudut. </li></ul><br><h2>  <font color="#3AC1EF">12. onPush Strategy Detection Change</font> </h2><br>  Secara default, Angular menggunakan strategi deteksi perubahan standar.  Dengan pendekatan ini, pengecekan komponen sedang berlangsung.  Meskipun tidak ada yang salah dengan ini, pendekatan untuk mendeteksi perubahan ini mungkin tidak efektif. <br><br>  Jika kita berbicara tentang aplikasi kecil, maka kinerjanya tidak terlalu terpengaruh.  Tetapi setelah aplikasi tumbuh ke ukuran tertentu, kecepatannya, terutama ketika diluncurkan di browser lama, dapat menurun. <br><br>  <code>onPush</code> deteksi perubahan <code>onPush</code> secara dramatis dapat mempercepat aplikasi.  Faktanya adalah bahwa ketika digunakan, pemeriksaan hanya dilakukan ketika peristiwa tertentu terjadi.  Ini jauh lebih baik daripada pemeriksaan konstan. <br><br><h3>  <font color="#3AC1EF">▍ Permintaan Pencarian</font> </h3><br><ul><li>  Deteksi perubahan onPush sudut (strategi deteksi perubahan onPush sudut). </li></ul><br><h2>  <font color="#3AC1EF">13. Membatasi akses ke rute, preloading, pemuatan malas</font> </h2><br>  Jika proyek Anda memiliki mekanisme yang menyediakan akses pengguna ke sistem, ini berarti Anda perlu menggunakan pembatasan akses ke rute.  Banyak aplikasi memerlukan kemampuan untuk melindungi halaman tertentu dari tampilan yang tidak sah.  Pembatasan akses rute berfungsi sebagai antarmuka antara router dan rute yang diminta.  Mereka membuat keputusan tentang apakah akses ke rute tertentu diizinkan dalam situasi tertentu.  Di bidang perlindungan rute, ada banyak hal yang berguna untuk dipelajari.  Secara khusus, ini adalah pengambilan keputusan berdasarkan analisis masa berlaku token, penggunaan peran otentikasi, dan penyediaan pekerjaan yang aman dengan rute. <br><br>  Preloading dan pemuatan data yang malas dapat meningkatkan pengalaman pengguna bekerja dengan situs dengan mengurangi waktu pemuatan aplikasi.  Akan bermanfaat untuk mengatakan bahwa teknologi pemuatan pra-malas tidak hanya terkait dengan gambar.  Teknologi ini digunakan saat memecah bundel aplikasi menjadi beberapa bagian dan saat memuat berbagai bagian bundel ini dalam kondisi yang berbeda. <br><br><h3>  <font color="#3AC1EF">▍ Permintaan Pencarian</font> </h3><br><ul><li>  Pelindung rute sudut (Membatasi akses ke rute di Sudut). </li><li>  Pola otentikasi sudut. </li><li>  Modul preloading dan pemuatan malas sudut (modul pemuatan awal dan pemuatan malas di Angular). </li><li>  Pola rute aman sudut. </li></ul><br><h2>  <font color="#3AC1EF">14. Konveyor khusus</font> </h2><br>  Pipa sudut membuat pemformatan data jauh lebih mudah.  Ada banyak konveyor bawaan yang memungkinkan Anda untuk menyelesaikan berbagai tugas standar.  Diantaranya adalah tugas memformat tanggal, jumlah mata uang, nilai persentase, serta, misalnya, menangani kasus karakter.  Namun, selalu ada tugas yang tidak ada konveyor standar. <br>  Dalam kasus-kasus seperti itulah dibutuhkan pipa khusus.  Mekanisme ini memungkinkan pemrogram untuk membuat filter sendiri dan menjelaskan transformasi data yang ia butuhkan.  Menggunakan semua ini tidaklah sulit, oleh karena itu konsep ini dapat direkomendasikan untuk dipelajari. <br><br><h3>  <font color="#3AC1EF">▍ Permintaan Pencarian</font> </h3><br><ul><li>  Pipa khusus sudut. </li></ul><br><h2>  <font color="#3AC1EF">15. Dekorator <code>@ViewChild</code> dan <code>@ContentChild</code></font> </h2><br>  Komponen dapat berkomunikasi satu sama lain berkat <code>@ContentChild</code> dan <code>@ContentChild</code> .  Inti dari Angular adalah membuat aplikasi multi-komponen yang dibuat menggunakan kerangka kerja ini terlihat seperti teka-teki.  Tetapi puzzle semacam itu tidak akan banyak berguna jika fragmennya diisolasi satu sama lain. <br><br>  Untuk menghubungkan potongan puzzle satu sama lain, dekorator <code>@ViewChild</code> dan <code>@ContentChild</code> .  Mempelajari fitur-fitur penggunaannya akan memberi Anda kesempatan untuk bekerja dengan komponen yang terkait dengan komponen lain.  Ini menyederhanakan tugas mengatur berbagi data antara berbagai komponen.  Ini memungkinkan Anda untuk mentransfer data dan informasi tentang peristiwa yang terjadi di komponen-komponen ini antara komponen. <br><br><h3>  <font color="#3AC1EF">▍ Permintaan Pencarian</font> </h3><br><ul><li>  Dekorator sudut (Dekorator di Sudut). </li><li>  Viewchild dan contentchild di Angular (Decorators <code>@ViewChild</code> dan <code>@ContentChild</code> in Angular). </li><li>  Berbagi data komponen sudut. </li></ul><br><h2>  <font color="#3AC1EF">16. Komponen dinamis dan arahan template-temp</font> </h2><br>  Komponen adalah blok bangunan aplikasi Angular.  Namun, tidak semua komponen harus dibuat terlebih dahulu.  Beberapa dari mereka perlu dibuat saat program sedang berjalan. <br>  Komponen dinamis memungkinkan aplikasi untuk membuat apa yang dibutuhkannya saat sedang berjalan. <br><br>  Komponen statis, tidak seperti yang dinamis, dibuat terlebih dahulu.  Ini dilakukan dalam kasus-kasus di mana komponen-komponennya tidak diharapkan dapat terpengaruh.  Mereka dapat diprediksi, dengan cara yang telah ditentukan, melakukan konversi data yang memasukkannya. <br><br>  Komponen dinamis, di sisi lain, diciptakan ketika diperlukan untuk mereka.  Mereka ternyata sangat berguna ketika mengembangkan aplikasi yang bekerja dengan sumber data eksternal.  Mereka berguna bahkan ketika Anda perlu mengatur reaksi aplikasi terhadap tindakan yang terjadi pada halaman. <br><br><h3>  <font color="#3AC1EF">▍ Permintaan Pencarian</font> </h3><br><ul><li>  Komponen dinamis dalam Angular. </li><li>  Komponen dinamis dan template temp-ng (Komponen dinamis dan petunjuk template-ng). </li></ul><br><h2>  <font color="#3AC1EF">17. Penghias <code>@Host</code> , <code>@HostBinding</code> dan arahan exportAs</font> </h2><br>  <code>@Host</code> , <code>@Host</code> , dan arahan <code>@HostBinding</code> digunakan di Angular untuk mengontrol apa yang mereka terapkan.  Mereka, di samping itu, memungkinkan untuk membuat templat ringkas untuk mengekspor entitas yang dapat digunakan dalam aplikasi. <br><br>  Jika hal di atas tampaknya tidak terlalu jelas bagi Anda, kami sarankan Anda membiasakan diri dengan arahan dan mencari tahu mengapa mereka diperlukan.  <code>@Host</code> , <code>@Host</code> , dan arahan <code>@HostBinding</code> adalah yang membantu Angular menjadi seperti itu. <br><br><h3>  <font color="#3AC1EF">▍ Permintaan Pencarian</font> </h3><br><ul><li>  Pola arahan sudut (Pola arahan sudut). </li><li>  <code>@Host</code> , <code>@HostBinding</code> dan exportAs di Angular (Dekorator <code>@Host</code> , <code>@HostBinding</code> dan arahan exportAs di Angular). </li></ul><br><h2>  <font color="#3AC1EF">18. Manajemen status aplikasi menggunakan NgRx</font> </h2><br>  Keadaan aplikasi ditentukan oleh apa yang dilihat pengguna.  Jika kebingungan berkuasa dalam kondisi aplikasi, ini dapat menunjukkan bahwa struktur data yang digunakan di dalamnya kurang beradaptasi dengan perubahan.  Perubahan seperti itu mungkin perlu dilakukan pada struktur data saat aplikasi tumbuh dan berkembang. <br><br>  Ketika seseorang mulai memahami spesifik bekerja dengan negara di Angular, ia juga mendekati pemahaman spesifik perilaku data dalam aplikasinya. <br><br>  Angular memiliki sistem manajemen negaranya sendiri.  Namun, ada satu teknologi, NgRx, yang memungkinkan Anda membawa manajemen status aplikasi ke tingkat yang lebih tinggi.  Secara khusus, misalnya, data dapat hilang ketika mentransfernya antara sejumlah komponen induk dan komponen anak.  Dan NgRx memungkinkan Anda untuk membuat repositori terpusat dan menyingkirkan masalah ini. <br><br><h3>  <font color="#3AC1EF">▍ Permintaan Pencarian</font> </h3><br><ul><li>  NgRx Angular (Menggunakan RxJS dalam Angular). </li><li>  Prinsip-prinsip fluks / Redux. </li><li>  Prinsip-prinsip manajemen negara sudut. </li></ul><br><h2>  <font color="#3AC1EF">19. Ketergantungan dan injeksi zona</font> </h2><br>  Injeksi ketergantungan adalah konsep universal yang masif.  Jika Anda tidak terlalu mengenalnya, Anda harus mempelajarinya.  Angular memiliki banyak cara untuk menyuntikkan dependensi secara akurat.  Ini terutama dicapai melalui penggunaan konstruktor.  Ini tentang mengimpor ke dalam kode hanya apa yang benar-benar dibutuhkan.  Ini membantu meningkatkan kinerja aplikasi. <br><br>  Konsep zona, seperti gagasan injeksi ketergantungan, tidak unik untuk Angular.  Ini adalah mekanisme yang memungkinkan aplikasi untuk memonitor status tugas asinkron sepanjang siklus hidupnya.  —  ,         ,   —  ,   .      . <br><br><h3> <font color="#3AC1EF">▍ </font> </h3><br><ul><li> Angular zones (  Angular). </li><li> Dependency injections ( ). </li><li> Angular DI (   Angular). </li></ul><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Angular- —   .        —     - ,   ,       ,     .           . ,    ,   Angular,      . <br><br>  <b>Pembaca yang budiman!</b>         Angular-? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455503/">https://habr.com/ru/post/id455503/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455489/index.html">Menghubungkan solusi audio dan video pihak ketiga ke Tim Microsoft</a></li>
<li><a href="../id455493/index.html">Apa yang Baru di Versi Angular 8</a></li>
<li><a href="../id455497/index.html">Penyaringan linear optimal: mulai dari gradient descent hingga filter adaptif</a></li>
<li><a href="../id455499/index.html">Ekstraksi gigi bungsu: bagaimana ini dilakukan?</a></li>
<li><a href="../id455501/index.html">Bagaimana Hollywood Secara Diam-diam Menggunakan AI untuk Membuat Keputusan Pembuatan Film Kunci</a></li>
<li><a href="../id455507/index.html">Ikhtisar Paket Python Datatable</a></li>
<li><a href="../id455509/index.html">Kisah mengapa saya masih menggunakan jQuery</a></li>
<li><a href="../id455511/index.html">Tidur adalah sumber daya utama bagi otak seorang programmer</a></li>
<li><a href="../id455513/index.html">Ledakan dan konspirasi global: kisah penciptaan baterai lithium-ion</a></li>
<li><a href="../id455515/index.html">Membalikkan dan meretas HDD eksternal Aigo yang mengenkripsi sendiri. Bagian 1: Membedah menjadi beberapa bagian</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>