<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüíº üõÄüèæ üë≤üèª Uso de enlaces de operaciones para hacer copias de seguridad de archivos en macOS sobre la marcha üíÉüèº üâê üêé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! Mi nombre es Denis Kopyrin, y hoy quiero hablar sobre c√≥mo resolvimos el problema de la copia de seguridad a pedido en macOS. De hecho, una...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Uso de enlaces de operaciones para hacer copias de seguridad de archivos en macOS sobre la marcha</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/acronis/blog/484816/">  Hola Habr!  Mi nombre es Denis Kopyrin, y hoy quiero hablar sobre c√≥mo resolvimos el problema de la copia de seguridad a pedido en macOS.  De hecho, una tarea interesante que encontr√© en el instituto eventualmente se convirti√≥ en un gran proyecto de investigaci√≥n sobre el trabajo con el sistema de archivos.  Todos los detalles est√°n debajo del corte. <br><br> <a href="https://habr.com/ru/company/acronis/blog/484816/"><img src="https://habrastorage.org/getpro/habr/post_images/e81/10c/67b/e8110c67b5fe5edb2a8259a8a68fe632.jpg" alt="imagen"></a> <br><a name="habracut"></a><br>  No comenzar√© desde lejos, solo puedo decir que todo comenz√≥ con un proyecto en el Instituto de F√≠sica y Tecnolog√≠a de Mosc√∫, que desarroll√© con mi supervisor en el departamento de base de Acronis.  Nos enfrentamos a la tarea de organizar el almacenamiento remoto de archivos, o m√°s bien, mantener el estado actual de sus copias de seguridad. <br><br>  Para garantizar la seguridad de los datos, utilizamos la extensi√≥n del n√∫cleo macOS, que recopila informaci√≥n sobre eventos en el sistema.  KPI para desarrolladores tiene una API KAUTH, que le permite recibir notificaciones sobre c√≥mo abrir y cerrar un archivo, eso es todo.  Si usa KAUTH, debe guardar completamente el archivo al abrirlo para escribir, porque los eventos de escritura en el archivo no est√°n disponibles para los desarrolladores.  Dicha informaci√≥n no fue suficiente para nuestras tareas.  De hecho, para complementar de forma permanente una copia de seguridad de los datos, debe comprender exactamente d√≥nde el usuario (o malware :) escribi√≥ los nuevos datos en el archivo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d12/250/d5e/d12250d5e699b0841d0059eb5ba8846c.png" alt="imagen"><br><br>  ¬øPero cu√°l de los desarrolladores estaba asustado por las restricciones del sistema operativo?  Si la API del kernel no le permite obtener informaci√≥n sobre las operaciones de escritura, entonces debe idear su propia forma de interceptar a trav√©s de otras herramientas del kernel. <br><br>  Al principio, no quer√≠amos parchear el n√∫cleo y sus estructuras.  En su lugar, intentaron crear un volumen virtual completo que nos permitiera interceptar todas las solicitudes de lectura y escritura que lo atraviesen.  Pero al mismo tiempo, result√≥ una caracter√≠stica desagradable de macOS: el sistema operativo cree que no tiene 1, sino 2 unidades flash USB, dos discos, etc.  Y por el hecho de que el segundo volumen cambia cuando se trabaja con el primero, macOS comienza a funcionar incorrectamente con las unidades.  Hab√≠a tantos problemas con este m√©todo que tuve que abandonarlo. <br><br><h3>  Busca otra soluci√≥n </h3><br>  A pesar de las limitaciones de KAUTH, este KPI le permite recibir notificaciones sobre el uso de un archivo para grabar antes de todas las operaciones.  Los desarrolladores tienen acceso a la abstracci√≥n del archivo BSD en el kernel - vnode.  Por extra√±o que parezca, result√≥ que parchear vnode es m√°s f√°cil que usar el filtrado de volumen.  La estructura vnode tiene una tabla de funciones que proporcionan trabajo con archivos reales.  Por lo tanto, tuvimos la idea de reemplazar esta tabla. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b1/6c7/a9b/6b16c7a9b87a054f0ae5898d043aa91d.png" alt="imagen"><br><br>  La idea fue considerada inmediatamente como una buena idea, pero para su implementaci√≥n fue necesario encontrar la tabla en la estructura vnode, ya que Apple no documenta su ubicaci√≥n en ning√∫n lado.  Para hacer esto, era necesario estudiar el c√≥digo de m√°quina del kernel, y tambi√©n determinar si es posible escribir en esta direcci√≥n para que el sistema no muera despu√©s de eso. <br><br>  Si se encuentra la tabla, simplemente la copiamos en la memoria, reemplazamos el puntero y pegamos el enlace a la nueva tabla en el vnode existente.  Gracias a esto, todas las operaciones con archivos pasar√°n por nuestro controlador, y podremos registrar todas las solicitudes de los usuarios, incluidas la lectura y la escritura.  Por lo tanto, la b√∫squeda de la mesa atesorada se ha convertido en nuestro principal objetivo. <br><br>  Dado que Apple realmente no quiere esto, para resolver el problema debe intentar "adivinar" la ubicaci√≥n de la tabla utilizando la heur√≠stica para la ubicaci√≥n relativa de los campos, o tomar una funci√≥n ya conocida, desarmarla y buscar un desplazamiento de esta informaci√≥n. <br><br>  <b>C√≥mo buscar un desplazamiento: una manera f√°cil</b> <br><br>  La forma m√°s sencilla de encontrar compensaciones de tabla en vnode es una heur√≠stica basada en la ubicaci√≥n de los campos en una estructura ( <a href="">enlace a Github</a> ). <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vnode</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (**v_op)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *); <span class="hljs-comment"><span class="hljs-comment">/* vnode operations vector */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mount_t</span></span> v_mount; <span class="hljs-comment"><span class="hljs-comment">/* ptr to vfs we are in */</span></span> ... }</code> </pre> <br>  Supondremos que el campo v_op que necesitamos est√° exactamente eliminado de 8 bytes de v_mount.  El valor de este √∫ltimo se puede obtener utilizando KPI p√∫blico ( <a href="">enlace a Github</a> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">mount_t</span></span> vnode_mount(<span class="hljs-keyword"><span class="hljs-keyword">vnode_t</span></span> vp);</code> </pre><br>  Conociendo el valor de v_mount, comenzaremos a buscar una "aguja en el pajar" - percibiremos el valor del puntero para vnode 'vp' como uintptr_t *, el valor de vnode_mount (vp) como uintptr_t.  Esto es seguido por iteraciones al valor "razonable" de i, hasta que se cumpla la condici√≥n 'haystack [i] == aguja'.  Y si la suposici√≥n sobre la ubicaci√≥n de los campos es correcta, el desplazamiento v_op es i-1. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getVOPPtr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">vnode_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> haystack = (<span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span>*) vp; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> needle = (<span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span>) vnode_mount(vp); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ATTEMPTCOUNT; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (haystack[i] == needle) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> haystack + (i - <span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; }</code> </pre><br>  <b>C√≥mo buscar un desplazamiento: desmontaje</b> <br><br>  A pesar de su simplicidad, el primer m√©todo tiene un inconveniente significativo.  Si Apple cambia el orden de los campos en la estructura vnode, el m√©todo simple se romper√°.  Un m√©todo m√°s universal pero menos trivial es desmontar din√°micamente el n√∫cleo. <br><br>  Por ejemplo, considere la funci√≥n de kernel desmontada VNOP_CREATE ( <a href="">enlace a Github</a> ) en macOS 10.14.6.  Las instrucciones que nos interesan est√°n marcadas con una flecha -&gt;. <br><br> <code>_VNOP_CREATE: <br> 1 push rbp <br> 2 mov rbp, rsp <br> 3 push r15 <br> 4 push r14 <br> 5 push r13 <br> 6 push r12 <br> 7 push rbx <br> 8 sub rsp, 0x48 <br> 9 mov r15, r8 <br> 10 mov r12, rdx <br> 11 mov r13, rsi <br> -&gt; 12 mov rbx, rdi <br> 13 lea rax, qword [___stack_chk_guard] <br> 14 mov rax, qword [rax] <br> 15 mov qword [rbp+-48], rax <br> -&gt; 16 lea rax, qword [_vnop_create_desc] ; _vnop_create_desc <br> 17 mov qword [rbp+-112], rax <br> 18 mov qword [rbp+-104], rdi <br> 19 mov qword [rbp+-96], rsi <br> 20 mov qword [rbp+-88], rdx <br> 21 mov qword [rbp+-80], rcx <br> 22 mov qword [rbp+-72], r8 <br> -&gt; 23 mov rax, qword [rdi+0xd0] <br> -&gt; 24 movsxd rcx, dword [_vnop_create_desc] <br> 25 lea rdi, qword [rbp+-112] <br> -&gt; 26 call qword [rax+rcx*8] <br> 27 mov r14d, eax <br> 28 test eax, eax <br> ‚Ä¶.</code> <br> <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">errno_t</span></span> VNOP_CREATE(<span class="hljs-keyword"><span class="hljs-keyword">vnode_t</span></span> dvp, <span class="hljs-keyword"><span class="hljs-keyword">vnode_t</span></span> * vpp, struct componentname * cnp, struct vnode_attr * vap, <span class="hljs-keyword"><span class="hljs-keyword">vfs_context_t</span></span> ctx) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _err; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vnop_create_args</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">;</span></span> a.a_desc = &amp;vnop;_create_desc; a.a_dvp = dvp; a.a_vpp = vpp; a.a_cnp = cnp; a.a_vap = vap; a.a_context = ctx; _err = (*dvp-&gt;v_op[vnop_create_desc.vdesc_offset])(&amp;a;); ‚Ä¶</code> </pre><br>  Escanearemos las instrucciones del ensamblador para encontrar el cambio en el vnode dvp.  El "prop√≥sito" del c√≥digo ensamblador es llamar a una funci√≥n desde la tabla v_op.  Para hacer esto, el procesador debe seguir estos pasos: <br><br><ol><li>  Sube dvp para registrarte </li><li>  Desreferenciarlo para obtener v_op (l√≠nea 23) </li><li>  Obtenga vnop_create_desc.vdesc_offset (l√≠nea 24) </li><li>  Llamar a una funci√≥n (l√≠nea 26) </li></ol><br>  Si todo est√° claro con los pasos 2-4, entonces surgen dificultades con el primer paso.  ¬øC√≥mo entender en qu√© registro se carg√≥ dvp?  Para hacer esto, utilizamos un m√©todo para emular una funci√≥n que monitorea los movimientos del puntero deseado.  De acuerdo con la convenci√≥n de llamadas System V x86_64, el primer argumento se pasa en el registro rdi.  Por lo tanto, decidimos hacer un seguimiento de todos los registros que contienen rdi.  En mi ejemplo, estos son los registros rbx y rdi.  Adem√°s, se puede guardar una copia del registro en la pila, que se encuentra en la versi√≥n de depuraci√≥n del n√∫cleo. <br><br>  Sabiendo que los registros rbx y rdi almacenan dvp, descubrimos que la l√≠nea 23 anula la referencia de vnode para obtener v_op.  Entonces asumimos que el desplazamiento en la estructura es 0xd0.  Para confirmar la decisi√≥n correcta, continuamos escaneando y nos aseguramos de que la funci√≥n se llame correctamente (l√≠neas 24 y 26). <br><br>  Este m√©todo es m√°s seguro, pero, desafortunadamente, tambi√©n tiene desventajas.  Tenemos que confiar en el hecho de que el patr√≥n de la funci√≥n (es decir, los 4 pasos que mencionamos anteriormente) ser√° el mismo.  Sin embargo, la probabilidad de cambiar el patr√≥n de la funci√≥n es un orden de magnitud menor que la probabilidad de cambiar el orden de los campos.  Entonces decidimos detenernos en el segundo m√©todo. <br><br><h3>  Vuelva a colocar los punteros en la tabla. </h3><br>  Despu√©s de encontrar v_op, surge la pregunta, ¬øc√≥mo usar este puntero?  Hay dos formas diferentes: sobrescribir la funci√≥n en la tabla (tercera flecha en la imagen) o sobrescribir la tabla en vnode (segunda flecha en la imagen). <br><br>  Al principio parece que la primera opci√≥n es m√°s rentable, porque solo necesitamos reemplazar un puntero.  Sin embargo, este enfoque tiene 2 inconvenientes significativos.  En primer lugar, la tabla v_op es la misma para todos los vnode de un sistema de archivos determinado (v_op para HFS +, v_op para APFS, ...), por lo que es necesario filtrar por vnode, lo que puede ser muy costoso; tendr√° que filtrar vnode adicional en cada operaci√≥n de escritura.  En segundo lugar, la tabla est√° escrita en la p√°gina de solo lectura.  Esta limitaci√≥n se puede eludir si usa la grabaci√≥n a trav√©s de IOMappedWrite64, evitando las verificaciones del sistema.  Adem√°s, si se env√≠a kext con el controlador del sistema de archivos, ser√° dif√≠cil descubrir c√≥mo eliminar el parche. <br><br>  La segunda opci√≥n resulta ser m√°s espec√≠fica y segura: se llamar√° al interceptor solo para el vnode necesario, y la memoria de vnode inicialmente permite operaciones de lectura-escritura.  Como se est√° reemplazando toda la tabla, es necesario asignar un poco m√°s de memoria (80 funciones en lugar de una).  Y dado que el n√∫mero de tablas suele ser igual al n√∫mero de sistemas de archivos, el l√≠mite de memoria es completamente insignificante. <br><br>  Es por eso que kext usa el segundo m√©todo, aunque, repito, a primera vista parece que esta opci√≥n es peor. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0f6/adc/957/0f6adc957cded9d732080d3f32cfa4d1.png" alt="imagen"><br><br>  Como resultado, nuestro controlador funciona de la siguiente manera: <br><br><ol><li>  La API de KAUTH proporciona vnode </li><li>  Estamos reemplazando la tabla vnode.  Si es necesario, interceptamos operaciones solo para vnode "interesante", por ejemplo, documentos de usuario </li><li>  Al interceptar, verificamos qu√© proceso est√° grabando, filtramos "nuestro" </li><li>  Enviamos una solicitud de UserSpace sincr√≥nica al cliente, quien decide qu√© es exactamente lo que se debe guardar. </li></ol><br><h3>  Que paso </h3><br>  Hoy tenemos un m√≥dulo experimental, que es una extensi√≥n del n√∫cleo macOS y tiene en cuenta cualquier cambio en el sistema de archivos a nivel granular.  Vale la pena se√±alar que en macOS 10.15 Apple introdujo un nuevo marco ( <a href="https://developer.apple.com/documentation/endpointsecurity%3Flanguage%3Dobjc">enlace a EndpointSecurity</a> ) para recibir notificaciones de cambios en el sistema de archivos, que est√° planeado para su uso en Active Protection, por lo tanto, la soluci√≥n descrita en el art√≠culo fue declarada obsoleta. </div></div><p>Source: <a href="https://habr.com/ru/post/484816/">https://habr.com/ru/post/484816/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../484802/index.html">Modo de autodestrucci√≥n: descomposici√≥n de la c√°psula endosc√≥pica debido a la luz.</a></li>
<li><a href="../484804/index.html">¬øQu√© cifrar en un sistema corporativo? ¬øY por qu√© haces esto?</a></li>
<li><a href="../484806/index.html">Diferencia entre cPanel y obsidiana Plesk</a></li>
<li><a href="../484812/index.html">Mi experiencia con Plesk</a></li>
<li><a href="../484814/index.html">6. Fortinet Getting Started v6.0. Filtrado web y control de aplicaciones</a></li>
<li><a href="../484818/index.html">El libro "C ++. La pr√°ctica de la programaci√≥n multiproceso "</a></li>
<li><a href="../484820/index.html">FAQ.Net: un programa gratuito para tomar notas para Windows con un dise√±o actualizado</a></li>
<li><a href="../484822/index.html">Blazor: c√≥mo evitar que un componente se enferme o dos enfoques para separar el c√≥digo del marcado</a></li>
<li><a href="../484824/index.html">La guerra por apagar las luces</a></li>
<li><a href="../484826/index.html">La inteligencia artificial empeora a√∫n m√°s la mala medicina</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>