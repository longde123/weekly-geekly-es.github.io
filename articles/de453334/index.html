<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧀 🚆 👩🏻‍⚖️ Sprechen Sie über PAKE ✌🏻 🐼 👨‍👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lassen Sie uns nun über Informationssicherheit sprechen. Diese Veröffentlichung ist dem Start des Kurses „Kryptografische Informationssicherheit“ gewi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sprechen Sie über PAKE</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/453334/">  Lassen Sie uns nun über Informationssicherheit sprechen.  Diese Veröffentlichung ist dem Start des Kurses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Kryptografische Informationssicherheit“ gewidmet</a> , der am 30. Mai beginnt.  Lass uns gehen. <br><br>  Erste Regel von PAKE: Sprich niemals über PAKE.  Die zweite Regel von PAKE besagt, dass die erste Regel Unsinn ist, da PAKE oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Password Authenticated Key Exchange</a> (rus. Schlüsselaustausch mit Passwortauthentifizierung) eine der nützlichsten Technologien ist, die praktisch nirgendwo verwendet wird.  Es sollte wo immer möglich implementiert werden, aber nicht so einfach. <br><br><img src="https://habrastorage.org/webt/gk/qt/xa/gkqtxaksei42embld2iyquekz44.png"><br><br><a name="habracut"></a><br>  Um zu verstehen, warum wir über Unsinn sprechen, schauen wir uns ein echtes Problem an. <br><br>  Angenommen, ich arbeite mit einem Server, auf dem Benutzerkennwörter gespeichert sind.  Es gibt eine traditionelle Methode zum Speichern: Hashing jedes Benutzerkennworts und Speichern des Ergebnisses in einer Kennwortdatenbank.  Es gibt viele Ideen, wie man mit dem Hash-Prozess umgeht.  Die heute am häufigsten verwendete Empfehlung besteht darin, eine speicherharte Kennwort-Hashing-Funktion (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">scrypt</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">argon2</a> (mit einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eindeutigen Salt</a> ) für jedes Kennwort) zu verwenden und dann das Hash-Ergebnis zu speichern.  Es gibt unterschiedliche Meinungen darüber, welche Hash-Funktion verwendet werden soll und ob sie einen geheimen Wert (genannt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Pfeffer"</a> ) verwenden kann, aber im Moment werden wir nicht darüber sprechen. <br><br>  Unabhängig davon, welchen Ansatz Sie wählen, haben alle diese Lösungen eine Achillesferse: <br>  <i>Wenn der Benutzer zurückkehrt, um die Site zu betreten, muss er weiterhin sein (offenes) Passwort an den Server senden, damit er die Überprüfung durchführen kann</i> . <br><br>  Diese Notwendigkeit kann zu unangenehmen Konsequenzen führen, wenn Ihr Server jemals kompromittiert wird oder wenn Ihre Entwickler einen dummen Fehler machen.  Anfang letzten Jahres hat Twitter beispielsweise alle Benutzer (und diese 330 Millionen!) Aufgefordert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, Kennwörter</a> zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ändern,</a> da sich herausstellte, dass das Unternehmen Textkennwörter (nicht gehasht) gespeichert hat. <br><br>  Derzeit widerspricht das Problem der Anmeldung in keiner Weise den Vorteilen des Passwort-Hashing.  Sie müssen jedoch eine bessere Lösung finden: eine, bei der das Kennwort niemals im Klartext an den Server gesendet wird.  Das kryptografische Tool, mit dem wir dies erreichen können, ist PAKE und insbesondere ein neues Protokoll namens OPAQUE, das wir am Ende dieses Artikels behandeln werden. <br><br><h2>  Was ist PAKE? </h2><br>  Das PAKE-Protokoll, das zuerst von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bellovin und Merritt</a> vorgeschlagen wurde, ist eine spezielle Art <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von Schlüsselaustauschprotokoll</a> .  Schlüsselaustauschprotokolle (oder „Schlüsselvereinbarungen“) sollen den beiden Parteien (nennen wir sie Client und Server) helfen, sich mithilfe der Kryptografie mit öffentlichem Schlüssel auf einen gemeinsam genutzten Schlüssel zu einigen.  Die frühesten Schlüsselaustauschprotokolle (zum Beispiel der klassische <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diffie-Hellman</a> ) waren nicht autorisiert, was sie anfällig für Angriffe wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Man-in-the-Middle machte</a> .  Eine Besonderheit der PAKE-Protokolle besteht darin, dass sich der Client mit einem Kennwort beim Server authentifiziert.  Aus offensichtlichen Gründen wird davon ausgegangen, dass das Kennwort oder sein Hash dem Server bereits bekannt ist, was eine Überprüfung ermöglicht. <br><br>  Wenn das alles wäre, wären PAKE-Protokolle einfach zu erstellen.  Was PAKE jedoch wirklich nützlich macht, ist, dass es auch einen Client-Passwortschutz bietet.  Eine ernsthaftere Garantie kann wie folgt formuliert werden: Nach einem Versuch, in das System einzutreten (erfolgreich oder erfolglos), sollten Client und Server nur wissen, ob das Clientkennwort mit dem vom Server erwarteten Wert übereinstimmt, und keine weiteren Informationen mehr.  Dies ist eine ziemlich gute Verteidigung.  Tatsächlich unterscheidet sich dies nicht von dem, was wir von einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Null-Offenlegungsnachweis</a> verlangen. <br><br><img src="https://habrastorage.org/webt/fv/s6/kt/fvs6ktjjxphiyeae5k13gtw0w4y.png"><br><blockquote>  Eine idealisierte Darstellung des PAKE-Protokolls.  Die Eingabe von beiden Seiten beinhaltet eine gewisse Zufälligkeit, die hier nicht gezeigt wird.  Der Lauscher muss den gemeinsam genutzten geheimen Schlüssel K nicht herausfinden, der selbst zufällig ist und nicht vom Passwort abhängt. </blockquote><br>  Das offensichtliche Problem bei PAKE ist natürlich, dass viele Entwickler das Protokoll „Schlüsselaustausch“ überhaupt nicht ausführen möchten!  Sie möchten nur sicherstellen, dass der Benutzer das Passwort kennt. <br><br>  Das Tolle an PAKE ist, dass der Anwendungsfall "Nur Anmelden" ziemlich einfach auszuführen ist.  Angenommen, ich habe ein Standard-PAKE-Protokoll, mit dem sich Client und Server auf einen gemeinsamen Schlüssel K einigen können. Wenn er das richtige Kennwort kennt (und nur in diesem Fall), müssen wir lediglich eine einfache Überprüfung implementieren, die beide Parteien erhalten haben der gleiche Schlüssel.  (Dies kann beispielsweise erfolgen, wenn die Parteien damit eine kryptografische Funktion berechnen und die Ergebnisse überprüfen.) Daher kann PAKE auch dann nützlich sein, wenn Sie nur das Kennwort überprüfen möchten. <br><br><h2>  SRP: PAKE, welche Zeit selbst vergessen hat </h2><br>  Das PAKE-Konzept scheint einen offensichtlichen Sicherheitsvorteil gegenüber dem naiven Ansatz zu bieten, den wir heute verwenden, um auf den Server zuzugreifen.  Und die Methoden selbst sind alt, in dem Sinne, dass PAKE seit 1992 bekannt ist!  Trotzdem sah ihn das Licht nie.  Warum passiert das? <br><br>  Es gibt mehrere offensichtliche Gründe.  Das offensichtlichste hängt mit den Einschränkungen des Internets zusammen: Es ist viel einfacher, ein Passwortformular auf einer Webseite zu platzieren, als ausgefallene Kryptografie in einem Browser zu implementieren.  Diese Erklärung reicht jedoch nicht aus.  Selbst native Anwendungen implementieren PAKE selten für Anmeldevorgänge.  Eine weitere mögliche Erklärung bezieht sich auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Patente</a> , obwohl die meisten bereits abgelaufen sind.  Für mich gibt es zwei wahrscheinliche Gründe, warum ich PAKE nicht habe: <br><br><ul><li>  Mangel an hochwertigen PAKE-Implementierungen in gängigen Sprachen, was die Verwendung schwierig macht; </li><li>  Kryptografiespezialisten vermitteln die Essenz und den Wert ihrer Arbeit nicht schlecht, so dass die meisten Menschen nicht einmal wissen, dass PAKE überhaupt existiert. </li></ul><br>  Trotz der Tatsache, dass ich sagte, dass PAKE jetzt nicht verwendet wird, gibt es immer noch Ausnahmen von den Regeln. <br><br>  Es gibt ein großartiges Protokoll, das 1998 von Tom Wu entwickelt wurde (nicht zu verwechseln mit Tim Wu) und das als „SRP“ (kurz für „Secure Remote Password“) bezeichnet wird.  Tatsächlich handelt es sich nur um ein dreistufiges PAKE mit einigen zusätzlichen Funktionen, die in den ersten Arbeiten nicht implementiert wurden.  Soweit ich weiß, unterscheidet sich SRP darin, dass es das häufigste PAKE-Protokoll der Welt ist.  Ich werde zwei Beweise für diese Aussage geben: <br><br><ol><li>  SRP wurde als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TLS-Chiffriersuite</a> standardisiert und in Bibliotheken wie beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenSSL</a> implementiert, obwohl niemand es besonders zu verwenden scheint. </li><li>  Apple nutzt SRP in seinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">iCloud Key Vault</a> in großem Umfang </li></ol><br>  Die zweite Tatsache an sich könnte SRP zu einem der am häufigsten verwendeten kryptografischen Protokolle der Welt machen. Die Anzahl der Geräte, die Apple stempelt, ist so groß.  Und es gibt nichts lustiges. <br><br>  Die Tatsache, dass die Industrie die SRP akzeptiert hat, ist sicherlich gut, aber andererseits und nicht sehr.  Meistens, weil SRP allein nicht die beste PAKE-Implementierung ist, obwohl jede PAKE-Empfehlung cool ist.  Ich dachte, ich würde in den Dschungel der Diskussionen über SRP gehen, aber diese Rede zog sich bereits hin und ich schweife von der Geschichte über ein wirklich gutes Protokoll ab, über das wir weiter unten sprechen werden.  Wenn Sie immer noch an der Diskussion über SRP interessiert sind, habe ich sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hierher gebracht</a> . <br><br>  Lassen Sie mich anstelle dieser unnötigen Details eine kurze Zusammenfassung meiner Gedanken zu SRP schreiben: <br><br><ol><li>  SRP macht einige Dinge richtig.  Erstens müssen Sie im Gegensatz zu früheren Versionen von PAKE das unformatierte Kennwort nicht auf dem Server speichern (oder gleichwertig einen Hash, der von einem Angreifer anstelle eines Kennworts verwendet werden könnte).  Stattdessen speichert der Server einen "Verifizierer", bei dem es sich um eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einwegfunktion</a> des Kennwort-Hash handelt.  Dies bedeutet, dass ein Angreifer aufgrund eines Kennwortdatenbanklecks einen Benutzer nur dann nicht sofort ersetzen kann, wenn er keine weiteren kostspieligen Wörterbuchangriffe ausführt.  (Der technische Name hierfür lautet "asymmetrisch" PAKE.) </li><li>  Es gibt bessere Nachrichten, die aktuelle Version von SRP (v4 v6a) wurde noch nicht gehackt! </li><li>  Allerdings (lassen Sie sich von den Entwicklern nicht beleidigen) ist die Architektur des SRP-Protokolls völlig verrückt und seine früheren Versionen wurden mehrmals gehackt - weshalb wir jetzt Version 6a haben.  Außerdem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beweist</a> der "Sicherheitsnachweis" im ursprünglichen Forschungsartikel eigentlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nichts</a> . </li><li>  SRP basiert derzeit auf einer ganzzahligen (endgültigen) Arithmetik, und aus verschiedenen Gründen (siehe Abschnitt 3 oben) kann seine Architektur eindeutig nicht auf eine elliptische <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kurve übertragen werden</a> .  Dies erfordert mehr Bandbreite und Berechnung, sodass SRP die vielen Leistungsverbesserungen, die wir in Add-Ons wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Curve25519</a> entwickelt haben, nicht nutzen kann. </li><li>  SRP ist anfällig für Pre-Computing-Angriffe, da es das Salz des Benutzers an jeden Angreifer weitergibt, der eine SRP-Sitzung initiieren kann.  Dies bedeutet, dass ich Ihren Server nach Ihrem Salt fragen und ein Wörterbuch mit potenziellen Kennwort-Hashes erstellen kann, bevor der Server kompromittiert wird. </li><li>  Trotz all dieser Mängel ist SRP extrem einfach und enthält auch Arbeitscode.  Darüber hinaus verfügt OpenSSL über Arbeitscode, der sogar in TLS integriert ist, was die Implementierung relativ einfach macht. </li></ol><br>  Von all diesen Punkten ist letzterer mit ziemlicher Sicherheit für den (relativ) hohen kommerziellen Erfolg verantwortlich, den SRP gegenüber anderen PAKE-Protokollen erzielt hat.  Er ist nicht perfekt, aber echt.  Dies wollte ich Experten für kryptografische Sicherheit vermitteln. <br><br><h2>  OPAQUE: PAKE neue Generation </h2><br>  Als ich vor einigen Monaten anfing, über PAKE nachzudenken, musste ich feststellen, dass die meisten vorhandenen Implementierungen eher schlecht abschnitten.  Entweder hatten sie Probleme, wie z. B. in SRP, und der Benutzer musste das Kennwort (oder das effektive Kennwort) auf dem Server speichern, oder dem Angreifer wurde das „Salz“ angezeigt, sodass der Angriff vor der Berechnung ausgeführt werden konnte. <br><br>  Anfang letzten Jahres enthüllten Jarecki, Kravczyk und Xu der Welt ein neues Protokoll namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OPAQUE</a> .  Es hat eine Reihe von wesentlichen Vorteilen: <br><br><ol><li>  Es kann auch dann implementiert werden, wenn Probleme mit Diffie-Hellman und diskreten Logarithmen auftreten.  Dies bedeutet, dass es im Gegensatz zu SRP mithilfe effektiver elliptischer Kurven leicht instanziiert werden kann. </li><li>  Noch besser: OPAQUE enthüllt einem Angreifer kein Salz.  Er löst dieses Problem, indem er "Saltful PRF" verwendet, um das Salt mit dem Passwort zu kombinieren, sodass der Client das Salt nicht erhält und der Server das Passwort nicht erhält. </li><li> OPAQUE funktioniert mit jeder Passwort-Hashing-Funktion.  Da alle Hashing-Arbeiten auf dem Client ausgeführt werden, kann OPAQUE den Server tatsächlich entlasten und den Onlinedienst freigeben, um beispielsweise extrem umfangreiche Sicherheitseinstellungen zu verwenden, z. B. die <code>scrypt</code> mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">viel RAM zu</a> konfigurieren. </li><li>  In Bezug auf Nachrichtenanzahl und Exponenten unterscheidet sich OPAQUE nicht wesentlich von SRP.  Da es jedoch mit effizienteren Parametern implementiert werden kann, wird es wahrscheinlich viel effizienter arbeiten. </li><li>  Im Gegensatz zu SRP verfügt OPAQUE über angemessene Sicherheitsnachweise (in einem sehr starken Modell). </li></ol><br>  Es gibt sogar einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Internet-Entwurfsvorschlag</a> für OPAQUE, den Sie hier lesen können.  Leider weiß ich im Moment nichts über die Qualität der Code-Implementierung, außer dass es bereits mehrere mögliche Implementierungen gibt.  Ich hoffe, dass dieses Problem bald behoben ist. <br>  Das vollwertige OPAQUE-Protokoll ist unten aufgeführt.  Im Rest dieses Abschnitts werde ich darüber sprechen, wie es funktioniert. <br><br>  <b>Problem 1: Salz geheim halten.</b>  Wie oben erwähnt, besteht das Hauptproblem bei früheren Versionen von PAKE darin, dass Salt vom Server auf den Client übertragen werden muss (immer noch nicht authentifiziert).  Auf diese Weise kann ein Angreifer vor dem Rechnen Angriffe ausführen, bei denen er anhand der empfangenen Daten ein Wörterbuch erstellen kann. <br><br>  Das Problem hierbei ist, dass Salt normalerweise zusammen mit dem Kennwort an eine Hash-Funktion (z. B. Verschlüsselung) übergeben wird.  Intuitiv muss jemand diese Funktion berechnen.  Wenn es sich um einen Server handelt, sollte der Server ein Kennwort sehen, das jede Bedeutung zunichte macht.  Wenn dies ein Kunde ist, braucht er Salz. <br><br>  Theoretisch können Sie dieses Problem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">umgehen,</a> indem Sie die Kennwort-Hashing-Funktion mithilfe des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sicheren Zwei-Parteien-Berechnungsprotokolls (2PC) berechnen</a> .  In der Praxis sind solche Lösungen mit ziemlicher Sicherheit ineffektiv, vor allem, weil Kennwort-Hashing-Funktionen komplex und zeitaufwändig sind.  Dies erhöht die Komplexität jedes 2PC-Systems erheblich. <br><br>  OPAQUE umgeht dies wie folgt.  Es hinterlässt einen Passwort-Hash auf der Clientseite, zeigt ihn jedoch nicht an.  Stattdessen wird ein spezielles Zwei-Wege-Protokoll namens Vergessliches PRF verwendet, um ein anderes Salt zu berechnen (nennen wir es salt2), sodass der Client salt2 in einer Hash-Funktion verwenden kann, aber nicht auf das ursprüngliche Salt zugreifen kann. <br><br>  Es funktioniert ungefähr so: <br><blockquote>  <i>Der Server speichert "salt" und der Client hat password.salt2 = PRF (salt, password). Dies wird zwischen dem Client und dem Server mithilfe eines Protokolls berechnet, bei dem der Client das Salt niemals erkennt und der Server das Kennwort kennt.</i>  <i>Der Client erhält salt2K = PasswordHash (salt2, Passwort) - und all dies wird auf dem Client berücksichtigt.</i> </blockquote><br>  Die eigentliche Implementierung von vergesslichem PRF kann unter Verwendung mehrerer Gruppenelemente und Exponenten erfolgen.  Noch besser ist, wenn der Client das falsche Passwort eingibt, erhält das Protokoll einen Dummy-Wert „salt2“, der nichts über den tatsächlichen Wert von salt aussagt. <br><br>  <b>Problem 2: Beweis, dass der Client den richtigen Schlüssel K erhalten hat.</b> Natürlich hat der Client im Moment den Schlüssel K erhalten, aber der Server hat keine Ahnung, was es ist.  Der Server weiß auch nicht, ob dies der richtige Schlüssel ist. <br><br>  Die OPAQUE-Lösung basiert auf der alten Idee von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gentry, Mackenzie und Ramzan</a> .  Wenn sich ein Benutzer zum ersten Mal am Server anmeldet, generiert der Server einen zuverlässigen öffentlichen und privaten Schlüssel für das Protokoll der sicheren Vereinbarung (z. B. HMQV) und verschlüsselt den empfangenen privaten Schlüssel unter K zusammen mit dem öffentlichen Schlüssel des Servers.  Die resultierende authentifizierte Verschlüsselung (und der öffentliche Schlüssel) werden in der Kennwortdatenbank gespeichert. <br><br>  <b><i>C = Verschlüsseln (K, geheimer Clientschlüssel | öffentlicher Schlüssel des Servers)</i></b> <br><br><img src="https://habrastorage.org/webt/9z/tb/uk/9ztbukhcywebjlgyrlbbaltk-0a.png"><br>  <i>Vollversion des OPAQUE-Protokolls, Auszug aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> .</i> <br><br>  Wenn sich der Client mithilfe des OPAQUE-Protokolls authentifizieren möchte, sendet ihm der Server den gespeicherten <b>C-</b> Code.  Wenn der Client in der ersten Phase das richtige Passwort eingegeben hat, kann er <b>K erhalten</b> und diese Chiffre entschlüsseln.  Ansonsten ist es nutzlos.  Mit einem kabelgebundenen geheimen Schlüssel kann er jetzt ein Standardvereinbarungsprotokoll mit einem authentifizierten Schlüssel ausführen, um den Handshake abzuschließen.  (Der Server überprüft die Eingabe der Clients, indem er sie mit seiner Kopie des öffentlichen Schlüssels des Clients vergleicht. Der Client führt dasselbe aus.) <br><br>  <b>Lassen Sie uns jetzt alles zusammenfügen.</b>  Alle diese Schritte können zu einem Protokoll kombiniert werden, das die gleiche Anzahl von Schritten wie SRP aufweist.  Wenn Sie die Überprüfungsschritte nicht beachten, sieht es wie im obigen Protokoll aus.  Im Prinzip besteht die Idee nur aus zwei Nachrichten: eine vom Client und die zweite wird an den Server zurückgesendet. <br><br>  Der letzte Aspekt der Arbeit von OPAQUE ist, dass es gute Sicherheitsnachweise gibt, die uns sagen, dass das resultierende Protokoll als sicher angesehen werden kann, wenn wir einen oder mehrere diskrete Logarithmen in einem zufälligen Orakelmodell verwenden, was anscheinend eine Standardannahme ist findet in den Einstellungen statt, mit denen wir arbeiten. <br><br><h2>  Fazit </h2><br>  Kurz gesagt, wir verfügen über eine zuverlässige Technologie, die die Verwendung von Kennwörtern erheblich vereinfacht und es uns ermöglicht, diese effizienter zu handhaben - mit vielen Hashing-Parametern und einer hohen Arbeitsbelastung auf der Clientseite.  Warum wird das nicht überall verwendet?  Vielleicht wird sich in den nächsten Jahren alles ändern.  Die Zeit wird zeigen. <br><br>  Gemäß der etablierten Tradition warten wir auf Ihre Kommentare und laden Sie ein, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Tag der offenen Tür</a> zu besuchen, der am 27. Mai von unserer Lehrerin, Kryptoanalytikerin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Elena Kirshanova</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">abgehalten wird</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453334/">https://habr.com/ru/post/de453334/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453324/index.html">Diode als Gleichrichter</a></li>
<li><a href="../de453326/index.html">So automatisieren Sie das IT-Infrastrukturmanagement - diskutieren Sie drei Trends</a></li>
<li><a href="../de453328/index.html">Zehn Jahre an einem abgelegenen Ort</a></li>
<li><a href="../de453330/index.html">Was tun, wenn der RAM abstürzt? Anamnese und Behandlungsmethoden</a></li>
<li><a href="../de453332/index.html">Über die seltsame Methode, Festplattenspeicher zu sparen</a></li>
<li><a href="../de453336/index.html">Auswahlhilfe für CNC-Brennmaschinen</a></li>
<li><a href="../de453338/index.html">Rust 1.35.0 Release: Implementierungen funktionaler Merkmale und andere Innovationen</a></li>
<li><a href="../de453340/index.html">Perl 5.30 veröffentlicht</a></li>
<li><a href="../de453342/index.html">Mythen über entfernte Mitarbeiter, die wir selbst zerstört haben</a></li>
<li><a href="../de453346/index.html">Speicher- und Datenschutztechnologien - der dritte Tag auf der VMware EMPOWER 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>