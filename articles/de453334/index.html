<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßÄ üöÜ üë©üèª‚Äç‚öñÔ∏è Sprechen Sie √ºber PAKE ‚úåüèª üêº üë®‚Äçüëß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lassen Sie uns nun √ºber Informationssicherheit sprechen. Diese Ver√∂ffentlichung ist dem Start des Kurses ‚ÄûKryptografische Informationssicherheit‚Äú gewi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sprechen Sie √ºber PAKE</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/453334/">  Lassen Sie uns nun √ºber Informationssicherheit sprechen.  Diese Ver√∂ffentlichung ist dem Start des Kurses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûKryptografische Informationssicherheit‚Äú gewidmet</a> , der am 30. Mai beginnt.  Lass uns gehen. <br><br>  Erste Regel von PAKE: Sprich niemals √ºber PAKE.  Die zweite Regel von PAKE besagt, dass die erste Regel Unsinn ist, da PAKE oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Password Authenticated Key Exchange</a> (rus. Schl√ºsselaustausch mit Passwortauthentifizierung) eine der n√ºtzlichsten Technologien ist, die praktisch nirgendwo verwendet wird.  Es sollte wo immer m√∂glich implementiert werden, aber nicht so einfach. <br><br><img src="https://habrastorage.org/webt/gk/qt/xa/gkqtxaksei42embld2iyquekz44.png"><br><br><a name="habracut"></a><br>  Um zu verstehen, warum wir √ºber Unsinn sprechen, schauen wir uns ein echtes Problem an. <br><br>  Angenommen, ich arbeite mit einem Server, auf dem Benutzerkennw√∂rter gespeichert sind.  Es gibt eine traditionelle Methode zum Speichern: Hashing jedes Benutzerkennworts und Speichern des Ergebnisses in einer Kennwortdatenbank.  Es gibt viele Ideen, wie man mit dem Hash-Prozess umgeht.  Die heute am h√§ufigsten verwendete Empfehlung besteht darin, eine speicherharte Kennwort-Hashing-Funktion (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">scrypt</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">argon2</a> (mit einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eindeutigen Salt</a> ) f√ºr jedes Kennwort) zu verwenden und dann das Hash-Ergebnis zu speichern.  Es gibt unterschiedliche Meinungen dar√ºber, welche Hash-Funktion verwendet werden soll und ob sie einen geheimen Wert (genannt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Pfeffer"</a> ) verwenden kann, aber im Moment werden wir nicht dar√ºber sprechen. <br><br>  Unabh√§ngig davon, welchen Ansatz Sie w√§hlen, haben alle diese L√∂sungen eine Achillesferse: <br>  <i>Wenn der Benutzer zur√ºckkehrt, um die Site zu betreten, muss er weiterhin sein (offenes) Passwort an den Server senden, damit er die √úberpr√ºfung durchf√ºhren kann</i> . <br><br>  Diese Notwendigkeit kann zu unangenehmen Konsequenzen f√ºhren, wenn Ihr Server jemals kompromittiert wird oder wenn Ihre Entwickler einen dummen Fehler machen.  Anfang letzten Jahres hat Twitter beispielsweise alle Benutzer (und diese 330 Millionen!) Aufgefordert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, Kennw√∂rter</a> zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√§ndern,</a> da sich herausstellte, dass das Unternehmen Textkennw√∂rter (nicht gehasht) gespeichert hat. <br><br>  Derzeit widerspricht das Problem der Anmeldung in keiner Weise den Vorteilen des Passwort-Hashing.  Sie m√ºssen jedoch eine bessere L√∂sung finden: eine, bei der das Kennwort niemals im Klartext an den Server gesendet wird.  Das kryptografische Tool, mit dem wir dies erreichen k√∂nnen, ist PAKE und insbesondere ein neues Protokoll namens OPAQUE, das wir am Ende dieses Artikels behandeln werden. <br><br><h2>  Was ist PAKE? </h2><br>  Das PAKE-Protokoll, das zuerst von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bellovin und Merritt</a> vorgeschlagen wurde, ist eine spezielle Art <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von Schl√ºsselaustauschprotokoll</a> .  Schl√ºsselaustauschprotokolle (oder ‚ÄûSchl√ºsselvereinbarungen‚Äú) sollen den beiden Parteien (nennen wir sie Client und Server) helfen, sich mithilfe der Kryptografie mit √∂ffentlichem Schl√ºssel auf einen gemeinsam genutzten Schl√ºssel zu einigen.  Die fr√ºhesten Schl√ºsselaustauschprotokolle (zum Beispiel der klassische <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diffie-Hellman</a> ) waren nicht autorisiert, was sie anf√§llig f√ºr Angriffe wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Man-in-the-Middle machte</a> .  Eine Besonderheit der PAKE-Protokolle besteht darin, dass sich der Client mit einem Kennwort beim Server authentifiziert.  Aus offensichtlichen Gr√ºnden wird davon ausgegangen, dass das Kennwort oder sein Hash dem Server bereits bekannt ist, was eine √úberpr√ºfung erm√∂glicht. <br><br>  Wenn das alles w√§re, w√§ren PAKE-Protokolle einfach zu erstellen.  Was PAKE jedoch wirklich n√ºtzlich macht, ist, dass es auch einen Client-Passwortschutz bietet.  Eine ernsthaftere Garantie kann wie folgt formuliert werden: Nach einem Versuch, in das System einzutreten (erfolgreich oder erfolglos), sollten Client und Server nur wissen, ob das Clientkennwort mit dem vom Server erwarteten Wert √ºbereinstimmt, und keine weiteren Informationen mehr.  Dies ist eine ziemlich gute Verteidigung.  Tats√§chlich unterscheidet sich dies nicht von dem, was wir von einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Null-Offenlegungsnachweis</a> verlangen. <br><br><img src="https://habrastorage.org/webt/fv/s6/kt/fvs6ktjjxphiyeae5k13gtw0w4y.png"><br><blockquote>  Eine idealisierte Darstellung des PAKE-Protokolls.  Die Eingabe von beiden Seiten beinhaltet eine gewisse Zuf√§lligkeit, die hier nicht gezeigt wird.  Der Lauscher muss den gemeinsam genutzten geheimen Schl√ºssel K nicht herausfinden, der selbst zuf√§llig ist und nicht vom Passwort abh√§ngt. </blockquote><br>  Das offensichtliche Problem bei PAKE ist nat√ºrlich, dass viele Entwickler das Protokoll ‚ÄûSchl√ºsselaustausch‚Äú √ºberhaupt nicht ausf√ºhren m√∂chten!  Sie m√∂chten nur sicherstellen, dass der Benutzer das Passwort kennt. <br><br>  Das Tolle an PAKE ist, dass der Anwendungsfall "Nur Anmelden" ziemlich einfach auszuf√ºhren ist.  Angenommen, ich habe ein Standard-PAKE-Protokoll, mit dem sich Client und Server auf einen gemeinsamen Schl√ºssel K einigen k√∂nnen. Wenn er das richtige Kennwort kennt (und nur in diesem Fall), m√ºssen wir lediglich eine einfache √úberpr√ºfung implementieren, die beide Parteien erhalten haben der gleiche Schl√ºssel.  (Dies kann beispielsweise erfolgen, wenn die Parteien damit eine kryptografische Funktion berechnen und die Ergebnisse √ºberpr√ºfen.) Daher kann PAKE auch dann n√ºtzlich sein, wenn Sie nur das Kennwort √ºberpr√ºfen m√∂chten. <br><br><h2>  SRP: PAKE, welche Zeit selbst vergessen hat </h2><br>  Das PAKE-Konzept scheint einen offensichtlichen Sicherheitsvorteil gegen√ºber dem naiven Ansatz zu bieten, den wir heute verwenden, um auf den Server zuzugreifen.  Und die Methoden selbst sind alt, in dem Sinne, dass PAKE seit 1992 bekannt ist!  Trotzdem sah ihn das Licht nie.  Warum passiert das? <br><br>  Es gibt mehrere offensichtliche Gr√ºnde.  Das offensichtlichste h√§ngt mit den Einschr√§nkungen des Internets zusammen: Es ist viel einfacher, ein Passwortformular auf einer Webseite zu platzieren, als ausgefallene Kryptografie in einem Browser zu implementieren.  Diese Erkl√§rung reicht jedoch nicht aus.  Selbst native Anwendungen implementieren PAKE selten f√ºr Anmeldevorg√§nge.  Eine weitere m√∂gliche Erkl√§rung bezieht sich auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Patente</a> , obwohl die meisten bereits abgelaufen sind.  F√ºr mich gibt es zwei wahrscheinliche Gr√ºnde, warum ich PAKE nicht habe: <br><br><ul><li>  Mangel an hochwertigen PAKE-Implementierungen in g√§ngigen Sprachen, was die Verwendung schwierig macht; </li><li>  Kryptografiespezialisten vermitteln die Essenz und den Wert ihrer Arbeit nicht schlecht, so dass die meisten Menschen nicht einmal wissen, dass PAKE √ºberhaupt existiert. </li></ul><br>  Trotz der Tatsache, dass ich sagte, dass PAKE jetzt nicht verwendet wird, gibt es immer noch Ausnahmen von den Regeln. <br><br>  Es gibt ein gro√üartiges Protokoll, das 1998 von Tom Wu entwickelt wurde (nicht zu verwechseln mit Tim Wu) und das als ‚ÄûSRP‚Äú (kurz f√ºr ‚ÄûSecure Remote Password‚Äú) bezeichnet wird.  Tats√§chlich handelt es sich nur um ein dreistufiges PAKE mit einigen zus√§tzlichen Funktionen, die in den ersten Arbeiten nicht implementiert wurden.  Soweit ich wei√ü, unterscheidet sich SRP darin, dass es das h√§ufigste PAKE-Protokoll der Welt ist.  Ich werde zwei Beweise f√ºr diese Aussage geben: <br><br><ol><li>  SRP wurde als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TLS-Chiffriersuite</a> standardisiert und in Bibliotheken wie beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenSSL</a> implementiert, obwohl niemand es besonders zu verwenden scheint. </li><li>  Apple nutzt SRP in seinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">iCloud Key Vault</a> in gro√üem Umfang </li></ol><br>  Die zweite Tatsache an sich k√∂nnte SRP zu einem der am h√§ufigsten verwendeten kryptografischen Protokolle der Welt machen. Die Anzahl der Ger√§te, die Apple stempelt, ist so gro√ü.  Und es gibt nichts lustiges. <br><br>  Die Tatsache, dass die Industrie die SRP akzeptiert hat, ist sicherlich gut, aber andererseits und nicht sehr.  Meistens, weil SRP allein nicht die beste PAKE-Implementierung ist, obwohl jede PAKE-Empfehlung cool ist.  Ich dachte, ich w√ºrde in den Dschungel der Diskussionen √ºber SRP gehen, aber diese Rede zog sich bereits hin und ich schweife von der Geschichte √ºber ein wirklich gutes Protokoll ab, √ºber das wir weiter unten sprechen werden.  Wenn Sie immer noch an der Diskussion √ºber SRP interessiert sind, habe ich sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hierher gebracht</a> . <br><br>  Lassen Sie mich anstelle dieser unn√∂tigen Details eine kurze Zusammenfassung meiner Gedanken zu SRP schreiben: <br><br><ol><li>  SRP macht einige Dinge richtig.  Erstens m√ºssen Sie im Gegensatz zu fr√ºheren Versionen von PAKE das unformatierte Kennwort nicht auf dem Server speichern (oder gleichwertig einen Hash, der von einem Angreifer anstelle eines Kennworts verwendet werden k√∂nnte).  Stattdessen speichert der Server einen "Verifizierer", bei dem es sich um eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einwegfunktion</a> des Kennwort-Hash handelt.  Dies bedeutet, dass ein Angreifer aufgrund eines Kennwortdatenbanklecks einen Benutzer nur dann nicht sofort ersetzen kann, wenn er keine weiteren kostspieligen W√∂rterbuchangriffe ausf√ºhrt.  (Der technische Name hierf√ºr lautet "asymmetrisch" PAKE.) </li><li>  Es gibt bessere Nachrichten, die aktuelle Version von SRP (v4 v6a) wurde noch nicht gehackt! </li><li>  Allerdings (lassen Sie sich von den Entwicklern nicht beleidigen) ist die Architektur des SRP-Protokolls v√∂llig verr√ºckt und seine fr√ºheren Versionen wurden mehrmals gehackt - weshalb wir jetzt Version 6a haben.  Au√üerdem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beweist</a> der "Sicherheitsnachweis" im urspr√ºnglichen Forschungsartikel eigentlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nichts</a> . </li><li>  SRP basiert derzeit auf einer ganzzahligen (endg√ºltigen) Arithmetik, und aus verschiedenen Gr√ºnden (siehe Abschnitt 3 oben) kann seine Architektur eindeutig nicht auf eine elliptische <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kurve √ºbertragen werden</a> .  Dies erfordert mehr Bandbreite und Berechnung, sodass SRP die vielen Leistungsverbesserungen, die wir in Add-Ons wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Curve25519</a> entwickelt haben, nicht nutzen kann. </li><li>  SRP ist anf√§llig f√ºr Pre-Computing-Angriffe, da es das Salz des Benutzers an jeden Angreifer weitergibt, der eine SRP-Sitzung initiieren kann.  Dies bedeutet, dass ich Ihren Server nach Ihrem Salt fragen und ein W√∂rterbuch mit potenziellen Kennwort-Hashes erstellen kann, bevor der Server kompromittiert wird. </li><li>  Trotz all dieser M√§ngel ist SRP extrem einfach und enth√§lt auch Arbeitscode.  Dar√ºber hinaus verf√ºgt OpenSSL √ºber Arbeitscode, der sogar in TLS integriert ist, was die Implementierung relativ einfach macht. </li></ol><br>  Von all diesen Punkten ist letzterer mit ziemlicher Sicherheit f√ºr den (relativ) hohen kommerziellen Erfolg verantwortlich, den SRP gegen√ºber anderen PAKE-Protokollen erzielt hat.  Er ist nicht perfekt, aber echt.  Dies wollte ich Experten f√ºr kryptografische Sicherheit vermitteln. <br><br><h2>  OPAQUE: PAKE neue Generation </h2><br>  Als ich vor einigen Monaten anfing, √ºber PAKE nachzudenken, musste ich feststellen, dass die meisten vorhandenen Implementierungen eher schlecht abschnitten.  Entweder hatten sie Probleme, wie z. B. in SRP, und der Benutzer musste das Kennwort (oder das effektive Kennwort) auf dem Server speichern, oder dem Angreifer wurde das ‚ÄûSalz‚Äú angezeigt, sodass der Angriff vor der Berechnung ausgef√ºhrt werden konnte. <br><br>  Anfang letzten Jahres enth√ºllten Jarecki, Kravczyk und Xu der Welt ein neues Protokoll namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OPAQUE</a> .  Es hat eine Reihe von wesentlichen Vorteilen: <br><br><ol><li>  Es kann auch dann implementiert werden, wenn Probleme mit Diffie-Hellman und diskreten Logarithmen auftreten.  Dies bedeutet, dass es im Gegensatz zu SRP mithilfe effektiver elliptischer Kurven leicht instanziiert werden kann. </li><li>  Noch besser: OPAQUE enth√ºllt einem Angreifer kein Salz.  Er l√∂st dieses Problem, indem er "Saltful PRF" verwendet, um das Salt mit dem Passwort zu kombinieren, sodass der Client das Salt nicht erh√§lt und der Server das Passwort nicht erh√§lt. </li><li> OPAQUE funktioniert mit jeder Passwort-Hashing-Funktion.  Da alle Hashing-Arbeiten auf dem Client ausgef√ºhrt werden, kann OPAQUE den Server tats√§chlich entlasten und den Onlinedienst freigeben, um beispielsweise extrem umfangreiche Sicherheitseinstellungen zu verwenden, z. B. die <code>scrypt</code> mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">viel RAM zu</a> konfigurieren. </li><li>  In Bezug auf Nachrichtenanzahl und Exponenten unterscheidet sich OPAQUE nicht wesentlich von SRP.  Da es jedoch mit effizienteren Parametern implementiert werden kann, wird es wahrscheinlich viel effizienter arbeiten. </li><li>  Im Gegensatz zu SRP verf√ºgt OPAQUE √ºber angemessene Sicherheitsnachweise (in einem sehr starken Modell). </li></ol><br>  Es gibt sogar einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Internet-Entwurfsvorschlag</a> f√ºr OPAQUE, den Sie hier lesen k√∂nnen.  Leider wei√ü ich im Moment nichts √ºber die Qualit√§t der Code-Implementierung, au√üer dass es bereits mehrere m√∂gliche Implementierungen gibt.  Ich hoffe, dass dieses Problem bald behoben ist. <br>  Das vollwertige OPAQUE-Protokoll ist unten aufgef√ºhrt.  Im Rest dieses Abschnitts werde ich dar√ºber sprechen, wie es funktioniert. <br><br>  <b>Problem 1: Salz geheim halten.</b>  Wie oben erw√§hnt, besteht das Hauptproblem bei fr√ºheren Versionen von PAKE darin, dass Salt vom Server auf den Client √ºbertragen werden muss (immer noch nicht authentifiziert).  Auf diese Weise kann ein Angreifer vor dem Rechnen Angriffe ausf√ºhren, bei denen er anhand der empfangenen Daten ein W√∂rterbuch erstellen kann. <br><br>  Das Problem hierbei ist, dass Salt normalerweise zusammen mit dem Kennwort an eine Hash-Funktion (z. B. Verschl√ºsselung) √ºbergeben wird.  Intuitiv muss jemand diese Funktion berechnen.  Wenn es sich um einen Server handelt, sollte der Server ein Kennwort sehen, das jede Bedeutung zunichte macht.  Wenn dies ein Kunde ist, braucht er Salz. <br><br>  Theoretisch k√∂nnen Sie dieses Problem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">umgehen,</a> indem Sie die Kennwort-Hashing-Funktion mithilfe des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sicheren Zwei-Parteien-Berechnungsprotokolls (2PC) berechnen</a> .  In der Praxis sind solche L√∂sungen mit ziemlicher Sicherheit ineffektiv, vor allem, weil Kennwort-Hashing-Funktionen komplex und zeitaufw√§ndig sind.  Dies erh√∂ht die Komplexit√§t jedes 2PC-Systems erheblich. <br><br>  OPAQUE umgeht dies wie folgt.  Es hinterl√§sst einen Passwort-Hash auf der Clientseite, zeigt ihn jedoch nicht an.  Stattdessen wird ein spezielles Zwei-Wege-Protokoll namens Vergessliches PRF verwendet, um ein anderes Salt zu berechnen (nennen wir es salt2), sodass der Client salt2 in einer Hash-Funktion verwenden kann, aber nicht auf das urspr√ºngliche Salt zugreifen kann. <br><br>  Es funktioniert ungef√§hr so: <br><blockquote>  <i>Der Server speichert "salt" und der Client hat password.salt2 = PRF (salt, password). Dies wird zwischen dem Client und dem Server mithilfe eines Protokolls berechnet, bei dem der Client das Salt niemals erkennt und der Server das Kennwort kennt.</i>  <i>Der Client erh√§lt salt2K = PasswordHash (salt2, Passwort) - und all dies wird auf dem Client ber√ºcksichtigt.</i> </blockquote><br>  Die eigentliche Implementierung von vergesslichem PRF kann unter Verwendung mehrerer Gruppenelemente und Exponenten erfolgen.  Noch besser ist, wenn der Client das falsche Passwort eingibt, erh√§lt das Protokoll einen Dummy-Wert ‚Äûsalt2‚Äú, der nichts √ºber den tats√§chlichen Wert von salt aussagt. <br><br>  <b>Problem 2: Beweis, dass der Client den richtigen Schl√ºssel K erhalten hat.</b> Nat√ºrlich hat der Client im Moment den Schl√ºssel K erhalten, aber der Server hat keine Ahnung, was es ist.  Der Server wei√ü auch nicht, ob dies der richtige Schl√ºssel ist. <br><br>  Die OPAQUE-L√∂sung basiert auf der alten Idee von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gentry, Mackenzie und Ramzan</a> .  Wenn sich ein Benutzer zum ersten Mal am Server anmeldet, generiert der Server einen zuverl√§ssigen √∂ffentlichen und privaten Schl√ºssel f√ºr das Protokoll der sicheren Vereinbarung (z. B. HMQV) und verschl√ºsselt den empfangenen privaten Schl√ºssel unter K zusammen mit dem √∂ffentlichen Schl√ºssel des Servers.  Die resultierende authentifizierte Verschl√ºsselung (und der √∂ffentliche Schl√ºssel) werden in der Kennwortdatenbank gespeichert. <br><br>  <b><i>C = Verschl√ºsseln (K, geheimer Clientschl√ºssel | √∂ffentlicher Schl√ºssel des Servers)</i></b> <br><br><img src="https://habrastorage.org/webt/9z/tb/uk/9ztbukhcywebjlgyrlbbaltk-0a.png"><br>  <i>Vollversion des OPAQUE-Protokolls, Auszug aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> .</i> <br><br>  Wenn sich der Client mithilfe des OPAQUE-Protokolls authentifizieren m√∂chte, sendet ihm der Server den gespeicherten <b>C-</b> Code.  Wenn der Client in der ersten Phase das richtige Passwort eingegeben hat, kann er <b>K erhalten</b> und diese Chiffre entschl√ºsseln.  Ansonsten ist es nutzlos.  Mit einem kabelgebundenen geheimen Schl√ºssel kann er jetzt ein Standardvereinbarungsprotokoll mit einem authentifizierten Schl√ºssel ausf√ºhren, um den Handshake abzuschlie√üen.  (Der Server √ºberpr√ºft die Eingabe der Clients, indem er sie mit seiner Kopie des √∂ffentlichen Schl√ºssels des Clients vergleicht. Der Client f√ºhrt dasselbe aus.) <br><br>  <b>Lassen Sie uns jetzt alles zusammenf√ºgen.</b>  Alle diese Schritte k√∂nnen zu einem Protokoll kombiniert werden, das die gleiche Anzahl von Schritten wie SRP aufweist.  Wenn Sie die √úberpr√ºfungsschritte nicht beachten, sieht es wie im obigen Protokoll aus.  Im Prinzip besteht die Idee nur aus zwei Nachrichten: eine vom Client und die zweite wird an den Server zur√ºckgesendet. <br><br>  Der letzte Aspekt der Arbeit von OPAQUE ist, dass es gute Sicherheitsnachweise gibt, die uns sagen, dass das resultierende Protokoll als sicher angesehen werden kann, wenn wir einen oder mehrere diskrete Logarithmen in einem zuf√§lligen Orakelmodell verwenden, was anscheinend eine Standardannahme ist findet in den Einstellungen statt, mit denen wir arbeiten. <br><br><h2>  Fazit </h2><br>  Kurz gesagt, wir verf√ºgen √ºber eine zuverl√§ssige Technologie, die die Verwendung von Kennw√∂rtern erheblich vereinfacht und es uns erm√∂glicht, diese effizienter zu handhaben - mit vielen Hashing-Parametern und einer hohen Arbeitsbelastung auf der Clientseite.  Warum wird das nicht √ºberall verwendet?  Vielleicht wird sich in den n√§chsten Jahren alles √§ndern.  Die Zeit wird zeigen. <br><br>  Gem√§√ü der etablierten Tradition warten wir auf Ihre Kommentare und laden Sie ein, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Tag der offenen T√ºr</a> zu besuchen, der am 27. Mai von unserer Lehrerin, Kryptoanalytikerin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Elena Kirshanova</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">abgehalten wird</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453334/">https://habr.com/ru/post/de453334/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453324/index.html">Diode als Gleichrichter</a></li>
<li><a href="../de453326/index.html">So automatisieren Sie das IT-Infrastrukturmanagement - diskutieren Sie drei Trends</a></li>
<li><a href="../de453328/index.html">Zehn Jahre an einem abgelegenen Ort</a></li>
<li><a href="../de453330/index.html">Was tun, wenn der RAM abst√ºrzt? Anamnese und Behandlungsmethoden</a></li>
<li><a href="../de453332/index.html">√úber die seltsame Methode, Festplattenspeicher zu sparen</a></li>
<li><a href="../de453336/index.html">Auswahlhilfe f√ºr CNC-Brennmaschinen</a></li>
<li><a href="../de453338/index.html">Rust 1.35.0 Release: Implementierungen funktionaler Merkmale und andere Innovationen</a></li>
<li><a href="../de453340/index.html">Perl 5.30 ver√∂ffentlicht</a></li>
<li><a href="../de453342/index.html">Mythen √ºber entfernte Mitarbeiter, die wir selbst zerst√∂rt haben</a></li>
<li><a href="../de453346/index.html">Speicher- und Datenschutztechnologien - der dritte Tag auf der VMware EMPOWER 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>