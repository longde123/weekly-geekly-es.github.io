<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖖🏻 💃 🌉 .Net Binäre Serialisierung ohne Bezugnahme auf die Assembly mit dem Quelltyp oder wie mit BinaryFormatter verhandelt wird 🏵️ 🏻 👩🏾‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werde ich die Erfahrungen mit der Serialisierung von Binärtypen zwischen Assemblys ohne Bezug zueinander teilen. Wie sich herausstel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.Net Binäre Serialisierung ohne Bezugnahme auf die Assembly mit dem Quelltyp oder wie mit BinaryFormatter verhandelt wird</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430646/">  In diesem Artikel werde ich die Erfahrungen mit der Serialisierung von Binärtypen zwischen Assemblys ohne Bezug zueinander teilen.  Wie sich herausstellte, gibt es echte und „legitime“ Fälle, in denen Sie Daten deserialisieren müssen, ohne einen Link zu der Assembly zu haben, in der sie deklariert sind.  In dem Artikel werde ich über das Szenario sprechen, in dem es erforderlich war, ich werde die Lösungsmethode beschreiben und ich werde auch über Zwischenfehler sprechen, die während der Suche gemacht wurden <br><br><h3>  Einführung  Erklärung des Problems </h3><br>  Wir arbeiten mit einem großen Unternehmen auf dem Gebiet der Geologie zusammen.  In der Vergangenheit hat das Unternehmen eine sehr unterschiedliche Software für die Arbeit mit Daten geschrieben, die von verschiedenen Gerätetypen stammen + Datenanalyse + Prognose.  Leider ist all diese Software weit davon entfernt, immer „freundlich“ miteinander zu sein, und meistens überhaupt nicht freundlich.  Um die Informationen irgendwie zu konsolidieren, wird jetzt ein Webportal erstellt, in dem verschiedene Programme ihre Daten in Form von XML hochladen.  Und das Portal versucht, eine Plus-Minus-Gesamtansicht zu erstellen.  Eine wichtige Nuance: Da die Entwickler des Portals in den Themenbereichen jeder Anwendung nicht stark sind, stellte jedes Team ein Parser / Datenkonverter-Modul von seiner XML-Datei für die Portaldatenstrukturen bereit. <br><a name="habracut"></a><br>  Ich arbeite in einem Team, das eine der Anwendungen entwickelt, und wir haben ziemlich einfach einen Exportmechanismus für unseren Teil der Daten geschrieben.  Hier entschied der Geschäftsanalyst jedoch, dass das zentrale Portal einen der Berichte benötigt, die unser Programm erstellt.  Hier trat das erste Problem auf: Der Bericht wird jedes Mal neu erstellt und die Ergebnisse werden nirgendwo gespeichert. <br>  "Also rette es!"  Der Leser wird wahrscheinlich denken.  Das habe ich auch gedacht, war aber ernsthaft enttäuscht von der Anforderung, dass der Bericht bereits für die heruntergeladenen Daten erstellt werden muss.  Nichts zu tun - Sie müssen Logik übertragen. <br><br><h2>  Stufe 0. Refactoring.  Nichts bedeutete Ärger </h2><br>  Es wurde beschlossen, die Logik zum Erstellen des Berichts (tatsächlich ist dies eine 4-Spalten-Beschriftung, aber die Logik ist ein Wagen und ein großer Wagen) in eine separate Klasse zu unterteilen und die Datei mit dieser Klasse durch Bezugnahme in die Parser-Assembly aufzunehmen.  Damit wir: <br><br><ol><li>  Vermeiden Sie direktes Kopieren </li><li>  Schutz vor Versionsdifferenzen </li></ol><br>  Die Aufteilung der Logik in eine separate Klasse ist keine schwierige Aufgabe.  Aber dann war nicht alles so rosig: Der Algorithmus basierte auf Geschäftsobjekten, deren Übertragung nicht in unser Konzept passte.  Ich musste die Methoden neu schreiben, damit sie nur einfache Typen akzeptieren und sie bearbeiten.  Es war nicht immer einfach und erforderte stellenweise Lösungen, deren Schönheit in Frage blieb, aber insgesamt wurde eine zuverlässige Lösung ohne offensichtliche Krücken erhalten. <br><br>  Es gab ein Detail, das, wie Sie wissen, oft als gemütliche Zuflucht für den Teufel dient: Wir haben einen seltsamen Ansatz von früheren Entwicklergenerationen geerbt, nach dem einige der zum Erstellen eines Berichts erforderlichen Daten als binär serialisierte .Net-Objekte in der Datenbank gespeichert werden ( Fragen „Warum?“, „Kaaak?“ usw. bleiben leider aufgrund des Mangels an Adressaten unbeantwortet.  Und bei der Eingabe der Berechnungen müssen wir sie natürlich deserialisieren. <br><br>  Diese Typen, die man nicht loswerden konnte, haben wir auch "per Referenz" aufgenommen, zumal sie eher nicht kompliziert waren. <br><br><h3>  Stufe 1. Deserialisierung.  Merken Sie sich den vollständigen Typnamen </h3><br>  Nachdem ich die obigen Manipulationen durchgeführt und einen Testlauf durchgeführt hatte, erhielt ich unerwartet einen Laufzeitfehler <br><blockquote>  [A] Namespace.TypeA kann nicht in [B] Namespace.TypeA umgewandelt werden.  Typ A stammt aus 'Assembley.Application, Version = 1.0.0.0, Culture = neutral, PublicKeyToken = null' im Kontext 'Default' am Speicherort '...'.  Typ B stammt aus 'Assmbley.Portal, Version = 1.0.0.0, Culture = neutral, PublicKeyToken = null' im Kontext 'Default' at location ''. </blockquote>  Die allerersten Google-Links haben mir mitgeteilt, dass BinaryFormatter nicht nur Daten schreibt, sondern auch Informationen in den Ausgabestream eingibt, was logisch ist.  Und wenn man bedenkt, dass der vollständige Name des Typs die Assembly enthält, in der er deklariert ist, unterscheidet sich das Bild von dem, für das ich versucht habe, einen Typ zu deserialisieren, völlig aus der Sicht von .Net <br><br>  Nachdem ich mich am Kopf gekratzt hatte, traf ich zufällig eine offensichtliche, aber leider bösartige Entscheidung, einen bestimmten Typ A-Typ während der <b>dynamischen</b> Deserialisierung zu ersetzen.  Alles hat funktioniert.  Die Ergebnisse des Berichts konvergierten von oben nach unten, Tests auf dem Build-Server wurden bestanden.  Mit dem Gefühl der Leistung senden wir die Aufgabe an die Tester. <br><br><h3>  Stufe 2. Die Haupt.  Serialisierung zwischen Baugruppen </h3><br>  Die Abrechnung erfolgte schnell in Form von von Testern registrierten Fehlern, die besagten, dass der Parser auf der Portalseite mit der Ausnahme, dass die Assembly Assembley.Application (Assembly aus unserer Anwendung) nicht geladen werden konnte, herunterfiel.  Erster Gedanke - Ich habe keine Referenzen bereinigt.  Aber - nein, alles ist in Ordnung, niemand bezieht sich.  Ich versuche es erneut im Sandkasten auszuführen - alles funktioniert.  Ich fange an, einen Erstellungsfehler zu vermuten, aber hier fällt mir eine Idee ein, die mir nicht gefällt: Ich ändere den Ausgabepfad für den Parser in einen separaten Ordner und nicht in das freigegebene bin-Verzeichnis der Anwendung.  Und voila - ich bekomme die beschriebene Ausnahme.  Die Stectrace-Analyse bestätigt vage Vermutungen - die Deserialisierung nimmt ab. <br><br>  Das Bewusstsein war schnell und schmerzhaft: Das Ersetzen eines bestimmten Typs durch Dynamic änderte nichts. BinaryFormatter erstellte immer noch einen Typ aus einer externen Assembly, nur wenn die Assembly mit dem Typ in der Nähe war, die Laufzeit ihn natürlich lud und wenn die Assembly weg war. Wir bekommen einen Fehler. <br><br>  Es gab einen Grund, traurig zu sein.  Aber googeln gab Hoffnung in Form <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der SerializationBinder-Klasse</a> .  Wie sich herausstellte, können Sie damit den Typ bestimmen, in dem unsere Daten deserialisiert werden.  Erstellen Sie dazu einen Erben und definieren Sie darin die folgende Methode. <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> Type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BindToType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">String assemblyName, String typeName</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br>  in dem Sie für bestimmte Bedingungen einen beliebigen Typ zurückgeben können. <br>  Die BinaryFormatter-Klasse verfügt über eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Binder-</a> Eigenschaft, in die Sie Ihre Implementierung einfügen können. <br><br>  Es scheint, dass es kein Problem gibt.  Aber auch hier bleiben Details (siehe oben). <br><br>  Zunächst müssen Sie Anforderungen für <b>alle</b> Typen (und auch für Standard) verarbeiten. <br><blockquote>  Eine interessante Implementierungsoption wurde hier im Internet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gefunden</a> , aber sie versuchen, den Standardordner von BinaryFormatter in Form einer Konstruktion zu verwenden <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> defaultBinder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryFormatter().Binder</code> </pre> <br>  Tatsächlich ist die Binder-Eigenschaft jedoch standardmäßig null.  Eine Analyse des Quellcodes ergab, dass innerhalb des BinaryFormatter, ob Binder überprüft wird, wenn ja, seine Methoden aufgerufen werden, wenn nicht, interne Logik verwendet wird, die letztendlich auf läuft <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> assembly = Assembly.Load(assemblyName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FormatterServices.GetTypeFromAssembly(assembly, typeName);</code> </pre><br></blockquote>  Ohne weiteres wiederholte ich die gleiche Logik in mir. <br><br>  Folgendes ist in der ersten Implementierung passiert <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyBinder</span></span> : <span class="hljs-title"><span class="hljs-title">SerializationBinder</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> Type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BindToType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> assemblyName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> typeName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (assemblyName.Contains(<span class="hljs-string"><span class="hljs-string">"&lt;ObligatoryPartOfNamespace&gt;"</span></span>) ) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bindToType = Type.GetType(typeName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bindToType; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bindToType = LoadTypeFromAssembly(assemblyName, typeName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bindToType; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadTypeFromAssembly</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> assemblyName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> typeName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(assemblyName) || <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(typeName)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> assembly = Assembly.Load(assemblyName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FormatterServices.GetTypeFromAssembly(assembly, typeName); } }</code> </pre><br>  Das heißt,  Es wird geprüft, ob der Namespace zum Projekt gehört - wir geben den Typ aus der aktuellen Domäne zurück, wenn der Systemtyp - wir laden aus der entsprechenden Assembly <br><br>  Es sieht logisch aus.  Wir beginnen zu testen: Unser Typ kommt - wir ersetzen, er wird erstellt.  Hurra!  String kommt - wir gehen entlang des Zweigs mit dem Laden aus der Baugruppe.  Es funktioniert!  Öffnen Sie virtuellen Champagner ... <br><br>  Aber hier ... Ein Wörterbuch enthält Elemente von Benutzertypen: Da es sich um einen Systemtyp handelt, versuchen wir natürlich, ihn aus der Assembly zu laden, aber da die Elemente, die er enthält, unsere Typen sind, mit vollständiger Qualifikation (Assembly, Version, Schlüssel) ), dann fallen wir wieder.  (Es sollte ein trauriges Lächeln geben). <br><br>  Natürlich müssen Sie den Eingabenamen des Typs ändern und Links zur gewünschten Assembly ersetzen.  Ich habe wirklich gehofft, dass es für den Typnamen ein Analogon der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AssemblyName-</a> Klasse gibt, aber ich habe nichts Ähnliches gefunden.  Das Schreiben eines universellen Parsers mit Ersatz ist keine leichte Aufgabe.  Nach einer Reihe von Experimenten kam ich zu der folgenden Lösung: Im statischen Konstruktor subtrahiere ich die zu ersetzenden Typen und suche dann in der Zeile nach dem Namen des erstellten Typs nach ihren Namen. Wenn ich ihn finde, ersetze ich den Namen der Baugruppe <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> The types that may be changed to local </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> protected static IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type&gt;</span></span></span><span class="hljs-comment"> _changedTypes; static MyBinder() { var executingAssembly = Assembly.GetCallingAssembly(); var name = executingAssembly.GetName().Name; _changedTypes = executingAssembly.GetTypes().Where(t =&gt; t.Namespace != null &amp;&amp; !t.Namespace.Contains(name) &amp;&amp; !t.Name.StartsWith("</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;")); //!t.Namespace.Contains(name) - .     ,         // "&lt;'      -     } private static string CorrectTypeName(string name) { foreach (var changedType in _changedTypes) { var ind = name.IndexOf(changedType.FullName); if (ind != -1) { var endIndex = name.IndexOf("PublicKeyToken", ind) ; if (endIndex != -1) { endIndex += +"PublicKeyToken".Length + 1; while (char.IsLetterOrDigit(name[endIndex++])) { } var sb = new StringBuilder(); sb.Append(name.Substring(0, ind)); sb.Append(changedType.AssemblyQualifiedName); sb.Append(name.Substring(endIndex-1)); name = sb.ToString(); } } } return name; } /// &lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> look up the type locally if the assembly-name is "NA" </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="assemblyName"&gt;</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="typeName"&gt;</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> public override Type BindToType(string assemblyName, string typeName) { typeName = CorrectTypeName(typeName); if (assemblyName.Contains("</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;ObligatoryPartOfNamespace&gt;</span></span></span><span class="hljs-comment">") || assemblyName.Equals("NA")) { var bindToType = Type.GetType(typeName); return bindToType; } else { var bindToType = LoadTypeFromAssembly(assemblyName, typeName); return bindToType; } }</span></span></code> </pre><br>  Wie Sie sehen können, habe ich davon ausgegangen, dass PublicKeyToken das letzte in der Typbeschreibung ist.  Vielleicht ist dies nicht 100% zuverlässig, aber in meinen Tests habe ich keine Fälle gefunden, in denen dies nicht der Fall ist. <br><br>  Also eine Zeile der Form <br><blockquote>  "System.Collections.Generic.Dictionary`2 [[SomeNamespace.CustomType, Assembley.Application, Version = 1.0.0.0, Culture = neutral, PublicKeyToken = null], [System.Byte [], mscorlib, Version = 4.0.0.0, Kultur = neutral, PublicKeyToken = b77a5c561934e089]] » </blockquote><br>  verwandelt sich in <br><blockquote>  "System.Collections.Generic.Dictionary`2 [[SomeNamespace.CustomType, Assembley.Portal, Version = 1.0.0.0, Culture = neutral, PublicKeyToken = null], [System.Byte [], mscorlib, Version = 4.0.0.0, Kultur = neutral, PublicKeyToken = b77a5c561934e089]] » </blockquote><br>  Jetzt funktionierte endlich alles "wie eine Uhr".  Es gab kleinere technische Feinheiten: Wenn Sie sich erinnern, wurden die von uns enthaltenen Dateien in den Link der Hauptanwendung aufgenommen.  In der Hauptanwendung werden all diese Tänze jedoch nicht benötigt.  Daher ein bedingter Kompilierungsmechanismus des Formulars <br><br><pre> <code class="cs hljs">BinaryFormatter binForm = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryFormatter(); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> EXTERNAL_LIB binForm.Binder = new MyBinder(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  Dementsprechend definieren wir in der Portalassembly das Makro EXTERNAL_LIB, aber in der Hauptanwendung - Nr <br><blockquote><h4>  "Nicht-lyrischer Exkurs" </h4><br>  Tatsächlich habe ich beim Codieren, um die Lösung schnell zu überprüfen, eine Fehleinschätzung vorgenommen, die mich wahrscheinlich eine bestimmte Anzahl von Nervenzellen gekostet hat: Für den Anfang habe ich nur die Typensubstitution für Dicitionary fest codiert.  Infolgedessen stellte sich nach der Deserialisierung heraus, dass es sich um ein leeres Wörterbuch handelte, das ebenfalls "abstürzte", wenn versucht wurde, einige Operationen damit auszuführen.  Ich begann bereits zu glauben, dass man <i>BinaryFormatter nicht täuschen könnte</i> , und begann verzweifelte Experimente mit dem Versuch, den Erben des Wörterbuchs zu schreiben.  Glücklicherweise hörte ich fast rechtzeitig auf und schrieb wieder einen universellen Substitutionsmechanismus. Als ich ihn implementierte, stellte ich fest, dass es nicht ausreicht, seinen Typ neu zu definieren, um seinen Typ neu zu definieren: Sie müssen sich immer noch um die Typen für KeyValuePair &lt;TKey, TValue&gt;, Comparer kümmern, die ebenfalls angefordert werden Bindemittel <br><br><br>  Dies sind die Abenteuer der binären Serialisierung.  Für das Feedback wäre ich dankbar. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430646/">https://habr.com/ru/post/de430646/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430632/index.html">Service in der Wirtschaft: Wie ausländische Einzelhändler schlüsselfertige Geschäfte in Russland eröffnen</a></li>
<li><a href="../de430634/index.html">Erstellen eines Softwaremoduls für den Programmierer XELTEK SuperPro 6100</a></li>
<li><a href="../de430636/index.html">Kleinhirn und Basalkerne anstelle der Kristallkugel: Wie das Gehirn die Zukunft vorhersagt</a></li>
<li><a href="../de430640/index.html">Rotes Meer: Warum die Aktien von Apple und anderen Technologieunternehmen fallen</a></li>
<li><a href="../de430642/index.html">Regie "Photonik" bei den Olympischen Spielen "Ich bin ein Profi" oder wie man sich ohne Prüfungen in eine Magistratur einschreibt</a></li>
<li><a href="../de430648/index.html">Geschichte von Pac-Man</a></li>
<li><a href="../de430650/index.html">Sex ist ein Verkäufer klassischer Arcade-Spiele. Und wer ist der Käufer?</a></li>
<li><a href="../de430654/index.html">devleads meetup: Wir stellen ein effektives Team zusammen, optimieren die Entwicklung und diskutieren aktuelle Themen</a></li>
<li><a href="../de430656/index.html">Zertifiziertes SAFe®-Programm</a></li>
<li><a href="../de430658/index.html">Wie es begann - Die Geburt von Videospielen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>