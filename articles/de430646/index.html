<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üññüèª üíÉ üåâ .Net Bin√§re Serialisierung ohne Bezugnahme auf die Assembly mit dem Quelltyp oder wie mit BinaryFormatter verhandelt wird üèµÔ∏è üèª üë©üèæ‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werde ich die Erfahrungen mit der Serialisierung von Bin√§rtypen zwischen Assemblys ohne Bezug zueinander teilen. Wie sich herausstel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.Net Bin√§re Serialisierung ohne Bezugnahme auf die Assembly mit dem Quelltyp oder wie mit BinaryFormatter verhandelt wird</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430646/">  In diesem Artikel werde ich die Erfahrungen mit der Serialisierung von Bin√§rtypen zwischen Assemblys ohne Bezug zueinander teilen.  Wie sich herausstellte, gibt es echte und ‚Äûlegitime‚Äú F√§lle, in denen Sie Daten deserialisieren m√ºssen, ohne einen Link zu der Assembly zu haben, in der sie deklariert sind.  In dem Artikel werde ich √ºber das Szenario sprechen, in dem es erforderlich war, ich werde die L√∂sungsmethode beschreiben und ich werde auch √ºber Zwischenfehler sprechen, die w√§hrend der Suche gemacht wurden <br><br><h3>  Einf√ºhrung  Erkl√§rung des Problems </h3><br>  Wir arbeiten mit einem gro√üen Unternehmen auf dem Gebiet der Geologie zusammen.  In der Vergangenheit hat das Unternehmen eine sehr unterschiedliche Software f√ºr die Arbeit mit Daten geschrieben, die von verschiedenen Ger√§tetypen stammen + Datenanalyse + Prognose.  Leider ist all diese Software weit davon entfernt, immer ‚Äûfreundlich‚Äú miteinander zu sein, und meistens √ºberhaupt nicht freundlich.  Um die Informationen irgendwie zu konsolidieren, wird jetzt ein Webportal erstellt, in dem verschiedene Programme ihre Daten in Form von XML hochladen.  Und das Portal versucht, eine Plus-Minus-Gesamtansicht zu erstellen.  Eine wichtige Nuance: Da die Entwickler des Portals in den Themenbereichen jeder Anwendung nicht stark sind, stellte jedes Team ein Parser / Datenkonverter-Modul von seiner XML-Datei f√ºr die Portaldatenstrukturen bereit. <br><a name="habracut"></a><br>  Ich arbeite in einem Team, das eine der Anwendungen entwickelt, und wir haben ziemlich einfach einen Exportmechanismus f√ºr unseren Teil der Daten geschrieben.  Hier entschied der Gesch√§ftsanalyst jedoch, dass das zentrale Portal einen der Berichte ben√∂tigt, die unser Programm erstellt.  Hier trat das erste Problem auf: Der Bericht wird jedes Mal neu erstellt und die Ergebnisse werden nirgendwo gespeichert. <br>  "Also rette es!"  Der Leser wird wahrscheinlich denken.  Das habe ich auch gedacht, war aber ernsthaft entt√§uscht von der Anforderung, dass der Bericht bereits f√ºr die heruntergeladenen Daten erstellt werden muss.  Nichts zu tun - Sie m√ºssen Logik √ºbertragen. <br><br><h2>  Stufe 0. Refactoring.  Nichts bedeutete √Ñrger </h2><br>  Es wurde beschlossen, die Logik zum Erstellen des Berichts (tats√§chlich ist dies eine 4-Spalten-Beschriftung, aber die Logik ist ein Wagen und ein gro√üer Wagen) in eine separate Klasse zu unterteilen und die Datei mit dieser Klasse durch Bezugnahme in die Parser-Assembly aufzunehmen.  Damit wir: <br><br><ol><li>  Vermeiden Sie direktes Kopieren </li><li>  Schutz vor Versionsdifferenzen </li></ol><br>  Die Aufteilung der Logik in eine separate Klasse ist keine schwierige Aufgabe.  Aber dann war nicht alles so rosig: Der Algorithmus basierte auf Gesch√§ftsobjekten, deren √úbertragung nicht in unser Konzept passte.  Ich musste die Methoden neu schreiben, damit sie nur einfache Typen akzeptieren und sie bearbeiten.  Es war nicht immer einfach und erforderte stellenweise L√∂sungen, deren Sch√∂nheit in Frage blieb, aber insgesamt wurde eine zuverl√§ssige L√∂sung ohne offensichtliche Kr√ºcken erhalten. <br><br>  Es gab ein Detail, das, wie Sie wissen, oft als gem√ºtliche Zuflucht f√ºr den Teufel dient: Wir haben einen seltsamen Ansatz von fr√ºheren Entwicklergenerationen geerbt, nach dem einige der zum Erstellen eines Berichts erforderlichen Daten als bin√§r serialisierte .Net-Objekte in der Datenbank gespeichert werden ( Fragen ‚ÄûWarum?‚Äú, ‚ÄûKaaak?‚Äú usw. bleiben leider aufgrund des Mangels an Adressaten unbeantwortet.  Und bei der Eingabe der Berechnungen m√ºssen wir sie nat√ºrlich deserialisieren. <br><br>  Diese Typen, die man nicht loswerden konnte, haben wir auch "per Referenz" aufgenommen, zumal sie eher nicht kompliziert waren. <br><br><h3>  Stufe 1. Deserialisierung.  Merken Sie sich den vollst√§ndigen Typnamen </h3><br>  Nachdem ich die obigen Manipulationen durchgef√ºhrt und einen Testlauf durchgef√ºhrt hatte, erhielt ich unerwartet einen Laufzeitfehler <br><blockquote>  [A] Namespace.TypeA kann nicht in [B] Namespace.TypeA umgewandelt werden.  Typ A stammt aus 'Assembley.Application, Version = 1.0.0.0, Culture = neutral, PublicKeyToken = null' im Kontext 'Default' am Speicherort '...'.  Typ B stammt aus 'Assmbley.Portal, Version = 1.0.0.0, Culture = neutral, PublicKeyToken = null' im Kontext 'Default' at location ''. </blockquote>  Die allerersten Google-Links haben mir mitgeteilt, dass BinaryFormatter nicht nur Daten schreibt, sondern auch Informationen in den Ausgabestream eingibt, was logisch ist.  Und wenn man bedenkt, dass der vollst√§ndige Name des Typs die Assembly enth√§lt, in der er deklariert ist, unterscheidet sich das Bild von dem, f√ºr das ich versucht habe, einen Typ zu deserialisieren, v√∂llig aus der Sicht von .Net <br><br>  Nachdem ich mich am Kopf gekratzt hatte, traf ich zuf√§llig eine offensichtliche, aber leider b√∂sartige Entscheidung, einen bestimmten Typ A-Typ w√§hrend der <b>dynamischen</b> Deserialisierung zu ersetzen.  Alles hat funktioniert.  Die Ergebnisse des Berichts konvergierten von oben nach unten, Tests auf dem Build-Server wurden bestanden.  Mit dem Gef√ºhl der Leistung senden wir die Aufgabe an die Tester. <br><br><h3>  Stufe 2. Die Haupt.  Serialisierung zwischen Baugruppen </h3><br>  Die Abrechnung erfolgte schnell in Form von von Testern registrierten Fehlern, die besagten, dass der Parser auf der Portalseite mit der Ausnahme, dass die Assembly Assembley.Application (Assembly aus unserer Anwendung) nicht geladen werden konnte, herunterfiel.  Erster Gedanke - Ich habe keine Referenzen bereinigt.  Aber - nein, alles ist in Ordnung, niemand bezieht sich.  Ich versuche es erneut im Sandkasten auszuf√ºhren - alles funktioniert.  Ich fange an, einen Erstellungsfehler zu vermuten, aber hier f√§llt mir eine Idee ein, die mir nicht gef√§llt: Ich √§ndere den Ausgabepfad f√ºr den Parser in einen separaten Ordner und nicht in das freigegebene bin-Verzeichnis der Anwendung.  Und voila - ich bekomme die beschriebene Ausnahme.  Die Stectrace-Analyse best√§tigt vage Vermutungen - die Deserialisierung nimmt ab. <br><br>  Das Bewusstsein war schnell und schmerzhaft: Das Ersetzen eines bestimmten Typs durch Dynamic √§nderte nichts. BinaryFormatter erstellte immer noch einen Typ aus einer externen Assembly, nur wenn die Assembly mit dem Typ in der N√§he war, die Laufzeit ihn nat√ºrlich lud und wenn die Assembly weg war. Wir bekommen einen Fehler. <br><br>  Es gab einen Grund, traurig zu sein.  Aber googeln gab Hoffnung in Form <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der SerializationBinder-Klasse</a> .  Wie sich herausstellte, k√∂nnen Sie damit den Typ bestimmen, in dem unsere Daten deserialisiert werden.  Erstellen Sie dazu einen Erben und definieren Sie darin die folgende Methode. <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> Type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BindToType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">String assemblyName, String typeName</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br>  in dem Sie f√ºr bestimmte Bedingungen einen beliebigen Typ zur√ºckgeben k√∂nnen. <br>  Die BinaryFormatter-Klasse verf√ºgt √ºber eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Binder-</a> Eigenschaft, in die Sie Ihre Implementierung einf√ºgen k√∂nnen. <br><br>  Es scheint, dass es kein Problem gibt.  Aber auch hier bleiben Details (siehe oben). <br><br>  Zun√§chst m√ºssen Sie Anforderungen f√ºr <b>alle</b> Typen (und auch f√ºr Standard) verarbeiten. <br><blockquote>  Eine interessante Implementierungsoption wurde hier im Internet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gefunden</a> , aber sie versuchen, den Standardordner von BinaryFormatter in Form einer Konstruktion zu verwenden <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> defaultBinder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryFormatter().Binder</code> </pre> <br>  Tats√§chlich ist die Binder-Eigenschaft jedoch standardm√§√üig null.  Eine Analyse des Quellcodes ergab, dass innerhalb des BinaryFormatter, ob Binder √ºberpr√ºft wird, wenn ja, seine Methoden aufgerufen werden, wenn nicht, interne Logik verwendet wird, die letztendlich auf l√§uft <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> assembly = Assembly.Load(assemblyName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FormatterServices.GetTypeFromAssembly(assembly, typeName);</code> </pre><br></blockquote>  Ohne weiteres wiederholte ich die gleiche Logik in mir. <br><br>  Folgendes ist in der ersten Implementierung passiert <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyBinder</span></span> : <span class="hljs-title"><span class="hljs-title">SerializationBinder</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> Type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BindToType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> assemblyName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> typeName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (assemblyName.Contains(<span class="hljs-string"><span class="hljs-string">"&lt;ObligatoryPartOfNamespace&gt;"</span></span>) ) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bindToType = Type.GetType(typeName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bindToType; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bindToType = LoadTypeFromAssembly(assemblyName, typeName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bindToType; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadTypeFromAssembly</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> assemblyName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> typeName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(assemblyName) || <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(typeName)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> assembly = Assembly.Load(assemblyName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FormatterServices.GetTypeFromAssembly(assembly, typeName); } }</code> </pre><br>  Das hei√üt,  Es wird gepr√ºft, ob der Namespace zum Projekt geh√∂rt - wir geben den Typ aus der aktuellen Dom√§ne zur√ºck, wenn der Systemtyp - wir laden aus der entsprechenden Assembly <br><br>  Es sieht logisch aus.  Wir beginnen zu testen: Unser Typ kommt - wir ersetzen, er wird erstellt.  Hurra!  String kommt - wir gehen entlang des Zweigs mit dem Laden aus der Baugruppe.  Es funktioniert!  √ñffnen Sie virtuellen Champagner ... <br><br>  Aber hier ... Ein W√∂rterbuch enth√§lt Elemente von Benutzertypen: Da es sich um einen Systemtyp handelt, versuchen wir nat√ºrlich, ihn aus der Assembly zu laden, aber da die Elemente, die er enth√§lt, unsere Typen sind, mit vollst√§ndiger Qualifikation (Assembly, Version, Schl√ºssel) ), dann fallen wir wieder.  (Es sollte ein trauriges L√§cheln geben). <br><br>  Nat√ºrlich m√ºssen Sie den Eingabenamen des Typs √§ndern und Links zur gew√ºnschten Assembly ersetzen.  Ich habe wirklich gehofft, dass es f√ºr den Typnamen ein Analogon der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AssemblyName-</a> Klasse gibt, aber ich habe nichts √Ñhnliches gefunden.  Das Schreiben eines universellen Parsers mit Ersatz ist keine leichte Aufgabe.  Nach einer Reihe von Experimenten kam ich zu der folgenden L√∂sung: Im statischen Konstruktor subtrahiere ich die zu ersetzenden Typen und suche dann in der Zeile nach dem Namen des erstellten Typs nach ihren Namen. Wenn ich ihn finde, ersetze ich den Namen der Baugruppe <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> The types that may be changed to local </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> protected static IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type&gt;</span></span></span><span class="hljs-comment"> _changedTypes; static MyBinder() { var executingAssembly = Assembly.GetCallingAssembly(); var name = executingAssembly.GetName().Name; _changedTypes = executingAssembly.GetTypes().Where(t =&gt; t.Namespace != null &amp;&amp; !t.Namespace.Contains(name) &amp;&amp; !t.Name.StartsWith("</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;")); //!t.Namespace.Contains(name) - .     ,         // "&lt;'      -     } private static string CorrectTypeName(string name) { foreach (var changedType in _changedTypes) { var ind = name.IndexOf(changedType.FullName); if (ind != -1) { var endIndex = name.IndexOf("PublicKeyToken", ind) ; if (endIndex != -1) { endIndex += +"PublicKeyToken".Length + 1; while (char.IsLetterOrDigit(name[endIndex++])) { } var sb = new StringBuilder(); sb.Append(name.Substring(0, ind)); sb.Append(changedType.AssemblyQualifiedName); sb.Append(name.Substring(endIndex-1)); name = sb.ToString(); } } } return name; } /// &lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> look up the type locally if the assembly-name is "NA" </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="assemblyName"&gt;</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="typeName"&gt;</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> public override Type BindToType(string assemblyName, string typeName) { typeName = CorrectTypeName(typeName); if (assemblyName.Contains("</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;ObligatoryPartOfNamespace&gt;</span></span></span><span class="hljs-comment">") || assemblyName.Equals("NA")) { var bindToType = Type.GetType(typeName); return bindToType; } else { var bindToType = LoadTypeFromAssembly(assemblyName, typeName); return bindToType; } }</span></span></code> </pre><br>  Wie Sie sehen k√∂nnen, habe ich davon ausgegangen, dass PublicKeyToken das letzte in der Typbeschreibung ist.  Vielleicht ist dies nicht 100% zuverl√§ssig, aber in meinen Tests habe ich keine F√§lle gefunden, in denen dies nicht der Fall ist. <br><br>  Also eine Zeile der Form <br><blockquote>  "System.Collections.Generic.Dictionary`2 [[SomeNamespace.CustomType, Assembley.Application, Version = 1.0.0.0, Culture = neutral, PublicKeyToken = null], [System.Byte [], mscorlib, Version = 4.0.0.0, Kultur = neutral, PublicKeyToken = b77a5c561934e089]] ¬ª </blockquote><br>  verwandelt sich in <br><blockquote>  "System.Collections.Generic.Dictionary`2 [[SomeNamespace.CustomType, Assembley.Portal, Version = 1.0.0.0, Culture = neutral, PublicKeyToken = null], [System.Byte [], mscorlib, Version = 4.0.0.0, Kultur = neutral, PublicKeyToken = b77a5c561934e089]] ¬ª </blockquote><br>  Jetzt funktionierte endlich alles "wie eine Uhr".  Es gab kleinere technische Feinheiten: Wenn Sie sich erinnern, wurden die von uns enthaltenen Dateien in den Link der Hauptanwendung aufgenommen.  In der Hauptanwendung werden all diese T√§nze jedoch nicht ben√∂tigt.  Daher ein bedingter Kompilierungsmechanismus des Formulars <br><br><pre> <code class="cs hljs">BinaryFormatter binForm = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryFormatter(); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> EXTERNAL_LIB binForm.Binder = new MyBinder(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  Dementsprechend definieren wir in der Portalassembly das Makro EXTERNAL_LIB, aber in der Hauptanwendung - Nr <br><blockquote><h4>  "Nicht-lyrischer Exkurs" </h4><br>  Tats√§chlich habe ich beim Codieren, um die L√∂sung schnell zu √ºberpr√ºfen, eine Fehleinsch√§tzung vorgenommen, die mich wahrscheinlich eine bestimmte Anzahl von Nervenzellen gekostet hat: F√ºr den Anfang habe ich nur die Typensubstitution f√ºr Dicitionary fest codiert.  Infolgedessen stellte sich nach der Deserialisierung heraus, dass es sich um ein leeres W√∂rterbuch handelte, das ebenfalls "abst√ºrzte", wenn versucht wurde, einige Operationen damit auszuf√ºhren.  Ich begann bereits zu glauben, dass man <i>BinaryFormatter nicht t√§uschen k√∂nnte</i> , und begann verzweifelte Experimente mit dem Versuch, den Erben des W√∂rterbuchs zu schreiben.  Gl√ºcklicherweise h√∂rte ich fast rechtzeitig auf und schrieb wieder einen universellen Substitutionsmechanismus. Als ich ihn implementierte, stellte ich fest, dass es nicht ausreicht, seinen Typ neu zu definieren, um seinen Typ neu zu definieren: Sie m√ºssen sich immer noch um die Typen f√ºr KeyValuePair &lt;TKey, TValue&gt;, Comparer k√ºmmern, die ebenfalls angefordert werden Bindemittel <br><br><br>  Dies sind die Abenteuer der bin√§ren Serialisierung.  F√ºr das Feedback w√§re ich dankbar. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430646/">https://habr.com/ru/post/de430646/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430632/index.html">Service in der Wirtschaft: Wie ausl√§ndische Einzelh√§ndler schl√ºsselfertige Gesch√§fte in Russland er√∂ffnen</a></li>
<li><a href="../de430634/index.html">Erstellen eines Softwaremoduls f√ºr den Programmierer XELTEK SuperPro 6100</a></li>
<li><a href="../de430636/index.html">Kleinhirn und Basalkerne anstelle der Kristallkugel: Wie das Gehirn die Zukunft vorhersagt</a></li>
<li><a href="../de430640/index.html">Rotes Meer: Warum die Aktien von Apple und anderen Technologieunternehmen fallen</a></li>
<li><a href="../de430642/index.html">Regie "Photonik" bei den Olympischen Spielen "Ich bin ein Profi" oder wie man sich ohne Pr√ºfungen in eine Magistratur einschreibt</a></li>
<li><a href="../de430648/index.html">Geschichte von Pac-Man</a></li>
<li><a href="../de430650/index.html">Sex ist ein Verk√§ufer klassischer Arcade-Spiele. Und wer ist der K√§ufer?</a></li>
<li><a href="../de430654/index.html">devleads meetup: Wir stellen ein effektives Team zusammen, optimieren die Entwicklung und diskutieren aktuelle Themen</a></li>
<li><a href="../de430656/index.html">Zertifiziertes SAFe¬Æ-Programm</a></li>
<li><a href="../de430658/index.html">Wie es begann - Die Geburt von Videospielen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>