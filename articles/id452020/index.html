<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¾â€ğŸŒ¾ ğŸ‘©â€ğŸ‘¦ ğŸ”° Prioritas HTTP / 2 Terbaik untuk Percepatan Web ğŸ‘ŒğŸ¼ ğŸ§“ ğŸ±</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="HTTP / 2 berjanji untuk mempercepat web secara signifikan, dan Cloudflare sejak dulu menggunakan akses HTTP / 2 untuk semua klien. Tetapi satu fitur H...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Prioritas HTTP / 2 Terbaik untuk Percepatan Web</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452020/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57d/5cf/dbe/57d5cfdbe917c7b464a249fb187b3ffd.png"></div><br>  HTTP / 2 berjanji untuk mempercepat web secara signifikan, dan Cloudflare sejak dulu menggunakan akses HTTP / 2 untuk semua klien.  Tetapi satu fitur HTTP / 2, prioritisasi, tidak memenuhi harapan.  Bukan karena secara fundamental rusak, tetapi karena implementasi di browser. <br><br>  Hari ini, Cloudflare menyarankan untuk mengubah prioritas HTTP / 2, yang memberi server kami kendali atas keputusan penentuan prioritas yang benar-benar mempercepat Internet. <br><br>  Secara historis, itu adalah browser yang mengontrol bagaimana dan kapan mengunduh konten web.  Hari ini, untuk semua paket berbayar, kami membuat perubahan radikal pada model ini.  Mereka mentransfer kontrol langsung ke pemilik situs.  Pada tab "Kecepatan" di dasbor Cloudflare, klien dapat mengaktifkan "Prioritas HTTP / 2 Lanjut": itu menimpa pengaturan browser default ke skema penjadwalan yang ditingkatkan, yang secara signifikan mempercepat akses bagi pengunjung (dalam beberapa kasus, kami melihat peningkatan 50%).  Dengan pekerja Cloudflare, pemilik situs dapat melangkah lebih jauh dan sepenuhnya menyesuaikan pengaturan untuk kebutuhan spesifik mereka. <br><a name="habracut"></a><br><h1>  Situasi saat ini </h1><br>  Halaman web terdiri dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://discuss.">lusinan (terkadang ratusan)</a> sumber daya individual yang diunduh dan dikumpulkan oleh peramban ke dalam konten akhir yang ditampilkan.  Ini termasuk konten yang terlihat dengan mana pengguna berinteraksi (HTML, CSS, gambar), serta logika aplikasi (JavaScript) untuk situs itu sendiri, iklan, analytics dan beacon pelacakan pemasaran.  Dari sudut pandang pengguna, urutan di mana sumber daya ini dimuat sangat penting: ini mempengaruhi waktu ketika ia melihat konten dan dapat berinteraksi dengan halaman. <br><br>  Peramban sebenarnya adalah mesin pengolah HTML yang melewati dokumen HTML dan mengikuti instruksi secara berurutan: dari awal hingga akhir HTML, membangun halaman saat bergerak.  Link style sheet (CSS) memberi tahu browser cara mendesain konten halaman, dan browser akan menunda tampilan konten sampai memuat stylesheet.  Skrip pada halaman mungkin memiliki perilaku berbeda.  Jika skrip ditandai sebagai â€œasinkronâ€ atau â€œtertundaâ€, peramban dapat melanjutkan memproses dokumen dan menjalankan skrip saat skrip tersedia.  Jika skrip tidak ditandai sebagai tidak sinkron atau ditangguhkan, browser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HARUS</a> berhenti memproses dokumen hingga skrip dimuat dan dieksekusi.  Script tersebut disebut "blocking" karena mereka memblokir browser untuk melanjutkan proses dokumen. <br><br>  Dokumen HTML dibagi menjadi dua bagian.  Judul dokumen &lt;head&gt; ada di awal dan berisi stylesheet, skrip, dan instruksi browser lainnya yang diperlukan untuk menampilkan konten.  Setelah judul adalah badan dokumen &lt;body&gt;, itu berisi konten aktual yang ditampilkan di jendela browser (meskipun skrip dan style sheet juga bisa ada di badan).  Sampai browser mencapai badan dokumen, pengguna tidak memiliki apa-apa untuk ditampilkan, dan halaman tetap kosong.  Karena itu, penting untuk memproses tajuk secepat mungkin.  Jika Anda tertarik dengan detailnya, situs web <i>HTML5 Rocks</i> memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tutorial yang bagus</a> tentang cara kerja browser. <br><br>  Peramban biasanya bertanggung jawab atas urutan berbagai sumber daya yang diperlukan untuk membangun halaman dan memproses lebih lanjut dokumen yang dimuat.  Dalam HTTP / 1.x, ada batasan pada berapa banyak objek browser dapat meminta dari server mana saja pada suatu waktu (biasanya 6 koneksi dan hanya satu sumber daya pada satu waktu per koneksi), sehingga urutan permintaan dikontrol secara ketat oleh browser.  Dalam HTTP / 2, situasinya sama sekali berbeda.  Peramban dapat meminta semua sumber daya sekaligus (paling tidak segera setelah mengetahui tentang mereka), dan memberikan instruksi terperinci kepada server tentang cara mengirim sumber daya ini. <br><br><h1>  Urutan pemuatan sumber daya yang optimal </h1><br>  Untuk sebagian besar bagian, ada urutan optimal dalam siklus pemuatan halaman yang memaksimalkan ketersediaan halaman untuk pengguna (dan perbedaan antara urutan pemuatan yang optimal dan tidak optimal dapat mencapai 50% atau lebih). <br><br>  Seperti dijelaskan di atas, sebelum browser dapat menampilkan konten apa pun, itu diblokir oleh CSS dan JavaScript di bagian <code>&lt;head&gt;</code> .  Pada tahap ini, lebih menguntungkan menggunakan 100% saluran untuk memuat sumber daya pemblokiran, daripada memuatnya secara berurutan, sebagaimana ditulis dalam kode HTML.  Ini memungkinkan peramban untuk menganalisis dan menjalankan setiap elemen sambil memuat sumber daya pemblokiran berikutnya, yang menciptakan saluran pipa yang optimal. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/db9/e18/fbe/db9e18fbe00d27755a152a8deabbcaa4.png"><br><br>  Waktu pemuatan skrip untuk pemuatan paralel atau berurutan tidak berbeda, tetapi untuk pemuatan sekuensial skrip pertama dapat diproses dan dieksekusi selama pemuatan kedua. <br><br>  Setelah memuat sumber daya pemblokiran, situasinya menjadi sedikit lebih menarik.  Di sini, pemuatan optimal mungkin bergantung pada situs tertentu atau bahkan prioritas bisnis (pemilihan konten atau iklan yang dibuat pengguna, atau analitik, dll.).  Masalah terpisah dengan font, karena browser mendeteksi font yang diinginkan setelah menerapkan stylesheet ke konten yang ditampilkan.  Oleh karena itu, pada saat browser mengetahui tentang font, perlu untuk menampilkan teks yang sudah siap untuk ditampilkan di layar.  Setiap keterlambatan pemuatan font tidak menghasilkan teks pada layar (atau teks ditampilkan dalam font yang salah). <br><br>  Sebagai aturan, beberapa pertukaran harus dipertimbangkan: <br><br><ul><li>  Fon dan gambar khusus di bagian halaman yang terlihat (viewport) harus dimuat secepat mungkin.  Mereka secara langsung mempengaruhi pengalaman visual pengguna saat memuat halaman. <br></li><li>  JavaScript non-pemblokiran harus dimuat secara berurutan sehubungan dengan sumber daya JavaScript lainnya sehingga masing-masingnya dapat disalin.  JavaScript dapat menyertakan logika aplikasi khusus, serta melacak suar untuk analitik dan pemasaran, dan penundaannya dapat menyebabkan penurunan indikator yang dilacak oleh bisnis. <br></li><li>  Gambar dapat diunggah secara paralel.  Beberapa byte pertama dari file gambar berisi ukurannya, yang mungkin diperlukan untuk tata letak browser, dan pemuatan paralel gambar progresif dapat memberikan kelengkapan visual setelah mentransfer sekitar 50% dari total volume. </li></ul><br>  Dengan adanya trade-off, dalam banyak kasus, strategi ini bekerja dengan baik: <br><br><ul><li>  Fon khusus diunduh secara berurutan dan berbagi bandwidth yang tersedia dengan gambar dalam cakupan. <br></li><li>  Gambar yang terlihat dimuat secara paralel, berbagi di antara mereka bagian dari bandwidth yang dialokasikan untuk mereka. <br></li><li>  Ketika tidak ada lagi font atau gambar yang terlihat: <br><ul><li>  Skrip non-pemblokiran dimuat secara berurutan dan berbagi bandwidth yang tersedia dengan gambar yang tidak terlihat (yang berada di luar ruang lingkup). <br></li><li>  Gambar yang tidak terlihat dimuat secara paralel, berbagi di antara mereka bagian dari bandwidth yang dialokasikan untuk mereka. </li></ul></li></ul><br>  Dengan demikian, konten yang terlihat oleh pengguna dimuat secepat mungkin, logika aplikasi tertunda seminimal mungkin, dan gambar yang tidak terlihat dimuat sedemikian rupa untuk menyelesaikan tata letak secepat mungkin. <br><br><h1>  Contoh </h1><br>  Untuk menggambarkan, gunakan halaman kategori produk yang disederhanakan dari situs e-commerce yang khas: <br><br><ul><li>  <b>Biru</b> - File HTML halaman itu sendiri. <br></li><li>  <b>Hijau</b> - Satu lembar gaya eksternal (file CSS). <br></li><li>  <b>Oranye</b> - Empat skrip eksternal (JavaScript).  Dua skrip pemblokiran di bagian atas halaman dan dua skrip asinkron.  Skrip pemblokiran ditampilkan dalam warna oranye yang lebih gelap. <br></li><li>  <b>Merah</b> adalah satu font web khusus. <br></li><li>  <b>Violet</b> - 13 gambar.  Logo halaman dan empat gambar produk ditampilkan di jendela tampilan, 8 gambar produk lainnya perlu digulir.  Lima gambar yang terlihat ditandai dengan warna ungu yang lebih gelap. </li></ul><br>  Untuk kesederhanaan, anggap semua sumber daya memiliki ukuran yang sama dan masing-masing memuat dalam 1 detik.  Mengunduh semua sumber daya membutuhkan total 20 detik, tetapi urutan dan metode pemuatannya sangat penting. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fbd/07b/58a/fbd07b58a4c8aeff2a758ad1946d8523.png"><br><br>  Inilah yang akan terlihat seperti pemuatan sumber daya optimal di browser: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b2/6a8/2cd/8b26a82cdb5c546e9005200e5528b988.gif"><br><br><ul><li>  Halaman ini kosong selama 4 detik pertama saat memuat HTML, CSS dan skrip pemblokiran: semuanya menggunakan koneksi 100%. <br></li><li>  Pada tanda 4 detik, latar belakang dan struktur halaman ditampilkan tanpa teks atau gambar. <br></li><li>  Setelah satu detik, sekitar 5 detik, teks halaman ditampilkan. <br></li><li>  Dalam interval 5-10 detik, gambar diunduh, buram pada awalnya, tetapi sangat cepat menjadi jelas.  Sekitar 7 detik, hasilnya hampir tidak bisa dibedakan dari versi final. <br></li><li>  Sekitar 10 detik, pemuatan semua konten visual di bagian yang terlihat dari halaman selesai. <br></li><li>  Selama dua detik berikutnya, JavaScript asinkron dimuat dan dieksekusi, mengeksekusi logika yang tidak kritis (analitik, tag pemasaran, dll.). <br></li><li>  Selama 8 detik terakhir, gambar yang tersisa dimuat jika pengguna menggulir halaman. </li></ul><br><h1>  Prioritas browser saat ini </h1><br>  Semua mesin browser saat ini menerapkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://calendar.perfplanet.com/2018/">berbagai strategi</a> penentuan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://calendar.perfplanet.com/2018/">prioritas</a> , tidak ada yang optimal. <br><br>  <b>Microsoft Edge dan Internet Explorer</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://calendar.perfplanet.com/2018/">tidak mendukung penentuan prioritas</a> , sehingga mereka bekerja dengan pengaturan HTTP / 2 default, yang memuat semuanya secara paralel, mendistribusikan bandwidth secara merata di antara semua sumber daya.  Microsoft Edge di versi mendatang akan beralih menggunakan mesin Chromium, yang dapat memperbaiki situasi.  Tetapi untuk saat ini, dalam contoh kami, browser sebagian besar waktu terjebak di header halaman, karena gambar memperlambat transmisi skrip pemblokiran dan style sheet. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e9c/844/a65/e9c844a65472a56d92cb37cd27f2f035.png"><br><br>  Secara visual, ini mengarah pada pengalaman yang agak menyakitkan: pengguna melihat layar kosong selama 19 detik, dan kemudian ada penundaan 1 detik untuk menampilkan teks.  Saat melihat animasi di bawah ini, bersabarlah, karena selama 19 detik sepertinya tidak ada yang terjadi di layar kosong (walaupun begitu): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6c9/fae/539/6c9fae539ae1d3c99570cf53af415be4.gif"><br><br>  <b>Safari</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://calendar.perfplanet.com/2018/">memuat semua sumber daya secara paralel</a> , berbagi bandwidth berdasarkan kepentingannya, menurut Safari (memblokir sumber daya seperti skrip dan stylesheet lebih penting daripada gambar).  Gambar dimuat secara paralel, tetapi juga secara bersamaan dengan memblokir konten. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c75/a7d/f05/c75a7df05716f5706aa4b037774733d2.png"><br><br>  Meskipun Safari mirip dengan Edge dalam arti bahwa semuanya dimuat secara bersamaan, mengalokasikan lebih banyak bandwidth untuk memblokir sumber daya memungkinkan Anda untuk menampilkan konten lebih awal: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f0c/840/5a1/f0c8405a1b6ddc40645ab7985e28a5eb.gif"><br><br><ul><li>  Setelah sekitar 8 detik, pemuatan stylesheet dan skrip selesai, sehingga Anda dapat mulai merender halaman.  Karena gambar dimuat secara paralel, mereka juga dapat ditampilkan sebagian (buram untuk gambar progresif).  Ini masih dua kali lebih lambat dari skenario optimal, tetapi jauh lebih baik daripada di Edge. <br></li><li>  Setelah sekitar 11 detik, font dimuat.  Anda dapat menampilkan teks.  Pada titik ini, lebih banyak data dimuat untuk gambar, dan mereka menjadi sedikit lebih tajam.  Ini sebanding dengan situasi di sekitar tanda 7 detik untuk skenario pemuatan yang optimal. <br></li><li>  Selama 9 detik yang tersisa, gambar menjadi lebih tajam karena lebih banyak data diunduh hingga, akhirnya, proses selesai dalam 20 detik. </li></ul><br>  <b>Firefox</b> membuat pohon dependensi yang mengelompokkan sumber daya, dan kemudian merencanakan grup untuk memuat satu demi satu atau berbagi bandwidth antar grup secara bersamaan.  Dalam grup ini, sumber daya berbagi bandwidth dan memuat secara bersamaan.  Gambar direncanakan untuk dimuat setelah stylesheet yang memblokir rendering dan dimuat secara paralel, tetapi skrip dan stylesheet yang memblokir rendering juga dimuat secara paralel dan tidak mendapat manfaat dari pipelining. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/870/e6d/83c/870e6d83c673b9c706dac49c78d3848d.png"><br><br>  Dalam contoh kami, ini terjadi sedikit lebih cepat daripada di Safari, karena gambar menunggu lembar gaya untuk dimuat: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bd2/806/b55/bd2806b55e830bd4c2a7e08bb1b18ce4.gif"><br><br><ul><li>  Sekitar 6 detik, konten halaman asli ditampilkan dengan versi gambar latar belakang dan buram (dibandingkan dengan 8 detik untuk Safari dan 4 detik dalam kasus terbaik). <br></li><li>  Pada 8 detik, font dimuat, dan Anda dapat menampilkan teks bersama dengan gambar produk yang sedikit lebih tajam (dibandingkan dengan Safari 11 detik dan 7 detik dalam kasus terbaik). <br></li><li>  Selama 12 detik tersisa, gambar menjadi lebih tajam saat konten yang tersisa dimuat. </li></ul><br>  <b>Chrome</b> (dan semua browser berbasis Chromium) memprioritaskan inventaris.  Ini bekerja sangat baik untuk memblokir sumber daya yang dimuat secara optimal, tetapi tidak begitu baik untuk gambar.  Setiap gambar dimuat hingga 100% sebelum memulai yang berikutnya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e22/14d/4e0/e2214d4e04fab810f0a4398fe02434c1.png"><br><br>  Dalam praktiknya, ini adalah skenario pengunduhan yang hampir optimal, dengan satu-satunya perbedaan adalah gambar diunduh satu per satu, dan tidak secara paralel: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/91e/76c/d1d/91e76cd1d814aef138b35345eda46d82.gif"><br><br><ul><li>  Hingga 5 detik, memuat Chrome identik dengan skenario optimal, menampilkan latar belakang pada detik ke-4 dan konten teks pada ke-5. <br></li><li>  Selama 5 detik berikutnya, gambar area visibilitas dimuat satu per satu hingga proses selesai pada sekitar 10 detik (dibandingkan dengan skenario optimal, ketika mereka ditampilkan dalam bentuk yang agak kabur di sekitar 7 detik dan menjadi lebih tajam selama tiga detik yang tersisa). <br></li><li>  Setelah bagian visual halaman selesai dalam 10 detik (identik dengan skenario optimal), sisa 10 detik dihabiskan untuk menjalankan skrip asinkron dan memuat gambar tersembunyi (serta dalam skenario optimal). </li></ul><br><h1>  Perbandingan visual </h1><br>  Perbedaan visualnya sangat berbeda, walaupun secara teknis memuat semua konten membutuhkan waktu yang sama: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/62e/2a1/d5f/62e2a1d5f10b801af61992517d7f5a5a.gif"><br><br><h1>  Prioritas Sisi Server </h1><br>  Prioritas HTTP / 2 diminta oleh klien (browser), dan server harus memutuskan apa yang harus dilakukan berdasarkan permintaan.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://github.com/andydavies/">Sejumlah besar server tidak mendukung fungsi ini sama sekali</a> , dan sisanya memenuhi permintaan klien.  Pilihan lain adalah untuk menentukan prioritas sisi server terbaik berdasarkan permintaan klien. <br><br>  Menurut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://http2.github.io/">spesifikasi</a> , HTTP / 2 prioritization adalah pohon ketergantungan yang membutuhkan pengetahuan penuh dari semua permintaan saat ini agar dapat memprioritaskan sumber daya relatif satu sama lain.  Ini memungkinkan Anda untuk menerapkan strategi yang sangat rumit, tetapi sulit untuk menerapkannya dengan baik di sisi browser atau server (sebagaimana dibuktikan oleh berbagai strategi browser dan berbagai tingkat dukungan server).  Untuk menyederhanakan pengelolaan penentuan prioritas, kami telah mengembangkan skema yang lebih sederhana yang masih memiliki semua fleksibilitas yang diperlukan untuk perencanaan yang optimal. <br><br>  Skema prioritas Cloudflare terdiri dari 64 "level" prioritas, dan dalam setiap level ada kelompok sumber daya yang menentukan cara membagi koneksi di antara mereka sendiri: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ba5/7e5/efa/ba57e5efa56119a58bbd39596da3f9ce.png"><br><br>  Pertama, semua sumber daya diunduh pada tingkat prioritas yang lebih tinggi, kemudian transisi ke tingkat yang lebih rendah terjadi. <br><br>  Dalam tingkat prioritas tertentu, ada tiga kelompok konkurensi yang berbeda: <br><br><ul><li>  <b>0</b> : semua sumber daya dalam grup â€œ0â€ dikirim secara berurutan sesuai urutan yang diminta menggunakan bandwidth 100%.  Hanya setelah memuat semua sumber daya dari grup "0" adalah kelompok lain pada tingkat yang sama dipertimbangkan. <br></li><li>  <b>1</b> : semua sumber daya dalam grup konkurensi "1" dikirim berurutan sesuai urutan permintaannya.  Bandwidth yang tersedia didistribusikan secara merata antara kelompok paralelisme "1" dan kelompok paralelisme "n". <br></li><li>  <b>n</b> : sumber daya dalam grup konkurensi "n" ditransmisikan secara paralel, berbagi bandwidth yang tersedia. </li></ul><br>  Dalam praktiknya, grup paralelisme "0" berguna untuk konten kritis yang perlu diproses secara berurutan (skrip, CSS, dll.).  Grup "1" berguna untuk konten yang kurang penting yang dapat berbagi bandwidth dengan sumber daya lain, tetapi di mana sumber daya itu sendiri masih mendapat manfaat dari pemrosesan sekuensial (skrip asinkron, gambar non-progresif, dll.).  Kelompok konkurensi "n" berguna untuk sumber daya yang mendapat manfaat dari pemrosesan paralel (gambar progresif, video, audio, dll.). <br><br><h1>  Cloudflare prioritisasi default </h1><br>  Dengan opsi prioritisasi tingkat lanjut, urutan pemuatan sumber daya yang "optimal", seperti dijelaskan di atas, diterapkan.  Prioritas spesifik yang diterapkan adalah sebagai berikut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b89/e96/e4f/b89e96e4f4534f5df00d732e97b5db62.png"><br><br>  Skema ini memungkinkan Anda untuk secara berurutan mengirim sumber daya yang memblokir render, kemudian mengirim gambar yang terlihat secara paralel, dan kemudian seluruh konten halaman dengan beberapa tingkat pembagian bandwidth untuk menyeimbangkan pemuatan aplikasi dan konten.  <i>Peringatan * Jika Detectable</i> adalah bahwa tidak semua browser membedakan antara berbagai jenis stylesheet dan skrip, tetapi tetap saja akan jauh lebih cepat dalam semua kasus.  Akselerasi 50%, terutama untuk pengunjung Edge dan Safari, tidak akan menjadi sesuatu yang luar biasa: <br><br> <a href=""><img src="https://habrastorage.org/webt/u_/1n/px/u_1npxrzhg0svmgdyzelnamxj84.png"></a> <br><br><h1>  Menetapkan Prioritas dengan Pekerja </h1><br>  Pekerjaan default yang lebih cepat itu hebat, tetapi ini menjadi sangat menarik berkat kemampuan untuk mengonfigurasi prioritas dengan dukungan Cloudflare Pekerja, sehingga situs dapat menimpa prioritas default untuk sumber daya atau menerapkan skema prioritas mereka sendiri. <br><br>  Jika pekerja menambahkan header <code>cf-priority</code> ke respons, maka server tepi Cloudflare akan menerapkan prioritas dan konkurensi yang ditentukan.  Format header adalah &lt;priority&gt; / &lt;concurrency&gt;, oleh karena itu header <code>response.headers.set('cf-priority', â€œ30/0â€);</code>  akan menetapkan prioritas 30 dan paralelisme 0 untuk jawaban ini. Demikian pula, "30/1" akan menetapkan paralelisme "1", dan "30 / n" akan menetapkan paralelisme ke n. <br><br>  Dengan fleksibilitas seperti itu, situs dapat menetapkan prioritas sumber daya yang sewenang-wenang untuk kebutuhannya.  Misalnya, untuk meningkatkan prioritas beberapa skrip asinkron penting atau gambar utama: mereka diunduh bahkan sebelum browser menentukan bahwa mereka berada dalam jangkauan. <br><br>  Untuk menginformasikan tentang keputusan penentuan prioritas, runtime pekerja juga menunjukkan informasi yang diminta oleh browser tentang penentuan prioritas dalam objek permintaan, yang diteruskan ke penerima acara pekerja (request.cf.requestPriority).  Prioritas masuk adalah daftar atribut yang dipisahkan oleh tanda titik koma.  Itu terlihat seperti ini: <code>weight=192;exclusive=0;group=3;group-weight=127</code> . <br><br><ul><li>  <b>weight</b> : weight untuk memprioritaskan HTTP / 2. <br></li><li>  <b>eksklusif</b> : bendera HTTP / 2 eksklusif (1 untuk browser berbasis Chromium, 0 untuk yang lain). <br></li><li>  <b>grup</b> : pengidentifikasi aliran HTTP / 2 untuk grup permintaan (bukan nol untuk Firefox). <br></li><li>  <b>group-weight</b> : HTTP / 2 weight untuk kelompok permintaan (bukan nol untuk Firefox). </li></ul><br><h1>  Ini baru permulaan. </h1><br>  Kemampuan untuk mengkonfigurasi dan mengendalikan prioritas jawaban adalah blok bangunan utama untuk pekerjaan masa depan yang hebat.  Kami bermaksud untuk memperkenalkan optimasi lanjutan kami sendiri di atas ini, tetapi dengan dukungan pekerja, semua situs dan peneliti dapat bereksperimen dengan berbagai strategi prioritas.  Melalui Apps Marketplace, perusahaan juga dapat membuat layanan optimisasi baru di atas platform kerja dan membuatnya tersedia untuk digunakan oleh situs lain. <br><br>  Jika Anda menggunakan paket Pro atau lebih tinggi, buka tab "Kecepatan" di dasbor Cloudflare dan aktifkan "prioritas HTTP / 2 lanjutan" untuk mempercepat situs Anda. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/386/d53/276/386d532767b6396ee628a7e0eb837282.png"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id452020/">https://habr.com/ru/post/id452020/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id452004/index.html">Menemukan lokasi jatuhnya perangkat "Bereshit" ke bulan</a></li>
<li><a href="../id452006/index.html">Epic Metaverse: Mengapa Penulis Fortnite Harus Mendapatkannya</a></li>
<li><a href="../id452008/index.html">Pendekatan teknik dan daftar periksa: bagaimana tidak menjadi gila dalam kekacauan tugas</a></li>
<li><a href="../id452010/index.html">Osmo Action: Kamera aksi pertama DJI</a></li>
<li><a href="../id452016/index.html">12 tahun di awan</a></li>
<li><a href="../id452022/index.html">Google memberi tahu pengguna tentang kerentanan dengan kunci Keamanan Titan mereka</a></li>
<li><a href="../id452026/index.html">20 tahun yang lalu, Microsoft selamanya mengubah cara kita menggunakan mouse</a></li>
<li><a href="../id452028/index.html">Sinar cahaya di kerajaan gelap: bagaimana teknologi mengembalikan penglihatan yang hilang</a></li>
<li><a href="../id452030/index.html">Sejarah Internet: Menemukan Interaktivitas</a></li>
<li><a href="../id452034/index.html">Kontrol diri waktu untuk pendidikan diri dan waktu untuk membaca buku</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>