<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📂 🚶🏼 🈲 Immersion in Move - Facebooks Programmiersprache Libra Blockchain 👩🏻‍🎓 👰🏾 📺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Als nächstes werden wir die Hauptmerkmale der Move-Sprache und ihre Hauptunterschiede zu einer anderen, bereits beliebten Sprache für intelligente Ver...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Immersion in Move - Facebooks Programmiersprache Libra Blockchain</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459990/"> Als nächstes werden wir die Hauptmerkmale der Move-Sprache und ihre Hauptunterschiede zu einer anderen, bereits beliebten Sprache für intelligente Verträge - Solidity (auf der Ethereum-Plattform) - im Detail untersuchen.  Das Material basiert auf einer Studie eines verfügbaren 26-seitigen Online-Whitepapers. <br><br><h3>  Einführung </h3><br>  Move ist eine ausführbare Bytecode-Sprache, mit der Benutzertransaktionen und intelligente Verträge ausgeführt werden.  Beachten Sie zwei Punkte: <br><br><ol><li>  Während Move eine Bytecode-Sprache ist, die direkt auf der virtuellen Maschine von Move ausgeführt werden kann, ist Solidity (intelligente Vertragssprache in Ethereum) eine übergeordnete Sprache, die zuerst in Bytecode kompiliert wird, bevor sie in EVM (Ethereum Virtual Machine) ausgeführt wird ) </li><li>  Move kann nicht nur für die Implementierung intelligenter Verträge verwendet werden, sondern auch für Benutzertransaktionen (dazu später mehr), während Solidity eine Sprache nur für intelligente Verträge ist. </li></ol><a name="habracut"></a><br>  <i>Übersetzung durch das INDEX Protocol-Projektteam.</i>  <i>Wir haben zuvor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">viel Material übersetzt, das das Libra-Projekt beschreibt</a> . Jetzt ist es an der Zeit, die Move-Sprache etwas genauer zu betrachten.</i>  <i>Die Übersetzung wurde in Verbindung mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">coolsiu gemacht</a></i> <br><br>  Ein wichtiges Merkmal von Move ist die Möglichkeit, benutzerdefinierte Ressourcentypen mit linearer Logiksemantik zu definieren: Eine Ressource kann niemals kopiert oder implizit gelöscht, sondern nur verschoben werden.  Funktionell ähnelt dies den Funktionen der Rust-Sprache.  Werte in Rust können jeweils nur einem Namen zugewiesen werden.  Wenn Sie einem anderen Namen einen Wert zuweisen, kann er unter dem vorherigen Namen nicht mehr aufgerufen werden. <br><br><img src="https://habrastorage.org/webt/np/px/97/nppx97owkfkamua9ccpc1aovkrg.png"><br><br>  Das folgende Codefragment gibt beispielsweise einen Fehler aus: <i>Verwendung des verschobenen Werts 'x'.</i>  Dies liegt daran, dass es in Rust keine Speicherbereinigung gibt.  Wenn Variablen den Gültigkeitsbereich verlassen, wird auch der Speicher freigegeben, auf den sie sich beziehen.  Einfach ausgedrückt kann es nur einen „Eigentümer“ von Daten geben.  In diesem Beispiel ist <i>x</i> der ursprüngliche Eigentümer und <i>y</i> wird der neue Eigentümer.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lesen Sie hier mehr über dieses Verhalten</a> . <br><br><h3>  Darstellung digitaler Assets in offenen Systemen </h3><br>  Es gibt zwei Eigenschaften von physischen Vermögenswerten, die digital schwer darzustellen sind: <br><br><ul><li>  <b>Seltenheit</b> (Knappheit im Original - Knappheit).  Die Höhe der Vermögenswerte (Ausgabe) im System sollte kontrolliert werden.  Das Duplizieren vorhandener Assets muss verboten werden, und das Erstellen neuer Assets ist eine privilegierte Operation. </li><li>  <b>Zugangskontrolle</b> .  Der Systemteilnehmer muss in der Lage sein, Assets mit Zugriffssteuerungsrichtlinien zu schützen. </li></ul><br>  Diese beiden Merkmale, die für physische Assets natürlich sind, müssen für digitale Objekte implementiert werden, wenn wir sie als Assets betrachten möchten.  Zum Beispiel ein seltenes Metall - hat ein natürliches Defizit, und nur Sie haben Zugriff darauf (zum Beispiel in Ihren Händen) und können es verkaufen oder ausgeben. <br><br>  Um zu veranschaulichen, wie wir zu diesen beiden Eigenschaften gekommen sind, beginnen wir mit den folgenden Sätzen: <br><br><h4>  Satz 1: Die einfachste Regel ohne Knappheit und Zugangskontrolle </h4><br><img src="https://habrastorage.org/webt/it/ar/vy/itarvy-z1ns775gm4oxu2isimxe.png"><br><br><ul><li>  <i>G [K]: = n</i> bedeutet, dass die Nummer, auf die der Schlüssel <i>K</i> im globalen Zustand der Blockchain zugreift, mit dem neuen Wert <i>n</i> aktualisiert wird. </li><li>  <i>Transaktion "Alice, 100"</i> bedeutet, den Kontostand von Alice auf 100 zu setzen. </li></ul><br>  Die obige Lösung weist mehrere schwerwiegende Probleme auf: <br><br><ul><li>  Alice kann eine unbegrenzte Anzahl von Münzen erhalten, indem sie einfach die <i>Transaktion "Alice, 100" sendet.</i> </li><li>  Die Münzen, die Alice an Bob sendet, sind nutzlos, da Bob sich mit derselben Technik eine unbegrenzte Anzahl von Münzen senden könnte. </li></ul><br><h4>  Vorschlag Nr. 2: Wir berücksichtigen das Defizit </h4><br><img src="https://habrastorage.org/webt/_1/s4/08/_1s408pxxtmawws6dw_vddgzr-m.png"><br><br>  Jetzt überwachen wir die Situation so, dass die Anzahl der <i>Ka-</i> Münzen vor der Überweisungstransaktion mindestens <i>n</i> beträgt.  Obwohl dies das Mangelproblem löst, gibt es keine Informationen darüber, wer Alices Münzen senden kann (bisher kann dies jeder, die Hauptsache ist, nicht gegen die Regel der Mengenbeschränkungen zu verstoßen). <br><br><h4>  Proposition 3: Kombination von Defizit und Zugangskontrolle </h4><br><img src="https://habrastorage.org/webt/yi/so/hh/yisohh7xhtgmzt8aparwsxdccfc.png"><br><br>  Wir lösen dieses Problem mit dem digitalen Signaturmechanismus <i>verify_sig,</i> bevor wir den <i>Kontostand</i> überprüfen. <i>Dies</i> bedeutet, dass Alice ihren privaten Schlüssel verwendet, um die Transaktion zu signieren und zu bestätigen, dass sie ihre Münzen besitzt. <br><br><h3>  Blockchain-Programmiersprachen </h3><br>  Bestehende Blockchain-Sprachen haben die folgenden Probleme (alle wurden in Move gelöst (Hinweis: <i>Leider spricht der Autor des Artikels in seinen Vergleichen nur Ethereum an, daher sollten Sie sie nur in diesem Zusammenhang verwenden. Die meisten</i> der folgenden Probleme werden <i>beispielsweise auch in EOS gelöst</i> )): <br><br>  <b>Indirekte Darstellung von Vermögenswerten</b> .  Ein Asset wird mit einer Ganzzahl codiert, ein ganzzahliger Wert ist jedoch nicht mit einem Asset identisch.  Tatsächlich gibt es keinen Typ oder Wert, der Bitcoin / Ether / &lt;Any Coin&gt; darstellt!  Dies macht das Schreiben von Programmen, die Assets verwenden, schwierig und fehleranfällig.  Muster wie das Übertragen von Assets zu / von Prozeduren oder das Speichern von Assets in Strukturen erfordern eine spezielle Sprachunterstützung. <br><br>  <b>Das Defizit ist nicht erweiterbar</b> .  Die Sprache ist nur ein knappes Gut.  Darüber hinaus sind Abhilfemaßnahmen gegen Defizite direkt in die Semantik der Sprache selbst eingebunden.  Wenn ein Entwickler ein Benutzer-Asset erstellen möchte, muss er alle Aspekte der Ressource selbst sorgfältig überwachen.  Dies sind nur die Probleme von intelligenten Verträgen von Ethereum. <br><br>  Benutzer stellen ihre Assets, ERC-20-Standardtoken, aus, wobei sie Ganzzahlen verwenden, um sowohl die Kosten als auch die Gesamtausgabe zu bestimmen.  Immer wenn neue Token erstellt werden, muss der Smart Contract Code die Einhaltung der Emissionsregeln unabhängig überprüfen.  Darüber hinaus führt die indirekte Darstellung von Vermögenswerten in einigen Fällen zu schwerwiegenden Fehlern - Doppelarbeit, doppelte Ausgaben oder sogar ein vollständiger Verlust von Vermögenswerten. <br><br>  <b>Fehlende flexible Zugangskontrolle</b> .  Die einzige derzeit verwendete Zugriffssteuerungsrichtlinie ist ein Signaturschema mit asymmetrischer Kryptografie.  Wie der Defizitschutz sind auch die Richtlinien zur Zugriffskontrolle tief in die Semantik der Sprache eingebettet.  Das Erweitern der Sprache, damit Programmierer ihre eigenen Zugriffssteuerungsrichtlinien definieren können, ist jedoch häufig keine sehr triviale Aufgabe. <br><br>  Dies gilt auch für Ethereum, wo intelligente Verträge keine native Kryptografieunterstützung für die Zugriffskontrolle bieten.  Entwickler müssen die Zugriffssteuerung manuell vorschreiben, z. B. mithilfe des Modifikators onlyOwner. <br><br>  Obwohl ich ein großer Fan von Ethereum bin, glaube ich, dass Asset-Eigenschaften aus Sicherheitsgründen von der Sprache nativ unterstützt werden sollten.  Insbesondere die Übertragung von Ether auf einen intelligenten Vertrag beinhaltet ein dynamisches Dispatching, was zur Entstehung einer neuen Klasse von Fehlern geführt hat, die als Schwachstellen beim Wiedereintritt bekannt sind.  Dynamisches Dispatching bedeutet hier, dass die Logik der Codeausführung zur Laufzeit (dynamisch) und nicht zur Kompilierungszeit (statisch) festgelegt wird. <br><br>  Wenn also in Solidity Vertrag A die Funktion von Vertrag B aufruft, kann Vertrag B Code ausführen, der nicht vom Entwickler von Vertrag A bereitgestellt wurde, was zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sicherheitslücken</a> beim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wiedereintritt</a> führen kann (Vertrag A führt versehentlich die Funktion von Vertrag B aus, um Geld vor dem tatsächlichen Abzug abzuheben Kontensalden). <br><br><h3>  Grundlagen des Sprachdesigns verschieben </h3><br><h4>  Ressourcen erster Ordnung </h4><br>  Auf einer höheren Ebene ist die Interaktion zwischen Modulen / Ressourcen / Prozeduren in der Move-Sprache den Beziehungen zwischen Klassen / Objekten und Methoden in OOP-Sprachen sehr ähnlich. <br>  Module in Move ähneln intelligenten Verträgen in anderen Blockchains.  Das Modul deklariert Ressourcentypen und -prozeduren, die die Regeln für das Erstellen, Zerstören und Aktualisieren deklarierter Ressourcen festlegen.  Aber all dies sind nur Konventionen („ <i>Jargon</i> “) in Move.  Wenig später werden wir diesen Punkt veranschaulichen. <br><br><h4>  Flexibilität </h4><br>  Move erhöht die Flexibilität der Waage durch Skripterstellung.  Jede Transaktion in Libra enthält ein Skript, das eigentlich das Haupttransaktionsverfahren ist.  Das Skript kann entweder eine bestimmte Aktion ausführen, z. B. Zahlungen gemäß der angegebenen Empfängerliste, oder andere Ressourcen wiederverwenden, indem beispielsweise eine Prozedur aufgerufen wird, in der die allgemeine Logik angegeben ist.  Aus diesem Grund bieten Move-Transaktionsskripte mehr Flexibilität.  Das Skript kann sowohl einmaliges als auch sich wiederholendes Verhalten verwenden, während Ethereum nur sich wiederholende Skripte ausführen kann (Aufrufen einer Smart Contract-Methode durch Aufrufen einer Methode).  Der Grund, warum es als "mehrfach" bezeichnet wird, ist, dass die Funktionen eines intelligenten Vertrags mehrfach ausgeführt werden können.  (Hinweis: <i>Der Moment ist hier sehr heikel. Einerseits sind Transaktionsskripte in Form von Pseudo-Bytecode auch in Bitcoin. Andererseits erweitert Move diese Sprache meines Wissens tatsächlich auf das Niveau einer vollwertigen intelligenten Vertragssprache.</i> ) <br><br><h4>  Sicherheit </h4><br>  Das ausführbare Format von Move ist Bytecode, der einerseits eine Sprache mit einer höheren Ebene als Assembler, aber einer niedrigeren Ebene als der Quellcode ist.  Der Bytecode wird in der Kette mithilfe des Bytecode-Verifizierers auf Verfügbarkeit von Ressourcen, Typen und Speichersicherheit überprüft und dann vom Interpreter ausgeführt.  Dieser Ansatz ermöglicht es Move, Sicherheit für den Quellcode bereitzustellen, jedoch ohne den Kompilierungsprozess und die Notwendigkeit, dem System einen Compiler hinzuzufügen.  Move zu einer Bytecode-Sprache zu machen, ist eine wirklich gute Lösung.  Es ist nicht erforderlich, es aus der Quelle zu kompilieren, wie dies bei Solidity der Fall ist, und Sie müssen sich keine Gedanken über mögliche Abstürze oder Angriffe auf die Compiler-Infrastruktur machen. <br><br><h4>  Überprüfbarkeit </h4><br>  Wir sind bestrebt, so einfache Überprüfungen wie möglich durchzuführen, da dies alles in der Kette erfolgt (Hinweis: <i>Online, bei jeder Transaktion führt jede Verzögerung zu einer Verlangsamung des gesamten Netzwerks</i> ). Das Sprachdesign ist jedoch zunächst einsatzbereit und Off-Chain-Mittel zur statischen Überprüfung.  Obwohl dies vorzuziehen ist, wurde die Entwicklung von Verifizierungswerkzeugen (als separates Toolkit) bisher auf die Zukunft verschoben, und jetzt wird nur die dynamische Verifizierung in der Kette unterstützt. <br><br><h4>  Modularität </h4><br>  Verschiebemodule bieten Datenabstraktion und lokalisieren kritische Vorgänge an Ressourcen.  Die vom Modul bereitgestellte Kapselung in Kombination mit dem vom Move-Typsystem bereitgestellten Schutz stellt sicher, dass die für die Modultypen festgelegten Eigenschaften nicht durch Code außerhalb des Moduls verletzt werden können.  Dies ist ein durchdachtes Design der Abstraktion, dh die Daten innerhalb des Vertrags können nur im Rahmen der Vertragsausführung geändert werden, nicht jedoch von außen. <br><br><img src="https://habrastorage.org/webt/rm/co/qe/rmcoqelz3bad4ltayox-u9rpxq0.png"><br><br><h3>  Bewertung verschieben </h3><br>  Ein Beispiel für ein Transaktionsskript zeigt, dass böswillige oder rücksichtslose Aktionen eines Programmierers außerhalb eines Moduls die Sicherheit von Modulressourcen nicht verletzen können.  Als nächstes sehen wir uns Beispiele an, wie Module, Ressourcen und Prozeduren zum Programmieren der Libra-Blockchain verwendet werden. <br><br><h4>  Peer-to-Peer-Zahlungen </h4><br><img src="https://habrastorage.org/webt/1a/hr/hh/1ahrhhw3rd4ky7jpfsvzxeohi0e.png"><br><br>  Der im Betrag angegebene Münzbetrag wird vom Guthaben des Absenders an den Empfänger überwiesen. <br>  Es gibt mehrere neue Punkte (rot hervorgehoben): <br><br><ul><li>  <b>0x0</b> : Adresse des Kontos, in dem das Modul gespeichert ist </li><li>  <b>Währung</b> : Modulname </li><li>  <b>Münze</b> : Ressourcentyp </li><li>  Der von der Prozedur zurückgegebene Münzwert ist ein Ressourcenwert mit dem Typ 0x0.Currency.Coin </li><li>  <b>move ()</b> : Wert kann nicht mehr verwendet werden </li><li>  <b>copy ()</b> : Wert kann später verwendet werden </li></ul><br>  Wir analysieren den Code: Im ersten Schritt ruft der Absender eine Prozedur namens <i>draw_from_sender</i> aus dem in <i>0x0.Currency</i> gespeicherten Modul auf.  In der zweiten Phase überweist der Absender das Geld an den Empfänger und verschiebt den Wert der <i>Münzressource</i> in das Einzahlungsverfahren des Moduls <i>0x0</i> . <i>Währung</i> . <br><br>  Hier sind drei Beispiele für Codefehler, die durch Überprüfungen zurückgewiesen werden: <br>  <b>Duplizieren von Geldern durch Ändern des Aufrufs zum <i>Verschieben (Münze)</i> zum <i>Kopieren (Münze)</i></b> .  Ressourcen können nur verschoben werden.  Der Versuch, die Menge einer Ressource zu duplizieren (z. B. durch Aufrufen von <i>copy (coin)</i> im obigen Beispiel), führt zu einem Fehler beim Überprüfen des Bytecodes. <br><br>  <b>Wiederverwendung von Geldern durch zweimalige Angabe von <i>Bewegung (Münze)</i></b> .  Durch Hinzufügen der Zeile <i>0x0.Currency.deposit (copy (some_other_payee), move (coin))</i> für das obige Beispiel kann der Absender zweimal Münzen "ausgeben" - das erste Mal mit dem Zahlungsempfänger und das zweite Mal mit <i>some_other_payee</i> .  Dies ist ein unerwünschtes Verhalten, das mit einem physischen Vermögenswert unmöglich ist.  Glücklicherweise wird Move dieses Programm ablehnen. <br><br>  <b>Geldverlust durch <i>Bewegungsfehler (Münze)</i></b> .  Wenn Sie die Ressource nicht verschieben (z. B. durch Löschen der Zeile mit dem <i>Verschieben (Münze)</i> ), wird durch Überprüfen des Bytecodes ein Fehler generiert.  Dies schützt Move-Programmierer vor versehentlichem oder böswilligem Geldverlust. <br><br><h3>  Währungsmodul </h3><br><img src="https://habrastorage.org/webt/p1/gx/rh/p1gxrhzyyl4cmlmlq5rcr4yhzmc.png"><br><br>  Jedes Konto kann 0 oder mehr Module (als Rechtecke dargestellt) und einen oder mehrere Ressourcenwerte (als Zylinder dargestellt) enthalten.  Ein Konto bei <i>0x0</i> enthält beispielsweise ein <i>0x0.Currency-</i> Modul und einen Ressourcenwert vom Typ <i>0x0.Currency.Coin</i> .  Das Konto bei <i>0x1</i> verfügt über zwei Ressourcen und ein Modul.  Das Konto bei <i>0x2</i> hat zwei Module und einen Ressourcenwert. <br><br>  Einige Punkte: <br><br><ul><li>  Das Transaktionsskript ist atomar - entweder vollständig oder gar nicht ausgeführt. </li><li>  Ein Modul ist ein langlebiger Code, der weltweit verfügbar ist. </li><li>  Der globale Status ist als Hash-Tabelle strukturiert, wobei der Schlüssel die Kontoadresse ist </li><li>  Konten dürfen nicht mehr als einen Ressourcenwert dieses Typs und nicht mehr als ein Modul mit einem bestimmten Namen enthalten (ein Konto bei <i>0x0</i> kann keine zusätzliche Ressource <i>0x0</i> enthalten. <i>Currency.Coin</i> oder ein anderes Modul namens <i>Currency</i> ) </li><li>  Die Adresse des deklarierten Moduls ist Teil des Typs ( <i>0x0.Currency.Coin</i> und <i>0x1.Currency.Coin</i> sind separate Typen, die nicht austauschbar verwendet werden können). </li><li>  Programmierer können mehrere Instanzen dieses Ressourcentyps im Konto speichern, indem sie ihre benutzerdefinierte Ressource definieren - ( <i>Ressource TwoCoins {c1: 0x0.Currency.Coin, c2: 0x0.Currency.Coin}</i> ) </li><li>  Sie können eine Ressource ohne Konflikte anhand ihres Namens <i>referenzieren</i> . Sie können beispielsweise mit <i>TwoCoins.c1</i> und <i>TwoCoins.c2</i> auf zwei Ressourcen <i>verweisen</i> . </li></ul><br><h4>  Coin Resource Ad </h4><br><img src="https://habrastorage.org/webt/az/79/8o/az798o2jkg9ft5tkiisy5fitk2o.png"><br>  Ein Modul namens <i>Währung</i> und ein Ressourcentyp namens <i>Münze</i> <br><br>  Einige Punkte: <br><br><ul><li>  <i>Coin</i> ist eine Einzelfeldstruktur vom Typ <i>u64</i> (64-Bit-Ganzzahl ohne Vorzeichen) </li><li>  Nur Prozeduren des <i>Währungsmoduls können</i> Münzwerte erstellen oder zerstören. </li><li>  Andere Module und Skripte können das Wertefeld nur durch offene Prozeduren schreiben oder referenzieren, die vom Modul bereitgestellt werden. </li></ul><br><h4>  Implementierung der Einzahlung </h4><br><img src="https://habrastorage.org/webt/52/uj/nw/52ujnwxqzafegglfjqrsckqwy50.png"><br><br>  Bei diesem Verfahren wird die <i>Münzressource</i> als Eingabe verwendet und mit der im Konto des Empfängers gespeicherten Münzressource kombiniert: <br><br><ol><li>  Zerstören Sie die Münzeingaberessource und zeichnen Sie ihren Wert auf. </li><li>  Abrufen eines Links zu einer eindeutigen Münzressource, die im Konto des Empfängers gespeichert ist. </li><li>  Ändern des Werts des Münzbetrags um den Wert, der beim Aufruf der Prozedur im Parameter übergeben wird. </li></ol><br>  Einige Punkte: <br><br><ul><li>  <i>Auspacken, BorrowGlobal</i> - integrierte Verfahren </li><li>  <i>Das Entpacken von &lt;T&gt;</i> ist die einzige Möglichkeit, eine Ressource vom Typ T zu löschen. Die Prozedur führt die Ressource zur Eingabe, zerstört sie und gibt den Wert zurück, der den Feldern der Ressource zugeordnet ist. </li><li>  <i>BorrowGlobal &lt;T&gt;</i> akzeptiert die Adresse als Eingabe und gibt einen Link zu einer eindeutigen Instanz von T zurück, die von dieser Adresse veröffentlicht wurde (deren Eigentümer sie ist) </li><li>  <i>&amp; mut Coin</i> ist ein Link zur <i>Coin-</i> Ressource </li></ul><br><h4>  Implementieren Sie draw_from_sender </h4><br><img src="https://habrastorage.org/webt/af/6s/h_/af6sh_tc_6jpvlwzgka0by5cnjo.png"><br><br>  Dieses Verfahren: <br><br><ol><li>  Ruft einen Link zu einer eindeutigen <i>Münzressource ab</i> , die mit dem Konto des Absenders verknüpft ist </li><li>  Verringert den Wert der <i>Münzressource</i> um den angegebenen Betrag </li><li>  Erstellt eine neue <i>Münzressource</i> mit einem aktualisierten Kontostand und gibt sie zurück. </li></ol><br>  Einige Punkte: <br><br><ul><li>  <i>Die Einzahlung</i> kann von jedem angerufen werden, aber <i>draw_from_sender</i> hat nur Zugriff auf die Münzen des aufrufenden Kontos </li><li>  <i>GetTxnSenderAddress</i> ähnelt <i>msg.sender</i> in Solidity </li><li>  <i>RejectUnless</i> ist ähnlich wie in Solidity <i>erforderlich</i> .  Wenn diese Prüfung fehlschlägt, wird die Transaktion gestoppt und alle Änderungen werden zurückgesetzt. </li><li>  <i>Pack &lt;T&gt;</i> ist auch eine integrierte Prozedur, die eine neue Ressource vom Typ T erstellt. </li><li>  Wie <i>&lt;T&gt; entpacken</i> kann <i>Pack &lt;T&gt;</i> nur innerhalb des Moduls aufgerufen werden, in dem die Ressource <i>T</i> beschrieben ist </li></ul><br><h3>  Fazit </h3><br>  Wir haben die Hauptmerkmale der Move-Sprache untersucht, sie mit Ethereum verglichen und uns auch mit der grundlegenden Syntax von Skripten vertraut gemacht.  Abschließend empfehle ich dringend, das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Original-</a> Whitepaper durchzusehen.  Es enthält viele Details zu den Prinzipien des Programmiersprachenentwurfs sowie viele nützliche Links. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459990/">https://habr.com/ru/post/de459990/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459978/index.html">Node.js Entwicklertools. Remoteprozeduraufruf an Web-Sockets</a></li>
<li><a href="../de459980/index.html">High-Tech nigerianische Briefe</a></li>
<li><a href="../de459982/index.html">Roslyn-Analysatoren. So schreiben Sie schnell und genau Code</a></li>
<li><a href="../de459984/index.html">Aufbau einer Infrastruktur als Code mit GitLab und Ansible</a></li>
<li><a href="../de459988/index.html">Der Hund aß in neuronalen Netzen</a></li>
<li><a href="../de459992/index.html">GOST R 57100-2016. Was war das?</a></li>
<li><a href="../de459994/index.html">Forschung: Linux ist immer noch das beliebteste Betriebssystem in der Cloud</a></li>
<li><a href="../de459996/index.html">Deutschland München Leitfaden für fortgeschrittene Einwanderer</a></li>
<li><a href="../de460002/index.html">Wie wir den Dream Service Desk erstellt haben</a></li>
<li><a href="../de460004/index.html">Glücklicher Systemadministratortag</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>