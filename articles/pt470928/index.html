<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â­•ï¸ ğŸ‘¨ğŸ½â€ğŸ¤ ğŸ•ï¸ PrÃ¡ticas recomendadas para executar o Buildah dentro de um contÃªiner ğŸ™…ğŸ¼ ğŸ‘¿ ğŸ´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Qual Ã© a beleza de dividir o tempo de execuÃ§Ã£o dos contÃªineres em componentes instrumentais separados? Em particular, o fato de que essas ferramentas ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PrÃ¡ticas recomendadas para executar o Buildah dentro de um contÃªiner</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/470928/">  Qual Ã© a beleza de dividir o tempo de execuÃ§Ã£o dos contÃªineres em componentes instrumentais separados?  Em particular, o fato de que essas ferramentas podem comeÃ§ar a ser combinadas para se protegerem. <br><br><img src="https://habrastorage.org/webt/mj/b5/x9/mjb5x9ahbaz_rlyie6anq31p2jm.png" width="100%"><br><br>  Muitas pessoas sÃ£o atraÃ­das pela idÃ©ia de construir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">OCIs de</a> contÃªineres no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Kubernetes</a> ou em um sistema similar.  Suponha que tenhamos um CI / CD que colete imagens constantemente, algo como o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Red Hat OpenShift</a> / Kubernetes seria muito Ãºtil em termos de balanceamento de carga durante a montagem.  AtÃ© recentemente, a maioria das pessoas simplesmente dava acesso aos contÃªineres no soquete do docker e tinha permissÃ£o para executar o comando docker build.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mostramos vÃ¡rios anos atrÃ¡s</a> que isso Ã© muito inseguro; na verdade, Ã© ainda pior do que fornecer um root ou sudo sem senha. <br><a name="habracut"></a><br>  Portanto, as pessoas estÃ£o constantemente tentando executar o Buildah em um contÃªiner.  Em resumo, criamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um exemplo</a> de como, em nossa opiniÃ£o, Ã© melhor executar o Buildah dentro do contÃªiner e colocar as imagens apropriadas em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">quay.io/buildah</a> .  Vamos comeÃ§ar ... <br><br><h3>  PersonalizaÃ§Ã£o </h3><br>  Essas imagens sÃ£o compiladas a partir do Dockerfiles, que podem ser encontrados no repositÃ³rio Buildah, na pasta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">buildahimage</a> . <br>  Aqui, examinamos a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">versÃ£o estÃ¡vel do Dockerfile</a> . <br><br><pre><code class="plaintext hljs"># stable/Dockerfile # # Build a Buildah container image from the latest # stable version of Buildah on the Fedoras Updates System. # https://bodhi.fedoraproject.org/updates/?search=buildah # This image can be used to create a secured container # that runs safely with privileges within the container. # FROM fedora:latest # Don't include container-selinux and remove # directories used by dnf that are just taking # up space. RUN yum -y install buildah fuse-overlayfs --exclude container-selinux; rm -rf /var/cache /var/log/dnf* /var/log/yum.* # Adjust storage.conf to enable Fuse storage. RUN sed -i -e 's|^#mount_program|mount_program|g' -e '/additionalimage.*/a "/var/lib/shared",' /etc/containers/storage.conf</code> </pre> <br>  Em vez de OverlayFS, implementado no nÃ­vel do kernel Linux do host, usamos o programa de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sobreposiÃ§Ã£o de fusÃ­veis</a> dentro do contÃªiner, porque no momento o OverlayFS pode ser montado apenas se tiver privilÃ©gios SYS_ADMIN pelos recursos do Linux.  E queremos executar nossos contÃªineres Buildah sem privilÃ©gios de root.  A sobreposiÃ§Ã£o de fusÃ­vel Ã© muito rÃ¡pida e tem melhor desempenho do que o driver de armazenamento VFS.  Observe que ao iniciar um contÃªiner Buildah usando o Fuse, vocÃª deve fornecer o dispositivo / dev / fuse. <br><br><pre> <code class="plaintext hljs">podman run --device /dev/fuse quay.io/buildahctr ... RUN mkdir -p /var/lib/shared/overlay-images /var/lib/shared/overlay-layers; touch /var/lib/shared/overlay-images/images.lock; touch /var/lib/shared/overlay-layers/layers.lock</code> </pre><br>  Em seguida, criamos um diretÃ³rio para armazenamento adicional.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O contÃªiner / armazenamento</a> suporta o conceito de conexÃ£o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">armazenamentos</a> adicionais de imagens somente leitura.  Por exemplo, vocÃª pode configurar a Ã¡rea de armazenamento de sobreposiÃ§Ã£o em uma mÃ¡quina e, em seguida, usar o NFS para montar esse armazenamento em outra mÃ¡quina e usar imagens dela sem fazer o download via pull.  Precisamos desse armazenamento para poder conectar algum tipo de armazenamento de imagem do host como um volume e usÃ¡-lo dentro do contÃªiner. <br><br><pre> <code class="plaintext hljs"># Set up environment variables to note that this is # not starting with user namespace and default to # isolate the filesystem with chroot. ENV _BUILDAH_STARTED_IN_USERNS="" BUILDAH_ISOLATION=chroot</code> </pre><br>  Finalmente, usando a variÃ¡vel de ambiente BUILDAH_ISOLATION, dizemos que, por padrÃ£o, o contÃªiner Buildah deve comeÃ§ar com o isolamento de chroot.  Isolamento adicional nÃ£o Ã© necessÃ¡rio aqui, pois jÃ¡ trabalhamos no contÃªiner.  Para que o Buildah crie seus prÃ³prios contÃªineres com separaÃ§Ã£o de espaÃ§os de nome, Ã© necessÃ¡rio o privilÃ©gio SYS_ADMIN, e para isso serÃ¡ necessÃ¡rio enfraquecer as regras SELinux e SECCOMP para o contÃªiner, o que contradiz a instalaÃ§Ã£o de um contÃªiner seguro. <br><br><h3>  Execute o Buildah dentro do contÃªiner </h3><br>  O esquema de imagem de contÃªiner Buildah discutido acima permite variar de maneira flexÃ­vel a maneira como vocÃª executa esses contÃªineres. <br><br><h4>  Velocidade vs. SeguranÃ§a </h4><br>  A seguranÃ§a do computador Ã© sempre um compromisso entre a velocidade do processo e a quantidade de proteÃ§Ã£o que o envolve.  Essa afirmaÃ§Ã£o tambÃ©m Ã© verdadeira ao montar contÃªineres; portanto, consideraremos abaixo opÃ§Ãµes para esse compromisso. <br><br>  A imagem do contÃªiner discutida acima manterÃ¡ seu repositÃ³rio em / var / lib / containers.  Portanto, precisamos montar o conteÃºdo nesta pasta e a maneira como fazemos isso afetarÃ¡ bastante a velocidade de montagem das imagens do contÃªiner. <br><br>  Vamos considerar trÃªs opÃ§Ãµes. <br><br>  <b>OpÃ§Ã£o 1.</b> Se for necessÃ¡ria seguranÃ§a mÃ¡xima, para cada contÃªiner vocÃª poderÃ¡ criar sua prÃ³pria pasta para contÃªineres / imagem e conectÃ¡-la ao contÃªiner via montagem de volume.  AlÃ©m disso, coloque o diretÃ³rio de contexto no prÃ³prio contÃªiner, na pasta / build: <br><br><pre> <code class="plaintext hljs"># mkdir /var/lib/containers1 # podman run -v ./build:/build:z -v /var/lib/containers1:/var/lib/containers:Z quay.io/buildah/stable\ buildah -t image1 bud /build # podman run -v /var/lib/containers1:/var/lib/containers:Z quay.io/buildah/stable buildah push \ image1 registry.company.com/myuser # rm -rf /var/lib/containers1</code> </pre><br>  <i>SeguranÃ§a</i>  O Buildah em execuÃ§Ã£o nesse contÃªiner tem seguranÃ§a mÃ¡xima: ele nÃ£o recebe privilÃ©gios de root com ferramentas de recursos e todas as restriÃ§Ãµes SECOMP e SELinux se aplicam a ele.Este contÃªiner pode atÃ© ser executado com o isolamento do namespace do usuÃ¡rio, adicionando uma opÃ§Ã£o como --uidmap 0: 100000: 10000 . <br><br>  <i>Performance.</i>  Mas o desempenho aqui Ã© mÃ­nimo, pois todas as imagens dos registros do contÃªiner sÃ£o copiadas para o host todas as vezes, e o cache nÃ£o funciona com a palavra "de jeito nenhum".  Ao concluir seu trabalho, o contÃªiner Buildah deve enviar a imagem ao registro e destruir o conteÃºdo no host.  Quando a imagem do contÃªiner for coletada na prÃ³xima vez, ela terÃ¡ que ser baixada do registro novamente, porque nesse momento nada permanecerÃ¡ no host. <br><br>  <b>OpÃ§Ã£o 2.</b> Se vocÃª precisar de desempenho no nÃ­vel do Docker, poderÃ¡ montar o contÃªiner / armazenamento do host diretamente no contÃªiner. <br><br><pre> <code class="plaintext hljs"># podman run -v ./build:/build:z -v /var/lib/containers:/var/lib/containers --security-opt label:disabled quay.io/buildah/stable buildah -t image2 bud /build # podman run -v /var/lib/containers:/var/lib/containers --security-opt label:disabled \ quay.io/buildah/stable buildah push image2 registry.company.com/myuser</code> </pre><br>  <i>SeguranÃ§a</i>  Essa Ã© a maneira menos segura de criar contÃªineres, porque aqui o contÃªiner pode modificar o armazenamento no host e, potencialmente, pode inserir no Podman ou no CRI-O uma imagem maliciosa.  AlÃ©m disso, vocÃª precisarÃ¡ desativar a separaÃ§Ã£o do SELinux para que os processos no contÃªiner Buildah possam interagir com o armazenamento no host.  Observe que essa opÃ§Ã£o ainda Ã© melhor que o soquete do Docker, pois o contÃªiner Ã© bloqueado pelas demais funÃ§Ãµes de seguranÃ§a e nÃ£o pode simplesmente pegar e executar qualquer contÃªiner no host. <br><br>  <i>Performance.</i>  Aqui estÃ¡ o mÃ¡ximo, pois o cache estÃ¡ totalmente envolvido.  Se o Podman ou o CRI-O jÃ¡ conseguiu baixar a imagem desejada para o host, o processo Buildah dentro do contÃªiner nÃ£o precisarÃ¡ baixÃ¡-lo novamente, e os assemblies subsequentes baseados nessa imagem tambÃ©m poderÃ£o obter o necessÃ¡rio do cache. <br><br>  <b>OpÃ§Ã£o 3.</b> A essÃªncia desse mÃ©todo Ã© combinar vÃ¡rias imagens em um projeto com uma pasta compartilhada para imagens de contÃªiner. <br><br><pre> <code class="plaintext hljs"># mkdir /var/lib/project3 # podman run --security-opt label:level=s0:C100, C200 -v ./build:/build:z \ -v /var/lib/project3:/var/lib/containers:Z quay.io/buildah/stable buildah -t image3 bud /build # podman run --security-opt label:level=s0:C100, C200 \ -v /var/lib/project3:/var/lib/containers quay.io/buildah/stable buildah push image3 \ registry.company.com/myuser</code> </pre><br>  Neste exemplo, nÃ£o excluÃ­mos a pasta do projeto (/ var / lib / project3) entre as partidas, portanto todas as construÃ§Ãµes subseqÃ¼entes no projeto aproveitam o cache. <br><br>  <i>SeguranÃ§a</i>  Algo entre as opÃ§Ãµes 1 e 2. Por um lado, os contÃªineres nÃ£o tÃªm acesso ao conteÃºdo no host e, portanto, nÃ£o podem colocar algo ruim no armazenamento de imagens do Podman / CRI-O.  Por outro lado, como parte de seu projeto, um contÃªiner pode interferir na montagem de outros contÃªineres. <br><br>  <i>Performance.</i>  Aqui Ã© pior do que ao usar um cache compartilhado no nÃ­vel do host, pois vocÃª nÃ£o pode usar imagens jÃ¡ baixadas anteriormente usando o Podman / CRI-O.  No entanto, depois que o Buildah faz o download da imagem, ela pode ser usada em quaisquer compilaÃ§Ãµes subseqÃ¼entes no projeto. <br><br><h4>  Armazenamento adicional </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Os contÃªineres / armazenamento</a> tÃªm algo interessante como lojas adicionais, graÃ§as Ã s quais os mecanismos de contÃªineres podem usar lojas de imagens externas no modo de sobreposiÃ§Ã£o somente leitura ao iniciar e construir contÃªineres.  De fato, vocÃª pode adicionar um ou mais armazenamentos somente leitura ao arquivo storage.conf para que, quando o contÃªiner for iniciado, o mecanismo do contÃªiner procure a imagem desejada neles.  AlÃ©m disso, ele baixarÃ¡ a imagem do registro apenas se nÃ£o a encontrar em nenhum desses repositÃ³rios.  O mecanismo de contÃªiner somente poderÃ¡ gravar no armazenamento gravÃ¡vel ... <br><br>  Se vocÃª rolar para cima e ver o Dockerfile, que usamos para criar a imagem quay.io/buildah/stable, existem as seguintes linhas: <br><br><pre> <code class="plaintext hljs"># Adjust storage.conf to enable Fuse storage. RUN sed -i -e 's|^#mount_program|mount_program|g' -e '/additionalimage.*/a "/var/lib/shared",' /etc/containers/storage.conf RUN mkdir -p /var/lib/shared/overlay-images /var/lib/shared/overlay-layers; touch /var/lib/shared/overlay-images/images.lock; touch /var/lib/shared/overlay-layers/layers.lock</code> </pre><br>  Na primeira linha, modificamos o /etc/containers/storage.conf dentro da imagem do contÃªiner, solicitando ao driver de armazenamento que use â€œadditionalimagestoresâ€ na pasta / var / lib / shared.  E na prÃ³xima linha, crie uma pasta compartilhada e adicione alguns arquivos de bloqueio para que nÃ£o haja abuso de contÃªineres / armazenamento.  Basicamente, apenas criamos um armazenamento de imagem de contÃªiner vazio. <br><br>  Se vocÃª montar contÃªineres / armazenamento acima desta pasta, o Buildah poderÃ¡ usar imagens. <br><br>  Agora, de volta Ã  opÃ§Ã£o 2 discutida acima, quando um contÃªiner Buildah pode ler e gravar em contÃªineres / loja em hosts e, consequentemente, tem desempenho mÃ¡ximo devido ao armazenamento em cache de imagens no nÃ­vel Podman / CRI-O, mas oferece um mÃ­nimo de seguranÃ§a, pois pode gravar diretamente em armazenamento.  E agora vamos fixar armazenamento adicional aqui e obter o melhor dos dois mundos. <br><br><pre> <code class="plaintext hljs"># mkdir /var/lib/containers4 # podman run -v ./build:/build:z -v /var/lib/containers/storage:/var/lib/shared:ro -v \ /var/lib/containers4:/var/lib/containers:Z quay.io/buildah/stable \ buildah -t image4 bud /build # podman run -v /var/lib/containers/storage:/var/lib/shared:ro \ -v &gt;/var/lib/containers4:/var/lib/containers:Z quay.io/buildah/stable buildah push image4 \ registry.company.com/myuser # rm -rf /var/lib/continers4</code> </pre><br>  Observe que o host / var / lib / containers / storage estÃ¡ montado em / var / lib / compartilhado dentro do container no modo somente leitura.  Portanto, trabalhando em um contÃªiner, o Buildah pode usar qualquer imagem baixada anteriormente usando o Podman / CRI-O (alta velocidade), mas pode gravar apenas em seu prÃ³prio repositÃ³rio (alta seguranÃ§a).  Observe tambÃ©m que isso Ã© feito sem desativar a separaÃ§Ã£o do SELinux para o contÃªiner. <br><br><h4>  Nuances importantes </h4><br>  Em nenhum caso vocÃª deve remover as imagens do armazenamento subjacente.  Caso contrÃ¡rio, o contÃªiner Buildah pode voar para fora. <br><br><h4>  E este nÃ£o Ã© todos os benefÃ­cios. </h4><br>  Recursos de armazenamento adicionais nÃ£o estÃ£o limitados ao cenÃ¡rio acima.  Por exemplo, vocÃª pode colocar todas as imagens de contÃªiner em um armazenamento de rede compartilhado e dar acesso a todos os contÃªineres da Buildah.  Suponha que tenhamos centenas de imagens que nosso sistema de CI / CD usa regularmente para criar imagens de contÃªiner.  Concentramos todas essas imagens em um Ãºnico host de armazenamento e, usando as ferramentas preferidas de armazenamento em rede (NFS, Gluster, Ceph, ISCSI, S3 ...), abrimos o armazenamento compartilhado para todos os nÃ³s Buildah ou Kubernetes. <br><br>  Agora Ã© suficiente montar esse armazenamento de rede no contÃªiner Buildah em / var / lib / shared e isso Ã© tudo - os contÃªineres Buildah nÃ£o precisam mais fazer o download de imagens via pull.  Assim, jogamos fora a fase prÃ©-populacional e estamos imediatamente prontos para lanÃ§ar os contÃªineres. <br><br>  E, Ã© claro, isso pode ser usado no sistema Kubernetes ou na infraestrutura de contÃªiner existente para iniciar e executar contÃªineres em qualquer lugar sem baixar imagens via pull.  AlÃ©m disso, o registro de contÃªiner, recebendo uma solicitaÃ§Ã£o por push para carregar uma imagem atualizada, pode enviar automaticamente essa imagem para um armazenamento de rede compartilhado, onde fica instantaneamente disponÃ­vel para todos os nÃ³s. <br><br>  Ã€s vezes, o tamanho das imagens do contÃªiner pode atingir muitos gigabytes.  A funcionalidade de armazenamentos adicionais permite que vocÃª faÃ§a sem clonar essas imagens por nÃ³s e torna o lanÃ§amento de contÃªineres quase instantÃ¢neo. <br><br>  AlÃ©m disso, atualmente estamos trabalhando em uma nova funÃ§Ã£o de montagens de volume de sobreposiÃ§Ã£o que tornarÃ¡ a montagem do contÃªiner ainda mais rÃ¡pida. <br><br><h3>  ConclusÃ£o </h3><br>  A execuÃ§Ã£o de um Buildah dentro de um contÃªiner no Kubernetes / CRI-O, Podman ou mesmo no Docker Ã© real, e Ã© mais simples e muito mais segura do que usar o docker.socket.  Melhoramos bastante a flexibilidade de trabalhar com imagens e agora vocÃª pode iniciÃ¡-las de vÃ¡rias maneiras para obter o equilÃ­brio ideal entre seguranÃ§a e desempenho. <br><br>  A funcionalidade de armazenamentos adicionais permite acelerar ou atÃ© eliminar completamente o download de imagens para os nÃ³s. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt470928/">https://habr.com/ru/post/pt470928/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt470918/index.html">F # 9: OpÃ§Ã£o de tipo</a></li>
<li><a href="../pt470920/index.html">Mais de 5 maneiras de conectar-se a uma nuvem DataLine</a></li>
<li><a href="../pt470922/index.html">AnÃºncio do mitap ThinkJava # 10 em Kharkov</a></li>
<li><a href="../pt470924/index.html">Por que para o novo projeto eu peguei o Robot Framework</a></li>
<li><a href="../pt470926/index.html">â€œConfiamos um no outro. Por exemplo, nÃ£o temos nenhum salÃ¡rio "- uma grande entrevista com Tim Lister, autor de Peopleware</a></li>
<li><a href="../pt470930/index.html">GamificaÃ§Ã£o do produto. Ratatype da histÃ³ria</a></li>
<li><a href="../pt470934/index.html">Cura antes do casamento: proliferaÃ§Ã£o celular e habilidades regenerativas da Ã¡gua-viva</a></li>
<li><a href="../pt470938/index.html">Como abrir um link em Python. Trabalhando com o WebBrowser e resolvendo um problema com o Internet Explorer</a></li>
<li><a href="../pt470940/index.html">MSK VUE.JS meetup # 3 no Mail.ru Group: materiais da mitap</a></li>
<li><a href="../pt470942/index.html">Do iniciante ao estilo Ã­cones: como fizemos prÃªmios em 2GIS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>