<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìü üëéüèæ üéµ Diagnostisches medizinisches Expertensystem zu Prolog üëéüèº üîª üôÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eintrag 
 Irgendwie hatte ich das Gl√ºck, das Thema der Arbeit in Software Engineering zu w√§hlen, und ich entschied mich au√üerdem, ein Expertensystem i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Diagnostisches medizinisches Expertensystem zu Prolog</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436722/"><h2>  Eintrag </h2><br>  Irgendwie hatte ich das Gl√ºck, das Thema der Arbeit in Software Engineering zu w√§hlen, und ich entschied mich au√üerdem, ein Expertensystem in der Sprache Prolog zu schreiben.  Obwohl es in der industriellen Programmierung fast nie verwendet wird, ist es theoretisch interessant und erm√∂glicht es Ihnen, intelligente Systeme (IP) auf schnellste Weise zu ber√ºhren.  Auch die Sprache selbst ist sportlich interessant, da Sie auf ungew√∂hnliche Weise denken, anders als bei prozeduraler Programmierung und OOP, einem guten Training f√ºr das Gehirn. <br><br>  Wir haben die Implementierung von Prolog - Visual Prolog mit integrierten GUI-Bibliotheken verwendet.  Aber wenn <br>  Wenn Sie eine GUI in Qt / C ++ schreiben m√∂chten, enth√§lt die Dokumentation Anweisungen zum Importieren eines Programms in eine DLL und zum Kompilieren mit einem C / C ++ - Projekt.  Daraus folgt, dass es mit anderen Sprachen kombiniert werden kann. <br><br>  Als ich an diesem Projekt arbeitete, fand ich im Allgemeinen keine Beispiele, die nicht primitiv genug waren, aber gleichzeitig nicht so gro√ü wie anspruchsvolle wissenschaftliche Beispiele.  Daher kann dieser Artikel eine sehr gute Hilfe f√ºr Anf√§nger und Leute sein, die zumindest ein wenig √§hnlich wie IP schreiben m√∂chten. <br><br>  Beschreibung des Systemzwecks: Es gibt eine Reihe von Parametern, die dem Herzsignal (EKG) entsprechen m√ºssen, anhand derer Sie die Krankheit bestimmen k√∂nnen.  Eine Person beantwortet die Fragen des Systems (im Dialogmodus), und das System, das als Experte f√ºr Herzerkrankungen fungiert, zieht Schlussfolgerungen √ºber eine m√∂gliche menschliche Krankheit. <br><br>  Das hei√üt,  Dieser Code kann als Framework (Prolog-Framework) zum Erstellen von Expertensystemen aus anderen Bereichen betrachtet werden, indem Sie einfach Ihre eigenen Regeln und Daten ersetzen.  Die Regeln, nach denen das Einf√ºgen ausgef√ºhrt wird, werden nachstehend beschrieben. <br><br><h2>  Pr√§dikatenrechnung erster Ordnung und Prologsprache </h2><br>  Die Prolog-Sprache implementiert das logische Programmierparadigma, dessen Idee die Verwendung von Computertechnologie f√ºr die logische Schlussfolgerung aus der deklarativen Beschreibung des Themenbereichs ist.  Dies unterscheidet es von prozeduralen Programmiersprachen, die genau definierte sequentielle Aktionen beschreiben.  Daher sind prozedurale Sprachen nicht zum Schreiben von ES geeignet, und wenn sie verwendet werden, nur als Hilfsmodule.  Ein weiteres Unterscheidungsmerkmal der Prolog-Sprache ist die Verwendung einer Teilmenge der Logiksprache erster Ordnung zur Beschreibung eines Programms, die bequemer und einfacher als f√ºr andere ist und von einer nat√ºrlichen Sprache zur Beschreibung der Welt durch den Menschen wechselt.  Bei der Erstellung eines ES ist dies eines der wichtigsten Probleme - wie Dom√§nenwissen in eine begrenzte formale Sprache √ºbersetzt werden kann, w√§hrend der von einer Person investierte Informationsgehalt erhalten bleibt.  Aufgrund der intuitiven Verst√§ndlichkeit und Einfachheit im Vergleich zu Logik zweiter Ordnung oder anderen mathematischen Kalk√ºlen besteht auch eine einfache M√∂glichkeit, Wissen von der formalen in die nat√ºrliche Form zur√ºck zu √ºbertragen. <br><br>  Die Sprachkonstruktionen des Prologs k√∂nnen in Form von Implikationen der Form dargestellt werden: <br><br> <code>A1, A2, ‚Ä¶, An &lt;= B1, B2, ‚Ä¶,Bm (n&gt;=0, m&gt;=0) (1)</code> <br> <br>  wobei Ai und Bi Atomformeln Fi (t1, t2, ..., tk) oder die Negation Fi (t1, t2, ..., tk) sind, wobei tk Terme sind (individuelle Konstante, Variable oder Ergebnis der Anwendung der Funktion) <br><br>  In Prolog werden alle Beziehungen als Fakten und Regeln geschrieben, wobei in Formel (1) n = 1 ist, um die Effizienz der logischen Folgerung zu erh√∂hen.  Die Regeln entsprechen einer Formel namens Hornformel: <br><br> <code>A&lt;=B1, B2, ‚Ä¶, Bm , m&gt;0 (2)</code> <br> <br>  Die Fakten entsprechen der Formel (2) mit m = 0: <br><br> <code>A&lt;= (3)</code> <br> <br>  Die Formel, die im Verlauf des Inferenzmechanismus bewiesen werden muss, ist die Formel (1) f√ºr n = 0, m&gt; 0, die als Ziel oder Anforderung bezeichnet wird: <br><br> <code>&lt;= B1, B2, ‚Ä¶Bm (4)</code> <br> <br>  Diese Sprachkonstrukte umfassen das gesamte Prolog-Programm. <br>  Zum Beispiel kann das folgende Wissen in Form eines Satzes in nat√ºrlicher Sprache - ‚ÄûSon Ani liebt Mascha‚Äú - als Tatsache geschrieben werden: <br><br><pre> <code class="plaintext hljs">((), )</code> </pre> <br>  und der Satz "Anya liebt jeden, den Olga liebt" in der Form: <br><br><pre> <code class="plaintext hljs">((,X)&lt;=(,X))</code> </pre> <br>  Oder die Argumentation ‚ÄûJeder Mensch ist sterblich.  Konfuzius ist ein Mann ‚Äú: <br><br><pre> <code class="plaintext hljs">(()&amp; ((X)&lt;=(X)) &lt;= ()</code> </pre> <br>  Der Prolog bietet auch Tools zum Definieren rekursiver Datenstrukturen wie B√§ume und Listen, die zus√§tzliche Funktionen zur bequemen Beschreibung des relevanten Wissens bieten. <br><br>  Somit ist ersichtlich, dass der Prolog eine flexible, einfache und intuitive Sprache zur Beschreibung von Wissen bietet. <br><br>  Dann stellt sich jedoch die Frage, ob die Implementierung dieser Sprache gew√§hlt werden soll, und es wurde beschlossen, ES f√ºr die Erweiterung der Prolog-Sprache - Visual Prolog - zu entwickeln. <br><br><h2>  Visueller Prolog </h2><br>  Visual Prolog ist ein Dialekt der Prolog-Sprache mit einer objektorientierten Erweiterung und einer integrierten Entwicklungsumgebung.  Diese Umgebung bietet Unterst√ºtzung f√ºr die Erstellung grafischer Oberfl√§chen und vieler anderer Bibliotheken.  Die Prolog-Sprache ist sehr beliebt f√ºr die Erstellung von ESs mit einer einfachen Syntax, die in ihrer Bedeutung Dom√§nenbeziehungen und Fakten √§hnelt.  Im Allgemeinen kann der Prolog-Sprachinterpreter selbst als ES im Sinne einer Pr√§dikatenlogik erster Ordnung betrachtet werden, bei der der Benutzer eine Frage in Form eines Ziels stellt, dessen Wahrheit bewiesen werden muss.  Dies ist eine deklarative Sprache, die beschreibt, was anstelle eines sequentiellen Algorithmus erhalten werden muss, und der perfekt ist, um das Wissen eines kleinen ES zu beschreiben.  Im Vergleich zu alternativen Umgebungen bieten AMZI Prolog und SWI-Prolog eine sehr effektive Schnittstelle f√ºr die Interaktion mit anderen Sprachen, entweder durch Verkn√ºpfen von Objektdateien oder durch dynamisches Laden von DLLs anderer Sprachen oder als eigenst√§ndiges DLL-Modul.  Visual Prolog ist ebenfalls gut dokumentiert und enth√§lt viele Beispiele.  Es besteht auch die Meinung, dass die Wahl einer Implementierungssprache, eine Art der Wissenspr√§sentation und eine Methode zur Argumentationsbildung im Vergleich zum Wissen eines Experten zweitrangig sind und nur den Mechanismus f√ºr deren erfolgreichen Einsatz beeinflussen.  Das Vorhandensein von Literatur, die den Prolog als Mittel zur Erstellung von ES verwendet, zeigt jedoch die Eignung seiner Verwendung, zumindest in kleinen Systemen. <br><br><h2>  ES Design </h2><br>  In der Literatur ist es √ºblich, ESs in mehrere grundlegende Komponenten zu unterteilen, die wenig voneinander abh√§ngig sind: die Wissensbasis, den Ausgabemechanismus und die Benutzeroberfl√§che. <br><br>  Es gibt zwei Arten der Organisation von Expertensystemen: die Regeln und die Fakten. <br><br>  Die Kenntnis der ES √ºber die Regeln wird in Form von Produktionsregeln aufgezeichnet.  Der linke Teil jeder Regel enth√§lt eine Alternative zur L√∂sung des Problems, und die rechten Teile (Pr√§missen) werden durch andere Regeln festgelegt.  Die einzige Ausnahme ist, wenn eine Regel nach Informationen in der Datenbank sucht, z. B. nach einer Antwort auf eine Frage.  Der Algorithmus des Ausgabemechanismus wird auf einen Vergleich reduziert. Bei vielen Optionen wird die ben√∂tigte nach dem Prinzip der Konfliktl√∂sung ausgew√§hlt. Am Ende wird die ausgew√§hlte Regel angewendet und alles beginnt von vorne.  Die Vorteile einer solchen Organisation bestehen darin, dass es sehr einfach ist, Regeln zum System hinzuzuf√ºgen, ohne andere Regeln zu beeinflussen, und dass sie leicht erg√§nzt und ge√§ndert werden k√∂nnen, da der Programmierer nur die gew√ºnschte Regel in den entsprechenden Regelblock einf√ºgen muss.  Eine solche Organisation weist auch Einschr√§nkungen auf, n√§mlich, dass es notwendig sein wird, einen unnat√ºrlichen Algorithmus zum Speichern von Trace zu organisieren oder eine Variable daf√ºr in den Regeln zu verwenden, dies verletzt jedoch die Bequemlichkeit des √Ñnderns der Regeln, da f√ºr jedes Regelpr√§dikat das Speichern von Trace organisiert werden muss.  Dies verletzt auch die Lesbarkeit des Programms und die M√∂glichkeit, den Ausgabemechanismus im Allgemeinen zu √§ndern, da zusammen mit den Informationen √ºber die Regeln das Durchlaufen durch die Aktion des Ausgabemechanismus beibehalten wird.  Dar√ºber hinaus k√∂nnen Sie mit dem Prolog die Regeln nicht in der Datenbankdatei speichern und die Regeln aus der Datenbank lesen, wodurch die Wissensdatenbank nicht aktualisiert werden kann, w√§hrend das Programm ausgef√ºhrt wird.  Listing 1 enth√§lt ein Beispiel f√ºr eine solche Wissensdatenbankorganisation. <br><br>  Listing 1 <br><br><pre> <code class="plaintext hljs">diag("SIRS"):- diag2("SIRS"). diag("Sepsis"):- diag("SIRS"), have("Sepsis character"). diag("Hard sepsis"):- diag("Sepsis"), have("Hard sepsis character"). diag("Shock sepsis"):- diag("Hard sepsis"), have("Shock sepsis character"). diag("MOF"):- diag("Hard sepsis"), have("MOF sepsis character"). diag("MOF"):- diag("Shock sepsis"), have("MOF sepsis character").</code> </pre> <br>  Wie aus Listing 1 ersichtlich, sollte der Ausgabemechanismus vollst√§ndig durch den integrierten Standard-Prolog-Ausgabemechanismus gesteuert werden. <br><br>  ES, die nach der Logik (nach den Fakten) organisiert sind, sind flexibler, da sie im Gegensatz zur direkten Verbindung von Regeln nach einer Referenzmethode (indirekt) zur Beschreibung der Beziehung von Regeln organisiert sind.  Beziehungen werden in Begriffen wie Regelnummern und nicht in verschachtelten Regeln geschrieben.  Eine solche Aufzeichnung ist konsistenter mit einer strengen Aufzeichnung in Form von S√§tzen der Pr√§dikatenlogik, was den Mechanismus zum Ableiten solcher Regeln flexibler macht.  Im Gegensatz zu der Organisation, die auf den Regeln basiert, h√§ngt die Suche nach der Prolog-L√∂sung weniger vom Prozess der logischen Folgerung der n√§chsten Regel ab, da neben der Ausgabe auch einige andere Aktionen ausgef√ºhrt werden k√∂nnen, z. B. ein alternativer Entscheidungsbaum durchlaufen oder sogar der Ausgabefluss ge√§ndert und unter Beibehaltung in die Ausgangsposition zur√ºckgekehrt werden kann alle Daten dar√ºber. <br><br>  Wie in der Organisation arbeitet ein Zyklus hier nach den Regeln: Matching - Konfliktl√∂sung - √úbergang zur n√§chsten Regel. Da der Ausgabemechanismus jedoch indirekt gesteuert wird, ist es zweckm√§√üig, Informationen zum Finden einer L√∂sung im Prozess anzuzeigen und dieses Format zu √§ndern, ohne die Wissensbasis zu √§ndern.  Der Hauptvorteil einer Organisation in Bezug auf Logik besteht darin, dass es m√∂glich ist, Variablen, die w√§hrend des Ausgabeprozesses zugeordnet werden, automatisch im Ausgabemechanismus verf√ºgbar zu machen, und sie k√∂nnen zusammen mit einer Kette der letzten Regeln ausgegeben werden, die an das aktuelle Ziel ausgegeben werden.  Dazu ist es jedoch erforderlich, zus√§tzlich einen Mechanismus f√ºr Geistertypen f√ºr verschiedene Regeltypen bereitzustellen.  Au√üerdem wird die Wissensdatenbank als Fakten gespeichert, sodass sie gespeichert oder aus einer Datei auf dem Medium gelesen werden kann.  Es ist schwieriger, das System anhand von Fakten als anhand der Regeln zu √§ndern und zu debuggen, da der Ausgabemechanismus durch die Werte von Variablen und Begriffen gesteuert wird, beispielsweise in Form einer Regelnummer, die zus√§tzliche M√∂glichkeiten f√ºr Fehler einf√ºhrt. <br><br>  Auch im Ausgabemechanismus gibt es mehr Variablen, die diesen Prozess beeinflussen, manchmal rekursiv und eher miteinander verbunden, was die Entwicklung erschwert und Fehler abf√§ngt. Dies ist jedoch der Preis f√ºr die Flexibilit√§t, die er bietet.  Das System arbeitet auch effizienter und schneller an Fakten als an den Regeln, was besonders f√ºr sperrige Echtzeit-ES oder sogar f√ºr verteilte Echtzeit-ES wichtig ist. <br><br>  Ein gro√üer ES f√ºr die medizinische Diagnose bei Aufnahme von Patienten in kritischem Zustand, insbesondere bei gleichzeitiger Anwendung durch viele √Ñrzte, muss ebenfalls in einen strengen Zeitrahmen passen. <br><br>  Es ist noch schwieriger, ein System aufgrund seiner Abh√§ngigkeit von Fakten auf Fakten zu testen, da in einem System auf Regeln nur ein Fehler den Ausgabemechanismus beeinflussen w√ºrde und dies sofort sichtbar w√ºrde, aber h√∂chstwahrscheinlich weiterhin an Fakten arbeiten w√ºrde. <br><br>  Da das entwickelte System f√ºr den Benutzer informativ sein sollte, sollte im Zuge der logischen Folgerung eine vern√ºnftige Antwort auf die Frage angezeigt werden - warum ben√∂tigte das System die angeforderten Informationen, damit der Benutzer wei√ü, in welchem ‚Äã‚ÄãStadium der L√∂sungssuche er sich befindet, was ohne Speichern der Ablaufverfolgung nicht erreicht werden kann Suche.  Auch am Ende sollte der Benutzer nach Beantwortung der Frage den Beweisbaum f√ºr die gefundenen L√∂sungen sehen k√∂nnen.  Angesichts aller Parameter des Systems schien mir das rationalste System die Regeln zu sein, da es auf der Festplatte gespeichert werden kann und sein Ausgabemechanismus einfacher zu organisieren ist.  Das Wissen √ºber die Diagnose von Herz-Kreislauf-Erkrankungen erwies sich aufgrund ihrer semantischen Vernetzung als schwierig zu formalisieren, insbesondere dort, wo die Bedeutung der Schlussfolgerungen der Regeln die Ber√ºcksichtigung zus√§tzlicher Informationen f√ºr jeden Einzelnen bedeutete.  Daher wurde bei der Auswahl eines Mechanismus zum Austausch heterogener Daten zwischen Pr√§dikaten eine Berechnung der logischen Art der Organisation durchgef√ºhrt. <br><br>  Es gibt auch zwei Arten von Inferenz: inverse und direkte Inferenz.  In komplexen medizinischen Konsultationssystemen wird immer noch eine Kombination dieser Typen verwendet: Ein bestimmter Wissensumfang wird von einem Typ abgeleitet, und ein anderer wird bereits auf seiner Grundlage verwendet. <br><br>  Eine direkte Schlussfolgerung besteht darin, einen Effekt zu finden, der auf einer Vielzahl von Fakten basiert, und dann andere Schlussfolgerungen aus den neuen Konsequenzen zu ziehen.  Es ist effektiv, wenn viele Hypothesen auf verschiedenen Ebenen miteinander verbunden sind, die bewiesen werden m√ºssen, oder wenn viele Axiome zur Ableitung vieler weiterer Hypothesen vorliegen. <br><br>  Die umgekehrte Schlussfolgerung ist das Gegenteil: Zuerst wird eine Hypothese ausgew√§hlt, die bewiesen werden muss, und dann wird versucht, die Pr√§misse dieser Hypothese zu beweisen, bis die n√§chste Pr√§misse als Axiom gefunden wird. <br><br>  In ES wird die Argumentation zu den Regeln durch die Methode der inversen logischen Inferenz implementiert, die Prolog verwendet.  Diese Option wurde gew√§hlt, da sie im Gegensatz zur direkten Inferenz mit diesem Wissen effizienter arbeitet, da die Anzahl der Zielscheitelpunkte viel mehr als Fakten ist und es keine konkurrierenden Hypothesen gibt (sie sind unabh√§ngig). <br><br><h2>  Implementierung </h2><br>  In Prolog werden Regeln als Regelpr√§dikat implementiert.  Jede Regel hat ihre eigene Nummer und ihren eigenen Namen. Dies ist eine Hypothese (Schlussfolgerung), die bewiesen werden muss.  Die Bedingung der Regel entspricht einer impliziten Aussage, die die Wahrheit der Hypothese vollst√§ndig bestimmt. <br><br>  Regelbedingung: <br><br><pre> <code class="plaintext hljs">Colclusion(K)=C1(K) and (C2(K) or C3(K)) and C4(K)</code> </pre> <br>  C1 (K) = Alle Schlussfolgerungen der Regeln mit den in der ersten Liste f√ºr die K-te Regel aufgezeichneten Zahlen sind wahr <br><br>  C2 (K) = True, mindestens eine Regel aus der zweiten Liste f√ºr die K-te Regel <br>  C3 (K) = Wirklich genau N (K) Schlussfolgerungen von Regeln aus der zweiten Liste f√ºr die K-te Regel <br><br>  C4 (K) = Das Pr√§dikat f√ºr die K-te Regel (Pr√§dikat doc (K)), das vom Benutzer beschrieben wird. <br>  Wenn eine Liste leer ist, ist die entsprechende Aussage wahr. <br><br>  Gleichzeitig k√∂nnen alle anderen Pr√§dikate in das Pr√§dikat f√ºr C4 eingegeben werden, gleichzeitig sollten sie jedoch nicht die logische Bedeutung der Schlussfolgerung verletzen.  Um die Ablehnung zu unterst√ºtzen, k√∂nnen hier auch einige vorhandene Schlussfolgerungen in der Wissensbasis eingegeben werden. <br><br>  Der Ausgabemechanismus stellt sicher, dass die Regeln in der richtigen Reihenfolge angewendet werden, und speichert die Ablaufverfolgung. <br><br>  Das Hauptprinzip der Schlussfolgerung besteht darin, die Wahrheit der Schlussfolgerung zu beweisen, alle ihre Schlussfolgerungen in der ersten Liste konsistent zu beweisen, dann die Schlussfolgerungen der zweiten Liste zu beweisen und am Ende die Wahrheit des Pr√§dikats zu √ºberpr√ºfen, das der Nummer der aktuellen Regel entspricht.  Um die zweite Liste zu √ºberpr√ºfen, werden alle weiteren Regeln bis zum Ende der Liste √ºberpr√ºft, wenn mindestens eine echte Regel gefunden wurde. <br><br><h2>  Pr√§dikatbeschreibung </h2><br>  Im Allgemeinen wird das Prinzip der Wissenskodierung auf dem Prolog unter Verwendung von zwei Pr√§dikaten in der folgenden Form implementiert: <br><br>  Regel (K, "Schlussfolgerungstext ist der Name der Regel", Id, Liste1, Liste2, N) <br>  doc (K) <br>  K - Regelnummer <br>  ID - Daten-ID f√ºr diese Regel <br>  Liste1 - Die erste Liste der Regelnummern <br>  Liste2 - zweite Liste der Regelnummern <br>  N ist die Anzahl der wahren Schlussfolgerungen <br><br>  Dar√ºber hinaus wird die Regel immer als Tatsache ohne Variablen geschrieben, und ihre Wahrheit bestimmt, wie gesagt, zus√§tzlich zu Listen das entsprechende Pr√§dikat doc. <br><br>  Hier einige Beispiele f√ºr Schreibkenntnisse: <br><br>  Regel (93, "TASH - TASH-Score 43%", tashSc10, [47], [], 0) <br>  Regel (33, "TASH - √úberschuss an Gr√ºnden - ist die Summe der Punkte", keine, [], [29,30,31,32], 1). <br><br>  Im Pr√§dikatdokument k√∂nnen beliebige andere Pr√§dikate verwendet werden, wodurch es m√∂glich ist, den Text der Anweisung der Regel der Menge aller Situationen zuzuordnen, die mit dem Prolog beschrieben werden k√∂nnen. <br><br>  Auf diese Weise wird das gesamte Wissen unter Verwendung dieser beiden Pr√§dikate aufgezeichnet. <br><br>  In doc-Pr√§dikaten werden die Benutzeroberfl√§chenfunktionen haupts√§chlich aufgerufen, da einige Regeln von Natur aus untrennbar mit der Antwort des Benutzers verkn√ºpft sind oder nach g√ºltigen Werten suchen. <br><br>  Beispielsweise legt das Dokument Pr√§dikate f√ºr Regeln fest, deren Wahrheit von dem Intervall abh√§ngt, in dem sich die Gesamtpunktzahl befindet, und f√ºhrt entsprechende √úberpr√ºfungen durch. <br><br>  Das doc-Pr√§dikat f√ºr die Diagnose von Sepsis-Erkrankungen verwendet das zus√§tzliche docc-Pr√§dikat, mit dem dem Benutzer keine unn√∂tigen Fragen gestellt werden k√∂nnen.  Wenn f√ºr ein Zeichen beispielsweise mindestens zwei Zeichen erforderlich sind und die Antwort auf zwei Zeichen Nein lautet, sollte das System keine weiteren Fragen stellen, da es offensichtlich ist, dass das Zeichen nicht wahr sein kann.  Zu diesem Zweck pr√ºft das docc-Pr√§dikat mehr als zwei negative Antworten in der Datenbank.  Es macht auch keinen Sinn, die dritte Frage zu stellen, wenn bereits eine Antwort auf zwei Fragen vorliegt, die ausreichen, um die Wahrheit des resultierenden Merkmals festzustellen. <br><br>  Das Pr√§dikat kolNeg (Quantity) sucht nach der Anzahl der negativen Antworten in der Datenbank f√ºr diese Gruppe von Attributen.  Dazu sucht er zun√§chst nach allen Arten von Zeichen dieser Zeichengruppe, um sie nicht mit anderen Gruppen zu verwechseln, und betrachtet sie dann aus der Menge in der Datenbank unter Verwendung des Pr√§dikats kol_neg_list_in_db, das mit der Liste der Zeichen dieser Gruppe arbeitet. <br><br><h2>  Codebeispiele </h2><br>  Das Projekt ist gro√ü, deshalb werde ich die wichtigsten Passagen geben. <br><br>  Listing 2 - Liste der Regeln <br><br><pre> <code class="plaintext hljs">rule(11,"Sepsises - SIRS . 1: t&gt;38C  t&lt;36",sirsPr1,[],[],0). rule(12,"Sepsises -   &gt;90",sirsPr2,[],[],0). rule(13,"Sepsises -  &gt;20  PaCO2&lt;32mmHg",sirsPr3,[],[],0).</code> </pre> <br>  Listing 3 - Liste der Fakten <br><br><pre> <code class="plaintext hljs">fact1(sirsPr1,"SIRS","SIRS . 1: t&gt;38C  t&lt;36"). fact1(sirsPr2,"SIRS","  &gt;90"). fact1(sirsPr3,"SIRS"," &gt;20  PaCO2&lt;32mmHg"). fact1(sirsPr4,"SIRS","- &gt;12.000/mm&gt;3, &lt;4.000/mm&gt;3  &gt;10% band").</code> </pre> <br>  - Liste der logischen Konsequenzen <br><br><pre> <code class="plaintext hljs">tash_score(1,tashSc1,0,8,"  &lt;5%"). tash_score(2,tashSc2,9,9,"  6%"). tash_score(3,tashSc3,10,10,"  8%").</code> </pre> <br>  Listing 4 - Ausgabemaschine <br><br><pre> <code class="1c hljs">sizeList([],<span class="hljs-number"><span class="hljs-number">0</span></span>):-!. sizeList([_<span class="hljs-string"><span class="hljs-string">|T],Size):- sizeList(T,SizeTail), Size=SizeTail+1. append_der_list([],List,List). append_der_list([H|L1],List2,[H|L3]):- append_der_list(L1,List2,L3). any2(NeedSize,NeedSize,_,[],[],_):-!. any2(_,_,[],[],[],_):-!. any2(NeedSize,Size,[H|T1],[H|T2],[FirstDer|OtherDer],Why):- Nomer=[H], go(Nomer,UnderFirstDer,Why), rule(H,Text,_,_,_,_), FirstDer=tree(Text,unmarked,UnderFirstDer,0),%der(H,UnderFirstDer), Size1=Size+1,!, any2(NeedSize,Size1,T1,T2,OtherDer,Why). any2(NeedSize,Size,[_|T1],List,OrDer,Why):- !,any2(NeedSize,Size,T1,List,OrDer,Why). go([],[],_):-!. go([H|T],[FirstDer|OtherDer],Why):- rule(H,Name,_,ListAnd,ListOr,KolOr), NewWhy=[Name|Why], go(ListAnd,UnderFirstDer,NewWhy), goOr(ListOr,KolOr,_,OrDer,NewWhy), append_der_list(UnderFirstDer,OrDer,TwoDers), FirstDer=tree(Name,unmarked,TwoDers,0), asserta(why_trace(NewWhy)), doc(H,NewWhy), go(T,OtherDer,Why). goOr([],_,[],[],_):-!. goOr(ListOr,KolOr,ListYes,OrDer,Why):- KolOr&lt;&gt;0, any2(KolOr,0,ListOr,ListYes,OrDer,Why), sizeList(ListYes,KolOr). goOr(ListOr,0,ListYes,OrDer,Why):- any2(100000,0,ListOr,ListYes,OrDer,Why), sizeList(ListYes,KolListYes), KolListYes&gt;0.</span></span></code> </pre> <br>  Listing 5 - Abschluss der endg√ºltigen Konsequenzen <br><br><pre> <code class="plaintext hljs">tashQuestion(Id):- fact2(Id,_,Prisnak,_), pos(Prisnak),!. tashQuestion(Id):- fact2(Id,_,Prisnak,_), neg(Prisnak),fail,!. tashQuestion(Id):- fact2(Id,_,Prisnak,Ball), not(neg(Prisnak)), not(pos(Prisnak)), dialog_ynw(Prisnak,Ans), tash_in_data_base(Ans,Prisnak,Ball),!. tash_in_data_base("y",Prisnak,Ball):- asserta(pos(Prisnak)),sum_tash(Sum1),Sum2=Sum1+Ball,asserta(sum_tash(Sum2)),!. tash_in_data_base("n",Prisnak,_):- asserta(neg(Prisnak)),!,fail. tash_in_data_base(_,_,_):- write("\nTASH-not correct answer"),!,fail. oneQuestion(Id):- fact1(Id,_,Prisnak), pos(Prisnak),!. oneQuestion(Id):- fact1(Id,_,Prisnak), not(neg(Prisnak)), question_sepsis(Prisnak),!.</code> </pre> <br><h2>  Schlussfolgerungen </h2><br>  Ich hoffe, dieser Artikel hilft Anf√§ngern beim Aufbau ihres eigenen Expertensystems. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436722/">https://habr.com/ru/post/de436722/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436712/index.html">Wie bewerbe ich ein inkrementelles Spiel? Kostenlos, schnell und effektiv *</a></li>
<li><a href="../de436714/index.html">Die Arbeit beginnt mit dem Testen.</a></li>
<li><a href="../de436716/index.html">Fake Door im Rahmen der Kundenentwicklung</a></li>
<li><a href="../de436718/index.html">Pers√∂nliche Erfahrung: F√ºnf Herausforderungen bei der Gr√ºndung eines Unternehmens in den USA</a></li>
<li><a href="../de436720/index.html">Es gibt eine Meinung: IPv6 ist fehlgeschlagen - wer denkt das und warum?</a></li>
<li><a href="../de436730/index.html">Unterhaltungselektronik Hall of Fame: Die Geschichten der besten Ger√§te der letzten 50 Jahre, Teil 5</a></li>
<li><a href="../de436740/index.html">Eigene Forschung, was k√∂nnen uns Open Source sagen?</a></li>
<li><a href="../de436742/index.html">Android Robotics bis 2019: Die wahre Geschichte; in 5 Teilen; Teil 1</a></li>
<li><a href="../de436744/index.html">Starten Sie Ihren Detektor f√ºr neuronale Netze mit dem Neural Compute Stick und OpenVINO auf dem Raspberry Pi</a></li>
<li><a href="../de436746/index.html">So verschlechtern Sie die Leistung, indem Sie sie verbessern</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>