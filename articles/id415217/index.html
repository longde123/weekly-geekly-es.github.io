<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßü ü§õüèø üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë© Membuat hook kucing di Unity. Bagian 2 üòõ üïî üë≤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Catatan : tutorial ini ditujukan untuk pengguna mahir dan berpengalaman, dan tidak mencakup topik seperti menambahkan komponen, membuat skrip GameObje...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membuat hook kucing di Unity. Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415217/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db0/187/d5e/db0187d5e9f5fc2bfa78b078dcb2a178.png" alt="gambar"></div><br><blockquote> <em>Catatan</em> : tutorial ini ditujukan untuk pengguna mahir dan berpengalaman, dan tidak mencakup topik seperti menambahkan komponen, membuat skrip GameObject baru, dan sintaksis C #.  Jika Anda perlu meningkatkan keterampilan Unity Anda, lihat tutorial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memulai Penggunaan dengan Unity</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengantar Script Unity kami</a> . </blockquote><br>  Di bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama</a> tutorial, kami belajar cara membuat kait kucing dengan mekanisme melilitkan tali di sekeliling rintangan.  Namun, kami ingin lebih: tali dapat membungkus benda di tingkat, tetapi tidak lepas ketika Anda kembali. <br><a name="habracut"></a><br><h2>  Mulai bekerja </h2><br>  Buka proyek jadi dari bagian pertama di Unity atau unduh <a href="">draf</a> untuk bagian tutorial ini, lalu buka <em>2DGrapplingHook-Part2-Starter</em> .  Seperti pada bagian pertama, kita akan menggunakan versi Unity 2017.1 atau lebih tinggi. <br><br>  Buka adegan <em>Game</em> di editor dari folder proyek <em>Scenes</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/89c/ee3/48c/89cee348caa1656418bcc0ded8e91bab.png"></div><br>  Luncurkan adegan Game dan coba kaitkan kait kucing di atas batu di atas karakter, lalu ayun untuk membuat tali membungkus sepasang tepi batu. <br><br>  Ketika Anda kembali, Anda akan melihat bahwa titik-titik batu tempat tali yang digunakan untuk berbalik tidak terlepas lagi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e9/d83/da7/4e9d83da7eda544a3f48cecbf3e64b08.gif"></div><br>  Pikirkan tentang titik di mana tali harus dibuka.  Untuk menyederhanakan tugas, lebih baik menggunakan kasing saat tali membungkus ujung-ujungnya. <br><br>  Jika siput, menempel pada batu di atas kepalanya, berayun ke kanan, maka tali akan bengkok setelah ambang batas di mana ia melintasi titik sudut 180 derajat dengan tepi yang saat siput terpasang.  Pada gambar di bawah, ini ditunjukkan oleh titik hijau yang disorot. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3eb/257/132/3eb25713213c01fb76fb97c49e6958cf.png"></div><br>  Ketika siput itu berayun kembali ke arah lain, tali itu harus kembali terlepas pada titik yang sama (disorot dengan warna merah pada gambar di atas): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ef/ad3/e22/2efad3e22fddf83cefcf52fca6175792.png"></div><br><h2>  Logika tidak terputus-putus </h2><br>  Untuk menghitung momen ketika Anda perlu melepas tali pada titik-titik yang dibungkus sebelumnya, kita perlu pengetahuan tentang geometri.  Secara khusus, kami akan menggunakan perbandingan sudut untuk menentukan kapan tali harus dilepas dari tepi. <br><br>  Tugas ini mungkin tampak sedikit mengintimidasi.  Matematika dapat menginspirasi horor dan keputusasaan bahkan dalam yang paling berani. <br><br>  Untungnya, Unity memiliki beberapa fungsi penolong matematika yang hebat yang dapat membuat hidup kita sedikit lebih mudah. <br><br>  Buka skrip <em>RopeSystem</em> di IDE dan buat metode baru yang disebut <code>HandleRopeUnwrap()</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleRopeUnwrap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { }</code> </pre> <br>  Buka <code>Update()</code> dan tambahkan pada akhirnya panggilan ke metode baru kami. <br><br><pre> <code class="cs hljs">HandleRopeUnwrap();</code> </pre> <br>  Sementara <code>HandleRopeUnwrap()</code> tidak melakukan apa-apa, tetapi sekarang kita dapat memproses logika yang terkait dengan seluruh proses melepaskan dari tepi. <br><br>  Seperti yang Anda ingat dari bagian pertama tutorial, kami menyimpan posisi pembungkus tali dalam koleksi yang disebut <code>ropePositions</code> , yang merupakan koleksi <code>List&lt;Vector2&gt;</code> .  Setiap kali tali melilit ujung, kami menjaga posisi titik bungkus ini dalam koleksi ini. <br><br>  Untuk membuat proses lebih efisien, kami tidak akan menjalankan logika apa pun di <code>HandleRopeUnwrap()</code> jika jumlah posisi yang disimpan dalam koleksi sama dengan atau kurang dari 1. <br><br>  Dengan kata lain, ketika siput telah terhubung ke titik awal dan tali belum melilit ujungnya, jumlah <code>ropePositions</code> adalah 1, dan kami tidak akan mengikuti logika pemrosesan yang tidak diputar. <br><br>  Tambahkan <code>return</code> sederhana ini ke bagian atas <code>HandleRopeUnwrap()</code> untuk menghemat siklus CPU yang berharga, karena metode ini dipanggil dari <code>Update()</code> berkali-kali per detik. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ropePositions.Count &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><h3>  Menambahkan Variabel Baru </h3><br>  Di bawah pengujian baru ini, kami akan menambahkan beberapa dimensi dan referensi ke berbagai sudut yang diperlukan untuk menerapkan dasar dari logika yang tidak terputar.  Tambahkan kode berikut ke <code>HandleRopeUnwrap()</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Hinge =       // Anchor =     Hinge // Hinge Angle =   anchor  hinge // Player Angle =   anchor  player // 1 var anchorIndex = ropePositions.Count - 2; // 2 var hingeIndex = ropePositions.Count - 1; // 3 var anchorPosition = ropePositions[anchorIndex]; // 4 var hingePosition = ropePositions[hingeIndex]; // 5 var hingeDir = hingePosition - anchorPosition; // 6 var hingeAngle = Vector2.Angle(anchorPosition, hingeDir); // 7 var playerDir = playerPosition - anchorPosition; // 8 var playerAngle = Vector2.Angle(anchorPosition, playerDir);</span></span></code> </pre> <br>  Ada banyak variabel di sini, jadi saya akan menjelaskan masing-masing, serta menambahkan ilustrasi yang nyaman yang akan membantu untuk memahami tujuan mereka. <br><br><ol><li>  <code>anchorIndex</code> adalah indeks dalam koleksi <code>ropePositions</code> di dua posisi dari akhir koleksi.  Kita dapat menganggapnya sebagai titik di dua posisi pada tali dari posisi siput.  Pada gambar di bawah ini, ini adalah titik pertama pengait kait ke permukaan.  Saat mengisi koleksi <code>ropePositions</code> titik pembungkus baru, titik ini akan selalu tetap menjadi titik pembungkus pada jarak dua posisi dari siput. </li><li>  <code>hingeIndex</code> adalah indeks koleksi yang menyimpan titik engsel saat ini;  dengan kata lain, posisi tali saat ini sedang membungkus titik terdekat dengan ujung tali dari siput.  Itu selalu pada jarak satu posisi dari siput, itulah sebabnya kami menggunakan <code>ropePositions.Count - 1</code> . </li><li>  <code>anchorPosition</code> dihitung dengan merujuk tempat <code>ropePositions</code> koleksi <code>ropePositions</code> dan merupakan nilai Vector2 sederhana dari posisi itu. </li><li>  <code>hingePosition</code> dihitung dengan merujuk tempat <code>hingeIndex</code> dalam koleksi <code>ropePositions</code> dan merupakan nilai Vector2 sederhana dari posisi itu. </li><li>  <code>hingeDir</code> adalah vektor yang diarahkan dari <code>anchorPosition</code> ke <code>hingePosition</code> .  Ini digunakan dalam variabel berikut untuk mendapatkan sudut. </li><li>  <code>hingeAngle</code> - fungsi pembantu yang berguna <code>Vector2.Angle()</code> digunakan di sini untuk menghitung sudut antara <code>anchorPosition</code> dan titik engsel. </li><li>  <code>playerDir</code> adalah vektor yang diarahkan dari <code>anchorPosition</code> ke posisi siput saat ini (playerPosition) </li><li>  Kemudian, menggunakan sudut antara titik jangkar dan pemain (siput), <code>playerAngle</code> dihitung. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73f/207/4c4/73f2074c470b3016bcd5ee386ce240e8.png"></div><br>  Semua variabel ini dihitung menggunakan posisi yang disimpan sebagai nilai Vector2 dalam koleksi <code>ropePositions</code> dan membandingkan posisi ini dengan posisi lain atau posisi pemain saat ini (slug). <br><br>  Dua variabel penting yang digunakan untuk perbandingan adalah <code>hingeAngle</code> dan <code>playerAngle</code> . <br><br>  Nilai yang disimpan dalam <code>hingeAngle</code> harus tetap statis karena selalu sudut yang konstan antara titik di dua "lipatan tali" dari siput dan "lipatan tali" saat ini yang paling dekat dengan siput yang tidak bergerak sampai tali tidak terpilin atau setelah dilipat titik tikungan baru akan ditambahkan. <br><br>  Saat siput <code>playerAngle</code> berubah.  Dengan membandingkan sudut ini dengan <code>hingeAngle</code> , dan juga memeriksa apakah siput di sebelah kiri atau kanan sudut ini, kita dapat menentukan apakah titik lipat saat ini yang paling dekat dengan siput harus dilepaskan. <br><br>  Di bagian pertama tutorial ini, kami menyimpan posisi lipatan dalam kamus yang disebut <code>wrapPointsLookup</code> .  Setiap kali kami menyimpan titik tekuk, kami menambahkannya ke kamus dengan posisi sebagai kunci dan dengan 0 sebagai nilainya.  Namun, nilai 0 ini agak misterius, bukan? <br><br>  Kami akan menggunakan nilai ini untuk menyimpan posisi siput relatif terhadap sudutnya dengan titik engsel (titik lipat saat ini paling dekat dengan siput). <br><br>  Jika Anda menetapkan nilai <em>-1</em> , maka sudut siput ( <code>playerAngle</code> ) kurang dari sudut engsel ( <code>hingeAngle</code> ), dan dengan nilai <em>1,</em> sudut <code>playerAngle</code> lebih besar daripada <code>hingeAngle</code> . <br><br>  Karena fakta bahwa kita menyimpan nilai-nilai dalam kamus, setiap kali kita membandingkan <code>playerAngle</code> dengan <code>hingeAngle</code> , kita dapat memahami apakah siput baru saja melewati batas yang setelah itu tali harus dilepas. <br><br>  Ini dapat dijelaskan secara berbeda: jika sudut siput baru saja diperiksa dan lebih kecil dari sudut engsel, tetapi terakhir kali disimpan dalam kamus titik lengkung itu ditandai dengan nilai yang menunjukkan bahwa itu berada di sisi lain sudut ini, maka titik tersebut harus dihapus ! <br><br><h3>  Tali pemisah </h3><br>  Lihatlah screenshot di bawah ini dengan catatan.  Siput kami menempel di batu, bergoyang ke atas, melilitkan tali di tepi batu pada saat naik. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db0/187/d5e/db0187d5e9f5fc2bfa78b078dcb2a178.png"></div><br>  Anda mungkin memperhatikan bahwa pada posisi ayunan paling atas, di mana siputnya buram, titik lipatan terdekat saat ini (ditandai dengan titik putih) akan disimpan dalam kamus <code>wrapPointsLookup</code> dengan nilai <em>1</em> . <br><br>  Dalam perjalanan turun, ketika <code>playerAngle</code> menjadi lebih kecil daripada <code>hingeAngle</code> (dua garis hijau putus-putus), seperti yang ditunjukkan oleh panah biru, pemeriksaan dilakukan, dan jika nilai terakhir (saat ini) dari titik bengkok adalah <em>1</em> , maka titik bengkok harus dihapus. <br><br>  Sekarang mari kita terapkan logika ini dalam kode.  Tetapi sebelum kita mulai, mari kita buat metode kosong yang akan kita gunakan untuk bersantai.  Karena ini, setelah membuat logika, itu tidak akan menyebabkan kesalahan. <br><br>  Tambahkan metode <code>UnwrapRopePosition(anchorIndex, hingeIndex)</code> baru <code>UnwrapRopePosition(anchorIndex, hingeIndex)</code> dengan memasukkan baris berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnwrapRopePosition</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> anchorIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hingeIndex</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br>  Setelah melakukan ini, kembali ke <code>HandleRopeUnwrap()</code> .  Di bawah variabel yang baru ditambahkan, tambahkan logika berikut, yang akan menangani dua kasus: <code>playerAngle</code> kurang dari <code>hingeAngle</code> dan <code>playerAngle</code> lebih dari <code>hingeAngle</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (playerAngle &lt; hingeAngle) { <span class="hljs-comment"><span class="hljs-comment">// 1 if (wrapPointsLookup[hingePosition] == 1) { UnwrapRopePosition(anchorIndex, hingeIndex); return; } // 2 wrapPointsLookup[hingePosition] = -1; } else { // 3 if (wrapPointsLookup[hingePosition] == -1) { UnwrapRopePosition(anchorIndex, hingeIndex); return; } // 4 wrapPointsLookup[hingePosition] = 1; }</span></span></code> </pre> <br>  Kode ini harus sesuai dengan penjelasan logika yang dijelaskan di atas untuk kasus pertama (ketika <code>playerAngle</code> &lt; <code>hingeAngle</code> ), tetapi juga menangani kasus kedua (ketika <code>playerAngle</code> &gt; <code>hingeAngle</code> ). <br><br><ol><li>  Jika titik lipat saat ini yang paling dekat dengan siput memiliki nilai <em>1</em> pada titik di mana <code>playerAngle</code> &lt; <code>hingeAngle</code> , maka kami menghapus titik ini dan melakukan pengembalian sehingga sisa metode tidak dieksekusi. </li><li>  Jika tidak, jika titik bengkok tidak ditandai terakhir dengan nilai <em>1</em> , tetapi <code>playerAngle</code> kurang dari <code>hingeAngle</code> , maka <em>-1</em> ditugaskan. </li><li>  Jika titik lipat saat ini yang paling dekat dengan siput adalah <em>-1</em> pada titik di mana <code>playerAngle</code> &gt; <code>hingeAngle</code> , kemudian hapus titik dan kembali. </li><li>  Jika tidak, kami menetapkan entri dalam kamus titik lengkung pada posisi engsel ke <em>1</em> . </li></ol><br>  Kode ini memastikan bahwa kamus <code>wrapPointsLookup</code> selalu diperbarui, memastikan bahwa nilai titik tekuk saat ini (paling dekat dengan siput) cocok dengan sudut siput saat ini relatif terhadap titik tekuk. <br><br>  Jangan lupa bahwa nilainya -1 ketika sudut slug kurang dari sudut engsel (relatif ke titik referensi), dan 1 ketika sudut slug lebih besar dari sudut engsel. <br><br>  Sekarang kita akan <code>UnwrapRopePosition()</code> dalam skrip <em>RopeSystem dengan</em> kode yang akan langsung terlibat dalam pelepasan, memindahkan posisi referensi dan menetapkan nilai jarak baru ke nilai jarak tali DistanceJoint2D.  Tambahkan baris berikut ke disk metode yang dibuat sebelumnya: <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">// 1 var newAnchorPosition = ropePositions[anchorIndex]; wrapPointsLookup.Remove(ropePositions[hingeIndex]); ropePositions.RemoveAt(hingeIndex); // 2 ropeHingeAnchorRb.transform.position = newAnchorPosition; distanceSet = false; // Set new rope distance joint distance for anchor position if not yet set. if (distanceSet) { return; } ropeJoint.distance = Vector2.Distance(transform.position, newAnchorPosition); distanceSet = true;</span></span></code> </pre> <br><ol><li>  Indeks titik jangkar saat ini (posisi kedua tali dari siput) menjadi posisi baru dari engsel, dan posisi lama dari engsel dilepas (yang sebelumnya paling dekat dengan siput dan yang sekarang kita "lepaskan").  Variabel <code>newAnchorPosition</code> diberikan nilai <code>anchorIndex</code> dalam daftar posisi tali.  Kemudian akan digunakan untuk memposisikan posisi yang diperbarui dari titik jangkar. </li><li>  Tali-sambungan RigidBody2D (dimana tali DistanceJoint2D terpasang) mengubah posisinya ke posisi baru dari titik jangkar.  Hal ini memastikan gerakan siput terus menerus yang lancar pada tali ketika terhubung ke DistanceJoint2D, dan koneksi ini harus memungkinkannya untuk terus berayun relatif terhadap posisi baru, yang menjadi referensi - dengan kata lain, relatif ke titik berikutnya turun tali dari posisinya. </li><li>  Maka Anda perlu memperbarui nilai jarak distanceJoint2D untuk memperhitungkan perubahan tajam dalam jarak dari siput ke titik referensi baru.  Jika ini belum dilakukan, pemeriksaan cepat dari flag <code>distanceSet</code> dilakukan, dan jarak diberikan nilai jarak yang dihitung antara siput dan posisi baru dari titik jangkar. </li></ol><br>  Simpan skrip dan kembali ke editor.  Mulai permainan lagi dan perhatikan bagaimana tali terlepas dari tepi ketika siput melewati nilai ambang batas dari setiap titik tikungan! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65b/4af/3a1/65b4af3a13e464947b394595dc052a06.gif"></div><br>  Meskipun logikanya sudah siap, kami akan menambahkan beberapa kode pembantu ke <code>HandleRopeUnwrap()</code> tepat sebelum membandingkan <code>playerAngle</code> dengan <code>hingeAngle</code> ( <code>if (playerAngle &lt; hingeAngle)</code> ). <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!wrapPointsLookup.ContainsKey(hingePosition)) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"We were not tracking hingePosition ("</span></span> + hingePosition + <span class="hljs-string"><span class="hljs-string">") in the look up dictionary."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br>  Sebenarnya, ini seharusnya tidak terjadi, karena kami mendefinisikan ulang dan melepaskan kait kucing ketika membungkus sekitar satu tulang rusuk dua kali, tetapi jika ini masih terjadi, kita dapat dengan mudah keluar dari metode ini dengan <code>return</code> sederhana dan pesan kesalahan di konsol. <br><br>  Selain itu, berkat ini, kami akan lebih mudah menangani kasus pembatas seperti itu;  Selain itu, kami mendapatkan pesan kesalahan kami sendiri jika terjadi sesuatu yang tidak perlu. <br><br><h2>  Ke mana harus pergi selanjutnya? </h2><br>  Berikut ini <a href="">tautan ke proyek yang sudah selesai</a> pada bagian kedua dan terakhir dari tutorial ini. <br><br>  Selamat telah menyelesaikan seri tutorial ini!  Ketika datang untuk membandingkan sudut dan posisi, semuanya menjadi sangat rumit, tetapi kami selamat dari ini dan sekarang kami memiliki sistem kait-kucing dan tali yang indah yang dapat berakhir pada objek dalam permainan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5f/69a/cbe/b5f69acbefc9de390ff25f0fbc4cbe10.png"></div><br>  Tahukah Anda bahwa tim pengembangan Persatuan kami telah menulis buku?  Jika tidak, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Unity Games By Tutorials</a> .  Game ini akan mengajarkan Anda cara membuat empat game yang sudah jadi dari awal: <br><br><ul><li>  Penembak dua tongkat </li><li>  Penembak orang pertama </li><li>  Game menara pertahanan (dengan dukungan VR!) </li><li>  Platformer 2D </li></ul><br>  Setelah membaca buku ini, Anda akan belajar cara membuat game sendiri untuk Windows, macOS, iOS, dan platform lainnya! <br><br>  Buku ini ditujukan untuk pemula dan mereka yang ingin meningkatkan keterampilan Persatuan mereka ke tingkat profesional.  Untuk menguasai buku ini, Anda harus memiliki pengalaman pemrograman (dalam bahasa apa pun). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id415217/">https://habr.com/ru/post/id415217/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id415207/index.html">Saat surga kehilangan kesempurnaan</a></li>
<li><a href="../id415209/index.html">"Saya perlu menjaga kamar kosong": munculnya pekerjaan yang tidak berarti</a></li>
<li><a href="../id415211/index.html">Bimasakti menyembunyikan puluhan ribu lubang hitam</a></li>
<li><a href="../id415213/index.html">Pemilu tidak bekerja sama sekali; matematika harus disalahkan</a></li>
<li><a href="../id415215/index.html">University of Michigan Memperkenalkan Komputer Terkecil di Dunia</a></li>
<li><a href="../id415219/index.html">Bagaimana saya menerima tawaran dari penerbit asing terkenal untuk menjadi penulis kursus online</a></li>
<li><a href="../id415221/index.html">Minggu Keamanan 23: 50 Miliar Perangkat IoT</a></li>
<li><a href="../id415223/index.html">Saluran penjualan</a></li>
<li><a href="../id415227/index.html">Ekosistem pembangunan pada tahun 2018: apa yang hidup programmer di Rusia dan di dunia</a></li>
<li><a href="../id415229/index.html">DevTube - Aggregator Video Open Source Baru untuk Pengembang</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>