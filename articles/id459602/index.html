<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🚀 🧖🏻 🈂️ Kami menanamkan Lua interpreter dalam proyek untuk mikrokontroler (stm32) ⚾️ 🕺🏻 👨🏼‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam aplikasi yang cukup besar, bagian penting dari proyek ini adalah logika bisnis. Lebih mudah untuk debug bagian ini dari program di komputer, dan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami menanamkan Lua interpreter dalam proyek untuk mikrokontroler (stm32)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459602/"><img src="https://habrastorage.org/webt/p6/9j/kz/p69jkzome873c4rbil8fftedrxs.png"><br><br>  Dalam aplikasi yang cukup besar, bagian penting dari proyek ini adalah logika bisnis.  Lebih mudah untuk debug bagian ini dari program di komputer, dan kemudian menanamkannya dalam proyek untuk mikrokontroler, berharap bahwa bagian ini akan dieksekusi persis seperti yang dimaksudkan tanpa debugging (kasus ideal). <br><br>  Karena sebagian besar program untuk mikrokontroler ditulis dalam C / C ++, untuk tujuan ini mereka biasanya menggunakan kelas abstrak yang menyediakan antarmuka ke entitas tingkat rendah (jika proyek ditulis hanya menggunakan C, struktur fungsi pointer sering digunakan).  Pendekatan ini memberikan tingkat abstraksi yang diperlukan pada setrika, namun penuh dengan kebutuhan untuk kompilasi ulang proyek secara konstan, diikuti dengan pemrograman memori non-volatile dari mikrokontroler dengan file <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">firmware</a> biner yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">besar</a> . <br><br>  Namun, ada cara lain - menggunakan bahasa skrip yang memungkinkan Anda untuk men-debug logika bisnis secara real time pada perangkat itu sendiri atau memuat skrip kerja langsung dari memori eksternal, tanpa menyertakan kode ini dalam firmware mikrokontroler. <br><br>  Saya memilih Lua sebagai bahasa scripting. <a name="habracut"></a><br><br><h2>  Kenapa Lua? </h2><br>  Ada beberapa bahasa skrip yang dapat Anda sematkan dalam proyek untuk mikrokontroler.  Beberapa BASIC-like sederhana, PyMite, Pawn ... Masing-masing memiliki pro dan kontra, sebuah diskusi yang tidak termasuk dalam daftar masalah yang dibahas dalam artikel ini. <br><br>  Secara singkat tentang apa yang baik khususnya lua - dapat ditemukan dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Lua dalam 60 menit</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"</a>  Artikel ini banyak menginspirasi saya dan, untuk studi yang lebih rinci tentang masalah ini, saya membaca buku panduan resmi dari penulis bahasa Robert Jeruzalimsky " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Programming in Lua</a> " (tersedia dalam terjemahan resmi Rusia). <br><br>  Saya juga ingin menyebutkan proyek eLua.  Dalam kasus saya, saya sudah memiliki lapisan tingkat rendah perangkat lunak yang siap pakai untuk berinteraksi dengan kedua periferal mikrokontroler dan periferal lain yang diperlukan yang terdapat di papan perangkat.  Oleh karena itu, saya belum mempertimbangkan proyek ini (karena diakui memberikan lapisan untuk menghubungkan inti Lua dengan periferal mikrokontroler). <br><br><h2>  Tentang proyek di mana Lua akan tertanam </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Secara tradisional</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek kotak pasir</a> saya akan digunakan sebagai kualitas bidang untuk eksperimen (tautan ke komit dengan lua yang sudah terintegrasi dengan semua perbaikan yang diperlukan yang dijelaskan di bawah). <br><br>  Proyek ini didasarkan pada mikrokontroler stm32f405rgt6 dengan 1 MB non-volatile dan 192 KB RAM (2 blok yang lebih tua dengan total kapasitas 128 KB saat ini digunakan). <br><br>  Proyek ini memiliki sistem operasi real-time FreeRTOS untuk mendukung infrastruktur perangkat keras.  Semua memori untuk tugas, semafor, dan objek FreeRTOS lainnya dialokasikan secara statis pada tahap penautan (terletak di area .bss RAM).  Semua entitas FreeRTOS (semaphore, antrian, tumpukan tugas, dll.) Adalah bagian dari objek global di area pribadi kelas mereka.  Namun, tumpukan FreeRTOS masih dialokasikan untuk mendukung fungsi <i>malloc</i> , <i>bebas</i> , <i>calloc</i> (diperlukan untuk fungsi seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">printf</a> ) yang didefinisikan ulang untuk bekerja dengannya.  Ada API yang dinaikkan untuk bekerja dengan kartu MicroSD (FatFS), serta men-debug UART (115200, 8N1). <br><br><h2>  Tentang logika menggunakan Lua sebagai bagian dari proyek </h2><br>  Untuk keperluan debugging business logic, diasumsikan bahwa perintah akan dikirim melalui UART, dikemas (sebagai objek terpisah) ke dalam garis jadi (diakhiri dengan karakter "\ n" + 0-terminator) dan dikirim ke mesin lua.  Jika eksekusi tidak berhasil, output melalui printf (karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebelumnya terlibat</a> dalam proyek).  Ketika logika debugged, dimungkinkan untuk mengunduh file logika bisnis akhir dari file dari kartu microSD (tidak termasuk dalam materi artikel ini).  Juga, untuk keperluan debug Lua, mesin akan dieksekusi di dalam utas FreeRTOS yang terpisah (di masa depan, utas terpisah akan dialokasikan untuk setiap skrip logika bisnis yang di-debug di mana ia akan dieksekusi dengan lingkungannya). <br><br><h2>  Pencantuman lua submodule dalam proyek </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cermin resmi proyek di github</a> akan digunakan sebagai sumber perpustakaan lua (karena proyek saya juga diposting di sana. Anda dapat menggunakan sumber langsung dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs resmi</a> ).  Karena proyek memiliki sistem yang mapan untuk mengumpulkan submodul sebagai bagian dari proyek, CMakeLists individual untuk masing-masing submodule, saya membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">submodule terpisah</a> di mana saya memasukkan fork ini dan CMakeLists untuk mempertahankan gaya build tunggal. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CMakeLists</a> membangun sumber repositori lua sebagai perpustakaan statis dengan flag kompilasi submodule berikut (diambil dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">file konfigurasi submodule</a> di proyek utama): <br><br><pre><code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(C_COMPILER_FLAGS <span class="hljs-string"><span class="hljs-string">"-std=gnu99;-fshort-enums;-fno-exceptions;-Wno-type-limits;-ffunction-sections;-fdata-sections;"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(MODULE_LUA_COMP_FLAGS <span class="hljs-string"><span class="hljs-string">"-O0;-g3;${C_COMPILER_FLAGS}"</span></span></code> </pre> <br>  Dan bendera spesifikasi prosesor yang digunakan (diatur dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">root CMakeLists</a> ): <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(HARDWARE_FLAGS -mthumb; -mcpu=cortex-m4; -mfloat-abi=hard; -mfpu=fpv4-sp-d16;)</code> </pre> <br>  Penting untuk mencatat perlunya CMakeLists root untuk menentukan definisi yang memungkinkan untuk tidak menggunakan nilai ganda (karena mikrokontroler tidak memiliki dukungan perangkat keras untuk ganda. Hanya float): <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">add_definitions</span></span>(-DLUA_32BITS)</code> </pre> <br>  Yah, itu tetap hanya untuk menginformasikan linker tentang perlunya merakit perpustakaan ini dan memasukkan hasilnya dalam tata letak tugas akhir: <br><br><div class="spoiler">  <b class="spoiler_title">CMakeLists merencanakan untuk menghubungkan proyek dengan perpustakaan lua</b> <div class="spoiler_text"><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">add_subdirectory</span></span>(<span class="hljs-variable"><span class="hljs-variable">${CMAKE_SOURCE_DIR}</span></span>/bsp/submodules/module_lua) ... <span class="hljs-keyword"><span class="hljs-keyword">target_link_libraries</span></span>(<span class="hljs-variable"><span class="hljs-variable">${PROJECT_NAME}</span></span>.elf PUBLIC <span class="hljs-comment"><span class="hljs-comment"># -Wl,--start-group       #      . #  Lua    ,      #  . "-Wl,--start-group" ..._... MODULE_LUA ..._... "-Wl,--end-group")</span></span></code> </pre> </div></div><br><h2>  Menentukan fungsi untuk bekerja dengan memori </h2><br>  Karena Lua sendiri tidak berurusan dengan memori, tanggung jawab ini ditransfer ke pengguna.  Namun, ketika menggunakan pustaka <i>lauxlib yang</i> dibundel dan fungsi <i>luaL_newstate</i> darinya, fungsi <i>l_alloc terikat</i> sebagai sistem memori.  Ini didefinisikan sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">l_alloc</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ud, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nsize)</span></span></span><span class="hljs-function"> </span></span>{ (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)ud; (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)osize; <span class="hljs-comment"><span class="hljs-comment">/* not used */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nsize == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(ptr); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">realloc</span></span>(ptr, nsize); }</code> </pre> <br>  Seperti yang disebutkan di awal artikel, proyek ini sudah memiliki fungsi <i>malloc</i> dan <i>bebas</i> , tetapi tidak ada fungsi <i>realokasi</i> .  Kami harus memperbaikinya. <br><br>  Dalam mekanisme standar untuk bekerja dengan tumpukan FreeRTOS, file heap_4.c yang digunakan dalam proyek tidak memiliki fungsi untuk mengubah ukuran blok memori yang dialokasikan sebelumnya.  Dalam hal ini, perlu untuk membuat implementasinya atas dasar <i>malloc</i> dan <i>gratis</i> . <br><br>  Karena di masa depan dimungkinkan untuk mengubah skema alokasi memori (menggunakan file heap_x.c lain), diputuskan untuk tidak menggunakan interior dari skema saat ini (heap_4.c), tetapi untuk membuat tambahan tingkat yang lebih tinggi.  Meski kurang efektif. <br><br>  Penting untuk dicatat bahwa metode <i>realloc</i> tidak hanya menghapus blok lama (jika ada) dan membuat yang baru, tetapi juga memindahkan data dari blok lama ke yang baru.  Selain itu, jika blok lama memiliki lebih banyak data daripada yang baru, yang baru diisi dengan yang lama hingga batasnya, dan data yang tersisa dibuang. <br><br>  Jika fakta ini tidak diperhitungkan, maka mesin Anda akan dapat menjalankan skrip seperti itu tiga kali dari baris " <i>a = 3 \ n</i> ", setelah itu akan jatuh ke dalam kesalahan yang sulit.  Masalahnya dapat dipecahkan setelah mempelajari gambar residual register di penangan kesalahan yang keras, dari mana akan mungkin untuk mengetahui bahwa kecelakaan itu terjadi setelah mencoba memperluas tabel dalam isi kode penerjemah dan perpustakaannya.  Jika Anda memanggil skrip seperti " <i>cetak 'tes'</i> ", maka perilaku akan berubah tergantung pada bagaimana file firmware dirakit (dengan kata lain, perilaku tersebut tidak terdefinisi). <br><br>  Untuk menyalin data dari blok lama ke yang baru, kita perlu mengetahui ukuran blok yang lama.  FreeRTOS heap_4.c (seperti file lain yang menyediakan metode penanganan tumpukan) tidak menyediakan API untuk ini.  Karena itu, Anda harus menyelesaikannya.  Sebagai dasar, saya mengambil fungsi <i>vPortFree</i> dan memotong fungsinya ke bentuk berikut: <br><br><div class="spoiler">  <b class="spoiler_title">Kode Fungsi VPortGetSizeBlock</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vPortGetSizeBlock</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *puc = (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *)pv; BlockLink_t *pxLink; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pv != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { puc -= xHeapStructSize; pxLink = (BlockLink_t *)puc; configASSERT((pxLink-&gt;xBlockSize &amp; xBlockAllocatedBit) != <span class="hljs-number"><span class="hljs-number">0</span></span>); configASSERT(pxLink-&gt;pxNextFreeBlock == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pxLink-&gt;xBlockSize &amp; ~xBlockAllocatedBit; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> </div></div><br>  Sekarang kecil, tulis <i>realloc</i> berdasarkan <i>malloc</i> , <i>gratis</i> , dan <i>vPortGetSizeBlock</i> : <br><br><div class="spoiler">  <b class="spoiler_title">Realloc kode implementasi berdasarkan pada malloc, gratis, dan vPortGetSizeBlock</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">realloc</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> new_size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptr == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(new_size); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* p = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(new_size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> old_size = vPortGetSizeBlock(ptr); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> cpy_len = (new_size &lt; old_size)?new_size:old_size; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(p, ptr, cpy_len); <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(ptr); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; }</code> </pre> </div></div><br><h2>  Tambahkan dukungan untuk bekerja dengan stdout </h2><br>  Sebagaimana diketahui dari deskripsi resmi, penerjemah lua itu sendiri tidak dapat bekerja dengan I / O.  Untuk keperluan ini, salah satu perpustakaan standar terhubung.  Untuk output, ia menggunakan aliran <i>stdout</i> .  Fungsi <i>luaopen_io</i> dari perpustakaan standar bertanggung jawab untuk menghubungkan ke aliran.  Untuk mendukung bekerja dengan <i>stdout</i> (tidak seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">printf</a> ), Anda harus mengganti fungsi <i>fwrite</i> .  Saya mendefinisikan ulang berdasarkan fungsi yang dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Fungsi penulisan</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> fwrite(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *buf, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> count, FILE *stream) { stream = stream; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> len = size * count; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *s = <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(buf); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_write_char((s[i])) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> len; }</code> </pre> </div></div><br>  Tanpa definisinya, fungsi <i>cetak</i> di lua akan berhasil dijalankan, tetapi tidak akan ada keluaran.  Selain itu, tidak akan ada kesalahan pada tumpukan Lua dari mesin (karena secara formal fungsi ini dijalankan dengan sukses). <br><br>  Selain fungsi ini, kita akan memerlukan fungsi <i>fflush</i> (untuk mode interaktif berfungsi, yang akan <i>dibahas</i> nanti).  Karena fungsi ini tidak dapat ditimpa, Anda harus menamainya sedikit berbeda.  Fungsi ini merupakan versi <i>singkat dari</i> fungsi <i>fwrite</i> dan dimaksudkan untuk mengirim apa yang sekarang ada di buffer dengan pembersihan berikutnya (tanpa transfer carriage tambahan). <br><br><div class="spoiler">  <b class="spoiler_title">Fungsi Mc_fflush</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mc_fflush</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> len = buf_p; buf_p = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (uart_1.tx(tx_buf, len, <span class="hljs-number"><span class="hljs-number">100</span></span>) != mc_interfaces::res::ok) { errno = EIO; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br></div></div><br><h2>  Mengambil string dari port serial </h2><br>  Untuk mendapatkan string untuk mesin lua, saya memutuskan untuk menulis kelas terminal-uart sederhana, yang: <br><br><ul><li>  menerima data pada port serial byte-by-byte (in interrupt); </li><li>  menambahkan byte yang diterima ke antrian, tempat aliran menerimanya dari; </li><li>  dalam aliran byte, jika ini bukan umpan baris, dikirim kembali dalam bentuk yang datangnya; </li><li>  jika umpan baris telah tiba (' <i>\ r</i> '), maka 2 byte dari carriage return terminal dikirim (" <i>\ n \ r</i> "); </li><li>  setelah mengirim respons, pawang byte yang tiba (objek tata letak baris) dipanggil; </li><li>  mengontrol penekanan tombol karakter hapus (untuk menghindari penghapusan karakter layanan dari jendela terminal); </li></ul><br>  Tautan ke sumber: <br><br><ul><li>  Antarmuka kelas UART ada di <a href="">sini</a> ; </li><li>  Kelas dasar UART ada di <a href="">sini</a> dan di <a href="">sini</a> ; </li><li>  kelas uart_terminal di <a href="">sini</a> dan di <a href="">sini</a> ; </li><li>  membuat objek kelas sebagai bagian dari proyek di <a href="">sini</a> . </li></ul><br>  Selain itu, saya perhatikan bahwa agar objek ini berfungsi dengan baik, Anda perlu menetapkan prioritas untuk gangguan UART dalam rentang yang diizinkan untuk bekerja dengan fungsi FreeRTOS dari interupsi.  Jika tidak, Anda bisa mendapatkan kesalahan sulit yang sulit di-debug.  Dalam contoh saat ini, opsi berikut untuk interupsi diatur dalam file <a href="">FreeRTOSConfig.h</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Pengaturan di FreeRTOSConfig.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> configPRIO_BITS 4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> configKERNEL_INTERRUPT_PRIORITY 0XF0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   FreeRTOS API   //   0x8 - 0xF. #define configMAX_SYSCALL_INTERRUPT_PRIORITY 0x80</span></span></span></span></code> </pre> </div></div><br>  Dalam proyek itu sendiri, objek class <i>nvic</i> menetapkan prioritas interrupt 0x9, yang termasuk dalam rentang yang valid (class nvic dijelaskan di <a href="">sini</a> dan di <a href="">sini</a> ). <br><br><h2>  Formasi string untuk mesin Lua </h2><br>  Bytes yang diterima dari objek uart_terminal ditransfer ke instance dari serial_cli kelas sederhana, yang menyediakan antarmuka minimal untuk mengedit string dan mentransfernya langsung ke utas di mana mesin lua dieksekusi (dengan memanggil fungsi callback).  Setelah menerima karakter '\ r', fungsi panggilan balik dipanggil.  Fungsi ini harus menyalin garis ke dirinya sendiri dan "melepaskan" kontrol (karena penerimaan byte baru diblokir selama panggilan. Ini bukan masalah dengan aliran diprioritaskan dengan benar dan kecepatan UART yang cukup rendah). <br><br>  Tautan ke sumber: <br><br><ul><li>  file deskripsi serial_cli di <a href="">sini</a> dan di <a href="">sini</a> ; </li><li>  membuat objek kelas sebagai bagian dari proyek di <a href="">sini</a> . </li></ul><br>  Penting untuk dicatat bahwa kelas ini menganggap string yang lebih panjang dari 255 karakter tidak valid dan membuangnya.  Ini disengaja, karena penerjemah lua memungkinkan Anda untuk memasukkan konstruk baris demi baris, menunggu akhir blok. <br><br><h2>  Mengirimkan string ke juru bahasa Lua dan pelaksanaannya </h2><br>  Penerjemah Lua itu sendiri tidak tahu bagaimana menerima kode blok baris demi baris, dan kemudian menjalankan seluruh blok itu sendiri.  Namun, jika Anda menginstal Lua pada komputer dan menjalankan interpreter dalam mode interaktif, kita dapat melihat bahwa eksekusi dilakukan baris demi baris dengan notasi yang sesuai saat Anda mengetik, bahwa blok belum selesai.  Karena mode interaktif adalah apa yang disediakan dalam paket standar, kita dapat melihat kodenya.  Itu terletak di file <a href="">lua.c.</a>  Kami tertarik pada fungsi <i>doREPL</i> dan semua yang digunakannya.  Agar tidak muncul dengan sepeda, untuk mendapatkan fungsi mode interaktif dalam proyek, saya membuat port kode ini di kelas yang terpisah, yang saya beri nama <i>lua_repl</i> dengan nama fungsi asli, yang menggunakan printf untuk menampilkan informasi ke konsol dan memiliki metode <i>add_lua_string</i> publik untuk menambahkan baris yang diterima dari objek kelas. serial_cli dijelaskan di atas. <br><br>  Referensi: <br><br><ul><li>  deskripsi kelas lua_repl di <a href="">sini</a> ; </li><li>  kode di <a href="">sini</a> , di <a href="">sini</a> dan di <a href="">sini</a> ; </li></ul><br>  Kelas dibuat sesuai dengan pola singleton Myers, karena tidak perlu memberikan beberapa mode interaktif dalam perangkat yang sama.  Objek kelas lua_repl menerima data dari objek kelas serial_cli di <a href="">sini</a> . <br><br>  Karena proyek sudah memiliki sistem terpadu untuk menginisialisasi dan melayani objek global, penunjuk ke objek kelas lua_repl diteruskan ke objek <a href="">pemain</a> kelas global <a href="">:: pangkalan di</a> <a href="">sini</a> .  Dalam metode <i>awal</i> objek <a href="">pemain</a> kelas <a href="">:: basis</a> (dideklarasikan di <a href="">sini</a> . Disebut juga dari main), metode <i>init</i> dari objek kelas lua_repl dipanggil dengan prioritas tugas FreeRTOS 3 (dalam proyek, Anda dapat menetapkan prioritas tugas dari 1 hingga 4. Di mana 1 Apakah prioritas terendah, dan 4 adalah yang tertinggi).  Setelah inisialisasi berhasil, kelas global memulai penjadwal FreeRTOS dan mode interaktif memulai kerjanya. <br><br><h2>  Masalah Porting </h2><br>  Di bawah ini adalah daftar masalah yang saya temui selama port Lua dari mesin. <br><br><h4>  2-3 skrip baris tunggal penugasan variabel dieksekusi, maka semuanya jatuh ke dalam kesalahan yang berat </h4><br>  Masalahnya adalah dengan metode realokasi.  Diperlukan tidak hanya untuk memilih kembali blok, tetapi juga untuk menyalin konten yang lama (seperti dijelaskan di atas). <br><br><h4>  Saat mencoba mencetak nilai, penerjemah jatuh ke kesalahan yang sulit </h4><br>  Sudah lebih sulit untuk mendeteksi masalah, tetapi pada akhirnya saya berhasil mengetahui bahwa snprintf digunakan untuk mencetak.  Karena lua menyimpan nilai dalam dobel (atau mengapung dalam kasus kami), printf (dan turunannya) dengan dukungan floating point diperlukan (saya menulis tentang seluk-beluk printf di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ). <br><br><h2>  Persyaratan untuk memori non-volatile (flash) </h2><br>  Berikut adalah beberapa pengukuran yang saya lakukan untuk menilai berapa banyak memori (flash) non-volatile perlu dialokasikan untuk mengintegrasikan mesin Lua ke dalam proyek.  Kompilasi dilakukan dengan menggunakan gcc-arm-none-eabi-8-2018-q4-major.  Versi Lua 5.4 digunakan.  Di bawah ini dalam pengukuran, frasa “tanpa Lua” berarti non-inklusi dari interpreter dan metode interaksi dengan itu dan perpustakaannya, serta objek kelas lua_repl dalam proyek.  Semua entitas tingkat rendah (termasuk penggantian untuk fungsi <i>printf</i> dan <i>fwrite</i> ) tetap ada dalam proyek.  Ukuran tumpukan FreeRTOS adalah 1024 * 25 byte.  Sisanya ditempati oleh entitas proyek global. <br><br>  Tabel ringkasan hasil adalah sebagai berikut (semua ukuran dalam byte): <br><table border="1"><tbody><tr><th>  Opsi pembuatan </th><th>  Tanpa lua </th><th>  Hanya inti </th><th>  Lua dengan perpustakaan dasar </th><th>  Lua dengan pangkalan perpustakaan, coroutine, tabel, string </th><th>  luaL_openlibs </th></tr><tr><td>  -O0 -g3 </td><td>  103028 </td><td>  220924 </td><td>  236124 </td><td>  262652 </td><td>  308372 </td></tr><tr><td>  -O1 -g3 </td><td>  74940 </td><td>  144732 </td><td>  156916 </td><td>  174452 </td><td>  213068 </td></tr><tr><td>  -Os -g0 </td><td>  71172 </td><td>  134228 </td><td>  145756 </td><td>  161428 </td><td>  198400 </td></tr></tbody></table><br><h2>  Persyaratan RAM </h2><br>  Karena konsumsi RAM sepenuhnya tergantung pada tugas, saya akan memberikan tabel ringkasan dari memori yang dikonsumsi segera setelah menyalakan mesin dengan satu set perpustakaan yang berbeda (ditampilkan oleh <i>cetakan (collectgarbage ("count") * 1024</i> perintah). <br><table border="1"><tbody><tr><td>  Komposisi </td><td>  RAM yang digunakan </td></tr><tr><td>  Lua dengan perpustakaan dasar </td><td>  4809 </td></tr><tr><td>  Lua dengan pangkalan perpustakaan, coroutine, tabel, string </td><td>  6407 </td></tr><tr><td>  luaL_openlibs </td><td>  12769 </td></tr></tbody></table><br>  Dalam hal menggunakan semua pustaka, ukuran RAM yang diperlukan meningkat secara signifikan dibandingkan dengan set sebelumnya.  Namun, penggunaannya dalam sebagian besar aplikasi tidak diperlukan. <br><br>  Selain itu, 4 kb juga dialokasikan ke tumpukan tugas, di mana mesin Lua dijalankan. <br><br><h2>  Penggunaan lebih lanjut </h2><br>  Untuk penggunaan penuh mesin dalam proyek, Anda perlu menjelaskan lebih lanjut semua antarmuka yang diperlukan oleh kode logika bisnis untuk perangkat keras atau objek layanan proyek.  Namun, ini adalah topik dari artikel terpisah. <br><br><h2>  Ringkasan </h2><br>  Artikel ini menjelaskan cara menghubungkan mesin Lua ke proyek untuk mikrokontroler, serta meluncurkan interpreter interaktif penuh yang memungkinkan Anda untuk bereksperimen dengan logika bisnis langsung dari baris perintah terminal.  Selain itu, persyaratan untuk perangkat keras mikrokontroler dipertimbangkan untuk konfigurasi yang berbeda dari mesin Lua. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459602/">https://habr.com/ru/post/id459602/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459590/index.html">Program afiliasi open source terdesentralisasi di blockchain Waves</a></li>
<li><a href="../id459592/index.html">Tiga tips manajemen waktu untuk mereka yang telah mencoba segalanya.</a></li>
<li><a href="../id459594/index.html">Baca di antara catatan: sistem transfer data di dalam musik</a></li>
<li><a href="../id459596/index.html">iOS Digest No. 9 (28 Juni - 11 Juli)</a></li>
<li><a href="../id459598/index.html">SELinux Pertanyaan yang Sering Diajukan (FAQ)</a></li>
<li><a href="../id459604/index.html">Telegram - bot | Menu lengkap</a></li>
<li><a href="../id459606/index.html">Jaringan sosial terdistribusi</a></li>
<li><a href="../id459610/index.html">Router berbahaya ini: peretasan paling besar dari peralatan jaringan baru-baru ini dan metode perlindungan</a></li>
<li><a href="../id459612/index.html">Bagaimana Qualcomm merobek industri ponsel selama hampir 20 tahun berturut-turut</a></li>
<li><a href="../id459614/index.html">Bebek robot mengaduk sawah</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>