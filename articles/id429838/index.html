<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🚒 ⭐️ 📭 Panduan JavaScript Bagian 3: Variabel, Tipe Data, Ekspresi, Objek 👨🏿‍🌾 🤜 🧑🏿‍🤝‍🧑🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini, di bagian ketiga dari terjemahan manual JavaScript, kita akan berbicara tentang berbagai cara mendeklarasikan variabel, tentang tipe data, t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Panduan JavaScript Bagian 3: Variabel, Tipe Data, Ekspresi, Objek</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/429838/">  Hari ini, di bagian ketiga dari terjemahan manual JavaScript, kita akan berbicara tentang berbagai cara mendeklarasikan variabel, tentang tipe data, tentang ekspresi dan tentang fitur bekerja dengan objek. <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1: program pertama, fitur bahasa, standar</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2: gaya kode dan struktur program</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3: variabel, tipe data, ekspresi, objek</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 4: fitur</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 5: array dan loop</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 6: pengecualian, titik koma, literal wildcard</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 7: mode ketat, kata kunci ini, acara, modul, perhitungan matematis</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 8: Tinjauan Umum Fitur ES6</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 9: Gambaran Umum Standar ES7, ES8, dan ES9</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/jf/eo/1s/jfeo1s-pygp9g5pazca5kjwvwoa.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Variabel</font> </h2><br>  Variabel adalah pengidentifikasi yang diberi nilai.  Variabel dapat diakses dalam program, bekerja dengan cara ini dengan nilai yang diberikan padanya. <br><br>  Variabel dalam JavaScript itu sendiri tidak mengandung informasi tentang jenis nilai yang akan disimpan di dalamnya.  Ini berarti bahwa dengan menulis ke variabel, misalnya, sebuah string, Anda kemudian dapat menulis angka ke dalamnya.  Operasi semacam itu tidak akan menyebabkan kesalahan dalam program.  Itulah sebabnya JavaScript kadang-kadang disebut bahasa "tidak diketik". <br><br>  Sebelum menggunakan variabel, harus dinyatakan menggunakan <code>var</code> atau <code>let</code> kata kunci.  Ketika datang ke konstan, kata kunci <code>const</code> digunakan.  Mendeklarasikan variabel dan memberinya nilai tertentu dimungkinkan tanpa menggunakan kata kunci ini, tetapi tidak disarankan. <br><br><h3>  <font color="#3AC1EF">▍ Kata kunci var</font> </h3><br>  Sebelum standar ES2015, menggunakan kata kunci <code>var</code> adalah satu-satunya cara untuk mendeklarasikan variabel. <br><br><pre> <code class="plaintext hljs">var a = 0</code> </pre> <br>  Jika <code>var</code> dihilangkan dalam konstruk ini, nilai akan ditugaskan ke variabel yang tidak dideklarasikan.  Hasil operasi ini tergantung pada mode di mana program sedang berjalan. <br><br>  Jadi, jika yang disebut mode ketat diaktifkan, ini akan menyebabkan kesalahan.  Jika mode ketat tidak diaktifkan, deklarasi variabel implisit akan terjadi dan akan ditetapkan ke objek global.  Secara khusus, ini berarti bahwa variabel yang secara implisit dideklarasikan dengan cara ini dalam suatu fungsi tertentu akan tersedia bahkan setelah fungsi tersebut menyelesaikan pekerjaannya.  Biasanya, diharapkan bahwa variabel yang dideklarasikan dalam fungsi tidak "melampaui" batas mereka.  Ini terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">function notVar() { bNotVar = 1 //    } notVar() console.log(bNotVar)</code> </pre> <br>  <code>1</code> akan sampai ke konsol, biasanya tidak ada yang mengharapkan perilaku ini dari program, ekspresi <code>bNotVar = 1</code> tidak terlihat seperti upaya untuk mendeklarasikan dan menginisialisasi variabel, tetapi sebagai upaya untuk mengakses variabel yang terletak di lingkup fungsi eksternal (ini cukup normal).  Akibatnya, deklarasi implisit variabel membingungkan orang yang membaca kode dan dapat menyebabkan perilaku program yang tidak terduga.  Nanti kita akan berbicara tentang fungsi dan cakupan, untuk saat ini, selalu mencoba untuk menggunakan kata kunci khusus ketika arti dari sebuah ekspresi adalah mendeklarasikan variabel.  Jika dalam contoh ini badan fungsi ditulis ulang sebagai <code>var bNotVar = 1</code> , maka upaya untuk memulai fragmen kode di atas akan menghasilkan pesan kesalahan (dapat dilihat di konsol browser). <br><br>  Ini mungkin terlihat, misalnya, seperti ini: <code>Uncaught ReferenceError: bNotVar is not defined</code> .  Artinya adalah fakta bahwa program tidak dapat bekerja dengan variabel yang tidak ada.  Adalah jauh lebih baik, ketika Anda pertama kali memulai program, untuk melihat pesan kesalahan seperti itu daripada menulis kode yang tidak dapat dimengerti yang dapat berperilaku tak terduga. <br><br>  Jika, ketika mendeklarasikan variabel, itu tidak diinisialisasi, itu tidak diberi nilai apa pun, itu secara otomatis akan diberi nilai yang <code>undefined</code> . <br><br><pre> <code class="plaintext hljs">var a //typeof a === 'undefined'</code> </pre> <br>  Variabel yang dideklarasikan menggunakan kata kunci <code>var</code> dapat berulang kali dideklarasikan lagi dengan memberikan nilai baru kepada mereka (tetapi ini dapat membingungkan seseorang yang membaca kode). <br><br><pre> <code class="plaintext hljs">var a = 1 var a = 2</code> </pre> <br>  Anda dapat mendeklarasikan beberapa variabel dalam satu ekspresi: <br><br><pre> <code class="plaintext hljs">var a = 1, b = 2</code> </pre> <br>  Ruang lingkup variabel disebut ruang lingkup program di mana variabel ini dapat diakses (terlihat). <br><br>  Variabel yang diinisialisasi dengan kata kunci <code>var</code> luar fungsi ditugaskan ke objek global.  Ini memiliki cakupan global dan dapat diakses dari mana saja dalam program ini.  Jika suatu variabel dideklarasikan menggunakan kata kunci <code>var</code> di dalam suatu fungsi, maka itu hanya terlihat di dalam fungsi ini, menjadi variabel lokal untuknya. <br><br>  Jika suatu variabel dideklarasikan dalam suatu fungsi menggunakan <code>var</code> yang namanya cocok dengan nama variabel tertentu dari lingkup global, itu akan "menimpa" variabel global.  Artinya, ketika mengakses variabel seperti itu di dalam fungsi, ia akan menggunakan versi lokalnya. <br><br>  Penting untuk dipahami bahwa blok (area kode yang dilampirkan dalam kurung) tidak membuat area visibilitas baru.  Lingkup baru dibuat saat fungsi dipanggil.  Kata kunci <code>var</code> memiliki apa yang disebut lingkup fungsional, bukan satu blok. <br><br>  Jika variabel dideklarasikan dalam kode fungsi, itu terlihat oleh seluruh kode fungsi.  Bahkan jika suatu variabel dideklarasikan dengan <code>var</code> di akhir kode fungsi, Anda dapat merujuknya di awal kode, karena mekanisme meningkatkan variabel (mengangkat) berfungsi di JavaScript.  Mekanisme ini “meningkatkan” deklarasi variabel, tetapi bukan operasi inisialisasi mereka.  Ini bisa menjadi sumber kebingungan, jadi buat aturan untuk mendeklarasikan variabel di awal fungsi. <br><br><h3>  <font color="#3AC1EF">▍ biarkan kata kunci</font> </h3><br>  Kata kunci let muncul di ES2015, yang, secara sederhana, dapat disebut versi "block" <code>var</code> .  Cakupan variabel yang dideklarasikan menggunakan kata kunci <code>let</code> terbatas pada blok, operator, atau ekspresi yang dideklarasikan, serta blok bersarang. <br><br>  Jika kata "biarkan" itu sendiri tampaknya tidak terlalu jelas, orang dapat membayangkan bahwa kata "biarkan" digunakan sebagai gantinya.  Maka ungkapan <code>let color = 'red'</code> dapat diterjemahkan ke dalam bahasa Inggris seperti ini: "biarkan warna menjadi merah", dan ke dalam bahasa Rusia seperti ini: "biarkan warna menjadi merah". <br><br>  Dengan menggunakan kata kunci <code>let</code> , Anda dapat menghilangkan ambiguitas yang terkait dengan kata kunci <code>var</code> (misalnya, Anda tidak akan dapat mendeklarasikan variabel yang sama dua kali dengan <code>let</code> ).  Menggunakan <code>let</code> luar fungsi, katakan ketika menginisialisasi loop, tidak membuat variabel global. <br><br>  Misalnya, kode seperti itu akan menyebabkan kesalahan: <br><br><pre> <code class="plaintext hljs">for (let i = 0; i &lt; 5; i++) {   console.log(i) } console.log(i)</code> </pre> <br>  Jika, ketika loop diinisialisasi, penghitung <code>i</code> akan dinyatakan menggunakan kata kunci <code>var</code> , maka <code>i</code> akan tersedia di luar loop setelah selesai. <br><br>  Saat ini, ketika mengembangkan program JS berdasarkan standar modern, Anda dapat sepenuhnya meninggalkan <code>var</code> dan hanya menggunakan kata kunci <code>let</code> dan <code>const</code> . <br><br><h3>  <font color="#3AC1EF">▍Kata kunci kata sandi</font> </h3><br>  Variabel dideklarasikan menggunakan <code>var</code> atau <code>let</code> kata kunci dapat ditimpa.  Jika <code>const</code> digunakan sebagai pengganti kata kunci ini, maka Anda tidak dapat menetapkan nilai baru ke konstanta yang dideklarasikan dan diinisialisasi dengan bantuannya. <br><br><pre> <code class="plaintext hljs">const a = 'test'</code> </pre> <br>  Dalam contoh ini, konstanta <code>a</code> tidak dapat diberi nilai baru.  Tetapi harus dicatat bahwa jika <code>a</code> bukan nilai primitif, seperti angka, tetapi objek, menggunakan kata kunci <code>const</code> tidak melindungi objek ini dari perubahan. <br><br>  Ketika mereka mengatakan bahwa suatu objek ditulis ke dalam variabel, mereka sebenarnya berarti bahwa variabel mengacu pada objek.  Tautan ini tidak dapat diubah, dan objek yang dituju oleh tautan dapat diubah. <br><br>  Kata kunci <code>const</code> tidak membuat objek berubah.  Ini hanya melindungi terhadap perubahan pada referensi yang ditulis dalam konstanta yang sesuai.  Begini tampilannya: <br><br><pre> <code class="plaintext hljs">const obj = {} console.log(obj.a) obj.a = 1 // console.log(obj.a) //obj = 5 // </code> </pre> <br>  Dalam konstanta <code>obj</code> , saat inisialisasi, objek kosong baru ditulis.  Mencoba mengakses propertinya <code>a</code> , yang tidak ada, tidak menyebabkan kesalahan.  Konsol <code>undefined</code> .  Setelah itu, kami menambahkan properti baru ke objek dan sekali lagi mencoba mengaksesnya.  Kali ini nilai properti ini - <code>1</code> - sampai ke konsol.  Jika Anda menghapus komentar pada baris terakhir dari contoh, upaya untuk mengeksekusi kode ini akan menyebabkan kesalahan. <br><br>  Kata kunci <code>const</code> sangat mirip dengan <code>let</code> , khususnya, ia memiliki ruang lingkup blok. <br><br>  Dalam kondisi modern, sangat diterima untuk menggunakan kata kunci <code>const</code> , menggunakan hanya dalam kasus-kasus khusus, untuk menyatakan semua entitas yang nilainya tidak direncanakan akan diubah.  Mengapa  Masalahnya adalah bahwa yang terbaik adalah berusaha untuk menggunakan konstruksi sesederhana mungkin yang tersedia agar tidak menyulitkan program dan menghindari kesalahan. <br><br><h2>  <font color="#3AC1EF">Tipe data</font> </h2><br>  JavaScript kadang-kadang disebut sebagai bahasa "tidak diketik", tetapi ini tidak benar.  Memang benar bahwa Anda dapat menulis nilai dari tipe yang berbeda ke dalam variabel, tetapi ada tipe data dalam JavaScript.  Secara khusus, kita berbicara tentang tipe data primitif dan objek. <br><br>  Untuk menentukan tipe data dari nilai tertentu, Anda dapat menggunakan <code>typeof</code> operator.  Ini mengembalikan string yang menunjukkan jenis operan. <br><br><h3>  <font color="#3AC1EF">▍ tipe data primitif</font> </h3><br>  Berikut adalah daftar tipe data JavaScript primitif: <br><br><ul><li>  <code>number</code> </li><li>  <code>string</code> (string) </li><li>  <code>boolean</code> (boolean) </li><li>  <code>null</code> (nilai <code>null</code> khusus) </li><li>  <code>undefined</code> (nilai spesial <code>undefined</code> ) </li><li>  <code>symbol</code> (simbol, digunakan dalam kasus khusus, muncul di ES6) </li></ul><br>  Di sini nama tipe data diberikan dalam bentuk di mana <code>typeof</code> operator mengembalikannya. <br><br>  Mari kita bicara tentang tipe data yang paling umum digunakan dari daftar ini. <br><br><h4>  Ketikkan nomor </h4><br>  Nilai <code>number</code> tipe dalam JavaScript direpresentasikan sebagai angka floating-point presisi ganda 64-bit. <br><br>  Dalam kode, literal numerik direpresentasikan sebagai bilangan bulat dan pecahan dalam sistem desimal.  Anda dapat menggunakan metode lain untuk mencatat angka.  Misalnya, jika pada awal literal numerik ada awalan <code>0x</code> - itu dianggap sebagai angka yang ditulis dalam notasi heksadesimal.  Bilangan juga dapat ditulis dalam notasi eksponensial (dalam angka-angka tersebut Anda dapat menemukan huruf <code>e</code> ). <br><br>  Berikut adalah contoh entri bilangan bulat: <br><br><pre> <code class="plaintext hljs">10 5354576767321 0xCC //  </code> </pre> <br>  Berikut adalah angka pecahan. <br><br><pre> <code class="plaintext hljs">3.14 .1234 5.2e4 //5.2 * 10^4</code> </pre> <br>  Numerik literal (perilaku ini juga merupakan karakteristik dari beberapa tipe primitif lainnya), ketika Anda mencoba mengaksesnya sebagai objek, secara otomatis, selama durasi operasi, dikonversi ke objek yang sesuai, yang disebut "pembungkus objek".  Dalam hal ini, kita berbicara tentang <code>Number</code> objek wrapper. <br><br>  Di sini, misalnya, tampak seperti upaya untuk mengakses variabel <code>a</code> , di mana literal numerik ditulis, sebagai objek, di konsol Google Chrome. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d6/775/b97/5d6775b97a38b1ba71d05c32b212e14f.png"></div><br>  <i><font color="#999999">Tooltip Bungkus Objek Angka</font></i> <br><br>  Jika, misalnya, Anda menggunakan metode <code>toString()</code> dari objek bertipe <code>Number</code> , itu akan mengembalikan representasi string dari angka tersebut.  Itu terlihat seperti perintah yang sesuai yang dapat dieksekusi di konsol browser (dan dalam kode reguler) seperti ini: <br><br><pre> <code class="plaintext hljs">a.toString()</code> </pre> <br>  Perhatikan tanda kurung ganda setelah nama metode.  Jika Anda tidak meletakkannya, sistem tidak akan memberikan kesalahan, tetapi, bukannya output yang diharapkan, konsol akan menampilkan sesuatu yang sama sekali tidak terlihat seperti representasi string dari angka 5. <br><br>  Objek <code>Number</code> global dapat digunakan dalam bentuk konstruktor, membuat angka baru dengan bantuannya (walaupun dalam bentuk ini hampir tidak pernah digunakan), ia juga dapat digunakan sebagai entitas independen tanpa membuat instance dari itu (yaitu, beberapa angka diwakili dari itu) bantuan).  Misalnya, properti <code>Number.MAX_VALUE</code> -nya berisi nilai numerik maksimum yang dapat direpresentasikan dalam JavaScript. <br><br><h4>  Ketikkan string </h4><br>  Nilai-nilai tipe <code>string</code> adalah urutan karakter.  Nilai-nilai tersebut ditentukan sebagai string literal yang diapit dengan tanda kutip tunggal atau ganda. <br><br><pre> <code class="plaintext hljs">'A string' "Another string"</code> </pre> <br>  Nilai string dapat dibagi menjadi beberapa bagian menggunakan karakter backslash. <br><br><pre> <code class="plaintext hljs">"A \ string"</code> </pre> <br>  Sebuah string dapat berisi apa yang disebut sekuens escape yang ditafsirkan ketika string tersebut dicetak ke konsol.  Misalnya, urutan <code>\n</code> berarti karakter baris baru.  Karakter backslash juga dapat digunakan untuk menambahkan tanda kutip ke string yang terlampir dalam tanda kutip yang sama.  Melarikan karakter kutipan dengan <code>\</code> menyebabkan sistem tidak menganggapnya sebagai karakter khusus. <br><br><pre> <code class="plaintext hljs">'I\'ma developer'</code> </pre> <br>  String dapat digabungkan menggunakan operator <code>+</code> . <br><br><pre> <code class="plaintext hljs">"A " + "string"</code> </pre> <br><h4>  Templat Literal </h4><br>  ES2015 memperkenalkan apa yang disebut pola literal, atau string pola.  Mereka adalah string yang dilampirkan dalam backticks ( <code>`</code> ) dan memiliki beberapa properti menarik. <br><br><pre> <code class="plaintext hljs">`a string`</code> </pre> <br>  Misalnya, dalam literal templat, Anda bisa mengganti nilai-nilai tertentu yang merupakan hasil dari mengevaluasi ekspresi JavaScript. <br><br><pre> <code class="plaintext hljs">`a string with ${something}` `a string with ${something+somethingElse}` `a string with ${obj.something()}`</code> </pre> <br>  Menggunakan kutipan balik memudahkan untuk menulis literal string multiline: <br><br><pre> <code class="plaintext hljs">`a string with ${something}`</code> </pre> <br><h4>  Ketik boolean </h4><br>  JavaScript memiliki beberapa kata cadangan yang digunakan saat bekerja dengan nilai boolean - ini <code>true</code> (benar), dan <code>false</code> (salah).  Operasi perbandingan, seperti <code>==</code> , <code>===</code> , <code>&lt;</code> , <code>&gt;</code> , mengembalikan <code>true</code> atau <code>false</code> . <br><br>  Ekspresi logis digunakan dalam konstruksi seperti <code>if</code> dan <code>while</code> , membantu mengendalikan kemajuan suatu program. <br><br>  Perlu dicatat bahwa di mana <code>true</code> atau <code>false</code> diharapkan, Anda dapat menggunakan nilai-nilai lain yang secara otomatis dianggap oleh bahasa sebagai true (truthy) atau false (falsy). <br><br>  Secara khusus, berikut ini adalah nilai-nilai salah: <br><br><pre> <code class="plaintext hljs">0 -0 NaN undefined null '' // </code> </pre> <br>  Nilai yang tersisa benar. <br><br><h4>  Ketik nol </h4><br>  JavaScript memiliki nilai <code>null</code> khusus yang menunjukkan tidak adanya nilai.  Makna serupa digunakan dalam bahasa lain. <br><br><h4>  Ketik tidak terdefinisi </h4><br>  Nilai yang <code>undefined</code> ditulis ke variabel tertentu menunjukkan bahwa variabel ini tidak diinisialisasi dan tidak ada nilai untuk itu. <br><br>  Nilai ini secara otomatis dikembalikan dari fungsi yang hasilnya tidak dikembalikan secara eksplisit menggunakan kata kunci <code>return</code> .  Jika fungsi menerima parameter yang, ketika dipanggil, tidak ditentukan, itu juga diatur ke <code>undefined</code> . <br><br>  Untuk memeriksa nilai <code>undefined</code> , Anda dapat menggunakan konstruksi berikut. <br><br><pre> <code class="plaintext hljs">typeof variable === 'undefined'</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Objek</font> </h3><br>  Semua nilai yang tidak primitif memiliki tipe objek.  Kita berbicara tentang fungsi, array, tentang apa yang kita sebut "objek", dan tentang banyak entitas lainnya.  Semua tipe data ini didasarkan pada tipe <code>object</code> , dan meskipun mereka berbeda dalam banyak hal satu sama lain, mereka memiliki banyak kesamaan. <br><br><h2>  <font color="#3AC1EF">Ekspresi</font> </h2><br>  Ekspresi adalah potongan-potongan kode yang dapat diproses dan diperoleh berdasarkan perhitungan yang dilakukan nilai tertentu.  JavaScript memiliki beberapa kategori ekspresi. <br><br><h4>  Ekspresi aritmatika </h4><br>  Ekspresi yang hasil perhitungannya termasuk dalam kategori ini. <br><br><pre> <code class="plaintext hljs">1 / 2 i++ i -= 2 i * 2</code> </pre> <br><h4>  Ekspresi string </h4><br>  Hasil mengevaluasi ekspresi seperti itu adalah string. <br><br><pre> <code class="plaintext hljs">'A ' + 'string' 'A ' += 'string'</code> </pre> <br><h4>  Ekspresi primer </h4><br>  Literal, konstanta, dan referensi untuk pengidentifikasi termasuk dalam kategori ini. <br><br><pre> <code class="plaintext hljs">2 0.02 'something' true false this // ,     undefined i // i    </code> </pre> <br>  Ini juga mencakup beberapa kata kunci dan konstruksi JavaScript. <br><br><pre> <code class="plaintext hljs">function class function* // yield // /   yield* //     async function* //   await //     /pattern/i //  () //</code> </pre> <br><h4>  Ekspresi Inisialisasi Array dan Objek </h4><br><pre> <code class="plaintext hljs">[] //  {} //  [1,2,3] {a: 1, b: 2} {a: {b: 1}}</code> </pre> <br><h4>  Ekspresi logis </h4><br>  Dalam ekspresi logis, operator logis digunakan, hasil perhitungannya adalah nilai logis. <br><br><pre> <code class="plaintext hljs">a &amp;&amp; b a || b !a</code> </pre> <br><h4>  Ekspresi Akses Properti </h4><br>  Ekspresi ini memungkinkan Anda untuk mengakses properti dan metode objek. <br><br><pre> <code class="plaintext hljs">object.property //   ( )  object[property] object['property']</code> </pre> <br><h4>  Ekspresi Penciptaan Objek </h4><br><pre> <code class="plaintext hljs">new object() new a(1) new MyRectangle('name', 2, {a: 4})</code> </pre> <br><h4>  Ekspresi pernyataan fungsi </h4><br><pre> <code class="plaintext hljs">function() {} function(a, b) { return a * b } (a, b) =&gt; a * b a =&gt; a * 2 () =&gt; { return 2 }</code> </pre> <br><h4>  Panggil ekspresi </h4><br>  Ekspresi semacam itu digunakan untuk memanggil fungsi atau metode objek. <br><br><pre> <code class="plaintext hljs">ax(2) window.resize()</code> </pre> <br><h2>  <font color="#3AC1EF">Bekerja dengan benda</font> </h2><br>  Kami telah menemukan objek di atas, berbicara tentang objek literal, tentang memanggil metode mereka, tentang mengakses properti mereka.  Di sini kita berbicara tentang objek secara lebih rinci, khususnya, mempertimbangkan mekanisme pewarisan prototipe dan penggunaan kata kunci <code>class</code> . <br><br><h3>  <font color="#3AC1EF">▍ pewarisan prototipe</font> </h3><br>  JavaScript menonjol di antara bahasa pemrograman modern karena mendukung warisan prototipe.  Sebagian besar bahasa berorientasi objek menggunakan model pewarisan berbasis kelas. <br><br>  Setiap objek JavaScript memiliki properti khusus ( <code>__proto__</code> ) yang menunjuk ke objek lain yang merupakan prototipe-nya.  Objek mewarisi properti dan metode prototipe. <br><br>  Misalkan kita memiliki objek yang dibuat menggunakan objek literal. <br><br><pre> <code class="plaintext hljs">const car = {}</code> </pre> <br>  Atau kami membuat objek menggunakan konstruktor <code>Object</code> . <br><br><pre> <code class="plaintext hljs">const car = new Object()</code> </pre> <br>  Dalam setiap kasus ini, prototipe objek <code>car</code> akan menjadi <code>Object.prototype</code> . <br><br>  Jika Anda membuat larik yang juga merupakan objek, prototipenya adalah objek <code>Array.prototype</code> . <br><br><pre> <code class="plaintext hljs">const list = [] //  const list = new Array()</code> </pre> <br>  Anda dapat memverifikasi ini sebagai berikut. <br><br><pre> <code class="plaintext hljs">car.__proto__ == Object.prototype //true car.__proto__ == new Object().__proto__ //true list.__proto__ == Object.prototype //false list.__proto__ == Array.prototype //true list.__proto__ == new Array().__proto__ //true</code> </pre> <br>  Di sini kami menggunakan properti <code>__proto__</code> , itu tidak harus tersedia untuk pengembang, tetapi Anda biasanya dapat mengaksesnya.  Perlu dicatat bahwa cara yang lebih dapat diandalkan untuk mendapatkan prototipe objek adalah dengan menggunakan metode <code>getPrototypeOf()</code> dari <code>Object</code> global. <br><br><pre> <code class="plaintext hljs">Object.getPrototypeOf(new Object())</code> </pre> <br>  Semua properti dan metode prototipe dapat diakses oleh objek yang memiliki prototipe ini.  Di sini, misalnya, terlihat seperti daftar array. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d4/9e5/abf/3d49e5abf535b680cdd52d4749bbe61b.png"></div><br>  <i><font color="#999999">Petunjuk array</font></i> <br><br>  Prototipe dasar untuk semua objek adalah <code>Object.prototype</code> . <br><br><pre> <code class="plaintext hljs">Array.prototype.__proto__ == Object.prototype</code> </pre> <br>  <code>Object.prototype</code> tidak memiliki prototipe. <br><br>  Apa yang kami lihat di atas adalah contoh rantai prototipe. <br><br>  Ketika mencoba mengakses properti atau metode dari suatu objek, jika objek itu sendiri tidak memiliki properti atau metode tersebut, mereka dicari dalam prototipe, kemudian dalam prototipe prototipe, dan seterusnya, sampai yang diinginkan ditemukan, atau sampai rantai prototipe tidak akan berakhir. <br><br>  Selain membuat objek menggunakan operator <code>new</code> dan menggunakan literal objek atau literal array, Anda bisa membuat instance objek menggunakan metode <code>Object.create()</code> .  Argumen pertama yang diteruskan ke metode ini adalah objek yang akan menjadi prototipe dari objek yang dibuat menggunakannya. <br><br><pre> <code class="plaintext hljs">const car = Object.create(Object.prototype)</code> </pre> <br>  Anda dapat memeriksa apakah suatu objek merupakan bagian dari rantai prototipe objek lain menggunakan metode <code>isPrototypeOf()</code> . <br><br><pre> <code class="plaintext hljs">const list = [] Array.prototype.isPrototypeOf(list)</code> </pre> <br><h4>  Fungsi konstruktor </h4><br>  Di atas, kami membuat objek baru menggunakan fungsi konstruktor yang sudah tersedia dalam bahasa (ketika mereka dipanggil, kata kunci <code>new</code> digunakan).      .  . <br><br><pre> <code class="plaintext hljs">function Person(name) { this.name = name } Person.prototype.hello = function() { console.log(this.name) } let person = new Person('Flavio') person.hello() console.log(Person.prototype.isPrototypeOf(person))</code> </pre> <br>    -.      ,      <code>this</code>   .       <code>name</code>     ,   .      .   -    ,  <code>name</code>    ,      . <br><br>         ,        <code>name</code> ,     .  ,     ,       ,          <code>hello()</code> .   ,      <code>Person</code>     <code>hello()</code>        (       ). <br><br><h3> <font color="#3AC1EF">▍</font> </h3><br>   ES6  JavaScript     «». <br><br>    JavaScript        .      ,   JS   .      , ,  ,  « »    .  ,  ,   ,  ,    ,  . <br><br><h4>   </h4><br>     . <br><br><pre> <code class="plaintext hljs">class Person { constructor(name) {   this.name = name } hello() {   return 'Hello, I am ' + this.name + '.' } }</code> </pre> <br>    ,           <code>new ClassIdentifier()</code> . <br><br>       <code>constructor</code> ,   . <br><br>     .    <code>hello()</code> —  ,     ,    .          <code>Person</code> . <br><br><pre> <code class="plaintext hljs">const flavio = new Person('Flavio') flavio.hello()</code> </pre> <br><h4> ,    </h4><br>     . ,     ,      ,  ,    . <br><br>  ,    (  )  ,     ,    -,      . <br><br><pre> <code class="plaintext hljs">class Programmer extends Person { hello() {   return super.hello() + ' I am a programmer.' } } const flavio = new Programmer('Flavio') flavio.hello()</code> </pre> <br>    <code>hello()</code>       <code>Hello, I am Flavio. I am a programmer</code> . <br><br>       (),          . <br><br>            <code>super</code> . <br><br><h4>   </h4><br> ,   ,  ,   ,     ,     .  ( <code>static</code> )   ,    . <br><br><h4>   </h4><br>  JavaScript   ,     (, ) .    , ,   . <br><br><h4>    </h4><br>     ,     <code>get</code>  <code>set</code> .         — ,        ,    .       -,   —       . <br><br><pre> <code class="plaintext hljs">class Person {   constructor(name) {     this.userName = name   }   set name(value) {     this.userName = value   }   get name() {     return this.userName   } }</code> </pre> <br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>       ,   ,         JavaScript.      . <br><br>  <b>Pembaca yang budiman!</b>       JS,    ,          class. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id429838/">https://habr.com/ru/post/id429838/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id429826/index.html">“Baterai” yang dapat dipakai: kapasitor mikro tekstil berdasarkan PEDOT-Cl</a></li>
<li><a href="../id429828/index.html">(Tidak hanya) mahasiswa baru: Universitas Instruksi 2.0</a></li>
<li><a href="../id429832/index.html">Terjemahan buku Andrew Un, Passion for Machine Learning, Bab 28 - 29</a></li>
<li><a href="../id429834/index.html">Mengapa mobil bisa bermain tidak manusiawi dengan baik di Mario, tetapi tidak di Pokemon?</a></li>
<li><a href="../id429836/index.html">Selamat tinggal, Elektron. Halo PWA desktop</a></li>
<li><a href="../id429840/index.html">Cara membuat mesin arcade vektor Atari Asteroids</a></li>
<li><a href="../id429842/index.html">Bagaimana cara mengajarkan kecerdasan buatan untuk menjual</a></li>
<li><a href="../id429844/index.html">Menu untuk menu, kisi atau bootstrap, kenyamanan</a></li>
<li><a href="../id429848/index.html">AI vs. pelecehan dan depresi: bagaimana bot membuat dunia menjadi tempat yang lebih baik</a></li>
<li><a href="../id429850/index.html">Kami mengundang Anda ke: cloud - acara teknologi cloud pertama dari tim Yandex.Cloud</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>