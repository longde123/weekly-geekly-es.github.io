<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏸 🗾 🔸 Apache Kafka + Spring Boot：您好，微服务 🧜🏿 👨🏾‍🤝‍👨🏽 💀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 在本文中，我们将在Linux下使用Apache Kafka在Spring Boot 2上编写一个应用程序，从安装JRE到工作的微服务应用程序。 

 看到该文章的前端开发部门的同事抱怨说，我没有解释Apache Kafka和Spring Boot是什么。 我相信任何需要使用上述技术来组装完...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apache Kafka + Spring Boot：您好，微服务</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440400/">哈Ha！ 在本文中，我们将在Linux下使用Apache Kafka在Spring Boot 2上编写一个应用程序，从安装JRE到工作的微服务应用程序。 <br><br> 看到该文章的前端开发部门的同事抱怨说，我没有解释Apache Kafka和Spring Boot是什么。 我相信任何需要使用上述技术来组装完成项目的人都知道它是什么以及为什么需要它。 如果对读者而言，问题并不闲着，那么这是有关Habr的优秀文章， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Apache Kafka</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Spring Boot是什么</a> 。 <br><br> 我们无需对Kafka，Spring Boot和Linux是什么进行冗长的解释，而是在Linux机器上从头开始运行Kafka服务器，编写两个微服务，并使其中一个向其他人发送消息-通常，配置完整的微服务架构。 <br><br><img src="https://habrastorage.org/webt/5d/p3/ab/5dp3abjx-c62zmfmmtp5tjvbjci.jpeg"><br><br> 该职位将包括两个部分。 在第一个中，我们在Linux机器上配置并运行Apache Kafka，第二个中，我们用Java编写了两个微服务。 <br><a name="habracut"></a><br> 在我以程序员的职业生涯开始的创业公司中，Kafka上有微服务，我的一个微服务也通过Kafka与其他人一起工作，但是我不知道服务器本身是如何工作的，无论是作为应用程序编写的还是已经完全装箱的产品。 当我发现Kafka仍然是盒装产品时，我感到惊讶和失望，我的任务不仅是用Java编写客户端（我喜欢这样做），还将完成的应用程序部署和配置为devOps（我讨厌做）。 但是，即使我可以在不到一天的时间内将其在Kafka虚拟服务器上提出，也确实非常简单。 这样啊 <br><br> 我们的应用程序将具有以下交互结构： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wy/id/y5/wyidy5ttuw6eam5buszy6rb8z0m.jpeg"></div><br> 与往常一样，在文章末尾，将有指向带有工作代码的git的链接。 <br><br><h1> 在虚拟机上部署Apache Kafka + Zookeeper </h1><br> 我试图在本地Linux，罂粟和远程Linux上提高Kafka。 在两种情况下（Linux），我很快就成功了。 对于罂粟，什么也没发生。 因此，我们将在Linux上安装Kafka。 我选择了Ubuntu 18.04。 <br><br> 为了让Kafka工作，她需要一个Zookeeper。 为此，必须在启动Kafka之前下载并运行它。 <br><br> 这样啊 <br><br><h4>  0.安装JRE </h4><br> 这是通过以下命令完成的： <br><br><pre><code class="bash hljs">sudo apt-get update sudo apt-get install default-jre</code> </pre> <br> 如果一切正常，那么您可以输入命令 <br><br><pre> <code class="bash hljs">java -version</code> </pre> <br> 并确保已安装Java。 <br><br><h4>  1.下载Zookeeper </h4><br> 我不喜欢Linux上的魔术团队，尤其是当他们只给出一些命令并且不清楚他们在做什么时。 因此，我将描述每个动作-它的确切作用。 因此，我们需要下载Zookeeper并将其解压缩到一个方便的文件夹中。 建议将所有应用程序都存储在/ opt文件夹中，也就是说，在我们的示例中，它将是/ opt / zookeeper。 <br><br> 我用下面的命令。 如果您认为其他Linux命令可以使您更正确地执行此操作，请使用它们。 我是开发人员，而不是开发人员，并且我与“山羊本身”级别的服务器进行通信。 因此，下载应用程序： <br><br><pre> <code class="bash hljs">wget -P /home/xpendence/downloads/ <span class="hljs-string"><span class="hljs-string">"http://apache-mirror.rbc.ru/pub/apache/zookeeper/zookeeper-3.4.12/zookeeper-3.4.12.tar.gz"</span></span></code> </pre> <br> 该应用程序被下载到您指定的文件夹中，我创建了文件夹/ home / xpendence / downloads，以下载我需要的所有应用程序。 <br><br><h4>  2.解压Zookeeper </h4><br> 我使用了命令： <br><br><pre> <code class="bash hljs">tar -xvzf /home/xpendence/downloads/zookeeper-3.4.12.tar.gz</code> </pre> <br> 此命令将归档文件解压缩到您所在的文件夹中。 然后，您可能需要将应用程序转移到/ opt / zookeeper。 您可以立即进入它，并从那里已经解压缩了存档。 <br><br><h4>  3.编辑设定 </h4><br> 在文件夹/ zookeeper / conf /中有一个文件zoo-sample.cfg，我建议将其重命名为zoo.conf，JVM将在启动时查找该文件。 最后应在文件中添加以下内容： <br><br><pre> <code class="bash hljs">tickTime=2000 dataDir=/var/zookeeper clientPort=2181</code> </pre> <br> 另外，创建/ var / zookeeper目录。 <br><br><h4>  4.启动Zookeeper </h4><br> 转到/ opt / zookeeper文件夹，并使用以下命令启动服务器： <br><br><pre> <code class="bash hljs">bin/zkServer.sh start</code> </pre> <br> 应该出现“开始”。 <br><br> 之后，我建议检查服务器是否正常运行。 我们写： <br><br><pre> <code class="bash hljs">telnet localhost 2181</code> </pre> <br> 应显示一条消息，说明连接成功。 如果服务器性能较弱，但未出现该消息，请重试-即使出现STARTED，应用程序也将在更晚的时候开始监听该端口。 当我在一台弱小的服务器上尝试所有这些操作时，它每次都发生在我身上。 如果一切都已连接，请输入命令 <br><br><pre> <code class="bash hljs">ruok</code> </pre> <br> 这是什么意思：“你还好吗？” 服务器应响应： <br><br><pre> <code class="bash hljs">imok ( !)</code> </pre> <br> 并断开连接。 因此，一切都按计划进行。 我们继续启动Apache Kafka。 <br><br><h4>  5.在Kafka下创建一个用户 </h4><br> 要使用Kafka，我们需要一个单独的用户。 <br><br><pre> <code class="bash hljs">sudo adduser --system --no-create-home --disabled-password --disabled-login kafka</code> </pre> <br><h4>  6.下载Apache Kafka </h4><br> 有两种分布-二进制和源。 我们需要一个二进制文件。 在外观上，带有二进制文件的归档文件大小不同。 二进制文件重59 MB，重6.5 MB。 <br><br> 使用下面的链接将二进制文件下载到该目录中： <br><br><pre> <code class="bash hljs">wget -P /home/xpendence/downloads/ <span class="hljs-string"><span class="hljs-string">"http://mirror.linux-ia64.org/apache/kafka/2.1.0/kafka_2.11-2.1.0.tgz"</span></span></code> </pre> <br><h4>  7.解压Apache Kafka </h4><br> 解压过程与Zookeeper的相同。 我们还将压缩文件解压缩到/ opt目录中，并将其重命名为kafka，以便/ bin文件夹的路径为/ opt / kafka / bin <br><br><pre> <code class="bash hljs">tar -xvzf /home/xpendence/downloads/kafka_2.11-2.1.0.tgz</code> </pre> <br><h4>  8.编辑设定 </h4><br> 设置在/opt/kafka/config/server.properties中。 添加一行： <br><br><pre> <code class="bash hljs">delete.topic.enable = <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br> 此设置似乎是可选的，没有它就可以工作。 此设置使您可以删除主题。 否则，您根本无法通过命令行删除主题。 <br><br><h4>  9.我们授予访问用户kafka目录Kafka的权限 </h4><br><pre> <code class="bash hljs">chown -R kafka:nogroup /opt/kafka chown -R kafka:nogroup /var/lib/kafka</code> </pre> <br><h4>  10.期待已久的Apache Kafka发布 </h4><br> 我们输入命令，然后启动Kafka： <br><br><pre> <code class="bash hljs">/opt/kafka/bin/kafka-server-start.sh /opt/kafka/config/server.properties</code> </pre> <br> 如果常规操作（Kafka用Java和Scala编写）没有溢出到日志中，那么一切正常，您可以测试我们的服务。 <br><br><h4>  10.1。 服务器问题弱 </h4><br> 为了在Apache Kafka上进行实验，我选择了一个性能较弱的服务器，该服务器具有一个内核和512 MB RAM（仅需99卢布），这对我来说是几个问题。 <br><br> 内存不足。 当然，您无法使用512 MB超频，并且由于内存不足，服务器无法部署Kafka。 事实是，默认情况下，Kafka占用1 GB的内存。 难怪他失踪了:) <br><br> 我们转到kafka-server-start.sh，zookeeper-server-start.sh。 已经有一条调节内存的行： <br><br><pre> <code class="java hljs">export KAFKA_HEAP_OPTS=<span class="hljs-string"><span class="hljs-string">"-Xmx1G -Xms1G"</span></span></code> </pre> <br> 更改为： <br><br><pre> <code class="java hljs">export KAFKA_HEAP_OPTS=<span class="hljs-string"><span class="hljs-string">"-Xmx256M -Xms128M"</span></span></code> </pre> <br> 这将降低Kafka的胃口，并允许您启动服务器。 <br><br> 计算机性能低下的第二个问题是没有足够的时间连接到Zookeeper。 默认情况下，这是6秒。 如果铁很弱，那当然是不够的。 在server.properties中，我们增加了与zukipper的连接时间： <br><br><pre> <code class="bash hljs">zookeeper.connection.timeout.ms=30000</code> </pre> <br> 我定了半分钟。 <br><br><h4>  11.测试Kafka服务器 </h4><br> 为此，我们将打开两个终端，其中一个将启动生产者，而另一个将启动消费者。 <br> 在第一个控制台中，输入一行： <br><br><pre> <code class="bash hljs">/opt/kafka/bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> /opt/kafka/bin/kafka-console-producer.sh --broker-list localhost:9092 --topic <span class="hljs-built_in"><span class="hljs-built_in">test</span></span></code> </pre> <br> 应显示此图标，表明生产者已准备好发送垃圾邮件： <br><br><pre> <code class="bash hljs">&gt;</code> </pre> <br> 在第二个控制台中，输入命令： <br><br><pre> <code class="bash hljs">/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> --from-beginning</code> </pre> <br> 现在，在生产者控制台中键入内容，当您按Enter键时，它将出现在消费者控制台中。 <br><br> <a href="" rel="nofollow"><img src="https://habrastorage.org/webt/k7/uu/kf/k7uukff1u2kyygrgetrnvjnqmmg.png"></a> <br><br> 如果您在屏幕上看到的画面与我大致相同-恭喜，最糟糕的时刻已经过去！ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n7/rg/lz/n7rglz4s3wvbqzg_chzjjooiazw.jpeg"></div><br> 现在我们只需要在Spring Boot上编写几个客户端即可通过Apache Kafka相互通信。 <br><br><h1> 在Spring Boot上编写应用程序 </h1><br> 我们将编写两个应用程序，它们将通过Apache Kafka交换消息。 第一条消息称为kafka-server，将包含生产者和消费者。 第二个称为kafka-tester，其设计目的是使我们拥有微服务架构。 <br><br><h3> 卡夫卡服务器 </h3><br> 对于通过Spring Initializr创建的项目，我们需要Kafka模块。 我添加了Lombok和Web，但这只是一个口味问题。 <br><br>  Kafka客户端由两个部分组成-生产者（他将消息发送到Kafka服务器）和消费者（他听着Kafka服务器并从那里接收有关他所订阅主题的新消息）。 我们的任务是编写两个组件并使它们工作。 <br><br> 消费者： <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KafkaConsumerConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Value</span></span>(<span class="hljs-string"><span class="hljs-string">"${kafka.server}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String kafkaServer; <span class="hljs-meta"><span class="hljs-meta">@Value</span></span>(<span class="hljs-string"><span class="hljs-string">"${kafka.group.id}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String kafkaGroupId; <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> KafkaListenerContainerFactory&lt;?&gt; batchFactory() { ConcurrentKafkaListenerContainerFactory&lt;Long, AbstractDto&gt; factory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentKafkaListenerContainerFactory&lt;&gt;(); factory.setConsumerFactory(consumerFactory()); factory.setBatchListener(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); factory.setMessageConverter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BatchMessagingMessageConverter(converter())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> factory; } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> KafkaListenerContainerFactory&lt;?&gt; singleFactory() { ConcurrentKafkaListenerContainerFactory&lt;Long, AbstractDto&gt; factory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentKafkaListenerContainerFactory&lt;&gt;(); factory.setConsumerFactory(consumerFactory()); factory.setBatchListener(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); factory.setMessageConverter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringJsonMessageConverter()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> factory; } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ConsumerFactory&lt;Long, AbstractDto&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consumerFactory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefaultKafkaConsumerFactory&lt;&gt;(consumerConfigs()); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> KafkaListenerContainerFactory&lt;?&gt; kafkaListenerContainerFactory() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentKafkaListenerContainerFactory&lt;&gt;(); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Map&lt;String, Object&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consumerConfigs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Map&lt;String, Object&gt; props = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaServer); props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, LongDeserializer.class); props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); props.put(ConsumerConfig.GROUP_ID_CONFIG, kafkaGroupId); props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> props; } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringJsonMessageConverter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">converter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringJsonMessageConverter(); } }</code> </pre> <br> 我们需要使用来自kafka.properties的静态数据初始化的2个字段。 <br><br><pre> <code class="java hljs">kafka.server=localhost:<span class="hljs-number"><span class="hljs-number">9092</span></span> kafka.group.id=server.broadcast</code> </pre> <br>  kafka.server是服务器挂起的地址，在这种情况下为本地。 默认情况下，Kafka侦听端口9092。 <br><br>  kafka.group.id是一组使用者，在其中传送消息的一个实例。 例如，您在一个小组中有三个快递员，他们都听同一个话题。 服务器上出现带有该主题的新消息后，该消息就会立即传递给组中的某人。 其余两个使用者没有收到该消息。 <br><br> 接下来，我们为消费者创建工厂-ConsumerFactory。 <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ConsumerFactory&lt;Long, AbstractDto&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consumerFactory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefaultKafkaConsumerFactory&lt;&gt;(consumerConfigs()); }</code> </pre> <br> 通过我们所需的属性进行初始化，它将在将来成为消费者的标准工厂。 <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Map&lt;String, Object&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consumerConfigs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Map&lt;String, Object&gt; props = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaServer); props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, LongDeserializer.class); props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); props.put(ConsumerConfig.GROUP_ID_CONFIG, kafkaGroupId); props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> props; }</code> </pre> <br>  ConsumerConfigs只是Map配置。 我们提供服务器地址，组和反序列化器。 <br><br> 此外，对于消费者而言，最重要的一点之一。 消费者可以接收单个对象和集合，例如StarshipDto和List。 而且，如果将StarshipDto作为JSON获取，则将List大致作为JSON数组获取。 因此，我们至少有两个消息工厂-用于单个消息和用于数组。 <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> KafkaListenerContainerFactory&lt;?&gt; singleFactory() { ConcurrentKafkaListenerContainerFactory&lt;Long, AbstractDto&gt; factory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentKafkaListenerContainerFactory&lt;&gt;(); factory.setConsumerFactory(consumerFactory()); factory.setBatchListener(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); factory.setMessageConverter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringJsonMessageConverter()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> factory; }</code> </pre> <br> 我们实例化ConcurrentKafkaListenerContainerFactory，分别键入Long（消息键）和AbstractDto（抽象消息值），并使用属性初始化其字段。 当然，我们用我们的标准工厂（已经包含Map配置）初始化工厂，然后标记为我们不侦听数据包（相同的数组），并指定一个简单的JSON转换器作为转换器。 <br><br> 当我们为包/数组（批处理）创建工厂时，主要区别（除了标记为监听包的事实）是，我们指定了一个特殊的包转换器作为转换器，它将转换包含以下内容的包从JSON字符串。 <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> KafkaListenerContainerFactory&lt;?&gt; batchFactory() { ConcurrentKafkaListenerContainerFactory&lt;Long, AbstractDto&gt; factory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentKafkaListenerContainerFactory&lt;&gt;(); factory.setConsumerFactory(consumerFactory()); factory.setBatchListener(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); factory.setMessageConverter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BatchMessagingMessageConverter(converter())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> factory; } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringJsonMessageConverter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">converter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringJsonMessageConverter(); }</code> </pre> <br> 还有一件事。 初始化Spring Bean时，名称kafkaListenerContainerFactory下的bin可能不会被计数，并且该应用程序将被破坏。 当然，可以使用更优雅的选项来解决问题，在注释中写下它们，因为现在我刚刚创建了一个卸载了具有相同名称功能的垃圾箱： <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> KafkaListenerContainerFactory&lt;?&gt; kafkaListenerContainerFactory() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentKafkaListenerContainerFactory&lt;&gt;(); }</code> </pre> <br> 消费者成立。 我们传递给生产者。 <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KafkaProducerConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Value</span></span>(<span class="hljs-string"><span class="hljs-string">"${kafka.server}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String kafkaServer; <span class="hljs-meta"><span class="hljs-meta">@Value</span></span>(<span class="hljs-string"><span class="hljs-string">"${kafka.producer.id}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String kafkaProducerId; <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Map&lt;String, Object&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">producerConfigs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Map&lt;String, Object&gt; props = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaServer); props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, LongSerializer.class); props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class); props.put(ProducerConfig.CLIENT_ID_CONFIG, kafkaProducerId); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> props; } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ProducerFactory&lt;Long, StarshipDto&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">producerStarshipFactory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefaultKafkaProducerFactory&lt;&gt;(producerConfigs()); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> KafkaTemplate&lt;Long, StarshipDto&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kafkaTemplate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ KafkaTemplate&lt;Long, StarshipDto&gt; template = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KafkaTemplate&lt;&gt;(producerStarshipFactory()); template.setMessageConverter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringJsonMessageConverter()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> template; } }</code> </pre> <br> 在静态变量中，我们需要kafka服务器的地址和生产者ID。 他可以是任何人。 <br><br> 如我们所见，在配置中，没有什么特别的。 几乎一样。 但是就工厂而言，有很大的不同。 我们必须为将要发送到其对象的每个类注册一个模板，并为其注册一个工厂。 我们有一对这样的对，但可以有数十对。 <br><br> 在模板中，我们标记为将序列化JSON中的对象，这也许就足够了。 <br><br> 我们有一个消费者和一个生产者，它仍然需要编写一项服务来发送和接收消息。 <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-meta"><span class="hljs-meta">@Slf</span></span>4j <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StarshipServiceImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StarshipService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> KafkaTemplate&lt;Long, StarshipDto&gt; kafkaStarshipTemplate; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ObjectMapper objectMapper; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StarshipServiceImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(KafkaTemplate&lt;Long, StarshipDto&gt; kafkaStarshipTemplate, ObjectMapper objectMapper)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.kafkaStarshipTemplate = kafkaStarshipTemplate; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.objectMapper = objectMapper; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StarshipDto dto)</span></span></span><span class="hljs-function"> </span></span>{ kafkaStarshipTemplate.send(<span class="hljs-string"><span class="hljs-string">"server.starship"</span></span>, dto); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@KafkaListener</span></span>(id = <span class="hljs-string"><span class="hljs-string">"Starship"</span></span>, topics = {<span class="hljs-string"><span class="hljs-string">"server.starship"</span></span>}, containerFactory = <span class="hljs-string"><span class="hljs-string">"singleFactory"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StarshipDto dto)</span></span></span><span class="hljs-function"> </span></span>{ log.info(<span class="hljs-string"><span class="hljs-string">"=&gt; consumed {}"</span></span>, writeValueAsString(dto)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeValueAsString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StarshipDto dto)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> objectMapper.writeValueAsString(dto); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (JsonProcessingException e) { e.printStackTrace(); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"Writing value to JSON failed: "</span></span> + dto.toString()); } } }</code> </pre> <br> 我们的服务只有两种方法，它们足以让我们解释客户的工作。 我们自动连接所需的模式： <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> KafkaTemplate&lt;Long, StarshipDto&gt; kafkaStarshipTemplate;</code> </pre> <br> 生产者方法： <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StarshipDto dto)</span></span></span><span class="hljs-function"> </span></span>{ kafkaStarshipTemplate.send(<span class="hljs-string"><span class="hljs-string">"server.starship"</span></span>, dto); }</code> </pre> <br> 向服务器发送消息所需要做的只是在模板上调用send方法，然后在其中传输主题（主题）和我们的对象。 该对象将以JSON序列化，并将在指定主题下跳转到服务器。 <br><br> 侦听方法如下所示： <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@KafkaListener</span></span>(id = <span class="hljs-string"><span class="hljs-string">"Starship"</span></span>, topics = {<span class="hljs-string"><span class="hljs-string">"server.starship"</span></span>}, containerFactory = <span class="hljs-string"><span class="hljs-string">"singleFactory"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StarshipDto dto)</span></span></span><span class="hljs-function"> </span></span>{ log.info(<span class="hljs-string"><span class="hljs-string">"=&gt; consumed {}"</span></span>, writeValueAsString(dto)); }</code> </pre> <br> 我们用@KafkaListener批注标记该方法，在其中注明我们喜欢的任何ID，已收听的主题以及将接收到的消息转换为所需内容的工厂。 在这种情况下，由于我们接受一个对象，因此我们需要一个singleFactory。 对于列表&lt;？&gt;，指定batchFactory。 结果，我们使用send方法将对象发送到kafka服务器，并使用消耗方法将其获取。 <br><br> 您可以在5分钟内编写一个测试，以演示Kafka的全部功能，但我们会走得更远-花10分钟编写另一个应用程序，该应用程序将向服务器发送消息，这是我们第一个应用程序将侦听的消息。 <br><br><h2> 卡夫卡测试仪 </h2><br> 具有编写第一个应用程序的经验，我们可以轻松编写第二个应用程序，尤其是如果我们复制粘贴和dto包，仅注册生产者（我们将仅发送消息）并将唯一的send方法添加到服务中。 使用下面的链接，您可以轻松下载项目代码，并确保其中没有复杂的代码。 <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Scheduled</span></span>(initialDelay = <span class="hljs-number"><span class="hljs-number">10000</span></span>, fixedDelay = <span class="hljs-number"><span class="hljs-number">5000</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">produce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ StarshipDto dto = createDto(); log.info(<span class="hljs-string"><span class="hljs-string">"&lt;= sending {}"</span></span>, writeValueAsString(dto)); kafkaStarshipTemplate.send(<span class="hljs-string"><span class="hljs-string">"server.starship"</span></span>, dto); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> StarshipDto </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createDto</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StarshipDto(<span class="hljs-string"><span class="hljs-string">"Starship "</span></span> + (LocalTime.now().toNanoOfDay() / <span class="hljs-number"><span class="hljs-number">1000000</span></span>)); }</code> </pre> <br> 在最初的10秒后，kafka-tester开始每5秒将带有星舰名称的消息发送到Kafka服务器（图片是可单击的）。 <br><br> <a href="" rel="nofollow"><img src="https://habrastorage.org/webt/oo/ri/gk/oorigkqltxuntytvhzbarlninhk.png"></a> <br><br> 在那里，kafka-server会收听和接收它们（图片也可单击）。 <br><br> <a href="" rel="nofollow"><img src="https://habrastorage.org/webt/cs/w-/vc/csw-vcgajjpjymkdxcwibqllnoi.png"></a> <br><br> 我希望那些梦想开始在Kafka编写微服务的人能够像我一样轻松地成功。 这是项目的链接： <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">kafka服务器</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">卡夫卡测试仪</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN440400/">https://habr.com/ru/post/zh-CN440400/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN440388/index.html">时间间隔：即将到来的C ++演变</a></li>
<li><a href="../zh-CN440390/index.html">嵌入式系统的多样化世界以及Embox在其中的地位</a></li>
<li><a href="../zh-CN440392/index.html">您网站上的WebRTC-没有错误，也没有预算</a></li>
<li><a href="../zh-CN440394/index.html">PostgreSQL权限提升-CVE-2018-10915解析</a></li>
<li><a href="../zh-CN440398/index.html">参加2018年俄罗斯AI杯的历史（和胜利）-CodeBall</a></li>
<li><a href="../zh-CN440402/index.html">SearchFace开发人员有关算法功能的信息</a></li>
<li><a href="../zh-CN440404/index.html">“信息架构”：OZON中的mitap</a></li>
<li><a href="../zh-CN440410/index.html">在地图上选择，缓存和显示照片</a></li>
<li><a href="../zh-CN440412/index.html">Zimbra协作套件和MS Exchange在同一域上</a></li>
<li><a href="../zh-CN440414/index.html">关于短绒棉，代码质量，一般质量和质量管理</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>