<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛴️ 👨🏿‍🎓 💨 Jenis untuk HTTP API yang ditulis dalam Python: pengalaman Instagram 🕡 👨🏽‍🚀 💩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini kami menerbitkan materi kedua dari seri yang ditujukan untuk penggunaan Python di Instagram. Terakhir kali itu memeriksa jenis kode server In...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jenis untuk HTTP API yang ditulis dalam Python: pengalaman Instagram</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/474308/">  Hari ini kami menerbitkan materi kedua dari seri yang ditujukan untuk penggunaan Python di Instagram.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Terakhir</a> kali itu memeriksa jenis kode server Instagram.  Server adalah monolith yang ditulis dengan Python.  Ini terdiri dari beberapa juta baris kode dan memiliki beberapa ribu titik akhir Django. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/nn/gh/jg/nnghjgmcauejll98mv34awk3cok.jpeg"></a> <br><br>  Artikel ini adalah tentang bagaimana Instagram menggunakan tipe untuk mendokumentasikan API HTTP dan untuk menegakkan kontrak ketika bekerja dengannya. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Tinjauan situasi</font> </h2><br>  Ketika Anda membuka klien seluler Instagram, itu, melalui HTTP, mengakses JSON-API dari server Python (Django) kami. <br><br>  Berikut adalah beberapa informasi tentang sistem kami yang akan memungkinkan Anda untuk mendapatkan gambaran tentang kompleksitas API yang kami gunakan untuk mengatur pekerjaan klien seluler.  Jadi inilah yang kita miliki: <br><br><ul><li>  Lebih dari 2000 titik akhir di server. </li><li>  Lebih dari 200 bidang tingkat atas dalam objek data klien yang mewakili gambar, video, atau cerita dalam suatu aplikasi. </li><li>  Ratusan programmer yang menulis kode server (dan bahkan lebih banyak yang berurusan dengan klien). </li><li>  Ratusan komitmen terhadap kode server dibuat setiap hari dan memodifikasi API.  Ini diperlukan untuk memberikan dukungan untuk fitur sistem baru. </li></ul><br>  Kami menggunakan jenis untuk mendokumentasikan API HTTP kami yang kompleks dan terus berkembang serta untuk menegakkan kontrak ketika bekerja dengannya. <br><br><h2>  <font color="#3AC1EF">Jenis</font> </h2><br>  Mari kita mulai dari awal.  Deskripsi sintaks untuk tipe anotasi dalam kode Python muncul di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PEP 484</a> .  Mengapa menambahkan tipe anotasi ke kode? <br><br>  Pertimbangkan fungsi yang mengunduh informasi tentang pahlawan Star Wars: <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_character</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id, calendar)</span></span></span><span class="hljs-function">:</span></span>     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> id == <span class="hljs-number"><span class="hljs-number">1000</span></span>:         <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Character(             id=<span class="hljs-number"><span class="hljs-number">1000</span></span>,             name=<span class="hljs-string"><span class="hljs-string">"Luke Skywalker"</span></span>,             birth_year=<span class="hljs-string"><span class="hljs-string">"19BBY"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> calendar == Calendar.BBY <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ...         )     ...</code> </pre> <br>  Untuk memahami fungsi ini, Anda perlu membaca kodenya.  Setelah melakukan ini, Anda dapat menemukan yang berikut: <br><br><ul><li>  Dibutuhkan integer identifier ( <code>id</code> ) karakter. </li><li>  Dibutuhkan nilai dari enumerasi yang sesuai ( <code>calendar</code> ).  Misalnya, <code>Calendar.BBY</code> berarti "Sebelum Pertempuran Yavin," yaitu, "Sebelum Pertempuran Yavin." </li><li>  Ini mengembalikan informasi tentang karakter dalam bentuk entitas yang berisi bidang yang mewakili pengidentifikasi karakter ini, nama dan tahun kelahirannya. </li></ul><br>  Fungsi memiliki kontrak implisit, artinya programmer harus mengembalikan setiap kali dia membaca kode fungsi.  Tetapi kode fungsi hanya ditulis sekali, dan Anda harus membacanya berkali-kali, jadi pendekatan untuk bekerja dengan kode ini tidak terlalu baik. <br><br>  Selain itu, sulit untuk memverifikasi bahwa mekanisme yang memanggil fungsi mematuhi kontrak implisit yang dijelaskan di atas.  Demikian pula, sulit untuk memverifikasi bahwa kontrak ini dihormati di tubuh fungsi.  Dalam basis kode besar, situasi seperti itu dapat menyebabkan kesalahan. <br><br>  Sekarang pertimbangkan fungsi yang sama yang menyatakan tipe anotasi: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_character</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: int, calendar: Calendar)</span></span></span><span class="hljs-function"> -&gt; Character:</span></span>    ...</code> </pre> <br>  Ketik anotasi memungkinkan Anda untuk secara eksplisit mengekspresikan kontrak fungsi ini.  Untuk memahami apa yang perlu diinput ke suatu fungsi, dan apa fungsi ini kembali, baca saja tanda tangannya.  Sistem pengecekan tipe dapat secara statis menganalisis fungsi dan memverifikasi kepatuhan dengan kontrak dalam kode.  Ini memungkinkan Anda untuk menyingkirkan seluruh kelas kesalahan! <br><br><h2>  <font color="#3AC1EF">Jenis untuk berbagai API HTTP</font> </h2><br>  Kami akan mengembangkan HTTP-API yang memungkinkan Anda menerima informasi tentang para pahlawan Star Wars.  Untuk menjelaskan kontrak eksplisit yang digunakan saat bekerja dengan API ini, kami akan menggunakan jenis anotasi. <br><br>  API kami harus menerima pengenal karakter ( <code>id</code> ) sebagai parameter URL dan nilai enumerasi <code>calendar</code> sebagai parameter permintaan.  API harus mengembalikan respons JSON dengan informasi karakter. <br><br>  Beginilah tampilan permintaan API dan responsnya: <br><br><pre> <code class="plaintext hljs">curl -X GET https://api.starwars.com/characters/1000?calendar=BBY {    "id": 1000,    "name": "Luke Skywalker",    "birth_year": "19BBY" }</code> </pre> <br>  Untuk mengimplementasikan API ini di Django, pertama-tama Anda harus mendaftarkan jalur URL dan fungsi tampilan yang bertanggung jawab untuk menerima permintaan HTTP yang dibuat di sepanjang jalur ini dan untuk mengembalikan respons. <br><br><pre> <code class="python hljs">urlpatterns = [    url(<span class="hljs-string"><span class="hljs-string">"characters/&lt;id&gt;/"</span></span>, get_character) ]</code> </pre> <br>  Fungsi, sebagai input, menerima parameter permintaan dan URL (dalam kasus kami, <code>id</code> ).  Ini mem-parsing dan melemparkan parameter permintaan <code>calendar</code> , yang merupakan nilai dari enumerasi yang sesuai, ke tipe yang diperlukan.  Itu memuat data karakter dari toko dan mengembalikan kamus berseri dalam JSON dan dibungkus dengan respons HTTP. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_character</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request: IGWSGIRequest, id: str)</span></span></span><span class="hljs-function"> -&gt; JsonResponse:</span></span>    calendar = Calendar(request.GET.get(<span class="hljs-string"><span class="hljs-string">"calendar"</span></span>, <span class="hljs-string"><span class="hljs-string">"BBY"</span></span>))    character = Store.get_character(id, calendar)    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> JsonResponse(asdict(character))</code> </pre> <br>  Meskipun fungsi disediakan dengan anotasi tipe, ia tidak secara eksplisit menggambarkan kontrak keras untuk HTTP API.  Dari tanda tangan fungsi ini kami tidak dapat menemukan nama atau tipe parameter permintaan, atau bidang respons dan tipenya. <br><br>  Apakah mungkin untuk membuat tanda tangan dari fungsi-representasi menjadi sama persis informatif dengan tanda tangan dari fungsi yang sebelumnya dipertimbangkan dengan anotasi jenis? <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_character</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: int, calendar: Calendar)</span></span></span><span class="hljs-function"> -&gt; Character:</span></span>    ...</code> </pre> <br>  Parameter fungsi dapat berupa parameter kueri (URL, kueri, atau parameter badan kueri).  Jenis nilai yang dikembalikan oleh fungsi dapat mewakili isi dari respons.  Dengan pendekatan ini, kami akan memiliki kontrak eksplisit dan dapat dimengerti untuk HTTP API, yang ketaatannya dapat dipastikan dengan sistem pengecekan tipe. <br><br><h2>  <font color="#3AC1EF">Implementasi</font> </h2><br>  Bagaimana cara menerapkan ide ini? <br><br>  Kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dekorator</a> untuk mengubah fungsi representasi yang sangat diketik menjadi fungsi representasi Django.  Langkah ini tidak memerlukan perubahan dalam hal bekerja dengan kerangka kerja Django.  Kita dapat menggunakan middleware yang sama, rute yang sama, dan komponen lain yang biasa kita gunakan. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@api_view def get_character(id: int, calendar: Calendar) -&gt; Character:    ...</span></span></code> </pre> <br>  Pertimbangkan detail <code>api_view</code> dekorator <code>api_view</code> : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">api_view</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view)</span></span></span><span class="hljs-function">:</span></span>    @functools.wraps(view)    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">django_view</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span>        params = {            param_name: param.annotation(extract(request, param))            <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> param_name, param <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> inspect.signature(view).parameters.items()        }        data = view(**params)        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> JsonResponse(asdict(data))       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> django_view</code> </pre> <br>  Ini adalah kode yang sulit untuk dipahami.  Mari kita menganalisis fitur-fiturnya. <br>  Kami, sebagai nilai input, mengambil fungsi representasi yang sangat diketik dan membungkusnya dalam fungsi representasi Django biasa, yang kami kembalikan: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">api_view</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view)</span></span></span><span class="hljs-function">:</span></span>    @functools.wraps(view)    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">django_view</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span>        ...    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> django_view</code> </pre> <br>  Sekarang lihat implementasi fungsi tampilan Django.  Pertama, kita perlu membuat argumen untuk fungsi presentasi yang sangat diketik.  Kami menggunakan introspeksi dan modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">inspeksi</a> untuk mendapatkan tanda tangan dari fungsi ini dan beralih pada parameternya: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> param_name, param <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> inspect.signature(view).parameters.items()</code> </pre> <br>  Untuk setiap parameter, kami memanggil fungsi <code>extract</code> , yang mengekstrak nilai parameter dari permintaan. <br><br>  Kemudian kami melemparkan parameter ke tipe yang diharapkan yang ditentukan dalam tanda tangan (misalnya, melemparkan <code>calendar</code> string ke nilai yang merupakan elemen dari enumerasi <code>Calendar</code> ). <br><br><pre> <code class="python hljs">param.annotation(extract(request, param))</code> </pre> <br>  Kami memanggil fungsi tampilan yang sangat diketik dengan argumen yang kami buat: <br><br><pre> <code class="python hljs">data = view(**params)</code> </pre> <br>  Fungsi mengembalikan nilai yang sangat diketik dari kelas <code>Character</code> .  Kami mengambil nilai ini, mengubahnya menjadi kamus dan membungkusnya dalam respons HTTP format JSON: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> JsonResponse(asdict(data))</code> </pre> <br>  Hebat!  Kami sekarang memiliki fungsi tampilan Django yang membungkus fungsi tampilan sangat diketik.  Akhirnya, lihat fungsi <code>extract</code> : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extract</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request: HttpRequest, param: Parameter)</span></span></span><span class="hljs-function"> -&gt; Any:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> request.resolver_match.route.contains(<span class="hljs-string"><span class="hljs-string">f"&lt;</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{param}</span></span></span><span class="hljs-string">&gt;"</span></span>):        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.resolver_match.kwargs.get(param.name)    <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>:        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.GET.get(param.name)</code> </pre> <br>  Setiap parameter dapat berupa parameter URL atau parameter permintaan.  Jalur URL permintaan (jalur yang kami daftarkan di awal) tersedia di objek rute sistem pencari lokasi Django.  Kami memeriksa nama parameter di jalur.  Jika ada nama, maka kita memiliki parameter URL.  Ini berarti bahwa kami dapat mengekstraknya dari permintaan.  Kalau tidak, ini adalah parameter kueri dan kita juga bisa mengekstraknya, tetapi dengan cara lain. <br><br>  Itu saja.  Ini adalah implementasi yang disederhanakan, tetapi menggambarkan ide dasar mengetik API. <br><br><h2>  <font color="#3AC1EF">Tipe data</font> </h2><br>  Jenis yang digunakan untuk mewakili konten respons HTTP (mis., <code>Character</code> ) dapat direpresentasikan baik dengan dataclass atau kamus yang diketik. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kelas</a> data adalah format deskripsi kelas kompak yang mewakili data. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dataclasses <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> dataclass @dataclass(frozen=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Character</span></span></span><span class="hljs-class">:</span></span>    id: int    name: str    birth_year: str luke = Character(    id=<span class="hljs-number"><span class="hljs-number">1000</span></span>,    name=<span class="hljs-string"><span class="hljs-string">"Luke Skywalker"</span></span>,    birth_year=<span class="hljs-string"><span class="hljs-string">"19BBY"</span></span> )</code> </pre> <br>  Instagram biasanya menggunakan kelas data untuk memodelkan objek respons HTTP.  Berikut adalah fitur utama mereka: <br><br><ul><li>  Mereka secara otomatis menghasilkan konstruksi templat dan berbagai metode pembantu. </li><li>  Dapat dimengerti untuk mengetikkan sistem pemeriksaan, yang berarti bahwa nilai-nilai dapat dikenakan pemeriksaan jenis. </li><li>  Mereka mempertahankan kekebalan berkat konstruk <code>frozen=True</code> . </li><li>  Mereka tersedia di pustaka standar Python 3.7, atau sebagai backport dalam Indeks Paket Python. </li></ul><br>  Sayangnya, Instagram memiliki basis kode yang ketinggalan zaman yang menggunakan kamus besar yang tidak diketik, yang dialihkan antara fungsi dan modul.  Tidak mudah menerjemahkan semua kode ini dari kamus ke kelas data.  Akibatnya, kami, menggunakan kelas data untuk kode baru, dan dalam kode lama kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kamus yang diketik</a> . <br><br>  Menggunakan kamus yang diketik memungkinkan kami untuk menambahkan anotasi jenis ke objek kamus klien dan, tanpa mengubah perilaku sistem kerja, menggunakan kemampuan memeriksa jenis. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mypy_extensions <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TypedDict <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Character</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(TypedDict)</span></span></span><span class="hljs-class">:</span></span>    id: int    name: str    birth_year: str luke: Character = {<span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">1000</span></span>} luke[<span class="hljs-string"><span class="hljs-string">"name"</span></span>] = <span class="hljs-string"><span class="hljs-string">"Luke Skywalker"</span></span> luke[<span class="hljs-string"><span class="hljs-string">"birth_year"</span></span>] = <span class="hljs-number"><span class="hljs-number">19</span></span> <span class="hljs-comment"><span class="hljs-comment"># type error, birth_year expects a str luke["invalid_key"] # type error, invalid_key does not exist</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Menangani kesalahan</font> </h2><br>  Fungsi tampilan diharapkan untuk mengembalikan informasi karakter dalam bentuk entitas <code>Character</code> .  Apa yang harus kita lakukan jika kita perlu mengembalikan kesalahan ke klien? <br><br>  Anda bisa melempar pengecualian yang akan ditangkap oleh kerangka kerja dan dikonversi menjadi respons HTTP dengan informasi kesalahan. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@api_view("GET") def get_character(id: str, calendar: Calendar) -&gt; Character:    try:        return Store.get_character(id)    except CharacterNotFound:        raise Http404Exception()</span></span></code> </pre> <br>  Contoh ini juga menunjukkan metode HTTP di dekorator, yang menetapkan metode HTTP yang diizinkan untuk API ini. <br><br><h2>  <font color="#3AC1EF">Alat-alatnya</font> </h2><br>  HTTP API sangat diketik menggunakan metode HTTP, tipe permintaan, dan tipe respons.  Kami dapat mengintrospeksi API ini dan menentukan bahwa ia harus menerima permintaan GET dengan string <code>id</code> di jalur URL dan dengan nilai <code>calendar</code> terkait dengan enumerasi terkait dalam string kueri.  Kita juga dapat belajar bahwa dalam menanggapi permintaan semacam itu, respons JSON harus diberikan dengan informasi tentang sifat <code>Character</code> . <br><br>  Apa yang dapat dilakukan dengan semua informasi ini? <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OpenAPI</a> adalah format deskripsi API yang menjadi dasar dibuatnya seperangkat alat bantu yang kaya.  Ini adalah keseluruhan ekosistem.  Jika kita menulis beberapa kode untuk melakukan introspeksi titik akhir dan menghasilkan spesifikasi OpenAPI berdasarkan data yang diterima, ini berarti bahwa kita akan memiliki kemampuan alat-alat ini. <br><br><pre> <code class="python hljs">paths:  /characters/{id}:    get:      parameters:        - <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: path          name: id          schema:            type: integer          required: true        - <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: query          name: calendar          schema:            type: string            enum: [<span class="hljs-string"><span class="hljs-string">"BBY"</span></span>]      responses:        <span class="hljs-string"><span class="hljs-string">'200'</span></span>:          content:            application/json:              schema:                type: object                ...</code> </pre> <br>  Kami dapat membuat dokumentasi HTTP API untuk <code>get_character</code> API, yang mencakup nama, tipe, permintaan, dan informasi respons.  Ini adalah tingkat abstraksi yang sesuai untuk pengembang klien yang perlu memenuhi permintaan ke titik akhir yang sesuai.  Mereka tidak perlu membaca kode implementasi Python untuk titik akhir ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/673/e79/28e/673e7928eb5c55d4d6ec83c506eaf450.png"><br>  <i><font color="#999999">Dokumentasi API</font></i> <br><br>  Atas dasar ini, Anda dapat membuat alat tambahan.  Misalnya, sarana untuk mengeksekusi permintaan dari browser.  Ini memungkinkan pengembang untuk mengakses API HTTP yang menarik bagi mereka tanpa harus menulis kode.  Kami bahkan dapat membuat kode klien tipe-aman untuk memastikan bahwa tipe berfungsi dengan benar pada klien dan server.  Karena hal ini, kami dapat menggunakan API yang diketik dengan ketat di server, panggilan yang dilakukan menggunakan kode klien yang diketik dengan ketat. <br><br>  Selain itu, kami dapat membuat sistem pemeriksaan kompatibilitas mundur.  Apa yang terjadi jika kita merilis versi baru dari kode server untuk mengakses API yang dimaksud, kita perlu menggunakan <code>id</code> , <code>name</code> , dan <code>birth_year</code> , dan kemudian kita mengerti bahwa kita tidak tahu tanggal lahir semua karakter?  Dalam hal ini, parameter <code>birth_year</code> perlu dibuat opsional, tetapi versi lama klien yang mengharapkan parameter yang sama mungkin berhenti bekerja.  Meskipun API kami berbeda dalam pengetikan eksplisit, tipe yang sesuai dapat berubah (katakanlah, API akan berubah jika menggunakan tahun kelahiran karakter adalah yang wajib pertama dan kemudian menjadi opsional).  Kami dapat melacak perubahan API dan memperingatkan pengembang API dengan memberi mereka konfirmasi pada saat yang tepat bahwa, dengan membuat beberapa perubahan, mereka dapat mengganggu kinerja klien. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Ada berbagai macam protokol aplikasi yang dapat digunakan komputer untuk berkomunikasi satu sama lain. <br><br>  Satu sisi spektrum ini diwakili oleh kerangka kerja RPC seperti penghematan dan gRPC.  Mereka berbeda dalam hal mereka biasanya menetapkan tipe ketat untuk permintaan dan tanggapan dan menghasilkan kode klien dan server untuk mengatur operasi permintaan.  Mereka dapat melakukannya tanpa HTTP dan bahkan tanpa JSON. <br><br>  Di sisi lain, ada kerangka kerja web tidak terstruktur yang ditulis dengan Python yang tidak memiliki kontrak eksplisit untuk permintaan dan tanggapan.  Pendekatan kami memberikan peluang yang khas untuk kerangka kerja terstruktur yang lebih jelas, tetapi pada saat yang sama memungkinkan Anda untuk terus menggunakan bundel HTTP + JSON dan berkontribusi pada fakta bahwa Anda harus melakukan sedikit perubahan pada kode aplikasi. <br><br>  Penting untuk dicatat bahwa ide ini bukan hal baru.  Ada banyak kerangka kerja yang ditulis dalam bahasa yang diketik sangat yang menyediakan pengembang dengan fitur yang kami jelaskan.  Jika kita berbicara tentang Python, maka ini adalah, misalnya, kerangka kerja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">APIStar</a> . <br><br>  Kami telah berhasil menugaskan penggunaan tipe untuk API HTTP.  Kami dapat menerapkan pendekatan yang dijelaskan untuk mengetik API di seluruh basis kode kami karena fakta bahwa itu juga berlaku untuk fungsi presentasi yang ada.  Nilai dari apa yang kami lakukan jelas bagi semua programmer kami.  Yaitu, kita berbicara tentang fakta bahwa dokumentasi yang dihasilkan secara otomatis telah menjadi sarana komunikasi yang efektif antara mereka yang mengembangkan server dan mereka yang menulis klien Instagram. <br><br>  <b>Pembaca yang budiman!</b>  Bagaimana Anda mendekati desain API HTTP di proyek Python Anda? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id474308/">https://habr.com/ru/post/id474308/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id474294/index.html">Kompatibilitas biner: sekarang atau tidak sama sekali</a></li>
<li><a href="../id474298/index.html">Menerapkan Operasi Transfer Kartu-ke-Kartu P2P Gateway</a></li>
<li><a href="../id474300/index.html">Cadangan yang andal, aman, dan serbaguna untuk U2F</a></li>
<li><a href="../id474302/index.html">Cara menulis skrip uji kegunaan aplikasi yang efektif</a></li>
<li><a href="../id474306/index.html">Buat gaya penunjuk, fokus, dan status aktif berbeda.</a></li>
<li><a href="../id474310/index.html">Apakah ada angka acak di CSS?</a></li>
<li><a href="../id474312/index.html">Menginstal GUI pada Windows Server Core</a></li>
<li><a href="../id474316/index.html">Mobil listrik buatan rumah-bagian 1. Bagaimana semuanya dimulai dan bagaimana saya mencetak 1.000.000 tampilan di youtube</a></li>
<li><a href="../id474318/index.html">Apa itu tabel tabel virtual?</a></li>
<li><a href="../id474320/index.html">Krisis Komunitas DDD</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>