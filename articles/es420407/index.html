<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍳 🗻 👼🏼 C no es un lenguaje de bajo nivel 👋🏼 👲🏽 🍘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Su computadora no es una versión rápida de PDP-11 
 Hola Habr! 

 Mi nombre es Anton Dovgal, soy desarrollador C (y no solo) en Badoo. 

 Me encontré ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C no es un lenguaje de bajo nivel</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/420407/"><img src="https://habrastorage.org/webt/8n/tg/og/8ntgogmuur_qld0ho0701jc83du.jpeg"><br><br><h3>  <i>Su computadora no es una versión rápida de PDP-11</i> </h3><br>  Hola Habr! <br><br>  Mi nombre es Anton Dovgal, soy desarrollador C (y no solo) en Badoo. <br><br>  Me encontré con un artículo de David Chiznell, investigador de la Universidad de Cambridge, en el que cuestiona la opinión generalmente aceptada de que el C es un lenguaje de bajo nivel, y sus argumentos me parecieron lo suficientemente interesantes. <br><br>  A la luz de las vulnerabilidades descubiertas recientemente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Meltdown y Spectre</a> deberían tomarse el tiempo para descubrir las razones de su aparición.  Ambas vulnerabilidades explotaron la ejecución especulativa de instrucciones por parte de los procesadores y permitieron que un atacante recibiera resultados a través de canales de terceros.  Se agregaron vulnerabilidades en los procesadores, junto con varios otros, para que los programadores de C continúen creyendo que programan en un lenguaje de bajo nivel, aunque este no ha sido el caso durante décadas. <br><br>  Los fabricantes de procesadores no están solos en esto.  Los desarrolladores del compilador C / C ++ también han contribuido. <br><a name="habracut"></a><br><h2>  ¿Qué es un lenguaje de bajo nivel? </h2><br>  El informático estadounidense y primer ganador del Premio Turing, Alan Perlis, dio la siguiente definición: <br><blockquote>  "Un lenguaje de programación es de bajo nivel si los programas escritos en él requieren atención a lo no esencial". </blockquote><br>  Aunque esta definición se refiere a C, no proporciona una comprensión de lo que la gente quiere ver en un lenguaje de bajo nivel.  Varias propiedades hacen que las personas consideren que el idioma es bajo.  Imagine una escala de lenguajes de programación con ensamblador en un extremo y una interfaz para una computadora Enterprise en el otro.  Los idiomas de bajo nivel están más cerca del hierro, mientras que los idiomas de alto nivel están más cerca de cómo piensan las personas. <br><br>  Para estar "más cerca del hardware", el lenguaje debe proporcionar abstracciones que coincidan con las abstracciones de la plataforma de destino.  Es fácil demostrar que C era un lenguaje de bajo nivel en PDP-11.  La ejecución secuencial de programas, un espacio de direcciones planas, incluso operadores de pre y post incremento, se adapta perfectamente a los modos de direccionamiento PDP-11. <br><br><h2>  Emuladores rápidos de PDP-11 </h2><br>  La razón clave de las vulnerabilidades de Spectre y Meltdown es que los creadores de los procesadores no solo fabricaron procesadores rápidos, sino que también hicieron procesadores rápidos con la interfaz PDP-11.  Esto es importante porque permite a los programadores de C seguir creyendo que su lenguaje está cerca del hardware. <br><br>  El código C proporciona un autómata abstracto secuencial en su mayoría (hasta C11, es completamente secuencial, si se excluyen las extensiones no estándar).  Crear un nuevo hilo es una llamada a una función de biblioteca, una operación que es bastante costosa.  Por lo tanto, los procesadores, que desean continuar ejecutando el código C, confían en el paralelismo de nivel de instrucción (ILP).  Analizan las operaciones vecinas y realizan operaciones independientes en paralelo.  Esto complica enormemente los procesadores y conduce a un mayor consumo de energía, pero permite que los programadores escriban principalmente código secuencial.  En contraste, los procesadores gráficos (GPU) logran un alto rendimiento de otra manera: requieren escribir programas paralelos. <br><br>  La alta concurrencia en el nivel de comando es la causa directa de Spectre y Meltdown.  El procesador Intel moderno ejecuta hasta 180 instrucciones simultáneamente (a diferencia de la máquina abstracta C secuencial, que espera que la instrucción anterior se ejecute antes de que comience la siguiente).  Una heurística típica del código C muestra que hay una rama en promedio por cada siete instrucciones.  Si desea mantener completa la canalización de instrucciones, debe adivinar las siguientes 25 ramas.  Esto, a su vez, agrega complejidad: el procesador primero calcula la rama adivinada incorrectamente y luego arroja los resultados de los cálculos, lo que afecta negativamente el consumo de energía.  Estos datos arrojados tienen resultados indirectos visibles, que se utilizaron en los ataques Spectre y Meltdown. <br><br>  Cambiar el nombre de los registros consume mucha energía y área de chips en los procesadores modernos.  No se puede apagar o reducir su consumo de energía, lo que lo hace inconveniente en la era del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">silicio oscuro</a> , cuando los transistores son bajos, pero los transistores involucrados son un recurso valioso.  Este dispositivo está ausente en la GPU, donde la concurrencia se logra mediante el uso de subprocesos en lugar de intentar ejecutar en paralelo código inicialmente secuencial.  Si las instrucciones no tienen dependencias que deban reconstruirse, entonces tampoco es necesario cambiar el nombre de los registros. <br><br>  Considere otra parte fundamental del diseño de C: memoria plana.  No ha existido en un par de décadas.  Un procesador moderno a menudo tiene tres niveles de almacenamiento en caché entre registros y memoria principal, lo que reduce el tiempo que lleva acceder a este último. <br><br>  El caché está oculto para el programador y, por lo tanto, es inaccesible desde C. El uso efectivo del caché es una de las formas de acelerar la ejecución del código en un procesador moderno, sin embargo, está completamente oculto de la máquina abstracta y los programadores se ven obligados a confiar en el conocimiento de los detalles de la implementación del caché (por ejemplo, que dos alineados de 64 bits los valores pueden aparecer en una línea de la caché) para escribir código eficiente. <br><br><h2>  Optimización C </h2><br>  Una de las características comunes atribuidas a los lenguajes de bajo nivel es la velocidad.  En particular, deberían ser fáciles de traducir a código rápido sin un compilador complicado.  Los defensores de C a menudo ignoran el argumento de que un compilador lo suficientemente inteligente puede acelerar el lenguaje cuando hablan de otros lenguajes. <br><br>  Desafortunadamente, usando una traducción simple, no puede obtener un código rápido de C. <br>  Los arquitectos de procesadores hacen esfuerzos heroicos para crear chips que puedan ejecutar código C rápidamente.  Pero los niveles de rendimiento que los programadores esperan ver se logran solo con la ayuda de optimizaciones increíblemente complejas realizadas por el compilador. <br>  El compilador de Clang (incluidas las partes correspondientes de LLVM) tiene aproximadamente 2 millones de líneas de código.  Para el análisis y la transformación del código, que son necesarios para acelerar C, se necesitan alrededor de 200,000 líneas de código (excluyendo comentarios y líneas en blanco). <br><br>  Por ejemplo, para procesar una gran cantidad de datos en C, debe escribir un bucle que procese cada elemento secuencialmente.  Para la ejecución óptima de este ciclo en un procesador moderno, el compilador debe determinar que las iteraciones del ciclo son independientes entre sí.  La palabra clave restrictiva puede ayudar en este caso: asegura que las escrituras en un puntero no interferirán con la lectura de otro puntero.  Esta información en C es mucho más limitada que en un lenguaje como Fortran, que es la razón principal por la que C no pudo sacarla de la informática de alto rendimiento. <br><br>  Después de que el compilador determina que las iteraciones son independientes entre sí, el siguiente paso es un intento de vectorizar el resultado, porque el rendimiento de los procesadores modernos es de cuatro a ocho veces mayor para el código vectorizado que para el código escalar.  Un lenguaje de bajo nivel para tales procesadores tendría sus propios tipos de vectores de longitud arbitraria.  Tales tipos están presentes en la representación LLVM intermedia, porque siempre es más fácil dividir operaciones grandes con vectores en varias pequeñas que construir operaciones vectoriales más grandes. <br><br>  En este punto, los optimizadores tienen que lidiar con las reglas de memoria C. C asegura que las estructuras con el mismo prefijo se puedan usar indistintamente y proporciona acceso a campos de estructuras de campo compensado en el lenguaje.  Esto significa que el compilador no puede cambiar el orden de los campos en la estructura o agregar una alineación para mejorar la vectorización (por ejemplo, transformar una estructura de matrices en una matriz de estructuras o viceversa).  Esto generalmente no es un problema en lenguajes de bajo nivel, donde es posible controlar la ubicación de los campos en la estructura, pero hace que la tarea de acelerar C. sea más difícil. <br><br>  C también requiere alineación al final de la estructura, ya que asegura que no haya alineación en las matrices.  La alineación es una parte bastante compleja de la especificación C, que interactúa pobremente con otras partes del lenguaje.  Por ejemplo, debería poder comparar dos estructuras utilizando el método de comparación sin tipo (es decir, la función memcmp ()), por lo que la copia de la estructura también debe estar alineada.  En algunos casos, copiar la alineación lleva un tiempo considerable. <br><br>  Considere las dos optimizaciones básicas que produce el compilador de C: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SROA</a> (reemplazo escalar de agregados, reemplazo escalar de agregados) y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">apertura de bucle</a> . <br><br>  SROA está tratando de reemplazar estructuras y matrices de tamaño fijo con variables separadas.  Esto permite que el compilador procese el acceso a ellos independientemente uno del otro e ignore la operación, si es obvio que su resultado no se utiliza.  En algunos casos, el efecto indirecto de esta optimización es eliminar la alineación. <br><br>  La segunda optimización, abrir el bucle, convierte el bucle con la condición en una condición con diferentes bucles en ambas ramas.  Esto cambia el orden de ejecución en oposición a la afirmación de que el programador sabe lo que se ejecutará en un lenguaje de bajo nivel.  Y esto también crea serios problemas con la forma en que C maneja las variables indefinidas y el comportamiento indefinido. <br><br>  En C, una variable no inicializada tiene un valor indefinido, que puede ser diferente con cada llamada.  Esto es importante porque le permite implementar el reciclaje diferido de las páginas de memoria.  Por ejemplo, en FreeBSD, la implementación de malloc () le dice al sistema que las páginas ya no están en uso, y el sistema usa la primera entrada de la página como prueba de que este no es el caso.  Apelar a la memoria recién asignada puede obtener el valor anterior, luego el sistema operativo puede reutilizar la página de memoria y luego reemplazarla con una página llena de ceros la próxima vez que escriba en otro lugar de la página.  La segunda llamada al mismo lugar en la página obtendrá un valor cero. <br><br>  Si la condición usa un valor indefinido, entonces el resultado tampoco está definido; cualquier cosa puede suceder.  Imagine una optimización de bucle abierto donde un bucle se ejecuta cero veces.  En el original, todo el bucle es código muerto.  En la versión abierta, ahora hay una condición con una variable que puede no inicializarse. <br>  Como resultado, el código muerto se puede convertir a un comportamiento indefinido.  Esta es solo una de las muchas optimizaciones que, al explorar más a fondo la semántica de C, resultan poco confiables. <br><br>  Al final, puede hacer que el código C se ejecute rápidamente, pero solo después de pasar miles de años hombre creando un compilador lo suficientemente inteligente.  Pero esto solo es posible si se violan ciertas reglas del lenguaje.  Los creadores del compilador permiten a los programadores de C imaginar que escriben código que está "cerca del hardware", pero tienen que generar código de máquina que se comporte de manera diferente para que los programadores sigan creyendo que escriben en un lenguaje rápido. <br><br><h2>  Entendiendo C </h2><br>  Uno de los atributos básicos de un lenguaje de bajo nivel es que los programadores pueden comprender fácilmente cómo se transfiere una máquina de lenguaje abstracto a una máquina física.  Este fue definitivamente el caso en PDP-11, donde las expresiones C se tradujeron en una o dos instrucciones.  Del mismo modo, el compilador colocó variables en ranuras de pila y convirtió los tipos simples en comprensibles para PDP-11. <br><br>  Desde entonces, las implementaciones de C se han vuelto mucho más complicadas: para mantener la ilusión de que C se transfiere fácilmente a una plataforma de hardware y se ejecuta rápidamente.  En 2015, una encuesta entre programadores de C, autores de compiladores y miembros del comité de estandarización mostró que había <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">problemas para comprender C.</a>  Por ejemplo, este lenguaje permite que una implementación agregue alineación a las estructuras (pero no a las matrices) para garantizar que todos los campos estén correctamente alineados para la plataforma de destino.  Si llena esta estructura con ceros y luego especifica un valor para algunos campos, ¿habrá ceros en los bits de alineación?  Según la encuesta, el 36% estaba seguro de que lo haría, y el 29% no sabía la respuesta.  Dependiendo del compilador y el nivel de optimización, esto puede ser cierto (o no). <br><br>  Este es un ejemplo bastante trivial, pero muchos programadores dan la respuesta incorrecta o no pueden responder en absoluto. <br><br>  Si agrega punteros, la semántica de C se vuelve aún más confusa.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El modelo BCPL</a> era bastante simple: todos los significados son palabras.  Cada palabra es datos o una dirección en la memoria.  La memoria es una matriz plana de celdas indexadas por dirección. <br><br>  El Modelo C permite la implementación para diferentes plataformas, incluidas las arquitecturas segmentadas, donde el puntero puede consistir en ID de segmentos y compensaciones, así como máquinas virtuales con un recolector de basura.  La especificación C restringe las operaciones de puntero permitidas para evitar problemas con dichos sistemas.  La respuesta al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Informe de defectos 260</a> menciona el origen del puntero: <br><blockquote>  “Las implementaciones pueden seguir el origen de un conjunto de bits y manejar aquellos que contienen un valor indefinido de manera diferente a los que contienen uno específico.  "Pueden manejar punteros de manera diferente dependiendo de su origen, incluso si son iguales en términos de su valor de bit". </blockquote><br>  Desafortunadamente, la palabra "origen" falta en la especificación C11, por lo que los compiladores deciden por sí mismos lo que significa.  GCC y Clang, por ejemplo, difieren en si el puntero que se convirtió al entero y viceversa conserva su origen.  Los compiladores pueden decidir que dos punteros a los resultados de malloc () siempre dan un resultado negativo al comparar, incluso si apuntan a la misma dirección. <br><br>  Estos malentendidos no son puramente académicos.  Por ejemplo, ya se han observado vulnerabilidades, que fueron el resultado de desbordar un entero con signo (comportamiento indefinido en C) o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">desreferenciar un puntero antes de verificar si es NULL</a> , a pesar de que se le dijo al compilador que el puntero no podía ser NULL. <br><br>  Si existen tales problemas, es difícil esperar que un programador entienda completamente cómo un programa en C se traduce a la arquitectura apropiada. <br><br><h2>  Introducir un procesador no para C </h2><br>  Los parches propuestos para proteger contra Specter y Meltdown causan una degradación severa del rendimiento, anulando todos los logros de microarquitectura en la última década.  Quizás sea hora de dejar de pensar en cómo hacer que el código C sea más rápido y, en cambio, pensar en nuevos modelos de programación en procesadores diseñados para la velocidad. <br><br>  Hay muchos ejemplos de arquitecturas que no se han centrado en el código C tradicional y de las cuales pueden inspirarse.  Por ejemplo, los procesadores orientados a subprocesos múltiples como Sun / Oracle UltraSPARC Tx no requieren tanta caché para mantener ocupados sus actuadores.  Los procesadores de investigación han ampliado este concepto a una gran cantidad de subprocesos planificados por hardware.  La idea clave es que, con suficientes subprocesos, el procesador puede pausar aquellos subprocesos que están esperando datos y llenar los actuadores con instrucciones de otros subprocesos.  El problema es que los programas C generalmente tienen muy pocos hilos. <br><br>  El SVE de ARM (Extensiones de vectores escalares, extensiones de vectores escalares) es otro trabajo similar de Berkeley, que ofrece un vistazo a la interfaz mejorada entre el programa y el hardware.  Los bloques de vectorización regulares implementan operaciones con vectores de un tamaño fijo y esperan que el compilador adapte el algoritmo al tamaño especificado.  Por el contrario, la interfaz SVE solicita al programador que describa independientemente el nivel de paralelismo y espera que el hardware lo adapte a los actuadores disponibles.  Usar esto en C es difícil porque el vectorizador automático necesita calcular el paralelismo basado en los bucles del código. <br><br>  Los cachés son grandes, pero esta no es la única razón de su complejidad.  El protocolo de soporte de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">coherencia de caché</a> es uno de los componentes más complejos de un procesador moderno.  La mayor parte de la dificultad proviene de tener que mantener un lenguaje en el que los datos se puedan compartir y mutar.  Como ejemplo opuesto, podemos usar una máquina abstracta de estilo Erlang, donde cada objeto es local o inmutable.  El protocolo de coherencia de caché para dicho sistema tendría solo dos casos: datos mutables y datos compartidos.  La memoria caché de la secuencia del programa que se transfirió a otro procesador debe deshabilitarse explícitamente, pero esta es una operación relativamente rara. <br><br>  Los objetos inmutables pueden simplificar aún más las memorias caché y abaratar algunas operaciones.  En un proyecto de Maxwell de Sun Labs, se observó que los objetos en el caché y los objetos creados recientemente son casi siempre los mismos.  Si los objetos mueren antes de ser excluidos de la memoria caché, entonces no puede escribirlos en la memoria principal y, por lo tanto, ahorrar consumo de energía.  El proyecto Maxwell propuso un recolector de basura que funcionaba en el caché y le permitía reciclar rápidamente la memoria.  Con los objetos inmutables en el montón y la pila mutable, el recolector de basura se convierte en una máquina de estado muy simple, que se implementa fácilmente en el hardware y le permite utilizar de manera eficiente un caché relativamente pequeño. <br><br>  Un procesador que esté diseñado únicamente para la velocidad, y no para el equilibrio entre velocidad y compatibilidad con C, probablemente debería admitir una gran cantidad de subprocesos, tener grandes bloques de vectorización y un modelo de memoria más simple.  Será difícil ejecutar el código C en dicho procesador, por lo tanto, dado el volumen de código C antiguo en el mundo, es poco probable que tenga éxito comercial. <br><br>  En el campo del desarrollo de software, existe el mito de que la programación paralela es difícil.  Alan Kay se sorprendería mucho al escuchar esto: les enseñó a los niños a usar el modelo de actor, con el que escribieron programas en más de 200 transmisiones.  Esto también es desconocido para los programadores de Erlang, que a menudo escriben programas con miles de componentes paralelos.  Es más correcto decir que la programación paralela es difícil en un lenguaje con una máquina abstracta como C. Y si prestas atención al predominio del hardware paralelo (desde procesadores multinúcleo a GPU multinúcleo), esta es solo otra forma de decir que C no es adecuado para hardware moderno proporcionando. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es420407/">https://habr.com/ru/post/es420407/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es420391/index.html">Salarios de TI a mediados de 2018</a></li>
<li><a href="../es420393/index.html">PHP, YII2 y la formación de grandes archivos de Excel</a></li>
<li><a href="../es420395/index.html">Tabletas "gratis" para prisioneros, nada gratis</a></li>
<li><a href="../es420397/index.html">Los científicos han encontrado una manera de revertir el proceso de envejecimiento de las células</a></li>
<li><a href="../es420405/index.html">Investigando el proceso de ventas de TI</a></li>
<li><a href="../es420409/index.html">Aprende OpenGL. Lección 5.7 - HDR</a></li>
<li><a href="../es420413/index.html">SQLite y NW.js: instrucciones paso a paso para crear fuertes amistades</a></li>
<li><a href="../es420415/index.html">Todo lo que quería saber sobre probar adaptadores de Wi-Fi, pero tenía miedo de preguntar</a></li>
<li><a href="../es420419/index.html">Corredores para aquellos a quienes les gusta la humillación o cómo cambiamos y modificamos PixJam</a></li>
<li><a href="../es420423/index.html">Problemas de interfaz de cruce de tierra</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>