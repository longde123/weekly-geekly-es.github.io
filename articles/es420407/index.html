<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç≥ üóª üëºüèº C no es un lenguaje de bajo nivel üëãüèº üë≤üèΩ üçò</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Su computadora no es una versi√≥n r√°pida de PDP-11 
 Hola Habr! 

 Mi nombre es Anton Dovgal, soy desarrollador C (y no solo) en Badoo. 

 Me encontr√© ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C no es un lenguaje de bajo nivel</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/420407/"><img src="https://habrastorage.org/webt/8n/tg/og/8ntgogmuur_qld0ho0701jc83du.jpeg"><br><br><h3>  <i>Su computadora no es una versi√≥n r√°pida de PDP-11</i> </h3><br>  Hola Habr! <br><br>  Mi nombre es Anton Dovgal, soy desarrollador C (y no solo) en Badoo. <br><br>  Me encontr√© con un art√≠culo de David Chiznell, investigador de la Universidad de Cambridge, en el que cuestiona la opini√≥n generalmente aceptada de que el C es un lenguaje de bajo nivel, y sus argumentos me parecieron lo suficientemente interesantes. <br><br>  A la luz de las vulnerabilidades descubiertas recientemente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Meltdown y Spectre</a> deber√≠an tomarse el tiempo para descubrir las razones de su aparici√≥n.  Ambas vulnerabilidades explotaron la ejecuci√≥n especulativa de instrucciones por parte de los procesadores y permitieron que un atacante recibiera resultados a trav√©s de canales de terceros.  Se agregaron vulnerabilidades en los procesadores, junto con varios otros, para que los programadores de C contin√∫en creyendo que programan en un lenguaje de bajo nivel, aunque este no ha sido el caso durante d√©cadas. <br><br>  Los fabricantes de procesadores no est√°n solos en esto.  Los desarrolladores del compilador C / C ++ tambi√©n han contribuido. <br><a name="habracut"></a><br><h2>  ¬øQu√© es un lenguaje de bajo nivel? </h2><br>  El inform√°tico estadounidense y primer ganador del Premio Turing, Alan Perlis, dio la siguiente definici√≥n: <br><blockquote>  "Un lenguaje de programaci√≥n es de bajo nivel si los programas escritos en √©l requieren atenci√≥n a lo no esencial". </blockquote><br>  Aunque esta definici√≥n se refiere a C, no proporciona una comprensi√≥n de lo que la gente quiere ver en un lenguaje de bajo nivel.  Varias propiedades hacen que las personas consideren que el idioma es bajo.  Imagine una escala de lenguajes de programaci√≥n con ensamblador en un extremo y una interfaz para una computadora Enterprise en el otro.  Los idiomas de bajo nivel est√°n m√°s cerca del hierro, mientras que los idiomas de alto nivel est√°n m√°s cerca de c√≥mo piensan las personas. <br><br>  Para estar "m√°s cerca del hardware", el lenguaje debe proporcionar abstracciones que coincidan con las abstracciones de la plataforma de destino.  Es f√°cil demostrar que C era un lenguaje de bajo nivel en PDP-11.  La ejecuci√≥n secuencial de programas, un espacio de direcciones planas, incluso operadores de pre y post incremento, se adapta perfectamente a los modos de direccionamiento PDP-11. <br><br><h2>  Emuladores r√°pidos de PDP-11 </h2><br>  La raz√≥n clave de las vulnerabilidades de Spectre y Meltdown es que los creadores de los procesadores no solo fabricaron procesadores r√°pidos, sino que tambi√©n hicieron procesadores r√°pidos con la interfaz PDP-11.  Esto es importante porque permite a los programadores de C seguir creyendo que su lenguaje est√° cerca del hardware. <br><br>  El c√≥digo C proporciona un aut√≥mata abstracto secuencial en su mayor√≠a (hasta C11, es completamente secuencial, si se excluyen las extensiones no est√°ndar).  Crear un nuevo hilo es una llamada a una funci√≥n de biblioteca, una operaci√≥n que es bastante costosa.  Por lo tanto, los procesadores, que desean continuar ejecutando el c√≥digo C, conf√≠an en el paralelismo de nivel de instrucci√≥n (ILP).  Analizan las operaciones vecinas y realizan operaciones independientes en paralelo.  Esto complica enormemente los procesadores y conduce a un mayor consumo de energ√≠a, pero permite que los programadores escriban principalmente c√≥digo secuencial.  En contraste, los procesadores gr√°ficos (GPU) logran un alto rendimiento de otra manera: requieren escribir programas paralelos. <br><br>  La alta concurrencia en el nivel de comando es la causa directa de Spectre y Meltdown.  El procesador Intel moderno ejecuta hasta 180 instrucciones simult√°neamente (a diferencia de la m√°quina abstracta C secuencial, que espera que la instrucci√≥n anterior se ejecute antes de que comience la siguiente).  Una heur√≠stica t√≠pica del c√≥digo C muestra que hay una rama en promedio por cada siete instrucciones.  Si desea mantener completa la canalizaci√≥n de instrucciones, debe adivinar las siguientes 25 ramas.  Esto, a su vez, agrega complejidad: el procesador primero calcula la rama adivinada incorrectamente y luego arroja los resultados de los c√°lculos, lo que afecta negativamente el consumo de energ√≠a.  Estos datos arrojados tienen resultados indirectos visibles, que se utilizaron en los ataques Spectre y Meltdown. <br><br>  Cambiar el nombre de los registros consume mucha energ√≠a y √°rea de chips en los procesadores modernos.  No se puede apagar o reducir su consumo de energ√≠a, lo que lo hace inconveniente en la era del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">silicio oscuro</a> , cuando los transistores son bajos, pero los transistores involucrados son un recurso valioso.  Este dispositivo est√° ausente en la GPU, donde la concurrencia se logra mediante el uso de subprocesos en lugar de intentar ejecutar en paralelo c√≥digo inicialmente secuencial.  Si las instrucciones no tienen dependencias que deban reconstruirse, entonces tampoco es necesario cambiar el nombre de los registros. <br><br>  Considere otra parte fundamental del dise√±o de C: memoria plana.  No ha existido en un par de d√©cadas.  Un procesador moderno a menudo tiene tres niveles de almacenamiento en cach√© entre registros y memoria principal, lo que reduce el tiempo que lleva acceder a este √∫ltimo. <br><br>  El cach√© est√° oculto para el programador y, por lo tanto, es inaccesible desde C. El uso efectivo del cach√© es una de las formas de acelerar la ejecuci√≥n del c√≥digo en un procesador moderno, sin embargo, est√° completamente oculto de la m√°quina abstracta y los programadores se ven obligados a confiar en el conocimiento de los detalles de la implementaci√≥n del cach√© (por ejemplo, que dos alineados de 64 bits los valores pueden aparecer en una l√≠nea de la cach√©) para escribir c√≥digo eficiente. <br><br><h2>  Optimizaci√≥n C </h2><br>  Una de las caracter√≠sticas comunes atribuidas a los lenguajes de bajo nivel es la velocidad.  En particular, deber√≠an ser f√°ciles de traducir a c√≥digo r√°pido sin un compilador complicado.  Los defensores de C a menudo ignoran el argumento de que un compilador lo suficientemente inteligente puede acelerar el lenguaje cuando hablan de otros lenguajes. <br><br>  Desafortunadamente, usando una traducci√≥n simple, no puede obtener un c√≥digo r√°pido de C. <br>  Los arquitectos de procesadores hacen esfuerzos heroicos para crear chips que puedan ejecutar c√≥digo C r√°pidamente.  Pero los niveles de rendimiento que los programadores esperan ver se logran solo con la ayuda de optimizaciones incre√≠blemente complejas realizadas por el compilador. <br>  El compilador de Clang (incluidas las partes correspondientes de LLVM) tiene aproximadamente 2 millones de l√≠neas de c√≥digo.  Para el an√°lisis y la transformaci√≥n del c√≥digo, que son necesarios para acelerar C, se necesitan alrededor de 200,000 l√≠neas de c√≥digo (excluyendo comentarios y l√≠neas en blanco). <br><br>  Por ejemplo, para procesar una gran cantidad de datos en C, debe escribir un bucle que procese cada elemento secuencialmente.  Para la ejecuci√≥n √≥ptima de este ciclo en un procesador moderno, el compilador debe determinar que las iteraciones del ciclo son independientes entre s√≠.  La palabra clave restrictiva puede ayudar en este caso: asegura que las escrituras en un puntero no interferir√°n con la lectura de otro puntero.  Esta informaci√≥n en C es mucho m√°s limitada que en un lenguaje como Fortran, que es la raz√≥n principal por la que C no pudo sacarla de la inform√°tica de alto rendimiento. <br><br>  Despu√©s de que el compilador determina que las iteraciones son independientes entre s√≠, el siguiente paso es un intento de vectorizar el resultado, porque el rendimiento de los procesadores modernos es de cuatro a ocho veces mayor para el c√≥digo vectorizado que para el c√≥digo escalar.  Un lenguaje de bajo nivel para tales procesadores tendr√≠a sus propios tipos de vectores de longitud arbitraria.  Tales tipos est√°n presentes en la representaci√≥n LLVM intermedia, porque siempre es m√°s f√°cil dividir operaciones grandes con vectores en varias peque√±as que construir operaciones vectoriales m√°s grandes. <br><br>  En este punto, los optimizadores tienen que lidiar con las reglas de memoria C. C asegura que las estructuras con el mismo prefijo se puedan usar indistintamente y proporciona acceso a campos de estructuras de campo compensado en el lenguaje.  Esto significa que el compilador no puede cambiar el orden de los campos en la estructura o agregar una alineaci√≥n para mejorar la vectorizaci√≥n (por ejemplo, transformar una estructura de matrices en una matriz de estructuras o viceversa).  Esto generalmente no es un problema en lenguajes de bajo nivel, donde es posible controlar la ubicaci√≥n de los campos en la estructura, pero hace que la tarea de acelerar C. sea m√°s dif√≠cil. <br><br>  C tambi√©n requiere alineaci√≥n al final de la estructura, ya que asegura que no haya alineaci√≥n en las matrices.  La alineaci√≥n es una parte bastante compleja de la especificaci√≥n C, que interact√∫a pobremente con otras partes del lenguaje.  Por ejemplo, deber√≠a poder comparar dos estructuras utilizando el m√©todo de comparaci√≥n sin tipo (es decir, la funci√≥n memcmp ()), por lo que la copia de la estructura tambi√©n debe estar alineada.  En algunos casos, copiar la alineaci√≥n lleva un tiempo considerable. <br><br>  Considere las dos optimizaciones b√°sicas que produce el compilador de C: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SROA</a> (reemplazo escalar de agregados, reemplazo escalar de agregados) y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">apertura de bucle</a> . <br><br>  SROA est√° tratando de reemplazar estructuras y matrices de tama√±o fijo con variables separadas.  Esto permite que el compilador procese el acceso a ellos independientemente uno del otro e ignore la operaci√≥n, si es obvio que su resultado no se utiliza.  En algunos casos, el efecto indirecto de esta optimizaci√≥n es eliminar la alineaci√≥n. <br><br>  La segunda optimizaci√≥n, abrir el bucle, convierte el bucle con la condici√≥n en una condici√≥n con diferentes bucles en ambas ramas.  Esto cambia el orden de ejecuci√≥n en oposici√≥n a la afirmaci√≥n de que el programador sabe lo que se ejecutar√° en un lenguaje de bajo nivel.  Y esto tambi√©n crea serios problemas con la forma en que C maneja las variables indefinidas y el comportamiento indefinido. <br><br>  En C, una variable no inicializada tiene un valor indefinido, que puede ser diferente con cada llamada.  Esto es importante porque le permite implementar el reciclaje diferido de las p√°ginas de memoria.  Por ejemplo, en FreeBSD, la implementaci√≥n de malloc () le dice al sistema que las p√°ginas ya no est√°n en uso, y el sistema usa la primera entrada de la p√°gina como prueba de que este no es el caso.  Apelar a la memoria reci√©n asignada puede obtener el valor anterior, luego el sistema operativo puede reutilizar la p√°gina de memoria y luego reemplazarla con una p√°gina llena de ceros la pr√≥xima vez que escriba en otro lugar de la p√°gina.  La segunda llamada al mismo lugar en la p√°gina obtendr√° un valor cero. <br><br>  Si la condici√≥n usa un valor indefinido, entonces el resultado tampoco est√° definido; cualquier cosa puede suceder.  Imagine una optimizaci√≥n de bucle abierto donde un bucle se ejecuta cero veces.  En el original, todo el bucle es c√≥digo muerto.  En la versi√≥n abierta, ahora hay una condici√≥n con una variable que puede no inicializarse. <br>  Como resultado, el c√≥digo muerto se puede convertir a un comportamiento indefinido.  Esta es solo una de las muchas optimizaciones que, al explorar m√°s a fondo la sem√°ntica de C, resultan poco confiables. <br><br>  Al final, puede hacer que el c√≥digo C se ejecute r√°pidamente, pero solo despu√©s de pasar miles de a√±os hombre creando un compilador lo suficientemente inteligente.  Pero esto solo es posible si se violan ciertas reglas del lenguaje.  Los creadores del compilador permiten a los programadores de C imaginar que escriben c√≥digo que est√° "cerca del hardware", pero tienen que generar c√≥digo de m√°quina que se comporte de manera diferente para que los programadores sigan creyendo que escriben en un lenguaje r√°pido. <br><br><h2>  Entendiendo C </h2><br>  Uno de los atributos b√°sicos de un lenguaje de bajo nivel es que los programadores pueden comprender f√°cilmente c√≥mo se transfiere una m√°quina de lenguaje abstracto a una m√°quina f√≠sica.  Este fue definitivamente el caso en PDP-11, donde las expresiones C se tradujeron en una o dos instrucciones.  Del mismo modo, el compilador coloc√≥ variables en ranuras de pila y convirti√≥ los tipos simples en comprensibles para PDP-11. <br><br>  Desde entonces, las implementaciones de C se han vuelto mucho m√°s complicadas: para mantener la ilusi√≥n de que C se transfiere f√°cilmente a una plataforma de hardware y se ejecuta r√°pidamente.  En 2015, una encuesta entre programadores de C, autores de compiladores y miembros del comit√© de estandarizaci√≥n mostr√≥ que hab√≠a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">problemas para comprender C.</a>  Por ejemplo, este lenguaje permite que una implementaci√≥n agregue alineaci√≥n a las estructuras (pero no a las matrices) para garantizar que todos los campos est√©n correctamente alineados para la plataforma de destino.  Si llena esta estructura con ceros y luego especifica un valor para algunos campos, ¬øhabr√° ceros en los bits de alineaci√≥n?  Seg√∫n la encuesta, el 36% estaba seguro de que lo har√≠a, y el 29% no sab√≠a la respuesta.  Dependiendo del compilador y el nivel de optimizaci√≥n, esto puede ser cierto (o no). <br><br>  Este es un ejemplo bastante trivial, pero muchos programadores dan la respuesta incorrecta o no pueden responder en absoluto. <br><br>  Si agrega punteros, la sem√°ntica de C se vuelve a√∫n m√°s confusa.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El modelo BCPL</a> era bastante simple: todos los significados son palabras.  Cada palabra es datos o una direcci√≥n en la memoria.  La memoria es una matriz plana de celdas indexadas por direcci√≥n. <br><br>  El Modelo C permite la implementaci√≥n para diferentes plataformas, incluidas las arquitecturas segmentadas, donde el puntero puede consistir en ID de segmentos y compensaciones, as√≠ como m√°quinas virtuales con un recolector de basura.  La especificaci√≥n C restringe las operaciones de puntero permitidas para evitar problemas con dichos sistemas.  La respuesta al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Informe de defectos 260</a> menciona el origen del puntero: <br><blockquote>  ‚ÄúLas implementaciones pueden seguir el origen de un conjunto de bits y manejar aquellos que contienen un valor indefinido de manera diferente a los que contienen uno espec√≠fico.  "Pueden manejar punteros de manera diferente dependiendo de su origen, incluso si son iguales en t√©rminos de su valor de bit". </blockquote><br>  Desafortunadamente, la palabra "origen" falta en la especificaci√≥n C11, por lo que los compiladores deciden por s√≠ mismos lo que significa.  GCC y Clang, por ejemplo, difieren en si el puntero que se convirti√≥ al entero y viceversa conserva su origen.  Los compiladores pueden decidir que dos punteros a los resultados de malloc () siempre dan un resultado negativo al comparar, incluso si apuntan a la misma direcci√≥n. <br><br>  Estos malentendidos no son puramente acad√©micos.  Por ejemplo, ya se han observado vulnerabilidades, que fueron el resultado de desbordar un entero con signo (comportamiento indefinido en C) o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">desreferenciar un puntero antes de verificar si es NULL</a> , a pesar de que se le dijo al compilador que el puntero no pod√≠a ser NULL. <br><br>  Si existen tales problemas, es dif√≠cil esperar que un programador entienda completamente c√≥mo un programa en C se traduce a la arquitectura apropiada. <br><br><h2>  Introducir un procesador no para C </h2><br>  Los parches propuestos para proteger contra Specter y Meltdown causan una degradaci√≥n severa del rendimiento, anulando todos los logros de microarquitectura en la √∫ltima d√©cada.  Quiz√°s sea hora de dejar de pensar en c√≥mo hacer que el c√≥digo C sea m√°s r√°pido y, en cambio, pensar en nuevos modelos de programaci√≥n en procesadores dise√±ados para la velocidad. <br><br>  Hay muchos ejemplos de arquitecturas que no se han centrado en el c√≥digo C tradicional y de las cuales pueden inspirarse.  Por ejemplo, los procesadores orientados a subprocesos m√∫ltiples como Sun / Oracle UltraSPARC Tx no requieren tanta cach√© para mantener ocupados sus actuadores.  Los procesadores de investigaci√≥n han ampliado este concepto a una gran cantidad de subprocesos planificados por hardware.  La idea clave es que, con suficientes subprocesos, el procesador puede pausar aquellos subprocesos que est√°n esperando datos y llenar los actuadores con instrucciones de otros subprocesos.  El problema es que los programas C generalmente tienen muy pocos hilos. <br><br>  El SVE de ARM (Extensiones de vectores escalares, extensiones de vectores escalares) es otro trabajo similar de Berkeley, que ofrece un vistazo a la interfaz mejorada entre el programa y el hardware.  Los bloques de vectorizaci√≥n regulares implementan operaciones con vectores de un tama√±o fijo y esperan que el compilador adapte el algoritmo al tama√±o especificado.  Por el contrario, la interfaz SVE solicita al programador que describa independientemente el nivel de paralelismo y espera que el hardware lo adapte a los actuadores disponibles.  Usar esto en C es dif√≠cil porque el vectorizador autom√°tico necesita calcular el paralelismo basado en los bucles del c√≥digo. <br><br>  Los cach√©s son grandes, pero esta no es la √∫nica raz√≥n de su complejidad.  El protocolo de soporte de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">coherencia de cach√©</a> es uno de los componentes m√°s complejos de un procesador moderno.  La mayor parte de la dificultad proviene de tener que mantener un lenguaje en el que los datos se puedan compartir y mutar.  Como ejemplo opuesto, podemos usar una m√°quina abstracta de estilo Erlang, donde cada objeto es local o inmutable.  El protocolo de coherencia de cach√© para dicho sistema tendr√≠a solo dos casos: datos mutables y datos compartidos.  La memoria cach√© de la secuencia del programa que se transfiri√≥ a otro procesador debe deshabilitarse expl√≠citamente, pero esta es una operaci√≥n relativamente rara. <br><br>  Los objetos inmutables pueden simplificar a√∫n m√°s las memorias cach√© y abaratar algunas operaciones.  En un proyecto de Maxwell de Sun Labs, se observ√≥ que los objetos en el cach√© y los objetos creados recientemente son casi siempre los mismos.  Si los objetos mueren antes de ser excluidos de la memoria cach√©, entonces no puede escribirlos en la memoria principal y, por lo tanto, ahorrar consumo de energ√≠a.  El proyecto Maxwell propuso un recolector de basura que funcionaba en el cach√© y le permit√≠a reciclar r√°pidamente la memoria.  Con los objetos inmutables en el mont√≥n y la pila mutable, el recolector de basura se convierte en una m√°quina de estado muy simple, que se implementa f√°cilmente en el hardware y le permite utilizar de manera eficiente un cach√© relativamente peque√±o. <br><br>  Un procesador que est√© dise√±ado √∫nicamente para la velocidad, y no para el equilibrio entre velocidad y compatibilidad con C, probablemente deber√≠a admitir una gran cantidad de subprocesos, tener grandes bloques de vectorizaci√≥n y un modelo de memoria m√°s simple.  Ser√° dif√≠cil ejecutar el c√≥digo C en dicho procesador, por lo tanto, dado el volumen de c√≥digo C antiguo en el mundo, es poco probable que tenga √©xito comercial. <br><br>  En el campo del desarrollo de software, existe el mito de que la programaci√≥n paralela es dif√≠cil.  Alan Kay se sorprender√≠a mucho al escuchar esto: les ense√±√≥ a los ni√±os a usar el modelo de actor, con el que escribieron programas en m√°s de 200 transmisiones.  Esto tambi√©n es desconocido para los programadores de Erlang, que a menudo escriben programas con miles de componentes paralelos.  Es m√°s correcto decir que la programaci√≥n paralela es dif√≠cil en un lenguaje con una m√°quina abstracta como C. Y si prestas atenci√≥n al predominio del hardware paralelo (desde procesadores multin√∫cleo a GPU multin√∫cleo), esta es solo otra forma de decir que C no es adecuado para hardware moderno proporcionando. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es420407/">https://habr.com/ru/post/es420407/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es420391/index.html">Salarios de TI a mediados de 2018</a></li>
<li><a href="../es420393/index.html">PHP, YII2 y la formaci√≥n de grandes archivos de Excel</a></li>
<li><a href="../es420395/index.html">Tabletas "gratis" para prisioneros, nada gratis</a></li>
<li><a href="../es420397/index.html">Los cient√≠ficos han encontrado una manera de revertir el proceso de envejecimiento de las c√©lulas</a></li>
<li><a href="../es420405/index.html">Investigando el proceso de ventas de TI</a></li>
<li><a href="../es420409/index.html">Aprende OpenGL. Lecci√≥n 5.7 - HDR</a></li>
<li><a href="../es420413/index.html">SQLite y NW.js: instrucciones paso a paso para crear fuertes amistades</a></li>
<li><a href="../es420415/index.html">Todo lo que quer√≠a saber sobre probar adaptadores de Wi-Fi, pero ten√≠a miedo de preguntar</a></li>
<li><a href="../es420419/index.html">Corredores para aquellos a quienes les gusta la humillaci√≥n o c√≥mo cambiamos y modificamos PixJam</a></li>
<li><a href="../es420423/index.html">Problemas de interfaz de cruce de tierra</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>