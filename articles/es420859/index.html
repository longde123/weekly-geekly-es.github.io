<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•î üñêüèº üìå A la pregunta de Wirth y cadenas üë©üèæ‚Äçüíª üë©üèæ‚Äçüé® üå∫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Algoritmos + estructuras de datos = programas - Virt N. 
 "Tuvimos una maravillosa oportunidad de realizar un ejercicio t√°ctico peque√±o pero extremada...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>A la pregunta de Wirth y cadenas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420859/"><h2>  Algoritmos + estructuras de datos = programas - Virt N. </h2><br><img src="https://habrastorage.org/webt/00/wp/ch/00wpchad9zptu4pxyqszkymsin4.jpeg" align="left"><h3>  "Tuvimos una maravillosa oportunidad de realizar un ejercicio t√°ctico peque√±o pero extremadamente instructivo" </h3><br>  A pesar del primer ep√≠grafe de esta publicaci√≥n, me permito estar en desacuerdo con el autor e intentar mostrar que, en algunos casos, la elecci√≥n correcta de la estructura de datos puede ser m√°s significativa que la elecci√≥n correcta de los algoritmos.  Para ilustrar una tesis tan sediciosa, consideremos una tarea simple pero prometedora para estudiar el juego "Cadena". <br><a name="habracut"></a><br>  Primero, sobre las reglas del juego: dos jugadores juegan, la posici√≥n inicial consiste en N objetos ubicados cerca.  El siguiente movimiento es eliminar uno o dos objetos ubicados cerca (puede intentar dar una definici√≥n formal de "ubicaci√≥n cercana", pero es comprensible en un nivel intuitivo).  El jugador que retira el √∫ltimo objeto gana: el juego directo, o el que debe (no puede omitir el movimiento) recoger el √∫ltimo objeto, gana el juego inverso.  Dado que en esta versi√≥n de las reglas, un juego directo ser√° simplemente poco interesante (m√°s sobre eso m√°s adelante), se introduce una restricci√≥n adicional: solo se puede eliminar un objeto en el primer movimiento. <br><br>  En primer lugar, determinamos que el juego es finito, porque con cada movimiento el n√∫mero de objetos disminuye estrictamente y el juego termina cuando se alcanza el n√∫mero de objetos calculado por cero, por lo tanto, tenemos el derecho de contar con el √©xito en el estudio de este juego.  Adem√°s, es obvio que el juego no puede durar m√°s de N movimientos, recordemos este hecho. <br><br>  El estudio del juego consiste en determinar si para un n√∫mero inicial espec√≠fico de objetos el jugador que realiza el primer movimiento est√° ganando (ya que este es un juego con suma cero, de lo contrario est√° perdiendo) con un juego √≥ptimo en ambos lados y en qu√© n√∫mero m√≠nimo de movimientos se logra la ganancia (o por cu√°l es el n√∫mero m√°ximo de movimientos que la p√©rdida aleja). <br><br>  Para algunos de H, la respuesta es obvia: con un objeto, el primero gana un juego directo en un turno y tambi√©n pierde un juego inverso (P1 = 1, I1 = -1).  Con dos objetos, el primer jugador pierde en dos movimientos en un juego directo y gana en dos movimientos en sentido inverso (P2 = -2, I2 = 2), lo que puede dar lugar a una hip√≥tesis sobre la simplicidad de evaluar este juego, que se confirma por el caso de tres objetos (P2 = 3, I3 = -3).  Afortunadamente (de lo contrario, esta publicaci√≥n no se habr√≠a publicado), un juego con cuatro objetos cambia un poco la imagen (P4 = -4, pero I4 = -3), por lo que es realmente necesario investigar el juego. <br><br>  Para algunos de H y para un cierto tipo de juego, existen algoritmos heur√≠sticos que dan una recompensa garantizada.  Por ejemplo, para un juego directo con una H inicial extra√±a, se puede garantizar que ganas si quitas el objeto central con el primer movimiento y luego repites los movimientos del oponente usando un lugar central como eje de simetr√≠a, entonces tenemos la garant√≠a de recoger el √∫ltimo objeto y ganar.  La misma estrategia funcionar√≠a con un n√∫mero par de objetos, si no fuera por las restricciones en el primer movimiento, lo que hace que el juego no sea tan trivial.  En t√©rminos generales, el uso de estrategias sim√©tricas es una ocurrencia bastante com√∫n en los juegos de conteo, pero no una panacea, porque, por ejemplo, en nuestro juego inverso esta estrategia falla.  Cabe se√±alar que las heur√≠sticas dan un algoritmo ganador pero no dan una estimaci√≥n precisa de la posici√≥n, ya que puede haber estrategias que conduzcan a ganancias m√°s r√°pidas (este es el caso de este juego en particular). <br><br>  ¬øC√≥mo podemos dar una evaluaci√≥n del juego? Exactamente como recib√≠ las estimaciones anteriores para 1-4 objetos; el m√©todo se llama b√∫squeda exhaustiva de arriba a abajo; debemos considerar el √°rbol completo del juego, es decir, todos los movimientos posibles para ambos lados y evaluar cada posici√≥n, incluyendo fuente, de acuerdo con ciertas reglas.  Cabe se√±alar que la existencia de heur√≠sticas exitosas no nos garantiza una evaluaci√≥n precisa, ya que responde solo la primera mitad de la pregunta: qui√©n gana, pero no da el n√∫mero m√≠nimo requerido de movimientos. <br><br>  Esto significa que debemos construir un √°rbol de juego completo, pero antes de continuar con la construcci√≥n, debemos crear un modelo del objeto en estudio, en nuestro caso, el juego. <br><br>  ¬øPor qu√© me concentro en esta etapa? Porque no podemos explorar el objeto en su materializaci√≥n.  No, puramente te√≥ricamente esto es posible ("poco es posible en el mundo en general, puramente te√≥ricamente") y puedo imaginar una imagen en la que una gran cantidad de robots juegan muchos juegos en el mundo real, pero el costo de material para tal soluci√≥n al problema de evaluar el juego excede el cantidades, por lo que nos vemos obligados a emprender el camino de modelar objetos reales con sus contrapartes de software.  Y aqu√≠ es muy importante seguir una l√≠nea fina, combinando un nivel suficiente de adecuaci√≥n del modelo y la simplificaci√≥n necesaria. <br><br>  Pero primero, un poco de matem√°tica para evaluar la complejidad de la tarea: necesitamos clasificar todos los movimientos posibles en el juego (la atenci√≥n no es todas las posiciones posibles, este es el tema de otro m√©todo, a saber, los movimientos) y nos gustar√≠a evaluar la cantidad requerida de recursos antes de comenzar el trabajo, para determinar el orden de la tarea.  En el primer movimiento, tenemos la oportunidad de eliminar cualquier chip (continuar√© llamando objetos) de H disponible, en el siguiente movimiento: cualquiera de los H-1 restantes o dos chips que est√©n cerca (no habr√° m√°s de esos pares que H-2), que da el n√∫mero total de opciones Hx (H-1 + H-2).  Es f√°cil ver que despu√©s del tercer movimiento tenemos Hx (H-1 + H-2) x (H-2 + H-3 + Œî) y as√≠ sucesivamente. <br><br>  Si nos restringimos en cada par√©ntesis solo a los primeros t√©rminos de la suma, entonces obtenemos una estimaci√≥n del n√∫mero total de movimientos como H!, Lo que nos da una estimaci√≥n en cuadraturas de H ^ H. <br><br>  Este es un resultado muy desagradable, que afirma que tendremos problemas muy grandes con H significativo, por lo que lo m√°s probable es que el modelado "frontal" conlleve costos computacionales significativos.  Por ejemplo, para 16 fichas en la posici√≥n inicial, tendremos que considerar aproximadamente 16! = 1013 movimientos, y si un movimiento es de 10E-9 segundos (estimaci√≥n bastante optimista), entonces el tiempo total ser√° de aproximadamente 10E4 segundos o casi 3 horas, lo que es un poco mucho , pero aceptable, pero para solo 20 chips, el tiempo de c√°lculo esperado es de 77 a√±os, lo cual es claramente inaceptable.  Factorial est√° creciendo muy r√°pido y no hay nada que hacer al respecto. <br><br>  Llamamos la atenci√≥n sobre el hecho de que el n√∫mero de movimientos excede significativamente el n√∫mero de posiciones posibles, que es solo 2 ^ N, y es obvio que caeremos en una posici√≥n separada para 16 fichas 10E (13-5) = 10E7 veces, lo cual es un hecho bastante cotidiano para tareas de b√∫squeda  Recuerde este hecho, nos ser√° √∫til m√°s tarde. <br><br>  Sin embargo, comenzaremos a escribir un programa, para el cual determinaremos el modelo.  Primero, numeramos los chips del 1 al H, luego creamos una matriz con el n√∫mero de elementos H y determinamos que el n√∫mero 1 en el elemento de la matriz con √≠ndice n significa la presencia del n√∫mero de chip n, y el n√∫mero 0, su ausencia en una posici√≥n espec√≠fica.  Dicho modelo es adecuado, simple, intuitivo y le permite hacer efectivas las operaciones de eliminaci√≥n de virutas, as√≠ como determinar la condici√≥n de "proximidad". <br><br>  Ahora que tenemos un modelo (estructura de datos), podemos comenzar a extraer (b√∫hos en el mundo) el algoritmo de este modelo.  El algoritmo de enumeraci√≥n completa con retorno es simple en el diagrama de bloques y consta de dos partes independientes: la enumeraci√≥n real y la evaluaci√≥n de posiciones, para comenzar implementaremos la primera parte.  Tenga en cuenta que este algoritmo no se implementa mejor dentro del marco del paradigma de programaci√≥n estructural y ser√≠a algo m√°s efectivo si nos permiti√©ramos usar una transici√≥n o repetir el c√≥digo, pero incluso sin estas desviaciones del estilo, la implementaci√≥n no es pretenciosa (la complejidad ciclom√°tica es bastante aceptable) .  Como todav√≠a no hemos introducido una evaluaci√≥n y nos gustar√≠a obtener el resultado del programa, simplemente derivamos las posiciones bajo consideraci√≥n y las examinamos con nuestros ojos para evaluar la implementaci√≥n correcta y asegurarnos de que los resultados correspondan a los esperados. <br><br>  Ahora agreguemos una estimaci√≥n de posici√≥n: por supuesto, el c√≥digo bien escrito es autodocumentado (aunque hay diferentes opiniones con respecto a esta declaraci√≥n), pero esta parte se describe mejor en palabras.  La idea es que proporcionemos una evaluaci√≥n inequ√≠voca de las posiciones finales (en nuestro caso, es √∫nica y consiste en cero fichas), en funci√≥n de las reglas del juego, y en todas las dem√°s posiciones damos una evaluaci√≥n neutral preliminar, y luego comenzamos a refinarla moviendo la estimaci√≥n hacia arriba del √°rbol .  Al retroceder, la estimaci√≥n de la posici√≥n actual cambia en uno en la direcci√≥n de cero, luego se invierte y se transfiere a la posici√≥n anterior, donde se combina con la estimaci√≥n anterior de acuerdo con las siguientes reglas: <br><br><ol><li>  la evaluaci√≥n neutral cambia a una nueva, </li><li>  una calificaci√≥n positiva cambia a una positiva m√°s peque√±a, </li><li>  una evaluaci√≥n negativa cambia a una gran negativa o positiva. </li></ol><br>  Despu√©s de haber pasado por todos los movimientos, la evaluaci√≥n de la posici√≥n inicial es final. <br><br>  Agregamos estimaciones a nuestro procedimiento para generar todas las posiciones y podemos admirar los resultados del an√°lisis, que se muestran en una tabla, agregar un contador de progreso y un medidor de tiempo para el an√°lisis.  En el compilador gcc (en modo de optimizaci√≥n -O2) en una m√°quina con un procesador, obtuve una tabla que confirma completamente nuestras suposiciones iniciales sobre el orden factorial de complejidad de la tarea.  De la misma tabla, vemos que dej√© de esperar resultados con H superior a 11, porque el tiempo de c√°lculo se volvi√≥ inaceptable (para m√≠, tal vez est√© listo para esperar media hora) y nuestra suposici√≥n sobre el curso y el nanosegundo no corresponde a la realidad (tiempo promedio consideraci√≥n de la posici√≥n es de 100 nseg).  Surge la pregunta: ¬øqu√© debemos hacer si queremos tener una estimaci√≥n de m√°s de 11 fichas en la posici√≥n inicial? <br><br>  Podr√≠amos tomar el camino de peque√±as optimizaciones, jugar con transiciones y banderas, entrar en insertos de ensamblador, aplicar operaciones de vectores dif√≠ciles del sistema de instrucciones de nuestro procesador, y de esta manera puede ganar velocidad de manera inequ√≠voca a veces, en un orden de magnitud, tal vez dos √≥rdenes de magnitud. - es muy poco probable, pero necesitamos una ganancia de muchos √≥rdenes de magnitud, ya que el orden (e incluso m√°s) consumiremos un aumento de H en uno sobre 10. Por cierto, si solo activa la optimizaci√≥n del compilador, har√° algo por nosotros y el tiempo de ejecuci√≥n disminuir√°  Tengo 4 veces - no est√° mal del todo y en l√≠nea con nuestras expectativas. <br><br>  Por lo tanto, primero debemos tratar de mejorar los algoritmos aplicados, y la primera de estas mejoras (y la principal) es el m√©todo de corte de fuerza bruta o el "procedimiento alfa-beta".  Su idea principal parece bastante robusta y consiste en el hecho de que si calificamos una determinada posici√≥n como ganadora, dejamos de mejorar la calificaci√≥n para esta y volvemos al √°rbol.  Este enfoque puede aumentar considerablemente la velocidad del algoritmo, especialmente si investigamos movimientos exitosos (que conducen a una victoria) en primer lugar.  Pero tambi√©n puede aumentar el tiempo, ya que se agrega la verificaci√≥n de la evaluaci√≥n actual y el procedimiento para elegir el curso es complicado, es muy dif√≠cil estimar la influencia de este m√©todo de antemano, es necesario realizar un experimento.  Y una consideraci√≥n m√°s: no debemos olvidar que en el caso de una b√∫squeda con un l√≠mite, en el caso de una posici√≥n ganadora, damos una estimaci√≥n verdadera, pero no precisa, ya que no consideramos parte de las opciones, y podr√≠an dar una victoria en menos movimientos.  Si tal disminuci√≥n en la precisi√≥n nos conviene, entonces, ¬øpor qu√© no usar este m√©todo, pero para una evaluaci√≥n precisa, nada m√°s que una b√∫squeda exhaustiva no funciona? <br><br>  Los resultados de la enumeraci√≥n de recorte se muestran en la siguiente tabla, y vemos que hay una ganancia de rendimiento y un aumento significativo, pero no suficiente para estudiar grandes valores de N. En qu√© direcci√≥n continuaremos nuestra investigaci√≥n: primero veremos otra estructura de datos, bueno, y luego, lo has adivinado (es bueno tratar con una audiencia astuta) es otro algoritmo. <br><br>  Prestemos atenci√≥n al hecho de que la estructura de datos adoptada por nosotros hace que los chips sean √∫nicos y, por ejemplo, un solo chip (que no tiene adyacente) en posici√≥n no es equivalente a un solo chip en la posici√≥n n + 2, lo cual es completamente incorrecto.  Seleccionamos el elemento clave de la posici√≥n del juego: el grupo de fichas ubicado junto a √©l y determinamos su caracter√≠stica principal: la cantidad de fichas en el grupo.  Es esta informaci√≥n la que determina de manera √∫nica cualquier posici√≥n en el juego, y debemos presentarla en una forma conveniente para la programaci√≥n.  Elegimos la estructura de datos m√°s simple y obvia: comenzamos una matriz de elementos H y almacenamos en el elemento n de la matriz el n√∫mero de grupos con exactamente n chips.  Entonces, por ejemplo.  Para la posici√≥n inicial con 3 fichas, tendremos la representaci√≥n {0,0,1}.  El procedimiento de ejecuci√≥n para la presentaci√≥n dada sigue siendo simple y efectivo, aunque, por supuesto, m√°s complicado que en la primera versi√≥n.  Despu√©s del primer movimiento (de los cuales hab√≠a dos en lugar de tres) obtenemos las posiciones {0,1,0} y {2,0,0}. <br><br>  Tratemos de estimar la ganancia esperada en el n√∫mero de movimientos para una estructura de datos dada.  Para el primer movimiento, tenemos opciones (H-1) / 2 + 1, para el segundo (dividimos el grupo H en my N-m-1) (m-1) / 2 + (N-m-1-1) / 2 (tomar 1 chip) + (m-2) / 2 + (N-m-1-2) / 2 (tomar 2 chips) = (H-3) / 2 + (H-5) / 2 y por analog√≠a , concluimos que en cada paso ahorramos al menos la mitad de los movimientos.  Entonces nuestra ganancia deber√≠a ser al menos 2 ^ H, lo cual es muy, muy bueno para la gran H.  De hecho, la ganancia ser√° a√∫n mayor, por ejemplo, para la posici√≥n {8,0 ...} en la primera realizaci√≥n, necesita ordenar 8 movimientos, y en la segunda solo 1 y la ganancia en este caso ser√° 8 veces.  Por lo tanto, podemos contar firmemente con 2 ^ H, pero esperamos mucho m√°s, lo cual comprobaremos.  Y seguro, para el programa de acuerdo con esta representaci√≥n, obtenemos la Tabla 4, la √∫ltima l√≠nea muestra la ganancia de rendimiento al cambiar a la segunda versi√≥n de la estructura de datos (calculada a mano).  El crecimiento es simplemente colosal y con confianza (llegamos al fondo) rompimos el l√≠mite de la posibilidad de an√°lisis de hasta 20 chips en la posici√≥n inicial a un costo de tiempo razonable. <br><br>  Adem√°s, podemos realizar una optimizaci√≥n sutil del algoritmo para una estructura de datos determinada y obtener incluso una ganancia en el rendimiento, pero no obtendremos un crecimiento tan dram√°tico (por orden de magnitud), que una vez m√°s indica que Wirth estaba equivocado.  Por ejemplo, en el programa anterior, el procedimiento para crear el pr√≥ximo candidato para el movimiento no fue deliberadamente √≥ptimo y su correcci√≥n obvia (dej√©moslo al lector curioso) aumentar√° la velocidad en 3 veces, pero esto es un poco, aunque agradable. <br><br>  Prestemos atenci√≥n a los resultados y veamos algunas cosas no obvias.  Por ejemplo, el programa afirma que una ganancia garantizada en un juego directo de 9 fichas no se logra en 9 movimientos, como se deduce del algoritmo sim√©trico heur√≠stico, sino en solo 7, y el primer movimiento coincide con el heur√≠stico (y, adem√°s, es la √∫nica posici√≥n ganadora ), pero el tercero y los siguientes no deben repetir los movimientos del oponente, como se desprende del algoritmo ingenuo, y la clave aqu√≠ es {1,0,0,1}, que tiene una calificaci√≥n de +4.  Ahora que hemos dado una evaluaci√≥n precisa del juego, podemos hacer preguntas interesantes con respecto a la presencia de posiciones con una evaluaci√≥n estable (en la que podemos dejar que el oponente se valga por nosotros mismos), la presencia de posiciones clave en el √°rbol de enumeraci√≥n, encontrar posiciones con el √∫nico movimiento correcto, y as√≠ sucesivamente (y incluso obtener respuestas a estas preguntas y las correctas). <br><br>  Aqu√≠ est√° la tabla resumen de calificaciones <br><table><tbody><tr><th>  Papas fritas </th><th>  Directo </th><th>  Retroalimentaci√≥n </th><th>  Posiciones / Tiempo </th><th>  Posiciones / Tiempo </th></tr><tr><td>  1 </td><td>  1 </td><td>  -1 </td><td>  1/0 </td><td>  1/0 </td></tr><tr><td>  2 </td><td>  -2 </td><td>  2 </td><td>  4/0 </td><td>  2/0 </td></tr><tr><td>  3 </td><td>  3 </td><td>  -3 </td><td>  17/0 </td><td>  7/0 </td></tr><tr><td>  4 4 </td><td>  -4 </td><td>  -3 </td><td>  82/0 </td><td>  20/0 </td></tr><tr><td>  5 5 </td><td>  5 5 </td><td>  4 4 </td><td>  463/0 </td><td>  71/0 </td></tr><tr><td>  6 6 </td><td>  5 5 </td><td>  -5 </td><td>  3032/0 </td><td>  263/0 </td></tr><tr><td>  7 7 </td><td>  7 7 </td><td>  6 6 </td><td>  22693/0 </td><td>  1107/0 </td></tr><tr><td>  8 </td><td>  -8 </td><td>  -7 </td><td>  191422/0 </td><td>  4945/0 </td></tr><tr><td>  9 9 </td><td>  7 7 </td><td>  -7 </td><td>  1798427 / 0.1 </td><td>  24,283 / 0 </td></tr><tr><td>  10 </td><td>  9 9 </td><td>  8 </td><td>  18634228 / 0.8 </td><td>  125419/0 </td></tr><tr><td>  11 </td><td>  11 </td><td>  -9 </td><td>  211177537 / 10.4 </td><td>  699165 / 0.1 </td></tr><tr><td>  12 </td><td>  -10 </td><td>  -9 </td><td>  *** / 127 </td><td>  4057686 / 0.6 </td></tr><tr><td>  13 </td><td>  11 </td><td>  10 </td><td></td><td>  25056975 / 3.84 </td></tr><tr><td>  14 </td><td>  -12 </td><td>  -11 </td><td></td><td>  160643971/28 </td></tr><tr><td>  15 </td><td>  13 </td><td>  12 </td><td></td><td>  1082854607/213 </td></tr><tr><td>  16 </td><td>  -14 </td><td>  -13 </td><td></td><td>  *** / 1698 </td></tr></tbody></table>  Sin embargo, vemos que la estimaci√≥n del tiempo de operaci√≥n se mantuvo factorial, aunque con una disminuci√≥n significativa en la tasa de crecimiento.  Busquemos otras formas de explorar el √°rbol del juego. <br><br>  Hemos perfeccionado el algoritmo de arriba hacia abajo (bueno, por supuesto, no lo terminamos en la forma fea que dibuj√© en la parte posterior del sobre, puede mejorar significativamente el rendimiento al reescribir cuidadosamente los procedimientos b√°sicos, y esto seguramente se har√°, pero el problema no es cardinal decide), as√≠ que vamos a la inversa: de abajo hacia arriba.  La idea de este m√©todo es intuitivamente simple y comprensible, pero muy dif√≠cil para el uso humano: comenzamos desde la posici√≥n final, que se estima de acuerdo con las reglas del juego, y comenzamos a transferir la estimaci√≥n hacia arriba en el √°rbol de acuerdo con las mismas reglas que para la b√∫squeda de arriba hacia abajo.  Por supuesto, al mismo tiempo estamos considerando no posibles movimientos hacia abajo desde la posici√≥n actual, pero estamos considerando todas las posiciones desde las cuales podr√≠amos entrar en el movimiento actual en uno.  Transferimos la estimaci√≥n de acuerdo con las reglas anteriores.  Adem√°s, aplicamos este procedimiento de forma iterativa y cuando deja de producir resultados, es decir, en la siguiente ronda, ni una sola posici√≥n cambi√≥ la evaluaci√≥n, la tarea se completa y la evaluaci√≥n de la posici√≥n inicial es correcta y precisa.  Este enfoque le permite reducir en gran medida el tiempo de b√∫squeda, especialmente si realiza algunas mejoras, pero tiene un fuerte inconveniente (y esto es un cl√°sico: cambiamos el tiempo de memoria), lo que limita significativamente su alcance: requisitos de memoria altos, ya que debemos almacenar estimaciones     ,          (     ).<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el caso del juego en cuesti√≥n, el m√©todo de representaci√≥n de bits para la primera estructura de datos sugiere que existen otros m√©todos que pueden reducir la cantidad de memoria requerida (almacenando solo los tres niveles de √°rbol considerados con la excepci√≥n de la capa inferior), pero, por supuesto, degradando el rendimiento, ya que la b√∫squeda se vuelve muy poco trivial. Sin embargo, para H no mayor que 20, el n√∫mero total de posiciones no ser√° mayor que 2 ^ 20, y una matriz de este tama√±o en la memoria para elementos que contienen un n√∫mero de -20 a 20, es decir, un n√∫mero de 8 bits, soy bastante capaz de imaginar y su implementaci√≥n no ser√° dif√≠cil. Por lo tanto, es bastante posible escribir un programa para dicho algoritmo y evaluar el rendimiento resultante, pero no nos apresuremos y hagamos estimaciones. El tipo de memoria que tendremos que asignar no es dif√≠cil de determinar, pero con par√°metros temporales es algo m√°s complicado.Supongamos que creamos inmediatamente todas las posiciones posibles, ser√°n M, entonces el n√∫mero promedio de movimientos desde una posici√≥n puede estimarse como no m√°s de 2 * N (una estimaci√≥n muy aproximada). Luego, en cada iteraci√≥n, necesitamos realizar no m√°s de M * 2 * H de transferencia de la estimaci√≥n, y dado que en cada ciclo mejoraremos la estimaci√≥n de al menos una posici√≥n, el tiempo de trabajo total ser√° del orden M * 2 * H * M.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luego, para la primera forma de presentar los datos, obtenemos 2 ^ H * M * 2 ^ H = 2 ^ (2 * H) * M (enfatizamos una vez m√°s que esta estimaci√≥n es muy fuerte desde arriba) y, por ejemplo, para H = 20, la estimaci√≥n del tiempo de b√∫squeda desde arriba -down ser√° 20! ~ 10E18, y para la b√∫squeda de abajo hacia arriba tenemos 2 ^ 40 * 20 = (2 ^ 10) ^ 4 * 40 = (10 ^ 3) ^ 4 * 40 ~ 10 ^ 14, es decir, para 20 fichas ganamos a tiempo al menos 10E6 veces, lo cual es muy bueno. Tambi√©n contaremos con 9 fichas iniciales, obteniendo 9! ~ 10E6 para la b√∫squeda superior, y 2 ^ 9 * 2 ^ 9 * 18 ~ 10E6 para la evaluaci√≥n de abajo hacia arriba, es decir, a partir de este n√∫mero, la b√∫squeda de la l√≠nea de fondo gana. La √∫ltima declaraci√≥n es un tanto apresurada, ya que el procedimiento para evaluar la siguiente posici√≥n se ha vuelto significativamente m√°s largo; tendremos que buscarlo entre los ya generados, pero para esta representaci√≥n particular en forma de matriz de bits, este procedimiento se realiza en O (1).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para la segunda presentaci√≥n, es necesario evaluar el n√∫mero de posiciones diferentes, que es una tarea del campo de la combinatoria. Como ejemplo, considere un juego con 9 fichas iniciales, para las cuales el n√∫mero total de diferentes posiciones ser√°: 1+ (1 + 4) + (1 + 3 + 2) + (1 + 3 + 3 + 2) + (1 + 2 + 2 + 1 + 1) + (1 + 2 + 1 + 1) + (1 + 1 + 1) + (1 + 1) + 1 = 1 + 5 + 6 + 9 + 7 + 5 + 3 + 2 + 1 = 39. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luego, una estimaci√≥n por el mismo m√©todo conducir√° al valor H * M * M = 39 * 39 * 9 ~ 10E4, que es dos √≥rdenes de magnitud mejor en velocidad en comparaci√≥n con la primera representaci√≥n, y a medida que H aumenta, la ganancia solo aumentar√°. En comparaci√≥n con ir por encima para la segunda vista, tambi√©n debe esperar una mejora significativa en el rendimiento, pero es m√°s dif√≠cil de evaluar, por lo que es m√°s f√°cil intentarlo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, si realiza un programa de an√°lisis de abajo hacia arriba, entonces para la segunda presentaci√≥n. No dar√© el programa, necesito dejar algo para que los lectores hagan el an√°lisis del hogar. Deber√≠amos obtener resultados para H significativo en un tiempo muy razonable. Otra ventaja de romper desde abajo es que podemos ahorrar significativamente al fijar la estimaci√≥n para la mitad inferior de las posiciones (que tiene un n√∫mero menor de fichas que N / 2), ya que una vez que la mitad inferior estimada se transfiere sin cambios para el siguiente n√∫mero de fichas, lo que nos dar√° una ganancia adicional en 2 veces</font></font><br><br><h4>   ‚Äî        ,         ,      .       ,     ,       (    )   . </h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bueno, en conclusi√≥n, la explicaci√≥n necesaria para aquellos que tomaron mi publicaci√≥n demasiado en serio y arden con indignaci√≥n (justa): no estoy completamente seguro de que especificar los algoritmos como el primer t√©rmino en la f√≥rmula de definici√≥n del programa confirme su mayor importancia, estoy completamente de acuerdo en que En algunas situaciones espec√≠ficas, un algoritmo seleccionado correctamente puede dar un aumento ordenado de la productividad, y no iba a incriminar a Dijkstra (a quien respeto con respeto) por errores. Todo fue una frase para llamar la atenci√≥n, y la publicaci√≥n trata sobre otra cosa: que la estructura de datos tambi√©n es extremadamente importante en t√©rminos de rendimiento y no quer√≠a que me olvidaran de esto en el proceso de dise√±o.</font></font><br><br>  PS.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ me dicen desde la audiencia (hola Max) que hay otro m√©todo para investigar el juego: matem√°tico y, dada la hip√≥tesis del doble apellido de que la mayor√≠a de los juegos de conteo se reducen al juego de Nim, entonces solo necesitamos calcularlo: la suma la posici√≥n inicial (en mi opini√≥n, la declaraci√≥n es dudosa), y tambi√©n puede convertir el juego original en juegos en el gr√°fico (no hay objeci√≥n), por lo que puede esperar una estimaci√≥n de 1.878 ^ N para el momento del trabajo (aunque el n√∫mero espec√≠fico me desconcert√≥ un poco). </font><font style="vertical-align: inherit;">Probablemente, estas consideraciones tienen derecho a la vida, al menos los art√≠culos de este contenido parecen convincentes, pero soy un practicante puro y dejo estas opciones nuevamente para lectores curiosos (ars longa, vita brevis).</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El programa est√° oculto aqu√≠.</font></font></b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ctime&gt; #include "stdio.h" #define MaxMax 17 #define Forward 1 // 1-   0 -  #define Version 1 // 0-   1 -   int hod[MaxMax+1],nf[MaxMax+1],oc[MaxMax+1],sm[MaxMax+1]; int lvl,count,nhod; #if Version==0 int pos[MaxMax+1]; inline void Start(int Max) { for (int i=0; i&lt;Max; i++) oc[i]=0; for (int i=0; i&lt;Max; ++i) pos[i]=1; pos[Max]=0; }; inline void FirstStep(int Max) { hod[lvl]=0; nf[lvl]=1; }; inline int ValidStep() { if ( (pos[hod[lvl]]==1) &amp;&amp; ((nf[lvl]==1) || (pos[hod[lvl]+1]==1)) ) return 1; else return 0; }; inline void MakeStep(void) { pos[hod[lvl]]=0; --count; if (nf[lvl]==2) { pos[hod[lvl]+1]=0; --count; }; }; inline void DownStep(int Max) { ++lvl; oc[lvl]=0; hod[lvl]=-1; nf[lvl]=2; }; inline void RemoveStep(void) { pos[hod[lvl]]=1; ++count; if (nf[lvl]==2) { pos[hod[lvl]+1]=1; ++count; }; }; inline void NextStep(void) { if ((nf[lvl]==1) &amp;&amp; (lvl&gt;0)) nf[lvl]=2; else { ++hod[lvl]; nf[lvl]=1; }; }; inline int LastStep(int Max) {if (hod[lvl]&gt;=Max) return 1; else return 0; }; void print(int Max) { for (int i=0; i&lt;Max; ++i) if (pos[i]==1) printf("*"); else printf("."); for (int i=0; i&lt;Max; ++i) if (i&lt;=lvl) printf ("%2d,%1d",hod[i],nf[i]); else printf(" "); printf("%3d ",count); for (int i=0; i&lt;Max; ++i) printf("%3d",oc[i]); printf("\n"); }; #endif #if Version==1 int gr[MaxMax+1]; inline void Start(int Max) { for (int i=0; i&lt;Max; i++) oc[i]=0; for (int i=0; i&lt;MaxMax; ++i) { gr[i]=0; }; gr[Max]=1; }; inline void FirstStep(int Max) { hod[lvl]=Max; nf[lvl]=1; sm[lvl]=0; }; inline int ValidStep(void) { if ( (gr[hod[lvl]]&gt;0) &amp;&amp; (hod[lvl]&gt;=nf[lvl]) ) return 1; else return 0; }; inline void MakeStep(void) { gr[hod[lvl]]-=1; gr[hod[lvl]-nf[lvl]-sm[lvl]]+=1; if (sm[lvl]&gt;0) gr[sm[lvl]]+=1; count-=nf[lvl]; }; inline void NextStep(void) { sm[lvl]++; if ( sm[lvl]*2 &gt; (hod[lvl]-nf[lvl]) ) { if ( (lvl&gt;0) &amp;&amp; (nf[lvl]==1) ) { nf[lvl]=2; sm[lvl]=0; } else { hod[lvl]-=1; sm[lvl]=0; nf[lvl]=1; }; }; }; inline void DownStep(int Max) { ++lvl; oc[lvl]=0; hod[lvl]=Max; nf[lvl]=1; sm[lvl]=0; }; inline void RemoveStep(void) { if (sm[lvl]&gt;0) gr[sm[lvl]]-=1; gr[hod[lvl]-nf[lvl]-sm[lvl]]-=1; gr[hod[lvl]]+=1; count+=nf[lvl]; }; inline int LastStep(int Max) {if (hod[lvl]&lt;=0) return 1; else return 0; }; void print(int Max) { if (Max==18) { for (int i=1; i&lt;=Max; ++i) printf("%2d,",gr[i]); for (int i=0; i&lt;Max; ++i) if (i&lt;=lvl) printf (" =&gt;%2d:%2d,%1d,%2d",i,hod[i],nf[i],sm[i]); else printf(" "); printf(" %3d:: ",count); for (int i=0; i&lt;Max; ++i) printf("%2d",oc[i]); printf("\n"); }; }; #endif inline void MoveOc(void) { int newoc=-oc[lvl+1]; if (newoc&gt;0) ++newoc; else --newoc; if ( (oc[lvl]==0) || ( (oc[lvl]&lt;0) &amp;&amp; (newoc&gt;0) ) || ( (oc[lvl]&gt;0) &amp;&amp; (newoc&gt;0) &amp;&amp; (newoc&lt;oc[lvl]) ) || ( (oc[lvl]&lt;0) &amp;&amp; (newoc&lt;0) &amp;&amp; (newoc&lt;oc[lvl]) ) ) { oc[lvl]=newoc; // if (oc[0]&gt;0) --ur; }; }; int ocenka(int Max) { Start(Max); count=Max; nhod=0; lvl=0; FirstStep(Max); while (lvl&gt;=0) { //print(Max); if ( ValidStep()==1) { MakeStep(); ++nhod; //print(Max); if (count&gt;0) DownStep(Max); else { #if Forward==1 oc[lvl]=1; #else if (oc[lvl]==0) oc[lvl]=-1; #endif RemoveStep(); }; //print(Max); }; NextStep(); if (LastStep(Max)==1) { --lvl; if (lvl&gt;-1) { MoveOc(); RemoveStep(); NextStep(); }; }; }; return nhod; }; void reverse(void); int main(void) { int last=1; for (int i=1; i&lt;=MaxMax; ++i) { clock_t start_time = clock(); int j=ocenka(i); printf("%2d %3d %12d %5.2f %5.2f\n",i,oc[0],j,(float)j/last,(clock()-start_time)/1000.); last=j; }; return 1; };</span></span></span></span></code> </pre> <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es420859/">https://habr.com/ru/post/es420859/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es420843/index.html">7 de septiembre, Ekaterimburgo: una reuni√≥n para desarrolladores de .NET</a></li>
<li><a href="../es420845/index.html">La domesticaci√≥n del obstinado con el uso de una muleta: el orificio del adaptador Wi-Fi WF2190 (Realtek8812AU Wireless LAN 802.11ac USB)</a></li>
<li><a href="../es420847/index.html">Introducci√≥n a la programaci√≥n de sombreadores para dise√±os</a></li>
<li><a href="../es420853/index.html">Conozca la pseudo consola de Windows (ConPTY)</a></li>
<li><a href="../es420857/index.html">Roaming Wi-Fi sin interrupciones: teor√≠a en la pr√°ctica</a></li>
<li><a href="../es420861/index.html">Prepar√°ndose para C ++ 20. Estudio de caso de Coroutines TS Real</a></li>
<li><a href="../es420863/index.html">Como hicimos el primer tel√©fono inteligente ruso, continu√≥</a></li>
<li><a href="../es420865/index.html">El principio de menor acci√≥n. Parte 1</a></li>
<li><a href="../es420867/index.html">C√°lculo de integrales definidas: algoritmos b√°sicos</a></li>
<li><a href="../es420869/index.html">Evacuaci√≥n, HAMR y MAMR: tres formas de maximizar la capacidad de los discos duros modernos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>