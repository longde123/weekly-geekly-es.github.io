<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🌾 🎧 📡 OpenGL ultramoderne. 2e partie 🤺 🕟 🤜🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tout de bonne humeur et température plus basse en dehors de la fenêtre. Comme promis, je publie une suite de l'article sur le super-duper d'OpenGL mod...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenGL ultramoderne. 2e partie</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457380/"><img src="https://habrastorage.org/webt/ui/wu/2k/uiwu2kjzkvznzwubjaqnk7lkoz0.jpeg"><br><br>  Tout de bonne humeur et température plus basse en dehors de la fenêtre.  Comme promis, je publie une suite de l'article sur le super-duper d'OpenGL moderne.  Qui n'a pas lu la première partie - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ultramodern OpenGL.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> <br><br>  Vous avez peut-être de la chance et je peux mettre tout le matériel restant dans cet article, ce n'est pas certain ... <br><a name="habracut"></a><br><h3>  <font color="#4682B4">Texture de tableau</font> </h3><br>  Les tableaux de textures ont été ajoutés à nouveau dans OpenGL 3.0, mais pour une raison quelconque, peu de gens écrivent à leur sujet (les informations sont masquées de manière fiable par les francs-maçons).  Vous êtes tous familiers avec la programmation et savez ce qu'est un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tableau</a> , bien que je ferais mieux de «l'approche» de l'autre côté. <br><br>  Pour réduire le nombre de commutations entre les textures et, par conséquent, pour réduire les opérations de changement d'état, les utilisateurs utilisent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des atlas de texture</a> (une texture qui stocke des données pour plusieurs objets).  Mais les gars intelligents de Khronos ont développé une alternative pour nous - la texture du tableau.  Maintenant, nous pouvons stocker des textures sous forme de couches dans ce tableau, c'est-à-dire que c'est une alternative aux atlas.  Le Wiki OpenGL a une description légèrement différente sur les mipmaps, etc., mais cela me semble trop compliqué ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien</a> ). <br><br>  Les avantages de cette approche par rapport aux atlas sont que chaque couche est considérée comme une texture distincte en termes d'emballage et de mipmapping. <br><br>  Mais revenons à nos béliers ... Le tableau de textures a trois types de cibles: <br><br><ul><li>  GL_TEXTURE_1D_ARRAY </li><li>  GL_TEXTURE_2D_ARRAY </li><li>  GL_TEXTURE_CUBE_MAP_ARRAY </li></ul><br>  Code pour créer un tableau de textures: <br><br><pre><code class="cpp hljs">GLsizei width = <span class="hljs-number"><span class="hljs-number">512</span></span>; GLsizei height = <span class="hljs-number"><span class="hljs-number">512</span></span>; GLsizei layers = <span class="hljs-number"><span class="hljs-number">3</span></span>; glCreateTextures(GL_TEXTURE_2D_ARRAY, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;texture_array); glTextureStorage3D(texture_array, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGBA8, width, height, layers);</code> </pre> <br>  Les plus attentifs ont remarqué que nous créons un référentiel pour les textures 2D, mais pour une raison quelconque, nous utilisons un tableau 3D, il n'y a pas d'erreur ou de faute de frappe ici.  Nous stockons des textures 2D, mais puisqu'elles sont situées dans des «couches», nous obtenons un tableau 3D (en fait, les données de pixels sont stockées, pas les textures. Le tableau 3D a des couches 2D avec des données de pixels). <br><br>  Ici, il est facile de comprendre l'exemple de la texture 1D.  Chaque ligne d'un tableau de pixels 2D est une couche 1D distincte.  Les textures Mipmap peuvent également être créées automatiquement. <br><br>  Sur ce point, toutes les difficultés se terminent et l'ajout d'une image à un calque spécifique est assez simple: <br><br><pre> <code class="cpp hljs">glTextureSubImage3D(texarray, mipmap_level, offset.x, offset.y, layer, width, height, <span class="hljs-number"><span class="hljs-number">1</span></span>, GL_RGBA, GL_UNSIGNED_BYTE, pixels);</code> </pre> <br>  Lorsque vous utilisez des tableaux, nous devons changer un peu le shader <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core layout (location = 0) out vec4 color; layout (location = 0) in vec2 texture_0; uniform sampler2DArray texture_array; uniform uint diffuse_layer; float getCoord(uint capacity, uint layer) { return max(0, min(float(capacity - 1), floor(float(layer) + 0.5))); } void main() { color = texture(texture_array, vec3(texture_0, getCoord(3, diffuse_layer))); }</span></span></code> </pre> <br>  La meilleure option serait de calculer la couche souhaitée en dehors du shader, pour cela, nous pouvons utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">UBO</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SSBO</a> (il est également utilisé pour transférer des matrices et de nombreuses autres données, mais c'est en quelque sorte une autre fois).  Si quelqu'un ne peut pas attendre <a href="">tyk_1</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tyk_2</a> , vous pouvez lire. <br><br>  Quant aux tailles, c'est-à-dire GL_MAX_ARRAY_TEXTURE_LAYERS qui est 256 en OpenGL 3.3 et 2048 en OpenGL 4.5. <br><br>  Il vaut la peine de parler de l'objet Sampler (non lié à la texture du tableau, mais une chose utile) - c'est un objet qui est utilisé pour configurer les états d'une unité de texture, quel que soit l'objet actuellement attaché à l'unité.  Il permet de séparer les états de l'échantillonneur d'un objet de texture particulier, ce qui améliore l'abstraction. <br><br><pre> <code class="cpp hljs">GLuint sampler_state = <span class="hljs-number"><span class="hljs-number">0</span></span>; glGenSamplers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;sampler_state); glSamplerParameteri(sampler_state, GL_TEXTURE_WRAP_S, GL_REPEAT); glSamplerParameteri(sampler_state, GL_TEXTURE_WRAP_T, GL_REPEAT); glSamplerParameteri(sampler_state, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glSamplerParameteri(sampler_state, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); glSamplerParameterf(sampler_state, GL_TEXTURE_MAX_ANISOTROPY_EXT, <span class="hljs-number"><span class="hljs-number">16.0f</span></span>);</code> </pre> <br>  Je viens de créer un objet échantillonneur, activé le filtrage linéaire et le filtrage anisotrope 16x pour n'importe quelle unité de texture. <br><br><pre> <code class="cpp hljs">GLuint texture_unit = <span class="hljs-number"><span class="hljs-number">0</span></span>; glBindSampler(texture_unit, sampler_state);</code> </pre> <br>  Ici, nous lions simplement l'échantillonneur à l'unité de texture souhaitée, et lorsqu'il cesse d'être le bindim 0 souhaité à cette unité. <br><br><pre> <code class="cpp hljs">glBindSampler(texture_unit, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Lorsque nous avons lié l'échantillonneur, ses paramètres ont priorité sur les paramètres de l'unité de texture.  Résultat: il n'est pas nécessaire de modifier la base de code existante pour ajouter des objets d'échantillonneur.  Vous pouvez laisser la création de texture telle quelle (avec ses propres états d'échantillonneur) et simplement ajouter du code pour contrôler et utiliser les objets d'échantillonneur. <br><br>  Lorsqu'il est temps de supprimer l'objet, nous appelons simplement cette fonction: <br><br><pre> <code class="cpp hljs">glDeleteSamplers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;sampler_state);</code> </pre> <br><h3>  <font color="#4682B4">Vue de texture</font> </h3><br>  Je vais traduire cela par "un pointeur de texture (il peut être plus correct que le lien, je suis xs)", car je ne connais pas la meilleure traduction. <br><br>  Quels sont les pointeurs dans la perspective d'OpenGL? <br><br>  Tout est très simple, c'est un pointeur vers les données d'une texture immuable (à savoir, mutable), comme nous le voyons dans l'image ci-dessous. <br><br><img src="https://habrastorage.org/webt/ul/r0/sy/ulr0syubsujlqfshyemnh6sqdoq.jpeg"><br><br>  En fait, c'est un objet qui partage les données de texel d'un certain objet de texture, pour l'analogie, nous pouvons utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">std :: shared_ptr de C ++</a> .  Tant qu'il existe au moins un pointeur de texture, la texture d'origine ne sera pas supprimée par le pilote. <br><br>  Le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wiki</a> est décrit plus en détail et mérite d'être lu sur les types de texture et de cible (ils ne doivent pas nécessairement correspondre) <br><br>  Pour créer un pointeur, nous devons obtenir un descripteur de texture en appelant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">glGenTexture</a> (aucune initialisation n'est nécessaire) puis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">glTextureView</a> . <br><br><pre> <code class="cpp hljs">glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;texture_view); glTextureView(texture_view, GL_TEXTURE_2D, source_name, internal_format, min_level, level_count, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Les pointeurs de texture peuvent pointer vers le Nième niveau de mipmap, assez utile et pratique.  Les pointeurs peuvent être soit des tableaux de textures, des parties de tableaux, une couche spécifique dans ce tableau, soit une tranche d'une texture 3D en tant que texture 2D. <br><br><h3>  <font color="#4682B4">Tampon unique pour l'index et le sommet</font> </h3><br>  Eh bien, tout sera rapide et facile.  Auparavant, la spécification OpenGL pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Vertex Buffer Object</a> recommandait que le développeur divise les données de sommet et d'index en différents tampons, mais maintenant ce n'est pas nécessaire (une longue histoire pourquoi pas). <br>  Tout ce dont nous avons besoin est de sauvegarder les indices devant les sommets et de dire où les sommets commencent (plus précisément, le décalage), pour cela il y a la commande <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">glVertexArrayVertexBuffer</a> <br><br>  Voici comment nous procéderions: <br><br><pre> <code class="cpp hljs">GLint alignment = GL_NONE; glGetIntegerv(GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT, &amp;alignment); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLsizei ind_len = GLsizei(ind_buffer.size() * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">element_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLsizei vrt_len = GLsizei(vrt_buffer.size() * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">vertex_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLuint ind_len_aligned = align(ind_len, alignment); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLuint vrt_len_aligned = align(vrt_len, alignment); GLuint buffer = GL_NONE; glCreateBuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;buffer); glNamedBufferStorage(buffer, ind_len_aligned + vrt_len_aligned, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, GL_DYNAMIC_STORAGE_BIT); glNamedBufferSubData(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, ind_len, ind_buffer.data()); glNamedBufferSubData(buffer, ind_len_aligned, vrt_len, vrt_buffer.data()); GLuint vao = GL_NONE; glCreateVertexArrays(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;vao); glVertexArrayVertexBuffer(vao, <span class="hljs-number"><span class="hljs-number">0</span></span>, buffer, ind_len_aligned, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">vertex_t</span></span>)); glVertexArrayElementBuffer(vao, buffer);</code> </pre> <br><br><h3>  <font color="#4682B4">Pavage et ombrage de calcul</font> </h3><br>  Je ne vais pas vous parler du shader de tessellation, car il y a beaucoup de matériel sur Google à ce sujet (en russe), voici quelques leçons: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3</a> .  Nous procédons à l'examen du shader pour les calculs (bliiin, aussi beaucoup de matériel, je vais vous le dire brièvement). <br><br>  L'avantage des cartes vidéo dans un très grand nombre de cœurs, les cartes vidéo sont conçues pour un grand nombre de petites tâches qui peuvent être effectuées en parallèle.  Le shader de calcul, comme son nom l'indique, permet de résoudre des problèmes qui ne sont pas liés au graphisme (pas nécessaire). <br><br>  Une image, je ne sais pas comment l'appeler (comme les flux sont regroupés). <br><br><img src="https://habrastorage.org/webt/tw/3a/x_/tw3ax_rzsrwx5look90ggm5xehw.jpeg"><br><br>  Que pouvons-nous utiliser? <br><br><ul><li>  Traitement d'image <ol><li>  Bloom </li><li>  Algorithmes basés sur les tuiles (ombrage différé) </li></ol></li><li>  Des simulations <br><ol><li>  Particules </li><li>  De l'eau </li></ol></li></ul><br>  De plus je ne vois aucune raison d'écrire, il y a aussi beaucoup d'informations sur Google, voici un exemple simple d'utilisation: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     glUseProgramStages( pipeline, GL_COMPUTE_SHADER_BIT, cs); // ,    / glBindImageTexture( 0, tex, 0, GL_FALSE, 0, GL_WRITE_ONLY, GL_RGBA8); // 80x45   (  1280720) glDispatchCompute( 80, 45, 1);</span></span></code> </pre> <br><br>  Voici un exemple de shader de calcul vide: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 430 layout(local_size_x = 1, local_size_y = 1) in; layout(rgba32f, binding = 0) uniform image2D img_output; void main() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// base pixel color for image vec4 pixel = vec4(0.0, 0.0, 0.0, 1.0); // get index in global work group ie x,y position ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy); // // interesting stuff happens here later // // output to a specific pixel in the image imageStore(img_output, pixel_coords, pixel); }</span></span></span></span></code> </pre> <br><br>  Voici quelques liens pour approfondir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4</a> . <br><br><h3>  <font color="#4682B4">Rendu de chemin</font> </h3><br>  Il s'agit d'une nouvelle extension (pas nouvelle) de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NVidia</a> , son objectif principal est le rendu 2D vectoriel.  Nous pouvons l'utiliser pour des textes ou l'interface utilisateur, et puisque les graphiques sont vectoriels, cela ne dépend pas de la résolution, ce qui est sans aucun doute un gros plus et notre interface utilisateur aura fière allure. <br><br>  Le concept de base est un pochoir, puis une couverture (couverture dans l'original).  Définissez le gabarit du chemin, puis visualisez les pixels. <br><br>  Pour la gestion, GLuint standard est utilisé et les fonctions de création et de suppression ont une convention de dénomination standard. <br><br><pre> <code class="cpp hljs">glGenPathsNV <span class="hljs-comment"><span class="hljs-comment">//  glDeletePathsNV // </span></span></code> </pre> <br><br>  Voici un peu comment obtenir le chemin: <br><ul><li>  SVG ou PostScript dans string'e <pre> <code class="cpp hljs">glPathStringNV</code> </pre> </li><li>  tableau de commandes avec les coordonnées correspondantes <pre> <code class="cpp hljs">glPathCommandsNV</code> </pre>  et pour la mise à jour des données <pre> <code class="cpp hljs">glPathSubCommands, glPathCoords, glPathSubCoords</code> </pre> </li><li>  polices <pre> <code class="cpp hljs">glPathGlyphsNV, glPathGlyphRangeNV</code> </pre> </li><li>  combinaisons linéaires de chemins existants (interpolation d'un, deux ou plusieurs chemins) <pre> <code class="cpp hljs">glCopyPathNV, glInterpolatePathsNV, glCombinePathsNV</code> </pre> </li><li>  transformation linéaire d'un chemin existant <pre> <code class="cpp hljs">glTransformPathNV</code> </pre> </li></ul><br>  Liste des commandes standard: <br><br><ul><li>  déplacer vers (x, y) </li><li>  chemin étroit </li><li>  ligne vers (x, y) </li><li>  courbe quadratique (x1, y1, x2, y2) </li><li>  courbe cubique (x1, y1, x2, y2, x3, y3) </li><li>  courbe quadratique lisse (x, y) </li><li>  courbe cubique lisse (x1, y1, x2, y2) </li><li>  arc elliptique (rx, ry, rotation sur l'axe des x, drapeau à grand arc, drapeau de balayage, x, y) </li></ul><br>  Voici à quoi ressemble la chaîne de chemin dans PostScript: <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"100 180 moveto 40 10 lineto 190 120 lineto 10 120 lineto 160 10 lineto closepath” // "</span></span><span class="hljs-number"><span class="hljs-number">300</span></span> <span class="hljs-number"><span class="hljs-number">300</span></span> moveto <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">400</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">300</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span> curveto <span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">400</span></span> <span class="hljs-number"><span class="hljs-number">300</span></span> <span class="hljs-number"><span class="hljs-number">300</span></span> curveto closepath” <span class="hljs-comment"><span class="hljs-comment">//</span></span></code> </pre> <br>  Et ici en SVG: <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"M100,180 L40,10 L190,120 L10,120 L160,10 z” // "</span></span>M300 <span class="hljs-number"><span class="hljs-number">300</span></span> C <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">400</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span>,<span class="hljs-number"><span class="hljs-number">300</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span>,<span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span>,<span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">400</span></span>,<span class="hljs-number"><span class="hljs-number">300</span></span> <span class="hljs-number"><span class="hljs-number">300</span></span>Z” <span class="hljs-comment"><span class="hljs-comment">//</span></span></code> </pre> <br>  Il existe encore toutes sortes de petits pains avec des types de remplissages, bords, coudes: <br><br><img src="https://habrastorage.org/webt/wx/uy/wv/wxuywvdg2rfuxlrrasn_hh9yzkm.jpeg"><br><br>  Je ne décrirai pas tout ici, car il y a beaucoup de matériel et il faudra un article entier (si c'est intéressant, je vais l'écrire en quelque sorte). <br><br>  Voici une liste de primitives de rendu <br><br><ul><li>  Courbes cubiques </li><li>  Courbes quadratiques </li><li>  Lignes </li><li>  Glyphes de police </li><li>  Arcs </li><li>  Style Dash &amp; Endcap </li></ul><br>  Voici du code, puis il y a beaucoup de texte: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// SVG  glPathStringNV( pathObj, GL_PATH_FORMAT_SVG_NV, strlen(svgPathString), svgPathString); //  glStencilFillPathNV( pathObj, GL_COUNT_UP_NV, 0x1F); // //  ( ) glCoverFillPathNV( pathObj, GL_BOUNDING_BOX_NV);</span></span></code> </pre> <br>  C’est tout. <br><br>  Il me semble que cet article est sorti moins intéressant et informatif, il était difficile de distinguer l'essentiel du matériel.  Si quelqu'un souhaite en savoir plus en détail, je peux supprimer certains documents NVidia et les liens vers les spécifications (si je me souviens où je les ai enregistrés).  Je suis également heureux de toute aide dans l'édition de l'article. <br><br>  Comme promis, j'écrirai l'article suivant sur l'optimisation et la réduction des appels de tirage.  Je voudrais vous demander d'écrire dans les commentaires ce que vous aimeriez lire d'autre et ce qui vous intéresse: <br><ul><li>  Écrire un jeu sur cocos2d-x (Entraînement uniquement, pas d'eau) </li><li>  Traduction d'une série d'articles sur Vulkan </li><li>  Quelques sujets sur OpenGL (quaternions, nouvelles fonctionnalités) </li><li>  Algorithmes d'infographie (éclairage, occlusion ambiante de l'écran spatial, réflexion de l'écran spatial) </li><li>  Vos options </li></ul><br><br>  Merci à tous pour votre attention. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr457380/">https://habr.com/ru/post/fr457380/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr457354/index.html">Obfuscation des données pour les tests de performances</a></li>
<li><a href="../fr457362/index.html">Promotion de RUVDS: préparer le serveur en été</a></li>
<li><a href="../fr457366/index.html">Un fanatique, un morceau de fer ou un spectateur - quel genre de joueur êtes-vous?</a></li>
<li><a href="../fr457374/index.html">Réduisez le temps de construction de vos projets Android</a></li>
<li><a href="../fr457378/index.html">Comment id Software a créé Wolfenstein 3D basé sur la technologie du commandant Keen</a></li>
<li><a href="../fr457382/index.html">7 habitudes des programmeurs performants</a></li>
<li><a href="../fr457386/index.html">Présentation des interfaces virtuelles Linux: tunnels</a></li>
<li><a href="../fr457390/index.html">Madagascar - île des contrastes</a></li>
<li><a href="../fr457392/index.html">Économies sur le développement multiplateforme mobile: étude de cas Skyeng</a></li>
<li><a href="../fr457396/index.html">Déverrouillage automatique du conteneur racine LUKS après un démarrage à chaud</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>