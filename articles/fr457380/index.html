<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçüåæ üéß üì° OpenGL ultramoderne. 2e partie ü§∫ üïü ü§úüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tout de bonne humeur et temp√©rature plus basse en dehors de la fen√™tre. Comme promis, je publie une suite de l'article sur le super-duper d'OpenGL mod...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenGL ultramoderne. 2e partie</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457380/"><img src="https://habrastorage.org/webt/ui/wu/2k/uiwu2kjzkvznzwubjaqnk7lkoz0.jpeg"><br><br>  Tout de bonne humeur et temp√©rature plus basse en dehors de la fen√™tre.  Comme promis, je publie une suite de l'article sur le super-duper d'OpenGL moderne.  Qui n'a pas lu la premi√®re partie - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ultramodern OpenGL.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> <br><br>  Vous avez peut-√™tre de la chance et je peux mettre tout le mat√©riel restant dans cet article, ce n'est pas certain ... <br><a name="habracut"></a><br><h3>  <font color="#4682B4">Texture de tableau</font> </h3><br>  Les tableaux de textures ont √©t√© ajout√©s √† nouveau dans OpenGL 3.0, mais pour une raison quelconque, peu de gens √©crivent √† leur sujet (les informations sont masqu√©es de mani√®re fiable par les francs-ma√ßons).  Vous √™tes tous familiers avec la programmation et savez ce qu'est un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tableau</a> , bien que je ferais mieux de ¬´l'approche¬ª de l'autre c√¥t√©. <br><br>  Pour r√©duire le nombre de commutations entre les textures et, par cons√©quent, pour r√©duire les op√©rations de changement d'√©tat, les utilisateurs utilisent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des atlas de texture</a> (une texture qui stocke des donn√©es pour plusieurs objets).  Mais les gars intelligents de Khronos ont d√©velopp√© une alternative pour nous - la texture du tableau.  Maintenant, nous pouvons stocker des textures sous forme de couches dans ce tableau, c'est-√†-dire que c'est une alternative aux atlas.  Le Wiki OpenGL a une description l√©g√®rement diff√©rente sur les mipmaps, etc., mais cela me semble trop compliqu√© ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien</a> ). <br><br>  Les avantages de cette approche par rapport aux atlas sont que chaque couche est consid√©r√©e comme une texture distincte en termes d'emballage et de mipmapping. <br><br>  Mais revenons √† nos b√©liers ... Le tableau de textures a trois types de cibles: <br><br><ul><li>  GL_TEXTURE_1D_ARRAY </li><li>  GL_TEXTURE_2D_ARRAY </li><li>  GL_TEXTURE_CUBE_MAP_ARRAY </li></ul><br>  Code pour cr√©er un tableau de textures: <br><br><pre><code class="cpp hljs">GLsizei width = <span class="hljs-number"><span class="hljs-number">512</span></span>; GLsizei height = <span class="hljs-number"><span class="hljs-number">512</span></span>; GLsizei layers = <span class="hljs-number"><span class="hljs-number">3</span></span>; glCreateTextures(GL_TEXTURE_2D_ARRAY, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;texture_array); glTextureStorage3D(texture_array, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGBA8, width, height, layers);</code> </pre> <br>  Les plus attentifs ont remarqu√© que nous cr√©ons un r√©f√©rentiel pour les textures 2D, mais pour une raison quelconque, nous utilisons un tableau 3D, il n'y a pas d'erreur ou de faute de frappe ici.  Nous stockons des textures 2D, mais puisqu'elles sont situ√©es dans des ¬´couches¬ª, nous obtenons un tableau 3D (en fait, les donn√©es de pixels sont stock√©es, pas les textures. Le tableau 3D a des couches 2D avec des donn√©es de pixels). <br><br>  Ici, il est facile de comprendre l'exemple de la texture 1D.  Chaque ligne d'un tableau de pixels 2D est une couche 1D distincte.  Les textures Mipmap peuvent √©galement √™tre cr√©√©es automatiquement. <br><br>  Sur ce point, toutes les difficult√©s se terminent et l'ajout d'une image √† un calque sp√©cifique est assez simple: <br><br><pre> <code class="cpp hljs">glTextureSubImage3D(texarray, mipmap_level, offset.x, offset.y, layer, width, height, <span class="hljs-number"><span class="hljs-number">1</span></span>, GL_RGBA, GL_UNSIGNED_BYTE, pixels);</code> </pre> <br>  Lorsque vous utilisez des tableaux, nous devons changer un peu le shader <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core layout (location = 0) out vec4 color; layout (location = 0) in vec2 texture_0; uniform sampler2DArray texture_array; uniform uint diffuse_layer; float getCoord(uint capacity, uint layer) { return max(0, min(float(capacity - 1), floor(float(layer) + 0.5))); } void main() { color = texture(texture_array, vec3(texture_0, getCoord(3, diffuse_layer))); }</span></span></code> </pre> <br>  La meilleure option serait de calculer la couche souhait√©e en dehors du shader, pour cela, nous pouvons utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">UBO</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SSBO</a> (il est √©galement utilis√© pour transf√©rer des matrices et de nombreuses autres donn√©es, mais c'est en quelque sorte une autre fois).  Si quelqu'un ne peut pas attendre <a href="">tyk_1</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tyk_2</a> , vous pouvez lire. <br><br>  Quant aux tailles, c'est-√†-dire GL_MAX_ARRAY_TEXTURE_LAYERS qui est 256 en OpenGL 3.3 et 2048 en OpenGL 4.5. <br><br>  Il vaut la peine de parler de l'objet Sampler (non li√© √† la texture du tableau, mais une chose utile) - c'est un objet qui est utilis√© pour configurer les √©tats d'une unit√© de texture, quel que soit l'objet actuellement attach√© √† l'unit√©.  Il permet de s√©parer les √©tats de l'√©chantillonneur d'un objet de texture particulier, ce qui am√©liore l'abstraction. <br><br><pre> <code class="cpp hljs">GLuint sampler_state = <span class="hljs-number"><span class="hljs-number">0</span></span>; glGenSamplers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;sampler_state); glSamplerParameteri(sampler_state, GL_TEXTURE_WRAP_S, GL_REPEAT); glSamplerParameteri(sampler_state, GL_TEXTURE_WRAP_T, GL_REPEAT); glSamplerParameteri(sampler_state, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glSamplerParameteri(sampler_state, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); glSamplerParameterf(sampler_state, GL_TEXTURE_MAX_ANISOTROPY_EXT, <span class="hljs-number"><span class="hljs-number">16.0f</span></span>);</code> </pre> <br>  Je viens de cr√©er un objet √©chantillonneur, activ√© le filtrage lin√©aire et le filtrage anisotrope 16x pour n'importe quelle unit√© de texture. <br><br><pre> <code class="cpp hljs">GLuint texture_unit = <span class="hljs-number"><span class="hljs-number">0</span></span>; glBindSampler(texture_unit, sampler_state);</code> </pre> <br>  Ici, nous lions simplement l'√©chantillonneur √† l'unit√© de texture souhait√©e, et lorsqu'il cesse d'√™tre le bindim 0 souhait√© √† cette unit√©. <br><br><pre> <code class="cpp hljs">glBindSampler(texture_unit, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Lorsque nous avons li√© l'√©chantillonneur, ses param√®tres ont priorit√© sur les param√®tres de l'unit√© de texture.  R√©sultat: il n'est pas n√©cessaire de modifier la base de code existante pour ajouter des objets d'√©chantillonneur.  Vous pouvez laisser la cr√©ation de texture telle quelle (avec ses propres √©tats d'√©chantillonneur) et simplement ajouter du code pour contr√¥ler et utiliser les objets d'√©chantillonneur. <br><br>  Lorsqu'il est temps de supprimer l'objet, nous appelons simplement cette fonction: <br><br><pre> <code class="cpp hljs">glDeleteSamplers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;sampler_state);</code> </pre> <br><h3>  <font color="#4682B4">Vue de texture</font> </h3><br>  Je vais traduire cela par "un pointeur de texture (il peut √™tre plus correct que le lien, je suis xs)", car je ne connais pas la meilleure traduction. <br><br>  Quels sont les pointeurs dans la perspective d'OpenGL? <br><br>  Tout est tr√®s simple, c'est un pointeur vers les donn√©es d'une texture immuable (√† savoir, mutable), comme nous le voyons dans l'image ci-dessous. <br><br><img src="https://habrastorage.org/webt/ul/r0/sy/ulr0syubsujlqfshyemnh6sqdoq.jpeg"><br><br>  En fait, c'est un objet qui partage les donn√©es de texel d'un certain objet de texture, pour l'analogie, nous pouvons utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">std :: shared_ptr de C ++</a> .  Tant qu'il existe au moins un pointeur de texture, la texture d'origine ne sera pas supprim√©e par le pilote. <br><br>  Le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wiki</a> est d√©crit plus en d√©tail et m√©rite d'√™tre lu sur les types de texture et de cible (ils ne doivent pas n√©cessairement correspondre) <br><br>  Pour cr√©er un pointeur, nous devons obtenir un descripteur de texture en appelant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">glGenTexture</a> (aucune initialisation n'est n√©cessaire) puis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">glTextureView</a> . <br><br><pre> <code class="cpp hljs">glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;texture_view); glTextureView(texture_view, GL_TEXTURE_2D, source_name, internal_format, min_level, level_count, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Les pointeurs de texture peuvent pointer vers le Ni√®me niveau de mipmap, assez utile et pratique.  Les pointeurs peuvent √™tre soit des tableaux de textures, des parties de tableaux, une couche sp√©cifique dans ce tableau, soit une tranche d'une texture 3D en tant que texture 2D. <br><br><h3>  <font color="#4682B4">Tampon unique pour l'index et le sommet</font> </h3><br>  Eh bien, tout sera rapide et facile.  Auparavant, la sp√©cification OpenGL pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Vertex Buffer Object</a> recommandait que le d√©veloppeur divise les donn√©es de sommet et d'index en diff√©rents tampons, mais maintenant ce n'est pas n√©cessaire (une longue histoire pourquoi pas). <br>  Tout ce dont nous avons besoin est de sauvegarder les indices devant les sommets et de dire o√π les sommets commencent (plus pr√©cis√©ment, le d√©calage), pour cela il y a la commande <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">glVertexArrayVertexBuffer</a> <br><br>  Voici comment nous proc√©derions: <br><br><pre> <code class="cpp hljs">GLint alignment = GL_NONE; glGetIntegerv(GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT, &amp;alignment); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLsizei ind_len = GLsizei(ind_buffer.size() * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">element_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLsizei vrt_len = GLsizei(vrt_buffer.size() * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">vertex_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLuint ind_len_aligned = align(ind_len, alignment); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLuint vrt_len_aligned = align(vrt_len, alignment); GLuint buffer = GL_NONE; glCreateBuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;buffer); glNamedBufferStorage(buffer, ind_len_aligned + vrt_len_aligned, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, GL_DYNAMIC_STORAGE_BIT); glNamedBufferSubData(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, ind_len, ind_buffer.data()); glNamedBufferSubData(buffer, ind_len_aligned, vrt_len, vrt_buffer.data()); GLuint vao = GL_NONE; glCreateVertexArrays(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;vao); glVertexArrayVertexBuffer(vao, <span class="hljs-number"><span class="hljs-number">0</span></span>, buffer, ind_len_aligned, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">vertex_t</span></span>)); glVertexArrayElementBuffer(vao, buffer);</code> </pre> <br><br><h3>  <font color="#4682B4">Pavage et ombrage de calcul</font> </h3><br>  Je ne vais pas vous parler du shader de tessellation, car il y a beaucoup de mat√©riel sur Google √† ce sujet (en russe), voici quelques le√ßons: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3</a> .  Nous proc√©dons √† l'examen du shader pour les calculs (bliiin, aussi beaucoup de mat√©riel, je vais vous le dire bri√®vement). <br><br>  L'avantage des cartes vid√©o dans un tr√®s grand nombre de c≈ìurs, les cartes vid√©o sont con√ßues pour un grand nombre de petites t√¢ches qui peuvent √™tre effectu√©es en parall√®le.  Le shader de calcul, comme son nom l'indique, permet de r√©soudre des probl√®mes qui ne sont pas li√©s au graphisme (pas n√©cessaire). <br><br>  Une image, je ne sais pas comment l'appeler (comme les flux sont regroup√©s). <br><br><img src="https://habrastorage.org/webt/tw/3a/x_/tw3ax_rzsrwx5look90ggm5xehw.jpeg"><br><br>  Que pouvons-nous utiliser? <br><br><ul><li>  Traitement d'image <ol><li>  Bloom </li><li>  Algorithmes bas√©s sur les tuiles (ombrage diff√©r√©) </li></ol></li><li>  Des simulations <br><ol><li>  Particules </li><li>  De l'eau </li></ol></li></ul><br>  De plus je ne vois aucune raison d'√©crire, il y a aussi beaucoup d'informations sur Google, voici un exemple simple d'utilisation: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     glUseProgramStages( pipeline, GL_COMPUTE_SHADER_BIT, cs); // ,    / glBindImageTexture( 0, tex, 0, GL_FALSE, 0, GL_WRITE_ONLY, GL_RGBA8); // 80x45   (  1280720) glDispatchCompute( 80, 45, 1);</span></span></code> </pre> <br><br>  Voici un exemple de shader de calcul vide: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 430 layout(local_size_x = 1, local_size_y = 1) in; layout(rgba32f, binding = 0) uniform image2D img_output; void main() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// base pixel color for image vec4 pixel = vec4(0.0, 0.0, 0.0, 1.0); // get index in global work group ie x,y position ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy); // // interesting stuff happens here later // // output to a specific pixel in the image imageStore(img_output, pixel_coords, pixel); }</span></span></span></span></code> </pre> <br><br>  Voici quelques liens pour approfondir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4</a> . <br><br><h3>  <font color="#4682B4">Rendu de chemin</font> </h3><br>  Il s'agit d'une nouvelle extension (pas nouvelle) de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NVidia</a> , son objectif principal est le rendu 2D vectoriel.  Nous pouvons l'utiliser pour des textes ou l'interface utilisateur, et puisque les graphiques sont vectoriels, cela ne d√©pend pas de la r√©solution, ce qui est sans aucun doute un gros plus et notre interface utilisateur aura fi√®re allure. <br><br>  Le concept de base est un pochoir, puis une couverture (couverture dans l'original).  D√©finissez le gabarit du chemin, puis visualisez les pixels. <br><br>  Pour la gestion, GLuint standard est utilis√© et les fonctions de cr√©ation et de suppression ont une convention de d√©nomination standard. <br><br><pre> <code class="cpp hljs">glGenPathsNV <span class="hljs-comment"><span class="hljs-comment">//  glDeletePathsNV // </span></span></code> </pre> <br><br>  Voici un peu comment obtenir le chemin: <br><ul><li>  SVG ou PostScript dans string'e <pre> <code class="cpp hljs">glPathStringNV</code> </pre> </li><li>  tableau de commandes avec les coordonn√©es correspondantes <pre> <code class="cpp hljs">glPathCommandsNV</code> </pre>  et pour la mise √† jour des donn√©es <pre> <code class="cpp hljs">glPathSubCommands, glPathCoords, glPathSubCoords</code> </pre> </li><li>  polices <pre> <code class="cpp hljs">glPathGlyphsNV, glPathGlyphRangeNV</code> </pre> </li><li>  combinaisons lin√©aires de chemins existants (interpolation d'un, deux ou plusieurs chemins) <pre> <code class="cpp hljs">glCopyPathNV, glInterpolatePathsNV, glCombinePathsNV</code> </pre> </li><li>  transformation lin√©aire d'un chemin existant <pre> <code class="cpp hljs">glTransformPathNV</code> </pre> </li></ul><br>  Liste des commandes standard: <br><br><ul><li>  d√©placer vers (x, y) </li><li>  chemin √©troit </li><li>  ligne vers (x, y) </li><li>  courbe quadratique (x1, y1, x2, y2) </li><li>  courbe cubique (x1, y1, x2, y2, x3, y3) </li><li>  courbe quadratique lisse (x, y) </li><li>  courbe cubique lisse (x1, y1, x2, y2) </li><li>  arc elliptique (rx, ry, rotation sur l'axe des x, drapeau √† grand arc, drapeau de balayage, x, y) </li></ul><br>  Voici √† quoi ressemble la cha√Æne de chemin dans PostScript: <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"100 180 moveto 40 10 lineto 190 120 lineto 10 120 lineto 160 10 lineto closepath‚Äù // "</span></span><span class="hljs-number"><span class="hljs-number">300</span></span> <span class="hljs-number"><span class="hljs-number">300</span></span> moveto <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">400</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">300</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span> curveto <span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">400</span></span> <span class="hljs-number"><span class="hljs-number">300</span></span> <span class="hljs-number"><span class="hljs-number">300</span></span> curveto closepath‚Äù <span class="hljs-comment"><span class="hljs-comment">//</span></span></code> </pre> <br>  Et ici en SVG: <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"M100,180 L40,10 L190,120 L10,120 L160,10 z‚Äù // "</span></span>M300 <span class="hljs-number"><span class="hljs-number">300</span></span> C <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">400</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span>,<span class="hljs-number"><span class="hljs-number">300</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span>,<span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span>,<span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">400</span></span>,<span class="hljs-number"><span class="hljs-number">300</span></span> <span class="hljs-number"><span class="hljs-number">300</span></span>Z‚Äù <span class="hljs-comment"><span class="hljs-comment">//</span></span></code> </pre> <br>  Il existe encore toutes sortes de petits pains avec des types de remplissages, bords, coudes: <br><br><img src="https://habrastorage.org/webt/wx/uy/wv/wxuywvdg2rfuxlrrasn_hh9yzkm.jpeg"><br><br>  Je ne d√©crirai pas tout ici, car il y a beaucoup de mat√©riel et il faudra un article entier (si c'est int√©ressant, je vais l'√©crire en quelque sorte). <br><br>  Voici une liste de primitives de rendu <br><br><ul><li>  Courbes cubiques </li><li>  Courbes quadratiques </li><li>  Lignes </li><li>  Glyphes de police </li><li>  Arcs </li><li>  Style Dash &amp; Endcap </li></ul><br>  Voici du code, puis il y a beaucoup de texte: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// SVG  glPathStringNV( pathObj, GL_PATH_FORMAT_SVG_NV, strlen(svgPathString), svgPathString); //  glStencilFillPathNV( pathObj, GL_COUNT_UP_NV, 0x1F); // //  ( ) glCoverFillPathNV( pathObj, GL_BOUNDING_BOX_NV);</span></span></code> </pre> <br>  C‚Äôest tout. <br><br>  Il me semble que cet article est sorti moins int√©ressant et informatif, il √©tait difficile de distinguer l'essentiel du mat√©riel.  Si quelqu'un souhaite en savoir plus en d√©tail, je peux supprimer certains documents NVidia et les liens vers les sp√©cifications (si je me souviens o√π je les ai enregistr√©s).  Je suis √©galement heureux de toute aide dans l'√©dition de l'article. <br><br>  Comme promis, j'√©crirai l'article suivant sur l'optimisation et la r√©duction des appels de tirage.  Je voudrais vous demander d'√©crire dans les commentaires ce que vous aimeriez lire d'autre et ce qui vous int√©resse: <br><ul><li>  √âcrire un jeu sur cocos2d-x (Entra√Ænement uniquement, pas d'eau) </li><li>  Traduction d'une s√©rie d'articles sur Vulkan </li><li>  Quelques sujets sur OpenGL (quaternions, nouvelles fonctionnalit√©s) </li><li>  Algorithmes d'infographie (√©clairage, occlusion ambiante de l'√©cran spatial, r√©flexion de l'√©cran spatial) </li><li>  Vos options </li></ul><br><br>  Merci √† tous pour votre attention. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr457380/">https://habr.com/ru/post/fr457380/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr457354/index.html">Obfuscation des donn√©es pour les tests de performances</a></li>
<li><a href="../fr457362/index.html">Promotion de RUVDS: pr√©parer le serveur en √©t√©</a></li>
<li><a href="../fr457366/index.html">Un fanatique, un morceau de fer ou un spectateur - quel genre de joueur √™tes-vous?</a></li>
<li><a href="../fr457374/index.html">R√©duisez le temps de construction de vos projets Android</a></li>
<li><a href="../fr457378/index.html">Comment id Software a cr√©√© Wolfenstein 3D bas√© sur la technologie du commandant Keen</a></li>
<li><a href="../fr457382/index.html">7 habitudes des programmeurs performants</a></li>
<li><a href="../fr457386/index.html">Pr√©sentation des interfaces virtuelles Linux: tunnels</a></li>
<li><a href="../fr457390/index.html">Madagascar - √Æle des contrastes</a></li>
<li><a href="../fr457392/index.html">√âconomies sur le d√©veloppement multiplateforme mobile: √©tude de cas Skyeng</a></li>
<li><a href="../fr457396/index.html">D√©verrouillage automatique du conteneur racine LUKS apr√®s un d√©marrage √† chaud</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>