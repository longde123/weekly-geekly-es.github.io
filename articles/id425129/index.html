<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úçüèΩ üèΩ üëã Bagaimana cara mengotomatisasi pembuatan mesin virtual? Kami memberi tahu secara detail üìÄ üÜë üñ±Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Membuat mesin virtual baru adalah rutinitas yang menyita waktu. Dan semakin banyak infrastruktur dan organisasi, semakin banyak prosedur yang terkait ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana cara mengotomatisasi pembuatan mesin virtual? Kami memberi tahu secara detail</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/icl_services/blog/425129/"> Membuat mesin virtual baru adalah rutinitas yang menyita waktu.  Dan semakin banyak infrastruktur dan organisasi, semakin banyak prosedur yang terkait dengan proses ini.  Kami mengotomatiskan proses ini menggunakan PowerShell. <br><br>  Selamat datang di kat jika Anda tertarik. <br><br><img src="https://habrastorage.org/webt/fv/fr/cc/fvfrccl_crsi5nfvcnstarorits.jpeg"><br><br><a name="habracut"></a><br>  Pemrogram tidak suka melakukan pekerjaan ganda, administrator sistem juga. <br><br>  Di bawah ini adalah contoh otomatisasi salah satu pelanggan kami. <br><br>  Kami ingin memastikan bahwa setiap insinyur atau manajer proyek dapat membuat mesin virtual baru dengan upaya minimal dan untuk periode minimum.  Pelanggan kami memiliki sistem ITSM, dalam contoh ini adalah ServiceNow, kami membuat formulir web yang sesuai dalam katalog layanan.  Untuk "memesan" mesin baru, manajer perlu mengisi kolom dan mengkonfirmasi "pesanan", setelah itu rantai proses diluncurkan, dan pada output kita mendapatkan mesin siap untuk digunakan. <br><br>  Jadi, mari kita lihat apa yang perlu didefinisikan manajer untuk membuat mesin virtual baru: <br><br><img src="https://habrastorage.org/webt/3l/8d/yo/3l8dyowobrfvbgpznotayqjywvu.png"><br><br>  <b>Deskripsi VM: deskripsi mesin virtual</b> <b><br></b>  Beberapa klarifikasi diperlukan di sini.  Dalam solusi kami, PowerShell 5.1 digunakan secara aktif, jadi untuk Windows saja, di masa mendatang kami akan mencoba menambahkan dukungan untuk mesin Unix dan beralih ke PowerShell Core. <br><br>  <b>OS</b> , sistem operasi.  Tidak ada hambatan khusus untuk menggunakan Windows 2008 (R2), tetapi kami menggunakan 2012R2 atau 2016. <br><br>  <b>Ukuran VM</b> , ukuran mesin virtual.  Untuk masing-masing, ini dapat ditentukan dengan caranya sendiri, dalam contoh ini Ram 1CPU-4Gb Kecil, Sedang 2CPU-8Gb, Besar 4-16. <br><br>  <b>Penyimpanan VM</b> , Disk 0 (C: \) memiliki ukuran tetap yang tidak dapat Anda ubah, hanya pemilih penyimpanan Fast / Slow yang tersedia.  "Cepat" dapat menjadi Tier Penyimpanan dengan SSD, dan "Lambat" dapat disimpan pada HDD "biasa" (tentu saja, SAN).  Disk1 (Disk2 dan seterusnya) juga memiliki pemilih untuk memilih Penyimpanan, serta bidang untuk memasukkan ukuran yang diinginkan dalam gigabyte, Surat untuk partisi dan ukuran kluster (yang penting untuk SQL Server). <br><br>  <b>Percayalah</b> , kami menentukan bahwa mesin harus bergabung dengan Domain atau tidak, dengan akses dari Jaringan Publik atau tidak. <br><br>  <b>Jenis</b> , jenis mesin.  Hampir setiap mesin dapat didefinisikan sebagai aplikasi front-end atau back-end atau lainnya dalam semua kasus lainnya.  Berdasarkan jenis yang dipilih, kita dapat lebih lanjut menentukan subnet yang paling cocok untuk mesin. <br><br>  <b>Lingkungan</b> , dalam infrastruktur pelanggan ada dua pusat data: Primer (Produksi) dan Sekunder (Dev / tes), DC dihubungkan oleh saluran komunikasi cepat dan memberikan toleransi kesalahan.  Dengan persetujuan, semua mesin virtual di DC Primer memiliki alamat IP mulai dari 10.230, dan di Secondary DC pada 10.231. <br><br>  <b>(SLA) Perjanjian Tingkat Layanan</b> , parameter ini memengaruhi kualitas layanan untuk mesin ini. <br><br>  <b>Aplikasi</b>  Kami telah menambahkan kemampuan untuk menginstal dan mengkonfigurasi SQL Server.  Anda harus memilih edisi, nama instance, dan collation.  Dimungkinkan juga untuk mengkonfigurasi peran Server Web dan banyak lagi. <br><br>  Sekarang kita perlu menentukan cara menyimpan nilai yang dipilih.  Kami memutuskan bahwa format yang paling nyaman adalah file JSON.  Seperti yang saya katakan sebelumnya, lingkungan pelanggan menggunakan ITSM ServiceNow;  manajer, setelah memilih semua nilai yang diperlukan, klik tombol "order" dan setelah itu ServiceNow meneruskan semua parameter ke skrip PowerShell kami (ke ServiceNow back-end), yang akan membuat file JSON.  Itu terlihat seperti ini: <br><br><pre><code class="plaintext hljs">.\CreateConfiguration.ps1 -SecurityZone trusted -VMDescription "VM for CRM System" -Requestor "evgeniy.vpro" -OSVersion 2k16 -OSEdition Standard -BuildNewVM -VMEnvironment Prod -VMServiceLevel GOLD -VMSize Medium -Disk0Tier Fast -Disk1Size 50 -Disk1Tier Eco -Disk1Letter D -MSSQLServer -MSSQLInstanceName "Instance1" -SQLCollation Latin1_General_CI_AS -SQLEdition Standard -Disk2Size 35 -Disk3Size 65</code> </pre> <br><br>  Di badan skrip CreateConfiguration .ps1: <br><br><pre> <code class="plaintext hljs"># PowerShell- $config = [ordered]@{} #    . $config.SecurityZone=$SecurityZone</code> </pre><br><br>  Pada akhirnya, ekspor objek kami ke file JSON: <br><br><pre> <code class="plaintext hljs">$ServerConfig = New-Object ‚ÄìTypeName PSObject $config ConvertTo-Json -InputObject $ServerConfig -Depth 100 | Out-File "C:\Configs\TargetNodes\Build\$($Hostname.ToLower()).json" -Force</code> </pre><br><br>  Konfigurasi sampel: <br><br><pre> <code class="plaintext hljs">{ "Hostname": "dsctest552", "SecurityZone": "trusted", "Domain": "testdomain", "Requestor": "evgeniy.vpro", "VM": { "Size": "Medium", "Environment": "Prod", "SLA": "GOLD", "DbEngine": "MSSQL", "RAM": 8, "Storage": [ { "Id": 0, "Tier": "Fast", "Size": "100", "Allocation": 4, "Letter": "C" }, { "Id": 1, "Tier": "Eco", "Size": 50, "Label": "Data", "Allocation": 64, "Letter": "D" }, { "Id": 2, "Tier": "Fast", "Size": 35, "Label": "Data", "Allocation": 64, "Letter": "E" }, { "Id": 3, "Tier": "Fast", "Size": 65, "Label": "Data", "Allocation": 64, "Letter": "F" } ] }, "Network": { "MAC": "", "IP": "10.230.168.50", "Gateway": "10.230.168.1", "VLAN": ‚ÄúVLAN168‚Äù }, "OS": { "Version": "2k16", "Edition": "Standard", "Administrators": [ "LocaAdmin", "testdomain\\ Security-LocalAdmins" ] }, "OU": "OU=Servers,OU=Staging,DC=testdomain", "Applications": [ { "Application": "Microsoft SQL Server 2016", "InstanceName": "vd", "Collation": "Latin1_General_CI_AS", "Edition": "Standard", "Features": "SQLENGINE", "Folders": { "DataRoot": "E:\\MSSQL", "UserDB": "E:\\MSSQL\\MSSQL11.vd\\MSSQL\\Data", "UserLog": "E:\\MSSQL\\MSSQL11.vd\\MSSQL\\Log", "TempDB": "D:\\MSSQL\\MSSQL11.vd\\MSSQL\\TempDB", "TempDBLog": "D:\\MSSQL\\MSSQL11.vd\\MSSQL\\TempDB", "Backup": "E:\\MSSQL\\MSSQL11.vd\\MSSQL\\Backup" }, "MaxMemory": 2147483647 } ], "Description": "VM for CRM", "Certificate": { "File": null, "Thumbprint": null }, "Version": 0 }</code> </pre><br><br>  Anda mungkin telah memperhatikan bahwa formulir web tidak memiliki nama mesin virtual dan alamat IP.  Kami mendapatkan nilai-nilai ini secara otomatis sebagai berikut: <br><br>  <b>Nama mesin</b> , ITSM ServiceNow memiliki bagian khusus: CMDB (Basis Data Manajemen Konfigurasi), basis data ini menyimpan semua catatan tentang mesin virtual yang ada, statusnya, tim pendukung, dll.  Kami telah membuat sekitar 200 catatan cadangan dengan status yang dialokasikan.  Untuk mendapatkan nama untuk mesin virtual, kami membuat permintaan REST ke CMDB dan mendapatkan catatan "bebas" pertama dan mengubah statusnya dari Alokasi ke instalasi Tertunda. <br><br>  <b>Alamat IP dan VLAN</b> , kami menyebarkan IPAM di jaringan kami - ini adalah fitur bawaan di Windows Server 2016 yang memungkinkan Anda untuk mengelola alamat IP di jaringan Anda.  Sama sekali tidak perlu menggunakan semua fitur IPAM (DHCP, DNS, AD), tetapi menggunakannya hanya sebagai basis data alamat IP dengan potensi ekstensi fungsi.  Skrip yang membuat file JSON membuat permintaan ke IPAM untuk alamat IP gratis pertama di subnet.  Dan subnet VLAN (x / 24 subnet) ditentukan berdasarkan nilai SLA, Environment, Trust, dan Type yang dipilih. <br>  File konfigurasi sudah siap, semua bidang sudah ada, Anda dapat membuat mesin.  Pertanyaannya adalah, "bagaimana cara menyimpan kredensial untuk semua skrip kami?".  Kami menggunakan paket <a href="">CredentialManager</a> .  Paket ini berfungsi dengan API Credential Manager Windows bawaan untuk menyimpan kata sandi.  Contoh membuat kata sandi: <br><br><pre> <code class="plaintext hljs">New-StoredCredential -Target "ESXi" -UserName "testdomain.eu\vmwareadm" -Password "veryultraP@ssw00rd." -Type Generic -Persist LocalMachine</code> </pre><br><br>  Kata sandi akan tersedia untuk dibaca dalam mesin dan akun ini. <br><br><pre> <code class="plaintext hljs">$ESXiAdmin = Get-StoredCredential -Type Generic -Target ESXi</code> </pre> <br><br>  Kami memiliki server tempat semua konfigurasi dengan GIT disimpan, sekarang kami dapat melacak semua perubahan dalam konfigurasi dengan andal: siapa, apa, di mana, dan kapan. <br><br>  Tugas terjadwal dikonfigurasikan di server ini: periksa folder dengan konfigurasi dan tulis di Windows Event Log tentang semua perubahan. <br><br>  Setelah 15 menit, tugas yang dijadwalkan akan menulis ke Windows EventLog bahwa file konfigurasi baru telah terdeteksi. <br><br>  Sudah waktunya untuk memeriksa konfigurasi ini.  Pertama-tama, kita perlu memastikan bahwa file memiliki format yang benar: <br><br><pre> <code class="plaintext hljs">$Configuration=(Get-Content -Raw $File | Out-String | ConvertFrom-Json)</code> </pre> <br><br>  Jika semuanya baik-baik saja, saatnya untuk mulai membuat mesin dan menjalankan skrip BuildVM.ps1. <br><br>  Dalam BuildVM.ps1, kami memverifikasi bahwa file konfigurasi memiliki deskripsi semua karakteristik mesin virtual: ukuran, env, sla, jenis, penyimpanan, ram, jaringan. <br><br>  Pastikan untuk memeriksa apakah ada mesin dengan nama yang sama di infrastruktur (CheckVM.ps1). <br>  Kami terhubung melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">VMWare PowerShell CLI</a> ke vSphere kami: <br><br><pre> <code class="plaintext hljs">$VmWareAdmin = Get-StoredCredential -Type Generic -Target ESXi Connect-VIServer -Server "vSphereSrv" -Credential $VmWareAdmin | Out-Null</code> </pre><br><br>  Periksa apakah ada mesin dengan nama yang sama di infrastruktur <br><br><pre> <code class="plaintext hljs">$VM=Get-VM $server -ErrorAction SilentlyContinue</code> </pre> <br><br>  Dan matikan: <br><br><pre> <code class="plaintext hljs">Disconnect-VIServer * -Force -Confirm:$false</code> </pre> <br><br>  Pastikan bahwa mesin juga tidak tersedia di WinRM <br><br><pre> <code class="plaintext hljs">$ping=Test-NetConnection -ComputerName $Configuration.Hostname -CommonTCPPort WINRM -InformationLevel Quiet -ErrorAction SilentlyContinue</code> </pre> <br><br>  Jika $ VM dan $ ping kosong, maka Anda dapat membuat mesin baru.  (Kami menangani situasi ketika mesin sudah dibuat secara manual di ESXi atau mesin ini di pusat data lain.) <br><br><blockquote>  Beberapa kata tentang mobil.  Ini adalah gambar mesin virtual yang disiapkan yang diselesaikan oleh sysprep dan dikonversi menjadi templat di vSphere kami.  Administrator lokal dengan kata sandi yang kita tahu disimpan dalam gambar, akun ini tidak macet setelah sysprep, yang akan memungkinkan kita untuk mengakses setiap mesin dari templat ini, dan nanti kita dapat mengganti kata sandi ini untuk tujuan keamanan. </blockquote><br><br><h3>  Menciptakan mesin virtual <br></h3><br>  Temukan gugus SLR yang sesuai: <br><br><pre> <code class="plaintext hljs">$Cluster=Get-Cluster -Name $Configuration.VM.SLA</code> </pre> <br><br>  Periksa apakah kami memiliki cukup ruang di Datastore: <br><br><pre> <code class="plaintext hljs">$DatastoreCluster = Get-DatastoreCluster |Where-Object {$_.Name -like $Datastore1Name} $Datastore1 = Get-Datastore -Location $DatastoreCluster |sort -Property "FreeSpaceGB" |select -Last 1 IF ($Datastore1.FreeSpaceGB -le "200"){ Write-Host -foreground red "STOP: Not enough datastore capacity for DISK" $vdisk.Id Break }</code> </pre><br><br>  Dan cukup memori: <br><br><pre> <code class="plaintext hljs">$VMHost = Get-VMHost -Location $Cluster |sort -Property "MemoryUsageGB" |select -First 1 IF ($VMHost.MemoryUsageGB -le "20"){ Write-Host -foreground red "STOP: No enough ESXi host capacity" Break }</code> </pre><br><br>  Kami mengambil templat kami <br><br><pre> <code class="plaintext hljs">$VMTemplate = Get-Template -Name 'Win2016_Std_x64_Template'</code> </pre> <br><br>  Dan buat mesin virtual baru <br><br><pre> <code class="plaintext hljs">New-VM -Name $Configuration.Hostname.ToUpper() -VMHost $VMHost -ResourcePool $ResourcePool -Datastore $Datastore -Template $VMTemplate -Location "AutoDeployed VMs"</code> </pre> <br><br>  Penting untuk menghubungkan antarmuka jaringan ke subnet dengan DHCP diaktifkan. <br><br>  Kami memulai mesin virtual <br><br><pre> <code class="plaintext hljs">Start-VM $VM</code> </pre> <br><br>  Dan simpan deskripsi mesin, sehingga nanti Anda bisa menentukan mesin di level VMWare. <br><br><pre> <code class="plaintext hljs">Set-Annotation -Entity $VM -CustomAttribute "Change request" -Value $Configuration.Request -Confirm:$false Set-VM $VM -Notes $Configuration.Description -Confirm:$false</code> </pre><br><br>  Mesin mulai hidup dan sekarang kita bisa mengetahui alamat MAC yang diterima: <br><br><pre> <code class="plaintext hljs">$vMAC = (($VM | Get-NetworkAdapter | Select-Object -Property "MacAddress").MacAddress).Replace(':','')</code> </pre> <br><br>  Simpan nilai ini ke file JSON kami. <br><br><pre> <code class="plaintext hljs">$Configuration.Network.MAC=$VMAC ConvertTo-Json -InputObject $Configuration -Depth 100 | Out-File "C:\Configs\TargetNodes\Build\$Hostname.json" -Force</code> </pre><br><br>  Inilah saatnya untuk berkomitmen pada Git kami bahwa mesin tersebut dibuat dan memiliki MAC uniknya sendiri. <br><br>  Mesin mulai menginisialisasi (setelah sysprep), mengatur peralatan dan konfigurasi awal. <br><br>  Mari kita tunggu sampai mesin WinRM kami tersedia dengan skrip EstablishConnection.ps1. <br><br>  Pertama-tama kita mencari tahu IP apa yang diterima mesin dari DHCP: <br><br><pre> <code class="plaintext hljs"># $MAC = $vMAC while($isOnline -ne $true){ if((Get-DhcpServerv4Lease -ClientId $MAC -ScopeId $StagingDHCPScope -ComputerName $DHCPServer -ErrorAction Ignore).IPAddress.IPAddressToString){ $tempIP=(Get-DhcpServerv4Lease -ClientId $MAC -ScopeId $StagingDHCPScope -ComputerName $DHCPServer).IPAddress.IPAddressToString break } else{ if($isOnline -ne $true){ Write-Host "`r$i`t" -NoNewline $i++ } } }</code> </pre><br><br>  Dan sekarang kita akan menunggu, ketika mesin akan tersedia di WinRM: <br><br><pre> <code class="plaintext hljs">$LocalAdmin = Get-StoredCredential -Type Generic -Target LocalAdmin $i=0 $isOnline=$false while($isOnline -ne $true){ if(Invoke-Command -ComputerName $tempIP -ScriptBlock{ Get-ItemProperty -Path "Registry::\HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing" } -Credential $LocalAdmin -ErrorAction SilentlyContinue){ $isOnline=$true break } else{ if($isOnline -ne $true){ Write-Host "`r$i" -NoNewline $i++ Start-Sleep -Seconds 1 } } }</code> </pre><br><br>  Mesin siap mengemudi. <br><br><h3>  Konfigurasi keadaan yang diinginkan <br></h3><br>  Untuk mengkonfigurasi konfigurasi yang diinginkan, kami menggunakan bagian PowerShell - DSC (Configuration State Configuration).  Ada Server Tarik DSC yang dikonfigurasi di jaringan: dscpull.testdomain.eu. <br>  Di bawah ini adalah konfigurasi Server Tarik DSC kami.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel bagus tentang konfigurasi Tarik DSC.</a> <br><br><pre> <code class="plaintext hljs">Node $NodeName { WindowsFeature DSCServiceFeature { Ensure = "Present" Name = "DSC-Service" } xDscWebService PSDSCPullServer { Ensure = "Present" EndpointName = "PSDSCPullServer" Port = 8080 PhysicalPath = "$env:SystemDrive\inetpub\PSDSCPullServer" CertificateThumbPrint = $certificateThumbPrint ModulePath = "$env:PROGRAMFILES\WindowsPowerShell\DscService\Modules" ConfigurationPath = "$env:PROGRAMFILES\WindowsPowerShell\DscService\Configuration" State = "Started" DependsOn = "[WindowsFeature]DSCServiceFeature" RegistrationKeyPath = "$env:PROGRAMFILES\WindowsPowerShell\DscService" AcceptSelfSignedCertificates = $true UseSecurityBestPractices = $true } File RegistrationKeyFile { Ensure = 'Present' Type = 'File' DestinationPath = "$env:ProgramFiles\WindowsPowerShell\DscService\RegistrationKeys.txt" Contents = $RegistrationKey } }</code> </pre><br><br>  Ini tersedia di: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://dscpull.testdomain.eu:8080</a> <br><br>  Titik Akhir: <a href="">https://dscpull.testdomain.eu:8080/PSDSCPullserver.svc</a> <br><br>  Semua klien server tarik harus memiliki PowerShell 5.1 yang diinstal <br>  Jika tidak PowerShell 5.1 diinstal: <br><br><pre> <code class="plaintext hljs">$PSVersionTable.PSVersion.Major ‚Äìlt 5</code> </pre> <br><br>  instal PowerShell 5.1: <br><br><pre> <code class="plaintext hljs">Write-Host "Download PowerShell 5.1" Invoke-Command -ComputerName $Node -ScriptBlock { [System.Net.ServicePointManager]::SecurityProtocol=[System.Net.SecurityProtocolType]::Tls12;Invoke-WebRequest -Uri "https://dscpull.testdomain.eu:8080/Files/Updates/WMF.msu" -OutFile C:\TEMP\WMF.MSU } Write-Host "Extract PowerShell 5.1" Invoke-Command -ComputerName $Node -ScriptBlock {Start-Process -FilePath 'wusa.exe' -ArgumentList "C:\temp\WMF.msu /extract:C:\temp\" -Wait -PassThru } Write-Host "Apply PowerShell 5.1" Invoke-Command -ComputerName $Node -ScriptBlock {Start-Process -FilePath 'dism.exe' -ArgumentList "/online /add-package /PackagePath:C:\temp\WindowsBlue-KB3191564-x64.cab /Quiet" -Wait -PassThru } Write-Host "PowerShell 5.1 has been installed"</code> </pre><br><br>  Server PKI juga digunakan di jaringan kami.  Ini adalah kondisi untuk enkripsi aman kredensial yang disimpan dalam file msa DSC (file Mof adalah "bahasa" di mana Pull Server dan kliennya berkomunikasi).  Ketika klien mencoba mendaftar pada Server Tarik, perlu untuk menentukan sertifikat cetak sidik jari dan kemudian pada Server Tarik akan menggunakan sertifikat ini untuk mengenkripsi kata sandi.  Di bawah ini kita akan melihat cara kerjanya. <br><br>  Impor Root CA ke mesin baru kami: <br><br><pre> <code class="plaintext hljs"> Invoke-Command -ComputerName $server -ScriptBlock{ $PKI="-----BEGIN CERTIFICATE----- MIIF2TCCA8GgAwIBAgIQSPIjcff9rotNdxbg3+ygqDANBgkqhkiG9w0BAQUFADAe **************************************************************** znafMvVx0B4tGEz2PFss/FviGdC3RohBHG0rF5jO50J4nS/3cGGm+HGdn1w/tZd0 a0FWpn9VCOSmXM2It+tSW1f4nZVt6T2kr1ZlTxkDhT7HMSGsrX/XJswzCkDGe3dE qrVVjNUkhVTaeeBWdujB5J6mcx7YkNsAUhODiS9Cf7FnYnxLFA72M0pijI48P5F0 ShM9HWAAUIrLkv13ug== -----END CERTIFICATE-----" $PKI | Out-File RootCA.cer Import-Certificate RootCA.cer -CertStoreLocation Cert:\LocalMachine\Root | select Thumbprint | Out-Null } -Credential $LocalAdmin | Out-Null</code> </pre><br><br>  Untuk pekerjaan lebih lanjut, kami membutuhkan sepasang kunci RSA.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kami akan menghasilkan sertifikat yang ditandatangani sendiri</a> dan untuk sementara bekerja dengannya. <br><br>  Sekarang kita bisa mendaftar di Server Tarik: <br><br><pre> <code class="plaintext hljs">$DscHostFQDN = [System.Net.Dns]::GetHostEntry([string]$env:computername).HostName $DscPullServerURL = "https://$($DscHostFQDN):8080/PSDSCPullserver.svc" $DscWebConfigChildPath = '\inetpub\psdscpullserver\web.config' $DscWebConfigPath = Join-Path -Path $env:SystemDrive -ChildPath $DscWebConfigChildPath $DscWebConfigXML = [xml](Get-Content $DscWebConfigPath) $DscRegKeyName = 'RegistrationKeys.txt' $DscRegKeyXMLNode = "//appSettings/add[@key = 'RegistrationKeyPath']" $DscRegKeyParentPath = ($DscWebConfigXML.SelectNodes($DscRegKeyXMLNode)).value $DscRegKeyPath = Join-Path -Path $DscRegKeyParentPath -ChildPath $DscRegKeyName $DscRegKey = Get-Content $DscRegKeyPath [DSCLocalConfigurationManager()] configuration RegisterOnPull { Node $Node { Settings { ConfigurationModeFrequencyMins = 1440 CertificateID = $Thumbprint RefreshMode ='Pull' RefreshFrequencyMins = 1440 RebootNodeIfNeeded = $true ConfigurationMode ='ApplyAndAutoCorrect' AllowModuleOverwrite = $true DebugMode = 'None' StatusRetentionTimeInDays = 1 } ConfigurationRepositoryWeb $([string]$env:computername) { ServerURL = $DscPullServerURL RegistrationKey = $DscRegKey CertificateID = $Thumbprint ConfigurationNames = @("$hostx") } } } RegisterOnPull -OutputPath $MetaConfigsStorage Set-DscLocalConfigurationManager -ComputerName $Node -Path $MetaConfigsStorage -Verbose -Force -Credential $LocalAdmin</code> </pre><br><br>  Kirim konfigurasi pertama ke mesin kami <br><br><pre> <code class="plaintext hljs">Configuration Rename { param ( [Parameter()] [System.String[]] $Node, $hostname ) Import-DscResource -ModuleName xComputerManagement Import-DscResource ‚ÄìModuleName PSDesiredStateConfiguration Node $Node { xComputer JoinDomain { Name = $hostname } } } Rename -Node $Node -OutputPath $DscConfigPath -hostname $hostname New-DscChecksum $DscConfigPath -Force Invoke-Command -ComputerName $Node -ScriptBlock{Update-DscConfiguration -Verbose -Wait } -Credential $LocalAdmin -Verbose</code> </pre><br><br>  Server akan secara otomatis mengganti nama dan reboot.  Sekarang kita bisa menjalankan Join Domain. <br><br><pre> <code class="plaintext hljs">Configuration JoinAD { param ( [Parameter()] [System.String[]] $Node, [Parameter(Mandatory = $true)] [ValidateNotNullorEmpty()] [System.Management.Automation.PSCredential] $DomainAdmin, $hostname, $domain ) Import-DscResource -ModuleName xComputerManagement Import-DscResource ‚ÄìModuleName PSDesiredStateConfiguration Node $Node { xComputer JoinDomain { Name = $hostname DomainName = $domain Credential = $DomainAdmin JoinOU = "OU=Servers,OU=Staging,DC=testdomain,DC=eu" } GroupSet LocalAdmins { GroupName = @( 'Administrators') Ensure = 'Present' MembersToInclude = @( 'testdomain-eu\dscstaging' ) } } } $cd = @{ AllNodes = @( @{ NodeName = $Node PSDscAllowPlainTextPassword = $false PSDscAllowDomainUser=$true Certificatefile = $CertFile Thumbprint = $Certificate.ToString() } ) } JoinAD -Node $Node -OutputPath $DscConfigPath -DomainAdmin $DomainAdmin -hostname $hostname -ConfigurationData $cd -domain $domain New-DscChecksum $DscConfigPath -Force Invoke-Command -ComputerName $Node -ScriptBlock{Update-DscConfiguration -Verbose -Wait } -Credential $LocalAdmin -Verbose</code> </pre><br><br>  Seperti inilah tampilan file mof kami: <br><br><pre> <code class="plaintext hljs">instance of MSFT_Credential as $MSFT_Credential1ref { Password = "-----BEGIN CMS-----\nMIIBsgYJKoZIhvcNAQcDoIIBozCCAZ8CAQAxggFKMIIBRgIBADAuMBoxGDAWBgNVBAMMD1dJTi1H\nNFFKTFFQME4xNQIQOQN77pxew75HU6l7GPn99TANBgkqhkiG9w0BAQcwAASCAQAlhFf7Zs2gJbJEnc1DEK2yWbKcO+BEyD2cr6vKHdn\nQ9TrjvbysEOvYjT15o6MccwkMEwGCSqGSIb3DQEHATAdBglghkgBZQMEASoEEEdKJT+GX4IkPezR\nwYncyQiAIAFKxwJocH4ufRsq9L2Ipkp+VQCx2ljlwif6ac4X/PqG\n-----END CMS-----"; UserName = "testdomain.eu\\service_DomainJoin_001"; }; instance of MSFT_xComputer as $MSFT_xComputer1ref { ResourceID = "[xComputer]JoinDomain"; Credential = $MSFT_Credential1ref; DomainName = "testdomain.eu"; SourceInfo = "C:\\Program Files\\WindowsPowerShell\\Scripts\\JoinAD.ps1::34::9::xComputer"; Name = "dsctest51"; JoinOU = "OU=Servers,OU=Staging,DC=testdomain,DC=eu"; ModuleName = "xComputerManagement"; ModuleVersion = "4.1.0.0"; ConfigurationName = "JoinAD"; };</code> nMIIBsgYJKoZIhvcNAQcDoIIBozCCAZ8CAQAxggFKMIIBRgIBADAuMBoxGDAWBgNVBAMMD1dJTi1H \ nNFFKTFFQME4xNQIQOQN77pxew75HU6l7GPn99TANBgkqhkiG9w0BAQcwAASCAQAlhFf7Zs2gJbJEnc1DEK2yWbKcO + BEyD2cr6vKHdn \ nQ9TrjvbysEOvYjT15o6MccwkMEwGCSqGSIb3DQEHATAdBglghkgBZQMEASoEEEdKJT + GX4IkPezR \ nwYncyQiAIAFKxwJocH4ufRsq9L2Ipkp + VQCx2ljlwif6ac4X / PqG \ n ----- END CMS -----"; <code class="plaintext hljs">instance of MSFT_Credential as $MSFT_Credential1ref { Password = "-----BEGIN CMS-----\nMIIBsgYJKoZIhvcNAQcDoIIBozCCAZ8CAQAxggFKMIIBRgIBADAuMBoxGDAWBgNVBAMMD1dJTi1H\nNFFKTFFQME4xNQIQOQN77pxew75HU6l7GPn99TANBgkqhkiG9w0BAQcwAASCAQAlhFf7Zs2gJbJEnc1DEK2yWbKcO+BEyD2cr6vKHdn\nQ9TrjvbysEOvYjT15o6MccwkMEwGCSqGSIb3DQEHATAdBglghkgBZQMEASoEEEdKJT+GX4IkPezR\nwYncyQiAIAFKxwJocH4ufRsq9L2Ipkp+VQCx2ljlwif6ac4X/PqG\n-----END CMS-----"; UserName = "testdomain.eu\\service_DomainJoin_001"; }; instance of MSFT_xComputer as $MSFT_xComputer1ref { ResourceID = "[xComputer]JoinDomain"; Credential = $MSFT_Credential1ref; DomainName = "testdomain.eu"; SourceInfo = "C:\\Program Files\\WindowsPowerShell\\Scripts\\JoinAD.ps1::34::9::xComputer"; Name = "dsctest51"; JoinOU = "OU=Servers,OU=Staging,DC=testdomain,DC=eu"; ModuleName = "xComputerManagement"; ModuleVersion = "4.1.0.0"; ConfigurationName = "JoinAD"; };</code> </pre><br><br>  Kredensial terenkripsi DSC dari akun layanan dengan hak Admin Domain: testdomain.eu \\ service_DomainJoin_001 dengan sertifikat yang ditandatangani sendiri.  Klien DSC dengan Kunci Privatnya mendekripsi kredensial dan menerapkan semua modul konfigurasi dengan kredensial domain yang ditentukan.  Dalam hal ini, ia melakukan Domain Bergabung di unit organisasi yang ditentukan. <br><br><pre> <code class="plaintext hljs">GroupSet LocalAdmins { GroupName = @( 'Administrators') Ensure = 'Present' MembersToInclude = @( testdomain-eu\dscstaging' ) }</code> </pre><br><br>  Modul ini menambahkan dscstaging ke administrator lokal untuk konfigurasi lebih lanjut. <br><br>  Setelah mem-boot ulang, kita akan dapat memasuki mesin dengan kredensial domain. <br><br>  Kami sedang menunggu server menerima sertifikat dari PKI kami (kami telah mengonfigurasi pendaftaran otomatis) dan di masa mendatang kami akan bekerja dengan sertifikat yang dikeluarkan oleh PKI kami. <br><br><pre> <code class="plaintext hljs">$vmcert=Invoke-Command -ComputerName $server -ScriptBlock{ return Get-ChildItem -Path cert:\LocalMachine\My | where {$_.EnhancedKeyUsageList.FriendlyName -eq "Document Encryption"-and $_.Issuer -eq "CN=TestDomain Issuing CA, DC=testdomain, DC=eu"} } -ErrorAction Ignore</code> </pre> <br><br>  Sekarang mendaftar untuk Tarik Server lagi dengan cap jempol yang diperbarui. <br><br>  Itu saja, mesin yang bergabung dengan domain, dan kita bisa menggunakannya dengan cara yang sesuai dengan kita. <br><br><h3>  Instal SQL Server <br></h3><br>  File JSON menjelaskan persyaratan untuk MS SQL Server, kami juga menggunakan DSC untuk menginstal dan mengkonfigurasi SQL Server.  Seperti inilah bentuk konfigurasi: <br><br><pre> <code class="plaintext hljs">Configuration $Node{ WindowsFeature "NetFramework35"{ Name = "NET-Framework-Core" Ensure = "Present" Source = "\\$DscHostFQDN\Files\Updates" } WindowsFeature "NetFramework45"{ Name = "NET-Framework-45-Core" Ensure= "Present" } SqlSetup "MSSQL2012NamedInstance"{ InstanceName = $MSSQL.InstanceName Features = $MSSQL.Features ProductKey = $ProductKey SQLCollation = $MSSQL.Collation SQLSysAdminAccounts = @('testdomain-EU\SQLAdmins',' testdomain-EU\Backup') InstallSharedDir = "C:\Program Files\Microsoft SQL Server" InstallSharedWOWDir = "C:\Program Files (x86)\Microsoft SQL Server" InstallSQLDataDir = $MSSQL.DataRoot SQLUserDBDir = $MSSQL.UserDBDir SQLUserDBLogDir = $MSSQL.UserLogDir SQLTempDBDir = $MSSQL.TempDBDir SQLTempDBLogDir = $MSSQL.TempDBLogDir SQLBackupDir = $MSSQL.BackupDir SourcePath = $SQLSource SAPwd = $SA SecurityMode = 'SQL' UpdateSource = ".\Updates" Action = "Install" ForceReboot = $True SQLSvcAccount = $SqlServiceCredential AgtSvcAccount = $SqlServiceCredential ISSvcAccount = $SqlServiceCredential BrowserSvcStartupType = "Automatic" DependsOn = '[WindowsFeature]NetFramework35', '[WindowsFeature]NetFramework45' }</code> </pre><br>  Di mana $ MSSQL didefinisikan: <br><pre> <code class="plaintext hljs">$MSSQL=$Configuration.Applications | where {$_.Application -eq "Microsoft SQL Server 2012"}</code> </pre> <br><br>  $ MSSQL.InstanceName - semua ini ditunjukkan dalam file Json kami.  Menerapkan konfigurasi ini akan menginstal MS SQL Server dengan semua pembaruan di folder Pembaruan dan me-restart server jika perlu. <br><br>  Mobil sudah siap. <br><br><h2>  Servis sekarang </h2><br>  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beberapa API yang tersedia</a> di Layanan-Sekarang.  Kami menggunakan API Istirahat. <br>  Untuk mendapatkan daftar mesin dengan status yang dialokasikan, kueri formulir digunakan: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">instance.service-now.com/cmdb_ci_server_list.do?sysparm_query=install_status=16</a> ^ u_subtype = ^ ORDERBYname <br>  Di PowerShell, tampilannya seperti ini: <br><pre> <code class="plaintext hljs">$url="https://instance.service-now.com/api/now/table/cmdb_ci_server?sysparm_query=install_status=16^u_subtype=^ORDERBYname" $uri= new-object System.Uri("https://instance.service-now.com/") #       $credentials = (Get-StoredCredential -Type Generic -Target DSC).GetNetworkCredential() $credentials = new-object System.Net.NetworkCredential $credentials.UserName, $credentials.SecurePassword Add-Type -AssemblyName System.Net.Http $handler = New-Object System.Net.Http.HttpClientHandler $handler.CookieContainer = New-Object System.Net.CookieContainer $handler.UseCookies=$true $handler.Credentials=$credentials $HttpClient = New-Object System.Net.Http.HttpClient($handler) $HttpClient.BaseAddress= $uri $Header = New-Object System.Net.Http.Headers.MediaTypeWithQualityHeaderValue("application/json") $HttpClient.DefaultRequestHeaders.Accept.Clear() $HttpClient.DefaultRequestHeaders.Accept.Add($Header); $response=$HttpClient.GetAsync($url) $respStream=$response.Result.Content.ReadAsStringAsync() $Servers = $respStream.Result | ConvertFrom-Json #   Configuration Items  $ServersCI=$Servers.result</code> </pre> <br>  Objek array pertama adalah nama host yang kita butuhkan. <br>  Jika mesin siap, maka Anda dapat mengubah status mesin di Service-Now, untuk ini skrip UpdateCI.ps1: <br><pre> <code class="plaintext hljs">param( $CI, [ValidateSet("Allocated","In use","Pending install")] $NewStatus='In use' ) $url="https://instance.service-now.com/api/now/table/cmdb_ci_server?sysparm_query=name=$CI" $uri= new-object System.Uri("https://instance.service-now.com/") $credentials = (Get-StoredCredential -Type Generic -Target DSC).GetNetworkCredential() $credentials = new-object System.Net.NetworkCredential $credentials.UserName, $credentials.SecurePassword Add-Type -AssemblyName System.Net.Http $handler = New-Object System.Net.Http.HttpClientHandler $handler.CookieContainer = New-Object System.Net.CookieContainer $handler.UseCookies=$true $handler.Credentials=$credentials $HttpClient = New-Object System.Net.Http.HttpClient($handler) $HttpClient.BaseAddress= $uri $Header = New-Object System.Net.Http.Headers.MediaTypeWithQualityHeaderValue("application/json") $HttpClient.DefaultRequestHeaders.Accept.Clear() $HttpClient.DefaultRequestHeaders.Accept.Add($Header); $response=$HttpClient.GetAsync($url) $respStream=$response.Result.Content.ReadAsStringAsync() $Servers = $respStream.Result | ConvertFrom-Json $ServerCI=$Servers.result[0] $update=@{} if($NewStatus -eq "In use"){ $update.install_status=1 } if($NewStatus -eq "Pending install"){ $update.install_status=4 } $stringcontent = New-Object System.Net.Http.StringContent((ConvertTo-Json -InputObject $update -Depth 100),[System.Text.Encoding]::UTF8, "application/json"); $result=$HttpClient.PutAsync("https://instance.service-now.com/api/now/table/cmdb_ci_server/$($ServerCI.sys_id)", $stringcontent)</code> </pre> <br>  Untuk mendapatkan tabel dan catatan, REST API GET permintaan digunakan, untuk mengubah catatan permintaan PUT / POST, di tubuh mana bidang yang perlu Anda ubah. <br><br>  <i>Kami telah membuat alat yang nyaman dengan alat grafis seperti Azure Portal, yang memungkinkan kami mengelola infrastruktur di tempat senyaman mungkin bagi kami dan pelanggan kami.</i> <br>  PS 12.24.2018.  Apakah semuanya tampak ketinggalan zaman?  Saatnya menggunakan Azure DevOps.  Pada artikel berikutnya, saya akan menunjukkan kepada Anda bagaimana melakukan semua ini dengan pipa Azure DevOps. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425129/">https://habr.com/ru/post/id425129/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425113/index.html">"Digital tipografi" atau pengalaman saya dalam digitalisasi buku</a></li>
<li><a href="../id425115/index.html">Full-blown DevOps: Tragedi Yunani dalam tiga babak</a></li>
<li><a href="../id425117/index.html">Dua bit per transistor: ROM densitas tinggi dalam chip Intel 8087 floating-point</a></li>
<li><a href="../id425123/index.html">Jantung misterius mesin drum Roland TR-808</a></li>
<li><a href="../id425125/index.html">@Pythonetc September 2018</a></li>
<li><a href="../id425131/index.html">Apa yang harus dibaca tentang teknologi blockchain: panduan, buku, dan artikel</a></li>
<li><a href="../id425133/index.html">Masalah pembayaran lintas batas - mengapa dan bagaimana blockchain digunakan di sini</a></li>
<li><a href="../id425135/index.html">Mengapa VoIP diakui sebagai layanan informasi di AS, dan apa artinya bagi industri dan pengguna telekomunikasi</a></li>
<li><a href="../id425137/index.html">Kami bekerja di konsol dengan cepat dan efisien</a></li>
<li><a href="../id425139/index.html">Bintang pop di bawah lensa kecerdasan buatan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>