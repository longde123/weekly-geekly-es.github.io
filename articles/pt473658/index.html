<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî± üèîÔ∏è üë©üèæ‚Äçüöí Lidando com bugs no Go 1.13 üöÇ ü•° üñêÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Na √∫ltima d√©cada, exploramos com sucesso o fato de que o Go lida com erros como valores . Embora a biblioteca padr√£o tenha suporte m√≠nimo para erros: ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lidando com bugs no Go 1.13</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/473658/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/9f/wo/zl/9fwozl-z2zhf7bg5l_i8lfvdxdw.jpeg"></div><br>  Na √∫ltima d√©cada, exploramos com sucesso o fato de que o Go lida com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">erros como valores</a> .  Embora a biblioteca padr√£o tenha suporte m√≠nimo para erros: somente as fun√ß√µes <code>fmt.Errorf</code> e <code>fmt.Errorf</code> que geram um erro contendo apenas uma mensagem - a interface interna permite que os programadores da Go adicionem qualquer informa√ß√£o.  Tudo que voc√™ precisa √© de um tipo que implemente o m√©todo <code>Error</code> : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> QueryError <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Err error } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *QueryError)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.Query + <span class="hljs-string"><span class="hljs-string">": "</span></span> + e.Err.Error() }</code> </pre> <a name="habracut"></a><br>  Esses tipos de erros s√£o encontrados em todos os idiomas e armazenam uma grande variedade de informa√ß√µes, de carimbos de data e hora a nomes de arquivos e endere√ßos de servidores.  Erros de baixo n√≠vel que fornecem contexto adicional s√£o frequentemente mencionados. <br><br>  O padr√£o, quando um erro cont√©m outro, √© encontrado com tanta frequ√™ncia no Go que, ap√≥s uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">discuss√£o acalorada</a> no Go 1.13, seu suporte expl√≠cito foi adicionado.  Neste artigo, examinaremos as adi√ß√µes √† biblioteca padr√£o que fornecem o suporte mencionado: tr√™s novas fun√ß√µes no pacote de erros e um novo comando de formata√ß√£o para <code>fmt.Errorf</code> . <br><br>  Antes de discutir as altera√ß√µes em detalhes, vamos falar sobre como os erros foram investigados e constru√≠dos nas vers√µes anteriores do idioma. <br><br><h1>  Erros antes do Go 1.13 </h1><br><h4>  Pesquisa de erro </h4><br>  Erros no Go s√£o significados.  Os programas tomam decis√µes com base nesses valores de maneiras diferentes.  Na maioria das vezes, o erro √© comparado a zero para verificar se a opera√ß√£o falhou. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">// something went wrong }</span></span></code> </pre><br>  √Äs vezes, comparamos o erro para descobrir o valor do <i>controle</i> e ver se ocorreu um erro espec√≠fico. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ErrNotFound = errors.New(<span class="hljs-string"><span class="hljs-string">"not found"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == ErrNotFound { <span class="hljs-comment"><span class="hljs-comment">// something wasn't found }</span></span></code> </pre> <br>  O valor do erro pode ser de qualquer tipo que satisfa√ßa a interface de erro definida no idioma.  Um programa pode usar uma instru√ß√£o de tipo ou uma op√ß√£o de tipo para exibir o valor do erro de um tipo mais espec√≠fico. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> NotFoundError <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *NotFoundError)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.Name + <span class="hljs-string"><span class="hljs-string">": not found"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e, ok := err.(*NotFoundError); ok { <span class="hljs-comment"><span class="hljs-comment">// e.Name wasn't found }</span></span></code> </pre><br><h4>  Adicionando informa√ß√µes </h4><br>  Freq√ºentemente, uma fun√ß√£o passa um erro para a pilha de chamadas, adicionando informa√ß√µes a ela, por exemplo, uma breve descri√ß√£o do que aconteceu quando o erro ocorreu.  Isso √© f√°cil, basta construir um novo erro que inclua o texto do erro anterior: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"decompress %v: %v"</span></span>, name, err) }</code> </pre> <br>  Ao criar um novo erro usando <code>fmt.Errorf</code> descartamos tudo, exceto o texto do erro original.  Como vimos no exemplo <code>QueryError</code> , √†s vezes voc√™ precisa definir um novo tipo de erro que contenha o erro original para salv√°-lo para an√°lise usando o c√≥digo: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> QueryError <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Err error }</code> </pre> <br>  Os programas podem procurar dentro do <code>*QueryError</code> e tomar uma decis√£o com base no erro original.  Isso √†s vezes √© chamado de desembrulhar um erro. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e, ok := err.(*QueryError); ok &amp;&amp; e.Err == ErrPermission { <span class="hljs-comment"><span class="hljs-comment">// query failed because of a permission problem }</span></span></code> </pre> <br>  O tipo <code>os.PathError</code> da biblioteca padr√£o √© outro exemplo de como um erro cont√©m outro. <br><br><h1>  Erros no Go 1.13 </h1><br><h4>  Desembrulhar o m√©todo </h4><br>  No Go 1.13, os pacotes de biblioteca padr√£o <code>errors</code> e <code>fmt</code> simplificaram o <code>fmt</code> erros que cont√™m outros erros.  O mais importante √© a conven√ß√£o, n√£o a mudan√ßa: um erro contendo outro erro pode implementar o m√©todo <code>Unwrap</code> , que retorna o erro original.  Se <code>e1.Unwrap()</code> retornar <code>e2</code> , dizemos que <code>e1</code> <i>empacota</i> <code>e2</code> e voc√™ pode <i>descompactar</i> <code>e1</code> para obter <code>e2</code> . <br><br>  De acordo com esta conven√ß√£o, voc√™ pode atribuir o tipo <code>QueryError</code> descrito acima ao m√©todo <code>QueryError</code> , que retorna o erro contido nele: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *QueryError)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Unwrap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.Err }</code> </pre> <br>  O resultado da descompacta√ß√£o de erro tamb√©m pode conter o m√©todo <code>Unwrap</code> .  A sequ√™ncia de erros obtidos atrav√©s da descompacta√ß√£o repetida, chamamos de <i>cadeia de erros</i> . <br><br><h4>  Investiga√ß√£o de erro com Is e As </h4><br>  No Go 1.13, o pacote de <code>errors</code> cont√©m duas novas fun√ß√µes para investigar erros: <code>Is</code> e <code>As</code> . <br><br>  A fun√ß√£o <code>errors.Is</code> compara um erro com um valor. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Similar to: // if err == ErrNotFound { ‚Ä¶ } if errors.Is(err, ErrNotFound) { // something wasn't found }</span></span></code> </pre> <br>  A fun√ß√£o As verifica se o erro √© de um tipo espec√≠fico. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Similar to: // if e, ok := err.(*QueryError); ok { ‚Ä¶ } var e *QueryError if errors.As(err, &amp;e) { // err is a *QueryError, and e is set to the error's value }</span></span></code> </pre> <br>  No caso mais simples, os <code>errors.Is</code> fun√ß√£o se comporta como uma compara√ß√£o com um erro de controle e os <code>errors.As</code> fun√ß√£o se comporta como uma instru√ß√£o de tipo.  No entanto, ao trabalhar com erros compactados, essas fun√ß√µes avaliam todos os erros na cadeia.  Vejamos o exemplo de <code>QueryError</code> acima para examinar o erro original: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e, ok := err.(*QueryError); ok &amp;&amp; e.Err == ErrPermission { <span class="hljs-comment"><span class="hljs-comment">// query failed because of a permission problem }</span></span></code> </pre> <br>  Usando a fun√ß√£o <code>errors.Is</code> , <code>errors.Is</code> pode escrever isso: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.Is(err, ErrPermission) { <span class="hljs-comment"><span class="hljs-comment">// err, or some error that it wraps, is a permission problem }</span></span></code> </pre> <br>  O pacote de <code>errors</code> tamb√©m cont√©m uma nova fun√ß√£o <code>Unwrap</code> que retorna o resultado da chamada do m√©todo <code>Unwrap</code> do erro ou retorna nulo se o erro n√£o tiver o m√©todo <code>Unwrap</code> .  Geralmente, √© melhor usar <code>errors.Is</code> ou <code>errors.As</code> . Como eles permitem que voc√™ examine toda a cadeia com uma √∫nica chamada. <br><br><h4>  Erro ao compactar com% w </h4><br>  Como mencionei, √© pr√°tica comum usar a fun√ß√£o <code>fmt.Errorf</code> para adicionar informa√ß√µes adicionais ao erro. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"decompress %v: %v"</span></span>, name, err) }</code> </pre> <br>  No Go 1.13, a fun√ß√£o <code>fmt.Errorf</code> suporta o novo comando <code>%w</code> .  Se for, o erro retornado por <code>fmt.Errorf</code> conter√° o m√©todo <code>Unwrap</code> que retorna o argumento <code>%w</code> , que deve ser um erro.  Em todos os outros casos, <code>%w</code> id√™ntico a <code>%v</code> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Return an error which unwraps to err. return fmt.Errorf("decompress %v: %w", name, err) }</span></span></code> </pre> <br>  A compacta√ß√£o do erro com <code>%w</code> torna dispon√≠vel para <code>errors.As</code> . <br><br><pre> <code class="go hljs">err := fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"access denied: %w"</span></span>, ErrPermission) ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.Is(err, ErrPermission) ...</code> </pre><br><h4>  Quando fazer as malas? </h4><br>  Ao adicionar um contexto adicional ao erro usando <code>fmt.Errorf</code> ou uma implementa√ß√£o de tipo personalizado, voc√™ precisa decidir se o novo erro conter√° o original.  N√£o existe uma resposta √∫nica para isso, tudo depende do contexto em que o novo erro √© criado.  Pack para mostrar a sua chamada.  N√£o empacote o erro se isso levar √† divulga√ß√£o dos detalhes da implementa√ß√£o. <br><br>  Por exemplo, imagine uma fun√ß√£o <code>Parse</code> que l√™ uma estrutura de dados complexa no <code>io.Reader</code> .  Se ocorrer um erro, vamos descobrir o n√∫mero da linha e coluna em que ocorreu.  Se ocorreu um erro durante a leitura do <code>io.Reader</code> , precisaremos <code>io.Reader</code> -lo para descobrir o motivo.  Como o chamador foi fornecido com a fun√ß√£o <code>io.Reader</code> , faz sentido mostrar o erro que ele gerou. <br><br>  Outro caso: uma fun√ß√£o que faz v√°rias chamadas ao banco de dados provavelmente n√£o deve retornar um erro no qual o resultado de uma dessas chamadas √© compactado.  Se o banco de dados usado por essa fun√ß√£o fizer parte da implementa√ß√£o, a divulga√ß√£o desses erros violar√° a abstra√ß√£o.  Por exemplo, se a fun√ß√£o <code>LookupUser</code> do pacote <code>pkg</code> usar o pacote Go <code>database/sql</code> , poder√° encontrar o erro <code>sql.ErrNoRows</code> .  Se voc√™ retornar um erro usando <code>fmt.Errorf("accessing DB: %v", err)</code> , o chamador n√£o poder√° olhar para dentro e encontrar <code>sql.ErrNoRows</code> .  Mas se a fun√ß√£o retornar <code>fmt.Errorf("accessing DB: %w", err)</code> , o chamador poder√° escrever: <br><br><pre> <code class="go hljs">err := pkg.LookupUser(...) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.Is(err, sql.ErrNoRows) ‚Ä¶</code> </pre> <br>  Nesse caso, a fun√ß√£o sempre deve retornar <code>sql.ErrNoRows</code> se voc√™ n√£o desejar interromper os clientes, mesmo ao alternar para um pacote com um banco de dados diferente.  Em outras palavras, o empacotamento faz parte de um erro da sua API.  Se voc√™ n√£o deseja confirmar o suporte para esse erro no futuro como parte da API, n√£o o empacote. <br><br>  √â importante lembrar que, independentemente de voc√™ o levar ou n√£o, o erro permanecer√° inalterado.  <i>Uma pessoa</i> que entender√° ter√° as mesmas informa√ß√µes.  A tomada de decis√µes sobre o empacotamento depende da necessidade de informa√ß√µes adicionais para os <i>programas,</i> para que possam tomar decis√µes mais informadas;  ou se voc√™ deseja ocultar essas informa√ß√µes para manter o n√≠vel de abstra√ß√£o. <br><br><h4>  Configurando o teste de erros usando os m√©todos Is e As </h4><br>  A fun√ß√£o <code>errors.Is</code> verifica todos os erros da cadeia em rela√ß√£o ao valor alvo.  Por padr√£o, um erro corresponde a esse valor se eles forem equivalentes.  Al√©m disso, um erro na cadeia pode declarar sua conformidade com o valor de destino usando a implementa√ß√£o do <i>m√©todo</i> <code>Is</code> . <br><br>  Considere o erro causado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pelo pacote Upspin</a> , que compara o erro com o modelo e avalia apenas campos diferentes de zero: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Error <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Path <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> User <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *Error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Is</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { t, ok := target.(*Error) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (e.Path == t.Path || t.Path == <span class="hljs-string"><span class="hljs-string">""</span></span>) &amp;&amp; (e.User == t.User || t.User == <span class="hljs-string"><span class="hljs-string">""</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.Is(err, &amp;Error{User: <span class="hljs-string"><span class="hljs-string">"someuser"</span></span>}) { <span class="hljs-comment"><span class="hljs-comment">// err's User field is "someuser". }</span></span></code> </pre> <br>  A fun√ß√£o <code>errors.As</code> tamb√©m aconselha o m√©todo As, se houver. <br><br><h4>  APIs de erros e pacotes </h4><br>  Um pacote que retorna erros (e a maioria dos pacotes faz isso) deve descrever as propriedades desses erros nos quais um programador pode confiar.  Um pacote bem projetado tamb√©m evitar√° retornar erros com propriedades que n√£o podem ser consideradas. <br><br>  O mais simples √© dizer se a opera√ß√£o foi bem-sucedida, retornando, respectivamente, o valor nulo ou n√£o nulo.  Em muitos casos, nenhuma outra informa√ß√£o √© necess√°ria. <br><br>  Se voc√™ precisar que a fun√ß√£o retorne um estado de erro identific√°vel, por exemplo, "elemento n√£o encontrado", poder√° retornar um erro no qual o valor do sinal est√° compactado. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ErrNotFound = errors.New(<span class="hljs-string"><span class="hljs-string">"not found"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// FetchItem returns the named item. // // If no item with the name exists, FetchItem returns an error // wrapping ErrNotFound. func FetchItem(name string) (*Item, error) { if itemNotFound(name) { return nil, fmt.Errorf("%q: %w", name, ErrNotFound) } // ... }</span></span></code> </pre> <br>  Existem outros padr√µes para fornecer erros que o chamador pode examinar semanticamente.  Por exemplo, retorne diretamente um valor de controle, um tipo espec√≠fico ou um valor que possa ser analisado usando uma fun√ß√£o predicativa. <br><br>  De qualquer forma, n√£o divulgue os detalhes internos ao usu√°rio.  Conforme mencionado no cap√≠tulo ‚ÄúQuando vale a pena embalar?‚Äù, Se voc√™ retornar um erro de outro pacote, converta-o para n√£o revelar o erro original, a menos que pretenda se comprometer a retornar esse erro espec√≠fico no futuro. <br><br><pre> <code class="go hljs">f, err := os.Open(filename) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">// The *os.PathError returned by os.Open is an internal detail. // To avoid exposing it to the caller, repackage it as a new // error with the same text. We use the %v formatting verb, since // %w would permit the caller to unwrap the original *os.PathError. return fmt.Errorf("%v", err) }</span></span></code> </pre> <br>  Se uma fun√ß√£o retornar um erro com um valor ou tipo de sinal compactado, n√£o retorne diretamente o erro original. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ErrPermission = errors.New(<span class="hljs-string"><span class="hljs-string">"permission denied"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// DoSomething returns an error wrapping ErrPermission if the user // does not have permission to do something. func DoSomething() { if !userHasPermission() { // If we return ErrPermission directly, callers might come // to depend on the exact error value, writing code like this: // // if err := pkg.DoSomething(); err == pkg.ErrPermission { ‚Ä¶ } // // This will cause problems if we want to add additional // context to the error in the future. To avoid this, we // return an error wrapping the sentinel so that users must // always unwrap it: // // if err := pkg.DoSomething(); errors.Is(err, pkg.ErrPermission) { ... } return fmt.Errorf("%w", ErrPermission) } // ... }</span></span></code> </pre><br><h4>  Conclus√£o </h4><br>  Embora tenhamos discutido apenas tr√™s fun√ß√µes e um comando de formata√ß√£o, esperamos que eles ajudem a melhorar bastante o tratamento de erros nos programas Go.  Esperamos que o empacotamento com o objetivo de fornecer contexto adicional se torne uma pr√°tica normal, ajudando os programadores a tomar melhores decis√µes e encontrar bugs mais rapidamente. <br><br>  Como Russ Cox disse em seu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">discurso na GopherCon 2019</a> , no caminho para o Go 2, experimentamos, simplificamos e enviamos.  E agora, depois de enviar essas mudan√ßas, iniciamos novos experimentos. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt473658/">https://habr.com/ru/post/pt473658/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt473646/index.html">Hackathon em uma pequena empresa: como organizar sem descarregar um trem de recursos</a></li>
<li><a href="../pt473648/index.html">O cavalo est√° morto - cry: transi√ß√£o de tslint para eslint</a></li>
<li><a href="../pt473652/index.html">Criando uma API REST com Node.js e um Banco de Dados Oracle. Parte 5</a></li>
<li><a href="../pt473654/index.html">PHP Composer: Corrija depend√™ncias sem dor</a></li>
<li><a href="../pt473656/index.html">Experi√™ncia com o Hugo Static Site Generator</a></li>
<li><a href="../pt473660/index.html">Arcade Reverse Engineering: Record Michael Jordan no NBA Jam</a></li>
<li><a href="../pt473664/index.html">Experi√™ncia de aprendizado em primeira m√£o. Yandex.Practicum - Analista de dados</a></li>
<li><a href="../pt473666/index.html">Como escritor de fic√ß√£o cient√≠fica, Arthur Clark quase fechou a revista Tech - Youth</a></li>
<li><a href="../pt473668/index.html">Por que Bitrix - Bitrix</a></li>
<li><a href="../pt473670/index.html">Stoloto: como introduzir um celular na loteria</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>