<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌒 🚪 👩🏼‍🚀 Bagaimana dan mengapa kami menulis ECS kami 💪🏿 🎡 🎄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel sebelumnya, saya menjelaskan teknologi dan pendekatan yang kami gunakan saat mengembangkan penembak cepat seluler baru. Karena itu adala...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana dan mengapa kami menulis ECS kami</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/413729/">  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya,</a> saya menjelaskan teknologi dan pendekatan yang kami gunakan saat mengembangkan penembak cepat seluler baru.  Karena  itu adalah ulasan dan bahkan artikel yang dangkal - hari ini saya akan menggali lebih dalam dan menjelaskan secara rinci mengapa kami memutuskan untuk menulis kerangka kerja ECS kami sendiri dan tidak menggunakan yang sudah ada.  Akan ada contoh kode dan bonus kecil di akhir. <br><img src="https://habrastorage.org/webt/qn/lg/zw/qnlgzwthwpjkkzzeeilv257iiga.png"><br><a name="habracut"></a><br><h3>  Apa itu ECS sebagai contoh </h3><br>  Saya sudah menjelaskan secara singkat apa itu Entity Component System, dan ada artikel tentang Habré tentang ECS ​​(pada dasarnya, terjemahan artikel - lihat ulasan saya tentang yang paling menarik di bagian akhir artikel, sebagai bonus).  Dan hari ini saya akan memberi tahu Anda bagaimana kami menggunakan ECS - menggunakan contoh kode kami. <br><br>  Diagram di atas menjelaskan esensi dari <i>Player</i> , komponen-komponennya dan data mereka, dan sistem yang bekerja dengan pemain dan komponen-komponennya.  Objek utama dalam diagram adalah pemain: <br><br><ul><li>  dapat bergerak di luar angkasa - Komponen <i>Transform</i> and <i>Movement</i> , <i>MoveSystem</i> ; </li><li>  memiliki beberapa kesehatan dan dapat mati - komponen <i>Kesehatan</i> , <i>Kerusakan</i> , <i>KerusakanSistem</i> ; </li><li>  setelah kematian muncul di titik respawn - komponen <i>Transform</i> untuk posisi itu, <i>Sistem RespawnS</i> ; </li><li>  mungkin kebal - komponen <i>Invincible</i> . </li></ul><br>  Kami menggambarkan ini dengan kode.  Pertama, mari kita dapatkan antarmuka untuk komponen dan sistem.  Komponen dapat memiliki metode bantu umum, sistem hanya memiliki satu metode <i>Jalankan</i> , yang menerima keadaan dunia pada input untuk diproses: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IComponent</span></span> { <span class="hljs-comment"><span class="hljs-comment">// &lt; &gt; } public interface ISystem { void Execute(GameState gs); }</span></span></code> </pre> <br>  Untuk komponen, kami membuat kelas rintisan yang digunakan oleh pembuat kode kami untuk mengubahnya menjadi kode komponen yang benar-benar digunakan.  Mari kita cari beberapa blanko untuk <i>Health</i> , <i>Damage</i> , dan <i>Invincible</i> (untuk komponen lainnya akan serupa). <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Component</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Health</span></span> { [Max(<span class="hljs-number"><span class="hljs-number">1000</span></span>)] <span class="hljs-comment"><span class="hljs-comment">//  -  1000 public int Hp; // -   public Health(int hp) {} } [Component] public class Damage { [DontSend] //      ,      public uint Amount; // -  public Entity Victim; //    public Entity Source; //    public Damage(uint amount, Entity victim, Entity source) {} } [Component] public class Invincible //   ,  ,    { }</span></span></code> </pre> <br>  Komponen menentukan keadaan dunia, oleh karena itu mereka hanya berisi data, tanpa metode.  Pada saat yang sama, tidak ada data dalam <i>Invincible</i> , digunakan dalam logika sebagai tanda kebal - jika esensi pemain memiliki komponen ini, maka pemain sekarang kebal. <br><br>  Atribut <i>Komponen</i> digunakan oleh generator untuk menemukan kelas kosong untuk komponen.  <i>Atribut</i> <i>Max</i> dan <i>DontSend</i> diperlukan sebagai petunjuk saat membuat cerita bersambung dan mengurangi ukuran keadaan dunia yang ditransmisikan melalui jaringan atau disimpan ke disk.  Dalam hal ini, server tidak akan membuat serial bidang <i>Jumlah</i> dan mengirimkannya melalui jaringan (karena klien tidak menggunakan parameter ini, diperlukan hanya di server).  Dan bidang <i>Hp</i> dapat dikemas dengan baik dalam beberapa bit, mengingat nilai kesehatan maksimum. <br><br>  Kami juga memiliki kelas <i>prefab Entitas</i> , tempat kami menambahkan informasi tentang semua komponen yang mungkin dari entitas apa pun, dan generator sudah akan membuat kelas nyata darinya: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Entity</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Health Health; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Damage Damage; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Invincible Invincible; <span class="hljs-comment"><span class="hljs-comment">// ... &lt; &gt; }</span></span></code> </pre> <br>  Setelah itu, generator kami akan membuat kode kelas komponen <i>Kesehatan</i> , <i>Kerusakan,</i> dan <i>Tak Terkalahkan</i> , yang sudah akan digunakan dalam logika permainan: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Health</span></span> : <span class="hljs-title"><span class="hljs-title">IComponent</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Hp; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reset</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Hp = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); } <span class="hljs-comment"><span class="hljs-comment">// ... &lt;  &gt; } public sealed class Damage : IComponent { public int Amount; public Entity Victim; public Entity Source; public void Reset() { Amount = default(int); Victim = default(Entity); Source = default(Entity); } // ... &lt;  &gt; } public sealed class Invincible : IComponent { }</span></span></code> </pre> <br>  Seperti yang Anda lihat, data tetap ada di kelas dan metode ditambahkan, misalnya, <i>Atur Ulang</i> .  Diperlukan untuk mengoptimalkan dan menggunakan kembali komponen dalam kumpulan.  Metode tambahan lainnya tidak mengandung logika bisnis - saya tidak akan memberikannya untuk singkatnya. <br><br>  Kelas juga akan dihasilkan untuk keadaan dunia, yang berisi daftar semua komponen dan entitas: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameState</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  public Table&lt;Movement&gt; Movements; public Table&lt;Health&gt; Healths; public Table&lt;Damage&gt; Damages; public Table&lt;Transform&gt; Transforms; public Table&lt;Invincible&gt; Invincibles; //   public Entity CreateEntity() { /* &lt;&gt; */ } public void Copy(GameState gs2) { /* &lt;&gt; */ } public Entity this[uint id] { /* &lt;&gt; */ } // ... &lt;   &gt; }</span></span></code> </pre> <br>  Dan akhirnya, kode yang dihasilkan untuk <i>Entity</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Entity</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> Id; <span class="hljs-comment"><span class="hljs-comment">//   public GameState GameState; //     //     : public Health Health { get { return GameState.Healths[Id]; } } public Damage Damage { get { return GameState.Damages[Id]; } } public Invincible Invincible { get { return GameState.Invincibles[Id]; } } // …     public Damage AddDamage() { return GameState.Damages.Insert(Id); } public Damage AddDamage(int total, Entity victim, Entity source) { var c = GameState.Damages.Insert(Id); c.Amount = total; c.Victim = victim; c.Source = source; return c; } public void DelDamage() { GameState.Damages.Delete(Id); } // … &lt;     &gt; }</span></span></code> </pre> <br>  Kelas <i>Entity</i> pada dasarnya hanya pengenal komponen.  Referensi ke objek dunia <i>GameState</i> hanya digunakan dalam metode tambahan untuk kenyamanan menulis kode logika bisnis.  Mengetahui pengenal suatu komponen, kita dapat menggunakannya untuk membuat serial hubungan di antara entitas, mengimplementasikan tautan dalam komponen ke entitas lain.  Sebagai contoh, komponen <i>Kerusakan</i> berisi referensi ke entitas <i>Korban</i> untuk menentukan siapa yang rusak. <br><br>  Ini mengakhiri kode yang dihasilkan.  Secara umum, kita membutuhkan generator agar tidak menulis metode bantu setiap saat.  Kami hanya menggambarkan komponen sebagai data, kemudian generator melakukan semua pekerjaan.  Contoh metode pembantu: <br><br><ul><li>  membuat / menghapus entitas; </li><li>  tambah / hapus / salin komponen, akses jika ada; </li><li>  bandingkan dua negara di dunia; </li><li>  cerita bersambung dari keadaan dunia; </li><li>  kompresi delta; </li><li>  kode halaman web atau jendela Persatuan untuk menampilkan keadaan dunia, entitas, komponen (lihat detail di bawah); </li><li>  dan lainnya </li></ul><br>  Mari kita beralih ke kode sistem.  Mereka mendefinisikan logika bisnis.  Misalnya, mari kita menulis kode sistem yang menghitung kerusakan pemain: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DamageSystem</span></span> : <span class="hljs-title"><span class="hljs-title">ISystem</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ISystem.Execute(GameState gs) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> damage <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gs.Damages) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> invincible = damage.Victim.Invincible; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (invincible != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> health = damage.Victim.Health; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (health == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; health.Hp -= damage.Amount; } } }</code> </pre> <br>  Sistem melewati semua komponen <i>Kerusakan</i> di dunia dan mencari tahu apakah ada komponen <i>Invincible</i> pada pemain yang berpotensi rusak ( <i>Korban</i> ).  Jika dia, pemain kebal, kerusakan tidak bertambah.  Selanjutnya, kami mendapatkan komponen <i>Kesehatan</i> korban dan mengurangi kesehatan pemain dengan jumlah kerusakan. <br><br>  Pertimbangkan fitur utama dari sistem: <br><br><ol><li>  Suatu sistem biasanya adalah kelas tanpa kewarganegaraan, tidak mengandung data internal apa pun, tidak mencoba menyimpannya di suatu tempat, kecuali data tentang dunia yang ditransmisikan dari luar. </li><li>  Sistem biasanya melalui semua komponen dari tipe tertentu dan bekerja dengannya.  Mereka biasanya dipanggil oleh tipe komponen ( <i>Damage</i> → <i>DamageSystem</i> ) atau oleh tindakan yang mereka lakukan ( <i>RespawnSystem</i> ). </li><li>  Sistem mengimplementasikan fungsionalitas minimal.  Sebagai contoh, jika kita melangkah lebih jauh, setelah <i>DamageSystem dijalankan,</i> <i>RemoveDamageSystem</i> lain akan menghapus semua komponen <i>Kerusakan</i> .  Pada centang selanjutnya, <i>ApplyDamageSystem</i> lain yang didasarkan pada pemotretan pemain dapat kembali menggantung komponen <i>Kerusakan</i> dengan kerusakan baru.  Dan kemudian <i>PlayerDeathSystem</i> akan memeriksa kesehatan pemain ( <i>Health.Hp</i> ) dan, jika kurang dari atau sama dengan 0, akan menghancurkan semua komponen pemain kecuali <i>Transform</i> dan tambahkan komponen Bendera <i>Mati</i> . </li></ol><br>  Total, kami mendapatkan kelas-kelas berikut dan hubungan di antara mereka: <br><img src="https://habrastorage.org/webt/g7/59/mq/g759mq06qfqqjymhz8ympcwejro.png"><br><br><h3>  Beberapa fakta tentang ECS </h3><br>  ECS memiliki pro dan kontra sebagai pendekatan untuk pengembangan dan cara mewakili dunia permainan, sehingga semua orang memutuskan sendiri apakah akan menggunakannya atau tidak.  Mari kita mulai dengan pro: <br><br><ul><li>  <b>Komposisi versus pewarisan berganda.</b>  Dalam kasus pewarisan berganda, banyak fungsi yang tidak perlu dapat diwarisi.  Dalam kasus ECS, fungsionalitas muncul / menghilang ketika komponen ditambahkan / dihapus. </li><li>  <b>Pemisahan logika dan data.</b>  Kemampuan untuk mengubah logika (mengubah sistem, menghapus / menambah komponen) tanpa merusak data.  Yaitu  Anda dapat menonaktifkan grup sistem yang bertanggung jawab atas fungsi tertentu kapan saja, semua yang lain akan terus berfungsi dan ini tidak akan memengaruhi data. </li><li>  <b>Siklus permainan disederhanakan.</b>  Satu <i>Pembaruan</i> muncul, dan seluruh siklus dibagi ke dalam sistem.  Data diproses oleh "aliran" dalam sistem, terlepas dari mesinnya (tidak ada jutaan panggilan <i>Perbarui</i> , seperti dalam Unity). </li><li>  <b>Entitas tidak tahu kelas mana yang mempengaruhinya</b> (dan seharusnya tidak tahu). </li><li>  <b>Penggunaan memori yang efisien</b> .  Itu tergantung pada implementasi ECS.  Anda bisa menggunakan kembali objek dan komponen entitas yang dibuat menggunakan kumpulan;  Anda dapat menggunakan tipe nilai untuk data dan menyimpannya dalam memori berdampingan ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lokalitas data</a> ). </li><li>  <b>Lebih mudah untuk menguji</b> ketika data dipisahkan dari logika.  Terutama ketika Anda menganggap bahwa logika adalah sistem kecil dengan beberapa baris kode. </li><li>  <b>Lihat dan edit keadaan dunia secara real time</b> .  Karena  keadaan dunia hanyalah data, kami menulis alat yang menampilkan di halaman web seluruh negara di pertandingan di server (serta adegan pertandingan dalam 3D).  Komponen apa pun dari entitas apa pun dapat dilihat, diubah, dihapus.  Hal yang sama dapat dilakukan di editor Unity untuk klien. </li></ul><br><img src="https://habrastorage.org/webt/zd/rz/a-/zdrza-80yltaqp8g3dqwd59zgqw.jpeg"><br><br>  Dan sekarang kontra: <br><br><ul><li>  <b>Anda perlu belajar berpikir, mendesain, dan menulis kode secara berbeda</b> .  Pikirkan dalam hal entitas, komponen, dan sistem.  Banyak pola desain dalam ECS diimplementasikan dengan cara yang sangat berbeda (lihat contoh implementasi pola <i>Negara</i> di salah satu artikel ulasan di akhir). </li><li>  <b>Lebih banyak kode</b> .  Luar biasa.  Di satu sisi, karena fakta bahwa kita memecah logika menjadi sistem kecil, alih-alih menggambarkan semua fungsi dalam satu kelas, ada lebih banyak kelas, tetapi tidak ada lebih banyak kode. </li><li>  <b>Urutan sistem disebut memengaruhi operasi seluruh game</b> .  Biasanya, sistem saling tergantung satu sama lain, urutan eksekusi diatur oleh daftar dan dieksekusi dalam urutan ini.  Sebagai contoh, <i>DamageSystem</i> pertama menganggap kerusakan, kemudian <i>RemoveDamageSystem</i> menghapus komponen <i>Kerusakan</i> .  Jika Anda secara tidak sengaja mengubah urutannya, maka semuanya akan bekerja secara berbeda.  Secara umum, ini juga berlaku untuk kasus OOP biasa, jika Anda mengubah urutan pemanggilan metode, tetapi dalam ECS lebih mudah untuk membuat kesalahan.  Misalnya, jika bagian dari logika berjalan pada klien untuk prediksi, maka urutannya harus sama dengan di server. </li><li>  <b>Kita perlu menghubungkan data dan peristiwa logika dengan tampilan</b> .  Dalam kasus Unity, kami memiliki MVP: <br><br>  - Model - <i>GameState</i> dari ECS; <br>  - Lihat - bersama kami, ini adalah kelas <i>MonoBehavior</i> Unity ( <i>Renderer</i> , <i>Teks</i> , dll.) Dan standar secara eksklusif; <br>  - Presenter menggunakan <i>GameState</i> untuk menentukan peristiwa penampilan / hilangnya entitas, komponen, dll., Menciptakan objek Persatuan dari prefab dan mengubahnya sesuai dengan perubahan di negara dunia. </li></ul><br>  <i>Tahukah Anda bahwa:</i> <br><br><ul><li>  <b>ECS bukan hanya tentang lokalitas data</b> .  Bagi saya, ini lebih merupakan paradigma pemrograman, sebuah pola, cara lain untuk merancang dunia game - sebut saja apa pun yang Anda suka.  Lokalitas data hanyalah sebuah optimasi. </li><li>  <b>Unity tidak memiliki ECS!</b>  Seringkali Anda bertanya kepada kandidat dalam wawancara tim - apa yang Anda ketahui tentang ECS?  Jika Anda belum pernah mendengar, Anda memberi tahu mereka, dan mereka menjawab: "Ah, jadi seperti di Unity, maka saya tahu!".  Tapi tidak, tidak seperti di mesin Unity.  Di sana, data dan logika digabungkan dalam komponen <i>MonoBehaviour</i> , dan <i>GameObject</i> (jika dibandingkan dengan entitas di ECS) memiliki data tambahan - nama, tempat dalam hierarki, dll. Pengembang persatuan saat ini sedang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengerjakan</a> implementasi ECS yang normal di mesin, dan sejauh ini tampaknya akan baik.  Mereka merekrut spesialis di bidang ini - saya harap hasilnya keren. </li></ul><br><h3>  Kriteria seleksi kami untuk kerangka ECS </h3><br>  Ketika kami memutuskan untuk membuat game di ECS, kami mulai mencari solusi yang siap pakai dan menuliskan persyaratan untuknya berdasarkan pengalaman salah satu pengembang.  Dan mereka melukis bagaimana solusi yang ada memenuhi persyaratan kami.  Itu setahun yang lalu, saat ini, sesuatu bisa saja berubah.  Sebagai solusi, kami mempertimbangkan: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Entitas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artemis C #</a> </li><li>  <a href="">Ash.net</a> </li><li>  ECS adalah solusi kami sendiri pada saat kami menyusunnya.  Yaitu  asumsi dan keinginan kita, apa yang bisa kita lakukan sendiri. </li></ul><br>  Kami menyusun tabel untuk perbandingan, di mana saya juga memasukkan solusi kami saat ini (menyebutnya sebagai <i>ECS (sekarang)</i> ): <br><br><img src="https://habrastorage.org/webt/0p/eh/hk/0pehhk27fihkyp-qmuhlpu0m5m4.png"><br>  <i>Warna merah - solusinya tidak mendukung persyaratan kami, oranye - sebagian mendukung, hijau - sepenuhnya mendukung.</i> <br><br>  Bagi kami, analogi operasi untuk mengakses komponen dan mencari entitas dalam ECS adalah operasi dalam database sql.  Oleh karena itu, kami menggunakan konsep seperti tabel (tabel), gabung (gabung operasi), indeks (indeks), dll. <br><br>  Kami akan menjelaskan persyaratan kami dan sejauh mana perpustakaan dan kerangka kerja pihak ketiga sesuai dengan mereka: <br><br><ul><li>  <b>set data terpisah (histori, saat ini, visual, statis)</b> - kemampuan untuk secara terpisah memperoleh dan menyimpan status dunia (misalnya, status saat ini untuk diproses, untuk rendering, riwayat negara, dll.).  <i>Semua keputusan yang dipertimbangkan mendukung persyaratan ini</i> . </li><li>  <b>ID entitas sebagai bilangan bulat</b> - dukungan untuk mewakili entitas dengan nomor pengenalnya.  Hal ini diperlukan untuk transmisi melalui jaringan dan kemampuan untuk menghubungkan entitas dalam sejarah negara.  <i>Tidak ada solusi yang dianggap didukung.</i>  <i>Misalnya, dalam Entitas, entitas diwakili oleh objek penuh (seperti GameObject di Unity).</i> </li><li>  <b>bergabung dengan ID O (N + M)</b> - dukungan untuk pengambilan sampel yang relatif cepat dari dua jenis komponen.  Misalnya, ketika Anda perlu mendapatkan semua entitas dengan komponen dari tipe Kerusakan (misalnya, potongan N mereka) dan Kesehatan (potongan M) untuk menghitung dan menyebabkan kerusakan.  <i>Ada dukungan penuh di Artemis;</i>  <i>di Entitas dan Ash.NET lebih cepat dari O (N²), tetapi lebih lambat dari O (N + M).</i>  <i>Saya tidak ingat penilaiannya sekarang.</i> </li><li>  <b>bergabung dengan referensi ID O (N + M)</b> - sama seperti di atas hanya ketika komponen dari satu entitas memiliki tautan ke yang lain, dan yang terakhir perlu mendapatkan komponen lain (dalam contoh kami, komponen <i>Kerusakan</i> pada entitas pembantu mengacu pada entitas pemain. <i>Korban</i> dan dari sana Anda perlu mendapatkan komponen <i>Kesehatan</i> ).  <i>Tidak didukung oleh solusi yang dipertimbangkan.</i> </li><li>  <b>tidak ada alokasi kueri</b> - tidak ada alokasi memori tambahan saat menanyakan komponen dan entitas dari negara dunia.  Dalam Entitas, itu dalam kasus-kasus tertentu, tetapi tidak berarti bagi kami. </li><li>  <b>tabel pool</b> - penyimpanan data dunia dalam pool, kemampuan untuk menggunakan kembali memori, alokasi hanya ketika pool kosong.  <i>Ada "beberapa" dukungan di Entitas dan Artemis, tidak ada sama sekali di Ash.NET.</i> </li><li>  <b>bandingkan dengan ID (tambah, del)</b> - dukungan bawaan untuk peristiwa penciptaan / penghancuran entitas dan komponen oleh ID.  Tingkat tampilan (Tampilan) diperlukan untuk menampilkan / menyembunyikan objek, memutar animasi, efek.  <i>Tidak didukung oleh solusi yang dipertimbangkan.</i> </li><li>  <b>Δ serialisasi (quantisation, skip)</b> - kompresi delta bawaan untuk membuat serialisasi keadaan dunia (misalnya, untuk mengurangi ukuran data yang dikirim melalui jaringan).  <i>Out of the Box tidak didukung dalam solusi apa pun.</i> </li><li>  <b>Interpolasi</b> adalah mekanisme interpolasi built-in antara negara-negara dunia.  <i>Tidak ada solusi yang didukung.</i> </li><li>  <b>reuse type type</b> - kemampuan untuk menggunakan tipe komponen yang pernah ditulis dalam berbagai jenis entitas.  <i>Hanya mendukung Entitas</i> . </li><li>  <b>urutan sistem eksplisit</b> - kemampuan untuk mengatur sistem pesanan panggilan Anda sendiri.  <i>Semua keputusan didukung.</i> </li><li>  <b>editor (unity / server)</b> - dukungan untuk melihat dan mengedit entitas secara real time, baik untuk klien maupun untuk server.  <i>Entitas hanya mendukung kemampuan untuk melihat dan mengedit entitas dan komponen di editor Unity.</i> </li><li>  <b>fast copy / replace</b> - kemampuan untuk dengan murah menyalin / mengganti data.  <i>Tidak ada solusi yang didukung.</i> </li><li>  <b>komponen sebagai tipe nilai (struct)</b> - komponen sebagai tipe nilai.  Pada prinsipnya, saya ingin mencapai kinerja yang baik berdasarkan ini.  <i>Tidak ada satu pun sistem yang didukung, kelas komponen ada di mana-mana.</i> </li></ul><br>  Persyaratan opsional ( <i>tidak ada solusi pada saat itu yang mendukungnya</i> ): <br><br><ul><li>  <b>indeks</b> - mengindeks data seperti dalam database. </li><li>  <b>kunci komposit</b> - <b>kunci</b> kompleks untuk akses cepat ke data (seperti dalam database). </li><li>  <b>pemeriksaan integritas</b> - kemampuan untuk memverifikasi integritas data dalam keadaan dunia.  Berguna untuk debugging. </li><li>  <b>kompresi konten-sadar</b> adalah <b>kompresi</b> data terbaik berdasarkan pengetahuan tentang sifat data.  Misalnya, jika kita tahu ukuran maksimum peta atau jumlah objek maksimum di dunia. </li><li>  <b>jenis / batas sistem</b> - pembatasan jumlah jenis komponen atau sistem.  <i>Di Artemis pada waktu itu tidak mungkin membuat lebih dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">32 atau 64 jenis komponen dan sistem</a></i> . </li></ul><br>  Seperti dapat dilihat dari tabel, kita sendiri ingin menerapkan semua persyaratan, kecuali yang opsional.  Bahkan, saat ini kami <i>belum</i> melakukan: <br><br><ul><li>  <i>bergabung dengan ID O (N + M)</i> dan <i>bergabung dengan referensi ID O (N + M)</i> - pemilihan untuk dua komponen yang berbeda masih menempati O (N²) (pada kenyataannya, bersarang <i>untuk</i> loop).  Di sisi lain, tidak ada begitu banyak entitas dan komponen untuk pertandingan. </li><li>  <i>bandingkan dengan ID (add, del)</i> - tidak diperlukan di level framework.  Kami menerapkan ini pada level yang lebih tinggi di MVP. </li><li>  <i>salin / ganti cepat</i> dan <i>komponen sebagai tipe nilai (struct)</i> - pada titik tertentu kami menyadari bahwa bekerja dengan struktur tidak akan senyaman dengan kelas, dan menetap di kelas - kami lebih memilih kenyamanan pengembangan daripada kinerja yang lebih baik.  Omong-omong, para pengembang Entitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">melakukan hal yang sama pada akhirnya</a> . </li></ul><br>  Pada saat yang sama, kami menyadari salah satu persyaratan yang awalnya opsional menurut kami: <br><br><ul><li>  <i>kompresi konten-sadar</i> - karena itu kami dapat secara signifikan (puluhan kali) mengurangi ukuran paket yang dikirimkan melalui jaringan.  Untuk jaringan data seluler, sangat penting untuk menyesuaikan ukuran paket di MTU sehingga tidak "dipecah" menjadi bagian-bagian kecil yang mungkin hilang, masuk dalam urutan yang berbeda, dan kemudian perlu dirakit di bagian-bagian.  Misalnya, di Photon, jika ukuran data tidak cocok di pustaka MTU, itu membagi data menjadi paket dan mengirimkannya sebagai dapat diandalkan (dengan pengiriman yang dijamin), bahkan jika Anda mengirimnya sebagai "tidak dapat diandalkan" dari atas.  Diuji dengan rasa sakit tangan pertama. </li></ul><br><h3>  Fitur pengembangan kami di ECS </h3><br><ul><li>  <b>Kami di ECS menulis logika bisnis secara eksklusif</b> .  Tidak ada pekerjaan dengan sumber daya, pandangan, dll.  Karena kode logika ECS secara bersamaan berjalan pada klien di Unity dan di server, kode tersebut harus sebebas mungkin dari tingkat dan modul lain. </li><li>  <b>Kami mencoba meminimalkan komponen dan sistem</b> .  Biasanya, untuk setiap tugas baru, kami memulai komponen dan sistem baru.  Tetapi kadang-kadang terjadi bahwa kita memodifikasi yang lama, menambahkan data baru ke komponen, dan "mengembang" sistem. </li><li>  <b>Dalam implementasi ECS kami, Anda tidak dapat menambahkan beberapa komponen dari jenis yang sama ke satu entitas</b> .  Karena itu, jika seorang pemain dipukul beberapa kali dalam satu centang (misalnya, beberapa lawan), maka kami biasanya membuat entitas baru untuk setiap kerusakan dan menambahkan komponen <i>Kerusakan</i> padanya. </li><li>  <b>Terkadang, presentasi tidak cukup dengan informasi yang ada di <i>GameState</i></b> .  Maka Anda harus menambahkan komponen khusus atau data tambahan yang tidak terlibat dalam logika, tetapi yang dibutuhkan tampilan.  Misalnya, bidikan adalah instan di server, satu tick hidup, dan secara visual, itu lebih lama pada klien.  Oleh karena itu, untuk klien, shot ditambahkan ke parameter "shot lifetime". </li><li>  <b>Kami mengimplementasikan acara / permintaan dengan membuat komponen khusus</b> .  Misalnya, jika seorang pemain mati, kami menggantungnya komponen tanpa data <i>Mati</i> , yang merupakan acara untuk sistem lain dan tingkat tampilan bahwa pemain telah meninggal.  Atau jika kita perlu menghidupkan kembali pemain di titik lagi, kami membuat entitas terpisah dengan komponen <i>Respawn</i> dengan informasi tambahan tentang siapa yang akan dihidupkan kembali.  Sistem <i>RespawnS</i> terpisah pada awal siklus permainan melewati komponen-komponen ini dan sudah menciptakan esensi pemain.  Yaitu  sebenarnya, entitas pertama adalah permintaan untuk membuat entitas kedua. </li><li>  <b>Kami memiliki komponen / entitas "tunggal" khusus</b> .  Misalnya, kami memiliki entitas dengan ID = 1, di mana komponen khusus digantung - pengaturan permainan. </li></ul><br><h3>  Bonus </h3><br>    —       ECS —    .     ,        ,   ,   : <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Unity, ECS  --</a> —       ECS   .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mopsicus</a>  ,   ECS,  .        :  Unity  ECS   ,   .    .   «» ECS    Unity.    ECS-,      : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LeoECS</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BrokenBricksECS</a> , <a href="">Svelto.ECS</a> . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Unity3D ECS  Job System</a> —   ,      ECS  Unity.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fstleo</a>   ,   Unity ECS,     ,         -      ,    JobSystem. </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  Entity System Framework      ?</a> —    Ash-  ActionScript.  ,   ,        OOP-  ECS-. </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">    Ash Entity System </a> —   ,    FSM  State  ECS —      ,       . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  Entity-Component-System —    </a> —     ECS  C++. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id413729/">https://habr.com/ru/post/id413729/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id413717/index.html">GraphQL untuk Platform InterSystems</a></li>
<li><a href="../id413719/index.html">C ++ 20 dalam perjalanan! Bertemu di Rapperswil Yona</a></li>
<li><a href="../id413721/index.html">Pemeriksaan Waktu: Timejacking vs Bitcoin</a></li>
<li><a href="../id413723/index.html">Saga layanan elektronik dan lokasi mereka. Bagian 2. Kabinet elektronik</a></li>
<li><a href="../id413725/index.html">Bekerja dengan array dalam bash</a></li>
<li><a href="../id413731/index.html">Penelitian Pasar Kerja BA / SA</a></li>
<li><a href="../id413733/index.html">Mikrosh, Krista, Apogee, Lviv - komputer take-away Soviet pertama</a></li>
<li><a href="../id413739/index.html">Bagaimana kami memindai seluruh Internet dan apa yang kami pelajari</a></li>
<li><a href="../id413741/index.html">Apa itu dan bagaimana: tayangan tim WWDC Redmadrobot</a></li>
<li><a href="../id413743/index.html">Luncurkan LAMP dan ratusan aplikasi web lainnya dalam beberapa klik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>