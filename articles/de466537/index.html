<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚óΩÔ∏è üè™ üñï Verwendung von JavaScript-Modulen in der Produktion: aktueller Stand der Dinge. Teil 1 üö£üèΩ üë∂üèª ü§≤üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor zwei Jahren schrieb ich √ºber eine Technik , die heute allgemein als Modul- / Nomodenmuster bezeichnet wird. Mit seiner Anwendung k√∂nnen Sie JavaSc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verwendung von JavaScript-Modulen in der Produktion: aktueller Stand der Dinge. Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/466537/"> Vor zwei Jahren schrieb ich √ºber eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Technik</a> , die heute allgemein als Modul- / Nomodenmuster bezeichnet wird.  Mit seiner Anwendung k√∂nnen Sie JavaScript-Code mit den Funktionen von ES2015 + schreiben und dann mithilfe von Bundlern und Transpilern zwei Versionen der Codebasis erstellen.  Eine davon enth√§lt moderne Syntax (sie wird mit einer Struktur wie <code>&lt;script type="module"&gt;</code> geladen, die zweite mit ES5-Syntax (sie wird mit <code>&lt;script nomodule&gt;</code> geladen). Das Modul / Nomodule-Muster erm√∂glicht das Senden an Browser, die Module unterst√ºtzen. Viel weniger Code als Browser, die diese Funktion nicht unterst√ºtzen. Dieses Muster wird jetzt von den meisten Webframeworks und Befehlszeilentools unterst√ºtzt. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/sd/_p/je/sd_pjea-digdrv7bbr_b3n4wdtq.jpeg"></a> <br><br>  Bisher habe ich empfohlen, Code in Paketen zu sammeln, obwohl ich die M√∂glichkeit hatte, modernen JavaScript-Code an die Produktion zu senden, und obwohl die meisten Browser Module unterst√ºtzten. <br><a name="habracut"></a><br>  Warum?  Vor allem, weil ich das Gef√ºhl hatte, dass das Laden von Modulen in den Browser langsam war.  Obwohl neuere Protokolle wie HTTP / 2 theoretisch das effiziente Laden mehrerer Dateien unterst√ºtzten, kamen alle damaligen Leistungsstudien zu dem Schluss, dass die Verwendung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bundlern</a> immer noch effizienter ist als die Verwendung von Modulen. <br><br>  Es muss jedoch zugegeben werden, dass diese Studien unvollst√§ndig waren.  Testf√§lle mit den darin untersuchten Modulen bestanden aus nicht optimierten und nicht minimierten Quellcodedateien, die in der Produktion bereitgestellt wurden.  Es gab keine Vergleiche des optimierten Bundles mit Modulen mit dem optimierten klassischen Skript. <br><br>  Um ehrlich zu sein, gab es zu diesem Zeitpunkt jedoch keine optimale M√∂glichkeit, die Module bereitzustellen.  Dank einiger moderner Verbesserungen der Bundler-Technologien ist es jetzt m√∂glich, Produktionscode in Form von ES2015-Modulen sowohl mit statischen als auch mit dynamischen Importbefehlen bereitzustellen und gleichzeitig eine h√∂here Leistung zu erzielen, als dies mit den verf√ºgbaren Optionen m√∂glich ist Module werden nicht verwendet. <br><br>  Es ist zu beachten, dass auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Website,</a> auf der das Originalmaterial ver√∂ffentlicht wird, dessen erster Teil der √úbersetzung wir heute ver√∂ffentlichen, die Module seit mehreren Monaten in der Produktion verwendet werden. <br><br><h2>  <font color="#3AC1EF">Missverst√§ndnisse √ºber Module</font> </h2><br>  Viele Leute, mit denen ich gesprochen habe, lehnen Module vollst√§ndig ab und betrachten sie nicht einmal als eine der Optionen f√ºr gro√ütechnische Produktionsanwendungen.  Viele von ihnen zitieren genau die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Studie</a> , die ich bereits erw√§hnt habe.  Das hei√üt, der Teil davon, der besagt, dass die Module nicht in der Produktion verwendet werden sollten, es sei denn, es handelt sich um ‚Äûkleine Webanwendungen, die weniger als 100 Module enthalten, die sich in einem relativ‚Äû kleinen ‚ÄúAbh√§ngigkeitsbaum unterscheiden (d. H. - eine, deren Tiefe 5 Stufen nicht √ºberschreitet). ‚Äú <br><br>  Wenn Sie jemals in das Verzeichnis <code>node_modules</code> eines Ihrer Projekte geschaut haben, wissen Sie wahrscheinlich, dass selbst eine kleine Anwendung problemlos mehr als 100 Abh√§ngigkeitsmodule haben kann.  Ich m√∂chte Ihnen einen Blick darauf werfen, wie viele Module in einigen der beliebtesten npm-Pakete verf√ºgbar sind. <br><div class="scrollable-table"><table><tbody><tr><td>  Paket <br></td><td>  Anzahl der Module <br></td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">date-fns</a> <br></td><td>  729 <br></td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lodash-es</a> <br></td><td>  643 <br></td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">rxjs</a> <br></td><td>  226 <br></td></tr></tbody></table></div><br>  Hier wurzelt das Hauptmissverst√§ndnis in Bezug auf Module.  Programmierer glauben, dass sie bei der Verwendung von Modulen in der Produktion nur zwei M√∂glichkeiten haben.  Die erste besteht darin, den gesamten Quellcode in seiner vorhandenen Form (einschlie√ülich des Verzeichnisses <code>node_modules</code> ) <code>node_modules</code> .  Die zweite besteht darin, √ºberhaupt keine Module zu verwenden. <br><br>  Wenn Sie sich jedoch die Empfehlungen aus der oben genannten Studie genau ansehen, werden Sie feststellen, dass das Laden von Modulen langsamer ist als das Laden normaler Skripte.  Es hei√üt nicht, dass Module √ºberhaupt nicht verwendet werden sollten.  Es geht nur um die Tatsache, dass Chrome, wenn jemand Hunderte nicht infizierter Moduldateien in der Produktion bereitstellt, diese nicht so schnell laden kann wie ein einzelnes minimiertes Bundle.  Infolgedessen empfiehlt die Studie, weiterhin Bundler, Compiler und Minifier zu verwenden. <br><br>  Aber wei√üt du was?  Tatsache ist, dass Sie all dies nutzen und Module in der Produktion verwenden k√∂nnen. <br><br>  In der Tat sind Module ein Format, in das wir konvertieren sollten, da Browser bereits wissen, wie Module geladen werden (und Browser, die dies nicht k√∂nnen, k√∂nnen eine Ersatzversion des Codes mithilfe des Nomodule-Mechanismus laden).  Wenn Sie sich den Code ansehen, den die beliebtesten Bundler generieren, finden Sie viele Vorlagenfragmente, deren Zweck nur darin besteht, anderen Code dynamisch zu laden und Abh√§ngigkeiten zu verwalten.  All dies ist jedoch nicht erforderlich, wenn wir nur die Module und Ausdr√ºcke zum <code>import</code> und <code>export</code> . <br><br>  Gl√ºcklicherweise unterst√ºtzt mindestens einer der beliebten modernen Bundler ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rollup</a> ) Module in Form von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ausgabedaten</a> .  Dies bedeutet, dass Sie den Code mit einem Bundler verarbeiten und Module in der Produktion bereitstellen k√∂nnen (ohne Vorlagenfragmente zum Laden des Codes zu verwenden).  Und da Rollup eine hervorragende Implementierung des Tree-Shaking-Algorithmus hat (der beste, den ich bei Bundlern gesehen habe), k√∂nnen Sie durch das Erstellen von Programmen in Form von Modulen mit Rollup Code erhalten, der kleiner ist als die Gr√∂√üe des gleichen Codes, der beim Anwenden erhalten wurde andere Mechanismen heute verf√ºgbar. <br><br>  Es sollte beachtet werden, dass sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">planen,</a> Unterst√ºtzung f√ºr Module in der n√§chsten Version von Parcel hinzuzuf√ºgen.  Webpack unterst√ºtzt noch keine Module als Ausgabeformat, aber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier ist</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">es</a> - Diskussionen, die sich auf dieses Problem konzentrieren. <br><br>  Ein weiteres Missverst√§ndnis in Bezug auf Module besteht darin, dass einige Leute glauben, dass Module nur verwendet werden k√∂nnen, wenn 100% der Projektabh√§ngigkeiten Module verwenden.  Leider (ich halte es f√ºr sehr bedauerlich) werden die meisten npm-Pakete noch f√ºr die Ver√∂ffentlichung im CommonJS-Format vorbereitet (einige Module, auch solche, die mit ES2015-Funktionen geschrieben wurden, werden vor der Ver√∂ffentlichung in npm in das CommonJS-Format √ºbersetzt)! <br><br>  Auch hier m√∂chte ich darauf hinweisen, dass Rollup √ºber ein Plugin ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">rollup-plugin-commonjs</a> ) verf√ºgt, das mit CommonJS geschriebenen Eingabequellcode in ES2015-Code konvertiert.  Auf jeden Fall w√§re es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">besser,</a> wenn das von Anfang an verwendete Abh√§ngigkeitsformat das ES2015-Modulformat verwendet.  Wenn einige Abh√§ngigkeiten jedoch nicht vorhanden sind, k√∂nnen Sie Projekte nicht mithilfe von Modulen in der Produktion bereitstellen. <br><br>  In den folgenden Teilen dieses Artikels werde ich Ihnen zeigen, wie ich Projekte in Bundles sammle, die Module verwenden (einschlie√ülich der Verwendung dynamischer Importe und der Codetrennung). Ich werde dar√ºber sprechen, warum solche L√∂sungen normalerweise produktiver sind als klassische Skripte, und zeigen, wie sie funktionieren mit Browsern, die keine Module unterst√ºtzen. <br><br><h2>  <font color="#3AC1EF">Optimale Code-Build-Strategie</font> </h2><br>  Das Erstellen von Code f√ºr die Produktion ist immer ein Versuch, die Vor- und Nachteile verschiedener L√∂sungen in Einklang zu bringen.  Einerseits m√∂chte der Entwickler, dass sein Code so schnell wie m√∂glich geladen und ausgef√ºhrt wird.  Andererseits m√∂chte er keinen Code herunterladen, der von den Benutzern des Projekts nicht verwendet wird. <br><br>  Dar√ºber hinaus m√ºssen Entwickler darauf vertrauen k√∂nnen, dass ihr Code am besten f√ºr das Caching geeignet ist.  Das gro√üe Problem der Codeb√ºndelung besteht darin, dass jede √Ñnderung des Codes, selbst eine ge√§nderte Zeile, zur Ung√ºltigmachung des Caches des gesamten Bundles f√ºhrt.  Wenn Sie eine Anwendung bereitstellen, die aus Tausenden kleiner Module besteht (genau in der Form dargestellt, in der sie im Quellcode enthalten sind), k√∂nnen Sie sicher geringf√ºgige √Ñnderungen am Code vornehmen und gleichzeitig wissen, dass der gr√∂√üte Teil des Anwendungscodes zwischengespeichert wird .  Wie ich bereits sagte, kann ein solcher Entwicklungsansatz wahrscheinlich bedeuten, dass das Laden des Codes beim ersten Besuch einer Ressource l√§nger dauern kann als die Verwendung herk√∂mmlicherer Ans√§tze. <br><br>  Infolgedessen stehen wir vor einer schwierigen Aufgabe, n√§mlich den richtigen Ansatz zu finden, um die B√ºndel in Teile zu zerlegen.  Wir m√ºssen das richtige Gleichgewicht zwischen der Geschwindigkeit des Ladens von Materialien und ihrer langfristigen Zwischenspeicherung finden. <br><br>  Die meisten Bundler verwenden standardm√§√üig Codeaufteilungstechniken, die auf dynamischen Importbefehlen basieren.  Aber ich w√ºrde sagen, dass das Teilen von Code nur mit einem Fokus auf dynamischen Import es nicht erlaubt, ihn in ausreichend kleine Fragmente zu zerlegen.  Dies gilt insbesondere f√ºr Websites mit vielen wiederkehrenden Benutzern (dh in Situationen, in denen das Zwischenspeichern wichtig ist). <br><br>  Ich glaube, dass Code in so kleine Fragmente wie m√∂glich aufgeteilt werden sollte.  Es lohnt sich, die Gr√∂√üe der Fragmente zu reduzieren, bis ihre Anzahl so stark zunimmt, dass die Download-Geschwindigkeit des Projekts beeintr√§chtigt wird.  Und obwohl ich definitiv jedem empfehlen kann, seine eigene Analyse der Situation durchzuf√ºhren, gibt es beim Laden von weniger als 100 Modulen keine merkliche Verlangsamung beim Laden, wenn Sie den ungef√§hren Berechnungen in der von mir erw√§hnten Studie glauben.  Eine separate Studie zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://medium.com/%40asyncmax/the-right-way-to-bundle-your-assets-for-faster-sites-over-">HTTP / 2-Leistung</a> ergab keine merkliche Projektverlangsamung beim Herunterladen von weniger als 50 Dateien.  Dort wurden jedoch nur Optionen getestet, bei denen die Anzahl der Dateien 1, 6, 50 und 1000 betrug. Daher sind wahrscheinlich 100 Dateien ein Wert, zu dem Sie problemlos navigieren k√∂nnen, ohne bef√ºrchten zu m√ºssen, dass die Download-Geschwindigkeit abnimmt. <br><br>  Was ist der beste Weg, um den Code aggressiv, aber nicht zu aggressiv in Teile aufzuteilen?  Zus√§tzlich zum Aufteilen von Code basierend auf dynamischen Importbefehlen w√ºrde ich Ihnen raten, sich das Aufteilen von Code in npm-Pakete genauer anzusehen.  Bei diesem Ansatz f√§llt das, was aus dem Ordner <code>node_modules</code> in das Projekt importiert wird, basierend auf dem Paketnamen in ein separates Fragment des fertigen Codes. <br><br><h2>  <font color="#3AC1EF">Pakettrennung</font> </h2><br>  Ich habe oben gesagt, dass einige der modernen Funktionen von Bundlern es erm√∂glichen, ein Hochleistungsschema f√ºr die Bereitstellung modulbasierter Projekte zu organisieren.  Wor√ºber ich gesprochen habe, sind zwei neue Rollup-Funktionen.  Die erste ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">automatische</a> <a href="">Codetrennung</a> durch dynamische <code>import()</code> -Befehle (hinzugef√ºgt <a href="">in Version 1.0.0</a> ).  Die zweite Option ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">manuelle</a> <code>manualChunks</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> die vom Programm basierend auf der Option <code>manualChunks</code> (hinzugef√ºgt in <a href="">Version 1.11.0</a> ) durchgef√ºhrt wird. <br><br>  Dank dieser beiden Funktionen ist es jetzt sehr einfach, den Erstellungsprozess zu konfigurieren, bei dem Code auf Paketebene aufgeteilt wird. <br><br>  Hier ist eine Beispielkonfiguration, die die Option <code>manualChunks</code> , wodurch jedes aus <code>node_modules</code> importierte Modul in ein separates <code>node_modules</code> f√§llt, dessen Name dem Namen des Pakets entspricht (technisch gesehen der Name des Paketverzeichnisses im Ordner <code>node_modules</code> ): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> {  <span class="hljs-attr"><span class="hljs-attr">input</span></span>: {    <span class="hljs-attr"><span class="hljs-attr">main</span></span>: <span class="hljs-string"><span class="hljs-string">'src/main.mjs'</span></span>,  },  <span class="hljs-attr"><span class="hljs-attr">output</span></span>: {    <span class="hljs-attr"><span class="hljs-attr">dir</span></span>: <span class="hljs-string"><span class="hljs-string">'build'</span></span>,    <span class="hljs-attr"><span class="hljs-attr">format</span></span>: <span class="hljs-string"><span class="hljs-string">'esm'</span></span>,    <span class="hljs-attr"><span class="hljs-attr">entryFileNames</span></span>: <span class="hljs-string"><span class="hljs-string">'[name].[hash].mjs'</span></span>,  },  manualChunks(id) {    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id.includes(<span class="hljs-string"><span class="hljs-string">'node_modules'</span></span>)) {      <span class="hljs-comment"><span class="hljs-comment">//   ,    `node_modules`.      //   - ,       .      const dirs = id.split(path.sep);      return dirs[dirs.lastIndexOf('node_modules') + 1];    }  }, }</span></span></code> </pre> <br>  Die Option <code>manualChunk</code> akzeptiert eine Funktion, die als einzelnes Argument den Pfad zur Moduldatei akzeptiert.  Diese Funktion kann einen Zeichenfolgennamen zur√ºckgeben.  Was zur√ºckgegeben wird, zeigt auf ein Fragment der Assembly, zu der das aktuelle Modul hinzugef√ºgt werden soll.  Wenn die Funktion nichts zur√ºckgibt, wird das Modul zum Standardfragment hinzugef√ºgt. <br><br>  <code>cloneDeep()</code> Sie sich eine Anwendung vor, die die <code>cloneDeep()</code> , <code>debounce()</code> und <code>find()</code> aus dem <code>lodash-es</code> Paket <code>lodash-es</code> .  Wenn Sie beim <code>lodash</code> dieser Anwendung die obige Konfiguration anwenden, wird jedes dieser Module (sowie jedes von diesen Modulen importierte <code>lodash</code> Modul) in einer einzelnen Ausgabedatei mit einem Namen wie <code>npm.lodash-es.XXXX.mjs</code> (hier ist <code>XXXX</code> eindeutig Moduldatei-Hash im <code>lodash-es</code> Fragment). <br><br>  Am Ende der Datei sehen Sie einen Exportausdruck wie den folgenden.  Beachten Sie, dass dieser Ausdruck nur Exportbefehle f√ºr Module enth√§lt, die dem Fragment hinzugef√ºgt wurden, und nicht alle <code>lodash</code> Module. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> {cloneDeep, debounce, find};</code> </pre> <br>  Wenn der Code in einem der anderen Fragmente diese <code>lodash</code> Module verwendet (m√∂glicherweise nur die <code>debounce()</code> -Methode), gibt es in diesen Fragmenten im oberen Teil einen Importausdruck, der folgenderma√üen aussieht: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {debounce} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./npm.lodash.XXXX.mjs'</span></span>;</code> </pre> <br>  Hoffentlich hat dieses Beispiel die Frage gekl√§rt, wie die manuelle Codetrennung in Rollup funktioniert.  Dar√ºber hinaus denke ich, dass die Ergebnisse der Codetrennung mithilfe der <code>import</code> und <code>export</code> viel einfacher zu lesen und zu verstehen sind als der Code von Fragmenten, deren Bildung nicht standardm√§√üige Mechanismen verwendet, die nur in einem bestimmten B√ºndler verwendet werden. <br><br>  Zum Beispiel ist es sehr schwierig herauszufinden, was in der n√§chsten Datei vor sich geht.  Dies ist die Ausgabe eines meiner alten Projekte, bei denen Webpack zum Teilen von Code verwendet wurde.  Fast alles in diesem Code wird in Browsern, die Module unterst√ºtzen, nicht ben√∂tigt. <br><br><pre> <code class="javascript hljs">(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>[<span class="hljs-string"><span class="hljs-string">"webpackJsonp"</span></span>] = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>[<span class="hljs-string"><span class="hljs-string">"webpackJsonp"</span></span>] || []).push([[<span class="hljs-string"><span class="hljs-string">"import1"</span></span>],{ <span class="hljs-comment"><span class="hljs-comment">/***/</span></span> <span class="hljs-string"><span class="hljs-string">"tLzr"</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*!*********************************!*\  !*** ./app/scripts/import-1.js ***!  \*********************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/*! exports provided: import1 */</span></span> <span class="hljs-comment"><span class="hljs-comment">/***/</span></span> (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">module, __webpack_exports__, __webpack_require__</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-string"><span class="hljs-string">"use strict"</span></span>; __webpack_require__.r(__webpack_exports__); <span class="hljs-comment"><span class="hljs-comment">/* harmony export (binding) */</span></span> __webpack_require__.d(__webpack_exports__, <span class="hljs-string"><span class="hljs-string">"import1"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> import1; }); <span class="hljs-comment"><span class="hljs-comment">/* harmony import */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _dep_1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(<span class="hljs-comment"><span class="hljs-comment">/*! ./dep-1 */</span></span> <span class="hljs-string"><span class="hljs-string">"6xPP"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> import1 = <span class="hljs-string"><span class="hljs-string">"imported: "</span></span> + _dep_1__WEBPACK_IMPORTED_MODULE_0__[<span class="hljs-string"><span class="hljs-string">"dep1"</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/***/</span></span> }) }]);</code> </pre> <br><h2>  <font color="#3AC1EF">Was ist, wenn es Hunderte von npm-Abh√§ngigkeiten gibt?</font> </h2><br>  Wie gesagt, ich glaube, dass die Trennung auf Codeebene auf Paketebene es dem Entwickler normalerweise erm√∂glicht, eine gute Position einzunehmen, wenn die Codetrennung aggressiv, aber nicht zu aggressiv ist. <br><br>  Wenn Ihre Anwendung Module aus Hunderten verschiedener npm-Pakete importiert, kann es nat√ºrlich immer noch vorkommen, dass der Browser sie nicht alle effektiv laden kann. <br><br>  Wenn Sie jedoch wirklich viele npm-Abh√§ngigkeiten haben, sollten Sie diese Strategie vorerst nicht vollst√§ndig aufgeben.  Denken Sie daran, dass Sie wahrscheinlich nicht alle npm-Abh√§ngigkeiten auf jeder Seite herunterladen werden.  Daher ist es wichtig herauszufinden, wie viele Abh√§ngigkeiten tats√§chlich geladen werden. <br><br>  Ich bin mir jedoch sicher, dass es einige echte Anwendungen gibt, die so viele npm-Abh√§ngigkeiten aufweisen, dass diese Abh√§ngigkeiten einfach nicht als separate Fragmente dargestellt werden k√∂nnen.  Wenn Ihr Projekt genau das ist - ich w√ºrde empfehlen, dass Sie nach einer M√∂glichkeit suchen, Pakete zu gruppieren, bei denen sich der Code, in dem sich mit hoher Wahrscheinlichkeit gleichzeitig √§ndern kann (wie " <code>react</code> und " <code>react-dom</code> da die Fragment-Cache- <code>react-dom</code> mit diesen Paketen ausgef√ºhrt wird zur gleichen Zeit.  Sp√§ter werde ich ein Beispiel zeigen, in dem alle React-Abh√§ngigkeiten in demselben <a href="">Fragment</a> gruppiert sind. <br><br>  Fortsetzung folgt‚Ä¶ <br><br>  <b>Liebe Leser!</b>  Wie gehen Sie in Ihren Projekten mit dem Problem der Codetrennung um? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466537/">https://habr.com/ru/post/de466537/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466521/index.html">C for Metal - Edelmetall f√ºr Computer auf Intel-Grafikkarten</a></li>
<li><a href="../de466525/index.html">Was ist ein PSD iPhone Layout und wie wird es verwendet?</a></li>
<li><a href="../de466527/index.html">Testen der Benutzerfunktionalit√§t von Websites mit Capybara-Seitenobjekten</a></li>
<li><a href="../de466529/index.html">Kompilierungstypen in der JVM: Aufdecken der Black Magic-Sitzung</a></li>
<li><a href="../de466535/index.html">DeepClone neu denken</a></li>
<li><a href="../de466539/index.html">Verwendung von JavaScript-Modulen in der Produktion: aktueller Stand der Dinge. Teil 2</a></li>
<li><a href="../de466541/index.html">Verwenden von DbTool zum Seeding von Datenbanken in .NET-Anwendungen (Core)</a></li>
<li><a href="../de466543/index.html">Habr Weekly # 17 / Sberbank-Darlehen werden von AI genehmigt - be√§ngstigend, Werbung in Open-Source-Produkten - zweifelhaft</a></li>
<li><a href="../de466547/index.html">Gl√ºcklicher Programmiertag</a></li>
<li><a href="../de466549/index.html">Allgemeine Funktionsprinzipien von QEMU-KVM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>