<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😾 👨🏿‍🎤 🌽 Geschützte Methoden in JavaScript ES5 🍤 🚟 🏡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In JavaScript wurden viele großartige Artikel über das Objektmodell geschrieben. Und über die verschiedenen Möglichkeiten, private Klassenmitglieder i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Geschützte Methoden in JavaScript ES5</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425521/">  In JavaScript wurden viele großartige Artikel über das Objektmodell geschrieben.  Und über die verschiedenen Möglichkeiten, private Klassenmitglieder im Internet zu erstellen, gibt es viele wertvolle Beschreibungen.  Aber über geschützte Methoden - es gibt sehr wenig Daten.  Ich möchte diese Lücke füllen und erläutern, wie Sie geschützte Methoden ohne Bibliotheken in reinem JavaScript ECMAScript 5 erstellen können. <br><br>  In diesem Artikel: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warum geschützte Klassenmitglieder benötigt werden</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was Sie brauchen, um die vorgestellte Methode zu verstehen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hilfsklasse ProtectedError</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implementierung geschützter Elemente (Methoden und Eigenschaften) für als Funktionen deklarierte Klassen (ECMAScript 5)</a> </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link zum Git-Hub-Repository mit Quellcode und Tests.</a> <a name="habracut"></a><br><br><h2>  Warum geschützte Klassenmitglieder benötigt werden </h2><br>  Kurz gesagt <br><br><ul><li>  Es ist einfacher, die Funktionsweise der Klasse zu verstehen und Fehler darin zu finden.  (Sie können sofort sehen, in welchem ​​Fall die Klassenmitglieder verwendet werden. Wenn privat, müssen Sie nur diese Klasse analysieren, und wenn geschützt, dann nur diese und abgeleitete Klassen.) </li><li>  einfacher, Änderungen zu verwalten.  (Sie können beispielsweise private Mitglieder entfernen, ohne befürchten zu müssen, dass etwas außerhalb der bearbeitbaren Klasse beschädigt wird.) </li><li> Die Anzahl der Anwendungen im Bug-Tracker wird reduziert, weil  Benutzer der Bibliothek oder des Steuerelements können unsere "privaten" Mitglieder "vernähen", die wir in der neuen Version der Klasse entfernt haben, oder die Logik ihrer Arbeit ändern. </li><li>  Und im Allgemeinen sind geschützte Klassenmitglieder ein Entwurfswerkzeug.  Es ist gut, es griffbereit und gut getestet zu haben. </li></ul><br>  Ich möchte Sie daran erinnern, dass die Hauptidee geschützter Mitglieder darin besteht, Methoden und Eigenschaften vor Benutzern der Klasseninstanz zu verbergen und gleichzeitig abgeleiteten Klassen Zugriff auf sie zu gewähren. <br><br>  Mit TypeScript können geschützte Methoden nicht aufgerufen werden. Nach der Kompilierung in JavaScript werden jedoch alle privaten und geschützten Mitglieder öffentlich.  Beispielsweise entwickeln wir ein Steuerelement oder eine Bibliothek, die Benutzer auf ihren Websites oder Anwendungen installieren.  Diese Benutzer können mit geschützten Mitgliedern tun, was sie wollen, was die Integrität der Klasse verletzt.  Infolgedessen strotzt unser Bug-Tracker vor Beschwerden, dass unsere Bibliothek oder Steuerung nicht richtig funktioniert.  Wir investieren Zeit und Mühe, um das Problem zu lösen. <i>"Befand sich das Objekt auf diese Weise in dem Zustand des Clients, der zu einem Fehler führte ?!"</i>  .  Um das Leben für alle einfacher zu machen, ist daher ein solcher Schutz erforderlich, der es nicht ermöglicht, die Bedeutung privater und geschützter Klassenmitglieder zu ändern. <br><br><h2>  Was Sie brauchen, um die betreffende Methode zu verstehen </h2><br>  Um die Methode zum Deklarieren geschützter Klassenmitglieder zu verstehen, benötigen Sie fundierte Kenntnisse: <br><br><ul><li>  Geräteklassen und Objekte in JavaScript. </li><li>  Möglichkeiten, private Klassenmitglieder zu erstellen (zumindest durch Schließung). </li><li>  Methoden Object.defineProperty und Object.getOwnPropertyDescriptor </li></ul><br>  Über das Gerätemodell in JavaScript kann ich beispielsweise einen ausgezeichneten Artikel von Andrey Akinshin ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">DreamWalker</a> ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Grundlegendes zu</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OOP in JS [Teil Nr. 1]“</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">empfehlen</a> . <br>  Über private Immobilien gibt es eine gute und meiner Meinung nach ziemlich vollständige Beschreibung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bis zu 4 verschiedenen Möglichkeiten, private Klassenmitglieder</a> auf der MDN-Website <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zu erstellen</a> . <br><br>  Mit der Object.defineProperty-Methode können wir Eigenschaften und Methoden vor For-In-Schleifen und damit vor Serialisierungsalgorithmen verbergen: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(MyClass.prototype, <span class="hljs-string"><span class="hljs-string">'protectedNumber'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.publicNumber = <span class="hljs-number"><span class="hljs-number">25</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyClass(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> prop <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> obj1){ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'property:'</span></span> prop); <span class="hljs-comment"><span class="hljs-comment">//prop     'protectedNumber' } console.log(JSON.stringify(obj1)); //  { 'publicNumber': 25 }</span></span></code> </pre> <br>  Eine solche Verschleierung muss durchgeführt werden, aber das reicht natürlich nicht aus, weil  Es besteht weiterhin die Möglichkeit, die Methode / Eigenschaft direkt aufzurufen: <br><br><pre> <code class="javascript hljs"> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj1.protectedNumber); <span class="hljs-comment"><span class="hljs-comment">//  12.</span></span></code> </pre><br><h2>  Hilfsklasse ProtectedError </h2><br>  Zunächst benötigen wir die ProtectedError-Klasse, die von Error erbt und ausgelöst wird, wenn kein Zugriff auf die geschützte Methode oder Eigenschaft besteht. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProtectedError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.message = <span class="hljs-string"><span class="hljs-string">"Encapsulation error, the object member you are trying to address is protected."</span></span>; } ProtectedError.prototype = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(); ProtectedError.prototype.constructor = ProtectedError;</code> </pre><br><h2>  Implementieren geschützter Klassenmitglieder in ES5 </h2><br>  Nachdem wir nun die ProtectedError-Klasse haben und verstehen, was Object.defineProperty mit dem Wert enumerable: false macht, analysieren wir die Erstellung einer Basisklasse, die die protectedMethod-Methode für alle abgeleiteten Klassen freigeben möchte, aber vor allen anderen verbergen: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BaseClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> BaseClass)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseClass(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   ,        /** @summary       */ function checkAccess() { if (!(this instanceof BaseClass)) throw new ProtectedError(); if (this.constructor === BaseClass) throw new ProtectedError() } Object.defineProperty(_self, 'protectedMethod', { enumerable: false, //    for-in  configurable:false, //     value: function(){ //   , ,          Base,     checkAccess.call(this); //  . protectedMethod(); } }); function protectedMethod(){ //       , //       this,   _self return 'example value'; } this.method = function (){ protectedMethod(); //          BaseClass //this.protectedMethod(); //   , ..      ProtectedError } }</span></span></code> </pre><br><h3>  Beschreibung des BaseClass-Klassenkonstruktors </h3><br>  Vielleicht werden Sie durch den Scheck verwirrt: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> BaseClass)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseClass();</code> </pre>  Dieser Test ist ein "Amateur".  Sie können es entfernen, es hat nichts mit geschützten Methoden zu tun.  Ich persönlich lasse es jedoch in meinem Code, weil  es wird für jene Fälle benötigt, in denen die Klasseninstanz nicht korrekt erstellt wird, d.h.  ohne das Schlüsselwort neu.  Zum Beispiel so: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj1 = BaseClass(); <span class="hljs-comment"><span class="hljs-comment">//  : var obj2 = BaseClass.call({});</span></span></code> </pre><br>  Tun Sie in solchen Fällen, was Sie möchten.  Sie können beispielsweise einen Fehler generieren: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> BaseClass)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Wrong instance creation. Maybe operator "new" was forgotten'</span></span>);</code> </pre><br>  Oder Sie können einfach korrekt instanziieren, wie in BaseClass. <br><br>  Als nächstes speichern wir die neue Instanz in der Variablen _self (warum ich das später erklären muss). <br><br><h3>  Beschreibung einer öffentlichen Eigenschaft namens protectedMethod </h3><br>  Wenn wir die Methode eingeben, rufen wir die Kontextprüfung auf, für die wir aufgerufen wurden.  Es ist besser, in einer separaten Methode auszuchecken, z. B. checkAccess, weil  Die gleiche Prüfung ist für alle geschützten Methoden und Eigenschaften von Klassen erforderlich.  Überprüfen Sie zunächst den Kontexttyp des Aufrufs.  Wenn dies einen anderen Typ als BaseClass hat, ist der Typ weder BaseClass selbst noch eines seiner Derivate.  Wir verbieten solche Anrufe. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> BaseClass)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProtectedError();</code> </pre><br>  Wie kann das passieren?  Zum Beispiel so: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseClass(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> someObject = {}; b.protectedMethod.call(someObject); <span class="hljs-comment"><span class="hljs-comment">//   ,  protectedMethod this   someObject    , .. someObject instanceof BaseClass  </span></span></code> </pre><br>  Bei abgeleiteten Klassen ist der Ausdruck dieser Instanz von BaseClass wahr.  Für BaseClass-Instanzen ist diese Instanz des BaseClass-Ausdrucks jedoch wahr.  Um Instanzen der BaseClass-Klasse von Instanzen abgeleiteter Klassen zu unterscheiden, überprüfen wir daher den Konstruktor.  Wenn der Konstruktor mit BaseClass übereinstimmt, wird unsere protectedMethod in der BaseClass-Instanz genau wie eine reguläre öffentliche Methode aufgerufen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseClass(); b.protectedMethod();</code> </pre><br>  Wir verbieten solche Anrufe: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.constructor === BaseClass) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProtectedError();</code> </pre><br>  Als nächstes folgt der Aufruf der geschlossenen Methode protectedMethod, die wir tatsächlich schützen.  Wenn Sie innerhalb der Methode auf die Mitglieder der BaseClass-Klasse verweisen müssen, können Sie dies mit der gespeicherten Instanz von _self tun.  Dies ist genau das, was _self erstellt wurde, um Zugriff auf Klassenmitglieder aus allen privaten / privaten Methoden zu erhalten.  Wenn Sie in Ihrer geschützten Methode oder Eigenschaft nicht auf Klassenmitglieder zugreifen müssen, können Sie daher die Variable _self nicht erstellen. <br><br><h3>  Aufrufen einer geschützten Methode innerhalb der BaseClass-Klasse </h3><br>  Innerhalb der BaseClass-Klasse darf auf protectedMethod nur über den Namen zugegriffen werden, nicht über diesen.  Andernfalls können wir innerhalb von protectedMethod nicht unterscheiden, ob wir als öffentliche Methode oder innerhalb einer Klasse aufgerufen wurden.  In diesem Fall spart uns der Abschluss - protectedMethod verhält sich wie eine normale private Methode, die innerhalb der Klasse geschlossen und nur im Rahmen der BaseClass-Funktion sichtbar ist. <br><br><h3>  DerivedClass Abgeleitete Klassenbeschreibung </h3><br>  Schauen wir uns nun eine abgeleitete Klasse an und wie Sie sie einer geschützten Methode einer Basisklasse zugänglich machen können. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DerivedClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _base = { <span class="hljs-attr"><span class="hljs-attr">protectedMethod</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.protectedMethod.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) }; <span class="hljs-comment"><span class="hljs-comment">/** @summary       */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAccess</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.constructor === DerivedClass) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProtectedError(); } <span class="hljs-comment"><span class="hljs-comment">//     Object.defineProperty(this, 'protectedMethod', { enumerable: false, // ..       this configurable: false,//         for-in  //      value: function(){ checkAccess.call(_self); return _base.protectedMethod(); } }); //        this.someMethod = function(){ console.log(_base.protectedMethod()); } } DerivedClass.prototype = new BaseClass(); Object.defineProperty(DerivedClass.prototype, 'constructor', { value : DerivedClass, configurable: false });</span></span></code> </pre><br><h3>  Abgeleitete Beschreibung des Klassenkonstruktors </h3><br>  In der abgeleiteten Klasse erstellen wir ein _base-Objekt, in dem wir einen Verweis auf die protectedMethod-Methode der Basisklasse platzieren, die über die Standardbindungsmethode für den Kontext der abgeleiteten Klasse geschlossen ist.  Dies bedeutet, dass _base.protectedMethod () aufgerufen wird;  In protectedMethod ist dies kein _base-Objekt, sondern eine Instanz der DerivedClass-Klasse. <br><br><h3>  ProtectedMethod Methodenbeschreibung In DerivedClass </h3><br>  In der DerivedClass-Klasse muss die public-Methode protectedMethod auf dieselbe Weise wie in der Basisklasse über Object.defineProperty deklariert und der Zugriff darauf durch Aufrufen der checkAccess-Methode oder durch direktes Einchecken der Methode überprüft werden: <br><br><pre> <code class="javascript hljs"> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(DerivedClass.prototype, <span class="hljs-string"><span class="hljs-string">'protectedMethod'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.constructor === DerivedClass) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProtectedError() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _base.protectedMethod(); } });</code> </pre><br>  Wir überprüfen - <i>"aber wurden wir als einfache öffentliche Methode aufgerufen?"</i>  Für Instanzen der DerivedClass-Klasse entspricht der Konstruktor DerivedClass.  Wenn ja, generieren Sie einen Fehler.  Andernfalls senden wir es an die Basisklasse und es werden bereits alle anderen Überprüfungen durchgeführt. <br><br>  In der abgeleiteten Klasse haben wir also zwei Funktionen.  Eine wird über Object.defineProperty deklariert und für von DerivedClass abgeleitete Klassen benötigt.  Es ist öffentlich und hat daher einen Scheck, der öffentliche Anrufe verbietet.  Die zweite Methode befindet sich im _base-Objekt, das innerhalb der DerivedClass-Klasse geschlossen ist und daher von außen für niemanden sichtbar ist. Sie wird verwendet, um von allen DerivedClass-Methoden auf die geschützte Methode zuzugreifen. <br><br><h3>  Eigentumsschutz </h3><br>  Bei Eigenschaften läuft die Arbeit etwas anders ab.  Eigenschaften in BaseClass werden wie gewohnt über Object.defineProperty definiert. Nur in Gettern und Setzern müssen Sie zuerst unsere Prüfung hinzufügen, d. H.  Rufen Sie checkAccess auf: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BaseClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAccess</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _protectedProperty; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">'protectedProperty'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ checkAccess.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _protectedProperty; }, <span class="hljs-attr"><span class="hljs-attr">set</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ checkAccess.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); _protectedProperty = value; }, <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }); }</code> </pre><br>  Innerhalb der BaseClass-Klasse wird nicht über diese, sondern über die geschlossene Variable _protectedProperty auf die protected-Eigenschaft zugegriffen.  Wenn es für uns wichtig ist, dass Getter und Setter funktionieren, wenn die Eigenschaft in der BaseClass-Klasse verwendet wird, müssen private Methoden getProtectedPropety und setProtectedProperty erstellt werden, in denen keine Überprüfungen stattfinden und die bereits aufgerufen werden sollten. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BaseClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAccess</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _protectedProperty; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">'protectedProperty'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ checkAccess.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getProtectedProperty(); }, <span class="hljs-attr"><span class="hljs-attr">set</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ checkAccess.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); setProtectedProperty(value); }, <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getProtectedProperty</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    return _protectedProperty; } function setProtectedProperty(value){ //    _protectedProperty = value; } }</span></span></code> </pre><br>  In abgeleiteten Klassen ist das Arbeiten mit Eigenschaften etwas komplizierter, weil  Eigenschaft kann nicht durch Kontext ersetzt werden.  Daher verwenden wir die Standardmethode Object.getOwnPropertyDescriptor, um den Getter und Setter aus der Eigenschaft der Basisklasse als Funktionen abzurufen, die den Aufrufkontext bereits ändern können: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DerivedClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAccess</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _base = { <span class="hljs-attr"><span class="hljs-attr">protectedMethod</span></span>: _self.protectedMethod.bind(_self), }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _baseProtectedPropertyDescriptor = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptor(_self, <span class="hljs-string"><span class="hljs-string">'protectedProperty'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      _base //    DerivedClass     Object.defineProperty(_base, 'protectedProperty', { get: function() { return _baseProtectedPropertyDescriptor.get.call(_self); }, set: function(value){ _baseProtectedPropertyDescriptor.set.call(_self, value); } }) //      ,      DerivedClass      . Object.defineProperty(_self, 'protectedProperty', { get: function () { checkAccess.call(_self); return base.protectedProperty; }, set: function (value) { checkAccess.call(_self); _base.protectedProperty = value; }, enumerable: false, configurable: false }); }</span></span></code> </pre><br><h3>  Vererbungsbeschreibung </h3><br>  Und das Letzte, was ich kommentieren möchte, ist die Vererbung von DerivedClass von BaseClass.  Wie Sie vielleicht wissen, ist DerivedClass.prototype = new BaseClass ();  erstellt nicht nur einen Prototyp, sondern schreibt auch seine Konstruktoreigenschaft neu.  Aus diesem Grund wird die Konstruktoreigenschaft für jede Instanz von DerivedClass gleich BaseClass.  Um dies zu beheben, schreiben Sie normalerweise nach dem Erstellen eines Prototyps die Konstruktoreigenschaft neu: <br><br><pre> <code class="javascript hljs">DerivedClass.prototype = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseClass(); DerivedClass.prototype.constructor = DerivedClass;</code> </pre><br>  Damit jedoch niemand diese Eigenschaft nach uns neu schreibt, verwenden wir dieselbe Object.defineProperty.  Die Eigenschaft configable: false verhindert, dass die Eigenschaft erneut überschrieben wird: <br><br><pre> <code class="javascript hljs">DerivedClass.prototype = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseClass(); <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(DerivedClass.prototype, <span class="hljs-string"><span class="hljs-string">'constructor'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span> : DerivedClass, <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> });</code> </pre></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425521/">https://habr.com/ru/post/de425521/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425505/index.html">Analyse des Linux-Kernel-Boot-Prozesses</a></li>
<li><a href="../de425507/index.html">Parsim Wikipedia für NLP-Aufgaben in 4 Teams</a></li>
<li><a href="../de425511/index.html">Nicht offensichtliche Funktionen der Rotativa-Anwendung zum Generieren von PDF in der ASP.NET MVC-Anwendung</a></li>
<li><a href="../de425515/index.html">Apple blockiert die unabhängige Reparatur neuer MacBook-Modelle</a></li>
<li><a href="../de425517/index.html">Wie Yandex mithilfe von Radar und Satelliten eine globale Niederschlagsvorhersage erstellte</a></li>
<li><a href="../de425525/index.html">Tim Berners-Lee geht auf den Kriegspfad: "Ein kleiner Schritt für das Web ..."</a></li>
<li><a href="../de425527/index.html">Listen bei Kotlin. Haskell Ansatz</a></li>
<li><a href="../de425529/index.html">Sans Forgetica: Eine Schriftart, mit der Sie sich das Gelesene etwas besser merken können</a></li>
<li><a href="../de425531/index.html">Kühlung der Flüssigkeitsbremse. Systementwicklungsoptionen</a></li>
<li><a href="../de425533/index.html">So arbeiten Sie in der Cloud: von der Überprüfung der Zuverlässigkeit eines Rechenzentrums bis zur Verwaltung einer virtuellen Infrastruktur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>