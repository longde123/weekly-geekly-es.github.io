<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòæ üë®üèø‚Äçüé§ üåΩ Gesch√ºtzte Methoden in JavaScript ES5 üç§ üöü üè°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In JavaScript wurden viele gro√üartige Artikel √ºber das Objektmodell geschrieben. Und √ºber die verschiedenen M√∂glichkeiten, private Klassenmitglieder i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gesch√ºtzte Methoden in JavaScript ES5</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425521/">  In JavaScript wurden viele gro√üartige Artikel √ºber das Objektmodell geschrieben.  Und √ºber die verschiedenen M√∂glichkeiten, private Klassenmitglieder im Internet zu erstellen, gibt es viele wertvolle Beschreibungen.  Aber √ºber gesch√ºtzte Methoden - es gibt sehr wenig Daten.  Ich m√∂chte diese L√ºcke f√ºllen und erl√§utern, wie Sie gesch√ºtzte Methoden ohne Bibliotheken in reinem JavaScript ECMAScript 5 erstellen k√∂nnen. <br><br>  In diesem Artikel: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warum gesch√ºtzte Klassenmitglieder ben√∂tigt werden</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was Sie brauchen, um die vorgestellte Methode zu verstehen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hilfsklasse ProtectedError</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implementierung gesch√ºtzter Elemente (Methoden und Eigenschaften) f√ºr als Funktionen deklarierte Klassen (ECMAScript 5)</a> </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link zum Git-Hub-Repository mit Quellcode und Tests.</a> <a name="habracut"></a><br><br><h2>  Warum gesch√ºtzte Klassenmitglieder ben√∂tigt werden </h2><br>  Kurz gesagt <br><br><ul><li>  Es ist einfacher, die Funktionsweise der Klasse zu verstehen und Fehler darin zu finden.  (Sie k√∂nnen sofort sehen, in welchem ‚Äã‚ÄãFall die Klassenmitglieder verwendet werden. Wenn privat, m√ºssen Sie nur diese Klasse analysieren, und wenn gesch√ºtzt, dann nur diese und abgeleitete Klassen.) </li><li>  einfacher, √Ñnderungen zu verwalten.  (Sie k√∂nnen beispielsweise private Mitglieder entfernen, ohne bef√ºrchten zu m√ºssen, dass etwas au√üerhalb der bearbeitbaren Klasse besch√§digt wird.) </li><li> Die Anzahl der Anwendungen im Bug-Tracker wird reduziert, weil  Benutzer der Bibliothek oder des Steuerelements k√∂nnen unsere "privaten" Mitglieder "vern√§hen", die wir in der neuen Version der Klasse entfernt haben, oder die Logik ihrer Arbeit √§ndern. </li><li>  Und im Allgemeinen sind gesch√ºtzte Klassenmitglieder ein Entwurfswerkzeug.  Es ist gut, es griffbereit und gut getestet zu haben. </li></ul><br>  Ich m√∂chte Sie daran erinnern, dass die Hauptidee gesch√ºtzter Mitglieder darin besteht, Methoden und Eigenschaften vor Benutzern der Klasseninstanz zu verbergen und gleichzeitig abgeleiteten Klassen Zugriff auf sie zu gew√§hren. <br><br>  Mit TypeScript k√∂nnen gesch√ºtzte Methoden nicht aufgerufen werden. Nach der Kompilierung in JavaScript werden jedoch alle privaten und gesch√ºtzten Mitglieder √∂ffentlich.  Beispielsweise entwickeln wir ein Steuerelement oder eine Bibliothek, die Benutzer auf ihren Websites oder Anwendungen installieren.  Diese Benutzer k√∂nnen mit gesch√ºtzten Mitgliedern tun, was sie wollen, was die Integrit√§t der Klasse verletzt.  Infolgedessen strotzt unser Bug-Tracker vor Beschwerden, dass unsere Bibliothek oder Steuerung nicht richtig funktioniert.  Wir investieren Zeit und M√ºhe, um das Problem zu l√∂sen. <i>"Befand sich das Objekt auf diese Weise in dem Zustand des Clients, der zu einem Fehler f√ºhrte ?!"</i>  .  Um das Leben f√ºr alle einfacher zu machen, ist daher ein solcher Schutz erforderlich, der es nicht erm√∂glicht, die Bedeutung privater und gesch√ºtzter Klassenmitglieder zu √§ndern. <br><br><h2>  Was Sie brauchen, um die betreffende Methode zu verstehen </h2><br>  Um die Methode zum Deklarieren gesch√ºtzter Klassenmitglieder zu verstehen, ben√∂tigen Sie fundierte Kenntnisse: <br><br><ul><li>  Ger√§teklassen und Objekte in JavaScript. </li><li>  M√∂glichkeiten, private Klassenmitglieder zu erstellen (zumindest durch Schlie√üung). </li><li>  Methoden Object.defineProperty und Object.getOwnPropertyDescriptor </li></ul><br>  √úber das Ger√§temodell in JavaScript kann ich beispielsweise einen ausgezeichneten Artikel von Andrey Akinshin ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">DreamWalker</a> ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚Äû</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Grundlegendes zu</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OOP in JS [Teil Nr. 1]‚Äú</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">empfehlen</a> . <br>  √úber private Immobilien gibt es eine gute und meiner Meinung nach ziemlich vollst√§ndige Beschreibung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bis zu 4 verschiedenen M√∂glichkeiten, private Klassenmitglieder</a> auf der MDN-Website <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zu erstellen</a> . <br><br>  Mit der Object.defineProperty-Methode k√∂nnen wir Eigenschaften und Methoden vor For-In-Schleifen und damit vor Serialisierungsalgorithmen verbergen: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(MyClass.prototype, <span class="hljs-string"><span class="hljs-string">'protectedNumber'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.publicNumber = <span class="hljs-number"><span class="hljs-number">25</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyClass(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> prop <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> obj1){ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'property:'</span></span> prop); <span class="hljs-comment"><span class="hljs-comment">//prop     'protectedNumber' } console.log(JSON.stringify(obj1)); //  { 'publicNumber': 25 }</span></span></code> </pre> <br>  Eine solche Verschleierung muss durchgef√ºhrt werden, aber das reicht nat√ºrlich nicht aus, weil  Es besteht weiterhin die M√∂glichkeit, die Methode / Eigenschaft direkt aufzurufen: <br><br><pre> <code class="javascript hljs"> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj1.protectedNumber); <span class="hljs-comment"><span class="hljs-comment">//  12.</span></span></code> </pre><br><h2>  Hilfsklasse ProtectedError </h2><br>  Zun√§chst ben√∂tigen wir die ProtectedError-Klasse, die von Error erbt und ausgel√∂st wird, wenn kein Zugriff auf die gesch√ºtzte Methode oder Eigenschaft besteht. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProtectedError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.message = <span class="hljs-string"><span class="hljs-string">"Encapsulation error, the object member you are trying to address is protected."</span></span>; } ProtectedError.prototype = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(); ProtectedError.prototype.constructor = ProtectedError;</code> </pre><br><h2>  Implementieren gesch√ºtzter Klassenmitglieder in ES5 </h2><br>  Nachdem wir nun die ProtectedError-Klasse haben und verstehen, was Object.defineProperty mit dem Wert enumerable: false macht, analysieren wir die Erstellung einer Basisklasse, die die protectedMethod-Methode f√ºr alle abgeleiteten Klassen freigeben m√∂chte, aber vor allen anderen verbergen: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BaseClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> BaseClass)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseClass(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   ,        /** @summary       */ function checkAccess() { if (!(this instanceof BaseClass)) throw new ProtectedError(); if (this.constructor === BaseClass) throw new ProtectedError() } Object.defineProperty(_self, 'protectedMethod', { enumerable: false, //    for-in  configurable:false, //     value: function(){ //   , ,          Base,     checkAccess.call(this); //  . protectedMethod(); } }); function protectedMethod(){ //       , //       this,   _self return 'example value'; } this.method = function (){ protectedMethod(); //          BaseClass //this.protectedMethod(); //   , ..      ProtectedError } }</span></span></code> </pre><br><h3>  Beschreibung des BaseClass-Klassenkonstruktors </h3><br>  Vielleicht werden Sie durch den Scheck verwirrt: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> BaseClass)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseClass();</code> </pre>  Dieser Test ist ein "Amateur".  Sie k√∂nnen es entfernen, es hat nichts mit gesch√ºtzten Methoden zu tun.  Ich pers√∂nlich lasse es jedoch in meinem Code, weil  es wird f√ºr jene F√§lle ben√∂tigt, in denen die Klasseninstanz nicht korrekt erstellt wird, d.h.  ohne das Schl√ºsselwort neu.  Zum Beispiel so: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj1 = BaseClass(); <span class="hljs-comment"><span class="hljs-comment">//  : var obj2 = BaseClass.call({});</span></span></code> </pre><br>  Tun Sie in solchen F√§llen, was Sie m√∂chten.  Sie k√∂nnen beispielsweise einen Fehler generieren: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> BaseClass)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Wrong instance creation. Maybe operator "new" was forgotten'</span></span>);</code> </pre><br>  Oder Sie k√∂nnen einfach korrekt instanziieren, wie in BaseClass. <br><br>  Als n√§chstes speichern wir die neue Instanz in der Variablen _self (warum ich das sp√§ter erkl√§ren muss). <br><br><h3>  Beschreibung einer √∂ffentlichen Eigenschaft namens protectedMethod </h3><br>  Wenn wir die Methode eingeben, rufen wir die Kontextpr√ºfung auf, f√ºr die wir aufgerufen wurden.  Es ist besser, in einer separaten Methode auszuchecken, z. B. checkAccess, weil  Die gleiche Pr√ºfung ist f√ºr alle gesch√ºtzten Methoden und Eigenschaften von Klassen erforderlich.  √úberpr√ºfen Sie zun√§chst den Kontexttyp des Aufrufs.  Wenn dies einen anderen Typ als BaseClass hat, ist der Typ weder BaseClass selbst noch eines seiner Derivate.  Wir verbieten solche Anrufe. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> BaseClass)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProtectedError();</code> </pre><br>  Wie kann das passieren?  Zum Beispiel so: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseClass(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> someObject = {}; b.protectedMethod.call(someObject); <span class="hljs-comment"><span class="hljs-comment">//   ,  protectedMethod this   someObject    , .. someObject instanceof BaseClass  </span></span></code> </pre><br>  Bei abgeleiteten Klassen ist der Ausdruck dieser Instanz von BaseClass wahr.  F√ºr BaseClass-Instanzen ist diese Instanz des BaseClass-Ausdrucks jedoch wahr.  Um Instanzen der BaseClass-Klasse von Instanzen abgeleiteter Klassen zu unterscheiden, √ºberpr√ºfen wir daher den Konstruktor.  Wenn der Konstruktor mit BaseClass √ºbereinstimmt, wird unsere protectedMethod in der BaseClass-Instanz genau wie eine regul√§re √∂ffentliche Methode aufgerufen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseClass(); b.protectedMethod();</code> </pre><br>  Wir verbieten solche Anrufe: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.constructor === BaseClass) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProtectedError();</code> </pre><br>  Als n√§chstes folgt der Aufruf der geschlossenen Methode protectedMethod, die wir tats√§chlich sch√ºtzen.  Wenn Sie innerhalb der Methode auf die Mitglieder der BaseClass-Klasse verweisen m√ºssen, k√∂nnen Sie dies mit der gespeicherten Instanz von _self tun.  Dies ist genau das, was _self erstellt wurde, um Zugriff auf Klassenmitglieder aus allen privaten / privaten Methoden zu erhalten.  Wenn Sie in Ihrer gesch√ºtzten Methode oder Eigenschaft nicht auf Klassenmitglieder zugreifen m√ºssen, k√∂nnen Sie daher die Variable _self nicht erstellen. <br><br><h3>  Aufrufen einer gesch√ºtzten Methode innerhalb der BaseClass-Klasse </h3><br>  Innerhalb der BaseClass-Klasse darf auf protectedMethod nur √ºber den Namen zugegriffen werden, nicht √ºber diesen.  Andernfalls k√∂nnen wir innerhalb von protectedMethod nicht unterscheiden, ob wir als √∂ffentliche Methode oder innerhalb einer Klasse aufgerufen wurden.  In diesem Fall spart uns der Abschluss - protectedMethod verh√§lt sich wie eine normale private Methode, die innerhalb der Klasse geschlossen und nur im Rahmen der BaseClass-Funktion sichtbar ist. <br><br><h3>  DerivedClass Abgeleitete Klassenbeschreibung </h3><br>  Schauen wir uns nun eine abgeleitete Klasse an und wie Sie sie einer gesch√ºtzten Methode einer Basisklasse zug√§nglich machen k√∂nnen. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DerivedClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _base = { <span class="hljs-attr"><span class="hljs-attr">protectedMethod</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.protectedMethod.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) }; <span class="hljs-comment"><span class="hljs-comment">/** @summary       */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAccess</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.constructor === DerivedClass) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProtectedError(); } <span class="hljs-comment"><span class="hljs-comment">//     Object.defineProperty(this, 'protectedMethod', { enumerable: false, // ..       this configurable: false,//         for-in  //      value: function(){ checkAccess.call(_self); return _base.protectedMethod(); } }); //        this.someMethod = function(){ console.log(_base.protectedMethod()); } } DerivedClass.prototype = new BaseClass(); Object.defineProperty(DerivedClass.prototype, 'constructor', { value : DerivedClass, configurable: false });</span></span></code> </pre><br><h3>  Abgeleitete Beschreibung des Klassenkonstruktors </h3><br>  In der abgeleiteten Klasse erstellen wir ein _base-Objekt, in dem wir einen Verweis auf die protectedMethod-Methode der Basisklasse platzieren, die √ºber die Standardbindungsmethode f√ºr den Kontext der abgeleiteten Klasse geschlossen ist.  Dies bedeutet, dass _base.protectedMethod () aufgerufen wird;  In protectedMethod ist dies kein _base-Objekt, sondern eine Instanz der DerivedClass-Klasse. <br><br><h3>  ProtectedMethod Methodenbeschreibung In DerivedClass </h3><br>  In der DerivedClass-Klasse muss die public-Methode protectedMethod auf dieselbe Weise wie in der Basisklasse √ºber Object.defineProperty deklariert und der Zugriff darauf durch Aufrufen der checkAccess-Methode oder durch direktes Einchecken der Methode √ºberpr√ºft werden: <br><br><pre> <code class="javascript hljs"> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(DerivedClass.prototype, <span class="hljs-string"><span class="hljs-string">'protectedMethod'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.constructor === DerivedClass) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProtectedError() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _base.protectedMethod(); } });</code> </pre><br>  Wir √ºberpr√ºfen - <i>"aber wurden wir als einfache √∂ffentliche Methode aufgerufen?"</i>  F√ºr Instanzen der DerivedClass-Klasse entspricht der Konstruktor DerivedClass.  Wenn ja, generieren Sie einen Fehler.  Andernfalls senden wir es an die Basisklasse und es werden bereits alle anderen √úberpr√ºfungen durchgef√ºhrt. <br><br>  In der abgeleiteten Klasse haben wir also zwei Funktionen.  Eine wird √ºber Object.defineProperty deklariert und f√ºr von DerivedClass abgeleitete Klassen ben√∂tigt.  Es ist √∂ffentlich und hat daher einen Scheck, der √∂ffentliche Anrufe verbietet.  Die zweite Methode befindet sich im _base-Objekt, das innerhalb der DerivedClass-Klasse geschlossen ist und daher von au√üen f√ºr niemanden sichtbar ist. Sie wird verwendet, um von allen DerivedClass-Methoden auf die gesch√ºtzte Methode zuzugreifen. <br><br><h3>  Eigentumsschutz </h3><br>  Bei Eigenschaften l√§uft die Arbeit etwas anders ab.  Eigenschaften in BaseClass werden wie gewohnt √ºber Object.defineProperty definiert. Nur in Gettern und Setzern m√ºssen Sie zuerst unsere Pr√ºfung hinzuf√ºgen, d. H.  Rufen Sie checkAccess auf: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BaseClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAccess</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _protectedProperty; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">'protectedProperty'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ checkAccess.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _protectedProperty; }, <span class="hljs-attr"><span class="hljs-attr">set</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ checkAccess.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); _protectedProperty = value; }, <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }); }</code> </pre><br>  Innerhalb der BaseClass-Klasse wird nicht √ºber diese, sondern √ºber die geschlossene Variable _protectedProperty auf die protected-Eigenschaft zugegriffen.  Wenn es f√ºr uns wichtig ist, dass Getter und Setter funktionieren, wenn die Eigenschaft in der BaseClass-Klasse verwendet wird, m√ºssen private Methoden getProtectedPropety und setProtectedProperty erstellt werden, in denen keine √úberpr√ºfungen stattfinden und die bereits aufgerufen werden sollten. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BaseClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAccess</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _protectedProperty; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">'protectedProperty'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ checkAccess.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getProtectedProperty(); }, <span class="hljs-attr"><span class="hljs-attr">set</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ checkAccess.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); setProtectedProperty(value); }, <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getProtectedProperty</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    return _protectedProperty; } function setProtectedProperty(value){ //    _protectedProperty = value; } }</span></span></code> </pre><br>  In abgeleiteten Klassen ist das Arbeiten mit Eigenschaften etwas komplizierter, weil  Eigenschaft kann nicht durch Kontext ersetzt werden.  Daher verwenden wir die Standardmethode Object.getOwnPropertyDescriptor, um den Getter und Setter aus der Eigenschaft der Basisklasse als Funktionen abzurufen, die den Aufrufkontext bereits √§ndern k√∂nnen: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DerivedClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAccess</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _base = { <span class="hljs-attr"><span class="hljs-attr">protectedMethod</span></span>: _self.protectedMethod.bind(_self), }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _baseProtectedPropertyDescriptor = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptor(_self, <span class="hljs-string"><span class="hljs-string">'protectedProperty'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      _base //    DerivedClass     Object.defineProperty(_base, 'protectedProperty', { get: function() { return _baseProtectedPropertyDescriptor.get.call(_self); }, set: function(value){ _baseProtectedPropertyDescriptor.set.call(_self, value); } }) //      ,      DerivedClass      . Object.defineProperty(_self, 'protectedProperty', { get: function () { checkAccess.call(_self); return base.protectedProperty; }, set: function (value) { checkAccess.call(_self); _base.protectedProperty = value; }, enumerable: false, configurable: false }); }</span></span></code> </pre><br><h3>  Vererbungsbeschreibung </h3><br>  Und das Letzte, was ich kommentieren m√∂chte, ist die Vererbung von DerivedClass von BaseClass.  Wie Sie vielleicht wissen, ist DerivedClass.prototype = new BaseClass ();  erstellt nicht nur einen Prototyp, sondern schreibt auch seine Konstruktoreigenschaft neu.  Aus diesem Grund wird die Konstruktoreigenschaft f√ºr jede Instanz von DerivedClass gleich BaseClass.  Um dies zu beheben, schreiben Sie normalerweise nach dem Erstellen eines Prototyps die Konstruktoreigenschaft neu: <br><br><pre> <code class="javascript hljs">DerivedClass.prototype = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseClass(); DerivedClass.prototype.constructor = DerivedClass;</code> </pre><br>  Damit jedoch niemand diese Eigenschaft nach uns neu schreibt, verwenden wir dieselbe Object.defineProperty.  Die Eigenschaft configable: false verhindert, dass die Eigenschaft erneut √ºberschrieben wird: <br><br><pre> <code class="javascript hljs">DerivedClass.prototype = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseClass(); <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(DerivedClass.prototype, <span class="hljs-string"><span class="hljs-string">'constructor'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span> : DerivedClass, <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> });</code> </pre></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425521/">https://habr.com/ru/post/de425521/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425505/index.html">Analyse des Linux-Kernel-Boot-Prozesses</a></li>
<li><a href="../de425507/index.html">Parsim Wikipedia f√ºr NLP-Aufgaben in 4 Teams</a></li>
<li><a href="../de425511/index.html">Nicht offensichtliche Funktionen der Rotativa-Anwendung zum Generieren von PDF in der ASP.NET MVC-Anwendung</a></li>
<li><a href="../de425515/index.html">Apple blockiert die unabh√§ngige Reparatur neuer MacBook-Modelle</a></li>
<li><a href="../de425517/index.html">Wie Yandex mithilfe von Radar und Satelliten eine globale Niederschlagsvorhersage erstellte</a></li>
<li><a href="../de425525/index.html">Tim Berners-Lee geht auf den Kriegspfad: "Ein kleiner Schritt f√ºr das Web ..."</a></li>
<li><a href="../de425527/index.html">Listen bei Kotlin. Haskell Ansatz</a></li>
<li><a href="../de425529/index.html">Sans Forgetica: Eine Schriftart, mit der Sie sich das Gelesene etwas besser merken k√∂nnen</a></li>
<li><a href="../de425531/index.html">K√ºhlung der Fl√ºssigkeitsbremse. Systementwicklungsoptionen</a></li>
<li><a href="../de425533/index.html">So arbeiten Sie in der Cloud: von der √úberpr√ºfung der Zuverl√§ssigkeit eines Rechenzentrums bis zur Verwaltung einer virtuellen Infrastruktur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>