<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úåüèø ü¶ì üï∫üèº Desenvolvimento de um sintetizador de m√∫sica simples no ATMEGA8 ‚ö±Ô∏è ü§¨ ü§¥üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alguns anos atr√°s, fiz um despertador no microcontrolador ATmega8, onde implementei um sintetizador de melodia simples de tom √∫nico (voz √∫nica). Exist...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desenvolvimento de um sintetizador de m√∫sica simples no ATMEGA8</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454514/">  Alguns anos atr√°s, fiz um despertador no microcontrolador ATmega8, onde implementei um sintetizador de melodia simples de tom √∫nico (voz √∫nica).  Existem muitos artigos na Internet para iniciantes sobre esse t√≥pico.  Como regra, um temporizador de 16 bits √© usado para gerar a frequ√™ncia (notas), que √© configurada de uma certa maneira, for√ßando no n√≠vel do hardware a emitir um sinal na forma de um meandro em um pino espec√≠fico do MC.  O segundo temporizador (8 bits) √© usado para implementar a dura√ß√£o de uma nota ou pausa.  As notas de acordo com f√≥rmulas conhecidas s√£o comparadas com frequ√™ncias e, por sua vez, s√£o comparadas com certos n√∫meros de 16 bits, inversamente proporcionais √†s frequ√™ncias que especificam os per√≠odos de contagem do temporizador. <br><a name="habracut"></a><br>  No meu projeto, forneci tr√™s melodias que foram escritas na mesma chave e escala.  Portanto, tive que usar um n√∫mero limitado e determinado de notas, o que facilitou a modelagem.  Al√©m disso, todas as tr√™s m√∫sicas foram tocadas no mesmo ritmo.  O c√≥digo da nota e seu c√≥digo de dura√ß√£o cabem facilmente em um byte.  A √∫nica desvantagem desse modelo foi a falta de versatilidade, a capacidade de editar, substituir ou complementar rapidamente a melodia.  Para gravar uma melodia, primeiro a escrevi em um editor de m√∫sica em um computador, depois copiei as notas e a dura√ß√£o delas, com a numera√ß√£o que decidi previamente e, em seguida, formei os bytes resultantes.  Eu fiz as √∫ltimas opera√ß√µes usando o programa Excel. <br><br>  No futuro, eu queria eliminar a desvantagem acima mencionada, traindo o design com certa universalidade e reduzindo o tempo para implementar a melodia.  Havia uma id√©ia que o programa MK lia os bytes de um dos famosos formatos de m√∫sica.  O mais popular e comum √© o formato MIDI.  Mais literalmente, esse n√£o √© tanto o formato de uma ‚Äúci√™ncia‚Äù que pode ser lida na Internet.  A especifica√ß√£o MIDI define o protocolo para transmiss√£o de mensagens em tempo real pela interface f√≠sica correspondente e descreve como os arquivos midi s√£o organizados em que essas mensagens podem ser armazenadas.  O formato midi √© orientado para a m√∫sica e, portanto, encontra aplica√ß√£o no campo relevante.  Este √© um controle s√≠ncrono de equipamentos de som, m√∫sicas coloridas, sintetizadores musicais e rob√¥s, etc.  Na esfera dom√©stica, o formato midi foi encontrado na era do in√≠cio do desenvolvimento de telefones celulares.  Nesse caso, as mensagens sobre a inclus√£o ou desativa√ß√£o de uma nota espec√≠fica, informa√ß√µes sobre um instrumento musical, o volume das notas sonoras e assim por diante s√£o gravadas no arquivo midi.  O celular que reproduz esse arquivo cont√©m um sintetizador que interpreta as mensagens midi nesse arquivo em tempo real e toca a melodia.  Nos est√°gios iniciais, os telefones eram capazes de tocar apenas melodias de tom √∫nico.  Com o tempo, a chamada polifonia apareceu. <br><br>  Na Internet, conheci artigos sobre a implementa√ß√£o de um sintetizador polif√¥nico no MK, que l√™ arquivos midi.  Nesse caso, pelo menos, uma ‚Äútabela de ondas‚Äù pr√©-formada (uma lista de formas de ondas sonoras) √© usada para cada instrumento musical armazenado na mem√≥ria do MK.  E, no meu caso particular, focaremos na implementa√ß√£o de um modelo mais simples: um sintetizador de tom √∫nico (voz √∫nica). <br><br>  Para come√ßar, estudei cuidadosamente a estrutura do arquivo midi e conclu√≠ que, al√©m das informa√ß√µes necess√°rias sobre as notas, ele cont√©m informa√ß√µes redundantes adicionais.  Portanto, decidiu-se escrever um programa simples para converter um arquivo midi em seu pr√≥prio formato.  O programa, trabalhando com muitos arquivos MIDI, n√£o apenas converte formatos, mas tamb√©m os organiza de uma certa maneira.  Com anteced√™ncia, decidi organizar o armazenamento de muitas m√∫sicas na mem√≥ria ROM (EEPROM 24XX512).  Por conveni√™ncia de visualiza√ß√£o no editor HEX, certifiquei-me de que cada melodia comece do in√≠cio do setor.  Ao contr√°rio de um cart√£o SD (por exemplo), o conceito de setor n√£o √© aplic√°vel √† ROM usada, ent√£o eu me expresso condicionalmente.  O tamanho do setor √© de 512 bytes.  E o primeiro setor da ROM √© reservado para os endere√ßos dos setores do in√≠cio de cada melodia.  Sup√µe-se que a melodia pode demorar v√°rios setores. <br><br>  Uma descri√ß√£o completa do formato de arquivo midi, √© claro, n√£o vale a pena fazer aqui.  Vou abordar apenas os pontos mais necess√°rios e necess√°rios.  Um arquivo midi cont√©m 16 canais, que, em regra, geralmente correspondem a um ou outro instrumento musical.  No nosso caso, n√£o importa que tipo de instrumento seja, e apenas um canal √© necess√°rio.  O conte√∫do de cada canal, juntamente com o cabe√ßalho, √© elaborado em um arquivo midi, de acordo com um princ√≠pio muito semelhante √† organiza√ß√£o do armazenamento de fluxos de v√≠deo e √°udio em um cont√™iner AVI.  Eu escrevi sobre o √∫ltimo anteriormente em um dos meus artigos.  O cabe√ßalho do arquivo midi √© um conjunto de alguns par√¢metros.  Um desses par√¢metros √© a resolu√ß√£o do tempo.  √â expresso no n√∫mero de "ticks" (um tipo de pixel) por trimestre (PPQN).  Um quarto √© um per√≠odo de tempo durante o qual uma sem√≠nima √© tocada.  Dependendo do andamento da melodia, a dura√ß√£o do trimestre pode ser diferente.  Portanto, a dura√ß√£o de um "pixel" (per√≠odo de amostragem) depende do tempo e do PPQN.  Todas as informa√ß√µes sobre a hora de um evento s√£o determinadas com precis√£o nessa dura√ß√£o. <br><br>  Al√©m disso, o cabe√ßalho cont√©m o tipo de arquivo MIDI (tipo 0 ou tipo 1) e o n√∫mero de canais.  Sem entrar em detalhes, trabalharemos com o tipo 1, o n√∫mero de canais 2. Um arquivo midi com uma melodia de tom √∫nico, logicamente, cont√©m um canal.  Mas no arquivo midi do ‚Äútipo 1‚Äù, al√©m do principal, existe outro canal ‚Äún√£o musical‚Äù no qual s√£o gravadas informa√ß√µes adicionais que n√£o cont√™m notas.  Estes s√£o os chamados metadados.  Tamb√©m n√£o h√° necessidade de entrar em detalhes.  A √∫nica informa√ß√£o de que precisamos √© de informa√ß√µes sobre o ritmo e em um formato incomum: microssegundos por trimestre.  No futuro, ser√° mostrado como usar essas informa√ß√µes, juntamente com o PPQN, para configurar o timer MK, respons√°vel pelo andamento. <br><br>  No bloco principal do canal com notas, estamos interessados ‚Äã‚Äãapenas em informa√ß√µes sobre os eventos de ativar e desativar as notas.  Um evento de ativa√ß√£o de nota possui dois par√¢metros: n√∫mero e volume da nota.  No total, s√£o fornecidas 128 notas e 128 n√≠veis de volume.  Estamos interessados ‚Äã‚Äãapenas no primeiro par√¢metro, porque n√£o importa qual seja o volume da nota: todas as notas ao tocar a melodia MK soar√£o no mesmo volume.  E, √© claro, a melodia n√£o deve conter notas "overdubbed", ou seja, a qualquer momento, mais de uma nota n√£o deve soar ao mesmo tempo.  O c√≥digo do evento de obten√ß√£o (ativa√ß√£o) das anota√ß√µes √© 0x90.  O c√≥digo do evento de anota√ß√£o √© 0x80.  No entanto, pelo menos o editor Cakewalk Pro Audio 9 n√£o usa o evento com o c√≥digo 0x80 ao exportar a composi√ß√£o para o formato midi.  Em vez disso, o evento 0x90 ocorre em toda a parte musical e a nota de que a nota est√° desativada √© seu volume zero.  Ou seja, o evento "desativar a nota" √© equivalente ao evento "ativar a nota com volume zero".  Talvez isso seja feito por raz√µes de economia.  De acordo com a especifica√ß√£o, o c√≥digo do evento n√£o pode ser reescrito se esse evento for repetido.  Entre os eventos, as informa√ß√µes sobre o intervalo de tempo s√£o registradas em um formato de tamanho vari√°vel.  Estes s√£o os valores inteiros do n√∫mero de "ticks" mencionados acima.  Na maioria das vezes, um byte √© suficiente para registrar o intervalo de tempo.  Se dois eventos seguem um ap√≥s o outro, ent√£o entre eles o intervalo de tempo √© obviamente igual a zero.  Isso, por exemplo, desativa a primeira e a inclus√£o da segunda nota a seguir, se n√£o houver pausa (espa√ßo) entre elas. <br><br>  Vamos tentar escrever uma sequ√™ncia de notas usando o programa "Cakewalk Pro Audio 9".  Existem muitos editores, mas eu decidi pelo primeiro que apareceu. <br><br><img src="https://habrastorage.org/webt/x2/rs/ig/x2rsigockegfkqq_xux3wgiesly.png"><br><br>  Primeiro, voc√™ precisa definir as configura√ß√µes do projeto.  Neste editor, voc√™ pode definir a resolu√ß√£o no tempo (PPQN).  Eu escolho o valor m√≠nimo igual a 48. Um valor muito grande n√£o faz sentido, pois voc√™ precisa trabalhar com n√∫meros grandes que excedam 1 byte de tamanho.  Mas o valor m√≠nimo de 48 √© bastante satisfat√≥rio.  Em quase todas as melodias, notas menores que 1/32 n√£o s√£o encontradas.  E se o n√∫mero de "ticks" por trimestre for 48, a nota ou pausa 1/32 ter√° uma dura√ß√£o de 48 / (32/4) = 6 "ticks".  Ou seja, existe a possibilidade te√≥rica de dividir completamente a nota 1/32 por 2 e at√© por 3. Deixamos os par√¢metros restantes na janela de propriedades do projeto por padr√£o. <br><br><img src="https://habrastorage.org/webt/q-/e8/1j/q-e81jrcz7-g-doa-oberdoezju.png"><br><br>  Em seguida, abra a propriedade da primeira faixa e atribua a ele um n√∫mero de canal igual a 1. A seu gosto, selecione um patch que corresponda a um instrumento musical ao tocar uma melodia no editor.  O n√∫mero do patch, √© claro, n√£o afetar√° o resultado final. <br><br><img src="https://habrastorage.org/webt/y-/2o/xn/y-2oxnmqemoxj3hwtflnanivyyk.png"><br><br>  O andamento da melodia √© definido no n√∫mero de quartos por minuto na barra de ferramentas do editor.  O valor do andamento padr√£o √© 100 bpm. <br><br>  O microcontrolador possui um timer de 8 bits, que, como j√° mencionado, ser√° usado para controlar a dura√ß√£o das notas e pausas no som.  Foi decidido que o intervalo de tempo entre opera√ß√µes adjacentes (interrup√ß√µes) de um cron√¥metro corresponderia ao intervalo de um ‚Äútique‚Äù.  Dependendo do andamento da melodia, o valor desse intervalo de tempo ser√° diferente.  Eu decidi usar interrup√ß√µes do temporizador de estouro.  E, dependendo do par√¢metro de inicializa√ß√£o do temporizador inicial, √© poss√≠vel ajustar esse mesmo intervalo de tempo, que depende do andamento da melodia.  Agora vamos aos c√°lculos. <br><br>  Como regra, na pr√°tica, em m√©dia, o andamento das m√∫sicas fica na ordem de 50 a 200. J√° foi dito que o andamento no arquivo midi √© definido em microssegundos em um quarto.  Para o tempo 50, esse valor √© 60.000.000 / 50 = 1.200.000 e para o tempo 250 ser√° 240.000. Como, de acordo com o projeto, um quarto cont√©m 48 ticks, a dura√ß√£o do tick para o andamento m√≠nimo ser√° 1.200.000 / 48 = 25.000 Œºs.  E para o ritmo m√°ximo, se voc√™ calcular da mesma maneira, - 5000 Œºs.  Para MK com uma frequ√™ncia de quartzo de 8 MHz e um divisor de timer preliminar m√°ximo de 1024, obtemos o seguinte.  Para o ritmo m√≠nimo, o temporizador precisa ser calculado 25000 / (1024/8) = 195 vezes.  O resultado √© arredondado para o valor inteiro mais pr√≥ximo, o erro de arredondamento praticamente n√£o afeta o resultado.  Para o ritmo m√°ximo - 5000 / (1024/8) = 39.  Aqui, o erro de arredondamento n√£o afeta mais, pois tamb√©m √© obtido um valor arredondado de 39 para valores de tempo vizinhos de 248 a 253. Portanto, o temporizador deve ser inicializado com um valor inverso: para o tempo m√≠nimo - (256-195) = 61 e para o m√°ximo - (256 -39) = 217.  O ritmo m√≠nimo no qual o timer ser√° fornecido na configura√ß√£o atual do MK √© de 39 bpm.  Com este valor, o temporizador deve ser contado 250 vezes.  E com um valor de 38 - j√° 257, que ultrapassa os limites do temporizador.  Decidi pegar o valor de 40 bpm no ritmo m√≠nimo e 240 no m√°ximo. <br><br>  Para calcular o n√∫mero de ticks, um temporizador virtual baseado no precedente ser√° usado.  √â o n√∫mero de ticks que define a dura√ß√£o de uma nota ou pausa, como j√° mencionado acima. <br><br>  Para implementar a reprodu√ß√£o de notas, um segundo temporizador de 16 bits √© usado.  De acordo com a especifica√ß√£o MIDI, s√£o fornecidas 128 notas.  Mas, na pr√°tica, eles s√£o usados ‚Äã‚Äãmuito menos.  Al√©m disso, as notas das oitavas mais baixa (com frequ√™ncias de cerca de 50 Hz) e mais alta (com frequ√™ncias de cerca de 8 kHz) n√£o ser√£o reproduzidas harmoniosamente pelo microcontrolador.  Mas, por tudo isso, um timer de 16 bits com um divisor fixo cobre quase toda a gama de notas fornecidas pelo midi, ou seja, sem as primeiras 35.  Mas eu escolhi como in√≠cio a nota com o n√∫mero 37 (seu c√≥digo √© 36, pois a codifica√ß√£o vem do zero).  Isso √© feito por conveni√™ncia, pois esse n√∫mero corresponde √† nota ‚ÄúC‚Äù, como a primeira nota em uma escala tradicional.  Corresponde a ele com uma frequ√™ncia de 65,4 Hz e o meio-ciclo √© - 1 / 65,4 / 2 = 0,00764 seg.  Esse per√≠odo com uma frequ√™ncia MK de 8 MHz e um divisor 1 (ou seja, sem divisor) contar√° o cron√¥metro aproximadamente como um todo por 0,00764 / (1/8000000) = 61156 vezes.  Para a 35¬™ nota, se voc√™ contar, esse valor ser√° 68645, que est√° al√©m do intervalo do timer de 16 bits.  Mas, mesmo que houvesse a necessidade de tocar notas abaixo do 36¬∫, voc√™ pode inserir o primeiro divisor de timer dispon√≠vel, igual a 8. Mas n√£o h√° necessidade pr√°tica disso, assim como n√£o h√° nem mesmo para tocar as notas mais altas.  No entanto, para a 128¬™ nota mais alta, nota ‚ÄúG‚Äù com uma frequ√™ncia de 12.543,85 Hz, o valor do temporizador √©, se contado de maneira semelhante, 319. As especifica√ß√µes de todos os c√°lculos acima s√£o determinadas pela configura√ß√£o espec√≠fica do modo de temporizador, que ser√° mostrado posteriormente. <br><br>  Agora, tenho uma pergunta n√£o menos importante: como obter a rela√ß√£o entre o n√∫mero da nota e o c√≥digo do temporizador?  Existe uma f√≥rmula conhecida para calcular a frequ√™ncia de uma nota pelo seu n√∫mero.  E o c√≥digo do temporizador para uma frequ√™ncia conhecida √© calculado facilmente, como mostrado acima nos exemplos.  Mas a raiz do 12¬∫ grau aparece na f√≥rmula da depend√™ncia da frequ√™ncia na nota e, em geral, eu n√£o gostaria de carregar o controlador com tais procedimentos computacionais.  Por outro lado, a cria√ß√£o de uma matriz de c√≥digos de timer para todas as notas tamb√©m n√£o √© racional.  E eu decidi fazer o seguinte, escolhendo um meio termo.  Basta criar uma s√©rie de c√≥digos de timer para as 12 primeiras notas, que s√£o uma oitava.  E as notas das oitavas a seguir devem ser obtidas multiplicando sequencialmente as frequ√™ncias das notas da primeira oitava por 2. Ou, a mesma coisa, dividindo sequencialmente os valores dos c√≥digos do temporizador por 2. Outra conveni√™ncia √© que o n√∫mero da oitava, por coincid√™ncia, √© um argumento na opera√ß√£o de mudan√ßa de bit para a direita ( ¬ª), Que ser√° usado como opera√ß√£o de divis√£o por pot√™ncias de dois.  Escolhi esse operador n√£o por acaso, pois seu argumento reflete o expoente do poder do divisor (o n√∫mero de divis√µes por 2).  E este √© o n√∫mero da oitava.  Para o meu conjunto de notas, um total de 8 oitavas est√° envolvido (a √∫ltima oitava est√° incompleta).  Uma nota em um arquivo midi √© codificada com um byte, mais precisamente, 7 bits.  Para reproduzir notas no MK, de acordo com a id√©ia acima, voc√™ deve primeiro calcular o n√∫mero da oitava e o n√∫mero da nota na oitava usando o c√≥digo da nota.  Esta opera√ß√£o √© realizada no est√°gio de convers√£o do arquivo midi para um formato simplificado.  Oito oitavas podem ser codificadas em tr√™s bits e 12 notas em uma oitava podem ser codificadas em quatro.  No total, verifica-se que a nota √© codificada nos mesmos sete bits que no arquivo midi, mas apenas em uma representa√ß√£o diferente, conveniente para o MK.  Devido ao fato de que 16 bits podem ser codificados com 4 bits e notas em uma oitava de 12, existem bytes n√£o utilizados. <br><br>  O √∫ltimo oitavo bit pode ser usado como um marcador para ativar ou desativar as notas.  No caso de MK, devido √† unanimidade da melodia, as informa√ß√µes sobre a nota silenciada ser√£o redundantes.  Com uma mudan√ßa direta de nota na melodia, n√£o h√° um "desligar-ligar-ligar", mas um "interruptor" da nota.  E no caso de uma pausa, ‚Äúo sil√™ncio est√° ativado‚Äù, para o qual voc√™ pode selecionar um byte especial do conjunto de bytes n√£o utilizados e n√£o usar as informa√ß√µes sobre como desativar a nota.  Essa ideia √© boa, pois salva o tamanho da melodia resultante ap√≥s a convers√£o, mas geralmente complica o modelo.  N√£o segui essa ideia, pois j√° h√° bastante mem√≥ria. <br><br>  As informa√ß√µes sobre as notas da melodia no arquivo midi s√£o armazenadas no bloco do canal correspondente na exibi√ß√£o "interval-event-interval-event ...".  No formato convertido, exatamente o mesmo princ√≠pio se aplica.  Para gravar um evento (ativar ou desativar uma nota), como mencionado acima, um byte √© usado.  O primeiro bit (o bit mais significativo 7) codifica o tipo de evento.  O valor "1" √© a nota ativada e o valor "0" √© a nota desativada.  Os pr√≥ximos tr√™s bits codificam o n√∫mero da oitava e os quatro bits mais baixos codificam o n√∫mero da nota na oitava.  Um byte tamb√©m √© usado para registrar o intervalo de tempo.  No formato midi original, √© usado um formato de tamanho vari√°vel.  Sua pequena desvantagem √© que apenas 7 bits codificam o intervalo de tempo (o n√∫mero de "ticks"), e o oitavo bit √© um sinal de continua√ß√£o.  Ou seja, com um byte, na verdade, voc√™ pode codificar um intervalo de at√© 128 ticks.  Mas como os intervalos de tempo entre eventos em melodias reais e simples √†s vezes excedem 128, mas quase nunca excedem 256, abandonei o formato de tamanho vari√°vel e custou um byte.  Ele codifica um intervalo de tempo de at√© 256 ticks.  Como o projeto usa 48 ticks por trimestre ou 48 * 4 = 192 ticks por ciclo, um byte pode ser usado para codificar um intervalo de 256/192 = 1 dura√ß√£o. (3) (um todo e um ter√ßo) ciclos, que bastante. <br><br>  No formato nativo para o qual o arquivo midi √© convertido, tamb√©m apliquei um cabe√ßalho pequeno, com 16 bytes de tamanho.  Os primeiros 14 bytes cont√™m o nome da melodia.  Naturalmente, o nome n√£o deve exceder 14 caracteres.  Ent√£o vem um espa√ßo zero.  O pr√≥ximo √∫ltimo byte reflete o andamento da melodia em uma exibi√ß√£o conveniente para o MK.  Este valor √© calculado no est√°gio de convers√£o e serve para inicializar o timer MK, respons√°vel pelo ritmo.  Como √© calculado √© discutido em alguns par√°grafos acima. <br><br>  A partir do 17¬∫ byte, o conte√∫do da melodia segue.  Cada byte √≠mpar corresponde a um intervalo de tempo e cada byte par corresponde a um evento (nota).<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O primeiro byte ser√° zero se a melodia come√ßar com uma nota, desde o in√≠cio do arquivo midi, sem uma pausa preliminar. Um sinal do final da melodia √© um r√≥tulo de dois bytes 0xFF. A tarefa envolve a reprodu√ß√£o c√≠clica de uma melodia por um microcontrolador. Para que a melodia no loop pare√ßa harmoniosa do ponto de vista do ritmo, ela deve ser repetida corretamente. Para fazer isso, se necess√°rio, ap√≥s uma √∫ltima nota, voc√™ precisar√° pausar um determinado comprimento, geralmente at√© que a √∫ltima medida seja preenchida. E para isso voc√™ precisa desviar o evento correspondente. Eu usei o byte 0x0F, que n√£o √© usado nas notas de codifica√ß√£o. Corresponde a desabilitar a 16¬™ nota na primeira oitava, o que √© um absurdo, uma vez que existem apenas 12 notas na oitava mencionamos acima sobre bytes n√£o utilizados. Assim, esse byte codifica uma "nota silenciosa",o bit alto tamb√©m pode servir como sinal de ativa√ß√£o ou desativa√ß√£o, apesar da redund√¢ncia de informa√ß√µes tamb√©m neste caso. Para definir esta nota no editor midi, tirei a primeira ou a segunda nota (qualquer uma delas). Deixe-me lembr√°-lo de que as primeiras 36 notas n√£o s√£o usadas no modelo. Assim, a primeira (ou segunda) nota √© usada conforme necess√°rio para a conclus√£o correta da melodia, de modo que o ritmo n√£o seja interrompido ao toc√°-la em um loop.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Continuando a trabalhar no editor do "Cakewalk Pro Audio 9", comporemos uma melodia arbitr√°ria. As figuras abaixo mostram as notas da melodia que reescrevi de uma das fotos na Internet. Imagens de notas s√£o apresentadas em dois estilos: no estilo "Piano roll" e no estilo cl√°ssico. O primeiro √© muito conveniente para escrever e editar melodias usando um mouse de computador. √â isso que eu uso. </font></font><br><br><img src="https://habrastorage.org/webt/lr/-r/hy/lr-rhyphwp5xckftmq8fbwhlchc.png"><br><br><img src="https://habrastorage.org/webt/ot/qf/d7/otqfd7db-6wj0o9dscmg60tp5d8.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como voc√™ pode ver na figura, no final, a nota mais baixa (primeira) √© aplicada ao sinal de sil√™ncio no intervalo de tempo certo para organizar corretamente o padr√£o c√≠clico. E no in√≠cio da melodia, em vista da presen√ßa de um toque, h√° um quarto de recuo antes da primeira nota. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O editor fornece um modo para exibir eventos em forma de tabela.</font></font><br><br><img src="https://habrastorage.org/webt/vy/gu/n1/vygun1nauiacc6-zjbq66whb7qg.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como voc√™ pode ver na figura, n√£o h√° nada sup√©rfluo na lista de eventos, exceto as anota√ß√µes, como √†s vezes acontece com manipula√ß√µes desnecess√°rias em um projeto musical. Se, no entanto, eventos desnecess√°rios que n√£o est√£o relacionados √†s notas estiverem inclu√≠dos por alguma raz√£o na lista, eles poder√£o ser exclu√≠dos pressionando a tecla Del. Embora, no est√°gio de convers√£o, todos os eventos desnecess√°rios sejam ignorados e o tempo delta "se acumule". A prop√≥sito, eu adicionei essa fun√ß√£o ao programa no est√°gio de depura√ß√£o. Como voc√™ pode imaginar, a tabela reflete o prazo e a dura√ß√£o de cada nota, al√©m de outras propriedades que n√£o precisamos. Ou seja, com uma linha na tabela, dois eventos midi s√£o expressos ao mesmo tempo: ativar e desativar notas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salve a melodia no formato ‚Äúmidi 1‚Äù, como mostra a figura.</font></font><br><br><img src="https://habrastorage.org/webt/l6/gx/uf/l6gxufg_2kmfge81godpmmhieki.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abra o arquivo salvo no editor HEX. Deve-se notar imediatamente que, diferentemente dos mesmos arquivos avi (como escrevi anteriormente), bytes de valores num√©ricos em um arquivo midi s√£o apresentados n√£o na ordem inversa, mas de acordo com a antiguidade (big endian).</font></font><br><br><img src="https://habrastorage.org/webt/wj/oi/cn/wjoicnlzwx4ixajswxz3m3_jj5i.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na figura, marquei com marcadores apenas os bytes desejados. Primeiro, uma moldura vermelha em negrito descreve tr√™s grupos de dois bytes em cada um. Este √©, respectivamente, o tipo de formato MIDI (1), o n√∫mero de canais (2) e o n√∫mero de ticks por trimestre (48). S√£o esses valores que essas tr√™s constantes devem ter para o trabalho adicional do programa de transforma√ß√£o. Arcos roxos marcam o in√≠cio de cada um dos dois canais. No primeiro canal, 6 bytes s√£o marcados com uma moldura cinza, dentro da qual tr√™s bytes s√£o real√ßados com uma moldura azul. Esses 6 bytes referem-se a um meta evento (marcador 0xFF) com um c√≥digo de 0x51 e um comprimento de conte√∫do de 0x03 bytes. Tr√™s bytes a mais - o conte√∫do do evento. Este evento define o andamento da melodia com apenas esses tr√™s bytes em um quadro azul. O √∫ltimo byte baixo pode ser descartado com seguran√ßa, porque a super precis√£o n√£o √© importante. N√£o darei uma descri√ß√£o detalhada e completa de todos os bytes no arquivo.Na segunda faixa - na faixa com notas - os valores dos intervalos de tempo s√£o circulados em uma moldura azul. A prop√≥sito, neste exemplo em particular, eles n√£o excederam um byte, exceto o √∫nico caso com a pen√∫ltima nota. √â a pen√∫ltima nota da melodia (contando a pseudo nota extra do final) que dura tr√™s quartos de uma medida, que √© 48 * 3 = 144 tiques e excede 128. E √© para isso que voc√™ precisa usar dois bytes, de acordo com o formato de tamanho vari√°vel. E para representar o intervalo de tempo no formato convertido, o valor 144 √© facilmente codificado com um byte. Eu circulei este caso especial em uma moldura azul dupla. As notas s√£o circuladas em uma moldura verde, ou melhor, seus c√≥digos. O volume de cada nota √© circulado em uma moldura cinza. Como j√° mencionado, um volume zero √© um sinal de mudo (libera√ß√£o) da nota e, em toda a composi√ß√£o, h√° um evento:ligar as notas. O c√≥digo para este evento, 0x90, est√° marcado em amarelo. N√£o esbocei todas as notas at√© o final da melodia. A √∫nica exce√ß√£o √© o quadro azul duplo por um √∫nico intervalo de tempo que excede o limite de 128 ticks.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Novamente, como mencionado acima, o programa para converter um arquivo midi em seu pr√≥prio formato para o MK realmente funciona com um grupo de v√°rios arquivos midi e, na sa√≠da, cria um arquivo de imagem para a EEPROM. Considere um fragmento deste arquivo relacionado ao conte√∫do da melodia convertida do exemplo acima. Abri em outro editor HEX para mostrar a imagem por setores e prestar aten√ß√£o nela. Cada nova melodia come√ßa com um novo setor.</font></font><br><br><img src="https://habrastorage.org/webt/9p/e5/h1/9pe5h1qaetdg-kjk-abaxvlk6am.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O √∫ltimo byte da primeira linha (os primeiros 16 bytes), circulado em uma moldura vermelha, define o andamento da melodia. De acordo com os c√°lculos, o valor 0xC1 (193) cai nos tempos 154, 155 e 156. Apenas no projeto, defino o tempo da melodia para 155 bpm, o que foi visto em uma das capturas de tela anteriores. Os primeiros bytes (at√© o dia 14) circulados em uma moldura azul determinam o nome da composi√ß√£o. Neste exemplo, "Cl√°ssico". Para o MK, essas informa√ß√µes s√£o desnecess√°rias, s√£o necess√°rias apenas para orienta√ß√£o no editor HEX. Embora, se voc√™ fizer um projeto mais complexo no MK usando o display, poder√° usar essas informa√ß√µes exibindo o nome da melodia tocada.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A segunda linha (do 17¬∫ byte) inicia o conte√∫do da melodia. Como no arquivo midi original, n√£o pintei todas as notas, mas pintei apenas uma parte. Os bytes √≠mpares destacados em azul s√£o intervalos de tempo. At√© os bytes marcados com uma moldura verde s√£o notas e sinais de ativa√ß√£o / desativa√ß√£o. Por exemplo, os dois primeiros bytes verdes, 0xB4 e 0x34, referem-se √† mesma nota com o c√≥digo 0x34, e os bytes diferem em apenas um bit de ordem superior. No byte 0xB4 (0b10110100), o bit alto √© um, que √© um sinal de ativar uma nota, e no byte 0x34 (0b00110100), o bit alto √© zero, que √© um sinal para desativar uma nota. O byte 0x34 codificou uma nota com os seguintes par√¢metros: c√≥digo de oitava 0b011 e o c√≥digo de nota em uma oitava - 0b0100. Ou, na forma decimal, 3 e 4, respectivamente. Se voc√™ n√£o contar a partir de zero,acontece que a primeira nota na melodia pertence √† quarta oitava e √© a quinta nela. A numera√ß√£o de oitavas aqui √© escolhida arbitrariamente, sem levar em considera√ß√£o a numera√ß√£o padr√£o. A nota acordada, de acordo com minha tabela auxiliar de c√°lculo Excel, √© a nota com o c√≥digo 76 (0x4C) para o formato midi, ou seja, a nota E6 (nota ‚Äúe‚Äù da 6¬™ oitava do meio). Assim √©: a composi√ß√£o come√ßa com esta nota.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deve-se notar um caso especial na sequ√™ncia musical, quando a mesma nota √© repetida sem pausa. No nosso exemplo, todas as notas adjacentes sem pausa s√£o diferentes. Mas h√° melodias em que a nota se repete sem pausa. Ou seja, o intervalo de tempo entre desligar uma e ativar a pr√≥xima nota exata √© zero. Em vista da peculiaridade de uma s√≠ntese complexa da m√∫sica, essa sequ√™ncia soa familiar em qualquer sintetizador. Mas, no caso do MK, parecer√° t√£o coeso que ser√° dif√≠cil ouvir a diferen√ßa entre duas notas id√™nticas. Na pr√°tica, √© claro, n√£o haver√° uma fus√£o clara devido aos c√°lculos intermedi√°rios que ocorrem no MC, mas, ainda assim, esse intervalo de tempo provavelmente ser√° muito menor do que a dura√ß√£o de um √∫nico tick. Para casos especiais, o programa est√° na fase de convers√£o,esbarrar nessa combina√ß√£o, introduz uma pausa entre as notas de 1 tiquetaque e reduz a dura√ß√£o de uma nota √† esquerda da mesma no mesmo intervalo de tempo. Uma ‚Äúdiferen√ßa‚Äù m√≠nima de 1 tick √© suficiente, como a pr√°tica demonstrou.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em um quadro azul duplo, circulei o valor do intervalo de tempo (0x90), que excede 128, e pelo qual tive que gastar dois bytes no arquivo midi, de acordo com o formato de tamanho vari√°vel. C√≠rculos verdes s√£o bytes circulados dentro e fora da mesma pseudo nota para alinhar a composi√ß√£o. O programa MK, ao ver esses bytes, os interpretar√° como ativando o sil√™ncio. Por fim, dois bytes 0xFF rodeados por uma moldura azul em negrito marcam o final da melodia. Os valores de todos os seguintes bytes no setor de mem√≥ria atual podem ser quaisquer, eles s√£o ignorados.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Considere o primeiro setor do arquivo de imagem EEPROM de sa√≠da. Como j√° escrevi, serve como uma lista de endere√ßos de setores do come√ßo de melodias. O programa varreu com sucesso 8 m√∫sicas sem erros (no momento em que escrevi, eu gravei 8 m√∫sicas). O valor do n√∫mero de melodias √© registrado no √∫ltimo 512¬∫ byte do setor. E desde o in√≠cio do setor, os endere√ßos s√£o escritos. Para a primeira melodia, o endere√ßo √© 0x01, que corresponde ao segundo setor (o primeiro, se voc√™ contar do zero). A terceira e quarta melodias (duas de oito) acabaram sendo longas e n√£o se encaixavam em um setor. Portanto, s√£o observadas lacunas na sequ√™ncia de endere√ßos. Se voc√™ contar 64kB de mem√≥ria, n√£o poder√° gravar mais de 127 m√∫sicas; portanto, um setor para endere√ßamento √© suficiente.</font></font><br><br><img src="https://habrastorage.org/webt/t7/fm/g-/t7fmg-97qcqphlojly3l8xcpnru.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todas as estimativas e c√°lculos preliminares refletidos no artigo, eu realizei no Excel. </font><font style="vertical-align: inherit;">As capturas de tela abaixo mostram capturas de tela das tabelas resultantes (no modo de janela dupla). </font></font><br><br><img src="https://habrastorage.org/webt/31/cb/my/31cbmycwzmmfr_noks7sifxpaps.png"><br><br><img src="https://habrastorage.org/webt/jn/tm/1f/jntm1fp2sga5erx_xmtqq3bbhcy.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quem se importa, abaixo do spoiler, est√° o texto de um programa em C que converte arquivos midi em um arquivo para o microcontrolador. </font><font style="vertical-align: inherit;">Do texto, removi as linhas extras usadas para depura√ß√£o. </font><font style="vertical-align: inherit;">O programa, at√© o momento, est√° funcionando, n√£o pretende ser leg√≠vel e instru√≠do em escrever c√≥digo.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arquivo principal 1.cpp</font></font></b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;windows.h&gt; #include &lt;string.h&gt; #define SPACE 1 HANDLE openInputFile(const char * filename) { return CreateFile ( filename, // Open Two.txt. GENERIC_READ, // Open for writing 0, // Do not share NULL, // No security OPEN_ALWAYS, // Open or create FILE_ATTRIBUTE_NORMAL, // Normal file NULL); // No template file } HANDLE openOutputFile(const char * filename) { return CreateFile ( filename, // Open Two.txt. GENERIC_WRITE, // Open for writing 0, // Do not share NULL, // No security OPEN_ALWAYS, // Open or create FILE_ATTRIBUTE_NORMAL, // Normal file NULL); // No template file } void filepos(HANDLE f, unsigned int p){ LONG LPos; LPos = p; SetFilePointer (f, LPos, NULL, FILE_BEGIN); //FILE_CURRENT //https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-setfilepointer } DWORD wr; DWORD ww; unsigned long int read32(HANDLE f){ unsigned char b3,b2,b1,b0; ReadFile(f, &amp;b3, 1, &amp;wr, NULL); ReadFile(f, &amp;b2, 1, &amp;wr, NULL); ReadFile(f, &amp;b1, 1, &amp;wr, NULL); ReadFile(f, &amp;b0, 1, &amp;wr, NULL); return b3&lt;&lt;24|b2&lt;&lt;16|b1&lt;&lt;8|b0; } unsigned long int read24(HANDLE f){ unsigned char b2,b1,b0; ReadFile(f, &amp;b2, 1, &amp;wr, NULL); ReadFile(f, &amp;b1, 1, &amp;wr, NULL); ReadFile(f, &amp;b0, 1, &amp;wr, NULL); return b2&lt;&lt;16|b1&lt;&lt;8|b0; } unsigned int read16(HANDLE f){ unsigned char b1,b0; ReadFile(f, &amp;b1, 1, &amp;wr, NULL); ReadFile(f, &amp;b0, 1, &amp;wr, NULL); return b1&lt;&lt;8|b0; } unsigned char read8(HANDLE f){ unsigned char b0; ReadFile(f, &amp;b0, 1, &amp;wr, NULL); return b0; } void message(unsigned char e){ printf("Error %d: ",e); switch(e){ case 1: // -   -; printf("In track0 event is not FF\n"); break; case 2: // -  127 printf("Len of FF &gt;127\n"); break; case 3: //  ; printf("Midi is incorrect\n"); break; case 4: //   ; printf("Delta&gt;255\n"); break; case 5: //    RPN  NRPN; printf("RPN or NRPN is detected\n"); break; case 6: //   ; printf("Note in 1...35 range\n"); break; case 7: //    ; printf("Long of name of midi file &gt;18\n"); break; } system("PAUSE"); } int main(){ HANDLE in; HANDLE out; unsigned int i,j; unsigned int inpos; unsigned int outpos=0; unsigned char byte; // ; unsigned char byte1; //  1  ; unsigned char byte2; //  2  ; unsigned char status; //- ( ); unsigned char sz0; // -; unsigned long int bsz0; //    -; unsigned short int format, ntrks, ppqn; //  ; unsigned long int bsz1; //    ; unsigned long int bpm; // ( .  ); unsigned long int time=0; //    ( ); unsigned char scale; //    ,  ; unsigned char oct; //    ; unsigned char nt; // ; unsigned char outnote; //      ; unsigned char prnote=0; //  ; unsigned char tdt; // ()   ; unsigned int dt; //    ( ); unsigned int outdelta=0; //    ( ); unsigned char prdelta=0; //  ; char fullname[30]; //    ; char name[16]; // ; WIN32_FIND_DATA fld; //   mid; HANDLE hf; unsigned short int csz; //  ; unsigned char nfile=0; // ; unsigned char adr[128]; //    ; out=openOutputFile("IMAGE.out"); outpos=512; //   ; filepos(out,outpos); hf=FindFirstFile(".\\midi\\*.mid",&amp;fld); do{ printf("\n***** %s *****\n",fld.cFileName); if(strlen(fld.cFileName)&gt;18){ //   ; message(7); } sprintf(name,"%s",fld.cFileName); name[strlen(fld.cFileName)-4]=0; // ; sprintf(fullname,".\\midi\\%s",fld.cFileName); //    ; WriteFile(out, name, strlen(name), &amp;ww, NULL); //    ; in=openInputFile(fullname); //    ; #include "process.cpp" //     ; outpos+=((csz/512)+1)*512; //    ; adr[nfile]=(outpos/512)-((csz/512)+1); //  ()   ; filepos(out,outpos); CloseHandle(in); nfile+=1; }while(FindNextFile(hf,&amp;fld)); //   ,    ; FindClose(hf); WriteFile(out, &amp;outnote, 1, &amp;ww, NULL); outpos=0; //   ; filepos(out,outpos); WriteFile(out, adr, nfile, &amp;ww, NULL); outpos=511; //  ; filepos(out,outpos); WriteFile(out, &amp;nfile, 1, &amp;ww, NULL); CloseHandle(out); system("PAUSE"); return 0; }</span></span></span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Anexo do arquivo Process.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs">time=<span class="hljs-number"><span class="hljs-number">0</span></span>; inpos=<span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ; filepos(in,inpos); format=read16(in); ntrks=read16(in); ppqn=read16(in); if(format!=1 || ntrks!=2 || ppqn!=48){ message(3); } inpos+=10; filepos(in,inpos); //    -; bsz0=read32(in); inpos+=4; while(inpos&lt;22+bsz0){ //      ; tdt=read8(in); inpos+=1; //   ; dt=(unsigned int)(tdt&amp;0x7F); while(tdt&amp;0x80){ tdt=read8(in); inpos+=1; dt=(dt&lt;&lt;7)|(tdt&amp;0x7F); } byte=read8(in); inpos+=1; if(byte==0xFF){ //  ,  -    -; byte=read8(in); //  -; sz0=read8(in); //  , ,     127 ( ); if(sz0&amp;0x80){ message(2); } inpos+=2; switch(byte){ case 0x51: //   "Set Tempo"; bpm=read24(in); scale=256-(bpm/(ppqn*128)); printf("scale=%d\n",scale); filepos(out,outpos+15); // ; WriteFile(out, &amp;scale, 1, &amp;ww, NULL); csz=16; break; default: break; } inpos+=sz0; filepos(in,inpos); // ,     0x51; }else{ message(1); } } //    ; outdelta=0; inpos+=4; filepos(in,inpos); bsz1=read32(in); inpos+=4; while(inpos&lt;30+bsz0+bsz1){ tdt=read8(in); inpos+=1; //   ; dt=(unsigned int)(tdt&amp;0x7F); while(tdt&amp;0x80){ tdt=read8(in); inpos+=1; dt=(dt&lt;&lt;7)|(tdt&amp;0x7F); } outdelta+=dt; //  ; // ,      , ; time+=dt; //  ; byte=read8(in); //    ,  ; inpos+=1; if(byte&amp;0x80){ //  ; status=byte; // ; if(byte==0xFF){ //   -; byte=read8(in); //    ,    ; sz0=read8(in); inpos+=(2+sz0); filepos(in,inpos); }else{ //    ; byte1=read8(in); inpos+=1; } }else{ //    ,        ; byte1=byte; } switch(status&amp;0xF0){ // ,      ; case 0xF0: //   ,  -; break; case 0x80: // ; byte2=read8(in); //     ( ); inpos+=1; //     ,    ; if(byte1&gt;1&amp;&amp;byte1&lt;36){ //         ; message(6); } if(byte1&gt;1){ // ; oct=((byte1-36)/12); //  ; nt=(byte1-36)%12; //    ; }else{ //   ; oct=0; nt=15; } outnote=(oct&lt;&lt;4)|nt; //  ; prnote=outnote; prdelta=outdelta; if(outdelta&gt;255){ //     255 (  ); message(4); } WriteFile(out, &amp;outdelta, 1, &amp;ww, NULL); WriteFile(out, &amp;outnote, 1, &amp;ww, NULL); csz+=2; outdelta=0; //  ; break; case 0x90: //   ; byte2=read8(in); //    ( ); inpos+=1; //     ,    ; if(byte1&gt;1&amp;&amp;byte1&lt;36){ //         ; message(6); } if(byte1&gt;1){ // ; oct=((byte1-36)/12); //  ; nt=(byte1-36)%12; //    ; }else{ //   ; oct=0; nt=15; } if(byte2){ //  ,   ; outnote=0x80|(oct&lt;&lt;4)|nt; //  = 1; //   ; if(!outdelta &amp;&amp; (outnote&amp;0x7F)==prnote){ //     ; prdelta-=SPACE; // -; filepos(out,outpos+csz-2); //    ; WriteFile(out, &amp;prdelta, 1, &amp;ww, NULL); // ; filepos(out,outpos+csz); outdelta=SPACE; //  -  ; } }else{ //  ,    ; outnote=(oct&lt;&lt;4)|nt; prnote=outnote; //  ; prdelta=outdelta; //  -; } if(outdelta&gt;255){ //   -    ; message(4); } WriteFile(out, &amp;outdelta, 1, &amp;ww, NULL); WriteFile(out, &amp;outnote, 1, &amp;ww, NULL); csz+=2; outdelta=0; // -   ; break; //   () ; case 0xA0: // ; byte2=read8(in); inpos+=1; break; case 0xB0: //   ; if(byte1&gt;=98&amp;&amp;byte1&gt;=101){ //     NRPN  RPN; message(5); //  ; } byte2=read8(in); inpos+=1; break; case 0xC0: //  (.  ); // , ,    ; break; case 0xD0: //; break; case 0xE0: // ; byte2=read8(in); inpos+=1; break; default: //  (   ); break; } } //     0xFFFF,    ; outdelta=255; outnote=255; WriteFile(out, &amp;outdelta, 1, &amp;ww, NULL); WriteFile(out, &amp;outnote, 1, &amp;ww, NULL); csz+=2; //   ,     ; printf("Length: %i (%i:%02i)\n",time,time/192,time%192);</span></span></code> </pre><br></div></div><br>  A parte b√°sica do programa para o MK, de fato, √© muito simples.  Considere uma das op√ß√µes para sua implementa√ß√£o, mais precisamente, sua parte principal. <br><br>  O temporizador 1, usado para gerar o som das notas, √© configurado da seguinte maneira.  Para ativar e desativar notas, as seguintes substitui√ß√µes s√£o usadas, respectivamente. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ENT1 TCCR1B=0x09;TCCR1A=0x40 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DIST1 TCCR1B=0x00;TCCR1A=0x00;PORTB.1=0</span></span></code> </pre><br>  Antes de iniciar o timer, voc√™ precisa atribuir ao registro OCR1A um valor de 16 bits que corresponder√° √† frequ√™ncia que est√° sendo reproduzida.  Isso ser√° mostrado mais tarde.  Quando o timer √© ativado, o registro TCCR1B recebe o Modo de Gera√ß√£o de Forma de Onda com um divisor de timer 1 e o registro TCCR1A √© definido como Alternar OC1A na Compara√ß√£o de Compara√ß√£o.  Nesse caso, o sinal √© removido da sa√≠da especialmente designada do MK ‚ÄúOC1A‚Äù.  No ATmega8 no pacote SMD, esse √© o pino 13, que √© o mesmo que PORTB.1.  Quando o timer √© desligado, os dois registradores s√£o redefinidos e a sa√≠da de PORTB.1 √© for√ßada a zero.  Isso √© necess√°rio para impedir, durante o sil√™ncio, a sa√≠da de uma tens√£o constante, o que seria indesej√°vel para a entrada do VLF.  No entanto, voc√™ pode colocar um capacitor no circuito, mas tamb√©m pode desativar programaticamente a sa√≠da.  Uma tens√£o constante pode ocorrer nesta sa√≠da se a nota for desativada no momento da fase correspondente do sinal, e isso ocorre em 50% dos casos. <br><br>  Crie uma matriz de valores de timer para 12 notas da primeira oitava.  Esses valores foram calculados antecipadamente. <br><br><pre> <code class="cpp hljs">freq[]={<span class="hljs-number"><span class="hljs-number">61156</span></span>,<span class="hljs-number"><span class="hljs-number">57724</span></span>,<span class="hljs-number"><span class="hljs-number">54484</span></span>,<span class="hljs-number"><span class="hljs-number">51426</span></span>,<span class="hljs-number"><span class="hljs-number">48540</span></span>,<span class="hljs-number"><span class="hljs-number">45815</span></span>,<span class="hljs-number"><span class="hljs-number">43244</span></span>,<span class="hljs-number"><span class="hljs-number">40817</span></span>,<span class="hljs-number"><span class="hljs-number">38526</span></span>,<span class="hljs-number"><span class="hljs-number">36364</span></span>,<span class="hljs-number"><span class="hljs-number">34323</span></span>,<span class="hljs-number"><span class="hljs-number">32396</span></span>};</code> </pre><br>  As notas de outras oitavas, como eu disse, ser√£o obtidas pela divis√£o em graus dois. <br><br>  A configura√ß√£o do temporizador 0 √© ainda mais simples.  Funciona constantemente, com uma interrup√ß√£o de transbordamento, cada vez que √© inicializado novamente com o valor que corresponde ao andamento da melodia.  O divisor do temporizador √© 5: TCCR0 = 0x05.  Com base nesse timer, √© criado um timer virtual que conta os tiques (vezes) na melodia.  O processamento da resposta desse timer √© colocado no ciclo principal do programa. <br><br>  A fun√ß√£o de interrup√ß√£o do timer 0 √© a seguinte. <br><br><pre> <code class="cpp hljs">interrupt [TIM0_OVF] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timer0_ovf_isr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ent01){ vt01+=<span class="hljs-number"><span class="hljs-number">1</span></span>; } TCNT0=top0; }</code> </pre><br>  Aqui, a vari√°vel ent01 √© respons√°vel por ativar o timer virtual.  Por essa vari√°vel, ela pode ser ativada ou desativada, se necess√°rio.  A vari√°vel vt01 √© a vari√°vel prim√°ria cont√°vel do timer virtual.  A linha TCNT0 = top0 indica a inicializa√ß√£o do temporizador 0 para o valor desejado top0, que √© lido no t√≠tulo da melodia antes de reproduzi-la. <br><br>  O n√∫mero da melodia a ser tocada corresponde √† vari√°vel alm.  Tamb√©m serve como bandeira do in√≠cio da reprodu√ß√£o.  Ela precisa atribuir um n√∫mero de melodia de uma das maneiras, dependendo da tarefa.  Depois disso, o pr√≥ximo bloco do ciclo principal ficar√° ativo. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(alm){ <span class="hljs-comment"><span class="hljs-comment">//     ; adr=eepr(alm-1)&lt;&lt;9; //     (&lt;&lt;9    512); adr+=15; //   ,      ; top0=eepr(adr); //  ; adr+=1; //     ; adr0=adr; //      (  ); top01=eepr(adr); //      " "  ; adr+=1; //   ; note=eepr(adr); // ; adr+=1; //    -; vt01=0; //    ; ent01=1; //  ; TCNT0=0; //  ; alm=0; //        ,   ; }</span></span></code> </pre><br>  A mudan√ßa adicional de nota para nota √© realizada na unidade de processamento do timer virtual, que tamb√©m √© colocado no loop principal. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(vt01&gt;=top01){ <span class="hljs-comment"><span class="hljs-comment">//   ,    ; vt01=0; //  ; if(note&amp;0x80){ //     ""; nt=note&amp;15; //    ; oct=(note&amp;0x7F)&gt;&gt;4; //  ; if(nt!=15){ //       15,   ; OCR1A=freq[nt]&gt;&gt;oct; //     ; //         ; ENT1; // ; }else{ //  " "   ; DIST1; // ; } }else{ //     ""; DIST1; // ; } top01=eepr(adr); //      " "; adr+=1; //   ; note=eepr(adr); //   ; adr+=1; // ; if(note==255 &amp;&amp; top01==255){ //      ; top01=eepr(adr0); //   ,   ; note=eepr(adr0+1); //   ; adr=adr0+2; //   ; } }</span></span></code> </pre><br>  A partir dos coment√°rios no texto do programa, tudo deve ser bem claro e compreens√≠vel. <br><br>  Para parar a melodia, use a seguinte inser√ß√£o do loop principal. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(stop){ <span class="hljs-comment"><span class="hljs-comment">//  ; DIST1; //  ; ent01=0; //  ; vt01=0; //  ; }</span></span></code> </pre><br>  H√° uma pequena observa√ß√£o sobre a implementa√ß√£o da reprodu√ß√£o da melodia.  Antes de cada nova nota come√ßar a soar, o microcontrolador gasta uma pequena quantidade de tempo convertendo o byte de leitura da nota em um valor de timer.  Desta vez, como se viu na pr√°tica, √© relativamente pequeno e n√£o afeta a qualidade da reprodu√ß√£o.  Mas eu tinha d√∫vidas de que essa opera√ß√£o permanecesse invis√≠vel.  Nesse caso, pausas extras apareceriam antes de cada nota e o ritmo da melodia seria interrompido.  Mas esse problema tamb√©m √© solucion√°vel.  Basta calcular os valores do timer da pr√≥xima nota com anteced√™ncia enquanto a nota atual soa.  Este procedimento deve ser executado separadamente do processamento do timer virtual no loop principal do programa usando um sinalizador especialmente designado.  Como √© improv√°vel que o tempo de c√°lculo exceda o tempo de reprodu√ß√£o da nota mais curta, essa solu√ß√£o √© adequada. <br><br>  Agora vamos testar o programa. <br><br>  Al√©m dos trechos de c√≥digo acima, adicionei fun√ß√µes de processamento de bot√£o ao programa MK, com as quais controlo a inclus√£o ou desativa√ß√£o de uma melodia espec√≠fica.  A EEPROM est√° conectada ao MK via barramento I2C, trabalho com o qual √© implementado no n√≠vel do software.  O projeto foi realizado com a ajuda do ‚ÄúCodeVisionAVR‚Äù junto com o ‚ÄúCodeWizardAVR‚Äù.  Sa√≠da o MK do pino 13 para a placa de som do PC atrav√©s do divisor e gravo o som da melodia no editor de som.  Pisquei a mem√≥ria EEPROM com a ajuda do firmware, sobre o qual escrevi em um dos artigos anteriores.  Como nem todos os bytes do arquivo de imagem s√£o √∫teis, o firmware da mem√≥ria pode ser implementado apenas por bytes √∫teis (at√© os marcadores finais das melodias), a fim de economizar tempo de grava√ß√£o e recursos de chip.  Para fazer isso, voc√™ pode criar um programa separado ou gravar bytes no chip diretamente durante a convers√£o, adicionando ao programa principal. <br><br>  Entre as oito m√∫sicas, h√° tr√™s de teste, com a qual avaliarei a faixa de frequ√™ncia de ouvido, o som da mesclagem de notas id√™nticas, o som das notas mais curtas, transi√ß√µes r√°pidas etc.  Deixe-me lembr√°-lo de que a mesclagem das mesmas notas realmente soa com uma pausa de um tiquetaque, e a primeira nota na fus√£o dura menos um. <br><br>  Uma das m√∫sicas de teste √© uma sequ√™ncia de notas do primeiro ao √∫ltimo, com dura√ß√£o de uma nota em um quarto e um tempo de melodia de 40 bpm. <br><br><img src="https://habrastorage.org/webt/d7/sr/hx/d7srhxannedgrv63owftqzeaf7k.png"><br><br>  Nesse cen√°rio, uma nota soa um pouco mais de um segundo e, portanto, voc√™ pode ouvir em detalhes como soa todo o intervalo de notas.  No espectro de frequ√™ncias no editor de √°udio "Adobe Audition", os principais componentes de frequ√™ncia e seus harm√¥nicos superiores s√£o observados devido √† forma de onda dente de serra correspondente.  E a rela√ß√£o logar√≠tmica entre o n√∫mero da nota e a frequ√™ncia √© impressionante. <br><br><img src="https://habrastorage.org/webt/sn/_2/xn/sn_2xnmlyxsmmfo23beniaqvzki.png"><br><br>  Analisando os intervalos de tempo, √© claramente visto que a pausa real entre notas consecutivas √© em m√©dia de cerca de 145 amostras (em uma frequ√™ncia de amostragem da grava√ß√£o de √°udio 44100 Hz), que √© de cerca de 3 ms.  Este √© o tempo durante o qual o MK executa os c√°lculos necess√°rios.  Essas inser√ß√µes est√£o presentes regularmente antes de cada nota.  Escrevi especificamente o significado nas amostras, pois essas informa√ß√µes s√£o mais originais e mais precisas, embora isso n√£o seja muito importante. <br><br><img src="https://habrastorage.org/webt/ue/t6/pg/uet6pgd-e0iac2m2imj3m4fa5o4.png"><br><br>  E a dura√ß√£o de um tique a um ritmo m√©dio da melodia de 120 bpm √© de cerca de 10 ms.  Segue-se que, em princ√≠pio, seria poss√≠vel n√£o introduzir a mesma corre√ß√£o em 1 tick, quando duas notas id√™nticas forem uma ap√≥s a outra sem pausa.  Eu acho que a inser√ß√£o regular de 3 ms entre as notas seria suficiente.  Ao ouvir uma melodia, essas inser√ß√µes regulares n√£o s√£o percept√≠veis e as melodias soam uniformemente.  Portanto, n√£o h√° necessidade espec√≠fica de calcular o valor do timer para a pr√≥xima nota enquanto a nota atual estiver sendo reproduzida. <br><br>  Outra melodia de teste com um ritmo de 200 bpm cont√©m sucessivamente as mesmas notas 1/32 da faixa intermedi√°ria, sem pausa.  Nesse caso, ap√≥s o processamento, ao tocar entre eles, h√° uma pausa de 1 tick, que neste ritmo r√°pido de 310 amostras (cerca de 6 ms) do sinal gravado. <br><br><img src="https://habrastorage.org/webt/ms/on/m_/msonm__-e7svpb38fq22xhul7dm.png"><br><br>  A dura√ß√£o desta pausa, a prop√≥sito, √© compar√°vel ao per√≠odo do sinal, o que indica um ritmo alto da melodia.  E seu som lembra um trinado. <br><br>  Em princ√≠pio, isso pode ser conclu√≠do.  Fiquei satisfeito com o resultado do dispositivo, ele superou todas as expectativas.  Na maioria das vezes, dediquei-me ao estudo do formato midi e √† depura√ß√£o do programa para convers√£o.  Um dos seguintes artigos tamb√©m dedicarei a um t√≥pico relacionado ao MIDI, que abordar√° a aplica√ß√£o desse formato em outras aplica√ß√µes interessantes. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt454514/">https://habr.com/ru/post/pt454514/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt454498/index.html">A tarefa com asteriscos: coletamos √≠m√£s el√©tricos no exemplo do Twitter Mantis-E0</a></li>
<li><a href="../pt454500/index.html">Douglas Engelbart: ‚ÄúAumentando o intelecto humano: uma estrutura conceitual‚Äù (passo 2)</a></li>
<li><a href="../pt454506/index.html">Entropic - Novo registro de pacote distribu√≠do para Node.js</a></li>
<li><a href="../pt454508/index.html">Portando aplicativos da √°rea de trabalho para o .NET Core</a></li>
<li><a href="../pt454512/index.html">Relat√≥rio do caf√© da manh√£ com Charles Weatherly, autor do livro de culto Etudes for Programmers</a></li>
<li><a href="../pt454516/index.html">Como obter um bom texto por 200 rublos</a></li>
<li><a href="../pt454518/index.html">Wasmer: a biblioteca Go mais r√°pida para executar o c√≥digo do WebAssembly</a></li>
<li><a href="../pt454520/index.html">Diretrizes para escrever c√≥digo JavaScript limpo</a></li>
<li><a href="../pt454522/index.html">Node.js: gerenciando a mem√≥ria dispon√≠vel para aplicativos em execu√ß√£o em cont√™ineres</a></li>
<li><a href="../pt454524/index.html">Repara√ß√£o de fita para a cabe√ßa Samsung Level On Pro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>