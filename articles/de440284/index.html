<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçí üßëüèæ‚Äçü§ù‚Äçüßëüèæ ‚úåüèª Ein neuer Blick auf die Anzeige von Dialogen in Android üßë‚Äçü§ù‚Äçüßë üòù üëºüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Bild zeigt den ersten Gedanken des Lesers, der sich fragt, was √ºber eine so einfache Aufgabe wie das Anzeigen eines Dialogs geschrieben werden kan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ein neuer Blick auf die Anzeige von Dialogen in Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mobileup/blog/440284/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/cu/u9/xl/cuu9xl-sjrrfz5v4pqqh9hocnxo.png"></a> </p><br><p>  Das Bild zeigt den ersten Gedanken des Lesers, der sich fragt, was √ºber eine so einfache Aufgabe wie das Anzeigen eines Dialogs geschrieben werden kann.  Der Manager denkt √§hnlich: "Hier gibt es nichts Kompliziertes, unser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vasya</a> wird es in 5 Minuten tun."  Nat√ºrlich √ºbertreibe ich, aber in Wirklichkeit ist nicht alles so einfach, wie es auf den ersten Blick scheint.  Besonders wenn wir √ºber Android sprechen. </p><br><p>  2019 war also auf dem Hof ‚Äã‚Äãund <strong>wir wissen immer noch nicht, wie man Dialoge richtig anzeigt</strong> . </p><a name="habracut"></a><br><p>  Lassen Sie es uns der Reihe nach tun und mit der Erkl√§rung des Problems beginnen: </p><br><blockquote>  Es ist erforderlich, einen einfachen Dialog mit dem Text anzuzeigen, um die Aktion und die Schaltfl√§chen ‚ÄûBest√§tigen / Abbrechen‚Äú zu best√§tigen.  Durch Klicken auf die Schaltfl√§che "Best√§tigen" - F√ºhren Sie eine Aktion aus, klicken Sie auf die Schaltfl√§che "Abbrechen" - schlie√üen Sie den Dialog. </blockquote><br><h1 id="reshenie-v-lob">  Stirnl√∂sung </h1><br><p>  Ich w√ºrde diese Methode als Junior bezeichnen, da dies nicht das erste Mal ist, dass ich auf ein Missverst√§ndnis sto√üe, warum Sie AlertDialog nicht einfach verwenden k√∂nnen, wie unten gezeigt: </p><br><pre><code class="kotlin hljs">AlertDialog.Builder(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .setMessage(<span class="hljs-string"><span class="hljs-string">"Please, confirm the action"</span></span>) .setPositiveButton(<span class="hljs-string"><span class="hljs-string">"Confirm"</span></span>) { dialog, which -&gt; <span class="hljs-comment"><span class="hljs-comment">// handle click } .setNegativeButton("Cancel", null) .create() .show()</span></span></code> </pre> <br><p>  Ein f√ºr Anf√§nger unerfahrener Weg, der offensichtlich und intuitiv ist.  Aber wie in vielen F√§llen bei der Arbeit mit Android ist diese Methode v√∂llig falsch.  Aus heiterem Himmel kommt es zu einem Speicherverlust. Schalten Sie einfach das Ger√§t aus, und in den Protokollen wird der folgende Fehler angezeigt: </p><br><div class="spoiler">  <b class="spoiler_title">Stacktrace</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">E/WindowManager: android.view.WindowLeaked: Activity com.example.testdialog.MainActivity has leaked window DecorView@71b5789[MainActivity] that was originally added here at android.view.ViewRootImpl.&lt;init&gt;(ViewRootImpl.java:511) at android.view.WindowManagerGlobal.addView(WindowManagerGlobal.java:346) at android.view.WindowManagerImpl.addView(WindowManagerImpl.java:93) at android.app.Dialog.show(Dialog.java:329) at com.example.testdialog.MainActivity.onCreate(MainActivity.kt:27) at android.app.Activity.performCreate(Activity.java:7144) at android.app.Activity.performCreate(Activity.java:7135) at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1271) at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2931) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3086) at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:78) at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:108) at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:68) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1816) at android.os.Handler.dispatchMessage(Handler.java:106) at android.os.Looper.loop(Looper.java:193) at android.app.ActivityThread.main(ActivityThread.java:6718) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:493) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:858)</code> </pre></div></div><br><p>  Bei Stackoverflow ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Frage</a> zu diesem Thema eine der beliebtesten.  Kurz gesagt, das Problem ist, dass wir entweder den Dialog anzeigen oder den Dialog nach Abschluss der Aktivierung nicht schlie√üen. </p><br><p>  Sie k√∂nnen nat√ºrlich im Dialogfeld in der Aktivit√§t onPause oder onDestroy die Option "Entlassen" aufrufen, wie in der Antwort als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Referenz angegeben</a> .  Aber genau das brauchen wir nicht.  Wir m√∂chten, dass der Dialog nach dem Drehen des Ger√§ts wiederhergestellt wird. </p><br><h1 id="ustarevshiy-sposob">  Veralteter Weg </h1><br><p>  Bevor Fragmente in Android angezeigt wurden, sollten Dialoge durch einen Aufruf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aktivierungsmethode showDialog</a> angezeigt worden sein.  In diesem Fall verwaltet die Aktivit√§t den Lebenszyklus des Dialogs korrekt und stellt ihn nach einer Runde wieder her.  Die Erstellung des Dialogs selbst musste im onCreateDialog-R√ºckruf implementiert werden: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CONFIRMATION_DIALOG_ID = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... @Override protected Dialog onCreateDialog(int id, Bundle args) { if (id == CONFIRMATION_DIALOG_ID) { return new AlertDialog.Builder(this) .setMessage("Please, confirm the action") .setPositiveButton("Confirm", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { // handle click } }) .create(); } else { return super.onCreateDialog(id, args); } } }</span></span></code> </pre> <br><p>  Es ist nicht sehr praktisch, dass Sie eine Dialogkennung starten und Parameter √ºber das Bundle √ºbergeben m√ºssen.  Und wir k√∂nnen immer noch das Problem "Durchgesickertes Fenster" bekommen, wenn wir versuchen, einen Dialog anzuzeigen, nachdem wir onDestroy f√ºr die Aktivit√§t aufgerufen haben.  Dies ist beispielsweise m√∂glich, wenn versucht wird, nach einer asynchronen Operation einen Fehler anzuzeigen. </p><br><p>  Im Allgemeinen ist dieses Problem typisch f√ºr Android, wenn Sie nach einem asynchronen Vorgang etwas tun m√ºssen und die Aktivit√§t oder das Fragment zu diesem Zeitpunkt bereits zerst√∂rt ist.  Dies ist wahrscheinlich der Grund, warum MV * -Muster in der Android-Community beliebter sind als bei iOS-Entwicklern. </p><br><h1 id="sposob-iz-dokumentacii">  Methode aus der Dokumentation </h1><br><p>  Fragmente wurden in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Android Honeycomb</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">angezeigt</a> , und die oben beschriebene Methode ist veraltet, und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">showDialog-</a> Methode der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aktivit√§t ist</a> als veraltet markiert.  Nein, AlertDialog ist nicht veraltet, da sich viele irren.  Gerade gibt es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DialogFragment</a> , das das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dialogobjekt umschlie√üt</a> und seinen Lebenszyklus steuert. </p><br><blockquote>  Native Snippets sind seit der 28 API ebenfalls veraltet.  Jetzt sollten Sie nur die Implementierung aus der Support Library (AndroidX) verwenden. </blockquote><p>  Lassen Sie uns unsere Aufgabe erf√ºllen, wie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Dokumentation vorgeschrieben</a> : </p><br><ol><li>  Zuerst m√ºssen Sie von DialogFragment erben und die Erstellung eines Dialogs in der onCreateDialog-Methode implementieren. </li><li>  Beschreiben der Dialogereignisschnittstelle und Instanziieren des Listeners in der onAttach-Methode. </li><li>  Implementieren Sie eine Dialogereignisschnittstelle in einer Aktivit√§t oder einem Fragment. </li></ol><br><blockquote>  Wenn dem Leser nicht klar ist, warum der H√∂rer nicht durch den Konstruktor geleitet werden kann, kann er hier mehr dar√ºber lesen </blockquote><p>  Dialogfragmentcode: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConfirmationDialogFragment</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DialogFragment</span></span></span></span>() { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConfirmationListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">confirmButtonClicked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancelButtonClicked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> listener: ConfirmationListener <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAttach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Context</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onAttach(context) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Instantiate the ConfirmationListener so we can send events to the host listener = activity as ConfirmationListener } catch (e: ClassCastException) { // The activity doesn't implement the interface, throw exception throw ClassCastException(activity.toString() + " must implement ConfirmationListener") } } override fun onCreateDialog(savedInstanceState: Bundle?): Dialog { return AlertDialog.Builder(context!!) .setMessage("Please, confirm the action") .setPositiveButton("Confirm") { _, _ -&gt; listener.confirmButtonClicked() } .setNegativeButton("Cancel") { _, _ -&gt; listener.cancelButtonClicked() } .create() } }</span></span></code> </pre> <br><p>  Aktivierungscode: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppCompatActivity</span></span></span></span>(), ConfirmationListener { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showConfirmationDialog</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ConfirmationDialogFragment() .show(supportFragmentManager, <span class="hljs-string"><span class="hljs-string">"ConfirmationDialogFragmentTag"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">confirmButtonClicked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// handle click } override fun cancelButtonClicked() { // handle click } }</span></span></code> </pre> <br><p>  Es hat sich genug Code herausgestellt, oder? </p><br><p>  In der Regel gibt es eine Art MVP im Projekt, aber ich habe entschieden, dass Presenter-Aufrufe in diesem Fall weggelassen werden k√∂nnen.  Im obigen Beispiel lohnt es sich, die statische Methode zum Erstellen des newInstance-Dialogfelds und zum erwarteten √úbergeben von Parametern an die Fragmentargumente hinzuzuf√ºgen. </p><br><p>  Und das alles, damit sich der Dialog rechtzeitig versteckt und korrekt wiederhergestellt wird.  Es ist nicht √ºberraschend, dass solche Fragen bei Stackoverflow auftauchen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eins</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei</a> . </p><br><h1 id="poisk-idealnogo-resheniya">  Die perfekte L√∂sung finden </h1><br><p>  Der aktuelle Stand der Dinge passte nicht zu uns, und wir suchten nach einer M√∂glichkeit, die Arbeit mit Dialogen komfortabler zu gestalten.  Es gab das Gef√ºhl, dass man es einfacher machen kann, fast wie bei der ersten Methode. </p><br><p>  Die folgenden √úberlegungen haben uns geleitet: </p><br><ul><li>  <strong>Muss ich den Dialog speichern und wiederherstellen, nachdem der Bewerbungsprozess abgebrochen wurde?</strong> <br>  In den meisten F√§llen ist dies nicht erforderlich, wie in unserem Beispiel, wenn Sie eine einfache Nachricht anzeigen oder etwas fragen m√ºssen.  Ein solcher Dialog ist relevant, bis die Aufmerksamkeit des Benutzers verloren geht.  Wenn Sie es nach einer langen Abwesenheit in der Anwendung wiederherstellen, verliert der Benutzer den Kontext mit der geplanten Aktion.  Daher m√ºssen <strong>Sie nur die Umdrehungen des Ger√§ts unterst√ºtzen</strong> und den Lebenszyklus des Dialogs korrekt handhaben.  Andernfalls kann der Benutzer aufgrund der unangenehmen Bewegung des Ger√§ts die gerade ge√∂ffnete Nachricht verlieren, ohne sie zu lesen. </li><li>  Bei Verwendung von DialogFragment wird zu viel Code angezeigt, und die Einfachheit geht verloren.  Daher w√§re es sch√∂n, das Fragment als Wrapper zu entfernen und <strong>Dialog direkt zu verwenden</strong> .  Dazu m√ºssen Sie den Status des Dialogfelds speichern, um ihn nach dem erneuten Erstellen der Ansicht wieder anzuzeigen und auszublenden, wenn die Ansicht stirbt. </li><li>  Jeder ist es gewohnt, die Darstellung des Dialogs als Team wahrzunehmen, insbesondere wenn Sie nur mit MVP arbeiten.  Die Aufgabe der anschlie√üenden Wiederherstellung des Zustands √ºbernimmt der FragmentManager.  Sie k√∂nnen diese Situation jedoch anders betrachten und beginnen, <strong>den Dialog als Zustand wahrzunehmen</strong> .  Dies ist viel praktischer, wenn Sie mit PM- oder MVVM-Mustern arbeiten. </li><li>  Angesichts der Tatsache, dass die meisten Anwendungen jetzt reaktive Ans√§tze verwenden, m√ºssen <strong>Dialoge reaktiv sein</strong> .  Die Hauptaufgabe besteht nicht darin, die Kette zu unterbrechen, die die Anzeige des Dialogs initiiert, und einen reaktiven Strom von Ereignissen anzuh√§ngen, um ein Ergebnis daraus zu erhalten.  Dies ist auf der PresentationModel / ViewModel-Seite sehr praktisch, wenn Sie mehrere Datenstr√∂me bearbeiten. </li></ul><br><p>  Wir haben alle oben genannten Anforderungen ber√ºcksichtigt und eine M√∂glichkeit gefunden, Dialoge reaktiv anzuzeigen, die wir erfolgreich in unserer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RxPM-</a> Bibliothek implementiert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">haben</a> (es gibt einen separaten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> dar√ºber). </p><br><p>  Die L√∂sung selbst erfordert keine Bibliothek und kann separat durchgef√ºhrt werden.  Geleitet von der Idee des ‚ÄûDialogs als Zustand‚Äú k√∂nnen Sie versuchen, eine L√∂sung zu erstellen, die auf dem trendigen ViewModel und LiveData basiert.  Aber ich werde dieses Recht dem Leser √ºberlassen, und dann werden wir √ºber eine fertige L√∂sung aus der Bibliothek sprechen. </p><br><h1 id="reaktivnyy-sposob">  Reaktive Methode </h1><br><p>  Ich werde zeigen, wie die anf√§ngliche Aufgabe in RxPM gel√∂st wird, aber zuerst ein paar Worte zu Schl√ºsselkonzepten aus der Bibliothek: </p><br><ul><li>  <strong>PresentationModel</strong> - speichert einen Reaktionszustand, enth√§lt UI-Logik und √ºberlebt Runden. </li><li>  <strong>Zustand</strong> ist ein reaktiver <strong>Zustand</strong> .  Sie k√∂nnen sich das als Wrapper √ºber BehaviorRelay vorstellen. </li><li>  <strong>Aktion</strong> - Ein Wrapper √ºber PublishRelay dient zum √úbertragen von Ereignissen von View zu PresentationModel. </li><li>  <strong>Staat</strong> und <strong>Aktion</strong> haben beobachtbare und Verbraucher. </li></ul><br><p>  Die <a href="">DialogControl-</a> Klasse ist f√ºr den Status des Dialogs verantwortlich.  Es gibt zwei Parameter: den ersten f√ºr den Datentyp, der im Dialogfeld angezeigt werden soll, den zweiten f√ºr den Ergebnistyp.  In unserem Beispiel ist der Datentyp Einheit, es kann sich jedoch um eine Nachricht an den Benutzer oder einen anderen Typ handeln. </p><br><p>  DialogControl verf√ºgt √ºber die folgenden Methoden: </p><br><ul><li>  <code>show(data: T)</code> - gibt nur einen Befehl zum Anzeigen an. </li><li>  <code>showForResult(data: T): Maybe&lt;R&gt;</code> - zeigt einen Dialog an und √∂ffnet den Stream, um das Ergebnis zu erhalten. </li><li>  <code>sendResult(result: R)</code> - sendet das Ergebnis und wird von der <code>sendResult(result: R)</code> aufgerufen. </li><li>  <code>dismiss()</code> - versteckt nur den Dialog. </li></ul><br><p>  DialogControl speichert den Status - gibt es einen Dialog auf dem Bildschirm oder nicht (Angezeigt / Abwesend).  So sieht es im Klassencode aus: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DialogControl</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T, R</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">internal</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>(pm: PresentationModel) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> displayed = pm.State&lt;Display&gt;(Absent) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = pm.Action&lt;R&gt;() <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Display</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Displayed</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt;</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: T) : Display() <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Absent : Display() } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Erstellen Sie ein einfaches PresentationModel: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SamplePresentationModel</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PresentationModel</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConfirmationDialogResult</span></span></span><span class="hljs-class"> </span></span>{ CONFIRMED, CANCELED } <span class="hljs-comment"><span class="hljs-comment">//        enum    val confirmationDialog = dialogControl&lt;Unit, ConfirmationDialogResult&gt;() val buttonClicks = Action&lt;Unit&gt;() override fun onCreate() { super.onCreate() buttonClicks.observable .switchMapMaybe { //           confirmationDialog.showForResult(Unit) .filter { it == ConfirmationDialogResult.CONFIRMED } } .subscribe { //   } .untilDestroy() } }</span></span></code> </pre> <br><p>  Bitte beachten Sie, dass die Klickverarbeitung, Best√§tigungsbest√§tigung und Aktionsverarbeitung in derselben Kette implementiert sind.  Auf diese Weise k√∂nnen Sie den Code fokussieren und die Logik nicht auf mehrere R√ºckrufe verteilen. </p><br><p>  Als N√§chstes binden wir DialogControl einfach mit der Erweiterung bindTo an die Ansicht. <br>  Wir sammeln den √ºblichen AlertDialog und senden das Ergebnis √ºber sendResult: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SampleActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PmSupportActivity</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SamplePresentationModel</span></span></span><span class="hljs-class">&gt;</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">providePresentationModel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = SamplePresentationModel() <span class="hljs-comment"><span class="hljs-comment">//     View  PresentationModel override fun onBindPresentationModel(pm: SamplePresentationModel) { pm.confirmationDialog bindTo { data, dialogControl -&gt; AlertDialog.Builder(this@SampleActivity) .setMessage("Please, confirm the action") .setPositiveButton("Confirm") { _, _ -&gt; dialogControl.sendResult(CONFIRMED) } .setNegativeButton("Cancel") { _, _ -&gt; dialogControl.sendResult(CANCELED) } .create() } button.clicks() bindTo pm.buttonClicks } }</span></span></code> </pre> <br><p>  In einem typischen Szenario passiert so etwas unter der Haube: </p><br><ol><li>  Wir klicken auf die Schaltfl√§che, das Ereignis √ºber die Aktion "buttonClicks" gelangt in das PresentationModel. </li><li>  F√ºr dieses Ereignis starten wir die Anzeige des Dialogfelds √ºber den Aufruf von showForResult. </li><li>  Infolgedessen √§ndert sich der Status in DialogControl von Abwesend zu Angezeigt. </li><li>  Wenn das angezeigte Ereignis empfangen wird, wird das Lambda aufgerufen, das wir in der bindTo-Bindung √ºbergeben haben.  Darin wird ein Dialogobjekt erstellt, das dann angezeigt wird. </li><li>  Der Benutzer dr√ºckt die Schaltfl√§che Best√§tigen, der Listener wird ausgel√∂st und das Ergebnis des Klicks wird durch Aufrufen von sendResult an DialogControl gesendet. </li><li>  Als n√§chstes f√§llt das Ergebnis in das interne Aktionsergebnis, und der Status von Angezeigt √§ndert sich in Abwesend. </li><li>  Wenn ein Abwesenheitsereignis empfangen wird, wird der aktuelle Dialog geschlossen. </li><li>  Das Ereignis aus dem Aktionsergebnis f√§llt in den Stream, der durch den Aufruf von showForResult ge√∂ffnet wurde und von der Kette in PresentationModel verarbeitet wird. </li></ol><br><p>  Es ist zu beachten, dass der Dialog geschlossen wird, auch wenn die Ansicht von PresentationModel getrennt wird.  In diesem Fall bleibt der Status angezeigt.  Es wird bei der n√§chsten Bindung empfangen und der Dialog wird wiederhergestellt. </p><br><p>  Wie Sie sehen k√∂nnen, ist DialogFragment nicht mehr erforderlich.  Das Dialogfeld wird angezeigt, wenn die Ansicht an das PresentationModel angeh√§ngt ist, und wird ausgeblendet, wenn die Ansicht gel√∂st wird.  Aufgrund der Tatsache, dass der Status in DialogControl gespeichert ist, das wiederum in PresentationModel gespeichert ist, wird der Dialog wiederhergestellt, nachdem das Ger√§t gedreht wurde. </p><br><h1 id="pishite-dialogi-pravilno">  Dialoge richtig schreiben </h1><br><p>  Wir haben verschiedene M√∂glichkeiten zur Anzeige von Dialogen untersucht.  Wenn Sie immer noch auf die erste Weise zeigen, dann bitte ich Sie, tun Sie dies nicht mehr.  F√ºr Liebhaber von MVP bleibt nichts anderes √ºbrig, als die Standardmethode zu verwenden, die in der offiziellen Dokumentation beschrieben ist.  Leider l√§sst die Tendenz zur Imperativit√§t dieses Musters nichts anderes zu.  Nun, ich empfehle RxJava-Fans, sich die reaktive Methode und unsere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RxPM-</a> Bibliothek genauer anzusehen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de440284/">https://habr.com/ru/post/de440284/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de440274/index.html">Aufbau eines privaten W√§hrungsdienstes mit Exonum</a></li>
<li><a href="../de440276/index.html">Front-End- und Back-End-Debugging</a></li>
<li><a href="../de440278/index.html">Schalten Sie Tinder auf Kubernetes um</a></li>
<li><a href="../de440280/index.html">Android Free Software Review</a></li>
<li><a href="../de440282/index.html">Schnellste Python-Webframeworks im Jahr 2019</a></li>
<li><a href="../de440286/index.html">Perlin-Rauschen, prozedurale Inhaltsgenerierung und interessanter Raum</a></li>
<li><a href="../de440288/index.html">IoT-Sicherheit. Problem 1. Smartwatches, Fitness-Tracker und Waagen</a></li>
<li><a href="../de440292/index.html">Das Buch ‚ÄûEinheit in Aktion. Plattform√ºbergreifende Entwicklung in C #. 2nd int. Ausgabe ¬ª</a></li>
<li><a href="../de440294/index.html">MIDI-Router auf Raspberry Pi</a></li>
<li><a href="../de440296/index.html">6 Anwendungen f√ºr das industrielle IoT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>