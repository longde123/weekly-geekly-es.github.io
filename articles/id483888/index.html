<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐯 🕜 💆🏼 Menjalankan program file tunggal di Java 11 tanpa kompilasi 📼 🏂🏻 🕵🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Biarkan file sumber HelloUniverse.java berisi definisi kelas dan metode main statis yang menampilkan satu baris teks ke terminal: 



 public class He...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menjalankan program file tunggal di Java 11 tanpa kompilasi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/nix/blog/483888/"><img src="https://habrastorage.org/webt/mr/ie/ii/mrieiilbpca6armxtc_yym5nqc0.jpeg"><br><br>  Biarkan file sumber HelloUniverse.java berisi definisi kelas dan metode <code>main</code> statis yang menampilkan satu baris teks ke terminal: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HelloUniverse</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hello InfoQ Universe"</span></span>); } }</code> </pre> <br>  Biasanya, untuk menjalankan kelas ini, Anda harus mengkompilasinya terlebih dahulu menggunakan Java compiler (javac), yang membuat file HelloUniverse.class: <br><br><pre> <code class="java hljs">mohamed_taman$ javac HelloUniverse.java</code> </pre> <br>  Maka Anda perlu menjalankan file yang dihasilkan menggunakan perintah Java virtual machine (interpreter): <br><br><pre> <code class="java hljs">mohamed_taman$ java HelloUniverse Hello InfoQ Universe</code> </pre> <br>  Kemudian virtualka akan mulai lebih dulu, yang akan memuat kelas dan mengeksekusi kode. <br><br>  Dan jika Anda perlu dengan cepat memeriksa sepotong kode?  Atau Anda baru mengenal Java ( <i>dalam hal ini, titik kunci</i> ) dan ingin bereksperimen dengan bahasa tersebut?  Dua langkah yang dijelaskan dapat memperumit masalah. <br><br>  Di Java SE 11, Anda dapat langsung menjalankan file sumber tunggal tanpa kompilasi perantara. <br><a name="habracut"></a><br>  Fitur ini sangat berguna untuk pemula yang ingin bekerja dengan program sederhana.  Dikombinasikan dengan jshell, Anda mendapatkan seperangkat alat yang hebat untuk mendidik pemula. <br><br>  Profesional dapat menggunakan alat ini untuk mempelajari inovasi dalam bahasa atau menguji API yang tidak dikenal.  Menurut pendapat kami, lebih baik mengotomatiskan banyak tugas, seperti menulis program Java dalam bentuk skrip dengan eksekusi selanjutnya dari OS shell.  Sebagai hasilnya, kita dapat bekerja secara fleksibel dengan skrip shell dan menggunakan semua fitur Java.  Mari kita bicarakan ini secara lebih rinci di bagian kedua artikel ini. <br><br>  Fitur hebat dari Java 11 ini memungkinkan Anda untuk langsung mengeksekusi file sumber tunggal tanpa kompilasi.  Mari kita bahas. <br><br><h3>  Apa yang kamu butuhkan </h3><br>  Untuk menjalankan kode yang disediakan dalam artikel, Anda memerlukan versi Java tidak lebih rendah dari 11. Pada saat penulisan, rilis saat ini adalah Java SE Development Kit 12.0.1 - versi terakhir ada di <a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk12-downloads-5295953.html">sini</a> , cukup terima persyaratan lisensi dan klik tautan untuk OS Anda.  Jika Anda ingin bereksperimen dengan fitur-fitur terbaru, Anda dapat <a href="https://jdk.java.net/13/">mengunduh</a> akses awal JDK 13. <br><br>  Harap dicatat bahwa rilis berbagai vendor OpenJDK sekarang juga tersedia, termasuk <a href="https://adoptopenjdk.net/">AdoptOpenJDK</a> . <br><br>  Pada artikel ini, kita akan menggunakan editor teks biasa dan bukan Java IDE untuk menghindari semua keajaiban IDE, dan menggunakan baris perintah Java langsung di terminal. <br><br><h2>  Jalankan .java dengan Java </h2><br>  Fungsi <a href="https://openjdk.java.net/jeps/330">JEP 330</a> (menjalankan program file tunggal dengan kode sumber) muncul di JDK 11. Ini memungkinkan Anda untuk secara langsung mengeksekusi file sumber dengan kode sumber Java, tanpa menggunakan juru bahasa.  Kode sumber dikompilasi dalam memori dan kemudian dieksekusi oleh interpreter tanpa membuat file .class pada disk. <br><br>  Namun, fungsi ini terbatas pada kode yang disimpan dalam satu file.  Anda tidak dapat menjalankan banyak file sumber sekaligus. <br><br>  Untuk mengatasi batasan ini, semua kelas harus didefinisikan dalam satu file.  Tidak ada batasan jumlah mereka.  Selain itu, ketika mereka berada di file yang sama, tidak masalah apakah itu publik atau pribadi. <br><br>  Kelas pertama yang didefinisikan dalam file akan dianggap sebagai yang utama, dan metode utama harus ditempatkan di dalamnya.  Artinya, ketertiban itu penting. <br><br><h3>  Contoh pertama </h3><br>  Mari kita mulai dengan contoh sederhana klasik - Hello Universe! <br><br>  Kami akan mendemonstrasikan fitur yang dideskripsikan dengan berbagai contoh sehingga Anda mendapatkan ide bagaimana itu dapat digunakan dalam pemrograman sehari-hari. <br><br>  Buat file HelloUniverse.java dengan kode dari awal artikel, kompilasi dan jalankan file kelas yang dihasilkan.  Kemudian hapus, sekarang Anda akan mengerti mengapa: <br><br><pre> <code class="java hljs">mohamed_taman$ rm HelloUniverse.class</code> </pre> <br>  Jika sekarang menggunakan Java interpreter Anda menjalankan file kelas tanpa kompilasi: <br><br><pre> <code class="java hljs">mohamed_taman$ java HelloUniverse.java Hello InfoQ Universe</code> </pre> <br>  Anda akan melihat hasil yang sama: file akan dieksekusi. <br><br>  Ini berarti bahwa sekarang Anda bisa menjalankan <code>java HelloUniverse.java</code> .  Kami mentransfer kode sumber itu sendiri, dan bukan file kelas: sistem di dalamnya sendiri mengkompilasinya, meluncurkan dan menampilkan pesan di konsol. <br><br>  Artinya, kompilasi masih dilakukan di bawah tenda.  Dan dalam hal kesalahannya, kami akan menerima pemberitahuan tentang ini.  Anda dapat memeriksa struktur direktori dan memastikan bahwa file kelas tidak dihasilkan, kompilasi dilakukan dalam memori. <br><br>  Sekarang mari kita cari tahu cara kerjanya. <br><br><h3>  Bagaimana interpreter Java mengeksekusi program HelloUniverse </h3><br>  Di JDK 10, peluncur Java dapat beroperasi dalam tiga mode: <br><br><ol><li>  Eksekusi file kelas. <br></li><li>  Eksekusi kelas utama dari file JAR. <br></li><li>  Eksekusi kelas utama modul. <br></li></ol><br>  Dan di Java 11, mode keempat muncul: <br><br><ol><li>  Eksekusi kelas yang dinyatakan dalam file sumber. <br></li></ol><br>  Dalam mode ini, file sumber dikompilasi dalam memori, dan kemudian kelas pertama dari file ini dijalankan. <br><br>  Sistem menentukan niat Anda untuk memasukkan file sumber sesuai dengan dua kriteria: <br><br><ol><li>  Item pertama pada baris perintah bukanlah opsi atau bagian dari opsi. <br></li><li>  Baris ini mungkin berisi <code>--source &lt;vrsion&gt;</code> . <br></li></ol><br>  Dalam kasus pertama, Java pertama akan mencari tahu apakah elemen pertama dari perintah adalah opsi atau bagian dari itu.  Jika ini adalah nama file yang diakhiri dengan .java, maka sistem akan menganggapnya sebagai kode sumber yang perlu dikompilasi dan dijalankan.  Anda juga dapat menambahkan opsi ke perintah Java sebelum nama file sumber.  <i>Misalnya, jika Anda ingin mengatur jalur kelas ketika file sumber menggunakan dependensi eksternal.</i> <br><br>  Dalam kasus kedua, mode bekerja dengan file sumber dipilih, dan elemen pertama pada baris perintah, yang bukan merupakan pilihan, dianggap sebagai file sumber yang perlu dikompilasi dan dijalankan. <br><br>  Jika file tidak memiliki ekstensi .java, maka Anda perlu menggunakan opsi <code>--source</code> untuk memaksanya masuk ke mode bekerja dengan file sumber. <br><br>  Ini penting dalam kasus di mana file sumber adalah "skrip" yang perlu dieksekusi, dan nama file tidak sesuai dengan konvensi yang biasa untuk menamai file sumber dengan kode Java. <br><br>  Menggunakan opsi <code>--source</code> , <code>--source</code> dapat menentukan versi bahasa sumber.  Kami akan membicarakan ini di bawah ini. <br><br><h3>  Bisakah saya meneruskan argumen di baris perintah? </h3><br>  Mari kita memperluas program Hello Universe kami sehingga menampilkan salam pribadi kepada setiap pengguna yang mengunjungi InfoQ Universe: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HelloUniverse2</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( args == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || args.length&lt; <span class="hljs-number"><span class="hljs-number">1</span></span> ){ System.err.println(<span class="hljs-string"><span class="hljs-string">"Name required"</span></span>); System.exit(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; System.out.printf(<span class="hljs-string"><span class="hljs-string">"Hello, %s to InfoQ Universe!! %n"</span></span>, name); } }</code> </pre> <br>  Simpan kode di file Greater.java.  Perhatikan bahwa nama file tidak cocok dengan nama kelas publik.  Ini melanggar aturan spesifikasi Java. <br><br>  Jalankan kode: <br><br><pre> <code class="java hljs">mohamed_taman$ java Greater.java <span class="hljs-string"><span class="hljs-string">"Mo. Taman"</span></span> Hello, Mo. Taman to InfoQ universe!!</code> </pre> <br>  Seperti yang Anda lihat, tidak masalah sama sekali bahwa kelas dan nama file tidak cocok.  Pembaca yang penuh perhatian mungkin juga memperhatikan bahwa kami meneruskan argumen ke kode setelah memproses nama file.  Ini berarti bahwa setiap argumen pada baris perintah setelah nama file diteruskan ke metode utama standar. <br><br><h3>  Tentukan tingkat kode sumber menggunakan opsi --source </h3><br>  Ada dua skenario untuk menggunakan opsi <code>--source</code> : <br><br><ol><li>  Menentukan level kode sumber. <br></li><li>  Paksa Java runtime ke mode sumber. <br></li></ol><br>  Dalam kasus pertama, jika Anda tidak menentukan level kode sumber, versi JDK saat ini diambil untuk itu.  Dan dalam kasus kedua, file dengan ekstensi selain .java dapat ditransfer untuk kompilasi dan eksekusi dengan cepat. <br><br>  Mari kita simak skenario kedua dulu.  Ganti nama Greater.java menjadi lebih besar tanpa ekstensi dan coba jalankan: <br><br><pre> <code class="java hljs">mohamed_taman$ java greater <span class="hljs-string"><span class="hljs-string">"Mo. Taman"</span></span> Error: Could not find or load main <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">greater</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Caused</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">by</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lang</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassNotFoundException</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">greater</span></span></span></span></code> </pre> <br>  Dengan tidak adanya ekstensi .java, penerjemah perintah mencari kelas yang dikompilasi dengan nama yang diteruskan sebagai argumen - ini adalah mode operasi pertama peluncur Java.  Untuk mencegah hal ini terjadi, gunakan opsi <code>--source</code> untuk memaksa beralih ke mode file sumber: <br><br><pre> <code class="java hljs">mohamed_taman$ java --source <span class="hljs-number"><span class="hljs-number">11</span></span> greater <span class="hljs-string"><span class="hljs-string">"Mo. Taman"</span></span> Hello, Mo. Taman to InfoQ universe!!</code> </pre> <br>  Sekarang mari kita beralih ke skenario pertama.  Kelas Greater.java kompatibel dengan JDK 10 karena mengandung kata kunci <code>var</code> , tetapi tidak kompatibel dengan JDK 9. Ubah <code>source</code> ke <code>10</code> : <br><br><pre> <code class="java hljs">mohamed_taman$ java --source <span class="hljs-number"><span class="hljs-number">10</span></span> Greater.java <span class="hljs-string"><span class="hljs-string">"Mo. Taman"</span></span> Hello Mo. Taman to InfoQ universe!!</code> </pre> <br>  Jalankan perintah sebelumnya lagi, tapi kali ini berikan <code>--source 9</code> bukannya <code>10</code> : <br><br><pre> <code class="java hljs">mohamed_taman$ java --source <span class="hljs-number"><span class="hljs-number">9</span></span> Greater.java <span class="hljs-string"><span class="hljs-string">"Mo. Taman"</span></span> Greater.java:<span class="hljs-number"><span class="hljs-number">8</span></span>: warning: as of release <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-string"><span class="hljs-string">'var'</span></span> is a restricted local variable type and cannot be used <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> type declarations or as the element type of an array <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; ^ Greater.java:<span class="hljs-number"><span class="hljs-number">8</span></span>: error: cannot find symbol <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; ^ symbol: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">var</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">location</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HelloWorld</span></span></span><span class="hljs-class"> 1 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">error</span></span></span><span class="hljs-class"> 1 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">warning</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">error</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">compilation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">failed</span></span></span></span></code> </pre> <br>  Catatan: kompiler memperingatkan bahwa <code>var</code> telah menjadi nama tipe terbatas di JDK 10.  Tetapi karena kami memiliki bahasa level 10, kompilasi berlanjut.  Namun, kerusakan terjadi karena file sumber tidak memiliki tipe bernama <code>var</code> . <br><br>  Semuanya sederhana.  Sekarang pertimbangkan penggunaan beberapa kelas. <br><br><h3>  Apakah pendekatan ini bekerja dengan banyak kelas? </h3><br>  Ya itu. <br><br>  Pertimbangkan sebuah contoh dengan dua kelas.  Kode memeriksa untuk melihat apakah nilai string yang diberikan adalah <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25BD%25D0%25B4%25D1%2580%25D0%25BE%25D0%25BC">palindrome</a> . <br><br>  Berikut adalah kode yang disimpan dalam file PalindromeChecker.java: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> java.lang.System.*; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PalindromeChecker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( args == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || args.length&lt; <span class="hljs-number"><span class="hljs-number">1</span></span> ){ err.println(<span class="hljs-string"><span class="hljs-string">"String is required!!"</span></span>); exit(<span class="hljs-number"><span class="hljs-number">1</span></span>); } out.printf(<span class="hljs-string"><span class="hljs-string">"The string {%s} is a Palindrome!! %b %n"</span></span>, args[<span class="hljs-number"><span class="hljs-number">0</span></span>], StringUtils .isPalindrome(args[<span class="hljs-number"><span class="hljs-number">0</span></span>])); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringUtils</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isPalindrome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String word)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(word)) .reverse() .toString() .equalsIgnoreCase(word); } }</code> </pre> <br>  Jalankan file: <br><br><pre> <code class="java hljs">mohamed_taman:code$ java PalindromeChecker.java RediVidEr The string {RediVidEr} is a Palindrome!! True</code> </pre> <br>  Jalankan lagi, ganti "RaceCar", bukan "MadAm": <br><br><pre> <code class="java hljs">mohamed_taman:code$ java PalindromeChecker.java RaceCar The string {RaceCar} is a Palindrome!! True</code> </pre> <br>  Sekarang gantikan "Mohamed" alih-alih "RaceCar": <br><br><pre> <code class="java hljs">mohamed_taman:code$ java PalindromeChecker.java Taman The string {Taman} is a Palindrome!! <span class="hljs-keyword"><span class="hljs-keyword">false</span></span></code> </pre> <br>  Seperti yang Anda lihat, Anda bisa menambahkan kelas publik sebanyak mungkin ke satu file sumber.  Pastikan bahwa metode utama didefinisikan terlebih dahulu.  Penerjemah akan menggunakan kelas pertama sebagai titik awal untuk memulai program setelah mengkompilasi kode dalam memori. <br><br><h3>  Bisakah saya menggunakan modul? </h3><br>  Ya, tidak ada batasan.  Kode yang dikompilasi memori dijalankan sebagai bagian dari modul yang tidak disebutkan namanya dengan opsi <code>--add-modules=ALL-DEFAULT</code> , yang memberikan akses ke semua modul yang dikirimkan bersama JDK. <br><br>  Artinya, kode dapat menggunakan modul yang berbeda tanpa perlu secara eksplisit mendefinisikan dependensi menggunakan module-info.java. <br><br>  Mari kita lihat kode yang membuat panggilan HTTP menggunakan HTTP Client API baru, diperkenalkan di JDK 11. Perhatikan bahwa API ini diperkenalkan di Java SE 9 sebagai fitur eksperimental, tetapi sekarang mereka memiliki status fungsi penuh dari modul java.net.http . <br><br>  Dalam contoh ini, kami akan memanggil REST API sederhana menggunakan metode GET untuk mendapatkan daftar pengguna.  Kami beralih ke <a href="https://reqres.in/api/users%3Fpage%3D2">reqres.in/api/users?page=2</a> layanan publik.  Kami menyimpan kode dalam file yang disebut UsersHttpClient.java: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> java.lang.System.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.http.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.http.HttpResponse.BodyHandlers; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UsersHttpClient</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = HttpClient.newBuilder().build(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = HttpRequest.newBuilder() .GET() .uri(URI.create(<span class="hljs-string"><span class="hljs-string">"https://reqres.in/api/users?page=2"</span></span>)) .build(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> response = client.send(request, BodyHandlers.ofString()); out.printf(<span class="hljs-string"><span class="hljs-string">"Response code is: %d %n"</span></span>,response.statusCode()); out.printf(<span class="hljs-string"><span class="hljs-string">"The response body is:%n %s %n"</span></span>, response.body()); } }</code> </pre> <br>  Jalankan program dan dapatkan hasilnya: <br><br><pre> <code class="java hljs">mohamed_taman:code$ java UsersHttpClient.java Response code is: <span class="hljs-number"><span class="hljs-number">200</span></span> The response body is: {<span class="hljs-string"><span class="hljs-string">"page"</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-string"><span class="hljs-string">"per_page"</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-string"><span class="hljs-string">"total"</span></span>:<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-string"><span class="hljs-string">"total_pages"</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-string"><span class="hljs-string">"data"</span></span>:[{<span class="hljs-string"><span class="hljs-string">"id"</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-string"><span class="hljs-string">"first_name"</span></span>:<span class="hljs-string"><span class="hljs-string">"Eve"</span></span>,<span class="hljs-string"><span class="hljs-string">"last_name"</span></span>:<span class="hljs-string"><span class="hljs-string">"Holt"</span></span>,<span class="hljs-string"><span class="hljs-string">"avatar"</span></span>:<span class="hljs-string"><span class="hljs-string">"https://s3.amazonaws.com/uifaces/faces/twitter/marcoramires/128.jpg"</span></span>},{<span class="hljs-string"><span class="hljs-string">"id"</span></span>:<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-string"><span class="hljs-string">"first_name"</span></span>:<span class="hljs-string"><span class="hljs-string">"Charles"</span></span>,<span class="hljs-string"><span class="hljs-string">"last_name"</span></span>:<span class="hljs-string"><span class="hljs-string">"Morris"</span></span>,<span class="hljs-string"><span class="hljs-string">"avatar"</span></span>:<span class="hljs-string"><span class="hljs-string">"https://s3.amazonaws.com/uifaces/faces/twitter/stephenmoon/128.jpg"</span></span>},{<span class="hljs-string"><span class="hljs-string">"id"</span></span>:<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-string"><span class="hljs-string">"first_name"</span></span>:<span class="hljs-string"><span class="hljs-string">"Tracey"</span></span>,<span class="hljs-string"><span class="hljs-string">"last_name"</span></span>:<span class="hljs-string"><span class="hljs-string">"Ramos"</span></span>,<span class="hljs-string"><span class="hljs-string">"avatar"</span></span>:<span class="hljs-string"><span class="hljs-string">"https://s3.amazonaws.com/uifaces/faces/twitter/bigmancho/128.jpg"</span></span>}]}</code> </pre> <br>  Sekarang Anda dapat dengan cepat menguji fitur-fitur baru yang disediakan oleh modul yang berbeda tanpa membuat modul Anda sendiri. <br><br><h2>  Mengapa skrip penting di Jawa? </h2><br>  Pertama, mari kita ingat apa itu skrip: <br><br><blockquote>  Skrip adalah program yang ditulis untuk lingkungan runtime tertentu yang mengotomatiskan pelaksanaan tugas atau perintah yang dapat dijalankan seseorang secara bergantian. </blockquote><br>  Dari definisi umum ini, kita dapat memperoleh definisi sederhana dari bahasa scripting - ini adalah bahasa pemrograman yang menggunakan konstruksi tingkat tinggi untuk menafsirkan dan mengeksekusi satu perintah (atau perintah) pada suatu waktu. <br><br>  Bahasa scripting menggunakan serangkaian perintah yang ditulis dalam file.  Seringkali bahasa-bahasa ini ditafsirkan (bukan dikompilasi) dan mematuhi gaya pemrograman prosedural (meskipun beberapa bahasa skrip juga memiliki sifat-sifat bahasa berorientasi objek). <br><br>  Secara umum, bahasa skrip lebih mudah dipelajari dan lebih cepat mengetik daripada dibandingkan dengan bahasa kompilasi yang lebih terstruktur seperti Java, C, dan C ++.  Bahasa scripting sisi server termasuk Perl, PHP, dan Python, dan di <i>sisi klien</i> , JavaScript. <br><br>  Untuk waktu yang lama, Java dianggap sebagai bahasa kompilasi yang terstruktur dengan sangat baik yang ditafsirkan oleh mesin virtual untuk dijalankan pada arsitektur komputasi apa pun.  Namun, Java tidak mudah dipelajari dan dibuat prototipe dibandingkan dengan bahasa scripting lainnya. <br><br>  Namun demikian, Java telah berusia 24 tahun, digunakan oleh sekitar 10 juta pengembang di seluruh dunia.  Rilis terbaru telah menambahkan sejumlah fitur baru untuk memudahkan programmer muda mempelajari bahasa ini, serta menggunakan fungsi bahasa dan API tanpa kompilasi dan IDE.  Sebagai contoh, Java SE 9 memperkenalkan JShell tool (REPL), yang mendukung pemrograman interaktif. <br><br>  Dan dengan dirilisnya JDK 11, bahasa ini mendapatkan kemampuan untuk mendukung skrip, karena sekarang Anda dapat mengeksekusi kode dengan panggilan sederhana ke perintah <code>java</code> ! <br><br>  Ada dua cara utama untuk menggunakan skrip di Java 11: <br><br><ol><li>  Panggilan langsung ke perintah <code>java</code> . <br></li><li>  Menggunakan skrip * nix untuk baris perintah, mirip dengan skrip Bash. <br></li></ol><br>  Kami sudah mempertimbangkan opsi pertama, sekarang kami akan berurusan dengan opsi kedua.  Ini membuka banyak kemungkinan bagi kita. <br><br><h3>  File Shebang: jalankan Java sebagai skrip shell </h3><br>  Jadi, di Java SE 11, dukungan untuk skrip muncul, termasuk file shebang tradisional dari dunia * nix.  Untuk mendukung mereka, spesifikasi bahasa tidak diperlukan. <br><br>  Dalam file shebang, dua byte pertama harus 0x23 dan 0x21.  Ini adalah pengkodean karakter ASCII #! .. Semua byte berikutnya dalam file tersebut dibaca berdasarkan pada sistem pengkodean default pada platform ini. <br><br>  Dengan demikian, agar file dapat dieksekusi menggunakan mekanisme shebang bawaan OS, hanya ada satu persyaratan: baris pertama dimulai dengan #! .. Ini berarti bahwa kami tidak memerlukan baris pertama khusus ketika peluncur Java secara eksplisit digunakan untuk menjalankan kode dari file sumber, seperti halnya dengan HelloUniverse.java. <br><br>  Jalankan contoh berikut di terminal yang menjalankan <i>macOS Mojave 10.14.5</i> .  Namun pertama-tama, kami akan menetapkan aturan penting yang harus diikuti saat membuat file shebang: <br><br><ul><li>  Jangan mencampur kode Java dengan kode bahasa skrip dari skrip shell OS Anda. <br></li><li>  Jika Anda perlu menambahkan opsi mesin virtual, Anda harus menentukan <code>--source</code> opsi pertama setelah nama file yang dapat dieksekusi di file shebang.  Opsi-opsi mesin virtual meliputi: <code>--class-path</code> , <code>--module-path</code> <code>--add-exports</code> , <code>--add-exports</code> , <code>--add-modules</code> , <code>--limit-modules</code> <code>--patch-module</code> , <code>--patch-module</code> , - <code>--upgrade-module-path</code> , serta variasi apa pun daripadanya.  Juga termasuk dalam daftar ini adalah opsi baru <code>--enable-preview</code> , dijelaskan dalam <a href="https://openjdk.java.net/jeps/12">JEP 12</a> . <br></li><li>  Anda harus menentukan versi Java yang digunakan dalam file sumber. <br></li><li>  Baris pertama file harus dimulai dengan karakter shebang (#!).  Sebagai contoh: <br> <code>#!/path/to/java --source &lt;vrsion&gt;</code> </li> <li>  Untuk file sumber Java, Anda TIDAK HARUS menggunakan mekanisme shebang untuk mengeksekusi file yang sesuai dengan konvensi penamaan standar (diakhiri dengan .java) <br></li><li>  Anda harus menandai file sebagai executable dengan perintah: <br>  <code>chmod +x &lt;Filname&gt;.&lt;Extnsion&gt;</code> . <br></li></ul><br>  Mari kita membuat file-shebang (program skrip), yang akan mencantumkan isi direktori yang namanya akan diteruskan sebagai parameter.  Jika tidak ada parameter yang dilewati, direktori saat ini akan diambil secara default. <br><br><pre> <code class="java hljs">#!/usr/bin/java --source <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.file.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> java.lang.System.*; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DirectoryLister</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ vardirName = <span class="hljs-string"><span class="hljs-string">"."</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( args == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || args.length&lt; <span class="hljs-number"><span class="hljs-number">1</span></span> ){ err.println(<span class="hljs-string"><span class="hljs-string">"Will list the current directory"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { dirName = args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } Files .walk(Paths.get(dirName)) .forEach(out::println); } }</code> </pre> <br>  Simpan kode ke file yang disebut dirlist tanpa ekstensi, dan kemudian tandai sebagai executable: <code>mohamed_taman:code$ chmod +x dirlist</code> . <br><br>  Jalankan file: <br><br><pre> <code class="java hljs">mohamed_taman:code$ ./dirlist Will list the current directory . ./PalindromeChecker.java ./greater ./UsersHttpClient.java ./HelloWorld.java ./Greater.java ./dirlist</code> </pre> <br>  Jalankan lagi menggunakan perintah yang melewati direktori induk, dan periksa hasilnya. <br><br><pre> <code class="java hljs">mohamed_taman:code$ ./dirlist ../</code> </pre> <br>  Catatan: ketika mengevaluasi kode sumber, penerjemah mengabaikan garis shebang (baris pertama).  Dengan demikian, file shebang dapat secara eksplisit disebut menggunakan peluncur, misalnya, dengan opsi tambahan: <br><br><pre> <code class="java hljs">$ java -Dtrace=<span class="hljs-keyword"><span class="hljs-keyword">true</span></span> --source <span class="hljs-number"><span class="hljs-number">11</span></span> dirlist</code> </pre> <br>  Ini juga harus diperhatikan: jika file skrip ada di direktori saat ini, maka Anda dapat menjalankannya seperti ini: <br><br><pre> <code class="java hljs">$ ./dirlist</code> </pre> <br>  Dan jika skrip terletak di direktori yang jalurnya ditentukan di PATH pengguna, maka Anda dapat menjalankannya seperti ini: <br><br><pre> <code class="java hljs">$ dirlist</code> </pre> <br>  Dan akhirnya, saya akan memberi Anda beberapa tips yang perlu diingat saat menggunakan skrip. <br><br><h2>  Kiat </h2><br><ol><li>  Beberapa opsi yang akan Anda lewati ke javac mungkin tidak diteruskan (atau tidak dikenali) ke <code>java</code> , misalnya, opsi <code>-Werror</code> atau <code>-Werror</code> . <br></li><li>  Jika ada file .class dan .java di classpath, maka peluncur akan memaksa Anda untuk menggunakan file kelas. <br><br><pre> <code class="java hljs">mohamed_taman:code$ javac HelloUniverse.java mohamed_taman:code$ java HelloUniverse.java error: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">found</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">on</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">application</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">path</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HelloUniverse</span></span></span></span></code> </pre> <br></li><li>  Waspadai kemungkinan konflik antara kelas dan nama paket.  Lihatlah struktur direktori ini: <br><br><pre> <code class="java hljs">mohamed_taman:code$ tree . ├── Greater.java ├── HelloUniverse │ ├── java.class │ └── java.java ├── HelloUniverse.java ├── PalindromeChecker.java ├── UsersHttpClient.java ├── dirlist └── greater</code> </pre> <br>  Perhatikan dua <code>java.java</code> dalam paket HelloUniverse dan file HelloUniverse.java di direktori yang sama.  Jika Anda mencoba menjalankan: <br><br><pre> <code class="java hljs">mohamed_taman:code$ java HelloUniverse.java</code> </pre> <br>  lalu file mana yang akan dieksekusi pertama dan yang kedua?  Peluncur tidak lagi merujuk ke file kelas dalam paket HelloUniverse.  Sebaliknya, itu akan memuat dan mengeksekusi file HelloUniverse.java yang asli, mis. File tersebut akan diluncurkan di direktori saat ini. <br></li></ol><br>  File Shebang membuka banyak kemungkinan untuk membuat skrip untuk mengotomatisasi semua jenis tugas menggunakan alat Java. <br><br><h2>  Ringkasan </h2><br>  Dimulai dengan Java SE 11 dan untuk pertama kalinya dalam sejarah pemrograman, Anda dapat langsung menjalankan skrip dengan kode Java tanpa kompilasi.  Ini memungkinkan Anda untuk menulis skrip Java dan menjalankannya dari baris * nix-command. <br><br>  Lakukan percobaan dengan fitur ini dan bagikan pengetahuan Anda dengan orang lain. <br><br><h2>  Sumber yang bermanfaat </h2><br><ul><li>  <a href="https://openjdk.java.net/jeps/330">JEP 330: Luncurkan Program Kode-Sumber File Tunggal</a> <br></li><li>  <a href="https://openjdk.java.net/jeps/12">JEP 12: Fitur Pratinjau Bahasa dan VM</a> <br></li><li>  <a href="https://docs.oracle.com/en/java/javase/11/">Dokumentasi JDK 11</a> <br></li><li>  <a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk12-downloads-5295953.html">Java SE Development Kit 12.0.1</a> <br></li><li>  <a href="https://reqres.in/">Uji front-end Anda terhadap API nyata</a> <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id483888/">https://habr.com/ru/post/id483888/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id483874/index.html">Publikasi kode VVVVVV menunjukkan betapa tidak sopannya permainan yang ada di dalamnya</a></li>
<li><a href="../id483876/index.html">Budaya perusahaan merah adalah masalah utama bisnis Rusia (Bagian 1)</a></li>
<li><a href="../id483880/index.html">Bagaimana pemrograman hari ini berbeda dari pemrograman 20 tahun yang lalu?</a></li>
<li><a href="../id483882/index.html">Pengujian unit dalam arsitektur Clean Swift</a></li>
<li><a href="../id483886/index.html">Set-top box Movix Pro: dari perangkat lunak hingga kacang terakhir</a></li>
<li><a href="../id483894/index.html">Pertemuan Avito Kafka: konektor, integrasi, awan</a></li>
<li><a href="../id483896/index.html">Cara meluncurkan produk sendiri jika Anda seorang pengembang: Kiat dari pencipta Laravel Taylor Otvel. Bagian 2: Menemukan Ide</a></li>
<li><a href="../id483898/index.html">Documents sebagai kode yang menentang atau bersama dengan Confluence? Gambaran umum dari beberapa cara untuk menerbitkan dari repositori ke Confluence</a></li>
<li><a href="../id483906/index.html">Terminal seluler dalam sistem kontrol akses</a></li>
<li><a href="../id483910/index.html">Teori Informasi Visual (Bagian 1)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>