<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòò üïñ ü§üüèª Jenis Referensi Nullable dalam C # 8.0 dan Analisis Statis üëáüèæ üë¶üèº üõãÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bukan rahasia lagi bahwa Microsoft telah bekerja pada rilis versi kedelapan C # untuk beberapa waktu. Dalam rilis Visual Studio 2019 baru-baru ini, ve...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jenis Referensi Nullable dalam C # 8.0 dan Analisis Statis</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/455230/"><p><img src="https://habrastorage.org/getpro/habr/post_images/523/17b/496/52317b4960a8b063bc7b6541e4e2666d.png" alt="Gambar 9"></p><br>  Bukan rahasia lagi bahwa Microsoft telah bekerja pada rilis versi kedelapan C # untuk beberapa waktu.  Dalam rilis Visual Studio 2019 baru-baru ini, versi bahasa baru (C # 8.0) sudah tersedia, tetapi sejauh ini hanya sebagai rilis beta.  Paket versi baru ini memiliki beberapa fitur, yang implementasinya mungkin tidak terlalu jelas, atau lebih tepatnya, tidak terlalu diharapkan.  Salah satu inovasi ini adalah kemampuan untuk menggunakan tipe Referensi Nullable.  Arti yang dinyatakan dari inovasi ini adalah perang melawan Null Reference Exception (NRE). <br><a name="habracut"></a><br>  Kami senang bahasanya berkembang dan fitur-fitur baru akan membantu pengembang.  Secara kebetulan, dalam penganalisis PVS-Studio kami untuk C #, kemampuan untuk mendeteksi NRE yang persis sama dalam kode relatif baru saja diperluas.  Dan kami bertanya pada diri sendiri - apakah ada gunanya sekarang untuk analisis statis pada umumnya, dan untuk PVS-Studio pada khususnya, untuk mencoba mencari dereferencing referensi nol, jika, setidaknya dalam kode baru menggunakan Referensi Nullable, dereferencing seperti itu akan menjadi "mustahil" ?  Mari kita coba jawab pertanyaan ini. <br><br><h2>  Pro dan Kontra Inovasi </h2><br>  Untuk memulainya, perlu diingat bahwa dalam versi beta terbaru dari C # 8.0, tersedia pada saat penulisan ini, Referensi Nullable dimatikan secara default, mis.  perilaku tipe referensi tidak akan berubah. <br><br>  Apa jenis referensi yang dapat dibatalkan dalam C # 8.0 jika Anda memasukkannya?  Ini adalah tipe referensi lama yang baik yang sama dengan perbedaan yang variabel-variabel dari tipe ini sekarang harus ditandai dengan '?'  (mis. <i>string?</i> ), mirip dengan yang sudah dilakukan untuk <i>Nullable &lt;T&gt;</i> , mis.  jenis signifikan yang dapat dibatalkan (mis. <i>int?</i> ).  Namun, sekarang <i>string yang</i> sama tanpa '?'  sudah mulai ditafsirkan sebagai referensi yang tidak dapat dibatalkan, mis.  ini adalah tipe referensi yang variabelnya tidak dapat berisi nilai <i>nol</i> . <br><br>  Null Reference Exception adalah salah satu pengecualian yang paling menjengkelkan karena tidak banyak menyebutkan sumber masalahnya, terutama jika ada beberapa referensi dalam satu baris dalam metode yang melempar pengecualian.  Kemampuan untuk melarang lewat <i>nol</i> ke variabel referensi tipe terlihat baik-baik saja, tetapi jika <i>nol</i> sebelumnya diteruskan ke metode, dan beberapa logika eksekusi lebih lanjut terkait dengan ini, lalu apa yang harus saya lakukan sekarang?  Tentu saja, Anda dapat melewatkan nilai literal, konstanta, atau hanya ‚Äútidak mungkin‚Äù alih-alih <i>nol</i> , yang, menurut logika program, tidak dapat ditugaskan ke variabel ini di tempat lain.  Namun, jatuhnya seluruh program dapat diganti dengan eksekusi salah "diam" lebih lanjut.  Ini tidak selalu lebih baik daripada melihat kesalahan segera. <br><br>  Dan jika bukan melemparkan pengecualian?  Pengecualian yang berarti di tempat di mana terjadi kesalahan selalu lebih baik daripada <i>NRE di</i> tempat yang lebih tinggi atau lebih rendah di tumpukan.  Tapi itu baik jika kita berbicara tentang proyek kita sendiri, di mana kita dapat memperbaiki konsumen dan memasukkan <i>blok uji coba,</i> dan ketika mengembangkan perpustakaan menggunakan Referensi (non) Nullable, kami bertanggung jawab bahwa beberapa metode selalu mengembalikan nilai.  Dan itu tidak selalu bahkan dalam kode asli yang akan (setidaknya sederhana) untuk menggantikan kembali <i>nol</i> untuk melempar pengecualian (terlalu banyak kode dapat dipengaruhi). <br><br>  Anda dapat mengaktifkan Referensi Nullable di seluruh tingkat proyek dengan menambahkan properti <i>NullableContextOptions</i> dengan nilai <i>aktifkan</i> padanya, atau pada tingkat file menggunakan arahan preprocessor: <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable string cantBeNull = string.Empty; string? canBeNull = null; cantBeNull = canBeNull!;</span></span></code> </pre> <br>  Jenis sekarang akan lebih visual.  Dengan tanda tangan metode, adalah mungkin untuk menentukan perilakunya, apakah mengandung cek untuk <i>nol</i> atau tidak, itu bisa mengembalikan <i>nol</i> atau tidak bisa.  Sekarang, jika Anda mencoba mengakses variabel referensi yang dapat dibatalkan tanpa memeriksa, kompiler akan menghasilkan peringatan. <br><br>  Cukup nyaman saat menggunakan perpustakaan pihak ketiga, tetapi ada situasi dengan kemungkinan kesalahan informasi.  Faktanya adalah bahwa melewati <i>null</i> masih dimungkinkan, misalnya, menggunakan operator null-forgiving baru (!).  Yaitu  hanya saja dengan bantuan satu tanda seru, Anda dapat mematahkan semua asumsi lebih lanjut yang akan dibuat tentang antarmuka menggunakan variabel-variabel ini: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable String GetStr() { return _count &gt; 0 ? _str : null!; } String str = GetStr(); var len = str.Length;</span></span></code> </pre> <br>  Ya, dapat dikatakan bahwa menulis dengan cara ini salah, dan tidak ada yang akan melakukan itu, tetapi selama kesempatan ini tetap ada, tidak mungkin lagi untuk sepenuhnya bergantung hanya pada kontrak yang diberlakukan oleh antarmuka metode ini (tidak dapat mengembalikan nol). <br><br>  Dan Anda dapat, dengan cara, menulis hal yang sama dengan bantuan beberapa operator!, Karena C # sekarang memungkinkan Anda untuk menulis seperti ini (dan kode ini dikompilasi sepenuhnya): <br><pre> <code class="cpp hljs">cantBeNull = canBeNull!!!!!!!;</code> </pre> <br>  Yaitu  kami ingin menekankan lebih lanjut: perhatikan - ini bisa menjadi <i>nol</i> !!!  (kami di tim menyebutnya pemrograman "emosional").  Bahkan, kompiler (dari Roslyn), ketika membangun sintaksis kode, menafsirkan operator!  mirip dengan tanda kurung sederhana, sehingga jumlah mereka, seperti halnya dengan tanda kurung, tidak terbatas.  Meskipun, jika Anda menulis banyak dari mereka, kompiler dapat "dibuang".  Mungkin ini akan berubah di versi final C # 8.0. <br><br>  Dengan cara yang sama, Anda dapat mem-bypass peringatan kompiler ketika mengakses variabel referensi yang dapat dibatalkan tanpa memeriksa: <br><pre> <code class="cpp hljs">canBeNull!.ToString();</code> </pre> <br>  Anda dapat menulis lebih emosional: <br><pre> <code class="cpp hljs">canBeNull!!!?.ToString();</code> </pre> <br>  Sintaks ini sebenarnya sulit dibayangkan dalam proyek nyata, menempatkan operator <i>null-maaf</i> kepada kompiler: semuanya baik-baik saja di sini, tidak diperlukan verifikasi.  Menambahkan operator elvis kami katakan: tetapi secara umum mungkin tidak normal, mari kita periksa. <br><br>  Dan sekarang muncul pertanyaan yang sah - mengapa, jika konsep tipe referensi yang tidak dapat <i>dibatalkan</i> menyiratkan bahwa variabel jenis ini tidak dapat mengandung <i>nol</i> , dapatkah kita masih menulisnya dengan mudah di sana?  Faktanya adalah bahwa "di bawah tenda", pada tingkat kode IL, jenis referensi kami yang tidak dapat dibatalkan tetap ... semua jenis referensi "biasa" yang sama.  Dan seluruh sintaks nullability sebenarnya hanya merupakan anotasi untuk penganalisa statis yang dibangun ke dalam kompiler (dan, menurut pendapat kami, bukan penganalisa yang paling nyaman, tetapi lebih pada nanti)  Menurut pendapat kami, memasukkan sintaks baru dalam bahasa hanya sebagai anotasi untuk alat pihak ketiga (bahkan jika itu dibangun ke dalam kompiler) bukan solusi yang paling "indah", karena  untuk seorang programmer yang menggunakan bahasa ini bahwa ini hanya sebuah anotasi mungkin tidak jelas sama sekali - lagipula, sintaks yang sangat mirip untuk struktur nullable bekerja dengan cara yang sangat berbeda. <br><br>  Kembali ke bagaimana masih mungkin untuk "mematahkan" jenis Referensi Nullable.  Pada saat penulisan, jika ada beberapa proyek dalam solusi, ketika melewati dari metode yang dinyatakan dalam satu proyek variabel referensi, misalnya dari tipe <i>String,</i> ke metode dari proyek lain di mana <i>NullableContextOptions</i> diaktifkan <i>,</i> kompiler akan memutuskan bahwa itu sudah menjadi String yang tidak dapat dibatalkan, dan tidak akan memberi peringatan.  Dan ini terlepas dari sejumlah besar atribut <i>[Nullable (1)] yang</i> ditambahkan ke setiap metode bidang dan kelas dalam kode IL ketika Referensi Nullable dihidupkan <i>.</i>  Ngomong-ngomong, atribut-atribut ini harus diperhitungkan jika Anda bekerja dengan daftar atribut melalui refleksi, mengandalkan keberadaan hanya atribut-atribut yang Anda tambahkan sendiri. <br><br>  Situasi ini dapat menimbulkan masalah tambahan saat mengonversi basis kode besar ke Referensi Nullable.  Kemungkinan besar proses ini akan bertahap, proyek per proyek.  Tentu saja, dengan pendekatan perubahan yang kompeten, Anda dapat secara bertahap beralih ke fungsional baru, tetapi jika Anda sudah memiliki konsep kerja, setiap perubahan di dalamnya berbahaya dan tidak diinginkan (berfungsi - jangan disentuh!).  Itu sebabnya ketika menggunakan penganalisa PVS-Studio tidak perlu mengedit kode sumber atau entah bagaimana menandainya untuk mendeteksi <i>NRE</i> potensial.  Untuk memeriksa tempat-tempat di mana <i>NullReferenceException</i> dapat terjadi <i>,</i> Anda hanya perlu memulai penganalisis dan melihat peringatan V3080.  Tidak perlu mengubah properti proyek atau kode sumber.  Tidak perlu menambahkan arahan, atribut, atau operator.  Tidak perlu mengubah kode Anda. <br><br>  Dengan dukungan tipe Referensi Nullable dalam penganalisa PVS-Studio, kami menghadapi pilihan - haruskah penganalisa menafsirkan variabel referensi yang tidak dapat dibatalkan sebagai nilai yang selalu tidak nol?  Setelah mempelajari masalah kemungkinan untuk "memecah" jaminan ini, kami sampai pada kesimpulan bahwa tidak ada - penganalisa seharusnya tidak membuat asumsi seperti itu.  Memang, bahkan jika tipe referensi non-nullable digunakan di mana-mana dalam proyek, penganalisa dapat melengkapi penggunaannya dengan hanya menemukan situasi di mana nilai <i>nol</i> dapat muncul dalam variabel seperti itu. <br><br><h2>  Bagaimana PVS-Studio mencari Pengecualian Referensi Null </h2><br>  Mekanisme aliran data dalam C # analyzer PVS-Studio memantau nilai-nilai variabel yang mungkin selama analisis.  Secara khusus, PVS-Studio juga melakukan analisis antar prosedur, yaitu  Mencoba menentukan nilai yang mungkin dikembalikan oleh metode, serta metode yang dipanggil dalam metode ini, dll.  Antara lain, penganalisa mengingat variabel yang berpotensi menjadi <i>nol</i> .  Jika di masa depan penganalisa melihat dereferencing tanpa memeriksa variabel seperti itu, sekali lagi, baik dalam kode saat ini sedang diperiksa atau di dalam metode yang disebut dalam kode ini, peringatan V3080 tentang potensi Pengecualian Referensi Null akan dikeluarkan. <br><br>  Pada saat yang sama, ide utama yang mendasari diagnosis ini adalah bahwa penganalisa hanya akan bersumpah jika melihat suatu tempat penugasan <i>nol</i> ke variabel.  Ini adalah perbedaan utama antara perilaku diagnostik ini dan penganalisa yang dibangun ke dalam kompiler yang bekerja dengan tipe Referensi Nullable.  Alat analisis yang dibangun ke dalam kompiler akan bersumpah pada setiap referensi variabel variabel nullable yang tidak diverifikasi dari jenisnya, kecuali, tentu saja, alat analisis ini ‚Äúditipu‚Äù oleh operator! dengan cara lain, benar-benar alat analisis apa pun dapat digunakan, terutama jika Anda menetapkan sendiri tujuan tersebut, dan PVS-Studio tidak terkecuali). <br><br>  PVS-Studio bersumpah hanya jika melihat <i>nol</i> (dalam konteks lokal, atau berasal dari suatu metode).  Pada saat yang sama, bahkan jika variabel tersebut adalah variabel referensi yang tidak dapat dibatalkan, perilaku penganalisa tidak akan berubah - itu masih akan bersumpah jika melihat bahwa nol ditulis untuk itu.  Menurut kami, pendekatan ini lebih tepat (atau, paling tidak, nyaman bagi pengguna penganalisa)  itu tidak memerlukan "mencakup" seluruh kode dengan cek <i>nol</i> untuk menemukan referensi potensial - ini bisa dilakukan sebelumnya, tanpa Referensi Nullable, misalnya, dengan kontrak yang sama.  Selain itu, penganalisa sekarang dapat digunakan untuk kontrol tambahan atas variabel referensi yang tidak dapat dibatalkan.  Jika mereka digunakan "dengan jujur", dan mereka tidak pernah ditugaskan nol - analis akan tetap diam.  Jika null ditugaskan dan variabel ditereferensi tanpa memeriksa, penganalisis memperingatkan tentang hal ini dengan pesan V3080: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable String GetStr() { return _count &gt; 0 ? _str : null!; } String str = GetStr(); var len = str.Length; &lt;== V3080: Possible null dereference. Consider inspecting </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'str'</span></span></span></span></code> </pre> <br><br>  Mari kita perhatikan beberapa contoh pemicu seperti diagnostik V3080 dalam kode Roslyn itu sendiri.  Kami telah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memeriksa proyek ini</a> belum lama ini, tetapi kali ini kami akan mempertimbangkan hanya pemicu Null Reference Exception potensial yang tidak ada dalam artikel sebelumnya.  Mari kita lihat bagaimana penganalisa PVS-Studio dapat menemukan potensi referensi referensi nol, dan bagaimana tempat-tempat ini dapat diperbaiki menggunakan sintaks Referensi Nullable baru. <br><br>  <i>V3080 [CWE-476] Kemungkinan null dereference di dalam metode.</i>  <i>Pertimbangkan memeriksa argumen 2: chainedTupleType.</i>  <i>Microsoft.CodeAnalysis.CSharp TupleTypeSymbol.cs 244</i> <br><pre> <code class="cpp hljs">NamedTypeSymbol chainedTupleType; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_underlyingType.Arity &lt; TupleTypeSymbol.RestPosition) { .... chainedTupleType = null; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Create(ConstructTupleUnderlyingType(firstTupleType, chainedTupleType, newElementTypes), elementNames: _elementNames);</code> </pre> <br>  Seperti yang Anda lihat, variabel <i>chainedTupleType</i> bisa nol di salah satu cabang eksekusi kode.  Kemudian <i>chainedTupleType</i> dilewatkan di dalam metode <i>ConstructTupleUnderlyingType,</i> dan digunakan di sana dengan verifikasi melalui <i>Debug.Assert</i> .  Situasi ini sangat umum di Roslyn, namun, perlu diingat bahwa <i>Debug.Assert</i> dihapus dalam versi rilis majelis.  Oleh karena itu, penganalisa masih menganggap dereferencing di dalam metode <i>ConstructTupleUnderlyingType</i> berbahaya.  Selanjutnya, kami memberikan tubuh metode ini, di mana dereferencing terjadi: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> NamedTypeSymbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConstructTupleUnderlyingType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( NamedTypeSymbol firstTupleType, NamedTypeSymbol chainedTupleTypeOpt, ImmutableArray&lt;TypeWithAnnotations&gt; elementTypes)</span></span></span><span class="hljs-function"> </span></span>{ Debug.Assert (chainedTupleTypeOpt is null == elementTypes.Length &lt; RestPosition); .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (loop &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... currentSymbol = chainedTupleTypeOpt.Construct(chainedTypes); loop--; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentSymbol; }</code> </pre> <br>  Apakah penganalisa harus mempertimbangkan Assert seperti itu sebenarnya merupakan poin yang dapat diperdebatkan (beberapa pengguna kami menginginkannya melakukan ini), karena kontrak dari System.Diagnostics.Contracts, misalnya, penganalisa sekarang mempertimbangkan.  Saya hanya akan memberi tahu Anda sebuah contoh kecil dari penggunaan Roslyn yang sama di penganalisa kami.  Baru-baru ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kami mendukung versi baru Visual Studio</a> , dan pada saat yang sama memperbarui penganalisis Roslyn ke versi 3.  Setelah itu, penganalisa mulai jatuh ketika memeriksa kode tertentu yang sebelumnya tidak pernah crash.  Pada saat yang sama, penganalisa mulai tidak berada dalam kode kita, tetapi di dalam kode Roslyn itu sendiri - untuk jatuh dengan Null Reference Exception.  Dan debugging lebih lanjut menunjukkan bahwa di tempat Roslyn sekarang jatuh, tepat beberapa baris di atas, ada pemeriksaan <i>nol yang</i> sama melalui <i>Debug.Assert</i> .  Dan dia, seperti yang kita lihat, tidak menyelamatkan. <br><br>  Ini adalah contoh masalah yang sangat bagus dengan Referensi Nullable <i>,</i> karena kompilator menganggap <i>Debug. Masukkan</i> cek yang valid dalam konfigurasi apa pun.  Yaitu, jika Anda cukup mengaktifkan <i>#nullable aktifkan</i> dan tandai argumen <i>chainedTupleTypeOpt</i> sebagai referensi yang dapat <i>dibatalkan</i> <i>,</i> tidak akan ada peringatan kompiler di lokasi dereferensi di metode <i>ConstructTupleUnderlyingType</i> . <br><br>  Pertimbangkan contoh pemicu PVS-Studio berikut ini. <br><br>  <i>V3080 Kemungkinan null dereference.</i>  <i>Pertimbangkan untuk memeriksa 'efektifRuleset'.</i>  <i>RuleSet.cs 146</i> <br><pre> <code class="cpp hljs">var effectiveRuleset = ruleSet.GetEffectiveRuleSet(includedRulesetPaths); effectiveRuleset = effectiveRuleset.WithEffectiveAction(ruleSetInclude.Action); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsStricterThan(effectiveRuleset.GeneralDiagnosticOption, ....)) effectiveGeneralOption = effectiveRuleset.GeneralDiagnosticOption;</code> </pre><br>  Peringatan ini mencatat bahwa memanggil metode <i>WithEffectiveAction</i> dapat mengembalikan <i>nol</i> , tetapi hasilnya digunakan tanpa memeriksa ( <i>efektifRuleset.GeneralDiagnosticOption</i> ).  Badan metode <i>WithEffectiveAction</i> , yang dapat mengembalikan nol, ditulis ke variabel <i>efektifRuleset</i> : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RuleSet </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WithEffectiveAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ReportDiagnostic action)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_includes.IsEmpty) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(....); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Suppress: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuleSet(....); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } }</code> </pre> <br><br>  Jika Anda mengaktifkan mode Referensi Nullable untuk metode <i>GetEffectiveRuleSet</i> , kita akan memiliki dua tempat di mana kita perlu mengubah perilaku.  Karena ada pengecualian melempar dalam metode di atas, logis untuk menganggap bahwa pemanggilan metode dibungkus dalam <i>blok try-catch</i> dan itu akan benar menulis ulang metode, melemparkan pengecualian bukannya mengembalikan nol.  Tetapi memanjat tantangan, kita melihat bahwa intersepsi itu tinggi dan konsekuensinya bisa sangat tidak terduga.  Mari kita lihat variabel consumer <i>efektifRuleset</i> - metode <i>IsStricterThan</i> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsStricterThan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ReportDiagnostic action1, ReportDiagnostic action2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action2) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Suppress: ....; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Warn: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> action1 == ReportDiagnostic.Error; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Error: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  Seperti yang Anda lihat, ini adalah saklar sederhana untuk dua enumerasi dengan kemungkinan nilai enumerasi <i>ReportDiagnostic.Default</i> .  Jadi yang terbaik adalah menulis ulang panggilan sebagai berikut: <br><br>  <i>Tanda</i> tangan <i>WithEffectiveAction</i> akan berubah: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable public RuleSet? WithEffectiveAction(ReportDiagnostic action)</span></span></code> </pre> <br>  panggilan akan terlihat seperti ini: <br><pre> <code class="cpp hljs">RuleSet? effectiveRuleset = ruleSet.GetEffectiveRuleSet(includedRulesetPaths); effectiveRuleset = effectiveRuleset?.WithEffectiveAction(ruleSetInclude.Action); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsStricterThan(effectiveRuleset?.GeneralDiagnosticOption ?? ReportDiagnostic.Default, effectiveGeneralOption)) effectiveGeneralOption = effectiveRuleset.GeneralDiagnosticOption;</code> </pre> <br>  mengetahui bahwa <i>IsStricterThan</i> hanya melakukan perbandingan - kondisinya dapat ditulis ulang, misalnya seperti ini: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effectiveRuleset == null || IsStricterThan(effectiveRuleset.GeneralDiagnosticOption, effectiveGeneralOption))</code> </pre> <br>  Mari kita beralih ke pesan berikutnya dari penganalisa. <br><br>  <i>V3080 Kemungkinan null dereference.</i>  <i>Pertimbangkan untuk memeriksa 'propertySymbol'.</i>  <i>BinderFactory.BinderFactoryVisitor.cs 372</i> <br><pre> <code class="cpp hljs">var propertySymbol = GetPropertySymbol(parent, resultBinder); var accessor = propertySymbol.GetMethod; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)accessor != null) resultBinder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InMethodBinder(accessor, resultBinder);</code> </pre> <br>  Penggunaan lebih lanjut dari variabel <i>propertySymbol</i> harus diperhitungkan ketika mengoreksi peringatan penganalisa. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> SourcePropertySymbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPropertySymbol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( BasePropertyDeclarationSyntax basePropertyDeclarationSyntax, Binder outerBinder)</span></span></span><span class="hljs-function"> </span></span>{ .... NamedTypeSymbol container = GetContainerType(outerBinder, basePropertyDeclarationSyntax); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)container == null) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (SourcePropertySymbol)GetMemberSymbol(propertyName, basePropertyDeclarationSyntax.Span, container, SymbolKind.Property); }</code> </pre> <br>  Metode <i>GetMemberSymbol</i> juga dapat mengembalikan <i>nol</i> dalam beberapa kasus. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Symbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMemberSymbol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> memberName, TextSpan memberSpan, NamedTypeSymbol container, SymbolKind kind)</span></span></span><span class="hljs-function"> </span></span>{ foreach (Symbol sym in container.GetMembers(memberName)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sym.Kind != kind) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sym.Kind == SymbolKind.Method) { .... var implementation = ((MethodSymbol)sym).PartialImplementationPart; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)implementation != null) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (InSpan(implementation.Locations[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.syntaxTree, memberSpan)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> implementation; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (InSpan(sym.Locations, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.syntaxTree, memberSpan)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sym; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; }</code> </pre> <br>  Menggunakan jenis referensi yang dapat dibatalkan, panggilan akan berubah seperti ini: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable SourcePropertySymbol? propertySymbol = GetPropertySymbol(parent, resultBinder); MethodSymbol? accessor = propertySymbol?.GetMethod; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((object)accessor != null) resultBinder = new InMethodBinder(accessor, resultBinder);</span></span></code> </pre> <br>  Cukup sederhana ketika Anda tahu di mana harus memperbaikinya.  Analisis statis dengan mudah menemukan potensi kesalahan ini dengan mendapatkan semua nilai bidang yang mungkin di semua rantai panggilan prosedur. <br><br>  <i>V3080 Kemungkinan null dereference.</i>  <i>Pertimbangkan untuk memeriksa 'simpleName'.</i>  <i>CSharpCommandLineParser.cs 1556</i> <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> simpleName; simpleName = PathUtilities.RemoveExtension( PathUtilities.GetFileName(sourceFiles.FirstOrDefault().Path)); outputFileName = simpleName + outputKind.GetDefaultExtension(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (simpleName.Length == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; !outputKind.IsNetModule()) ....</code> </pre> <br>  Masalahnya ada di baris dengan memeriksa <i>simpleName. Panjang.</i>  <i>simpleName</i> adalah hasil dari seluruh rangkaian metode dan mungkin <i>nol</i> .  Ngomong-ngomong, demi rasa ingin tahu, Anda dapat melihat metode <i>RemoveExtension</i> dan menemukan perbedaan dari <i>Path.GetFileNameWithoutExtension.</i>  Di sini kita dapat membatasi diri untuk memeriksa <i>simpleName! = Null</i> , tetapi dalam konteks tautan bukan nol, kode akan terlihat seperti ini: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable public static string? RemoveExtension(string path) { .... } string simpleName;</span></span></code> </pre> <br>  Panggilan akan terlihat seperti ini: <br><pre> <code class="cpp hljs">simpleName = PathUtilities.RemoveExtension( PathUtilities.GetFileName(sourceFiles.FirstOrDefault().Path)) ?? String.Empty;</code> </pre> <br><h2>  Kesimpulan </h2><br>  Jenis referensi Nullable dapat sangat membantu dalam perencanaan arsitektur yang dibangun dari awal, tetapi pengerjaan ulang kode yang ada berpotensi membutuhkan banyak waktu dan perawatan, karena dapat menyebabkan banyak kesalahan halus.  Dalam artikel ini, kami tidak bermaksud untuk mencegah siapa pun dari menggunakan jenis Referensi Nullable di proyek kami.  Kami percaya bahwa inovasi ini umumnya bermanfaat untuk bahasa, meskipun bagaimana penerapannya dapat menimbulkan pertanyaan. <br><br>  Anda harus selalu mengingat keterbatasan yang melekat dalam pendekatan ini, dan bahwa mode Referensi Nullable yang dihidupkan tidak melindungi terhadap kesalahan dengan dereferencing tautan nol, dan jika digunakan secara tidak benar, itu bahkan dapat menyebabkan mereka.  Sebaiknya pertimbangkan penggunaan penganalisa statis modern, misalnya PVS-Studio, yang mendukung analisis antar-prosedur, sebagai alat tambahan yang, bersama-sama dengan Referensi Nullable, dapat melindungi Anda dari referensi referensi nol yang kosong.  Masing-masing pendekatan ini - baik analisis inter-prosedural mendalam dan anotasi tanda tangan metode (yang pada dasarnya membuat Referensi Nullable), memiliki kelebihan dan kekurangan.  Penganalisa akan memungkinkan Anda untuk mendapatkan daftar tempat-tempat yang berpotensi berbahaya, dan juga, ketika mengubah kode yang ada, melihat semua konsekuensi dari perubahan tersebut.  Jika Anda menetapkan <i>nol</i> dalam hal apa pun, penganalisa harus segera menunjukkan semua konsumen variabel, yang tidak diperiksa sebelum dereferencing. <br><br>  Anda dapat secara independen mencari beberapa kesalahan lain baik di proyek yang dipertimbangkan, dan di Anda sendiri.  Untuk melakukan ini, Anda hanya perlu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengunduh</a> dan mencoba penganalisa PVS-Studio. <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/898/3b6/5a7/8983b65a74adb29a2113eba12fbec3f1.png" align="left"></a> </p><br><br>  Jika Anda ingin berbagi artikel ini dengan audiens yang berbahasa Inggris, silakan gunakan tautan ke terjemahan: Paul Eremeev, Alexander Senichkin.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jenis referensi yang dapat dihapus dalam C # 8.0 dan analisis statis</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455230/">https://habr.com/ru/post/id455230/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455216/index.html">Pengukur kecepatan Doppler</a></li>
<li><a href="../id455218/index.html">Pendekatan Ekosistem untuk Teknologi Bisnis</a></li>
<li><a href="../id455224/index.html">Musik Jari: Mainkan Apa Pun Dengan Sphero's SpecDrums</a></li>
<li><a href="../id455226/index.html">Mengapa menerapkan ahli bahasa terapan?</a></li>
<li><a href="../id455228/index.html">The One Who Resurrected Duke Nukem: Wawancara dengan Randy Pitchford, Gearbox Wizard</a></li>
<li><a href="../id455234/index.html">Jenis referensi dapat dihapus dalam C # 8.0 dan analisis statis</a></li>
<li><a href="../id455236/index.html">Comodo mencabut sertifikat tanpa alasan</a></li>
<li><a href="../id455240/index.html">Menggunakan tingkat cacat yang ditolak untuk meningkatkan pelaporan kesalahan</a></li>
<li><a href="../id455242/index.html">Kurang telinga atau bagaimana tidak merusak suara dalam game dari awal</a></li>
<li><a href="../id455244/index.html">Komik "Soldering is Easy" dalam versi yang diperbarui (2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>