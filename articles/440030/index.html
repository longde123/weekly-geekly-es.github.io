<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌵 🧒 👇🏾 Identifique el bloqueo de PKH en un enrutador OpenWrt con WireGuard y DNSCrypt 👎🏿 🐬 🙇🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¿Cuál es la diferencia con materiales similares? 


- Implementación pura de OpenWrt 
- Usando WireGuard 
- La configuración del enrutador se organiza...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Identifique el bloqueo de PKH en un enrutador OpenWrt con WireGuard y DNSCrypt</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440030/"><h2 id="chem-otlichaetsya-ot-podobnyh-materialov">  ¿Cuál es la diferencia con materiales similares? </h2><br><ul><li>  Implementación pura de OpenWrt </li><li>  Usando WireGuard </li><li>  La configuración del enrutador se organiza usando configuraciones OpenWrt, y no un montón en un script </li><li>  Hay situaciones al reiniciar la red y reiniciar </li><li>  Consume pocos recursos de enrutador: las subredes bloqueadas están contenidas en iptables y no en tablas de enrutamiento.  Lo que le permite implementar este negocio incluso en dispositivos débiles </li><li>  Automatice la configuración con Ansible (no se requiere python en el enrutador) </li></ul><a name="habracut"></a><br><h2 id="videoversiya">  Versión de video </h2><br><iframe width="560" height="315" src="https://www.youtube.com/embed/GMvEF0PXN-w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="pochemu-openwrt-i-wireguard">  ¿Por qué OpenWrt y WireGuard? </h2><br><p>  OpenWrt está instalado en muchos modelos de enrutadores soho, está configurado y ampliado según lo desee su corazón.  Ahora muchos firmwares de enrutadores son complementos sobre OpenWrt. </p><br><p>  Wireguard se utiliza debido a su configuración rápida y fácil, y también debido a la alta velocidad de transmisión a través del túnel. </p><br><h2 id="nemnogo-o-wireguard">  Un poco sobre WireGuard </h2><br><p>  En nuestro caso, el servidor es un VPS fuera del ILV, el cliente es un enrutador OpenWrt en casa.  Cuando quieres ir a <del>  pornolab </del>  telegrama, su enrutador dirigirá el tráfico a través de un servidor con WireGuard. <br>  WireGuard genera una conexión de sitio a sitio, es decir  tanto el servidor como el cliente tienen el lado del servidor y el cliente de la configuración.  Si no está claro, quedará claro cuando vea la configuración. </p><br><p>  El servidor y el cliente tienen sus propias claves públicas y privadas. </p><br><h2 id="nastroyka-wireguard-na-servere">  Configurar WireGuard en el servidor </h2><br><p>  Estoy haciendo todo en Ubuntu 18.04, pero en la documentación oficial hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" title="instrucciones de instalación">instrucciones de instalación</a> para todos los sistemas operativos conocidos y no muy. </p><br><h3 id="ustanovka">  Instalación </h3><br><pre><code class="bash hljs">sudo add-apt-repository ppa:wireguard/wireguard</code> </pre> <br><blockquote>  Si ocurre un error <br><pre> <code class="bash hljs">sudo: add-apt-repository: <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> not found</code> </pre> <br><br>  Instalar software-properties-common: el paquete proporciona la capacidad de agregar y eliminar PPA <br><pre> <code class="bash hljs">sudo apt install software-properties-common</code> </pre> <br></blockquote><br><pre> <code class="bash hljs">sudo apt update sudo apt install wireguard-dkms wireguard-tools</code> </pre> <br><p>  Generamos claves para el servidor.  Guardaremos las claves en el directorio WireGuard para mayor comodidad. </p><br><pre> <code class="plaintext hljs">cd /etc/wireguard/ wg genkey | tee privatekey-server | wg pubkey &gt; publickey-server</code> </pre> <br><p>  En consecuencia, habrá una clave privada en el archivo del servidor de clave privada y una clave pública en el archivo del servidor de clave pública. <br>  También generamos inmediatamente una clave para el cliente: </p><br><pre> <code class="plaintext hljs">wg genkey | tee privatekey-client | wg pubkey &gt; publickey-client</code> </pre> <br><p><img src="https://habrastorage.org/webt/k4/xo/m5/k4xom503xmvyxdhjsvelqhaslxo.png"></p><br><h3 id="konfiguraciya">  Configuracion </h3><br><p>  La configuración se almacena en /etc/wireguard/wg0.conf.  El lado del servidor se ve así: </p><br><pre> <code class="bash hljs">[Interface] Address = 192.168.100.1 PrivateKey = privatekey-server ListenPort = 51820 PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o ens3 -j MASQUERADE PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o ens3 -j MASQUERADE</code> </pre> <br><p>  <strong>Dirección</strong> : dirección de la interfaz wg (dirección dentro del túnel) <br>  <strong>PrivateKey</strong> : clave privada (privatekey-server) <br>  <strong>ListenPort</strong> : el puerto en el que el servicio está esperando para conectarse </p><br><p>  Bueno, hacemos máscaras, porque usaremos este servidor para acceder a Internet <br>  Tenga en cuenta que el nombre de la interfaz en su caso puede diferir: </p><br><p>  Parte del cliente </p><br><pre> <code class="bash hljs">[Peer] PublicKey = publickey-client AllowedIPs = 192.168.100.3/24</code> </pre> <br><p>  <strong>PublicKey</strong> : la clave pública de nuestro enrutador (publickey-client) <br>  <strong>Las IP permitidas</strong> son las subredes que estarán disponibles a través de este túnel.  El servidor solo necesita acceso a la dirección del cliente. </p><br><p>  Ambas partes se almacenan en una configuración. </p><br><p>  Active el inicio automático al reiniciar: </p><br><pre> <code class="bash hljs">systemctl <span class="hljs-built_in"><span class="hljs-built_in">enable</span></span> wg-quick@wg0</code> </pre> <br><p>  Hacemos del servidor un enrutador: </p><br><pre> <code class="bash hljs">sysctl -w net.ipv4.ip_forward=1</code> </pre> <br><p>  Configura el cortafuegos.  Supongamos que solo tenemos WireGuard y ssh en nuestro servidor: </p><br><pre> <code class="bash hljs">sudo iptables -A INPUT -i lo -j ACCEPT sudo iptables -A INPUT -p udp -m udp --dport 51820 -j ACCEPT sudo iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT sudo iptables -A INPUT -p icmp -j ACCEPT sudo iptables -A INPUT -p tcp -m tcp --dport 22 -j ACCEPT sudo iptables -A INPUT -j DROP</code> </pre> <br><p>  Guarde la configuración de iptables: </p><br><pre> <code class="bash hljs">sudo apt-get install iptables-persistent sudo netfilter-persistent save</code> </pre> <br><p>  Levantamos la interfaz wg por primera vez manualmente: </p><br><pre> <code class="bash hljs">wg-quick up wg0</code> </pre> <br><p><img src="https://habrastorage.org/webt/1_/me/ai/1_meai1la87gto2qfa7vwmcfmju.png"></p><br><p>  El servidor WireGuard está listo. </p><br><p>  <strong>UPD 27/06/19</strong> Si su proveedor todavía usa PPoE, entonces necesita agregar una regla.  Gracias <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">denix123</a> </p><br><pre> <code class="plaintext hljs">iptables -t mangle -I POSTROUTING -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu</code> </pre> <br><h2 id="nastroyka-routera">  Configuración del enrutador </h2><br><p>  Estoy usando OpenWrt versión 18.06.1 en Xiaomi mi 3G y Asus RT-N16. </p><br><h3 id="logika-raboty-routera">  La lógica del enrutador </h3><br><p>  Cargamos las listas, las colocamos en iptables, iptables marca todas las direcciones de estas listas con un marcador 0x1.  Además, todos los paquetes marcados con 0x1 van a una tabla de enrutamiento separada, todos los paquetes que caen en esta tabla de enrutamiento pasan por la interfaz wg. </p><br><p><img src="https://habrastorage.org/webt/vy/rc/ji/vyrcjihaaozo-vzf1nkm9nlxpl0.gif"></p><br><h3 id="ustanovka-paketov">  Instalación de paquete </h3><br><p>  En cuanto al espacio ocupado en el flash, todo necesitará aproximadamente 0.9MB.  Si tiene un lugar muy malo, reemplace curl con wget y es posible que no necesite instalar dnscrypt-proxy. </p><br><p>  Ponemos paquetes.  En OpenWrt, esto es fácil de hacer a través del administrador de paquetes opkg: </p><br><pre> <code class="bash hljs">opkg update opkg install ipset wireguard curl</code> </pre> <br><h3 id="zagruzka-spiskov">  Descargar listas </h3><br><p>  Todo lo que se puede hacer a través de las características estándar de OpenWrt se hace a través de ellos.  Todo lo demás (excepto hotplug) lo puse en un pequeño script: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh START=99 dir=/tmp/lst mkdir -p $dir echo "Run download lists" curl -z $dir/subnet.lst https://antifilter.download/list/subnet.lst --output $dir/subnet.lst curl -z $dir/ipsum.lst https://antifilter.download/list/ipsum.lst --output $dir/ipsum.lst echo "Firewall restart" /etc/init.d/firewall restart</span></span></code> </pre> <br><p>  Las listas de subredes y direcciones prohibidas se obtienen por archivos.  Para ellos creamos un directorio en / tmp.  In / tmp: como es RAM, esta característica de OpenWrt es bastante conveniente.  No vale la pena volver a escribir algo en la ROM del enrutador. </p><br><p>  Bombeamos las listas con antifilter.download curl, el indicador z significa que curl descargará el archivo solo si el archivo remoto es diferente del archivo local o si no está allí, como es el caso al cargar el enrutador. </p><br><p>  <em>subnet.lst</em> : una lista de subredes bloqueadas; no cambia con frecuencia. <br>  <em>ipsum.lst</em> es una lista de direcciones bloqueadas, que se resume por máscara.  En lugar de 150 mil registros, obtenemos 15 mil, convenientemente. </p><br><p>  Después de tener los archivos, reiniciamos el firewall, esto es necesario para que ipset funcione y agregue listas a iptables, configuraremos ipset en / etc / config / firewall. </p><br><p>  Este script que agreguemos en /etc/init.d/ se llamará hirkn.  Hazlo ejecutable </p><br><pre> <code class="bash hljs">chmod +x /etc/init.d/hirkn</code> </pre> <br><p>  Ahora no solo tenemos un script, sino un servicio completo.  Para que comience en el arranque, hacemos un enlace simbólico en /etc/rc.d.  Lo necesitamos para comenzar después de todos los demás servicios, por lo que creamos el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" title="prefijo S99">prefijo S99</a> </p><br><pre> <code class="bash hljs">ln -s /etc/init.d/hirkn /etc/rc.d/S99hirkn</code> </pre> <br><p>  Las listas deben actualizarse de vez en cuando, agregamos registros en cron: </p><br><pre> <code class="bash hljs">crontab -e</code> </pre> <br><pre> <code class="bash hljs">0 4 * * * /etc/init.d/hirkn</code> </pre> <br><p>  Parece bastante suficiente actualizarlos una vez al día.  Tenga en cuenta que al agregar listas a ipset, la red se cae, en mi caso son 2 segundos. <br>  <strong>UPD</strong> : Si no desea descansos, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">sigo73</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Grayver</a> sugirieron en los comentarios cómo hacerlo. </p><br><p>  También encienda la corona, por defecto está deshabilitada: </p><br><pre> <code class="bash hljs">/etc/init.d/cron <span class="hljs-built_in"><span class="hljs-built_in">enable</span></span> /etc/init.d/cron start</code> </pre> <br><h3 id="konfiguraciya-tablicy-marshrutizacii">  Configuración de la tabla de enrutamiento </h3><br><p>  Cree una tabla de enrutamiento para el tráfico a través del túnel simplemente agregando la línea: </p><br><pre> <code class="bash hljs">99 vpn</code> </pre> <br><p>  al archivo / etc / iproute2 / rt_tables. </p><br><p>  Puede crear una ruta predeterminada para la tabla "vpn" a través de la interfaz wg con el comando: </p><br><pre> <code class="bash hljs">ip route add table vpn default dev wg0</code> </pre> <br><p>  Pero cuando reinicia la red, la ruta desaparece, por lo que creamos el archivo 30-rknroute en el directorio /etc/hotplug.d/iface/ con contenido simple: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh ip route add table vpn default dev wg0</span></span></code> </pre> <br><p>  Esto significa que cuando activa / desactiva las interfaces, se agregará nuestra ruta.  Y en consecuencia, esta ruta siempre estará registrada. </p><br><h3 id="konfiguraciya-seti">  Configuración de red </h3><br><p>  Necesitamos configurar WireGuard y la regla para paquetes etiquetados 0x1. </p><br><p>  La configuración de WireGuard se encuentra en / etc / config / network </p><br><p>  La parte del "servidor": </p><br><pre> <code class="bash hljs">config interface <span class="hljs-string"><span class="hljs-string">'wg0'</span></span> option private_key <span class="hljs-string"><span class="hljs-string">'privatekey-client'</span></span> list addresses <span class="hljs-string"><span class="hljs-string">'192.168.100.3/24'</span></span> option listen_port <span class="hljs-string"><span class="hljs-string">'51820'</span></span> option proto <span class="hljs-string"><span class="hljs-string">'wireguard'</span></span></code> </pre> <br><p>  <strong>private_key</strong> es el privatekey-client que generamos al configurar el servidor <br>  <strong>lista de direcciones</strong> - dirección de interfaz wg <br>  <strong>listen_port</strong> : el puerto en el que WireGuard acepta conexiones.  Pero la conexión se realizará a través del puerto en el servidor, por lo que aquí no abriremos el puerto en el firewall para ello. <br>  <strong>proto</strong> : especifique el protocolo para que openwrt entienda que esta es una configuración de WireGuard </p><br><p>  Parte "Cliente": </p><br><pre> <code class="bash hljs">config wireguard_wg0 option public_key <span class="hljs-string"><span class="hljs-string">'publickey-server'</span></span> option allowed_ips <span class="hljs-string"><span class="hljs-string">'0.0.0.0/0'</span></span> option route_allowed_ips <span class="hljs-string"><span class="hljs-string">'0'</span></span> option endpoint_host <span class="hljs-string"><span class="hljs-string">'wg-server-ip'</span></span> option persistent_keepalive <span class="hljs-string"><span class="hljs-string">'25'</span></span> option endpoint_port <span class="hljs-string"><span class="hljs-string">'51820'</span></span></code> </pre> <br><p>  <strong>public_key</strong> - clave del servidor publickey <br>  <strong>allowed_ips</strong> : subredes en las que el tráfico puede atravesar el túnel, en nuestro caso no se requieren restricciones, por lo tanto, 0.0.0.0/0 <br>  <strong>route_allowed_ips</strong> : una marca que realiza una ruta a través de la interfaz wg para las redes enumeradas desde el parámetro allow_ips.  En nuestro caso, esto no es necesario, iptables funciona <br>  <strong>endpoint_host</strong> - ip / url de nuestro servidor wg <br>  <strong>persistent_keepalive</strong> : intervalo de tiempo después del cual se envían los paquetes para admitir la conexión <br>  <strong>endpoint_port</strong> - puerto wireguard en el servidor </p><br><p>  También agregaremos una regla a la configuración de red que enviará todo el tráfico marcado 0x1 a la tabla de enrutamiento "vpn": </p><br><pre> <code class="bash hljs">config rule option priority <span class="hljs-string"><span class="hljs-string">'100'</span></span> option lookup <span class="hljs-string"><span class="hljs-string">'vpn'</span></span> option mark <span class="hljs-string"><span class="hljs-string">'0x1'</span></span></code> </pre> <br><h3 id="konfiguraciya-firewall">  Configuración de firewall </h3><br><p><del>  Agregamos dos reglas para marcar paquetes, no se ajustan a la sintaxis UCI de openwrt, por lo que las agregamos "tal cual" a /etc/firewall.user. </del><br>  <strong>UPD</strong> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Grayver</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" title="sugerido">sugirió</a> que encajan bastante bien.  Los configuramos después de configurar ipset </p><br><p>  La configuración del firewall está en / etc / config / firewall </p><br><p>  Agregue una zona para protección de cables.  En openwrt, las zonas son cadenas personalizadas en iptables.  Por lo tanto, se crea una zona con una / varias interfaces y las reglas ya están colgadas en ella.  La zona para wg se ve así: </p><br><pre> <code class="bash hljs">config zone option name <span class="hljs-string"><span class="hljs-string">'wg'</span></span> option family <span class="hljs-string"><span class="hljs-string">'ipv4'</span></span> option masq <span class="hljs-string"><span class="hljs-string">'1'</span></span> option output <span class="hljs-string"><span class="hljs-string">'ACCEPT'</span></span> option forward <span class="hljs-string"><span class="hljs-string">'REJECT'</span></span> option input <span class="hljs-string"><span class="hljs-string">'REJECT'</span></span> option mtu_fix <span class="hljs-string"><span class="hljs-string">'1'</span></span> option network <span class="hljs-string"><span class="hljs-string">'wg0'</span></span></code> </pre> <br><p>  Solo permitimos que el tráfico salga de la interfaz y habilitemos el enmascaramiento. </p><br><p>  Ahora debe habilitar el reenvío desde la zona lan a la zona wg: </p><br><pre> <code class="bash hljs">config forwarding option src <span class="hljs-string"><span class="hljs-string">'lan'</span></span> option dest <span class="hljs-string"><span class="hljs-string">'wg'</span></span></code> </pre> <br><p>  Bueno, lo último es crear listas en iptables usando ipset: </p><br><pre> <code class="bash hljs">config ipset option name <span class="hljs-string"><span class="hljs-string">'vpn_subnets'</span></span> option storage <span class="hljs-string"><span class="hljs-string">'hash'</span></span> option loadfile <span class="hljs-string"><span class="hljs-string">'/tmp/lst/subnet.lst'</span></span> option match <span class="hljs-string"><span class="hljs-string">'dst_net'</span></span> config ipset option name <span class="hljs-string"><span class="hljs-string">'vpn_ipsum'</span></span> option storage <span class="hljs-string"><span class="hljs-string">'hash'</span></span> option loadfile <span class="hljs-string"><span class="hljs-string">'/tmp/lst/ipsum.lst'</span></span> option match <span class="hljs-string"><span class="hljs-string">'dst_net'</span></span></code> </pre> <br><p>  <strong>loadfile</strong> : el archivo del que tomamos la lista <br>  <strong>nombre</strong> - nombre para nuestra lista <br>  <strong>almacenamiento</strong> , <strong>coincidencia</strong> : aquí especificamos cómo almacenar y qué tipo de datos.  Almacenaremos el tipo "subred" </p><br><p>  <strong>UPD</strong> : si desea utilizar la lista de direcciones IP individuales, debe aumentar el tamaño de la lista de IPset.  En config ipset add </p><br><pre> <code class="plaintext hljs"> option hashsize '1000000' option maxelem '1000000'</code> </pre> <br><p>  De lo contrario, recibirá un error </p><br><pre> <code class="plaintext hljs">ipset v6.38: Hash is full, cannot add more elements</code> </pre> <br><p>  <strong>UPD</strong> : agregue dos reglas para etiquetar paquetes </p><br><pre> <code class="plaintext hljs">config rule option name 'mark_subnet' option src 'lan' option proto 'all' option ipset 'vpn_subnets' option set_mark '0x1' option target 'MARK' config rule option name 'mark_ipsum' option src 'lan' option proto 'all' option ipset 'vpn_ipsum' option set_mark '0x1' option target 'MARK'</code> </pre> <br><p>  Estas reglas implican que todos los paquetes que van a las subredes desde las listas vpn_subnets y vpn_ipsum deben marcarse con 0x1. </p><br><p>  Después de eso, reiniciamos la red: </p><br><pre> <code class="bash hljs">/etc/init.d/network restart</code> </pre> <br><p><img src="https://habrastorage.org/webt/e6/pm/m6/e6pmm6etqcw0dbz-c3ddqmzqemo.png"></p><br><p>  y ejecuta el script: </p><br><pre> <code class="bash hljs">/etc/init.d/hirkn</code> </pre> <br><p><img src="https://habrastorage.org/webt/e4/q-/6r/e4q-6rktvq2y8znvhmtpxfdsnwi.gif"></p><br><p>  Después de elaborar el guión, todo debería funcionar para usted.  Verifique la ruta en el cliente del enrutador: </p><br><pre> <code class="bash hljs">mtr/traceroute telegram.org/linkedin.com</code> </pre> <br><p><img src="https://habrastorage.org/webt/wp/6e/jp/wp6ejpwtfwu9xkk-iizc8qj_aeu.gif"></p><br><h2 id="bonusom-nastroim-dnscrypt">  Bonus configure DNSCrypt </h2><br><p>  Por qué  Su proveedor puede sustituir cuidadosamente la dirección IP del recurso bloqueado, redirigiéndolo a su ip con un código auxiliar, bueno, nuestra omisión de IP no ayudará en este caso.  Para la sustitución, no siempre es necesario utilizar el servidor dns del proveedor, sus solicitudes pueden ser interceptadas y las respuestas serán sustituidas.  Bueno, por cierto, no solo el proveedor puede hacer esto. </p><br><pre> <code class="bash hljs">opkg install dnscrpt-proxy</code> </pre> <br><p>  Configure la configuración / etc / config / dnscrypt-proxy de esta manera: </p><br><pre> <code class="bash hljs">config dnscrypt-proxy ns1 option address <span class="hljs-string"><span class="hljs-string">'127.0.0.1'</span></span> option port <span class="hljs-string"><span class="hljs-string">'5353'</span></span> option resolver <span class="hljs-string"><span class="hljs-string">'cpunks-ru'</span></span></code> </pre> <br><p>  Entonces tenemos el servicio dnscrypt en el puerto 5353 disponible en localhost. </p><br><p>  <strong>Resolver</strong> es un servidor dns que admite cifrado.  En el enrutador, el archivo /usr/share/dnscrypt-proxy/dnscrypt-resolvers.csv contiene una lista de servidores disponibles en el momento del lanzamiento de la versión instalada de dnscrypt.  Y aquí está <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://dnscrypt.info/public-servers/</a> en general todos los servidores dnscrypt disponibles.  Puede elegir otro solucionador y / o agregar servidores para tolerancia a fallas.  Tenga en cuenta que para que DNSCrypt funcione con el solucionador seleccionado, debe especificarse en dnscrypt-resolvers.csv. </p><br><p>  Configuramos dnsmasq para que funcione con dnscrypt.  En / etc / config / dhcp, comente la línea: </p><br><pre> <code class="bash hljs">option resolvfile <span class="hljs-string"><span class="hljs-string">'/tmp/resolv.conf.auto'</span></span></code> </pre> <br><p>  para que el servidor dns del proveedor no esté involucrado. </p><br><p>  Y agregue: </p><br><pre> <code class="bash hljs"> list server <span class="hljs-string"><span class="hljs-string">'/pool.ntp.org/208.67.222.222'</span></span> list server <span class="hljs-string"><span class="hljs-string">'127.0.0.1#5353'</span></span></code> </pre> <br><p>  La entrada del <strong>servidor de lista 'dominio / ip_dns'</strong> indica qué servidor dns usar para resolver el dominio especificado.  Por lo tanto, no usamos dnscrypt para la sincronización de ntp; es importante que el servicio dnscrypt tenga la hora actual. </p><br><p><del>  Cuando se carga el enrutador, el script hirkn se ejecuta más rápido de lo que se inicia dnscrypt, por lo que el dominio antifilter.download no se resuelve y las listas no se descargan.  Puedes hacer un retraso u otra cosa, pero hasta ahora no veo ninguna razón. </del><br>  <strong>UPD</strong> : necesita agregar una línea </p><br><pre> <code class="plaintext hljs">START=99</code> </pre> <br><p>  a hirkn script </p><br><p>  Como resultado, obtenemos dicha inserción en la configuración: </p><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#option resolvfile '/tmp/resolv.conf.auto' list server '/pool.ntp.org/208.67.222.222' list server '127.0.0.1#5353'</span></span></code> </pre> <br><p>  <strong>UPD</strong> : en algunos dispositivos, DNSCrypt se inicia de todos modos después del script.  La forma más fácil de solucionar esto es agregar la línea a / etc / config / dhcp </p><br><pre> <code class="plaintext hljs"> list server '/antifilter.download/208.67.222.222'</code> </pre> <br><p>  Deshabilite el uso del DNS del proveedor para la interfaz wan <br>  En / etc / config / network agregue la línea </p><br><pre> <code class="plaintext hljs">option peerdns '0'</code> </pre> <br><p>  a la interfaz wan. <br>  Obtenemos esta configuración </p><br><pre> <code class="bash hljs">config interface <span class="hljs-string"><span class="hljs-string">'wan'</span></span> option ifname <span class="hljs-string"><span class="hljs-string">'eth0.2'</span></span> option proto <span class="hljs-string"><span class="hljs-string">'dhcp'</span></span> option peerdns <span class="hljs-string"><span class="hljs-string">'0'</span></span></code> </pre> <br><p>  Reiniciar la red </p><br><pre> <code class="plaintext hljs">/etc/init.d/network restart</code> </pre> <br><p>  Agregar al inicio e iniciar dnscrypt: </p><br><pre> <code class="bash hljs">/etc/init.d/dnscrypt-proxy <span class="hljs-built_in"><span class="hljs-built_in">enable</span></span> /etc/init.d/dnscrypt-proxy start</code> </pre> <br><p>  Reinicie dnsmasq: </p><br><pre> <code class="bash hljs">/etc/init.d/dnsmasq restart</code> </pre> <br><p><img src="https://habrastorage.org/webt/i2/b5/90/i2b590nxr6-lqnk1h2-tq-i6t-4.gif"><br>  <em>Ilustración del trabajo sin DNSCrypt y con DNSCrypt</em> </p><br><h2 id="avtomaticheski-razvertyvaem-s-pomoschyu-ansible">  Implementado automáticamente con Ansible </h2><br><p>  Playbook y plantillas están en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" title="github">github</a> .  Utiliza un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">módulo</a> , no necesita python en el enrutador y hay soporte para uci.  Traté de asegurarme de que su configuración OpenWrt permaneciera intacta, pero tenga cuidado de todos modos. </p><br><p>  Instale el módulo gekmihesg / ansible-openwrt: </p><br><pre> <code class="bash hljs">ansible-galaxy install gekmihesg.openwrt</code> </pre> <br><p>  Copie el libro de jugadas y la tempeita: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> /etc/ansible git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/itdoginfo/ansible-openwrt-hirkn mv ansible-openwrt-hirkn/* . rm -rf ansible-openwrt-hirkn</code> </pre> <br><p>  Agregue su enrutador a los hosts: </p><br><pre> <code class="bash hljs">[openwrt] 192.168.1.1</code> </pre> <br><p>  Sustituya sus variables en hirkn.yml: </p><br><pre> <code class="bash hljs"> vars: ansible_template_dir: /etc/ansible/templates/ wg_server_address: wg_server_ip/url wg_private_key: privatekey-client wg_public_key: publickey-server wg_listen_port: 51820 wg_client_port: 51820 wg_client_address: 192.168.100.3/24</code> </pre> <br><p>  Asegúrese de configurar: </p><br><p>  <strong>wg_server_address</strong> - servidor de protección ip / url <br>  <strong>wg_private_key</strong> , <strong>wg_public_key</strong> - clave privada del cliente y servidor público <br>  El resto no se puede cambiar o cambiar, dependiendo de cómo esté configurado el servidor WireGuard </p><br><p>  Lanzar libro de jugadas </p><br><pre> <code class="bash hljs">ansible-playbook playbooks/hirkn.yml</code> </pre> <br><p>  Después de completar el libro de jugadas, el enrutador comenzará inmediatamente a evitar los bloqueos a través de su servidor Wireguard. </p><br><h2 id="pochemu-ne-bgp">  ¿Por qué no BGP? </h2><br><p>  Bajo openwrt hay dos utilidades que implementan BGP: quagga y bird.  Quagg no pude obtener datos del antifiltro.  Bird se hizo amigo del servicio de media patada, pero desafortunadamente no entendí cómo forzar que se agregue la interfaz predeterminada a las subredes recibidas.  (Estaré encantado de saber cómo se puede implementar esto). </p><br><p>  En los comentarios sobre tales artículos, vi que los enrutadores de las personas eran "reflexivos" por un tiempo, cuando colocaban listas en la tabla de enrutamiento.  Con la implementación a través de ipset, mi Xiaomi mi 3G piensa durante 2 segundos (Asus rt-n16 durante 5 segundos), cuando le das de comer una lista de 15 mil subredes.  Con más trabajo, no noté la carga en el procesador. </p><br><p>  <em>Todos los materiales no son un llamado a la acción y se presentan para familiarizarse con la funcionalidad del sistema operativo Linux.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/440030/">https://habr.com/ru/post/440030/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../440018/index.html">Exposición local dinámica</a></li>
<li><a href="../440020/index.html">Regresión o regresión en pruebas</a></li>
<li><a href="../440022/index.html">Un pequeño Ferrari: Fintech-startup Rally Rd te permitirá comprar "acciones" de autos raros</a></li>
<li><a href="../440024/index.html">Redireccionar printf () de STM32 a Qt Creator Console</a></li>
<li><a href="../440026/index.html">Kaggle: no puede caminar - corramos</a></li>
<li><a href="../440032/index.html">Inteligencia Artificial Horizon Zero Dawn</a></li>
<li><a href="../440034/index.html">BESO Arquitectura. Del microservicio al monolito</a></li>
<li><a href="../440036/index.html">Mecanografía táctil</a></li>
<li><a href="../440040/index.html">En desarrollo, cada uno por sí mismo. Pero a veces conduce a un callejón sin salida.</a></li>
<li><a href="../440044/index.html">Historia detallada de Qualcomm</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>