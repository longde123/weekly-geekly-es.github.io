<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗃️ 💍 🤱🏾 EJTAG：吸引黑客2 🙊 🧐 🧘🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在我以前的EJTAG出版物中：对黑客和Black Swift 的吸引力：使用EJTAG时，考虑了使用EJTAG的最简单方法-加载到RAM中并启动用户程序。但是，EJTAG的功能不限于此。该出版物描述了如何使用openocd和GDB免费软件工具使用EJTAG来组织简单的代码调试。
 
 一位读者的来信...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>EJTAG：吸引黑客2</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/383505/"><img src="https://habrastorage.org/files/ac4/ecc/125/ac4ecc125c314e7682edb1a9e0fb99ed.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我以前的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EJTAG</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出版物中</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">：对黑客</font></a><font style="vertical-align: inherit;">和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Black Swift </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">的吸引力</font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">：使用EJTAG时</font></a><font style="vertical-align: inherit;">，考虑了使用EJTAG的最简单方法-加载到RAM中并启动用户程序。</font><font style="vertical-align: inherit;">但是，EJTAG的功能不限于此。</font><font style="vertical-align: inherit;">该出版物描述了如何使用openocd和GDB免费软件工具使用EJTAG来组织简单的代码调试。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一位读者的来信提示我写这篇出版物，他要求我保持匿名并向我寻求帮助-基于AR9344的设备无法启动（在U-boot初始化阶段挂起）-我如何找出EJTAG的问题所在？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于我手头上没有基于AR9344的设备，但是基于相关AR9331芯片的Black Swift Pro板却成为了叙述的焦点。我认为AR9344所做的更改并不重要。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
继续</font><font style="vertical-align: inherit;">问题的陈述：有</font><font style="vertical-align: inherit;">一块Black Swift Pro板，我们通过EJTAG使用openocd连接到它，并使处理器进入停止模式。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要求顺序执行数十条处理器指令，在每条指令执行后停止，并在必要时检查RAM，引导ROM，外围控制器寄存器或处理器寄存器的内容。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要解决该问题，我至少看到两种方法：</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">简单-仅使用openocd-openocd已经具有执行所需操作的基本功能。</font><font style="vertical-align: inherit;">只需要能够使用它即可；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">复杂-使用openocd + GDB包-用户将控制通过GDB执行处理器指令的过程，而openocd会将GDB请求转换为EJTAG命令。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在更详细地考虑两种解决方案。</font></font><br>
<blockquote>    ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Black Swift:  EJTAG</a>.<br>
</blockquote><br>
<br>
<h3> 1:   openocd</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
那些阅读过我以前有关EJTAG的出版物的人应该记住，openocd在其中似乎是一个哑脚本执行器（配置文件），它似乎以批处理方式工作，并且不提供用户交互。但是，事实并非如此。实际上，在运行openocd软件时，可以使用命令行界面“询问”它以执行命令。要访问命令行界面，openocd将启动telnet服务器。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
缺省情况下，Telnet服务器使用TCP端口4444，如有必要，可使用选项更改TCP端口号</font></font><code>telnet_port</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（请参见下面的示例）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们尝试使用openocd跟踪Black Swift板的引导程序。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
配置文件示例</font></font><code>black-swift-trace.cfg</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 对于openocd，这将迫使telnet服务器的openocd使用端口4455：</font></font><br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 来源[寻找介面/ ftdi / tumpa.cfg]</font></font><font></font>
 <font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 adapter_khz 6000</font></font><font></font>
 <font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 来源[找到black-swift.cfg]</font></font><font></font>
 <font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 telnet_port 4455</font></font><font></font>
 <font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 在里面</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 停止</font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以root身份运行openocd 0.9.0如下所示：</font></font><br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ＃openocd -f black-swift-trace.cfg</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 打开片上调试器0.9.0（2015-05-28-17：08）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 根据GNU GPL v2许可</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 有关错误报告，请阅读</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
         http://openocd.org/doc/doxygen/bugs.html</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 没有分开</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 适配器速度：6000 kHz</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 信息：自动选择第一个可用的会话传输“ jtag”。</font><font style="vertical-align: inherit;">要覆盖，请使用“运输选择&lt;运输&gt;”。</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 错误：找不到设备</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 错误：无法使用vid 0403，pid 8a98，描述'*'和串行'*'打开ftdi设备</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 信息：时钟速度6000 kHz</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 信息：JTAG接头：ar9331.cpu接头/找到的设备：0x00000001（MFG：0x000，零件：0x0000，ver：0x0）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 目标状态：已停止</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 由于调试请求，目标在MIPS32模式下暂停，pc：0xbfc00000</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 目标状态：已停止</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 由于单步操作，目标在MIPS32模式下停止，pc：0xbfc00404</font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在我们可以打开另一个终端窗口，并使用以下程序连接到openocd telnet服务器</font></font><code>telnet</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> $ telnet本地主机4455</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 尝试:: 1 ...</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 尝试127.0.0.1 ...</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 连接到本地主机。</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 转义字符为'^]'。</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 打开片上调试器</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 &gt;</font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用该命令很容易获得所有openocd命令的列表</font></font><code>help</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了逐步执行处理器指令，</font></font><code>step</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以下</font><font style="vertical-align: inherit;">命令对我们有用</font><font style="vertical-align: inherit;">：</font></font><br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 步骤[地址]</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
       在寄存器指定的地址执行一条指令</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
       命令计数器（PC）。</font><font style="vertical-align: inherit;">如果指定了地址参数，则</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
       该指令将从地址​​地址开始执行。</font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在控制台中逐步执行处理器指令如下所示：</font></font><br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &gt;步骤0xbfc00400</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 目标状态：已停止</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 由于单步操作，目标在MIPS32模式下停止，pc：0xbfc00404</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 &gt;步骤</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 目标状态：已停止</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 由于单步操作，目标在MIPS32模式下停止，pc：0xbfc00408</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 &gt;步骤</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 目标状态：已停止</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 由于单步操作，目标在MIPS32模式下停止，pc：0xbfc0040c</font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下openocd命令也可能有用：</font></font><br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> reg [（寄存器编号|寄存器名称）[（值|'力'）]]</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
       读取或写入处理器寄存器值。</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
       不带参数调用reg将导致所有寄存器的输出。</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
       如果使用'force'参数，则强制</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
       从处理器中减去寄存器（而不是发出缓存）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
       值）。</font></font><font></font>
 <font></font>
 mwb ['phys'] address value [count]<font></font>
          address ,     value.<font></font>
          phys,   address —  ,<font></font>
          — .<font></font>
          count    address  <font></font>
           count,    <font></font>
         value.<font></font>
 <font></font>
 mwh ['phys'] address value [count]<font></font>
         mwb,     16- .<font></font>
 <font></font>
 mww ['phys'] address value [count]<font></font>
         mwb,     32- .<font></font>
 <font></font>
 mdb ['phys'] address [count]<font></font>
               address.<font></font>
          phys,   address —  ,<font></font>
          — .<font></font>
          count        <font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
       数组位于地址地址长度的计数字节。</font></font><font></font>
 <font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 mdh ['phys']地址[count]</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
       该命令类似于mdb，但是读取的是16位字而不是字节。</font></font><font></font>
 <font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 mdw ['phys']地址[count]</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
       该命令类似于mdb，但是读取的是32位字而不是字节。</font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所见，不幸的是，尽管</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有一个具有ARM体系结构的处理器反汇编器</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但最新的（在撰写本文时）openocd 0.9.0版本无法反汇编具有MIPS体系结构的处理器的指令</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于缺少反汇编程序，因此直接使用openocd逐步执行处理器指令并不十分方便。</font><font style="vertical-align: inherit;">如果使用GDB，则可以提高舒适度。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决方案2：使用openocd + GDB捆绑包</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在openocd + GDB捆绑包中，角色分配如下：用户与GDB进行通信，这提供了一个方便的调试接口，从控制指令执行的机制中抽象出来，openocd承担了根据GDB的指令直接控制处理器的任务。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与openocd相比，使用GDB通过EJTAG控制MIPS处理器上指令的执行具有多个优点：</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如上所述，GDB内置了用于MIPS架构的反汇编程序；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以使用源中的调试信息；</font><font style="vertical-align: inherit;">例如，如果您正在调试自己的C程序，则GDB将能够显示当前正在执行的C代码行，并精确地详细说明程序变量的状态，而不是带有神秘地址的存储单元；</font></font></li>
<li>   openocd  GDB   GDB Remote Serial Protocol;  qemu    ,                ,              — GDB;</li>
<li>,    GDB      TAB.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
应当记住，GDB使用高级概念运行，并且openocd被迫与这样的设备一起工作，并且并非总是可以使用EJTAG有效地实现GDB Wishlist。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，用户指示GDB在指定地址处设置断点，该指令转到openocd，但是对于MIPS处理器，openocd至少有两种方法来设置断点：</font></font><br>
<ul>
<li>        sdbbp,        , openocd  sdbbp   ,    sdbbp     ,   .    software breakpoint.  ,          .</li>
<li>         .          .     , hardware breakpoint, .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管在GDB远程串行协议中，硬件断点和软件断点之间是有区别的（请参见</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">协议描述</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中的程序包z和z0 </font><font style="vertical-align: inherit;">），并且GDB提供了选择断点类型的适当选项，但可能会发现在特定处理器上使用点有限制一种或另一种类型的细分。因此，openocd有一个选项</font></font><code>gdb_breakpoint_override</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，允许您强制采用上述两种组织断点的方法之一。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了连接GDB调试器，openocd实现了一个GDB服务器，该服务器默认使用TCP端口3333。如有必要，可以使用option更改TCP端口号</font></font><code>gdb_port</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要连接到控制MIPS处理器的openocd GDB服务器，我们需要具有MIPS支持的特殊版本的GDB。</font><font style="vertical-align: inherit;">我假设读者使用Sourcery CodeBench软件包中的mips-linux-gnu-gdb，使用运行Debian Linux的基于x86 / amd64的计算机来运行openocd和GDB。</font><font style="vertical-align: inherit;">关于如何安装此软件包的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">信息</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，请</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">在此处</font></a><font style="vertical-align: inherit;">撰写</font><font style="vertical-align: inherit;">，在编写这些行时，最后一个是2015年5月发布的Sourcery CodeBench mips-2015.05-18版本，您可以</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用此链接在此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载存档</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们尝试在实践中使用openocd + GDB捆绑包。</font><font style="vertical-align: inherit;">运行openocd：</font></font><br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ＃openocd -f运行u-boot_mod-trace.cfg \</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 &gt; -c“ gdb_breakpoint_override hard” -c“步骤0xbfc00400”</font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
openocd的最后两个命令将提供以下内容：</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不管GDB想象在那里，都将使用硬件断点（地址0xbfc0xxxx对应于ROM，因此软件断点将不起作用）；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将从地址0xbfc00400执行一条指令，此后处理器将再次停止。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
打开另一个终端窗口并启动GDB：</font></font><br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> $ /opt/mips-2015.05/bin/mips-linux-gnu-gdb</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 GNU gdb（Sourcery CodeBench Lite 2015.05-18）7.7.50.20140217-cvs</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 版权所有（C）2014自由软件基金会，Inc.</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 许可证GPLv3 +：GNU GPL版本3或更高版本&lt;http://gnu.org/licenses/gpl.html&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 这是免费软件：您可以自由更改和重新分发它。</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 在法律允许的范围内，没有任何担保。</font><font style="vertical-align: inherit;">输入“显示复制”</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 和“显示保修”了解详情。</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 该GDB被配置为“ --host = i686-pc-linux-gnu --target = mips-linux-gnu”。</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 键入“显示配置”以获取配置详细信息。</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 有关错误报告的说明，请参阅：</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 &lt;https://sourcery.mentor.com/GNUToolchain/&gt;。</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 在线找到GDB手册和其他文档资源：</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 &lt;http://www.gnu.org/software/gdb/documentation/&gt;。</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 要获得帮助，请键入“帮助”。</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 输入“ apropos word”以搜索与“ word”相关的命令。</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 （gdb）</font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们解释GDB所使用的处理器的类型，要求反汇编该处理器的下一条可执行指令，最后连接到openocd GDB服务器：</font></font><br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> （GDB）设置体系结构MIPS：ISA32R2</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 假定目标体系结构是mips：isa32r2</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 （gdb）设置endian大</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 假定目标为大端</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 （gdb）将disassemble-next-line设置为on</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 （GDB）目标遥控器：3333</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 远程调试使用：3333</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 0xbfc00404 in ?? </font><font style="vertical-align: inherit;">（）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 =&gt; 0xbfc00404：40 80 08 00 mtc0零，c0_random</font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了在GDB中执行一条处理器指令，使用了一条命令</font></font><code>stepi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">让我们尝试遵循处理器中的一些指令，不要被GDB关于缺少调试信息（找不到函数的开始）的警告所迷惑，在这种情况下没有地方可以获取此信息。</font></font><br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> （gdb）stepi</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 警告：GDB在0xbfc00408处找不到该函数的开始。</font></font><font></font>
 <font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
     GDB在0xbfc00408处找不到该函数的开始</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 因此无法确定该函数的堆栈框架的大小。</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 这意味着GDB可能无法访问该堆栈帧，或者</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 它下面的框架。</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
     此问题很可能是由无效的程序计数器或</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 堆栈指针。</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
     但是，如果您认为GDB应该简单地向后搜索</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 从0xbfc00408开始，代码看起来像a的开头</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 功能，您可以使用`set来扩大搜索范围</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 启发式围栏后命令。</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 0xbfc00408 in ?? </font><font style="vertical-align: inherit;">（）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 =&gt; 0xbfc00408：40 80 10 00 mtc0零，c0_entrylo0</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 （gdb）stepi</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 警告：GDB在0xbfc0040c处找不到该函数的开始。</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 0xbfc0040c在?? </font><font style="vertical-align: inherit;">（）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 =&gt; 0xbfc0040c：40 80 18 00 mtc0零，c0_entrylo1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 （gdb）stepi</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 警告：GDB在0xbfc00410处找不到该函数的开始。</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 0xbfc00410 in ?? </font><font style="vertical-align: inherit;">（）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 =&gt; 0xbfc00410：40 80 20 00 mtc0零，c0_context</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 （gdb）</font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在读取0xbfc00408处的32位字：</font></font><br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> （gdb）p / x * 0xbfc00408</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 $ 1 = 0x40801000</font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要打印处理器寄存器的状态，请使用以下命令</font></font><code>info registers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> （GDB）信息寄存器</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
           在v0处为零v1 a0 a1 a2 a3</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  R0 00000000 37c688e2 22b15a00 28252198 0c12d319 4193c014 84e49102 06193640</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
             t0 t1 t2 t3 t4 t5 t6 t7</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  R8 00000002 9f003bc0 92061301 1201c163 31d004a0 92944911 ac031248 b806001c</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
             s0 s1 s2 s3 s4 s5 s6 s7</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  R16 8bc81985 402da011 c94d2454 88d5a554 81808e0d cc445151 4401a826 50020402</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
             t8 t9 k0 k1 gp sp s8 ra</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  R24 01c06b30 01000000 10000004 fffffffe 9f003bc0 54854eab 329d626b bfc004b4</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
         状态lo hi badvaddr原因pc</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
       00400004 00244309 b9ca872c ed6a1f00 60808350 bfc00410</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
           fcsr冷杉</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
       00000000 00000000</font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GDB是具有大量命令和选项的高级工具。</font><font style="vertical-align: inherit;">为了更熟悉GDB，我请读者阅读</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GDB官方文档</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初始化AR9331 RAM控制器</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们看看GDB如何解决一个特定的问题：通过在Black Swift板上跟踪U-boot执行，我们将在RAM控制器的寄存器中标识一系列条目，从而导致其初始化。</font><font style="vertical-align: inherit;">如果我们想绕过U-boot使用openocd在Black Swift上运行程序，则检测到这样的序列非常有用。</font><font style="vertical-align: inherit;">同样，在为Black Swift创建备用引导程序时，此初始化序列很有用。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
运行openocd（就像上一节一样）：</font></font><br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ＃openocd -f运行u-boot_mod-trace.cfg \</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 &gt; -c“ gdb_breakpoint_override hard” -c“步骤0xbfc00400”</font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要运行GDB，请编写一个脚本</font></font><code>bs-u-boot-trace-gdb.conf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 设置体系结构的技巧：isa32r2</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 设置大端</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 设置反汇编下一行</font></font><font></font>
 <font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 目标遥控器：3333</font></font><font></font>
 <font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 取消分页</font></font><font></font>
 <font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 设置日志文件bs_gdb.log</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 设置登录</font></font><font></font>
 <font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 而$ pc！=（void（*）（））0x9f002ab0</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
         斯蒂皮</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
         信息寄存器</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 结束</font></font><font></font>
 <font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 分离</font></font><font></font>
 <font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 退出</font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与上一节中的示例相比，该脚本使GDB将输出复制到文件中</font></font><code>bs_gdb.log</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并禁用分页（用户确认页面翻页），然后开始循环执行处理器指令并在每条指令之后显示处理器寄存器的状态。</font><font style="vertical-align: inherit;">当PC寄存器（以下指令的地址寄存器）达到值0x9f002ab0时，GDB与openocd断开连接并停止工作。</font><font style="vertical-align: inherit;">因此，在GDB的末尾，将创建</font></font><code>bs_gdb.log</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个具有处理器指令执行完整轨迹的</font><font style="vertical-align: inherit;">文件</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GDB的启动如下：</font></font><br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> $ /opt/mips-2015.05/bin/mips-linux-gnu-gdb -x bs-u-boot-trace-gdb.conf</font></font></pre></blockquote><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：该脚本</font></font><code>bs-u-boot-trace-gdb.conf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">很可能在板上电后不会立即运行，因为u-boot_mod将另外重置AR9331的反神秘错误，这将导致脚本停止执行。</font><font style="vertical-align: inherit;">在这种情况下，请停止openocd和GDB，然后再次运行openocd和GDB。</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，一切都变得很小了-您需要从文件中选择</font></font><code>bs_gdb.log</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有写入指令</font></font><code>sw</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（存储字，即写入32位值）。</font><font style="vertical-align: inherit;">AR9331存储器控制器的寄存器为32位，因此可以安全地忽略存储系列中的其他指令。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于反汇编器仅生成指令的参数寄存器的名称</font></font><code>sw</code><br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> =&gt; 0xbfc004ec：ad f9 00 00 sw t9,0（t7）</font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但不是它们的值，仅从file中</font></font><code>bs_gdb.log</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选择包含sw语句的所有行</font><font style="vertical-align: inherit;">是不够的</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">为了确定使用sw将哪个值写入哪个地址，必须对该文件进行</font></font><code>bs_gdb.log</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其他处理。</font><font style="vertical-align: inherit;">可以使用parse_gdb_output.pl脚本完成处理：</font></font><br>
<pre><code class="perl hljs"> <span class="hljs-comment">#!/usr/bin/perl -w</span><font></font>
 <font></font>
 <span class="hljs-keyword">my</span> %r;<font></font>
 <font></font>
 <span class="hljs-keyword">foreach</span> $i (<span class="hljs-string">qw(zero at v0 v1 a0 a1 a2 a3 t0 t1 t2 t3 t4 t5 t6 t7
        s0 s1 s2 s3 s4 s5 s6 s7 t8 t9 k0 k1 gp sp s8 ra)</span>) {<font></font>
    $r{$i} = <span class="hljs-string">"none"</span>;<font></font>
 }<font></font>
 <font></font>
 <span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">parse_reg</span>($)
 </span>{<font></font>
    $_ = $_[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^ R/</span>) {
        <span class="hljs-keyword">my</span> @fields = <span class="hljs-keyword">split</span> <span class="hljs-keyword">m</span><span class="hljs-string">'\s+'</span>;
        <span class="hljs-keyword">my</span> $f = <span class="hljs-number">2</span>;
        <span class="hljs-keyword">my</span> @rgs;<font></font>
 <font></font>
        @rgs = <span class="hljs-string">qw(zero at v0 v1 a0 a1 a2 a3)</span> <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^ R0/</span>);<font></font>
        @rgs = <span class="hljs-string">qw(t0 t1 t2 t3 t4 t5 t6 t7)</span> <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^ R8/</span>);<font></font>
        @rgs = <span class="hljs-string">qw(s0 s1 s2 s3 s4 s5 s6 s7)</span> <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^ R1/</span>);<font></font>
        @rgs = <span class="hljs-string">qw(t8 t9 k0 k1 gp sp s8 ra)</span> <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^ R2/</span>);<font></font>
 <font></font>
        <span class="hljs-keyword">foreach</span> $i (@rgs) {<font></font>
            $r{$i} = $fields[$f];<font></font>
            $f = $f + <span class="hljs-number">1</span>;<font></font>
        }<font></font>
    }<font></font>
 }<font></font>
 <font></font>
 <span class="hljs-keyword">while</span> (&lt;&gt;) {
    <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^=&gt;([^s]*)\tsw\t([^,]*),(\d+)\(([^)]*)\)/</span>) {
        <span class="hljs-keyword">my</span> $rs = $2;
        <span class="hljs-keyword">my</span> $offset = $3;
        <span class="hljs-keyword">my</span> $rd = $4;<font></font>
 <font></font>
        parse_reg(&lt;&gt;);<font></font>
        parse_reg(&lt;&gt;);<font></font>
        parse_reg(&lt;&gt;);<font></font>
        parse_reg(&lt;&gt;);<font></font>
 <font></font>
        <span class="hljs-keyword">print</span>(<span class="hljs-string">"$1    sw $rs={0x$r{$rs}}, $offset($rd={0x$r{$rd}})\n"</span>);<font></font>
    }<font></font>
 }</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
启动</font></font><code>parse_gdb_output.pl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如下：</font></font><br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ grep“ ^ = \ | ^ R” bs_gdb.log | </font><font style="vertical-align: inherit;">./parse_gdb_output.pl</font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是输出的摘要</font></font><code>parse_gdb_output.pl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（标记' </font></font><code>&lt;&lt;&lt; PLL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">'和' </font></font><code>&lt;&lt;&lt; DDR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">'稍后手动输入）：</font></font><br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ...</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  0x9f002700：ad cf 00 00 sw t7 = {0x00dbd860}，0（t6 = {0xb8116248}）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  0x9f00271c：ad f9 00 00 sw t9 = {0x000fffff}，0（t7 = {0xb800009c}）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  0x9f0027a0：ad f9 00 00 sw t9 = {0x00018004}，0（t7 = {0xb8050008}）&lt;&lt;&lt; PLL</font></font><font></font>
  0x9f0027dc:   ad f9 00 00    sw t9={0x00000352}, 0(t7={0xb8050004}) &lt;&lt;&lt;<font></font>
  0x9f002840:   ad f9 00 00    sw t9={0x40818000}, 0(t7={0xb8050000}) &lt;&lt;&lt;<font></font>
  0x9f002898:   ad f9 00 00    sw t9={0x001003e8}, 0(t7={0xb8050010}) &lt;&lt;&lt;<font></font>
  0x9f0028f4:   ad f9 00 00    sw t9={0x00818000}, 0(t7={0xb8050000}) &lt;&lt;&lt;<font></font>
  0x9f002970:   ad cf 00 00    sw t7={0x00800000}, 0(t6={0xb8116248})<font></font>
 ...<font></font>
  0x9f002994:   ad cf 00 00    sw t7={0x40800700}, 0(t6={0xb8116248})<font></font>
  0x9f002a54:   ad f9 00 00    sw t9={0x00008000}, 0(t7={0xb8050008})<font></font>
  0x9f00309c:   af 38 00 00    sw t8={0x7fbc8cd0}, 0(t9={0xb8000000}) &lt;&lt;&lt; DDR<font></font>
  0x9f0030b0:   af 38 00 00    sw t8={0x9dd0e6a8}, 0(t9={0xb8000004}) &lt;&lt;&lt;<font></font>
  0x9f0030dc:   af 38 00 00    sw t8={0x00000a59}, 0(t9={0xb800008c}) &lt;&lt;&lt;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  0x9f0030ec：af 38 00 00 sw t8 = {0x00000008}，0（t9 = {0xb8000010}）&lt;&lt;&lt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 ...</font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于时钟信号发生器（PLL）的寄存器的地址和DDR类型的内存控制器的寄存器的地址是已知的，因此很容易弄清楚应该向哪个地址写入哪些数字才能正确初始化RAM控制器。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">摘要</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所见，使用openocd和GDB通过JTAG进行调试并不困难，并且所描述的工作方法不仅适用于AR9331，而且经过一些调整甚至适用于具有不同架构的处理器，openocd和GDB均对此提供了支持。</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN383505/">https://habr.com/ru/post/zh-CN383505/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN383495/index.html">在俄罗斯生存。“哈士奇，转发，推文：如何不违反反极端主义立法”</a></li>
<li><a href="../zh-CN383497/index.html">Портирование Lode Runner с БК на УКНЦ</a></li>
<li><a href="../zh-CN383499/index.html">刻苦经历艰难</a></li>
<li><a href="../zh-CN383501/index.html">在美国启动了一项实验，模拟了持续365天飞往火星的飞行</a></li>
<li><a href="../zh-CN383503/index.html">钙钛矿光电管：每平方米5克</a></li>
<li><a href="../zh-CN383507/index.html">月球基地项目：历史</a></li>
<li><a href="../zh-CN383509/index.html">海盗湾创始人在退出后立即被捕</a></li>
<li><a href="../zh-CN383511/index.html">在超级计算机上计算的光合作用的最初时刻</a></li>
<li><a href="../zh-CN383513/index.html">即使丝绸之路关闭，在线毒品供应也会增加</a></li>
<li><a href="../zh-CN383517/index.html">2015年RAICamp-第一天</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>