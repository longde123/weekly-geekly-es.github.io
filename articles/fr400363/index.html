<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✒️ 📞 ⛹🏾 Plonger profondément: du CSS au transistor 👦🏻 ♋️ 👩🏽‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a 70 ans, le 16 décembre 1947, dans les laboratoires Bell Labs, John Bardin et Walter Brattain, sous la direction de William Shockley, ont créé l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Plonger profondément: du CSS au transistor</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/400363/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a 70 ans, le 16 décembre 1947, dans les laboratoires Bell Labs, John Bardin et Walter Brattain, sous la direction de William Shockley, ont créé le premier transistor bipolaire opérationnel. </font><font style="vertical-align: inherit;">Le 23 décembre, Brattain a présenté à ses collègues le premier amplificateur à transistor. </font><font style="vertical-align: inherit;">Par conséquent, ce jour est souvent appelé </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transistor Day</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6u/ty/ic/6utyic2_kroyqcpgvrcybtv7kjm.jpeg" alt="Bardin est debout à gauche, Brattain est debout à droite, Shockley est assis"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il n'est pas nécessaire de parler de l'importance de cet événement. </font><font style="vertical-align: inherit;">Le transistor est considéré comme l'une des inventions les plus importantes du XXe siècle, sans lequel les ordinateurs fonctionneraient encore sur les lampes et les relais et occuperaient des bâtiments entiers. </font><font style="vertical-align: inherit;">Shockley, Bardin et Brattain ont reçu le prix Nobel de physique pour leur travail en 1956. </font><font style="vertical-align: inherit;">Au fil des ans, le transistor s'est miniaturisé à seulement quelques atomes. </font><font style="vertical-align: inherit;">Chaque processeur possède des milliards de transistors, de sorte que le transistor peut être appelé le périphérique le plus massif créé par l'humanité. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais quel genre de travail le transistor fait-il pour nous? </font><font style="vertical-align: inherit;">Allons dans un voyage mental: nous allons tracer le chemin depuis le bout des doigts de haut niveau jusqu'à notre anniversaire - le transistor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Que prendre comme point de départ? </font><font style="vertical-align: inherit;">Eh bien, dessinez au moins un bouton habrakat.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTML et CSS</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un bouton se compose de pixels d'arrière-plan, de texte et d'une bordure. </font><font style="vertical-align: inherit;">Dans le code, défini par la balise &lt;a&gt;, auquel les règles de disposition CSS sont appliquées. </font><font style="vertical-align: inherit;">Par exemple, une règle CSS est appliquée à une bordure aux coins arrondis:</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">border-radius</span></span>: 3<span class="hljs-selector-tag"><span class="hljs-selector-tag">px</span></span>;</code></pre><img src="https://habrastorage.org/getpro/geektimes/post_images/b36/f41/354/b36f41354796b490cd910c72747da8af.png" alt="knopa"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, la frontière se compose de quatre segments et de quatre arcs («quarts» d'un cercle). </font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Navigateur</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour la recherche, j'ai pris mon Firefox préféré. </font><font style="vertical-align: inherit;">Avant que FF ne commence à dessiner notre bouton, il doit faire beaucoup de travail sur l'analyse et le calcul de la position des éléments:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Télécharger du HTML sur un réseau, analyser, composer une arborescence DOM</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Téléchargez sur le réseau CSS, effectuez une analyse lexicale, analysez</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lier des règles basées sur la priorité et l'héritage aux éléments de la page</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour tous les nœuds DOM visibles, composez un arbre de leurs zones rectangulaires - cadres. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour les cadres, calculez les dimensions et l'emplacement (voir la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vidéo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Composez des calques à partir de cadres en tenant compte du z-index et du type de contenu (&lt;canvas&gt;, SVG, &lt;video&gt;).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Créez une liste de dessins dans l'ordre: couleur d'arrière-plan, image d'arrière-plan, bordure, descendants, contour.</font></font></li>
</ul><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajouter. </font><font style="vertical-align: inherit;">matériel de lecture:</font></font></b><div class="spoiler_text"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gecko:Overview</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">How Browsers Work: Behind the scenes of modern web browsers</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   </a><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous ne nous attarderons pas sur ces étapes en détail. </font><font style="vertical-align: inherit;">Après eux vient le dessin réel des éléments nécessaires.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Téléchargez la source pour savoir ce qui s'y passe,</font></font></b><div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  Mozilla Firefox</a>.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>    Firefox  Mercurial  Visual Studio   C++.  VS        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">symbols.mozilla.org</a>.      -  /layout/. <br>
<br>
 ,    ,     ,   Firefox.     c   ,       ,     —         FF.<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le fichier </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nsCSSRenderingBorders.cpp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est responsable du dessin des bordures </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Et la fonction générale du dessin des bordures s'appelle (qui aurait pensé): </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DrawBorders ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">La fonction sélectionne la méthode de rendu optimale pour diverses situations. </font><font style="vertical-align: inherit;">Nous avons un cas relativement simple: il y a un rayon de bordure, mais les bordures de tous les côtés sont solides et de la même couleur.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notre si</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (allBordersSame &amp;&amp;<font></font>
      mCompositeColors[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp;<font></font>
      mBorderStyles[<span class="hljs-number"><span class="hljs-number">0</span></span>] == NS_STYLE_BORDER_STYLE_SOLID &amp;&amp;<font></font>
      !mAvoidStroke &amp;&amp;<font></font>
      !mNoBorderRadius)<font></font>
  {<font></font>
    <span class="hljs-comment"><span class="hljs-comment">// Relatively simple case.</span></span><font></font>
    gfxRect outerRect = ThebesRect(mOuterRect);<font></font>
    <span class="hljs-function"><span class="hljs-function">RoundedRect </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">borderInnerRect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(outerRect, mBorderRadii)</span></span></span></span>;<font></font>
    borderInnerRect.Deflate(mBorderWidths[eSideTop],<font></font>
                            mBorderWidths[eSideBottom],<font></font>
                            mBorderWidths[eSideLeft],<font></font>
                            mBorderWidths[eSideRight]);<font></font>
<font></font>
    <span class="hljs-comment"><span class="hljs-comment">// Instead of stroking we just use two paths: an inner and an outer.</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// This allows us to draw borders that we couldn't when stroking. For example,</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// borders with a border width &gt;= the border radius. (i.e. when there are</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// square corners on the inside)</span></span>
    <span class="hljs-comment"><span class="hljs-comment">//</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// Further, this approach can be more efficient because the backend</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// doesn't need to compute an offset curve to stroke the path. We know that</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// the rounded parts are elipses we can offset exactly and can just compute</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// a new cubic approximation.</span></span><font></font>
    RefPtr&lt;PathBuilder&gt; builder = mDrawTarget-&gt;CreatePathBuilder();<font></font>
    AppendRoundedRectToPath(builder, mOuterRect, mBorderRadii, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);<font></font>
    AppendRoundedRectToPath(builder, ToRect(borderInnerRect.rect), borderInnerRect.corners, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);<font></font>
    RefPtr&lt;Path&gt; path = builder-&gt;Finish();<font></font>
    mDrawTarget-&gt;Fill(path, color);<font></font>
    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;<font></font>
  }<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe des options beaucoup plus complexes, telles que l'ancrage dans les coins avec le rayon de bordure de différents types de bordures en pointillés et en pointillés, voir </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DrawDashedOrDottedCorner ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Il en code complètement</font></font><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grands commentaires</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs">    <span class="hljs-comment"><span class="hljs-comment">//      radius.width</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// |&lt;-----------------&gt;|</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// |                   |</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// |             ___---+-------------</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// |         __--     #|#       ###</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// |       _-        ##|##     #####</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// |     /           ##+##     ##+##</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// |   /             # P #     #####</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// |  |               #|#       ###</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// | |             __--+-------------</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// ||            _-    ^</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// ||          /       |</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// |         /        first dot is filled</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// |        |</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// |       |</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// |      |</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// |      |</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// |      |</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// +------+</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// |##  ##|</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// |##  ##|</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// |##  ##|</span></span>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais revenons à notre if. </font><font style="vertical-align: inherit;">À partir du commentaire, nous apprenons que dans ce cas, la bordure est dessinée à l'aide de deux rectangles - interne et externe, puis le chemin créé (chemin) est rempli de la couleur souhaitée.</font></font><br>
<br>
<pre><code class="cpp hljs">AppendRoundedRectToPath(builder, mOuterRect, mBorderRadii, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);<font></font>
AppendRoundedRectToPath(builder, ToRect(borderInnerRect.rect), borderInnerRect.corners, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);<font></font>
RefPtr&lt;Path&gt; path = builder-&gt;Finish();<font></font>
mDrawTarget-&gt;Fill(path, color);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Accédez à </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AppendRoundedRectToPath ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans gfx / 2d / PathHelpers.cpp.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encore une fois, nous fixons des points d'arrêt</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/getpro/geektimes/post_images/4cd/ab2/6a9/4cdab26a931ee33578231106b0bbf354.png" alt="a9430-clip-21kb"><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous apprenons du commentaire sur la fonction que les coins sont dessinés en quatre points de contrôle par </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des courbes de Bézier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Les courbes de Bézier sont souvent utilisées en infographie, y compris pour dessiner des arcs de cercles et d'ellipses. Comme nous en apprenons davantage dans le commentaire, il existe de nombreuses options pour choisir des points de contrôle pour construire une courbe. Dans ce cas, nous avons besoin que les points 0 et 3 appartiennent aux côtés du rectangle, les points 0, 1 et C se trouvent sur une ligne droite, les points 3, 2 et C sur l'autre. Voir la figure: </font></font><br>
<br>
<img src="https://habrastorage.org/files/9d2/6f9/e3a/9d26f9e3a86b42b09fe5fc35be1880a2.png" alt="mozilla frontière arrondie courbe de bezier"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il nous reste à calculer le rapport des longueurs des segments 01 / 0C et 32 ​​/ 3C. Ici, les auteurs utilisent des calculs approximatifs et obtiennent la constante magique alpha:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Float alpha = Float(<span class="hljs-number"><span class="hljs-number">0.55191497064665766025</span></span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Malheureusement, les articles avec l'algorithme de sélection des points de contrôle référencé par le commentaire ne sont pas dans le domaine public. </font><font style="vertical-align: inherit;">Mais en général, il convient de noter qu'en infographie, les algorithmes utilisent souvent l'approximation pour améliorer les performances. </font><font style="vertical-align: inherit;">Par exemple, l' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algorithme de Brezenham</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vous permet de dessiner des segments et des cercles non "dans le front" - en résolvant les équations y = f (x), mais avec des opérations entières plus astucieuses. </font><font style="vertical-align: inherit;">Même chose avec le remplissage, etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Plus loin dans le cycle, nous allons d'un coin à l'autre, utilisons alpha pour calculer les coordonnées des points de contrôle et, enfin, appelons les fonctions de dessin de la ligne de frontière et de l'arc du coin:</font></font><br>
<br>
<pre><code class="cpp hljs">aPathBuilder-&gt;LineTo(p0);<font></font>
aPathBuilder-&gt;BezierTo(p1, p2, p3); </code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajouter. </font><font style="vertical-align: inherit;">matériel de lecture</font></font></b><div class="spoiler_text"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> :       </a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> Javascript:     </a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cairo vs. Skia</a><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code AppendRoundedRectToPath () complet</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">
</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AppendRoundedRectToPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PathBuilder* aPathBuilder,
                        </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Rect&amp; aRect,
                        </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> RectCornerRadii&amp; aRadii,
                        </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aDrawClockwise)</span></span></span><span class="hljs-function">
</span></span>{
  <span class="hljs-comment"><span class="hljs-comment">// For CW drawing, this looks like:</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//  ...******0**      1    C</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//              ****</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//                  ***    2</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//                     **</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//                       *</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//                        *</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//                         3</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//                         *</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//                         *</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// Where 0, 1, 2, 3 are the control points of the Bezier curve for</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// the corner, and C is the actual corner point.</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// At the start of the loop, the current point is assumed to be</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// the point adjacent to the top left corner on the top</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// horizontal.  Note that corner indices start at the top left and</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// continue clockwise, whereas in our loop i = 0 refers to the top</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// right corner.</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// When going CCW, the control points are swapped, and the first</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// corner that's drawn is the top left (along with the top segment).</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// There is considerable latitude in how one chooses the four</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// control points for a Bezier curve approximation to an ellipse.</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// For the overall path to be continuous and show no corner at the</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// endpoints of the arc, points 0 and 3 must be at the ends of the</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// straight segments of the rectangle; points 0, 1, and C must be</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// collinear; and points 3, 2, and C must also be collinear.  This</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// leaves only two free parameters: the ratio of the line segments</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// 01 and 0C, and the ratio of the line segments 32 and 3C.  See</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// the following papers for extensive discussion of how to choose</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// these ratios:</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//   Dokken, Tor, et al. "Good approximation of circles by</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//      curvature-continuous Bezier curves."  Computer-Aided</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//      Geometric Design 7(1990) 33--41.</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//   Goldapp, Michael. "Approximation of circular arcs by cubic</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//      polynomials." Computer-Aided Geometric Design 8(1991) 227--238.</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//   Maisonobe, Luc. "Drawing an elliptical arc using polylines,</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//      quadratic, or cubic Bezier curves."</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//      http://www.spaceroots.org/documents/ellipse/elliptical-arc.pdf</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// We follow the approach in section 2 of Goldapp (least-error,</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// Hermite-type approximation) and make both ratios equal to</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//          2   2 + n - sqrt(2n + 28)</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//  alpha = - * ---------------------</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//          3           n - 4</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// where n = 3( cbrt(sqrt(2)+1) - cbrt(sqrt(2)-1) ).</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// This is the result of Goldapp's equation (10b) when the angle</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// swept out by the arc is pi/2, and the parameter "a-bar" is the</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// expression given immediately below equation (21).</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// Using this value, the maximum radial error for a circle, as a</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// fraction of the radius, is on the order of 0.2 x 10^-3.</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// Neither Dokken nor Goldapp discusses error for a general</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// ellipse; Maisonobe does, but his choice of control points</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// follows different constraints, and Goldapp's expression for</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// 'alpha' gives much smaller radial error, even for very flat</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// ellipses, than Maisonobe's equivalent.</span></span>
  <span class="hljs-comment"><span class="hljs-comment">//</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// For the various corners and for each axis, the sign of this</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// constant changes, or it might be 0 -- it's multiplied by the</span></span>
  <span class="hljs-comment"><span class="hljs-comment">// appropriate multiplier from the list before using.</span></span><font></font>
<font></font>
  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Float alpha = Float(<span class="hljs-number"><span class="hljs-number">0.55191497064665766025</span></span>);<font></font>
<font></font>
  <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> Float a, b; } twoFloats;<font></font>
<font></font>
  twoFloats cwCornerMults[<span class="hljs-number"><span class="hljs-number">4</span></span>] = { { <span class="hljs-number"><span class="hljs-number">-1</span></span>,  <span class="hljs-number"><span class="hljs-number">0</span></span> },    <span class="hljs-comment"><span class="hljs-comment">// cc == clockwise</span></span>
                                 {  <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span> },<font></font>
                                 { +<span class="hljs-number"><span class="hljs-number">1</span></span>,  <span class="hljs-number"><span class="hljs-number">0</span></span> },<font></font>
                                 {  <span class="hljs-number"><span class="hljs-number">0</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span> } };<font></font>
  twoFloats ccwCornerMults[<span class="hljs-number"><span class="hljs-number">4</span></span>] = { { +<span class="hljs-number"><span class="hljs-number">1</span></span>,  <span class="hljs-number"><span class="hljs-number">0</span></span> },   <span class="hljs-comment"><span class="hljs-comment">// ccw == counter-clockwise</span></span>
                                  {  <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span> },<font></font>
                                  { <span class="hljs-number"><span class="hljs-number">-1</span></span>,  <span class="hljs-number"><span class="hljs-number">0</span></span> },<font></font>
                                  {  <span class="hljs-number"><span class="hljs-number">0</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span> } };<font></font>
<font></font>
  twoFloats *cornerMults = aDrawClockwise ? cwCornerMults : ccwCornerMults;<font></font>
<font></font>
  Point cornerCoords[] = { aRect.TopLeft(), aRect.TopRight(),<font></font>
                           aRect.BottomRight(), aRect.BottomLeft() };<font></font>
<font></font>
  Point pc, p0, p1, p2, p3;<font></font>
<font></font>
  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (aDrawClockwise) {<font></font>
    aPathBuilder-&gt;MoveTo(Point(aRect.X() + aRadii[RectCorner::TopLeft].width,<font></font>
                               aRect.Y()));<font></font>
  } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {<font></font>
    aPathBuilder-&gt;MoveTo(Point(aRect.X() + aRect.Width() - aRadii[RectCorner::TopRight].width,<font></font>
                               aRect.Y()));<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++i) {
    <span class="hljs-comment"><span class="hljs-comment">// the corner index -- either 1 2 3 0 (cw) or 0 3 2 1 (ccw)</span></span>
    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = aDrawClockwise ? ((i+<span class="hljs-number"><span class="hljs-number">1</span></span>) % <span class="hljs-number"><span class="hljs-number">4</span></span>) : ((<span class="hljs-number"><span class="hljs-number">4</span></span>-i) % <span class="hljs-number"><span class="hljs-number">4</span></span>);<font></font>
<font></font>
    <span class="hljs-comment"><span class="hljs-comment">// i+2 and i+3 respectively.  These are used to index into the corner</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// multiplier table, and were deduced by calculating out the long form</span></span>
    <span class="hljs-comment"><span class="hljs-comment">// of each corner and finding a pattern in the signs and values.</span></span>
    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i2 = (i+<span class="hljs-number"><span class="hljs-number">2</span></span>) % <span class="hljs-number"><span class="hljs-number">4</span></span>;
    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i3 = (i+<span class="hljs-number"><span class="hljs-number">3</span></span>) % <span class="hljs-number"><span class="hljs-number">4</span></span>;<font></font>
<font></font>
    pc = cornerCoords[c];<font></font>
<font></font>
    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (aRadii[c].width &gt; <span class="hljs-number"><span class="hljs-number">0.0</span></span> &amp;&amp; aRadii[c].height &gt; <span class="hljs-number"><span class="hljs-number">0.0</span></span>) {<font></font>
      p0.x = pc.x + cornerMults[i].a * aRadii[c].width;<font></font>
      p0.y = pc.y + cornerMults[i].b * aRadii[c].height;<font></font>
<font></font>
      p3.x = pc.x + cornerMults[i3].a * aRadii[c].width;<font></font>
      p3.y = pc.y + cornerMults[i3].b * aRadii[c].height;<font></font>
<font></font>
      p1.x = p0.x + alpha * cornerMults[i2].a * aRadii[c].width;<font></font>
      p1.y = p0.y + alpha * cornerMults[i2].b * aRadii[c].height;<font></font>
<font></font>
      p2.x = p3.x - alpha * cornerMults[i3].a * aRadii[c].width;<font></font>
      p2.y = p3.y - alpha * cornerMults[i3].b * aRadii[c].height;<font></font>
<font></font>
      aPathBuilder-&gt;LineTo(p0);<font></font>
      aPathBuilder-&gt;BezierTo(p1, p2, p3);<font></font>
    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {<font></font>
      aPathBuilder-&gt;LineTo(pc);<font></font>
    }<font></font>
  }<font></font>
<font></font>
  aPathBuilder-&gt;Close();<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais alors tout dépend du backend des graphiques 2D que Mozilla utilise. </font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moteur graphique</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gecko utilise la bibliothèque Moz2D indépendante de la plate-forme, qui à son tour peut utiliser l'un des backends: Cairo, Skia, Direct2D, Quartz et NV Path. </font><font style="vertical-align: inherit;">Par exemple, Direct2D, Cairo, Skia sont disponibles pour Windows. </font><font style="vertical-align: inherit;">Skia est également le backend Chromium. </font><font style="vertical-align: inherit;">Vous pouvez changer le backend dans about: config. </font><font style="vertical-align: inherit;">Les backends, à leur tour, peuvent tout lire sur le CPU, ou ils peuvent utiliser l'accélération matérielle GPU dans une certaine mesure. </font><font style="vertical-align: inherit;">Par exemple, Skia a son propre backend OpenGL - Ganesh. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le code Direct2D est fermé, nous ferions donc mieux d'activer Skia et de voir ce qu'il fait. </font><font style="vertical-align: inherit;">La fonction pour dessiner une courbe cubique SkPath :: cubicTo est appelée. </font><font style="vertical-align: inherit;">Pour construire une courbe, elle est divisée par </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l'algorithme de Castelljo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en un certain nombre de segments droits, qui sont réellement dessinés (voir core / SkGeometry.cpp).</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajouter. </font><font style="vertical-align: inherit;">matériel de lecture</font></font></b><div class="spoiler_text"><a href=""> skia/src/core/SkGeometry.cpp</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Adaptive Subdivision of Bezier Curves<br>
</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Performance Of Bézier Curves Rendering In Web Browsers</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Software vs. GPU rasterization in Chromium</a><br>
</div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code machine</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour être honnête, je n'ai pas réussi à comprendre pleinement les internes de Skia, j'ai donc pris un peu de recul - vers AppendRoundedRectToPath (), où toutes les opérations sont effectuées sur des entiers - ce qui pourrait être plus facile? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après avoir ouvert le code désassemblé, il faut y trouver l'opération d'addition.</font></font><br>
<br>
<pre><code class="hljs powershell">...
<span class="hljs-number"><span class="hljs-number">142</span></span>B1863 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span>                add         byte ptr [<span class="hljs-type"><span class="hljs-type">eax</span></span>],al  
<span class="hljs-number"><span class="hljs-number">142</span></span>B1865 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>D <span class="hljs-number"><span class="hljs-number">43</span></span> FF <span class="hljs-number"><span class="hljs-number">0</span></span>F <span class="hljs-number"><span class="hljs-number">84</span></span>    add         byte ptr [<span class="hljs-type"><span class="hljs-type">ebp</span></span>-<span class="hljs-number"><span class="hljs-number">7</span></span><span class="hljs-type"><span class="hljs-type">BF000BDh</span></span>],cl  
<span class="hljs-number"><span class="hljs-number">142</span></span>B186B <span class="hljs-number"><span class="hljs-number">67</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span>             add         dword ptr [<span class="hljs-type"><span class="hljs-type">bx</span></span>+<span class="hljs-type"><span class="hljs-type">si</span></span>],eax  
<span class="hljs-number"><span class="hljs-number">142</span></span>B186E <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">99</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>F <span class="hljs-number"><span class="hljs-number">57</span></span> C9 F7    add         byte ptr [<span class="hljs-type"><span class="hljs-type">ecx</span></span>-<span class="hljs-number"><span class="hljs-number">836</span></span><span class="hljs-type"><span class="hljs-type">A8F1h</span></span>],bl  
<span class="hljs-number"><span class="hljs-number">142</span></span>B1874 F9                   stc  
<span class="hljs-number"><span class="hljs-number">142</span></span>B1875 <span class="hljs-number"><span class="hljs-number">8</span></span>B C3                mov         eax,ebx  
<span class="hljs-number"><span class="hljs-number">142</span></span>B1877 <span class="hljs-number"><span class="hljs-number">8</span></span>B CA                mov         ecx,edx  
<span class="hljs-number"><span class="hljs-number">142</span></span>B1879 <span class="hljs-number"><span class="hljs-number">99</span></span>                   cdq  
<span class="hljs-number"><span class="hljs-number">142</span></span>B187A F7 <span class="hljs-number"><span class="hljs-number">7</span></span>C <span class="hljs-number"><span class="hljs-number">24</span></span> <span class="hljs-number"><span class="hljs-number">28</span></span>          idiv        eax,dword ptr [<span class="hljs-type"><span class="hljs-type">esp</span></span>+<span class="hljs-number"><span class="hljs-number">28</span></span><span class="hljs-type"><span class="hljs-type">h</span></span>]  <font></font>
...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ouais! Même une personne aussi éloignée de l'ASM que je peux facilement deviner que l'opération ADD est responsable de l'ajout. Effectuez la première opération: </font></font><br>
<br>
<code>142B1863 00 00 add byte ptr [eax],al </code><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0x142B1863 - adresse dans la RAM </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0x00 - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opcode</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - code d'instruction du processeur. Ce Mozilla compilé sous x86, et en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ouvrant la table d'instructions x86</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nous verrons que le code 00 signifie une opération d'ajout 8 bits avec des mnémoniques ADD. Le premier opérande peut être un registre ou une cellule mémoire à accès aléatoire, le second peut être un registre. Le premier opérande est ajouté au second, le résultat est écrit dans le premier. Je vais expliquer, au cas où, que le registre est une mémoire RAM ultrarapide à l'intérieur du processeur, par exemple, pour stocker des résultats de calcul intermédiaires. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le deuxième octet est également 0x00 et est appelé </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MOD-REG-R / M</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ses bits spécifient les opérandes et la méthode d'adressage. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/09d/264/86f/09d26486fdeabed7c7d258cadfea7cc3.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MOD = 00b en combinaison avec R / M = 000b signifie que l' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adressage indirect est utilisé</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
REG = 000b signifie que le registre AL est utilisé (les 8 bits inférieurs du registre EAX) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[eax] - indique que l'ajout est effectué avec la cellule RAM, dont l'adresse est dans le registre EAX. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment le processeur traite-t-il la commande ADD?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPU</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur la base de la description de la microarchitecture </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skylake</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">j'ai compilé une liste (extrêmement simplifiée) d'étapes:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les instructions X86 sont extraites d'un cache d'instructions L1 de 32 Ko dans un tampon de précodage de 16 octets</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les commandes précodées sont organisées dans la file d'instructions (taille 2x25) et pénètrent dans les décodeurs</font></font></li>
<li>  x86   1-4   (µOPs).  ADD  1 µOP  ALU (- )  2 µOP  AGU (  ) (<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">.</a>,    ).           86      .</li>
<li>   Allocation Queue (IDQ).    ,   Loop Stream Detector —     .</li>
<li> :     ,      .              .   .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La micro-opération est confiée au gestionnaire Unified Scheduler, qui décide à quel moment et à quel port envoyer les opérations à exécuter dans l'ordre de réception. </font><font style="vertical-align: inherit;">Derrière chaque port se trouve un actionneur. </font><font style="vertical-align: inherit;">Nos micro-opérations iront à ALU et AGU.</font></font></li>
</ol><br>
<img src="https://habrastorage.org/webt/xs/is/ij/xsisijruqtk6obopjmtkgx-fm7o.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le cœur de SkyLake. </font><font style="vertical-align: inherit;">Image de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en.wikichip.org</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je le répète, c'est ma description très simplifiée et ne prétend pas être exacte et complète. </font><font style="vertical-align: inherit;">Pour plus de référence, je recommande de lire le post </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Journey Through the Computing Processor Processor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et l'article </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Processors from the Intel Core i7 Family</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ALU</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il serait maintenant intéressant de savoir ce qui se passe à ALU: comment les chiffres sont-ils additionnés? Malheureusement, les informations sur la mise en œuvre spécifique de la microarchitecture et de l'ALU sont le secret commercial d'Intel, nous revenons donc à la théorie plus tard. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un dispositif pour ajouter deux bits binaires (c'est-à-dire un bit) est appelé </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">additionneur</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . La sortie est la somme et le bit de retenue. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/un/ic/bx/unicbxzbhpwhf79hla4ssznt9rw.gif"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Source: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikipédia</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Depuis dans la vie réelle, nous devons ajouter des nombres composés de plusieurs chiffres, l'additionneur doit également accepter le bit de retenue du chiffre précédent comme entrée. Un tel additionneur est appelé </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">plein</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/so/vw/jl/sovwjlxnsewbnpv5grlt8ii29_c.gif"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Source: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikipedia</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Comme le montre la figure, l'additionneur est composé d'éléments logiques: XOR, AND, OR. Et chaque élément logique</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut être implémenté à l'</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aide de plusieurs transistors. Ou même un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">relais</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/355/ccc/357/355ccc357f77c624fc089e5513679985.jpg" alt="Mattausch, conception CMOS, H20 / 6/6"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un exemple d'implémentation d'un additionneur complet sur les </font><font style="vertical-align: inherit;">transistors </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CMOS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Nous sommes donc arrivés au transistor! Bien que, bien sûr, non seulement les ALU fonctionnent sur les transistors, mais aussi sur d'autres unités de processeur, mais la plupart des transistors sont utilisés dans le cache comme ses cellules. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En réalité, le circuit additionneur de notre processeur peut être construit différemment et être beaucoup plus compliqué. Par exemple, il y a 45 ans déjà, Intel 8008 était en mesure de calculer tous les bits de retenue à l'avance afin d'effectuer l'addition en parallèle (le soi-disant additionneur avec report parallèle). Peu importe, lisez l'intéressant </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">article de blog</font></a><font style="vertical-align: inherit;"> sur la rétro-ingénierie ALU Intel 8008 dans le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blog</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ken Shirriff. </font><font style="vertical-align: inherit;">C'est-à-dire </font><font style="vertical-align: inherit;">Diverses optimisations sont utilisées: par exemple, la multiplication est également </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bénéfique à</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ne pas faire de front.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusions: qu'avons-nous appris?</font></font></h3><br>
<ul>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est compliqué</font></font></i></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela est clairement démontré: pour résoudre le problème de la complexité excessive, les ingénieurs utilisent la division de systèmes complexes en niveaux (couches).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les architectures à plusieurs niveaux offrent une portabilité: par exemple, Firefox peut fonctionner sur différents systèmes d'exploitation et sur différents matériels.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'interaction entre les niveaux est due à l'ouverture des spécifications des interfaces, des services et des formats de données, par exemple HTML et CSS, C ++, un ensemble de commandes x86, etc.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notre héros du jour travaille tout en bas - un </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transistor</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PS </font><font style="vertical-align: inherit;">Je suis un amateur (développeur web), et je connais un peu l'architecture C ++, ASM, BT - du cours de l'institut, je pourrais gâcher quelque chose. </font><font style="vertical-align: inherit;">N'hésitez pas à envoyer des commentaires.</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr400363/">https://habr.com/ru/post/fr400363/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr400351/index.html">Le restaurant KFC Smart en Chine devine les préférences des visiteurs par visage</a></li>
<li><a href="../fr400355/index.html">Crowdsourcing Amazon: comment un demi-million de personnes reçoivent un sou pour la formation en IA</a></li>
<li><a href="../fr400357/index.html">Google montre un modèle de charité à triple avantage</a></li>
<li><a href="../fr400359/index.html">Proprioception pour les non-spécialistes. Partie 3. Assis dynamique sur une chaise</a></li>
<li><a href="../fr400361/index.html">Foreve Elon 2016/2017 (réveillon du Nouvel An en ligne)</a></li>
<li><a href="../fr400365/index.html">Que promettent les utilisateurs de VKontakte en 2017</a></li>
<li><a href="../fr400367/index.html">Que faire le week-end: interphone avec télécommande, remappage sans budget Nextion, confrontation avec Onlaym</a></li>
<li><a href="../fr400371/index.html">2017 n'est pas seulement une prime ...</a></li>
<li><a href="../fr400377/index.html">Aperçu des matériaux 3D actuels</a></li>
<li><a href="../fr400379/index.html">Comment nous avons organisé la quête dans Telegram, et ce qui en est ressorti. UPD: nous avons résumé les résultats du concours</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>