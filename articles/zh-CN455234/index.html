<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‼️ 🚴🏾 🎈 C＃8.0中的可空引用类型和静态分析 🐍 👩‍👧‍👦 👕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="微软从事C＃语言的第8版已经有一段时间了，这不是什么秘密。 新的语言版本（C＃8.0）在Visual Studio 2019的最新版本中已经可用，但仍处于beta版本。 这个新版本将以一些不太明显或相当出乎意料的方式实现一些功能。 可空引用类型就是其中之一。 宣布此功能是与Null参考异常（NRE）...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C＃8.0中的可空引用类型和静态分析</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/455234/"><p><img src="https://habrastorage.org/getpro/habr/post_images/523/17b/496/52317b4960a8b063bc7b6541e4e2666d.png" alt="图片9"></p><br> 微软从事C＃语言的第8版已经有一段时间了，这不是什么秘密。 新的语言版本（C＃8.0）在Visual Studio 2019的最新版本中已经可用，但仍处于beta版本。 这个新版本将以一些不太明显或相当出乎意料的方式实现一些功能。 可空引用类型就是其中之一。 宣布此功能是与Null参考异常（NRE）对抗的一种手段。 <br><a name="habracut"></a><br> 很高兴看到该语言不断发展并获得新功能以帮助开发人员。 巧合的是，不久前，我们大大增强了PVS-Studio的C＃分析仪检测NRE的能力。 现在，我们想知道一般的静态分析器，尤其是PVS-Studio是否仍然应该费心去诊断潜在的空引用，因为至少在将要使用Nullable Reference的新代码中，这样的引用将变得“不可能”？ 让我们尝试清除它。 <br><br><h2> 新功能的优缺点 </h2><br> 在继续之前，有一个提醒：撰写本文时可用的最新beta版C＃8.0默认情况下禁用了Nullable引用类型，即，引用类型的行为未更改。 <br><br> 那么，如果启用此选项，在C＃8.0中什么是完全可为空的引用类型？ 它们基本上与旧的引用类型相同，只是现在您必须添加“？” 在类型名称（例如<i>string？</i> ）之后，类似于<i>Nullable &lt;T&gt;</i> ，即可空值类型（例如<i>int？</i> ）。 如果没有'？'，我们的<i>字符串</i>类型现在将被解释为不可为空的引用，即不能分配为<i>null</i>的引用类型。 <br><br> 空引用异常是进入程序的最令人烦恼的异常之一，因为它并没有过多说明其源代码，尤其是当throwing方法连续包含许多取消引用操作时。 禁止对引用类型的变量进行空值分配的功能看起来很酷，但是将<i>空值</i>传递给方法具有一些依赖于该方法的执行逻辑的情况又如何呢？ 当然，除了<i>null之外</i> ，我们还可以使用文字，常数或简单地“不可能”的值，这些值在逻辑上不能分配给其他任何地方的变量。 但这带来了用“无声的”但执行错误的程序替换崩溃的风险，这通常比立即解决错误要糟糕。 <br><br> 那么抛出异常呢？ 在发生问题的位置抛出的有意义的异常总是比堆​​栈上方或下方的<i>NRE</i>更好。 但这仅对您自己的项目有用，您可以在其中插入<i>try-catch</i>块来纠正使用者，这完全是您的责任。 当使用（非）Nullable Reference开发库时，我们需要保证某种方法总是返回一个值。 毕竟，即使在您自己的代码中，也不总是可能（或至少很容易）用异常抛出来代替返回<i>null</i> （因为这可能会影响太多代码）。 <br><br>  Nullable Reference可以在全局项目级别通过添加<i>NullableContextOptions</i>属性并为其启用值来<i>启用，</i>也可以在文件级别通过preprocessor指令<i>启用</i> ： <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable string cantBeNull = string.Empty; string? canBeNull = null; cantBeNull = canBeNull!;</span></span></code> </pre> <br> 可空引用功能将使类型更具信息性。 方法签名为您提供了有关其行为的线索：是否具有空检查，是否可以返回<i>空</i> 。 现在，当您尝试使用可为空的引用变量而不对其进行检查时，编译器将发出警告。 <br><br> 当使用第三方库时，这非常方便，但是也增加了误导库用户的风险，因为仍然可以使用新的允许<i>空</i>值的运算符（！）传递<i>null</i> 。 也就是说，仅添加一个感叹号可能会破坏使用此类变量的接口的所有进一步假设： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable String GetStr() { return _count &gt; 0 ? _str : null!; } String str = GetStr(); var len = str.Length;</span></span></code> </pre> <br> 是的，您可以辩称这是不好的编程，没有人会真正写出像这样的代码，但是，只要有可能做到这一点，您就不能仅仅依靠给定方法的接口所施加的约定而感到安全（说它不能返回<i>null</i> ）。 <br><br> 顺便说一句，您可以使用几个编写相同的代码<i>！</i> 运算符，因为C＃现在允许您这样做（并且这样的代码是完全可编译的）： <br><br><pre> <code class="cpp hljs">cantBeNull = canBeNull!!!!!!!;</code> </pre> <br> 通过这样写，我们可以强调这个想法，“看，这可能是<i>空的</i> ！！！”  （在我们的团队中，我们将此称为“情感”编程）。 实际上，在构建语法树时，编译器（来自Roslyn）解释了<i>！</i> 运算符与解释正则括号的方式相同，这意味着您可以编写尽可能多的<i>!！</i> 随便-就像用括号一样。 但是，如果您编写了足够多的代码，则可以“关闭”编译器。 也许这将在C＃8.0的最终版本中得到解决。 <br><br> 同样，在访问可为空的引用变量时，无需检查即可避免编译器警告： <br><br><pre> <code class="cpp hljs">canBeNull!.ToString();</code> </pre> <br> 让我们增加更多情绪： <br><br><pre> <code class="cpp hljs">canBeNull!!!?.ToString();</code> </pre> <br> 但是，您几乎看不到实际代码中的语法。 通过编写可为<i>null的</i>运算符，我们告诉编译器“此代码可以，不需要检查。” 通过添加猫王运算符，我们告诉它： 让我们检查一下以防万一。” <br><br> 现在，您可以合理地问，为什么仍然可以轻松地将<i>null</i>分配给不可为空的引用类型的变量，如果这些类型的确切含义暗示此类变量不能具有<i>null值</i>呢？ 答案是，在IL代码级别的“幕后”，我们的不可为空的引用类型仍然是...很好的旧“常规”引用类型，并且整个可空性语法实际上只是编译器内置的注释。分析器（我们认为使用起来不太方便，但稍后会详细说明）。 就个人而言，我们认为将新语法作为第三方工具的注释（甚至内置于编译器中）只是一种“整洁”的解决方案，因为事实上这仅仅是一个注释，可能根本看不出来对程序员而言，因为此语法与可为空的结构的语法非常相似，但其工作方式却完全不同。 <br><br> 回到打破Nullable引用类型的其他方式。 在撰写本文时，当您有一个包含多个项目的解决方案时，请将引用类型的变量（例如， <i>字符串）</i>从一个项目中声明的方法传递给另一个具有<i>NullableContext的</i>项目中的方法。编译器假定它正在处理不可为null的String，并且编译器将保持沉默。 尽管启用了Nullable References时，IL代码中的每个字段和方法都添加了大量的<i>[Nullable（1）]</i>属性<i>。</i> 顺便说一下，如果您使用反射来处理这些属性并假定代码仅包含您的自定义属性，则应考虑这些属性。 <br><br> 当将大型代码库调整为Nullable Reference样式时，这种情况可能会引起其他麻烦。 此过程可能会逐项目运行一段时间。 当然，如果谨慎，可以逐步集成新功能，但是如果您已经有一个正在运行的项目，则对其进行任何更改都是危险且不可取的（如果可行，请不要触摸它！）。 这就是为什么我们确保您在使用PVS-Studio分析仪时不必修改源代码或将其标记为检测潜在的<i>NRE</i>的原因。 要检查可能引发<i>NullReferenceException的</i>位置<i>，</i>只需运行分析器并查找V3080警告。 无需更改项目的属性或源代码。 无需添加指令，属性或运算符。 无需更改旧代码。 <br><br> 在为PVS-Studio添加可空引用支持时，我们必须决定分析器是否应假定非空引用类型的变量始终具有非空值。 在研究了打破此保证的方式后，我们决定PVS-Studio不应该做出这样的假设。 毕竟，即使一个项目一直使用不可为空的引用类型，分析器也可以通过检测这些变量的值为<i>null的</i>特定情况来添加此功能。 <br><br><h2>  PVS-Studio如何查找空引用异常 </h2><br>  PVS-Studio的C＃分析器中的数据流机制在分析过程中跟踪变量的可能值。 这也包括过程间分析，即跟踪方法及其嵌套方法返回的可能值，等等。 除此之外，PVS-Studio还会记住可以分配<i>空</i>值的变量。 每当发现此类变量在未经检查的情况下被取消引用时，无论是在当前正在分析的代码中，还是在此代码中调用的方法内部，都将发出V3080警告，提示可能存在Null引用异常。 <br><br> 该诊断背后的想法是让分析仪仅在看到<i>空</i>分配时才会生气。 这是我们诊断行为与编译器内置分析器处理Nullable Reference类型的行为之间的主要区别。 内置分析器将指向未检查的可为空的参考变量的每个取消引用-假定没有被使用<i>！</i>误导了<i>。</i> 操作员，甚至只是一个复杂的检查（但是，应该注意，绝对可以将任何静态分析仪（这里也不例外）PVS-Studio可以以一种或另一种方式“混合”，特别是如果您打算这样做）。 <br><br> 另一方面，PVS-Studio仅在看到<i>空值时</i> （无论是在本地上下文中还是在外部方法的上下文中）警告您。 即使变量是不可为空的引用类型，如果分析器看到对该变量的<i>空</i>赋值，它也将始终指向该变量。 我们认为，这种方法更合适（或至少对用户更方便），因为它不需要使用空检查来“涂抹”整个代码以跟踪潜在的取消引用-毕竟，即使在可空引用之前，此选项仍然可用例如通过使用合同进行介绍。 而且，分析器现在可以更好地控制非空引用变量本身。 如果“公平地”使用了这样的变量并且从未将其分配为<i>null</i> ，则PVS-Studio不会说一个字。 如果将变量分配为<i>null</i> ，然后在没有事先检查的情况下将其取消引用，PVS-Studio将发出V3080警告： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable String GetStr() { return _count &gt; 0 ? _str : null!; } String str = GetStr(); var len = str.Length; &lt;== V3080: Possible null dereference. Consider inspecting </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'str'</span></span></span></span></code> </pre> <br> 现在，让我们看一些示例，这些示例演示了Roslyn本身的代码如何触发此诊断。 我们最近已经<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">检查了该项目</a> ，但是这次我们将仅查看先前文章中未提及的潜在的Null引用异常。 我们将看到PVS-Studio如何检测潜在的NRE，以及如何使用新的Nullable Reference语法对其进行修复。 <br><br>  <i>V3080 [CWE-476]方法内部可能存在空取消引用。</i>  <i>考虑检查第二个参数：chainedTupleType。</i>  <i>Microsoft.CodeAnalysis.CSharp TupleTypeSymbol.cs 244</i> <br><br><pre> <code class="cpp hljs">NamedTypeSymbol chainedTupleType; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_underlyingType.Arity &lt; TupleTypeSymbol.RestPosition) { .... chainedTupleType = null; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Create(ConstructTupleUnderlyingType(firstTupleType, chainedTupleType, newElementTypes), elementNames: _elementNames);</code> </pre> <br> 如您所见，可以在执行分支之一中为<i>chainedTupleType</i>变量分配<i>空</i>值。 然后将其传递给<i>ConstructTupleUnderlyingType</i>方法，并在<i>Debug.Assert</i>检查之后在<i>此</i>使用。 这是Roslyn中非常常见的模式，但请记住，在发行版中已删除了<i>Debug.Assert</i> 。 这就是为什么分析器仍然认为<i>ConstructTupleUnderlyingType</i>方法内的取消引用很危险。 这是该方法的主体，在该主体中进行取消引用： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> NamedTypeSymbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConstructTupleUnderlyingType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( NamedTypeSymbol firstTupleType, NamedTypeSymbol chainedTupleTypeOpt, ImmutableArray&lt;TypeWithAnnotations&gt; elementTypes)</span></span></span><span class="hljs-function"> </span></span>{ Debug.Assert (chainedTupleTypeOpt is null == elementTypes.Length &lt; RestPosition); .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (loop &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... currentSymbol = chainedTupleTypeOpt.Construct(chainedTypes); loop--; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentSymbol; }</code> </pre> <br> 分析器是否应考虑这样的Asserts（我们的某些用户希望这样做）实际上是一个争议问题-毕竟，分析器确实考虑了System.Diagnostics.Contracts的合同。 这是根据我们在自己的分析仪中使用Roslyn的经验得出的一个小实例。 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">最近添加对Visual Studio最新版本的支持的</a>同时，我们还将Roslyn更新到了其第三版。 此后，PVS-Studio开始因以前从未崩溃的某些代码而崩溃。 崩溃以及Null引用异常不会在我们的代码中发生，而是在Roslyn的代码中发生。 调试显示，Roslyn现在崩溃的代码段具有这种<i>Debug.Assert</i>基于null的检查行高了几行-该检查显然没有帮助。 <br><br> 这是一个图形示例，说明由于编译器将<i>Debug.Assert</i>视为任何配置中的可靠检查，因此您可能会遇到Nullable Reference的麻烦。 也就是说，如果添加<i>#nullable enable</i>并将标记的<i>chainedTupleTypeOpt</i>参数标记为可为空的引用<i>，</i>则编译器将不会在<i>ConstructTupleUnderlyingType</i>方法内对取消引用发出任何警告。 <br><br> 转到PVS-Studio的其他警告示例。 <br><br>  <i>V3080可能为空的取消引用。</i>  <i>考虑检查“ effectiveRuleset”。</i>  <i>RuleSet.cs 146</i> <br><br><pre> <code class="cpp hljs">var effectiveRuleset = ruleSet.GetEffectiveRuleSet(includedRulesetPaths); effectiveRuleset = effectiveRuleset.WithEffectiveAction(ruleSetInclude.Action); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsStricterThan(effectiveRuleset.GeneralDiagnosticOption, ....)) effectiveGeneralOption = effectiveRuleset.GeneralDiagnosticOption;</code> </pre><br> 此警告说，对<i>WithEffectiveAction</i>方法的调用可能返回<i>null</i> ，而在使用前未检查分配给变量<i>有效规则集</i>的返回值（ <i>有效</i> <i>规则集.GeneralDiagnosticOption</i> ）。 这是<i>WithEffectiveAction</i>方法的<i>正文</i> ： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RuleSet </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WithEffectiveAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ReportDiagnostic action)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_includes.IsEmpty) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(....); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Suppress: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuleSet(....); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } }</code> </pre> <br> 通过为方法<i>GetEffectiveRuleSet</i>启用Nullable Reference，我们将获得两个必须更改代码行为的位置。 由于上面显示的方法可以引发异常，因此逻辑上假设对它的调用包装在<i>try-catch</i>块中，并且重写该方法以引发异常而不是返回<i>null</i>是正确的。 但是，如果您跟踪一些回叫，则会发现捕获的代码距离太远，无法可靠地预测后果。 让我们看一看<i>有效</i> <i>Ruleset</i>变量的使用方<i>IsStricterThan</i>方法： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsStricterThan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ReportDiagnostic action1, ReportDiagnostic action2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action2) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Suppress: ....; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Warn: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> action1 == ReportDiagnostic.Error; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Error: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br> 如您所见，这是一个简单的switch语句，可以在两个枚举之间进行选择，其中<i>ReportDiagnostic.Default</i>为默认值。 因此，最好将调用重写如下： <br><br>  <i>WithEffectiveAction</i>的签名将更改： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable public RuleSet? WithEffectiveAction(ReportDiagnostic action)</span></span></code> </pre> <br> 该呼叫将如下所示： <br><br><pre> <code class="cpp hljs">RuleSet? effectiveRuleset = ruleSet.GetEffectiveRuleSet(includedRulesetPaths); effectiveRuleset = effectiveRuleset?.WithEffectiveAction(ruleSetInclude.Action); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsStricterThan(effectiveRuleset?.GeneralDiagnosticOption ?? ReportDiagnostic.Default, effectiveGeneralOption)) effectiveGeneralOption = effectiveRuleset.GeneralDiagnosticOption;</code> </pre> <br> 由于<i>IsStricterThan</i>仅执行比较，因此可以重写条件-例如，如下所示： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effectiveRuleset == null || IsStricterThan(effectiveRuleset.GeneralDiagnosticOption, effectiveGeneralOption))</code> </pre> <br> 下一个例子。 <br><br>  <i>V3080可能为空的取消引用。</i>  <i>考虑检查“ propertySymbol”。</i>  <i>BinderFactory.BinderFactoryVisitor.cs 372</i> <br><br><pre> <code class="cpp hljs">var propertySymbol = GetPropertySymbol(parent, resultBinder); var accessor = propertySymbol.GetMethod; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)accessor != null) resultBinder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InMethodBinder(accessor, resultBinder);</code> </pre> <br> 要解决此警告，我们接下来需要查看<i>propertySymbol</i>变量会发生什么。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> SourcePropertySymbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPropertySymbol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( BasePropertyDeclarationSyntax basePropertyDeclarationSyntax, Binder outerBinder)</span></span></span><span class="hljs-function"> </span></span>{ .... NamedTypeSymbol container = GetContainerType(outerBinder, basePropertyDeclarationSyntax); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)container == null) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (SourcePropertySymbol)GetMemberSymbol(propertyName, basePropertyDeclarationSyntax.Span, container, SymbolKind.Property); }</code> </pre> <br> 在某些情况下， <i>GetMemberSymbol</i>方法也可以返回<i>null</i> 。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Symbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMemberSymbol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> memberName, TextSpan memberSpan, NamedTypeSymbol container, SymbolKind kind)</span></span></span><span class="hljs-function"> </span></span>{ foreach (Symbol sym in container.GetMembers(memberName)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sym.Kind != kind) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sym.Kind == SymbolKind.Method) { .... var implementation = ((MethodSymbol)sym).PartialImplementationPart; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)implementation != null) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (InSpan(implementation.Locations[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.syntaxTree, memberSpan)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> implementation; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (InSpan(sym.Locations, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.syntaxTree, memberSpan)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sym; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; }</code> </pre> <br> 启用可空引用类型后，调用将更改为此： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable SourcePropertySymbol? propertySymbol = GetPropertySymbol(parent, resultBinder); MethodSymbol? accessor = propertySymbol?.GetMethod; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((object)accessor != null) resultBinder = new InMethodBinder(accessor, resultBinder);</span></span></code> </pre> <br> 当您知道在哪里查看时，很容易修复。 通过从所有过程调用链中收集字段的所有可能值，静态分析可以毫不费力地捕获此潜在错误。 <br><br>  <i>V3080可能为空的取消引用。</i>  <i>考虑检查“ simpleName”。</i>  <i>CSharpCommandLineParser.cs 1556</i> <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> simpleName; simpleName = PathUtilities.RemoveExtension( PathUtilities.GetFileName(sourceFiles.FirstOrDefault().Path)); outputFileName = simpleName + outputKind.GetDefaultExtension(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (simpleName.Length == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; !outputKind.IsNetModule()) ....</code> </pre> <br> 问题出在<i>simpleName.Length</i>检查。 变量<i>simpleName</i>是通过执行一系列方法产生的，可以分配为<i>null</i> 。 顺便说一句，如果您好奇的话，可以查看<i>RemoveExtension</i>方法，以了解它与<i>Path.GetFileNameWithoutExtension有何</i>不同<i>。</i> 一个<i>simpleName！=空</i>检查就足够了，但是对于非空引用类型，代码将变为如下所示： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable public static string? RemoveExtension(string path) { .... } string simpleName;</span></span></code> </pre> <br> 呼叫可能如下所示： <br><br><pre> <code class="cpp hljs">simpleName = PathUtilities.RemoveExtension( PathUtilities.GetFileName(sourceFiles.FirstOrDefault().Path)) ?? String.Empty;</code> </pre> <br><h2> 结论 </h2><br> 从零开始设计体系结构时，可空引用类型可以提供很大的帮助，但是重新编写现有代码可能需要很多时间和精力，因为它可能会导致许多难以捉摸的错误。 本文并不旨在阻止您使用Nullable Reference类型。 我们发现此新功能通常很有用，即使其具体实现方式可能会引起争议。 <br><br> 但是，请始终记住这种方法的局限性，并牢记启用“可空引用”模式并不能保护您免受NRE的侵害，一旦滥用，它本身就可能成为这些错误的来源。 我们建议您使用现代的静态分析工具（例如PVS-Studio）对Nullable Reference功能进行补充，该工具支持过程间分析以保护您的程序免受NRE的侵害。 这些方法中的每一种-深入的过程间分析和注释方法签名（实际上是Nullable Reference模式所做的）-都有其优点和缺点。 分析器将为您提供潜在危险位置的列表，并让您查看修改现有代码的后果。 如果某处有空分配，则分析器将指向该变量的每个使用方，在不检查的情况下将其取消引用。 <br><br> 您可以检查该项目或您自己的项目是否存在其他缺陷-只需<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">下载</a> PVS-Studio并尝试一下。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN455234/">https://habr.com/ru/post/zh-CN455234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN455218/index.html">商业技术的生态系统方法</a></li>
<li><a href="../zh-CN455224/index.html">手指音乐：使用Sphero的SpecDrums演奏任何音乐</a></li>
<li><a href="../zh-CN455226/index.html">为什么申请应聘的语言学家？</a></li>
<li><a href="../zh-CN455228/index.html">复活努克公爵的人：专访变速箱向导的兰迪·皮特福德</a></li>
<li><a href="../zh-CN455230/index.html">C＃8.0中的可空引用类型和静态分析</a></li>
<li><a href="../zh-CN455236/index.html">Comodo无故撤销证书</a></li>
<li><a href="../zh-CN455240/index.html">使用不良率来改善错误报告</a></li>
<li><a href="../zh-CN455242/index.html">从一开始就减少耳朵或如何不破坏游戏中的声音</a></li>
<li><a href="../zh-CN455244/index.html">更新版本的漫画“轻松焊接”（2019）</a></li>
<li><a href="../zh-CN455246/index.html">圣彼得堡客户体验日注册将于6月20日开始</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>