<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì∑ üëß üîÜ Memo. AVR Buzic üì£ üñäÔ∏è üê≤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esensi 
 Saya telah membuat sejumlah perangkat elektronik hobi yang berbeda, dan saya memiliki fitur aneh: jika ada emitor piezoelektrik suara (buzzer...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memo. AVR Buzic</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/402329/"><img src="https://habrastorage.org/files/a62/a7b/0f9/a62a7b0f93e34b378c415b8d4b1873bb.jpg"><br><h3>  Esensi </h3><br>  Saya telah membuat sejumlah perangkat elektronik hobi yang berbeda, dan saya memiliki fitur aneh: jika ada emitor piezoelektrik suara (buzzer) di papan, saya, setelah menyelesaikan pekerjaan utama pada proyek, mulai menderita omong kosong dan membuatnya memainkan berbagai melodi (sebanyak mungkin) )  Sangat berguna untuk memasukkan melodi di akhir proses yang panjang untuk menarik perhatian.  Sebagai contoh, saya menggunakannya ketika saya membangun kamera eksposur darurat untuk menerangi photoresist, dll. <br><br>  Tetapi ketika saya mulai mencari contoh-contoh pembangkit frekuensi untuk AVR di jaringan, untuk beberapa alasan saya menemukan proyek-proyek yang mengerikan atau tidak cukup ringkas yang mengimplementasikan pembangkitan frekuensi suara dengan cara yang murni terprogram.  Dan kemudian saya memutuskan untuk mencari tahu sendiri ... <br><a name="habracut"></a><br><h3>  Penyimpangan liris </h3><br>  Hobi saya mencakup penciptaan berbagai perangkat pada mikrokontroler, karena ini tidak bersinggungan dengan prof saya.  aktivitas (pengembangan perangkat lunak), saya menganggap diri saya otodidak, dan dalam elektronik tidak terlalu kuat.  Sebenarnya, saya lebih suka mikrokontroler PIC, tetapi kebetulan saya telah mengumpulkan sejumlah mikrokontroler Atmel AVR (sekarang sudah Microchip).  Segera buat reservasi yang saya tidak pernah miliki AVR di tangan saya, yaitu  Ini adalah proyek pertama saya di Atmel MCU, yaitu Atmega48pa.  Proyek itu sendiri melakukan beberapa payload, tetapi di sini saya akan menjelaskan hanya sebagian yang terkait dengan generasi frekuensi suara.  Tes untuk menghasilkan frekuensi yang saya sebut "buzic", sebagai singkatan untuk musik buzzer.  Ya, saya hampir lupa: pada Habr ada pengguna dengan nama panggilan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">buzic</a> , saya ingin segera memperingatkan bahwa memo ini tidak berlaku baginya, dan untuk berjaga-jaga, saya segera meminta maaf karena menggunakan kombinasi huruf "Buzic". <br><br><h3>  Jadi ayo pergi </h3><br>  Saya berkenalan dengan sejumlah besar contoh dari jaringan - semuanya dibangun baik pada siklus paling sederhana di bagian utama firmware, atau dalam gangguan timer.  Tetapi mereka semua menggunakan pendekatan yang sama untuk menghasilkan frekuensi: <br><br><ol><li>  beri makan tingkat tinggi ke kaki mikrokontroler </li><li>  membuat penundaan </li><li>  umpan rendah ke kaki mikrokontroler </li></ol><br>  Mengubah pengaturan waktu tunda dan timer - sesuaikan frekuensi. <br><br>  Pendekatan ini tidak cocok untuk saya, karena  Saya tidak punya keinginan untuk menulis kode untuk kontrol manual kaki mikrokontroler.  Saya ingin "batu" untuk menghasilkan frekuensi suara untuk saya, dan saya hanya mengatur nilai register tertentu, sehingga mengubahnya (frekuensi). <br><br>  Saat mempelajari datasheet (selanjutnya disebut sebagai DS), saya masih menemukan mode timer yang saya butuhkan - dan mode ini, seperti yang Anda duga, adalah mode CTC (Clear Timer on Compare Match).  Karena fungsi memainkan musik, secara sederhana, bukan fungsi utama, saya lebih suka memilih timer 2 untuk itu (paragraf 22 SD). <br><br>  Semua orang tahu bahwa hampir semua mikrokontroler memiliki mode pembuatan sinyal PWM yang diterapkan pada timer dan sepenuhnya perangkat keras.  Tetapi dalam tugas ini, PWM tidak cocok karena  hanya satu frekuensi yang akan dihasilkan dalam perangkat keras.  Oleh karena itu, kita memerlukan PFM (modulasi frekuensi pulsa).  Beberapa kesamaan PFM adalah mode timer CTC (klausa 22.7.2 LH). <br><br><h3>  Mode CTC </h3><br>  Timer 2 dalam mikrokontroler Atmega48pa adalah 8-bit, yaitu, "kutu" dari 0 hingga 255 dan kemudian berjalan dalam lingkaran.  Omong-omong, timer dapat bergerak ke arah yang berbeda, tetapi tidak dalam kasus kami.  Komponen yang diperlukan berikutnya adalah Unit Bandingkan.  Berbicara dengan sangat kasar, modul ini adalah inisiator dari setiap peristiwa yang berkaitan dengan timer.  Peristiwa dapat berbeda - seperti interupsi, perubahan tingkat kaki tertentu mikrokontroler, dll. (Jelas, kami tertarik pada yang kedua).  Seperti yang Anda tebak, modul perbandingan tidak hanya bernama - itu membandingkan nilai tertentu yang dipilih oleh pengembang firmware dengan nilai timer saat ini.  Jika nilai waktu mencapai nilai yang kita atur, suatu peristiwa terjadi.  Peristiwa juga dapat terjadi ketika timer meluap atau selama reset.  <b>Ok, kami sampai pada kesimpulan bahwa nyaman bagi kami pada waktu-waktu tertentu bahwa timer, bersama dengan modul perbandingan, secara independen mengubah level kaki mikrokontroler ke arah yang berlawanan - sehingga menghasilkan pulsa.</b> <br><br>  Tugas kedua adalah mengatur interval antara pulsa-pulsa ini - mis.  mengontrol frekuensi generasi.  Seluruh keunikan mode CTC terletak pada kenyataan bahwa dalam mode ini timer tidak menuju ke akhir (255), tetapi diatur ulang ketika nilai yang ditetapkan tercapai.  Dengan demikian, dengan mengubah nilai ini, kita sebenarnya dapat mengontrol frekuensi.  Sebagai contoh, jika kita mengatur nilai modul perbandingan ke 10, maka perubahan level pada kaki mikrokontroler akan terjadi 20 kali lebih sering daripada jika kita mengaturnya (nilai modul perbandingan) menjadi 200. <b>Sekarang kita dapat mengontrol frekuensi!</b> <br><br><img src="https://habrastorage.org/files/d45/90e/b7a/d4590eb7acd543a59fc71057cc6ae5b5.png"><br><br><h3>  Besi </h3><br><img src="https://habrastorage.org/files/8f9/dbb/8f5/8f9dbb8f514f4819863dff1a4dff4690.png"><br>  Pinout mikrokontroler menunjukkan bahwa kita perlu menghubungkan buzzer ke kaki PB3 (OC2A) atau kaki PD3 (OC2B), karena  OC2A dan OC2B berarti persis bahwa pada kaki ini, timer 2 dapat menghasilkan sinyal. <br><br>  Skema yang biasanya saya gunakan untuk menghubungkan buzzer adalah: <br><img src="https://habrastorage.org/files/8c8/a1e/7c6/8c8a1e7c67cf433989b5b94b89fa3e55.png"><br><br>  <b>Jadi kami merakit perangkat.</b> <br><br><h3>  Daftar </h3><br>  Pada paragraf sebelumnya, kami memutuskan pilihan kaki - ini adalah PB3 (OC2A), kami akan bekerja dengannya.  Jika Anda membutuhkan PD3, maka baginya semuanya akan sama, yang akan terlihat jelas dari cerita. <br><br>  Kami akan mengkonfigurasi timer 2 kami dengan mengubah 3 register: <br><ol><li>  TCCR2A - pengaturan mode dan pemilihan perilaku </li><li>  TCCR2B - pengaturan mode dan pembagi frekuensi timer (juga FOC bit - kami tidak menggunakannya) </li><li>  OCR2A (OCR2B untuk kasus kaki PD3) - nilai modul perbandingan </li></ol><br><br>  Pertimbangkan dulu register TCCR2A dan TCCR2B <br><img src="https://habrastorage.org/files/37b/def/522/37bdef52208b48b381b06405d9eddcb5.png"><br>  Seperti yang Anda lihat, kami memiliki 3 kelompok bit yang signifikan bagi kami - ini adalah bit dari seri COM2xx, WGM2x dan CS2x <br>  Hal pertama yang perlu kita ubah adalah WGM2x - ini adalah hal utama untuk memilih mode pembuatan - bit ini digunakan untuk memilih mode CTC kami. <br><br><img src="https://habrastorage.org/files/f34/28d/3e3/f3428d3e3ecc4e1aafcef3c82b061d23.png"><br>  <i>Catatan: jelas di LH kesalahan ketik dalam "Pembaruan OCR0x di" harus OCR2x</i> <br><br>  Yaitu  kodenya akan seperti ini: <br><pre><code class="cpp hljs">TCCR2A = _BV(WGM21) ;</code> </pre> <br>  Seperti yang Anda lihat, TCCR2B belum digunakan.  WGM22 harus nol, tetapi sudah nol. <br><br>  Langkah selanjutnya adalah mengkonfigurasi bit COM2xx, lebih tepatnya COM2Ax - karena  kami bekerja dengan kaki PB3 (untuk COM3Bx PD3 digunakan dengan cara yang sama).  Apa yang akan terjadi pada kaki PB3 kita tergantung pada mereka. <br><br>  Bit COM2xx bergantung pada mode yang kami pilih dengan bit WGM2x, jadi kami harus menemukan bagian yang sesuai di LH.  Karena  kami memiliki mode CTC, mis.  bukan PWM, maka kami mencari piring "Bandingkan Mode Output, non-PWM", ini dia: <br><img src="https://habrastorage.org/files/771/054/3e2/7710543e25404353b1c1056cd3a58483.png"><br>  Di sini Anda perlu memilih "Toggle" - sehingga level pada kaki berubah ke kebalikan ketika timer mencapai nilai yang ditetapkan.  Level konstan berubah dan mengimplementasikan generasi frekuensi yang kita butuhkan. <br><br>  Karena  bit COM2xx juga ada dalam register TCCR2A - hanya itu yang berubah: <br><pre> <code class="cpp hljs">TCCR2A = _BV(COM2A0) | _BV(WGM21) ;</code> </pre><br>  Tentu, Anda juga perlu memilih pembagi frekuensi dengan bit CS2x, dan tentu saja, mengatur kaki PB3 ke output ... tapi kami tidak akan melakukannya sehingga ketika kami menghidupkan MK, kami tidak akan mendapatkan pekikan tajam pada frekuensi yang tidak dapat dipahami, tetapi ketika kami melakukan semua pengaturan lain dan hidupkan kaki untuk keluar - akan dijelaskan di bawah ini. <br><br>  Jadi mari kita lihat inisialisasi kita: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;avr/io.h&gt; //set bit - using bitwise OR operator #define sbi(x,y) x |= _BV(y) //clear bit - using bitwise AND operator #define cbi(x,y) x &amp;= ~(_BV(y)) #define BUZ_PIN PB3 void timer2_buzzer_init() { // PB3 cbi(PORTB, BUZ_PIN); // PB3  ,    cbi(DDRB, BUZ_PIN); //  TCCR2A = _BV(COM2A0) | _BV(WGM21) ; //   (      ) OCR2A = 0; }</span></span></span></span></code> </pre><br>  Saya menggunakan makro cbi dan sbi (memata-matai suatu tempat di jaringan) untuk mengatur bit individual, dan membiarkannya seperti itu.  Makro ini, tentu saja, telah ditempatkan di file header, tetapi untuk kejelasan, saya taruh di sini. <br><br><h3>  Perhitungan frekuensi dan durasi catatan </h3><br>  Sekarang kita sampai pada inti permasalahannya.  Beberapa waktu yang lalu, kenalan musisi mencoba untuk mengarahkan sejumlah informasi tentang staf musik ke otak programmer saya, otak saya hampir mendidih, tetapi saya masih mengeluarkan sebutir berguna dari percakapan ini. <br>  Saya memperingatkan Anda segera - ketidakakuratan besar mungkin terjadi. <br><ol><li>  masing-masing ukuran terdiri dari 4 kuartal </li><li>  Setiap melodi memiliki tempo - yaitu  jumlah tempat seperti itu per menit </li><li>  Setiap not dapat dimainkan sebagai seluruh ukuran keseluruhan, serta bagiannya 1/2, 1/3, 1/4, dll. </li><li>  Setiap nada, tentu saja, memiliki frekuensi tertentu </li></ol><br>  Kami memeriksa kasus yang paling umum, pada kenyataannya, semuanya lebih rumit di sana, setidaknya bagi saya, jadi saya tidak akan membahas topik ini dalam kerangka cerita ini. <br><br>  Baiklah, kita akan bekerja dengan apa yang kita miliki.  Hal yang paling penting bagi kami adalah pada akhirnya mendapatkan frekuensi catatan (pada kenyataannya, nilai register OCR2A) dan durasinya, misalnya, dalam milidetik.  Oleh karena itu, perlu untuk membuat perhitungan. <br><br>  Karena  kita berada dalam kerangka bahasa pemrograman, melodi paling mudah untuk disimpan dalam sebuah array.  Cara paling logis untuk mengatur setiap elemen array dalam format adalah catatan + durasi.  Penting untuk menghitung ukuran elemen dalam byte, karena kami menulis di bawah mikrokontroler dan dengan sumber daya di sini adalah ketat - itu berarti ukuran elemen dalam byte harus memadai. <br><br><h4>  Frekuensi </h4><br>  Mari kita mulai dengan frekuensinya.  Karena  kami memiliki timer 8-bit 2, register perbandingan OCR2A juga 8-bit.  Artinya, elemen kami dari array melodi sudah akan setidaknya 2 byte, karena Anda masih perlu menyimpan durasinya.  Bahkan, 2 byte adalah batas untuk jenis kerajinan ini.  Kami masih belum mendapatkan suara yang bagus, untuk membuatnya lebih halus, dan menghabiskan lebih banyak byte tidak masuk akal.  <b>Jadi, kami berhenti pada 2 byte.</b> <br><br>  <b>Saat menghitung frekuensi, sebenarnya, masalah besar lain muncul.</b> <br>  Jika Anda melihat frekuensi not, kita akan melihat bahwa not dibagi menjadi oktaf. <br><img src="https://habrastorage.org/files/240/294/17a/24029417a547408aa6806c9ddf66d593.jpg"><br>  Untuk sebagian besar melodi sederhana, 3 oktaf sudah cukup, tetapi saya memutuskan untuk mengelak dan menerapkan 6: besar, kecil dan 4 berikutnya. <br><br>  Sekarang mari kita menyimpang dari musik dan terjun kembali ke dunia pemrograman mikrokontroler. <br>  Setiap timer dalam AVR (dan sebagian besar MK lainnya) terkait dengan frekuensi MK itu sendiri.  Frekuensi kuarsa di sirkuit saya adalah 16Mhz.  Frekuensi yang sama ditentukan oleh F_CPU "define" sama dengan 16000000 dalam kasus saya. Dalam register TCCR2B, kita dapat memilih pembagi frekuensi sehingga timer 2 kita tidak "menandai" pada kecepatan panik 16000000 kali per detik, tetapi sedikit lebih lambat.  Pembagi frekuensi dipilih oleh bit CS2x, seperti yang disebutkan di atas. <br><br><img src="https://habrastorage.org/files/9bd/ca6/247/9bdca624740e4dd787574c6604291dc3.png"><br>  <i>Catatan: jelas dalam LH kesalahan ketik bukan "CA2x" harus CS2x</i> <br><br>  Muncul pertanyaan - bagaimana cara mengkonfigurasi pembagi? <br><br>  Untuk melakukan ini, Anda perlu memahami cara menghitung nilai untuk register OCR2A.  Dan menghitungnya cukup sederhana: <br>  <b>OCR2A = F_CPU / (pembagi frekuensi kuarsa * 2) / frekuensi catatan</b> <br>  Misalnya, ambil catatan SEBELUM oktaf pertama dan pembagi 256 (CS22 = 1, CS21 = 1, CS20 = 0): <br>  OCR2A = 16000000 / (256 * 2) / 261 = 119 <br><br>  Saya akan segera menjelaskan dari mana penggandaan oleh 2 berasal. Faktanya adalah bahwa kami memilih mode "Toggle" dengan register COM2Ax, yang berarti bahwa perubahan level pada kaki dari rendah ke tinggi (atau sebaliknya) dan kembali akan terjadi dalam 2 lintasan timer: pertama timer mencapai nilai OCR2A dan mengubah kaki mikrokontroler, misalnya, dari 1 ke 0, diatur ulang dan hanya pada putaran kedua berubah 0 kembali ke 1. Oleh karena itu, 2 putaran timer pergi untuk setiap gelombang penuh, masing-masing, pembagi harus dikalikan dengan 2, jika tidak kita hanya mendapatkan setengah dari frekuensi catatan kami. <br><br>  Oleh karena itu kemalangan yang disebutkan di atas ... <br><br>  Jika kita mengambil catatan SEBELUM oktaf besar dan meninggalkan pembagi 256: <br>  OCR2A = 16000000 / (256 * 2) / 65 = 480 !!! <br>  <b>480 - jumlah ini jelas lebih dari 255 dan secara fisik tidak masuk ke dalam register OCR2A 8-bit.</b> <br><br>  Apa yang harus dilakukan  Jelas mengubah pembagi, tetapi jika kita menempatkan pembagi 1024, maka dengan oktaf besar, semuanya akan baik-baik saja.  Masalah akan dimulai dengan oktaf atas: <br>  LA 4th Octave - OCR2A = 16000000 / (1024 * 2) / 3520 = 4 <br>  Oktaf keempat yang tajam - OCR2A = 16000000 / (1024 * 2) / 3729 = 4 <br>  <b>Nilai OCR2A tidak lagi berbeda, yang berarti bahwa suara juga akan berhenti berbeda.</b> <br><br>  <b>Hanya ada satu jalan keluar: untuk frekuensi catatan Anda perlu menyimpan tidak hanya nilai register OCR2A, tetapi juga bit pembagi frekuensi kuarsa.</b>  <b>Karena</b>  <b>untuk oktaf yang berbeda akan ada nilai yang berbeda dari pembagi frekuensi kuarsa, yang kita perlu atur di register TCCR2B!</b> <br><br>  Sekarang semuanya jatuh ke tempatnya - dan saya akhirnya menjelaskan mengapa kita tidak bisa langsung mengisi nilai pembagi di fungsi timer2_buzzer_init (). <br><br>  Sayangnya, pembagi frekuensi adalah 3 bit lebih banyak.  Dan mereka harus diambil dalam byte kedua elemen array melodi. <br><br><div class="spoiler">  <b class="spoiler_title">Hidup makro</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DIV_MASK (_BV(CS20) | _BV(CS21) | _BV(CS22)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DIV_1024 (_BV(CS20) | _BV(CS21) | _BV(CS22)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DIV_256 (_BV(CS21) | _BV(CS22)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DIV_128 (_BV(CS20) | _BV(CS22)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DIV_64 _BV(CS22) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DIV_32 (_BV(CS20) | _BV(CS21)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NOTE_1024( x ) ((F_CPU / (1024 * 2) / x) | (DIV_1024 &lt;&lt; 8)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NOTE_256( x ) ((F_CPU / (256 * 2) / x) | (DIV_256 &lt;&lt; 8)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NOTE_128( x ) ((F_CPU / (128 * 2) / x) | (DIV_128 &lt;&lt; 8)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NOTE_64( x ) ((F_CPU / (64 * 2) / x) | (DIV_64 &lt;&lt; 8)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NOTE_32( x ) ((F_CPU / (32 * 2) / x) | (DIV_32 &lt;&lt; 8)) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  #define DOB NOTE_1024( 65 ) #define DO_B NOTE_1024( 69 ) #define REB NOTE_1024 ( 73 ) #define RE_B NOTE_1024 ( 78 ) #define MIB NOTE_1024 ( 82 ) #define FAB NOTE_1024 ( 87 ) #define FA_B NOTE_1024 ( 93 ) #define SOLB NOTE_1024 ( 98 ) #define SOL_B NOTE_1024 ( 104 ) #define LAB NOTE_1024 ( 110 ) #define LA_B NOTE_1024 ( 116 ) #define SIB NOTE_1024 ( 123 ) //  #define DOS NOTE_256( 131 ) #define DO_S NOTE_256( 138 ) #define RES NOTE_256 ( 146 ) #define RE_S NOTE_256 ( 155 ) #define MIS NOTE_256 ( 164 ) #define FAS NOTE_256 ( 174 ) #define FA_S NOTE_256 ( 185 ) #define SOLS NOTE_256 ( 196 ) #define SOL_S NOTE_256 ( 207 ) #define LAS NOTE_256 ( 219 ) #define LA_S NOTE_256 ( 233 ) #define SIS NOTE_256 ( 246 ) //  #define DO1 NOTE_256( 261 ) #define DO_1 NOTE_256( 277 ) #define RE1 NOTE_256 ( 293 ) #define RE_1 NOTE_256 ( 310 ) #define MI1 NOTE_256 ( 329 ) #define FA1 NOTE_256 ( 348 ) #define FA_1 NOTE_256 ( 369 ) #define SOL1 NOTE_256 ( 391 ) #define SOL_1 NOTE_256 ( 414 ) #define LA1 NOTE_256 ( 439 ) #define LA_1 NOTE_256 ( 465 ) #define SI1 NOTE_256 ( 493 ) //  #define DO2 NOTE_128( 522 ) #define DO_2 NOTE_128( 553 ) #define RE2 NOTE_128 ( 586 ) #define RE_2 NOTE_128 ( 621 ) #define MI2 NOTE_128 ( 658 ) #define FA2 NOTE_128 ( 697 ) #define FA_2 NOTE_128 ( 738 ) #define SOL2 NOTE_128 ( 782 ) #define SOL_2 NOTE_128 ( 829 ) #define LA2 NOTE_128 ( 878 ) #define LA_2 NOTE_128 ( 930 ) #define SI2 NOTE_128 ( 985 ) //  #define DO3 NOTE_64( 1047 ) #define DO_3 NOTE_64( 1109 ) #define RE3 NOTE_64 ( 1175 ) #define RE_3 NOTE_64 ( 1245 ) #define MI3 NOTE_64 ( 1319 ) #define FA3 NOTE_64 ( 1397 ) #define FA_3 NOTE_64 ( 1480 ) #define SOL3 NOTE_64 ( 1568 ) #define SOL_3 NOTE_64 ( 1661 ) #define LA3 NOTE_64 ( 1760 ) #define LA_3 NOTE_64 ( 1865 ) #define SI3 NOTE_64 ( 1976 ) //  #define DO4 NOTE_32( 2093 ) #define DO_4 NOTE_32( 2217 ) #define RE4 NOTE_32 ( 2349 ) #define RE_4 NOTE_32 ( 2489 ) #define MI4 NOTE_32 ( 2637 ) #define FA4 NOTE_32 ( 2794 ) #define FA_4 NOTE_32 ( 2960 ) #define SOL4 NOTE_32 ( 3136 ) #define SOL_4 NOTE_32 ( 3322 ) #define LA4 NOTE_32 ( 3520 ) #define LA_4 NOTE_32 ( 3729 ) #define SI4 NOTE_32 ( 3951 )</span></span></span></span></code> </pre><br></div></div><br><br>  Dan untuk durasi not, kita hanya memiliki 5 bit tersisa, jadi mari kita hitung durasinya. <br><br><h4>  Durasi </h4><br>  Pertama, Anda perlu menerjemahkan nilai tempo ke unit sementara (misalnya, dalam milidetik) - Saya melakukannya seperti ini: <br>  <b>Durasi ukuran musik dalam ms = (60.000 ms * 4 kuartal) / nilai tempo.</b> <br><br>  Dengan demikian, jika kita berbicara tentang beat parts, maka nilai ini perlu dibagi, dan pada awalnya saya berpikir bahwa shift kiri yang biasa untuk divider akan cukup.  Yaitu  kodenya adalah ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> calc_note_delay(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> precalced_tempo, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> note) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (precalced_tempo / _BV((note &gt;&gt; <span class="hljs-number"><span class="hljs-number">11</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0b00111</span></span>)); }</code> </pre> <br><br>  Yaitu  Saya menggunakan 3 bit (dari 5 sisanya) dan mendapat bagian dari irama musik dari derajat 2 hingga 1/128.  Tetapi ketika saya memberi seorang teman meminta saya untuk menulis semacam nada dering untuk besi saya, ada pertanyaan mengapa tidak ada 1/3 atau 1/6 dan saya mulai berpikir ... <br><br>  Pada akhirnya, saya membuat sistem yang rumit untuk mendapatkan durasi seperti itu.  Satu bit dari sisa 2x - saya habiskan untuk tanda multiplikasi 3 untuk pembagi jam yang diperoleh setelah shift.  Dan bit terakhir adalah untuk menunjukkan apakah perlu untuk mengurangi 1. Ini sulit untuk dijelaskan, lebih mudah untuk melihat kode: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> calc_note_delay(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> precalced_tempo, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> note) { note &gt;&gt;= <span class="hljs-number"><span class="hljs-number">11</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> divider = _BV(note &amp; <span class="hljs-number"><span class="hljs-number">0b00111</span></span>); note &gt;&gt;= <span class="hljs-number"><span class="hljs-number">3</span></span>; divider *= ((note &amp; <span class="hljs-number"><span class="hljs-number">0b01</span></span>) ? <span class="hljs-number"><span class="hljs-number">3</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>); divider -= (note &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (precalced_tempo / divider); }</code> </pre> <br>  Lalu saya "mendefinisikan" semua catatan yang mungkin (kecuali yang kurang dari 1/128). <br><div class="spoiler">  <b class="spoiler_title">Inilah mereka</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_MINUS_1 0b10000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_MUL_3 0b01000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N2 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N3 (2 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N4 2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N5 (1 | DEL_MINUS_1 | DEL_MUL_3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N6 (1 | DEL_MUL_3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N7 (3 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N8 3 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N11 (2 | DEL_MUL_3 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N12 (2 | DEL_MUL_3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N15 (4 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N16 4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N23 (3 | DEL_MUL_3 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N24 (3 | DEL_MUL_3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N31 (5 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N32 5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N47 (4 | DEL_MUL_3 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N48 (4 | DEL_MUL_3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N63 (6 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N64 6 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N95 (5 | DEL_MUL_3 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N96 (5 | DEL_MUL_3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N127 (7 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N128 7</span></span></code> </pre><br></div></div><br><br><h4>  Menyatukan semuanya </h4><br>  Total, kami memiliki format berikut untuk elemen array nada dering kami. <br><br><ul><li>  1bit: delay divider - 1 </li><li>  1bit: tunda pembagi * 3 </li><li>  3bit: tunda shift pembagi </li><li>  3bit: pembagi jam cpu </li><li>  8bit: nilai OCR2A </li></ul><br>  Hanya 16 bit. <br><br>  Pembaca yang budiman, jika Anda mau, Anda bisa memimpikan formatnya sendiri, mungkin sesuatu yang lebih luas daripada milik saya akan lahir. <br><br>  Kami lupa menambahkan catatan kosong, mis.  diam.  Dan akhirnya, saya menjelaskan mengapa di awal, dalam fungsi timer2_buzzer_init (), kami secara khusus mengatur kaki PB3 ke input dan bukan output.  Mengubah register DDRB, kita akan menghidupkan dan mematikan pemutaran "keheningan" atau komposisi secara keseluruhan.  Karena  kita tidak dapat memiliki catatan dengan nilai 0 - itu akan menjadi catatan "kosong". <br><br>  Tentukan makro yang hilang dan fungsi untuk mengaktifkan pembuatan suara: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EMPTY_NOTE 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NOTE(delay, note) (uint16_t)((delay </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; 11) | note) ........ ........ ........ void play_music_note(uint16_t note) { if (note) { TCCR2B = (note &gt;&gt; 8) &amp; DIV_MASK; OCR2A = note &amp; 0xff; sbi(DDRB, BUZ_PIN); } else cbi(DDRB, BUZ_PIN); }</span></span></span></span></code> </pre><br>  Sekarang saya akan menunjukkan kepada Anda seperti apa nada dering yang ditulis menurut prinsip ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> king[] PROGMEM = { NOTE(DEL_1N4, MI3), NOTE(DEL_1N4, FA_3), NOTE(DEL_1N4, SOL3), NOTE(DEL_1N4, LA3), NOTE(DEL_1N4, SI3), NOTE(DEL_1N4, SOL3), NOTE(DEL_1N2, SI3), NOTE(DEL_1N4, LA_3), NOTE(DEL_1N4, FA_3), NOTE(DEL_1N4, LA_3), NOTE(DEL_1N4, EMPTY_NOTE), NOTE(DEL_1N4, LA3), NOTE(DEL_1N4, FA3), NOTE(DEL_1N2, LA3), NOTE(DEL_1N4, MI3), NOTE(DEL_1N4, FA_3), NOTE(DEL_1N4, SOL3), NOTE(DEL_1N4, LA3), NOTE(DEL_1N4, SI3), NOTE(DEL_1N4, SOL3), NOTE(DEL_1N4, SI3), NOTE(DEL_1N4, MI4), NOTE(DEL_1N4, RE4), NOTE(DEL_1N4, SI3), NOTE(DEL_1N4, SOL3), NOTE(DEL_1N4, SI3), NOTE(DEL_1N2, RE4), NOTE(DEL_1N2, EMPTY_NOTE), };</code> </pre><br><br><h3>  Memainkan nada dering </h3><br>  Kami masih memiliki satu tugas - memainkan melodi.  Untuk melakukan ini, kita perlu "menjalankan" melalui array nada dering, menahan jeda yang tepat dan mengganti frekuensi catatan.  Jelas, kita perlu timer lain, yang, omong-omong, dapat digunakan untuk tugas-tugas umum lainnya, seperti yang biasanya saya lakukan.  Selain itu, Anda dapat beralih di antara elemen array baik dalam gangguan timer ini, atau dalam loop utama, dan menggunakan timer untuk menghitung waktu.  Dalam contoh ini, saya menggunakan opsi ke-2. <br><br>  Seperti yang Anda ketahui, isi dari program apa pun untuk MK termasuk loop tak terbatas: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { <span class="hljs-comment"><span class="hljs-comment">//   } return 0; }</span></span></code> </pre><br>  Di dalamnya kita akan "berlari" di sepanjang array kita.  Tetapi kita membutuhkan fungsi yang mirip dengan GetTickCount dari WinApi, yang mengembalikan jumlah milidetik pada sistem operasi Windows.  Tapi tentu saja, di dunia MK tidak ada fungsi seperti itu "di luar kotak", jadi kita harus menulis sendiri. <br><br><h4>  Timer 1 </h4><br>  Untuk menghitung interval waktu (saya sengaja tidak menulis milidetik, nanti Anda akan mengerti alasannya) Saya menggunakan timer 1 bersamaan dengan mode CTC yang sudah dikenal.  Timer 1 adalah timer 16-bit, yang berarti bahwa nilai modul perbandingan untuk itu sudah ditunjukkan oleh 2 register 8-bit OCR1AH ‚Äã‚Äãdan OCR1AL - untuk masing-masing byte tinggi dan rendah.  Saya tidak ingin menjelaskan secara rinci pekerjaan dengan timer 1, karena ini tidak berlaku untuk topik utama memo ini.  Karena itu, saya akan memberi tahu Anda hanya dalam 2 kata. <br><br>  Kami sebenarnya membutuhkan 3 fungsi: <br><ul><li>  Inisialisasi pengatur waktu </li><li>  Timer interrupt handler </li><li>  fungsi yang mengembalikan jumlah interval waktu. </li></ul><br><div class="spoiler">  <b class="spoiler_title">File kode C</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;avr/io.h&gt; #include &lt;avr/interrupt.h&gt; #include &lt;util/atomic.h&gt; #include "timer1_ticks.h" volatile unsigned long timer1_ticks; //  ISR (TIMER1_COMPA_vect) { timer1_ticks++; } void timer1_ticks_init() { //   // CTC ,     8 TCCR1B |= (1 &lt;&lt; WGM12) | (1 &lt;&lt; CS11); //     OCR1AH = (uint8_t)(CTC_MATCH_OVERFLOW &gt;&gt; 8); OCR1AL = (uint8_t) CTC_MATCH_OVERFLOW; //    TIMSK1 |= (1 &lt;&lt; OCIE1A); } unsigned long ticks() { unsigned long ticks_return; //  ,   ticks_return   //     ATOMIC_BLOCK(ATOMIC_FORCEON) { ticks_return = timer1_ticks; } return ticks_return; }</span></span></span></span></code> </pre><br></div></div><br><br>  Sebelum saya menunjukkan file header dengan CTC_MATCH_OVERFLOW konstan tertentu, kita perlu kembali ke waktu ke bagian <b>"Durasi"</b> dan menentukan makro yang paling penting untuk melodi, yang menghitung tempo melodi.  Saya menunggu lama untuk menentukannya, karena langsung terhubung ke pemain, dan karenanya dengan timer 1. <br>  Dalam perkiraan pertama, itu tampak seperti ini (lihat perhitungan di bagian "Durasi"): <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TEMPO( x ) (60000 * 4 / x)</span></span></code> </pre><br>  Nilai yang kita dapatkan pada output selanjutnya kita harus mengganti argumen pertama menjadi fungsi <b>calc_note_delay</b> .  Sekarang perhatikan fungsi calc_note_delay, yaitu baris: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (precalced_tempo / divider);</code> </pre><br>  Kami melihat bahwa nilai yang diperoleh dengan menghitung makro TEMPO dibagi dengan pembagi tertentu.  Ingat bahwa pembagi maksimum yang telah kami tetapkan adalah <b>DEL_1N128</b> , mis.  pembagi akan 128. <br><br>  Sekarang mari kita ambil nilai tempo umum sama dengan 240 dan lakukan beberapa perhitungan sederhana: <br>  <b>60000 * 4/240 = 1000</b> <br>  Oh horor!  Kami hanya mendapat 1000, karena nilai ini masih akan dibagi dengan 128, kami berisiko tergelincir ke 0, dengan harga tinggi.  <b>Ini adalah masalah durasi kedua.</b> <br><br>  Bagaimana cara mengatasinya?  Jelas, untuk memperluas rentang nilai tempo, kita perlu menambah jumlah yang diperoleh dengan menghitung makro TEMPO.  Ini dapat dilakukan hanya dengan satu cara - untuk menjauh dari milidetik dan menghitung waktu dalam interval waktu tertentu.  Sekarang Anda mengerti mengapa selama ini saya menghindari menyebutkan "milidetik" dalam cerita.  Mari kita definisikan makro lain: <br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MS_DIVIDER 4</span></span></code> </pre> <br>  Jadikan itu sebagai pembagi milidetik kita - bagilah milidetik, misalnya 4 kali (250 Œºs). <br>  Maka Anda perlu mengubah makro TEMPO: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TEMPO( x ) (60000 * MS_DIVIDER * 4 / x)</span></span></code> </pre> <br><br>  Sekarang, dengan hati nurani yang bersih, saya akan memberikan file header untuk bekerja dengan timer 1: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> TIMER1_TICKS_H_INCLUDED #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TIMER1_TICKS_H_INCLUDED #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MS_DIVIDER 4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTC_MATCH_OVERFLOW ((F_CPU / 1000) / (8 * MS_DIVIDER)) void timer1_ticks_init(); unsigned long ticks(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// TIMER1_TICKS_H_INCLUDED</span></span></span></span></code> </pre> <br>  Sekarang kita bisa, mengubah MS_DIVIDER, menyesuaikan rentang untuk tugas kita - saya punya 4 dalam kode saya - ini sudah cukup untuk tugas saya.  <b>Perhatian: jika Anda masih memiliki tugas yang "terikat" ke timer 1, jangan lupa untuk melipatgandakan / membagi nilai kontrol waktu untuknya dengan MS_DIVIDER.</b> <br><br><h4>  Meja putar </h4><br>  Sekarang mari kita tulis pemain kami.  Saya pikir semuanya akan jelas dari kode dan komentar. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ timer1_ticks_init(); <span class="hljs-comment"><span class="hljs-comment">//   sei(); timer2_buzzer_init(); //    MS_DIVIDER long time_since = ticks(); //       MS_DIVIDER uint16_t note_delay = 0; //     uint16_t note_pos = 0; //  uint16_t length = sizeof(king) / sizeof(king[0]); //     uint16_t tempo = TEMPO(240); for(;;) { unsigned long time_current = ticks(); if (time_current - time_since &gt; note_delay) { //   uint16_t note = pgm_read_word(&amp;king[note_pos]); //   play_music_note(note); //    note_delay = calc_note_delay(tempo, note); //  if (++note_pos &gt;= length) note_pos = 0; time_since = time_current; } } return 0; }</span></span></code> </pre><br><br><h3>  Kesimpulan </h3><br>  Saya berharap memo ini bermanfaat bagi pembaca yang terhormat dan saya sendiri, agar tidak melupakan semua nuansa lagu, kalau-kalau saya mengambil mikrokontroler AVR lagi. <br><br>  Yah, secara tradisional video dan kode sumber (saya mengembangkannya di lingkungan Blok Kode, jadi jangan takut dengan file yang tidak jelas): <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/j60UCr2q0Ak" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode sumber</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id402329/">https://habr.com/ru/post/id402329/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id402319/index.html">Universitas Jagiellonian mengembangkan aplikasi pelatih menggunakan kemampuan IBM Watson</a></li>
<li><a href="../id402321/index.html">Ulasan Livall: helm pintar dengan pengontrol, mikrofon, dan aplikasi asli</a></li>
<li><a href="../id402323/index.html">"Juga berhasil": Seni mendengarkan musik</a></li>
<li><a href="../id402325/index.html">"Dunia kurus." Bab 7</a></li>
<li><a href="../id402327/index.html">WayRay mengumumkan kemitraan strategis dengan Banma Technologies dengan dukungan investasi dari Alibaba Group</a></li>
<li><a href="../id402345/index.html">Data keanekaragaman spesies</a></li>
<li><a href="../id402347/index.html">Pilihan headphone olahraga hingga 2500 rubel</a></li>
<li><a href="../id402351/index.html">Internet Seluruh Dunia: Jepang dan Singapura</a></li>
<li><a href="../id402355/index.html">Catur kuantum</a></li>
<li><a href="../id402357/index.html">Bisakah saya mengganti Adobe Premiere dan Sony Vegas dengan editor video gratis?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>