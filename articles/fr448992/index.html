<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚Äçüé® üëåüèø ‚ñ∂Ô∏è Hachage polyvalent et parfait üññüèΩ üßìüèª üí™üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous commen√ßons la semaine avec du mat√©riel utile d√©di√© au lancement du cours "Algorithmes pour les d√©veloppeurs" . Bonne lecture. 



 1. Pr√©sentatio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hachage polyvalent et parfait</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/448992/">  Nous commen√ßons la semaine avec du mat√©riel utile d√©di√© au lancement du cours <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Algorithmes pour les d√©veloppeurs"</a> .  Bonne lecture. <br><br><img src="https://habrastorage.org/webt/na/5_/ja/na5_jaknhrabunnqxjqmc1yjtvi.png"><br><br>  <b>1. Pr√©sentation</b> <br><br>  Le hachage est un excellent outil pratique, avec une th√©orie int√©ressante et subtile.  En plus d'utiliser les donn√©es comme structure de vocabulaire, le hachage se trouve √©galement dans de nombreux domaines diff√©rents, y compris la cryptographie et la th√©orie de la complexit√©.  Dans cette conf√©rence, nous d√©crivons deux concepts importants: le hachage universel (√©galement connu sous le nom de famille universelle de fonctions de hachage) et le hachage id√©al. <a name="habracut"></a><br><br>  Le mat√©riel mis en √©vidence dans cette conf√©rence comprend: <br><br><ul><li>  Le cadre formel et l'id√©e g√©n√©rale du hachage. </li><li>  Hachage universel. </li><li>  Hachage parfait. </li></ul><br>  <b>2. Introduction</b> <br><br>  Nous allons consid√©rer le probl√®me principal avec le dictionnaire que nous avons discut√© auparavant, et consid√©rer deux versions: statique et dynamique: <br><br><ul><li>  <i>Statique</i> : √©tant donn√© un grand nombre d'√©l√©ments S, nous voulons le stocker de mani√®re √† pouvoir effectuer rapidement une recherche. </li><li>  Par exemple, un dictionnaire fixe. </li><li>  <i>Dynamique</i> : nous avons ici une s√©quence de demandes d'insertion, de recherche et √©ventuellement de suppression.  Nous voulons faire tout cela efficacement. </li></ul><br>  Pour le premier probl√®me, nous pourrions utiliser un tableau tri√© et une recherche binaire.  Pour le second, nous pourrions utiliser un arbre de recherche √©quilibr√©.  Cependant, le hachage fournit une approche alternative, qui est souvent le moyen le plus rapide et le plus pratique pour r√©soudre ces probl√®mes.  Par exemple, supposons que vous √©crivez un programme de recherche AI ‚Äã‚Äãet que vous souhaitiez stocker des situations que vous avez d√©j√† r√©solues (positions sur le tableau ou √©l√©ments de l'espace d'√©tat) afin de ne pas r√©p√©ter les m√™mes calculs lorsque vous les rencontrez √† nouveau.  Le hachage permet de stocker facilement ces informations.  Il existe √©galement de nombreuses applications en cryptographie, r√©seaux, th√©orie de la complexit√©. <br><br>  <b>3. Bases du hachage</b> <br><br>  Le param√®tre formel de hachage est le suivant. <br><br><ul><li>  Les cl√©s appartiennent √† un grand ensemble de U. (Par exemple, imaginez que U est une collection de toutes les cha√Ænes avec une longueur maximale de 80 caract√®res ascii.) </li><li>  Nous avons vraiment besoin de quelques cl√©s S en U (les cl√©s peuvent √™tre statiques ou dynamiques).  Soit N = | S |.  Imaginez que N est beaucoup plus petit que la taille de U. Par exemple, S est l'ensemble des noms d'√©l√®ves dans une classe qui est beaucoup plus petit que 128 ^ 80. </li><li>  Nous allons effectuer des insertions et des recherches en utilisant un tableau A d'une certaine taille M et une <b>fonction de hachage</b> h: U ‚Üí {0, ..., M - 1}.  √âtant donn√© l'√©l√©ment x, l'id√©e de hachage est que nous voulons le stocker dans A [h (x)].  Notez que si U √©tait petit (par exemple, des cha√Ænes de 2 caract√®res), vous pourriez simplement enregistrer x dans A [x], comme dans le tri par blocs.  Le probl√®me est que U est grand, nous avons donc besoin d'une fonction de hachage. </li><li>  Nous avons besoin d'une m√©thode pour r√©soudre les collisions.  Une collision se produit lorsque h (x) = h (y) pour deux cl√©s diff√©rentes x et y.  Dans cette conf√©rence, nous traiterons les collisions en d√©finissant chaque √©l√©ment de A comme une liste cha√Æn√©e.  Il existe un certain nombre d'autres m√©thodes, mais pour les probl√®mes sur lesquels nous nous concentrerons ici, c'est la plus appropri√©e.  Cette m√©thode est appel√©e m√©thode de cha√Ænage.  Pour ins√©rer un √©l√©ment, nous le mettons simplement en haut de la liste.  Si h est une bonne fonction de hachage, alors nous esp√©rons que les listes seront petites. </li></ul><br>  L'un des avantages du hachage est que toutes les op√©rations de dictionnaire sont incroyablement faciles √† impl√©menter.  Pour rechercher la cl√© x, calculez simplement l'indice i = h (x) puis parcourez la liste dans A [i] jusqu'√† ce que vous la trouviez (ou quittez la liste).  Pour ins√©rer, placez simplement un nouvel √©l√©ment en haut de sa liste.  Pour supprimer, il vous suffit d'effectuer l'op√©ration de suppression dans la liste li√©e.  Passons maintenant √† la question: de quoi avons-nous besoin pour obtenir de bonnes performances? <br><br>  Propri√©t√©s souhaitables.  Propri√©t√©s cl√©s souhaitables pour un bon sch√©ma de hachage: <br><br><ol><li>  Les cl√©s sont bien dispers√©es afin que nous n'ayons pas trop de collisions, car les collisions affectent le temps de recherche et de suppression. </li><li>  M = O (N): en particulier, nous aimerions que notre circuit atteigne la propri√©t√© (1) sans que la taille du tableau M soit beaucoup plus grande que le nombre d'√©l√©ments N. </li><li>  La fonction h doit √™tre calcul√©e rapidement.  Dans notre analyse d'aujourd'hui, nous consid√©rerons le temps pour calculer h (x) comme une constante.  Cependant, il convient de rappeler que cela ne devrait pas √™tre trop compliqu√© car cela affecte le temps d'ex√©cution global. </li></ol><br>  Compte tenu de cela, le temps de recherche pour l'√©l√©ment x est O (la taille de la liste est A [h (x)]).  Il en va de m√™me pour les suppressions.  Les insertions prennent O (1), quelle que soit la longueur des listes.  Nous voulons donc analyser la taille de ces listes. <br><br>  Intuition de base: une fa√ßon de bien r√©partir les √©l√©ments est de les r√©partir de mani√®re al√©atoire.  Malheureusement, nous ne pouvons pas simplement utiliser le g√©n√©rateur de nombres al√©atoires pour d√©cider o√π diriger l'√©l√©ment suivant, car nous ne pourrons plus jamais le retrouver.  Donc, nous voulons que h soit quelque chose de ¬´pseudo-al√©atoire¬ª dans un sens formel. <br><br>  Nous allons maintenant pr√©senter de mauvaises nouvelles, puis de bonnes nouvelles. <br><br>  √ânonc√© 1 (mauvaise nouvelle) Pour toute fonction de hachage h si | U |  ‚â• (N ‚àí1) M +1, il y a un ensemble S d'√©l√©ments N qui ont tous hach√© au m√™me endroit. <br><br>  Preuve: par le principe de Dirichlet.  En particulier, pour consid√©rer les contrepoints, si chaque emplacement n'avait pas plus de N - 1 √©l√©ments de U qui le hachaient, alors U pourrait avoir une taille ne d√©passant pas M (N - 1). <br><br>  C'est en partie pourquoi le hachage semble si myst√©rieux - comment peut-on affirmer que le hachage est bon si, pour une fonction de hachage, vous pouvez penser √† des moyens de l'emp√™cher?  Une r√©ponse est qu'il existe de nombreuses fonctions de hachage simples qui fonctionnent bien dans la pratique pour les ensembles typiques S. Mais que faire si nous voulons une bonne garantie du pire des cas? <br><br>  Voici l'id√©e cl√©: utilisons la randomisation dans notre construction h, similaire au tri rapide randomis√©.  (Inutile de dire que h sera une fonction d√©terministe).  Nous montrerons que pour toute s√©quence d'op√©rations d'insertion et de recherche (nous n'avons pas besoin de supposer que l'ensemble des √©l√©ments ins√©r√©s S est al√©atoire), si nous choisissons h de cette mani√®re probabiliste, les performances de h dans cette s√©quence seront bonnes en pr√©vision.  Ainsi, c'est la m√™me garantie que dans le tri rapide ou les pi√®ges randomis√©s.  En particulier, c'est l'id√©e du hachage universel. <br><br>  Une fois que nous aurons d√©velopp√© cette id√©e, nous l'utiliserons pour une application particuli√®rement agr√©able appel√©e ¬´hachage parfait¬ª. <br><br>  <b>4. Hachage universel</b> <br><br>  D√©finition 1. Un algorithme al√©atoire H pour construire des fonctions de hachage h: U ‚Üí {1, ..., M} <br>  universel si pour tout x! = y dans U nous avons <br><br><img src="https://habrastorage.org/webt/bj/h3/hd/bjh3hdghlrhmfl-4mf6i3xybf14.png"><br><br>  On peut aussi dire que l'ensemble H des fonctions de hachage est une famille universelle de fonctions de hachage si la proc√©dure ¬´al√©atoirement s√©lectionner h ‚àà H¬ª est universelle.  (Ici, nous identifions l'ensemble des fonctions avec une distribution uniforme sur l'ensemble.) <br><br>  Th√©or√®me 2. Si H est universel, alors pour tout ensemble S ‚äÜ U de taille N, pour tout x ‚àà U (par exemple, que nous pourrions rechercher), si nous construisons h au hasard conform√©ment √† H, le nombre attendu de collisions entre x et d'autres √©l√©ments en S pas plus que N / M. <br><br>  Preuve: chaque y ‚àà S (y! = X) a au plus 1 / M de chance de collision avec x par la d√©finition de ¬´universel¬ª.  Alors <br><br><ul><li>  Soit Cxy = 1 si x et y entrent en collision, et 0 sinon. </li><li>  Soit Cx le nombre total de collisions pour x.  Donc, Cx = Py‚ààS, y! = X Cxy. </li><li>  Nous savons que E [Cxy] = Pr (x et y entrent en collision) ‚â§ 1 / M. </li><li>  Ainsi, en lin√©arit√© de l'esp√©rance, E [Cx] = Py E [Cxy] &lt;N / M. </li></ul><br>  Nous obtenons maintenant le corollaire suivant. <br><br>  Corollaire 3. Si H est universel, alors pour toute s√©quence d'op√©rations d'insertion, de recherche et de suppression L, dans laquelle il ne peut y avoir plus de M √©l√©ments dans un syst√®me √† la fois, le co√ªt total attendu des op√©rations L pour un h al√©atoire ‚àà H n'est que de O (L) (affichage de l'heure pour calculer h comme constantes). <br><br>  Preuve: pour toute op√©ration donn√©e de la s√©quence, son co√ªt attendu est constant par le th√©or√®me 2, donc le co√ªt total attendu des op√©rations L est O (L) en lin√©arit√© des attentes. <br><br>  Question: peut-on r√©ellement construire un H universel?  Sinon, tout cela est assez inutile.  Heureusement, la r√©ponse est oui. <br><br>  <i><b>4.1.</b></i>  <i><b>Cr√©ation d'une famille de hachage universelle: m√©thode matricielle</b></i> <br><br>  Supposons que les cl√©s aient une longueur de u bits.  Disons que la taille de la table M est √©gale au degr√© 2; par cons√©quent, l'index est long de b bits avec M = 2b. <br><br>  Ce que nous allons faire est de choisir h comme matrice al√©atoire 0/1 b-by-u et de d√©finir h (x) = hx, o√π nous ajoutons le mod 2. Ces matrices sont courtes et √©paisses.  Par exemple: <br><br><img src="https://habrastorage.org/webt/ly/q4/4k/lyq44kg-g4d8iloztroepglar9k.png"><br><br>  Proposition 4. Pour x! = Y Prh [h (x) = h (y)] = 1 / M = 1 / 2b. <br><br>  Preuve: tout d'abord, que signifie multiplier h par x?  Nous pouvons penser √† cela comme l'ajout de certaines colonnes h (en faisant l'addition vectorielle mod 2), o√π 1 bit en x indique celles √† ajouter.  (par exemple, nous avons ajout√© les 1√®re et 3√®me colonnes de h ci-dessus) <br><br>  Prenez maintenant une paire de cl√©s arbitraire x, y telle que x! = Y.  Ils devraient √™tre diff√©rents quelque part, alors disons qu'ils diff√®rent dans la i-√®me coordonn√©e, et pour plus de concr√©tisation, nous disons xi = 0 et yi = 1. Imaginez que nous avons d'abord s√©lectionn√© tous les h sauf la i-√®me colonne.  Pour les autres √©chantillons de la i√®me colonne, h (x) est fixe.  Cependant, chacun des 2b r√©glages diff√©rents de la i√®me colonne donne une valeur diff√©rente de h (y) (en particulier, chaque fois que nous tournons un peu dans cette colonne, nous transformons le bit correspondant en h (y)).  Il y a donc exactement 1 / 2b de chance que h (x) = h (y). <br><br>  Il existe d'autres m√©thodes pour construire des familles de hachage universelles, qui sont √©galement bas√©es sur la multiplication des nombres premiers (voir la section 6.1). <br><br>  La question suivante que nous consid√©rerons: si nous corrigeons l'ensemble S, pouvons-nous trouver une fonction de hachage h telle que toutes les recherches auront un temps constant?  La r√©ponse est oui, ce qui m√®ne au sujet du hachage parfait. <br><br>  <b>5. Hachage parfait</b> <br><br>  Nous disons qu'une fonction de hachage est id√©ale pour S si toutes les recherches ont lieu dans O (1).  Voici deux fa√ßons de cr√©er des fonctions de hachage parfaites pour un ensemble donn√© S. <br><br>  <i><b>5.1 M√©thode 1: une solution dans l'espace O (N2)</b></i> <br><br>  Disons que nous voulons avoir une table dont la taille est quadratique en taille N de notre dictionnaire S. Alors, voici une m√©thode simple pour construire une fonction de hachage id√©ale.  Soit H universel et M = N2.  Ensuite, choisissez simplement un h al√©atoire de H et essayez-le!  La d√©claration est qu'il y a au moins 50% de chances qu'elle n'ait pas de collisions. <br><br>  Proposition 5. Si H est universel et M = N2, alors Prh‚àºH (pas de collisions dans S) ‚â• 1/2. <br><br>  Preuve: <br><br>  ‚Ä¢ Combien de paires (x, y) y a-t-il dans S?  La r√©ponse est: <img src="https://habrastorage.org/webt/1n/oh/w7/1nohw79oejhbrsciul36nklg4sq.png"><br>  ‚Ä¢ Pour chaque paire, la probabilit√© de leur collision est ‚â§ 1 / M par d√©finition d'universalit√©. <br>  ‚Ä¢ Donc Pr (il y a collision) ‚â§ <img src="https://habrastorage.org/webt/1n/oh/w7/1nohw79oejhbrsciul36nklg4sq.png">  / M &lt;1/2. <br><br>  C'est comme l'autre c√¥t√© du ¬´paradoxe d'anniversaire¬ª.  Si le nombre de jours est beaucoup plus grand que le nombre de personnes au carr√©, il y a une chance raisonnable qu'aucun couple n'ait le m√™me anniversaire. <br><br>  Donc, nous choisissons simplement un h al√©atoire de H, et si des collisions surviennent, nous choisissons simplement un nouveau h.  En moyenne, nous n'aurons besoin de le faire que deux fois.  Maintenant, que se passe-t-il si nous voulons utiliser uniquement l'espace O (N)? <br><br>  5.2 M√©thode 2: une solution dans l'espace O (N) <br><br>  La question de savoir s'il est possible d'obtenir un hachage parfait dans l'espace O (N) est ouverte depuis un certain temps: "Faut-il trier les tables?"  Autrement dit, pour un ensemble fixe, vous ne pouvez obtenir un temps de recherche constant qu'avec un espace lin√©aire?  Il y a eu une s√©rie de tentatives de plus en plus complexes, jusqu'√† ce qu'il soit finalement r√©solu en utilisant la bonne id√©e des fonctions de hachage universelles dans un sch√©ma √† deux niveaux. <br><br>  La m√©thode est la suivante.  Tout d'abord, nous allons hacher dans une table de taille N en utilisant un hachage universel.  Cela entra√Ænera des collisions (sauf si nous avons de la chance).  Cependant, nous remanions chaque panier en utilisant la m√©thode 1, en ajustant la taille du panier pour obtenir z√©ro collision.  Ainsi, le sch√©ma consiste dans le fait que nous avons une fonction de hachage du premier niveau h et une table A du premier niveau, puis N fonctions de hachage du deuxi√®me niveau h1, ..., hN et N de la deuxi√®me table de niveau A1, ..., A.N ... Pour trouver l'√©l√©ment x, nous calculons d'abord i = h (x), puis trouvons l'√©l√©ment dans Ai [hi (x)].  (Si vous faisiez cela en pratique, vous pourriez d√©finir le drapeau de sorte que vous ne fassiez la deuxi√®me √©tape que s'il y avait vraiment des conflits avec l'index i, sinon vous mettriez simplement x lui-m√™me dans A [i], mais disons ne nous en soucions pas ici.) <br><br>  Disons qu'une fonction de hachage h hache n √©l√©ments de S √† l'emplacement i.  Nous avons d√©j√† prouv√© (en analysant la m√©thode 1) que nous pouvons trouver h1, ..., hN, de sorte que l'espace total utilis√© dans les tables secondaires est Pi (ni) 2. Il reste √† montrer que nous pouvons trouver une fonction de premier niveau h telle que Pi (ni) 2 = O (N).  En fait, nous allons montrer ce qui suit: <br><br>  Th√©or√®me 6. Si nous choisissons le point de d√©part h dans l'ensemble universel H, alors <br><br><pre><code class="plaintext hljs">Pr[X i (ni)2 &gt; 4N] &lt; 1/2.</code> </pre> <br>  Preuve.  Prouvons cela en montrant que E [Pi (ni) 2] &lt;2N.  Cela implique ce que nous voulons de l'in√©galit√© de Markov.  (S'il y avait m√™me une probabilit√© de 1/2 que la somme puisse √™tre sup√©rieure √† 4N, alors ce seul fait signifierait que l'attente devrait √™tre sup√©rieure √† 2N. Ainsi, si l'attente est inf√©rieure √† 2N, la probabilit√© d'√©chec devrait √™tre inf√©rieure 1/2.) <br><br>  Maintenant, l'astuce est qu'une fa√ßon de calculer ce montant est de compter le nombre de paires ordonn√©es qui ont une collision, y compris les collisions avec soi-m√™me.  Par exemple, si le panier a {d, e, f}, alors d aura un conflit avec chacun de {d, e, f}, e aura un conflit avec chacun de {d, e, f}, et f aura un conflit avec chacun de {d, e, f}, nous obtenons donc 9. Donc, nous avons: <br><br><pre> <code class="plaintext hljs">E[X i (ni)2] = E[X x X y Cxy] (Cxy = 1 if x and y collide, else Cxy = 0) = N +X x X y6=x E[Cxy] ‚â§ N + N(N ‚àí 1)/M (where the 1/M comes from the definition of universal) &lt; 2N. (since M = N)</code> </pre><br>  Donc, nous essayons simplement un h al√©atoire de H jusqu'√† ce que nous en trouvions un tel que Pi n2 i &lt;4N, puis en fixant cette fonction h, nous trouvons N fonctions de hachage secondaires h1, ..., hN comme dans la m√©thode 1. <br><br>  <b>6. Discussion suppl√©mentaire</b> <br><br>  <i><b>6.1 Une autre m√©thode de hachage universelle</b></i> <br><br>  Voici une autre m√©thode pour construire des fonctions de hachage universelles, qui est l√©g√®rement plus efficace que la m√©thode matricielle donn√©e pr√©c√©demment. <br><br>  Dans la m√©thode matricielle, nous avons consid√©r√© la cl√© comme un vecteur de bits.  Dans cette m√©thode, nous consid√©rerons plut√¥t la cl√© x comme un vecteur d'entiers [x1, x2, ..., xk] avec la seule exigence que chaque xi soit dans la plage {0, 1, ..., M-1}.  Par exemple, si nous hachons des cha√Ænes de longueur k, alors xi peut √™tre le i√®me caract√®re (si la taille de notre table est au moins 256) ou la i√®me paire de caract√®res (si la taille de notre table est au moins 65536).  De plus, nous exigerons que la taille de notre table M soit un nombre premier.  Pour s√©lectionner la fonction de hachage h, nous s√©lectionnons k nombres al√©atoires r1, r2, ..., pk parmi {0, 1, ..., M - 1} et d√©terminons: <br><br><pre> <code class="plaintext hljs">h(x) = r1x1 + r2x2 + . . . + rkxk mod M.</code> </pre> <br>  La preuve que cette m√©thode est universelle est construite de la m√™me mani√®re que la preuve de la m√©thode matricielle.  Soit x et y deux cl√©s diff√©rentes.  Nous voulons montrer que Prh (h (x) = h (y)) ‚â§ 1 / M. Puisque x! = Y, il doit y avoir un cas o√π il existe un indice i tel que xi! = Yi.  Imaginez maintenant que vous avez d'abord s√©lectionn√© tous les nombres al√©atoires rj pour j! = I.  Soit h ‚Ä≤ (x) = Pj6 = i rjxj.  Donc, en choisissant ri, nous obtenons h (x) = h ‚Ä≤ (x) + rixi.  Cela signifie que nous avons un conflit entre x et y exactement quand <br><br><pre> <code class="plaintext hljs">h‚Ä≤(x) + rixi = h‚Ä≤(y) + riyi mod M, or equivalently when ri(xi ‚àí yi) = h‚Ä≤(y) ‚àí h‚Ä≤(x) mod M.</code> </pre> <br>  Puisque M est premier, la division par une valeur non nulle de mod M est valide (chaque entier de 1 √† M -1 a un modulo inverse M multiplicatif), ce qui signifie qu'il existe exactement une valeur ri modulo M pour laquelle l'√©quation ci-dessus est vraie vrai, √† savoir ri = (h ‚Ä≤ (y) - h ‚Ä≤ (x)) / (xi - yi) mod M. Ainsi, la probabilit√© de cet incident est exactement de 1 / M. <br><br>  <b><i>6.2 Autres utilisations du hachage</i></b> <br><br>  Supposons que nous ayons une longue s√©quence d'√©l√©ments et que nous voulons voir le nombre d'√©l√©ments diff√©rents dans la liste.  Existe-t-il un bon moyen de proc√©der? <br><br>  Une fa√ßon consiste √† cr√©er une table de hachage, puis √† effectuer un passage dans la s√©quence en effectuant une recherche pour chaque √©l√©ment, puis en l'ins√©rant s'il ne figure pas d√©j√† dans la table.  Le nombre d'√©l√©ments individuels est simplement le nombre d'inserts. <br><br>  Et maintenant, que se passe-t-il si la liste est vraiment √©norme et que nous n'avons pas d'endroit o√π la stocker, mais une r√©ponse approximative nous convient.  Par exemple, imaginez que nous sommes un routeur et observons le nombre de paquets qui passent, et nous voulons (approximativement) voir combien d'adresses IP source diff√©rentes existent. <br><br>  Voici une bonne id√©e: disons que nous avons une fonction de hachage h qui se comporte comme une fonction al√©atoire, et imaginons que h (x) est un nombre r√©el de 0 √† 1. Une chose que nous pouvons faire est de simplement garder une trace du minimum la valeur de hachage a √©t√© produite jusqu'√† pr√©sent (nous n'avons donc pas de table du tout).  Par exemple, si les cl√©s sont 3,10,3,3,12,10,12 et h (3) = 0,4, h (10) = 0,2, h (12) = 0,7, alors nous obtenons 0, 2. <br><br>  Le fait est que si nous s√©lectionnons N nombres al√©atoires dans [0, 1], la valeur minimale attendue sera 1 / (N + 1).  De plus, il y a de fortes chances qu'il soit assez proche (nous pouvons am√©liorer notre estimation en ex√©cutant plusieurs fonctions de hachage et en prenant la m√©diane des plus bas). <br><br>  Question: pourquoi utiliser une fonction de hachage, et pas seulement choisir un nombre al√©atoire √† chaque fois?  C'est parce que nous nous soucions du nombre d'√©l√©ments diff√©rents, et pas seulement du nombre total d'√©l√©ments (ce probl√®me est beaucoup plus simple: il suffit d'utiliser un compteur ...). <br><br>  Amis, cet article vous a-t-il √©t√© utile?  √âcrivez dans les commentaires et rejoignez la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">journ√©e portes ouvertes</a> , qui se tiendra le 25 avril. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr448992/">https://habr.com/ru/post/fr448992/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr448976/index.html">Les √©v√©nements du printemps de Gamedev au HSE</a></li>
<li><a href="../fr448980/index.html">Notre premier d√©jeuner ensemble: pourquoi et comment nous passons notre journ√©e de test</a></li>
<li><a href="../fr448982/index.html">CMS sans t√™te. Pourquoi j'√©cris le mien</a></li>
<li><a href="../fr448986/index.html">R√©tro-ing√©nierie 3D avec num√©risation 3D</a></li>
<li><a href="../fr448988/index.html">Les SSD de Kingston sont devenus plus spacieux, maintenant presque le m√™me co√ªt - nous rencontrons la s√©rie A400-R</a></li>
<li><a href="../fr448994/index.html">Est-il si difficile de d√©marrer le chemin d'un recruteur informatique?</a></li>
<li><a href="../fr448996/index.html">Cr√©ation d'une politique de mot de passe sous Linux</a></li>
<li><a href="../fr448998/index.html">Si la connexion n'est que de l'√©tain, vous devez l'enterrer</a></li>
<li><a href="../fr449000/index.html">Est-ce que Deno est le nouveau Node.js?</a></li>
<li><a href="../fr449002/index.html">V√©rification formelle sur l'exemple du probl√®me du loup, de la ch√®vre et du chou</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>