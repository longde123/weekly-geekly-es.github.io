<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👢 ⚫️ 🏛️ Gestion des dépendances Python: une comparaison des approches ☪️ 🏴󠁧󠁢󠁷󠁬󠁳󠁿 🎧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="J'écris en python depuis cinq ans, dont les trois dernières années ont développé mon propre projet. La plupart de cette façon, mon équipe m'aide. Et a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gestion des dépendances Python: une comparaison des approches</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461511/"><img src="http://ftcdn.pw/cd64d5e9-af9a-46cc-868b-c8873c98adb6.png" alt="image"><br><br>  J'écris en python depuis cinq ans, dont les trois dernières années ont développé mon propre projet.  La plupart de cette façon, mon équipe m'aide.  Et avec chaque version, avec chaque nouvelle fonctionnalité, nous essayons de plus en plus de faire en sorte que le projet ne se transforme pas en désordre avec du code non pris en charge;  nous luttons avec les importations cycliques, les dépendances mutuelles, allouons des modules réutilisables, reconstruisons la structure. <br><br>  Malheureusement, dans la communauté Python, il n'y a pas de concept universel de «bonne architecture», il n'y a que le concept de «pythonicité», nous devons donc trouver l'architecture nous-mêmes.  Under the cut - Longrid avec des réflexions sur l'architecture, et tout d'abord - sur la gestion des dépendances est applicable à Python. <br><a name="habracut"></a><br><h1>  django.setup () </h1><br>  Je vais commencer par une question aux junglers.  Écrivez-vous souvent ces deux lignes? <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> django django.setup()</code> </pre> <br>  Vous devez démarrer le fichier à partir de cela si vous souhaitez travailler avec des objets django sans démarrer le serveur web django lui-même.  Cela s'applique aux modèles et aux outils pour travailler avec le temps ( <code><b>django.utils.timezone</b></code> ), les <code><b>django.urls.reverse</b></code> ( <code><b>django.urls.reverse</b></code> ), et bien plus encore.  Si cela n'est pas fait, vous obtiendrez une erreur: <br><br><pre> <code class="plaintext hljs">django.core.exceptions.AppRegistryNotReady: Apps aren't loaded yet.</code> </pre><br>  J'écris constamment ces deux lignes.  Je suis un grand fan du code d'éjection;  J'aime créer un fichier <code><b>.py</b></code> séparé, y tordre les choses, le comprendre - puis l'intégrer dans le projet. <br><br>  Et cette constante <code><b>django.setup()</b></code> me gêne beaucoup.  Premièrement, vous en avez assez de le répéter partout;  et, deuxièmement, l'initialisation de django prend plusieurs secondes (nous avons un gros monolithe), et lorsque vous redémarrez le même fichier 10, 20, 100 fois - cela ralentit simplement le développement. <br><br>  Comment se débarrasser de <code><b>django.setup()</b></code> ?  Vous devez écrire du code qui dépend au minimum de django. <br><br>  Par exemple, si nous écrivons un client d'une API externe, nous pouvons le rendre dépendant de django: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> django.conf <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> settings <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">APIClient</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.api_key = settings.SOME_API_KEY <span class="hljs-comment"><span class="hljs-comment"># : client = APIClient()</span></span></code> </pre><br>  ou il peut être indépendant de django: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">APIClient</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, api_key)</span></span></span><span class="hljs-function">:</span></span> self.api_key = api_key <span class="hljs-comment"><span class="hljs-comment"># : client = APIClient(api_key='abc')</span></span></code> </pre><br>  Dans le deuxième cas, le constructeur est plus encombrant, mais toutes les manipulations avec cette classe peuvent être effectuées sans charger l'ensemble des machines dzhangovskoy. <br><br>  Les tests deviennent également plus faciles.  Comment tester un composant qui dépend des paramètres de <code><b>django.conf.settings</b></code> ?  Verrouillez-les simplement avec le décorateur <code><b>@override_settings</b></code> .  Et si le composant ne dépend de rien, il n'y aura rien à mouiller: il a transmis les paramètres au constructeur - et l'a conduit. <br><br><h1>  Gestion des dépendances </h1><br>  L'histoire des dépendances <code><b>django</b></code> est l'exemple le plus frappant d'un problème que je rencontre tous les jours: les problèmes de gestion des dépendances en python - et l'architecture globale des applications python. <br><br>  La relation avec la gestion des dépendances dans la communauté Python est mitigée.  On distingue trois camps principaux: <br><br><ul><li>  Python est un langage flexible.  Nous écrivons comme nous voulons, selon ce que nous voulons.  Nous ne sommes pas gênés par les dépendances cycliques, la substitution d'attributs pour les classes lors de l'exécution, etc. <br><br></li><li>  Python est un langage spécial.  Il existe des façons idiomatiques de créer une architecture et des dépendances.  Le transfert de données vers le haut et vers le bas de la pile d'appels est effectué par des itérateurs, des coroutines et des gestionnaires de contexte. <br><br><div class="spoiler">  <b class="spoiler_title">Rapport de classe sur ce sujet et exemple</b> <div class="spoiler_text">  Brandon Rhodes, Dropbox: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hissez votre IO</a> . <br><br>  Exemple du rapport: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""          """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"/etc/hosts"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> file: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> parse_hosts(file): print(line) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_hosts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lines)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""    -   """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> lines: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> line.startswith(<span class="hljs-string"><span class="hljs-string">"#"</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> line</code> </pre><br></div></div><br></li><li>  La flexibilité de Python est un moyen supplémentaire de se tirer une balle dans le pied.  Vous avez besoin d'un ensemble rigide de règles pour gérer les dépendances.  Un bon exemple est les gars russes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de python sec</a> .  Il y a toujours une approche moins hardcore - la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">structure Django pour l'échelle et la longévité</a> , mais l'idée est la même. <br></li></ul><br>  Il existe plusieurs articles sur la gestion des dépendances en python ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemple 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemple 2</a> ), mais ils se résument tous à la publicité des cadres d'injection de dépendance de quelqu'un.  Cet article est une nouvelle entrée sur le même sujet, mais cette fois c'est une pure expérience de pensée sans publicité.  Il s'agit d'une tentative de trouver un équilibre entre les trois approches ci-dessus, de se passer d'un cadre supplémentaire et de le rendre «pythonique». <br><br>  J'ai récemment lu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Clean Architecture</a> - et je semble comprendre quelle est la valeur de l'injection de dépendances en python et comment elle peut être implémentée.  Je l'ai vu sur l'exemple de mon propre projet.  En bref, cela <b>protège le code contre la rupture lorsqu'un autre code change</b> . <br><br><h1>  Données source </h1><br>  Il existe un client API qui exécute les requêtes HTTP pour le raccourcisseur de service: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># shortener_client.py import requests class ShortenerClient: def __init__(self, api_key): self.api_key = api_key def shorten_link(self, url): response = requests.post( url='https://fstrk.cc/short', headers={'Authorization': self.api_key}, json={'url': url} ) return response.json()['url']</span></span></code> </pre><br>  Et il y a un module qui raccourcit tous les liens dans le texte.  Pour ce faire, il utilise le client API raccourcisseur: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># text_processor.py import re from shortener_client import ShortenerClient class TextProcessor: def __init__(self, text): self.text = text def process(self): changed_text = self.text links = re.findall( r'https?://[^\r\n\t") ]*', self.text, flags=re.MULTILINE ) api_client = ShortenerClient('abc') for link in links: shortened = api_client.shorten_link(link) changed_text = changed_text.replace(link, shortened) return changed_text</span></span></code> </pre><br>  La logique d'exécution du code réside dans un fichier de contrôle séparé (appelons-le un contrôleur): <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># controller.py from text_processor import TextProcessor processor = TextProcessor("""  1: https://ya.ru  2: https://google.com """) print(processor.process())</span></span></code> </pre><br>  Tout fonctionne.  Le processeur analyse le texte, raccourcit les liens à l'aide d'un raccourcisseur, renvoie le résultat.  Les dépendances ressemblent à ceci: <br><br><img src="http://ftcdn.pw/58d8aa1d-0024-42c6-918e-05b2d41f126d.png" alt="image"><br><br><h1>  Le problème </h1><br>  Voici le problème: la classe <code><b>TextProcessor</b></code> dépend de la classe <code><b>ShortenerClient</b></code> - et <b>s'arrête lorsque l'interface</b> <code><b>ShortenerClient</b></code> <b>change</b> . <br><br>  Comment cela peut-il arriver? <br><br>  Supposons que dans notre projet, nous avons décidé de suivre les <code><b>shorten_link</b></code> et d'ajouter l'argument <code><b>callback_url</b></code> à la méthode <code><b>shorten_link</b></code> .  Cet argument signifie l'adresse à laquelle les notifications doivent parvenir lorsque vous cliquez sur un lien. <br><br>  La méthode <code><b>ShortenerClient.shorten_link</b></code> commencé à ressembler à ceci: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shorten_link</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, url, callback_url)</span></span></span><span class="hljs-function">:</span></span> response = requests.post( url=<span class="hljs-string"><span class="hljs-string">'https://fstrk.cc/short'</span></span>, headers={<span class="hljs-string"><span class="hljs-string">'Authorization'</span></span>: self.api_key}, json={<span class="hljs-string"><span class="hljs-string">'url'</span></span>: url, <span class="hljs-string"><span class="hljs-string">'callback_on_click'</span></span>: callback_url} ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response.json()[<span class="hljs-string"><span class="hljs-string">'url'</span></span>]</code> </pre><br>  Et que se passe-t-il?  Et il s'avère que lorsque nous essayons de commencer, nous obtenons une erreur: <br><br><pre> <code class="python hljs">TypeError: shorten_link() missing <span class="hljs-number"><span class="hljs-number">1</span></span> required positional argument: <span class="hljs-string"><span class="hljs-string">'callback_url'</span></span></code> </pre><br>  Autrement dit, nous avons changé le raccourcisseur, mais ce n'est pas lui qui s'est cassé, mais son client: <br><br><img src="http://ftcdn.pw/13e9dcd5-7866-4c82-b1d0-e56134650b62.png" alt="image"><br><br>  Et alors?  Eh bien, le fichier d'appel s'est cassé, nous sommes allés le réparer.  Quel est le problème? <br><br>  Si cela est résolu en une minute - ils sont allés et corrigés - alors ce n'est bien sûr pas un problème du tout.  S'il y a peu de code dans les classes et si vous les supportez vous-même (c'est votre projet parallèle, ce sont deux petites classes du même sous-système, etc.), alors vous pouvez vous arrêter là. <br><br>  Les problèmes commencent lorsque: <br><br><ul><li>  les modules appelants et appelés ont beaucoup de code; </li><li>  différents modules sont pris en charge par différentes personnes / équipes. </li></ul><br>  Si vous écrivez la classe <code><b>ShortenerClient</b></code> et que votre collègue écrit <code><b>TextProcessor</b></code> , vous obtenez une situation offensive: <b>vous avez modifié le code, mais il s'est cassé.</b>  Et il s'est cassé dans un endroit que vous n'avez pas vu dans la vie, et maintenant vous devez vous asseoir et comprendre le code de quelqu'un d'autre. <br><br>  Ce qui est encore plus intéressant, c'est lorsque votre module est utilisé à plusieurs endroits, et non à un seul;  et votre modification cassera le code sur le tas de fichiers. <br><br>  Par conséquent, le problème peut être formulé comme suit: comment organiser le code de sorte que lorsque l'interface <code><b>ShortenerClient</b></code> est modifiée, <code><b>ShortenerClient</b></code> <b>lui-même <code><b>ShortenerClient</b></code> , et non ses consommateurs</b> (il peut y en avoir beaucoup) <br><br>  La solution ici est: <br><br><ul><li>  Les consommateurs de classe et la classe elle-même doivent se mettre d'accord sur une interface commune.  Cette interface devrait devenir loi. </li><li>  Si la classe cesse de correspondre à son interface, ce seront ses problèmes, et non les problèmes des consommateurs. </li></ul><br><img src="http://ftcdn.pw/dbb4d320-2683-4f2e-821e-dea621b54b53.png" alt="image"><br><br><h1>  Geler l'interface </h1><br>  À quoi ressemble la fixation d'une interface en python?  Ceci est une classe abstraite: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> abc <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ABC, abstractmethod <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractClient</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(ABC)</span></span></span><span class="hljs-class">:</span></span> @abstractmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, api_key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> @abstractmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shorten_link</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, link)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre><br>  Si maintenant nous héritons de cette classe et oublions d'implémenter une méthode, nous obtiendrons une erreur: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShortenerClient</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(AbstractClient)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__ini__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, api_key)</span></span></span><span class="hljs-function">:</span></span> self.api_key = api_key client = ShortenerClient(<span class="hljs-string"><span class="hljs-string">'123'</span></span>) &gt;&gt;&gt; TypeError: Can<span class="hljs-string"><span class="hljs-string">'t instantiate abstract class ShortenerClient with abstract methods __init__, shorten_link</span></span></code> </pre><br>  Mais cela ne suffit pas.  Une classe abstraite capture uniquement les noms des méthodes, mais pas leur signature. <br><br>  Besoin d'un deuxième outil de vérification de signature Ce deuxième outil est <code><b>mypy</b></code> .  Cela aidera à vérifier les signatures des méthodes héritées.  Pour ce faire, nous devons ajouter des annotations à l'interface: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># shortener_client.py from abc import ABC, abstractmethod class AbstractClient(ABC): @abstractmethod def __init__(self, api_key: str) -&gt; None: pass @abstractmethod def shorten_link(self, link: str) -&gt; str: pass class ShortenerClient(AbstractClient): def __init__(self, api_key: str) -&gt; None: self.api_key = api_key def shorten_link(self, link: str, callback_url: str) -&gt; str: return 'xxx'</span></span></code> </pre><br>  Si nous vérifions maintenant ce code avec <code><b>mypy</b></code> , nous obtenons une erreur en raison de l'argument supplémentaire <code><b>callback_url</b></code> : <br><br><pre> <code class="plaintext hljs">mypy shortener_client.py &gt;&gt;&gt; error: Signature of "shorten_link" incompatible with supertype "AbstractClient"</code> </pre><br>  Nous avons maintenant un moyen fiable de valider l'interface de classe. <br><br><h1>  Inversion de dépendance </h1><br>  Après avoir débogué l'interface, nous devons la déplacer vers un autre endroit afin d'éliminer complètement la dépendance du consommateur envers le fichier <code><b>shortener_client.py</b></code> .  Par exemple, vous pouvez faire glisser l'interface directement vers le consommateur - vers un fichier avec le processeur <code><b>TextProcessor</b></code> : <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># text_processor.py import re from abc import ABC, abstractmethod class AbstractClient(ABC): @abstractmethod def __init__(self, api_key: str) -&gt; None: pass @abstractmethod def shorten_link(self, link: str) -&gt; str: pass class TextProcessor: def __init__(self, text, shortener_client: AbstractClient) -&gt; None: self.text = text self.shortener_client = shortener_client def process(self) -&gt; str: changed_text = self.text links = re.findall( r'https?://[^\r\n\t") ]*', self.text, flags=re.MULTILINE ) for link in links: shortened = self.shortener_client.shorten_link(link) changed_text = changed_text.replace(link, shortened) return changed_text</span></span></code> </pre><br>  Et cela va changer le sens de la dépendance!  Désormais, le <code><b>TextProcessor</b></code> possède l'interface d'interaction et, par conséquent, <code><b>ShortenerClient</b></code> dépend, et non l'inverse. <br><br><img src="http://ftcdn.pw/33f3c619-63bf-420d-99d0-67bed0dfa628.png" alt="image"><br><br>  En termes simples, nous pouvons décrire l'essence de notre transformation comme suit: <br><br><ul><li>  <code><b>TextProcessor</b></code> dit: Je suis un processeur et je suis impliqué dans la conversion de texte.  Je ne veux rien savoir du mécanisme de raccourcissement: ce n'est pas mon affaire.  Je veux tirer la méthode <code><b>shorten_link</b></code> pour qu'elle <code><b>shorten_link</b></code> tout pour moi.  Alors s'il vous plaît, donnez-moi un objet qui joue selon mes règles.  Les décisions sur la façon dont j'interagis sont prises par moi, pas par lui. </li><li>  <code><b>ShortenerClient</b></code> dit: il semble que je ne puisse pas exister dans le vide, et ils nécessitent un certain comportement de ma part.  Je vais demander à <code><b>TextProcessor</b></code> ce dont j'ai besoin pour ne pas casser. </li></ul><br><h1>  Plusieurs consommateurs </h1><br>  Si plusieurs modules utilisent des liens raccourcis, l'interface doit être placée non pas dans l'un d'eux, mais dans un fichier séparé, situé au-dessus des autres fichiers, plus haut dans la hiérarchie: <br><br><img src="http://ftcdn.pw/a81ef19a-45aa-4b23-b93a-e9a6b9094670.png" alt="image"><br><br><h1>  Composant de contrôle </h1><br>  Si les consommateurs n'importent pas <code><b>ShortenerClient</b></code> , alors qui l'importera et créera un objet de classe?  Ce devrait être un composant de contrôle - dans notre cas, c'est <code><b>controller.py</b></code> . <br><br>  L'approche la plus simple est une injection de dépendance directe, l'injection de dépendance «dans le front».  Nous créons des objets dans le code appelant, transférons un objet à un autre.  Bénéfice <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># controller.py import TextProcessor import ShortenerClient processor = TextProcessor( text=' 1: https://ya.ru  2: https://google.com', shortener_client=ShortenerClient(api_key='123') ) print(processor.process())</span></span></code> </pre><br><h1>  Approche Python </h1><br>  Une approche plus «pythonique» serait l'injection de dépendance par héritage. <br><br><div class="spoiler">  <b class="spoiler_title">Raymond Hettinger en parle en détail dans son rapport Super réfléchi.</b> <div class="spoiler_text"><div class="oembed">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://www.youtube.com/watch?v=EiOglTERPEo</a> </div><br></div></div><br>  Pour adapter le code à ce style, vous devez modifier légèrement le <code><b>TextProcessor</b></code> , le rendant héritable: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># text_processor.py class TextProcessor: def __init__(self, text: str) -&gt; None: self.text = text self.shortener_client: AbstractClient = self.get_shortener_client() def get_shortener_client(self) -&gt; AbstractClient: """      """ raise NotImplementedError</span></span></code> </pre><br>  Et puis, dans le code appelant, héritez-le: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># controller.py import TextProcessor import ShortenerClient class ProcessorWithClient(TextProcessor): """   ,    """ def get_shortener_client(self) -&gt; ShortenerClient: return ShortenerClient(api_key='abc') processor = ProcessorWithClient( text=' 1: https://ya.ru  2: https://google.com' ) print(processor.process())</span></span></code> </pre><br>  Le deuxième exemple est omniprésent dans les cadres populaires: <br><br><ul><li>  Chez Django, nous sommes constamment hérités.  Nous redéfinissons les méthodes de vue basée sur les classes, les modèles, les formulaires;  en d'autres termes, injectez nos dépendances dans le travail déjà débogué du framework. </li><li>  En DRF, la même chose.  Nous élargissons les vues, les sérialiseurs et les autorisations. </li><li>  Et ainsi de suite.  Il y a beaucoup d'exemples. </li></ul><br>  Le deuxième exemple semble plus joli et plus familier, n'est-ce pas?  Développons-la et voyons si cette beauté est préservée. <br><br><h1>  Développement Python </h1><br>  Dans la logique métier, il y a généralement plus de deux composants.  Supposons que notre <code><b>TextProcessor</b></code> n'est pas une classe indépendante, mais seulement l'un des éléments du <code><b>TextPipeline</b></code> qui traite le texte et l'envoie à la messagerie: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TextPipeline</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, text, email)</span></span></span><span class="hljs-function">:</span></span> self.text_processor = TextProcessor(text) self.mailer = Mailer(email) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_and_mail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> processed_text = self.text_processor.process() self.mailer.send_text(text=processed_text)</code> </pre><br>  Si nous voulons isoler le <code><b>TextPipeline</b></code> des classes utilisées, nous devons suivre la même procédure que précédemment: <br><br><ul><li>  la classe <code><b>TextPipeline</b></code> déclarera des interfaces pour les composants utilisés; </li><li>  les composants utilisés seront obligés de se conformer à ces interfaces; </li><li>  du code externe rassemblera tout et fonctionnera. </li></ul><br>  Le diagramme de dépendance ressemblera à ceci: <br><br><img src="http://ftcdn.pw/35f207fa-3ad7-4779-92c3-ae8f63401b8e.png" alt="image"><br><br>  Mais à quoi ressemblera maintenant le code assembleur de ces dépendances? <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TextProcessor <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ShortenerClient <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Mailer <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TextPipeline <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProcessorWithClient</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(TextProcessor)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_shortener_client</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function"> -&gt; ShortenerClient:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ShortenerClient(api_key=<span class="hljs-string"><span class="hljs-string">'123'</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PipelineWithDependencies</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(TextPipeline)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_text_processor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, text: str)</span></span></span><span class="hljs-function"> -&gt; ProcessorWithClient:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ProcessorWithClient(text) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_mailer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, email: str)</span></span></span><span class="hljs-function"> -&gt; Mailer:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Mailer(email) pipeline = PipelineWithDependencies( email=<span class="hljs-string"><span class="hljs-string">'abc@def.com'</span></span>, text=<span class="hljs-string"><span class="hljs-string">' 1: https://ya.ru  2: https://google.com'</span></span> ) pipeline.process_and_mail()</code> </pre><br>  L'avez-vous remarqué?  Nous <code><b>TextProcessor</b></code> abord de la classe <code><b>TextProcessor</b></code> pour y insérer le <code><b>ShortenerClient</b></code> , puis nous <code><b>TextPipeline</b></code> du <code><b>TextPipeline</b></code> pour y insérer notre <code><b>TextProcessor</b></code> substitué (ainsi que <code><b>Mailer</b></code> ).  Nous avons plusieurs niveaux de redéfinition séquentielle.  Déjà compliqué. <br><br>  Pourquoi tous les cadres sont-ils organisés de cette manière?  <b>Oui, car il ne convient qu'aux frameworks.</b> <br><br><ul><li>  Tous les niveaux du cadre sont clairement définis et leur nombre est limité.  Par exemple, dans Django, vous pouvez remplacer <code><b>FormField</b></code> pour l'insérer dans une substitution d'un <code><b>Form</b></code> , pour insérer un formulaire dans une substitution de <code><b>View</b></code> .  C’est tout.  Trois niveaux. </li><li>  Chaque cadre sert un objectif.  Cette tâche est clairement définie. </li><li>  Chaque cadre possède une documentation détaillée qui décrit comment et quoi hériter;  quoi et avec quoi combiner. </li></ul><br>  Pouvez-vous identifier et documenter clairement et sans ambiguïté votre logique métier?  Surtout l'architecture des niveaux auxquels il fonctionne?  Non.  Malheureusement, l'approche de Raymond Hettinger ne s'adapte pas à la logique métier. <br><br><h1>  Retour à l'approche du front </h1><br>  À plusieurs niveaux de difficulté, une approche simple l'emporte.  Il semble plus simple - et plus facile à changer lorsque la logique change. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TextProcessor <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ShortenerClient <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Mailer <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TextPipeline pipeline = TextPipeline( text_processor=TextProcessor( text=<span class="hljs-string"><span class="hljs-string">' 1: https://ya.ru  2: https://google.com'</span></span>, shortener_client=ShortenerClient(api_key=<span class="hljs-string"><span class="hljs-string">'abc'</span></span>) ), mailer=Mailer(<span class="hljs-string"><span class="hljs-string">'abc@def.com'</span></span>) ) pipeline.process_and_mail()</code> </pre><br>  Mais, lorsque le nombre de niveaux de logique augmente, même cette approche devient incommode.  Nous devons impérativement initier un tas de classes, les passer les uns dans les autres.  Je veux éviter de nombreux niveaux d'imbrication. <br><br>  Essayons encore un appel. <br><br><h1>  Stockage d'instance global </h1><br>  Essayons de créer un dictionnaire global dans lequel se trouveront les instances des composants dont nous avons besoin.  Et laissez ces composants s'obtenir grâce à l'accès à ce dictionnaire. <br><br>  Appelons-le <code><b>INSTANCE_DICT</b></code> : <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># text_processor.py import INSTANCE_DICT class TextProcessor(AbstractTextProcessor): def __init__(self, text) -&gt; None: self.text = text def process(self) -&gt; str: shortener_client: AbstractClient = INSTANCE_DICT['Shortener'] # ...  </span></span></code> </pre><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># text_pipeline.py import INSTANCE_DICT class TextPipeline: def __init__(self) -&gt; None: self.text_processor: AbstractTextProcessor = INSTANCE_DICT[ 'TextProcessor'] self.mailer: AbstractMailer = INSTANCE_DICT['Mailer'] def process_and_mail(self) -&gt; None: processed_text = self.text_processor.process() self.mailer.send_text(text=processed_text)</span></span></code> </pre><br>  L'astuce consiste à <b>mettre nos objets dans ce dictionnaire avant d'y accéder</b> .  C'est ce que nous ferons dans <code><b>controller.py</b></code> : <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># controller.py import INSTANCE_DICT import TextProcessor import ShortenerClient import Mailer import TextPipeline INSTANCE_DICT['Shortener'] = ShortenerClient('123') INSTANCE_DICT['Mailer'] = Mailer('abc@def.com') INSTANCE_DICT['TextProcessor'] = TextProcessor(text=' : https://ya.ru') pipeline = TextPipeline() pipeline.process_and_mail()</span></span></code> </pre><br>  Avantages de travailler avec un dictionnaire global: <br><br><ul><li>  pas de magie du capot moteur et des cadres DI supplémentaires; </li><li>  une liste plate de dépendances dans lesquelles vous n'avez pas besoin de gérer l'imbrication; </li><li>  tous les bonus DI: tests simples, indépendance, protection des composants contre les pannes lorsque d'autres composants changent. </li></ul><br>  Bien sûr, au lieu de créer <code><b>INSTANCE_DICT</b></code> - <code><b>INSTANCE_DICT</b></code> , vous pouvez utiliser une sorte de framework DI;  mais l'essence de cela ne changera pas.  Le cadre offrira une gestion plus flexible des instances;  il vous permettra de les créer sous forme de singletones ou de bundles, comme une usine;  mais l'idée restera la même. <br><br>  Peut-être qu'à un moment donné, cela ne me suffira pas, et je continue de choisir une sorte de cadre. <br><br>  Et, peut-être, tout cela est inutile, et il est plus facile de s'en passer: écrire des importations directes et ne pas créer d'interfaces abstraites inutiles. <br><br>  Quelle est votre expérience avec la gestion des dépendances en python?  Et en général - est-ce nécessaire, ou est-ce que j'invente un problème de l'air? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr461511/">https://habr.com/ru/post/fr461511/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr461501/index.html">Pourquoi aux États-Unis, ils enquêtent sur le travail des grandes entreprises informatiques</a></li>
<li><a href="../fr461503/index.html">Rendre la base de données disponible pour une connexion à distance</a></li>
<li><a href="../fr461505/index.html">8 bugs de développeurs JavaScript novices qui vous empêchent de devenir un professionnel</a></li>
<li><a href="../fr461507/index.html">Pourquoi avons-nous décidé de lancer l'accélérateur d'entreprise Gazprom Neft StartupDrive, et qui l'a déjà adopté</a></li>
<li><a href="../fr461509/index.html">Assistants de voyage: une sélection de gadgets et accessoires</a></li>
<li><a href="../fr461517/index.html">Meilleurs algorithmes de copier-coller pour C et C ++. Haiku OS Cookbook</a></li>
<li><a href="../fr461519/index.html">Meilleurs algorithmes de copier-coller pour C et C ++. Collection de recettes Haiku OS</a></li>
<li><a href="../fr461523/index.html">WAL dans PostgreSQL: 4. Configuration du journal</a></li>
<li><a href="../fr461525/index.html">Comment j'ai fait un curseur vraiment adaptatif (carrousel)</a></li>
<li><a href="../fr461527/index.html">Lévitation acoustique bricolage</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>