<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏅 🧛🏿 👶🏽 PHPUnit. "Como faço para testar meu maldito controlador" ou testar se há dúvidas 👩🏿‍🌾 👟 🕧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Oi Habr. 



 Sim, este é outro post sobre o tópico de teste. Parece que aqui já é possível discutir? Todos que precisam - escrevem testes, que não pr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PHPUnit. "Como faço para testar meu maldito controlador" ou testar se há dúvidas</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485418/">  Oi Habr. <br><br><img src="https://habrastorage.org/webt/do/li/as/doliasx6rmfzgqhvfc-7jdazq-w.jpeg" alt="imagem"><br><br>  Sim, este é outro post sobre o tópico de teste.  Parece que aqui já é possível discutir?  Todos que precisam - escrevem testes, que não precisam - eles não escrevem, todos estão felizes!  O fato é que a maioria dos posts sobre testes de unidade tem ... como ofender ninguém ... exemplos idiotas!  Sério, não!  Hoje vou tentar consertar.  Eu peço gato. <br><a name="habracut"></a><br>  Assim, a pesquisa rápida no tópico de testes encontra apenas muitos artigos, que em sua maioria são divididos em duas categorias: <br><br>  1) A felicidade de um redator.  Primeiro, vemos uma longa introdução, depois a história dos testes de unidade na Rússia antiga, depois dez hacks de vida com testes e, no final, um exemplo.  Com testes de código como este: <br><br><pre><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Calculator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($a, $b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $a + $b; } }</code> </pre> <br>  E eu não estou brincando agora.  Eu realmente vi artigos com uma "calculadora" como um guia de estudo.  Sim, sim, entendo que, para começar, é necessário simplificar tudo, abstrações, e para trás ... Mas é aqui que tudo acaba!  E então termine a coruja, como eles dizem <br><br>  2) Exemplos excessivamente sofisticados.  Vamos escrever um teste e colocá-lo no CI do Gitlab. Em seguida, corrigiremos automaticamente se o teste for aprovado e aplicaremos a infecção pelo PHP aos testes, mas conectaremos tudo ao Hudson.  E assim por diante nesse estilo.  Parece ser útil, mas parece que não é exatamente o que você está procurando.  Mas você só quer aumentar um pouco a estabilidade do seu projeto.  E todas essas continuidades - bem, então, não de uma só vez. <br><br>  Como resultado, as pessoas duvidam: "Mas eu preciso disso".  Por sua vez, quero tentar explicar mais claramente os testes.  E faça uma reserva imediatamente - sou desenvolvedor, não sou testador.  Tenho certeza de que eu mesmo não sei muito, e minha primeira palavra na minha vida não foi a palavra "mok".  Eu nunca trabalhei em TDD!  Mas tenho certeza de que mesmo meu nível atual de habilidades me permitiu cobrir vários projetos com testes, e esses mesmos testes já detectaram uma dúzia de bugs.  E se isso me ajudasse, poderia ajudar outra pessoa.  Alguns erros detectados seriam difíceis de detectar manualmente. <br><br>  Para começar, um pequeno programa educacional no formato de perguntas e respostas: <br><br>  P: Preciso usar algum tipo de estrutura?  E se eu tiver o Yii?  E se Kohana?  E se% one_more_framework_name%? <br>  R: Não, o PHPUnit é uma estrutura de teste independente, você pode até parafusá-la no código legado em uma estrutura criada por você. <br><br>  P: E agora estou rapidamente navegando pelo site com minhas mãos, e isso é normal.  Por que eu preciso disso? <br>  R: A execução de várias dezenas de testes dura vários segundos.  O teste automático é sempre mais rápido que o manual e, com testes de alta qualidade, também é mais confiável, pois abrange todos os cenários. <br><br>  P: Eu tenho um código legado com funções de 2000 linhas.  Posso testar isso? <br>  A: Sim e não.  Em teoria, sim, qualquer código pode ser coberto com um teste.  Na prática, o código deve ser escrito com uma base para testes futuros.  Uma função de linha 2000 terá muitas dependências, ramificações, casos de borda.  Pode acabar cobrindo tudo no final, mas provavelmente levará um tempo inaceitavelmente longo.  Quanto melhor o código, mais fácil é testá-lo.  Quanto melhor a responsabilidade única for respeitada, mais fáceis serão os testes.  Para testar projetos antigos com mais freqüência, primeiro é necessário refatorá-los com frieza. <br><br><img src="https://habrastorage.org/webt/c5/oa/ze/c5oaze8gmau8ticskgu44o5wyza.jpeg" alt="imagem"><br><br>  P: Eu tenho métodos muito simples (funções), o que há para testar?  Tudo é confiável lá, não há espaço para erro! <br>  R: Deve-se entender que você não testa a implementação correta da função (se você não possui TDD), simplesmente "corrige" seu estado atual de trabalho.  No futuro, quando precisar alterá-lo, você poderá determinar rapidamente se quebrou o comportamento usando o teste.  Exemplo: existe uma função que valida o email.  Ela faz isso regularmente. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isValid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($email)</span></span></span><span class="hljs-function"> </span></span>{ $regex = <span class="hljs-string"><span class="hljs-string">"very_complex_regex_here"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_array($email)) { $result = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($email <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $item) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (preg_match($regex, $item) === <span class="hljs-number"><span class="hljs-number">0</span></span>) { $result = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $result = preg_match($regex, $emai) ==! <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $result; }</code> </pre><br>  Todo o seu código espera que, se você passar um email válido para essa função, ele retornará verdadeiro.  Uma matriz de e-mails válidos também é verdadeira.  Uma matriz com pelo menos um endereço de email inválido é falsa.  Bem e assim por diante, o código é claro.  Mas chegou o dia e você decidiu substituir a monstruosa temporada regular por uma API externa.  Mas como garantir que a função reescrita não mudou o princípio de operação?  De repente, ele não lida bem com a matriz?  Ou retornará não booleano?  E os testes podem manter isso sob controle.  Um teste bem escrito indicará imediatamente um comportamento de função diferente do esperado. <br><br>  P: Quando começarei a perceber algum sentido nos testes? <br>  R: Em primeiro lugar, assim que você cobrir uma parte significativa do código.  Quanto mais próxima a cobertura estiver de 100%, mais confiável será o teste.  Em segundo lugar, assim que você precisar fazer alterações globais ou alterações na parte complexa do código.  Os testes podem detectar problemas facilmente perdidos manualmente (casos limítrofes).  Em terceiro lugar, ao escrever os próprios testes!  Muitas vezes, há uma situação ao escrever um teste, que revela falhas de código que não são visíveis à primeira vista. <br><br>  P: Bem, eu tenho um site no laravel.  O site não é uma função, o site é uma montanha de código de merda.  Como testar aqui? <br>  A: Isto é o que será discutido mais adiante.  Em resumo: testamos separadamente os métodos dos controladores, separadamente o middleware, separadamente os serviços, etc. <br><br>  Uma das idéias do teste de unidade é isolar a seção de código testada.  Quanto menos código você testar com um teste, melhor.  Vejamos um exemplo o mais próximo possível da vida real: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Controller</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($userService, $emailService)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;userService = $userService; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;emailService = $emailService; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($request)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($request-&gt;login) || <span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($request-&gt;password)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Auth error"</span></span>; } $password = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;userService-&gt;getPasswordFor($request-&gt;login); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($password)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Auth error - no password"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($password !== $request-&gt;password) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Incorrect password"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;emailService-&gt;sendEmail($request-&gt;login); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Success"</span></span>; } } <span class="hljs-comment"><span class="hljs-comment">// .... /* somewhere in project core */ $controller = new Controller($userService, $emailService); $controller-&gt;login($request);</span></span></code> </pre> <br>  Esse é um método muito típico de efetuar login no sistema em pequenos projetos.  Tudo o que esperamos são as mensagens de erro corretas e o email enviado no caso de um login bem-sucedido.  Como testar esse método?  Primeiro, você precisa identificar dependências externas.  No nosso caso, existem dois deles - $ userService e $ emailService.  Eles são passados ​​pelo construtor de classe, o que facilita muito nossa tarefa.  Mas, como mencionado anteriormente, quanto menos código testamos em uma passagem, melhor. <br><br>  Emulação, substituição de objetos é chamada mokanem (do inglês. Mock objeto, literalmente: "paródia de objeto").  Ninguém se preocupa em escrever esses objetos manualmente, mas tudo já foi inventado diante de nós, de modo que uma biblioteca maravilhosa como <a href="https://github.com/mockery/mockery" rel="nofollow">Mockery</a> vem em socorro.  Vamos criar mokas para serviços. <br><br><pre> <code class="php hljs">$userService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'user_service'</span></span>); $emailService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'email_service'</span></span>);</code> </pre> <br>  Agora crie o objeto $ request.  Para começar, testaremos a lógica de verificar os campos de login e senha.  Queremos ter certeza de que, se não houver, nosso método manipulará corretamente esse caso e retornará a mensagem (!) Desejada. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testEmptyLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $userService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'user_service'</span></span>); $emailService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'email_service'</span></span>); $controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Controller($userService, $emailService); $request = (object) []; $result = $controller-&gt;login($request); }</code> </pre><br>  Nada complicado, certo?  Criamos stubs para os parâmetros de classe necessários, criamos uma instância da classe desejada e "extraímos" o método desejado, passando uma solicitação deliberadamente errada.  Tenho uma resposta.  Mas como verificar agora?  Esta é a parte mais importante do teste - a chamada afirmação.  O PHPUnit possui dezenas de <a href="https://phpunit.readthedocs.io/ru/latest/assertions.html" rel="nofollow">asserções</a> prontas.  Basta usar um deles. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testEmptyLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $userService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'user_service'</span></span>); $emailService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'email_service'</span></span>); $controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Controller($userService, $emailService); $request = (object) []; $result = $controller-&gt;login($request); <span class="hljs-comment"><span class="hljs-comment">// vv assertion here! vv $this-&gt;assertEquals("Auth error", $result); }</span></span></code> </pre><br>  Este teste garante o seguinte - se o argumento de login chegar ao objeto de método que não possui o campo de login ou senha, o método retornará a string "Erro de autenticação".  Isso, em geral, é tudo.  Tão simples - mas tão útil, porque agora podemos editar o método de login sem medo de quebrar algo.  Nosso front-end pode ter certeza de que, se algo acontecer - ele receberá esse erro.  E se alguém quebrar esse comportamento (por exemplo, decidir alterar o texto do erro), o teste imediatamente sinalizará isso!  Adicionamos as verificações restantes para cobrir o maior número possível de cenários. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testEmptyPassword</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $userService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'user_service'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// $userService-&gt;getPasswordFor(__any__arg__); // '' $userService-&gt;shouldReceive('getPasswordFor')-&gt;andReturn(''); $emailService = Mockery::mock('email_service'); $request = (object) [ 'login' =&gt; 'john', 'pass' =&gt; '1234' ]; $result = (new Controller($userService, $emailService))-&gt;login($request); $this-&gt;assertEquals("Auth error - no password", $result); } function testUncorrectPassword() { $userService = Mockery::mock('user_service'); // $userService-&gt;getPasswordFor(__any__arg__); // '4321' $userService-&gt;shouldReceive('getPasswordFor')-&gt;andReturn('4321'); $emailService = Mockery::mock('email_service'); $request = (object) [ 'login' =&gt; 'john', 'pass' =&gt; '1234' ]; $result = (new Controller($userService, $emailService))-&gt;login($request); $this-&gt;assertEquals("Incorrect password", $result); } function testSuccessfullLogin() { $userService = Mockery::mock('user_service'); // $userService-&gt;getPasswordFor(__any__arg__); // '1234' $userService-&gt;shouldReceive('getPasswordFor')-&gt;andReturn('1234'); $emailService = Mockery::mock('email_service'); $request = (object) [ 'login' =&gt; 'john', 'pass' =&gt; '1234' ]; $result = (new Controller($userService, $emailService))-&gt;login($request); $this-&gt;assertEquals("Success", $result); }</span></span></code> </pre><br>  Observe os métodos shouldReceive e andReturn?  Eles nos permitem criar métodos em stubs que retornam apenas o que precisamos.  Precisa testar o erro de senha errado?  Nós escrevemos um stub $ userService que sempre retorna a senha errada.  E é isso. <br><br>  E quanto às dependências, você pergunta.  Nós então os "afogamos", e se eles quebrarem?  Mas é exatamente para isso que serve a cobertura máxima de código nos testes.  Não verificaremos a operação desses serviços no contexto do logon - testaremos o logon na esperança da operação correta dos serviços.  E então escrevemos os mesmos testes isolados para esses serviços.  E depois testa suas dependências.  E assim por diante  Como resultado, cada teste individual garante <b>apenas a</b> operação correta de um pequeno pedaço de código, desde que todas as suas dependências funcionem corretamente.  E como todas as dependências também são cobertas por testes, sua operação correta também é garantida.  Como resultado, qualquer alteração no sistema que interrompa a lógica do trabalho, mesmo o menor pedaço de código, aparecerá imediatamente em um teste específico.  Como especificamente executar o teste - não vou contar, a documentação no PHPUnit é muito boa.  E no Laravel, por exemplo, basta executar vendor / bin / phpunit a partir da raiz do projeto para ver uma mensagem como esta <br><br><img src="https://habrastorage.org/webt/va/bc/co/vabccob2dpo9xiqk7ek9syxinmo.jpeg" alt="imagem">  - Todos os testes foram bem sucedidos.  Ou algo assim <br><br><img src="https://habrastorage.org/webt/bh/mc/pu/bhmcpuar0iluxa8nxxmwrkdgvqs.jpeg" alt="imagem">  Uma das sete afirmações falhou. <br><br>  "Isso, é claro, é legal, mas em que não consigo colocar minhas mãos?", Você pergunta.  E vamos imaginar o seguinte código para este <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($infoApi, $userName)</span></span></span><span class="hljs-function"> </span></span>{ $response = $infoApi-&gt;getInfo($userName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($response-&gt;status === <span class="hljs-string"><span class="hljs-string">"API Error"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $response-&gt;result; } <span class="hljs-comment"><span class="hljs-comment">// ... somewhere in system $api = new ExternalApi(); $info = getInfo($api, 'John'); if ($info === null) { die('Api is down'); } echo $info;</span></span></code> </pre><br>  Vemos um modelo simplificado de trabalho com uma API externa.  A função usa alguma classe para trabalhar com a API e, em caso de erro, retorna nulo.  Se, ao usar esta função, ficarmos nulos, devemos "aumentar o pânico" (enviar uma mensagem para a folga, enviar um e-mail ao desenvolvedor ou lançar um erro no kibana. Sim, várias opções).  Tudo parece ser simples, certo?  Mas imagine que depois de algum tempo outro desenvolvedor decidiu "consertar" essa função.  Ele decidiu que retornar nulo é o século passado, e ele deveria lançar uma exceção. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($infoApi, $userName)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span></span>{ $response = $infoApi-&gt;getInfo($userName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($response-&gt;status === <span class="hljs-string"><span class="hljs-string">"API Error"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApiException($response); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $response-&gt;result; }</code> </pre><br>  E ele até reescreveu todas as seções do código em que essa função foi chamada!  Todos menos um.  Ele sentia falta dele.  Distraído, cansado, errado - mas você nunca sabe.  O fato é que um pedaço de código ainda está aguardando o antigo comportamento da função.  E o PHP não é Java para nós - não receberemos um erro de compilação com o argumento de que a função jogável não está envolvida no try-catch.  Como resultado, em um dos 100 cenários de uso do site, no caso de uma queda da API, não receberemos uma mensagem do sistema.  Além disso, com o teste manual, provavelmente não capturaremos esta versão do evento.  A API é externa, não depende de nós, funciona bem - e, provavelmente, não colocaremos nossas mãos em caso de falha da API e tratamento incorreto de exceções.  Porém, se tivermos testes, eles entenderão muito bem esse caso, porque a classe ExternalApi é "abafada" em vários testes e emula o comportamento normal e a falha.  E o próximo teste vai cair <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testApiFail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $api = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'api'</span></span>); $api-&gt;shouldReceive(<span class="hljs-string"><span class="hljs-string">'getInfo'</span></span>)-&gt;andReturn((object) [ <span class="hljs-string"><span class="hljs-string">'status'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'API Error'</span></span> ]); $result = getInfo($api, <span class="hljs-string"><span class="hljs-string">'name'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertNull($result); }</code> </pre><br>  Esta informação é realmente suficiente.  Se você não tiver macarrão herdado, depois de 20 a 30 minutos, poderá escrever seu primeiro teste.  E algumas semanas depois - para aprender algo novo, legal, retorne aos comentários neste post e escreva qual autor o govnokoder não conhece sobre% framework_name% e escreve testes ruins, mas você precisa fazer% this_way%.  E ficarei muito feliz nesse caso.  Isso significa que meu objetivo foi alcançado: alguém descobriu o teste por si mesmo e aumentou um pouco o nível geral de profissionalismo em nosso campo! <br><br>  Críticas fundamentadas são bem-vindas. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt485418/">https://habr.com/ru/post/pt485418/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt485394/index.html">Como nasceu a infraestrutura da Internet</a></li>
<li><a href="../pt485396/index.html">Verificação de integridade do esquadrão: medindo a saúde da equipe</a></li>
<li><a href="../pt485398/index.html">Antipatterns do PostgreSQL: acerte o dicionário pesado JOIN</a></li>
<li><a href="../pt485404/index.html">Percebemos o efeito visual do filme "The Matrix"</a></li>
<li><a href="../pt485416/index.html">Maneiras práticas de mapear dados no Kotlin</a></li>
<li><a href="../pt485424/index.html">Como eu ensino crianças Python</a></li>
<li><a href="../pt485426/index.html">Carros na Holanda: estatísticas e informações para 2019</a></li>
<li><a href="../pt485428/index.html">O misterioso programa LyX. Parte 5</a></li>
<li><a href="../pt485430/index.html">Editor de texto multiusuário simples com criptografia de ponta a ponta</a></li>
<li><a href="../pt485438/index.html">Testando componentes da interface do usuário do React</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>