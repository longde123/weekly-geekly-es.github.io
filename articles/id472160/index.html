<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👍🏽 🔈 🤨 Phantom OS: jendela subsistem - lakukan kontrol 🈁 👨🏾‍🔧 🕤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini kita akan berbicara tentang bagaimana grafik Phantom UI diatur. 

 (Apa itu Phantom OS, Anda dapat mengetahuinya dengan membaca artikel-artik...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Phantom OS: jendela subsistem - lakukan kontrol</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472160/"> Hari ini kita akan berbicara tentang bagaimana grafik Phantom UI diatur. <br><br>  (Apa itu Phantom OS, Anda dapat mengetahuinya dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membaca artikel-artikel ini</a> .) <br><br>  Lebih tepatnya - bagaimana UI grafis ini lahir.  Untuk waktu yang lama, Phantom hanya memiliki kesimpulan grafis - hampir tidak mungkin untuk menyampaikan apa pun ke sistem dengan mouse. <br><br>  Sekarang waktunya telah tiba untuk membuat paling tidak sederhana - tetapi aplikasi, yang berarti - Anda memerlukan UI.  Bagaimanapun - sistem, kita akan jujur, itu tampak menakutkan.  Dan ini bukan mode sekarang. <br><br>  Apa yang tersedia di awal proyek UI?  Pada prinsipnya - banyak. <br><br>  Faktanya, ada grafis - driver video, subsistem jendela dalam mode hanya-tampilan, font bitmap, subsistem acara jendela (acara), kontrol fokus jendela, dan primitif terkait. <br><br>  Sekarang langkah-langkahnya dan sedikit lagi. <br><a name="habracut"></a><br>  Subsistem driver video dapat menjalankan fungsi probe () dari beberapa driver secara bergantian, menerima permintaan dari mereka untuk resolusi maksimum dan bitness warna, plus kemampuan untuk bekerja dalam mode akselerator 2D.  Sistem ini membutuhkan warna minimum 24-bit.  Pada level ini, kami memiliki framebuffer (layar dalam memori), mouse, dan beberapa jenis bitblt primitif. <br><br>  Bitblt primitif - tiga tipe dasar diimplementasikan - penyalinan penuh grafik (dengan persegi panjang terpotong), penyalinan dengan mempertimbangkan transparansi biner akun (piksel benar-benar transparan atau sangat buram) dan z-buffer.  Yaitu, kemampuan untuk menyalin pada layar hanya piksel yang memiliki koordinat z lebih besar dari koordinat z dari piksel yang ada - untuk menyelesaikan sebagian tumpang tindih jendela. <br><br>  Lapisan fungsi berikutnya adalah subsistem jendela.  Di sini ada konsep jendela, dekorasi jendela (bingkai, jendela judul dengan tombol), koordinat x / y / z jendela dan serangkaian fungsi yang bertanggung jawab untuk menggambar jendela di layar dan mengendalikan pergerakannya di sepanjang sumbu. <br><br><div class="spoiler">  <b class="spoiler_title">Dokumentasi</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kepala Dokumentasi</a> <br></div></div><br>  Acara berikut mengikuti - antrian mikrotask, yang diproses oleh driver tingkat bawah untuk rendering dan mengelola keadaan windows. <br><br>  Perlu dicatat bahwa pikiran terbaik umat manusia mengklaim bahwa sistem jendela-grafik yang akan bekerja secara stabil dan tanpa masalah dalam lingkungan yang tidak dapat dibaca tidak dapat ditulis tanpa antrian peristiwa.  Upaya saya yang sederhana untuk mengabaikan pernyataan ini sejauh ini hanya menegaskannya.  Sangat sulit untuk menghilangkan antrian pesan dan membuat semua utas meminta acara jendela untuk program dan kadang-kadang menyebabkan perang di layar. <br><br>  Oleh karena itu, sebagian besar primitif sistem jendela yang berkaitan dengan sesuatu yang lebih besar dari gambar di dalam jendela diimplementasikan melalui antrian pesan.  Permintaan mengirim ke antrian pesan "menggambar area ini di layar" atau "mengatur ulang jendela di atas yang lain", dan utas terpisah di bagian bawah mengeksekusi mereka teratur dan serius. <br><br>  Ini hanya mendapatkan aliran peristiwa dari mouse (ditekan, diseret), keyboard (ditekan, dilepaskan) dan sistem jendela itu sendiri (peristiwa sekunder - setelah menggerakkan jendela ke atas, menggambar ulang area layar). <br><br>  Tugas terpisah pada tingkat arus peristiwa adalah apa yang disebut fokus.  Jendela yang terfokus menerima aliran acara dari keyboard, dan memang itu jelas disorot di layar sebagai titik mengatasi aktivitas pengguna.  Selain tugas yang jelas untuk memilih jendela untuk mengarahkan acara, sistem ini juga menginformasikan jendela tentang kehilangan fokus, yang kadang-kadang penting. <br><br><div class="spoiler">  <b class="spoiler_title">Dokumentasi</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kepala Dokumentasi</a> <br></div></div><br>  Level selanjutnya adalah grafik primitif untuk menggambar di jendela. <br><br>  Ada dua opsi utama untuk implementasi.  Tua, ekonomis - ketika sebuah jendela tidak menyimpan salinan dari apa yang ditarik ke dalamnya.  Jika jendela seperti itu dihapus, dan Anda perlu menggambar yang terhapus lagi (misalnya, jendela dikembalikan ke layar dari tepi), maka jendela memanggil fungsi dari programnya, dan fungsi ini harus menggambar semua yang diperlukan.  Ini adalah model yang khas dan sangat merepotkan karena berbagai alasan.  Yang kedua dipilih di Phantom - setiap jendela memiliki bitmap di mana isi jendela saat ini digambar.  Sistem grafis selalu dapat merujuk ke salinan ini dan memperbaruinya di layar tanpa menarik program pengguna. <br><br>  Perhatikan bahwa jendela milik program pengguna (dan bukan kernel) di Phantom, tentu saja, gigih, disimpan dalam memori persisten dan setelah mem-boot ulang OS menyimpan semua yang tergambar di dalamnya.  Ini, kebetulan, secara mengejutkan bermanfaat dan menyederhanakan kode aplikasi di beberapa tempat menjadi tidak senonoh. <br><br>  Seperangkat gambar primitif memungkinkan kode aplikasi, seperti biasa, untuk menggambar titik, garis, bitmap, baris teks dalam font bitmap, dan beberapa hal kecil lainnya di jendela. <br><br>  Pada kekayaan subsistem grafis ini pada awal proyek "UI Phantom Baru" dan berakhir.  Pada prinsipnya, kit pria ini sudah cukup banyak, tetapi hanya untuk pengguna.  Tidak ada input <br><br>  Lebih tepatnya, ada dukungan yang belum sempurna untuk konsep "tombol", tetapi hanya dengan mouse, hanya di bilah alat dan hanya untuk menutup jendela.  :) <br><br>  Tugas pengembangan adalah sebagai berikut: <br><br><ul><li>  TrueType  Tanpa ini, sayang sekali. </li><li>  Acara keyboard dan kontrol keyboard.  Setidaknya dasar. </li><li>  Untuk berpikir tentang lokalisasi tata letak - setidaknya alfabet Cyrillic, tetapi meletakkan dasar untuk mengubah tata letak. </li><li>  Kontrol - tombol, tombol radio, bidang teks, label, menu dan sebagainya. </li><li>  Fokus kontrol adalah pilihan titik kontrol di dalam jendela. </li><li>  Beberapa jenis komponen layar untuk mengelola windows di layar.  Bilah tugas? </li><li>  Sebenarnya, gambar kontrol dan secara umum beberapa jenis desain UI - tidak boleh seperti pertanian kolektif seperti sebelumnya. </li></ul><br>  Seperti ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cb2/88b/7a8/cb288b7a8fa56dffa45b3aed20fc6eba.png" alt="gambar" width="600"><br><br>  Di perjalanan, ternyata alpha-blending juga diperlukan, yaitu transparansi sebagian piksel ketika melapiskan gambar.  Nah, menjadi jelas bahwa sudah waktunya untuk menyentuh Unicode untuk ambing. <br><br>  Pendekatan berat ini dibagi menjadi tiga bagian besar: Desain, Trump, sisanya. <br><br>  Tentang desain, singkatnya: Ada desain UI gratis di Internet tanpa persyaratan penggunaan yang jahat.  Tiga hari untuk mencari dan memilih, waktu tanpa akhir untuk pemotongan artistik elemen grafis. <br><br><h4>  Jenis truf </h4><br>  Saya takut akan hal ini, tetapi ternyata sia-sia.  Ada libfreetype, ada contoh aplikasi, setelah dua hari rendering font vektor bekerja cukup baik dalam mode uji. <br><br>  Namun, ada kehalusan, dan tidak semua jalan telah dibahas.  Yaitu.  Bekerja dengan font dari kernel - is.  Font-font tersebut kemudian digerakkan oleh hardcode ke dalam biner kernel.  Ini tidak dapat dihindari untuk font sistem, tetapi kode pengguna harus memiliki mekanisme pemuatannya sendiri.  Dan meskipun beberapa FS di Phantom, tentu saja, adalah dan akan, model ini tidak wajar baginya.  Anda harus dapat menyimpan font di objek yang persisten dan membawanya melalui jaringan. <br><br>  Yang kedua lebih sederhana - rookery font gratis berlimpah, dan organisasi mereka tidak akan lama. <br><br>  Tapi yang pertama ... <br><br>  Anda mungkin tidak tahu, tetapi variabel string di Phantom memiliki properti tak terduga untuk programmer yang tidak terbiasa kegigihan.  Mereka dapat mengganti file.  Aliran byte adalah aliran byte.  Tidak hanya itu, itu juga, menurut definisi, memori dipetakan - ini adalah variabel.  Artinya, pada prinsipnya, apa yang kami simpan di OS biasa dalam sebuah file, di Phantom, Anda bisa memasukkannya ke dalam variabel string.  Saya sering bertindak - dan kompiler Phantom bahkan memiliki desain - untuk menyedot file menjadi string konstan.  Jadi di userland, Phantoms melakukan penetrasi, misalnya, bitmap.  Tetapi ini juga merupakan metode yang memalukan, karena pada saat runtime variabel ini perlu di-parseed untuk mendapatkan representasi objek yang dapat dioperasikan.  Namun, untuk bitmap, maka, untuk menghormati konsep Phantom, semuanya baik-baik saja di sini.  Kami mengkompilasi file grafik menjadi string ketika mengkompilasi, ketika Phantom pertama kali diluncurkan, itu dikonversi ke objek biner persisten dari jenis bitmep, dan itu sudah digunakan kemudian setelah sejumlah reboot OS dan tidak memerlukan sumber asli.  Ini juga harus dilakukan dengan font, tetapi agak kurang umum.  Saat bekerja, font vektor dirender menjadi raster, dan perlu menyimpan raster yang di-render seperti itu.  Ini bukan trik atau masalah - mereka dapat dilipat lagi menjadi objek Phantom seperti bitmap, tetapi sudah ada beberapa jenis infrastruktur yang diperlukan - gaya font-style-style-style-size-glyph (kode UTF) glyph bitmap. <br><br>  Ini tidak terlalu sulit, tetapi, tampaknya, tugas dari tahap selanjutnya.  Sementara font-font dirasterisasi atas banding. <br><br><div class="spoiler">  <b class="spoiler_title">Dokumentasi</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kepala Dokumentasi</a> <br></div></div><br><h4>  Unicode </h4><br>  Merender font menurut definisi melibatkan bekerja dengan Unicode.  Ini, tentu saja, bagus, karena kita harus mulai kapan-kapan.  Bahkan, itu cukup untuk melengkapi penyaji dengan konverter dari UTF-8 ke UTF-32 (dan ini adalah nomor mesin terbang di font), unduh font dengan alfabet Cyrillic dan ini bagian dari pelokalan bekerja.  Apalagi jika kita menginginkan bahasa lain, maka perlu dan cukup untuk mengganti font.  Namun, font dasar yang dipilih mengandung banyak - untuk Eropa, pasti cukup.  Cina akan membutuhkan penggantian font, ya. <br><br><h4>  Bekerja dengan keyboard </h4><br>  Tidak ada tanda-tanda aksi militer sama sekali, tetapi, lebih dari harapan, saya harus berjuang.  Ternyata driver keyboard lama masih ... berharap untuk melihat perangkat keras dari IBM PC XT.  Ya, abad lalu.  Faktanya adalah bahwa pengontrol keyboard mampu (mampu!) Untuk mengubah kode pindai keyboard modern (yang disebut set kode kedua) menjadi yang kuno. <br><br>  Ternyata karena terlambat QEMU, pertobatan semacam itu, tampaknya, akhirnya dibuang.  Atau tanpa sengaja bangkrut.  Namun faktanya, pengemudi menolak bekerja.  Dengan kesedihan, selama satu jam, dengan bantuan beberapa ibu, aku mengantar pengemudi dari UOS yang ramah ke Phantom.  Hanya untuk mengetahui bahwa dia memiliki masalah yang sama.  Set pertama.  Saya harus menulis ulang tabel kode pindai dan pengurai.  Saya tidak kembali ke pengemudi lama, dan itulah sebabnya.  Ternyata driver dari uOS memiliki antarmuka yang lebih elegan ke sistem.  Yaitu, ia kembali ke sana bukan, seperti kebiasaan, sepasang (kode karakter, kode pemindaian tombol), tetapi satu karakter UTF-32 32-bit.  Ternyata di UTF ada rentang kode khusus yang dialokasikan untuk penggunaan lokal, dan itu lebih dari cukup untuk semua tombol fungsi yang mungkin.  Bekerja dengan aliran peristiwa dalam kode UI jauh lebih sederhana. <br><br>  Selain itu, lokalisasi jatuh sempurna pada model seperti itu.  Sudah cukup untuk overlay tabel ASCII-&gt; UTF32 untuk bahasa yang diinginkan (set karakter), dan sorakan - kita punya Cyrillic.  Yah - hampir sampai.  Sekarang akan perlu untuk transcode ke dalam UTF-8, atau untuk membuat ulang jeroan beberapa bagian UI ke UTF-32.  Saya juga telah menempatkan momen ini sebagai prioritas rendah. <br><br><h4>  Kontrol </h4><br><div class="spoiler">  <b class="spoiler_title">Dokumentasi</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab dalam dokumentasi</a> <br></div></div><br>  Tombol, radio, kotak centang, dan elemen UI spesifik lainnya. <br><br>  Infrastruktur umum meliputi: <br><br><ul><li>  Mekanisme untuk menyimpan kontrol terkait dengan jendela </li><li>  Elemen visualisasi kontrol tipikal - bingkai, latar belakang, teks, ikon, dll. </li><li>  Transmisi ke kontrol acara dan pola reaksi tipikal (push / toggle) </li><li>  Melacak kejadian mouse dan melayang-layang keadaan </li><li>  Panggilan balik dan pembuatan peristiwa sekunder untuk menginformasikan tentang perubahan status </li></ul><br><h4>  Kontrol fokus </h4><br>  Agar kontrol (tombol, misalnya) digunakan tanpa mouse, beberapa hal diperlukan. <br><br><ul><li>  Kemampuan untuk memilihnya dari keyboard </li><li>  Tampilkan pilihan ini </li><li>  Respons keyboard </li><li>  Deteksi kehilangan fokus. </li></ul><br>  Yang terakhir adalah yang paling sulit. <br><br>  Faktanya, kontrol fokus dengan keyboard dan mouse, dan ini adalah satu dan entitas yang sama - jika kita memilih bidang teks dengan mouse, itu akan merespon tombol.  Jika setelah itu Anda menekan TAB, hak untuk bekerja dengan keyboard akan beralih ke yang lain. <br><br>  Tugas terpisah adalah bahwa beberapa kontrol dapat dikelompokkan dan statusnya perlu diperbarui dengan cara yang terkait.  Menekan radiobathorn “memeras” tetangganya. <br><br>  Sekali lagi, kembali ke fakta bahwa kita sedang menulis OS yang persisten.  Ini berarti bahwa kontrol potensial dapat disimpan dalam RAM yang persisten dan selamat dari reboot sistem kernel. <br><br>  Artinya, hubungannya dengan nukleus akan baik untuk diminimalkan.  Setiap pointer ke memori non-persisten (sebenarnya ke kernel) setelah reboot akan tidak valid dan harus dikembalikan.  Ini berarti bahwa penunjuk seperti itu tidak memiliki hak untuk menyimpan informasi tentang status kontrol.  Posisi kursor sebagai bilangan bulat - ya.  Pointer ke buffer di kernel yang posisinya ditentukan oleh posisi kursor tidak.  Baik atau ya, hanya bilangan bulat yang masih ada dan itu lebih penting.  Ini dalam praktiknya tidak terlalu memberatkan, tetapi kita harus ingat. <br><br>  Akhirnya, bilah tugas.  Ini adalah hal semacam itu di bagian bawah (samping, atas) layar di mana pengguna menusuk jika ia kehilangan jendela. <br><br>  Pada prinsipnya, ini seharusnya sudah menjadi bagian dari tanah pengguna, tetapi ... kernel sudah aktif menggunakan GUI, jadi untuk saat ini bagian ini juga akan berada di bagian bawah.  Saya harap sementara. <br><br><h4>  Total </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/3f8/44b/5b4/3f844b5b46e9f0b52b782d891465246a.png" alt="gambar"><br><br>  Menurut pendapat saya, tugas-tugas yang ditetapkan ke arah ini secara umum telah diselesaikan.  Tentu saja, tidak ada batasan untuk kesempurnaan, tetapi, menurut saya, antarmuka telah mengambil langkah nyata dari peretas menjadi universal. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id472160/">https://habr.com/ru/post/id472160/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id472148/index.html">Retrogaming: PAL vs NTSC. Atau mengapa PAL tidak diperlukan</a></li>
<li><a href="../id472152/index.html">Menguji kode multithreaded dan asynchronous</a></li>
<li><a href="../id472154/index.html">Bagaimana tidak ketinggalan anggaran untuk produksi serial bangunan-2: harga untuk cetakan plastik skala kecil</a></li>
<li><a href="../id472156/index.html">Menerapkan pola Objek Halaman dalam Python + pytest</a></li>
<li><a href="../id472158/index.html">"Proses pendidikan di bidang TI dan bukan hanya": kontes teknologi dan acara Universitas ITMO</a></li>
<li><a href="../id472162/index.html">Pemasaran Email Outsourced: Cara Membangun dan Apa yang Diharapkan</a></li>
<li><a href="../id472168/index.html">Praktik menghibur untuk pengembang</a></li>
<li><a href="../id472170/index.html">Siapa yang menyarankan desentralisasi zona root DNS</a></li>
<li><a href="../id472172/index.html">Perancangan ulang situs web yang tepat - algoritme langkah demi langkah, pertanyaan dasar, dan nuansa</a></li>
<li><a href="../id472174/index.html">Kepribadian dan suara: Paul Voight - "Sennheiser 30s", ayah dari broadband, crossover mekanis dan jalur transmisi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>