<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≤üèΩ üë≤ üëÇüèΩ Comment installer un million d'√©toiles dans un iPhone üòß üë©üèª‚Äç‚öïÔ∏è ‚Ü©Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Une chose aussi romantique qu'un ciel √©toil√© et une chose aussi hardcore que l'optimisation de la consommation de m√©moire par une application iOS peuv...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment installer un million d'√©toiles dans un iPhone</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/427845/"><img src="https://habrastorage.org/webt/q7/xz/3_/q7xz3_mzwjft238rwmzhjpbnwqm.jpeg"><br><br>  Une chose aussi romantique qu'un ciel √©toil√© et une chose aussi hardcore que l'optimisation de la consommation de m√©moire par une application iOS peuvent bien aller de pair: cela vaut la peine d'essayer de pousser ce ciel √©toil√© dans une application AR, et la question de la m√™me consommation se posera imm√©diatement. <br><br>  Pour minimiser l'utilisation de la m√©moire sera utile dans de nombreux autres cas.  Donc, ce texte sur l'exemple d'un petit projet montre des m√©thodes d'optimisation qui peuvent √™tre utiles dans des applications iOS compl√®tement diff√©rentes (et pas seulement iOS-). <br><a name="habracut"></a><br>  Le message a √©t√© pr√©par√© sur la base d'une transcription du rapport de <b>Conrad Filer</b> de la conf√©rence Mobius 2018 Piter.  Nous attachons sa vid√©o, puis une version texte √† la premi√®re personne: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/51PJjrh9yTA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Heureux d'accueillir tout le monde!  Je m'appelle Conrad Filer, et sous le nom spectaculaire de ¬´Un million d'√©toiles dans un iPhone¬ª, nous verrons comment vous pouvez r√©duire la taille de la m√©moire occup√©e par votre application iOS.  Color√© et en exemples. <br><br><h2>  Pourquoi optimiser? </h2><br>  Qu'est-ce qui nous encourage g√©n√©ralement √† faire de l'optimisation, que souhaitons-nous exactement?  Nous ne voulons pas cela: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/54b/0ef/fbf/54b0effbffa93a27e65a50000242046d.gif"></div><br><br>  Nous ne voulons pas que l'utilisateur attende.  Autrement dit, la premi√®re raison est de <b>r√©duire le temps de d√©marrage</b> . <br><br>  Une autre raison est <b>d'am√©liorer la qualit√©</b> . <br><br><img src="https://habrastorage.org/webt/dj/6i/0w/dj6i0wxgzgv87xkdvnkiy6ddy48.jpeg"><br><br>  Nous pouvons parler de la qualit√© des images, du son et m√™me de l'IA.  ¬´AI optimis√©e¬ª signifie que vous pouvez en faire plus - par exemple, calculer le jeu pour un plus grand nombre de mouvements en avant. <br><br>  La troisi√®me raison est tr√®s importante: <b>√©conomiser la batterie</b> .  L'optimisation permet de d√©charger moins la batterie.  Voici une comparaison int√©ressante, quoique du monde Android.  Ici compar√© Vulkan et OpenGL ES: <br><br><img src="https://habrastorage.org/webt/9n/ni/dx/9nnidxssdqtw_t2ibkdatsaapfm.jpeg"><br><br>  Le second est pire optimis√© pour les plateformes mobiles.  En observant la vitesse de consommation d'√©nergie de la batterie, vous pouvez voir que pour une image similaire, OpenGL ES a d√©pens√© beaucoup plus de ressources que Vulkan. <br><br>  Quel type d'optimisation peut aider ici?  Par exemple, dans un jeu au tour par tour, lorsque l'utilisateur pense √† son coup, vous pouvez r√©duire le FPS √† z√©ro.  Si vous avez un moteur 3D, il est tout √† fait sage de tout d√©sactiver pendant que l'utilisateur regarde simplement l'√©cran. <br><br>  De plus, il y a des moments o√π, sans approche optimis√©e, vous ne pourrez pas impl√©menter l'une ou l'autre fonctionnalit√© avanc√©e: elle ne sera tout simplement pas tir√©e. <br><br><h2>  Pas de fanatisme </h2><br>  Parlant d'optimisation, on ne peut que rappeler la th√®se de Donald Knuth: ¬´Il faut oublier la faible efficacit√©, disons, dans 97% des cas: l'optimisation pr√©matur√©e est √† l'origine de tous les maux.  Bien que nous ne devrions pas abandonner nos capacit√©s dans ces 3% critiques. " <br><br>  Dans 97% des cas, nous ne devons pas nous soucier de l'efficacit√©, mais d'abord de la fa√ßon de rendre notre code compr√©hensible, s√ªr et testable.  Nous d√©veloppons toujours pour les appareils mobiles, et non pour les vaisseaux spatiaux.  Les entreprises dans lesquelles nous travaillons ne devraient pas payer trop cher pour le support du code que nous avons √©crit.  De plus, le temps de travail du d√©veloppeur a un co√ªt, et si vous le d√©pensez pour optimiser quelque chose de non essentiel, vous d√©pensez l'argent de l'entreprise.  Eh bien, le fait qu'un code bien optimis√© ait tendance √† √™tre plus difficile √† comprendre, vous pouvez le voir pour les exemples que je vais vous montrer aujourd'hui. <br><br>  En g√©n√©ral, hi√©rarchisez et optimisez de mani√®re significative au besoin. <br><br><h2>  Les approches </h2><br>  Lorsque nous travaillons sur l'optimisation, nous surveillons g√©n√©ralement les performances (lecture: charge du processeur) ou la quantit√© de m√©moire utilis√©e.  Souvent, ces deux options entrent en conflit et vous devrez trouver un √©quilibre entre elles. <br><br>  Dans le cas du processeur, nous pouvons r√©duire le nombre de cycles de processeur requis par nos op√©rations.  Comme vous le savez, moins de cycles de processeur nous donnent moins de temps de chargement, moins de consommation de batterie, la capacit√© de fournir une meilleure qualit√©, etc. <br><br>  Pour les d√©veloppeurs iOS, Xcode Instruments dispose d'un outil Time Profiler pratique.  Il vous permet de suivre le nombre de cycles CPU d√©pens√©s par diff√©rentes parties de votre application.  Ce rapport ne concerne pas les outils, donc je ne vais pas entrer dans les d√©tails maintenant, il y avait une bonne vid√©o de la WWDC √† ce sujet. <br><br>  Vous pouvez choisir un autre objectif - l'optimisation pour la m√©moire.  Nous essaierons de nous assurer qu'au d√©marrage, notre application tient dans le plus petit nombre possible de cellules RAM.  N'oubliez pas que les applications les plus volumineuses sont les premiers candidats √† un arr√™t forc√© lors du nettoyage, que l'OS est oblig√© de r√©aliser.  Par cons√©quent, cela affecte la dur√©e pendant laquelle votre application reste en arri√®re-plan. <br><br>  Il est √©galement important que la ressource RAM pour diff√©rents appareils soit √©galement diff√©rente.  Par exemple, si vous d√©cidez de d√©velopper pour Apple Watch, la m√©moire est insuffisante, ce qui vous permet √©galement d'optimiser. <br><br>  Enfin, parfois une petite quantit√© de m√©moire rend √©galement le programme tr√®s rapide.  Je vais vous donner un exemple.  Voici les structures de diff√©rentes tailles en octets: <br><br><img src="https://habrastorage.org/webt/mg/2c/_2/mg2c_2se8rpo_gwwnqlfbcaf2ks.jpeg"><br><br>  Element8 contient 8 octets, Element16 - 16, etc. <br><br><img src="https://habrastorage.org/webt/ot/hq/l3/othql3uj6cujllgs99m_ypmkok8.jpeg"><br><br>  Nous allons cr√©er des tableaux, un pour chacun de nos types de structures.  La dimension de tous les tableaux est la m√™me - 10 000 √©l√©ments.  Chaque structure contient un nombre diff√©rent de champs (croissant);  le champ n est le premier champ et, par cons√©quent, il est pr√©sent dans toutes les structures. <br><br>  Essayons maintenant ce qui suit: pour chaque tableau, nous calculerons la somme de tous ses champs n.  Autrement dit, √† chaque fois, nous additionnerons le m√™me nombre d'√©l√©ments (10 000 pi√®ces).  La seule diff√©rence est que pour chaque somme la variable n sera extraite de structures de tailles diff√©rentes.  Nous voulons savoir si la sommation prend le m√™me temps. <br><br>  Le r√©sultat est le suivant: <br><br><img src="https://habrastorage.org/webt/el/mu/k1/elmuk1tm_yaku9exe4xgbaw8gp4.jpeg"><br><br>  Le graphique montre la d√©pendance du temps de sommation √† la taille de la structure utilis√©e dans le tableau.  Il s'av√®re que l'obtention du champ n √† partir d'une structure plus grande est plus longue, et donc l'op√©ration de sommation prend plus de temps. <br>  Beaucoup d'entre vous ont d√©j√† compris pourquoi cela se produit. <br><br>  Le processeur a des caches L1, L2 (parfois m√™me L3 et L4).  Le processeur acc√®de √† ce type de m√©moire directement et rapidement. <br><br><img src="https://habrastorage.org/webt/u1/yy/r9/u1yyr9z2pxbwcffecy8i_xoa5qq.jpeg"><br><br>  Des caches existent pour acc√©l√©rer la r√©utilisation des donn√©es.  Supposons que nous travaillons avec des tableaux.  Si la baie requise par le processeur est d√©j√† pr√©sente dans l'un des caches, elle √©tait d√©j√† requise par le processeur plus t√¥t.  √Ä ce moment, il les a demand√©s √† la m√©moire principale, les a plac√©s dans le cache, a effectu√© toutes les op√©rations n√©cessaires avec eux, apr√®s quoi ces donn√©es sont rest√©es mensong√®res (ils n'ont pas eu le temps d'effacer les autres). <br><br><img src="https://habrastorage.org/webt/qt/cd/om/qtcdomuam8uo4cz2tnkevtmvxuk.jpeg"><br><br>  Les tailles des caches L1, L2 ne sont pas si grandes.  La baie dont le processeur a besoin pour fonctionner peut √™tre plus grande.  Afin d'effectuer pleinement l'op√©ration sur un tel tableau, nous devrons le d√©charger dans le cache en plusieurs parties et op√©rer sur ces parties une par une.  En raison de demandes constantes √† la m√©moire principale, le traitement de notre baie prendra beaucoup plus de temps. <br><br>  Lors de la programmation des structures de donn√©es, essayez de garder √† l'esprit les caches.  Il est possible qu'en r√©duisant la taille de votre structure de donn√©es, vous atteigniez sa capacit√© de cache r√©ussie et acc√©l√©rerez les op√©rations qui seront effectu√©es sur elle √† l'avenir.  L'interaction avec la m√©moire principale a toujours √©t√©, est et restera probablement un facteur important de productivit√© - m√™me lorsque vous √©crivez sur Swift pour des appareils modernes hautes performances. <br><br><h2>  CPU vs RAM: initialisation paresseuse </h2><br>  Bien que dans certains cas, lorsque la m√©moire utilis√©e est r√©duite, le programme commence √† fonctionner plus rapidement, il existe des cas o√π ces deux mesures, au contraire, sont en conflit.  Je vais donner un exemple avec le concept d'initialisation paresseuse. <br><br>  Supposons que nous ayons une m√©thode makeHeavyObject () qui retourne un gros objet.  Cette m√©thode initialise la variable lazilyCalculated. <br><br><img src="https://habrastorage.org/webt/-y/2v/4l/-y2v4lzluwid2sxmelau-qp9yiu.jpeg"><br><br>  Le modificateur paresseux d√©finit la variable lazilyCalculated sur l'initialisation paresseuse.  Cela signifie qu'une valeur ne lui sera affect√©e que lors du premier appel √† celle-ci lors de l'ex√©cution.  C'est alors que la m√©thode makeHeavyObject () fonctionnera et que l'objet r√©sultant sera assign√© √† la variable lazilyCalculated. <br><br>  Quel est le plus ici?  D√®s le moment de l'initialisation (quoique plus tard, mais il sera ex√©cut√©), nous avons un objet situ√© en m√©moire.  Sa valeur est compt√©e, il est pr√™t √† l'emploi - il suffit de faire une demande.  Une autre chose est que notre objet est grand et d√®s l'instant de l'initialisation occupera en m√©moire sa part du lion de cellules. <br><br>  Vous pouvez aller dans l'autre sens - ne stockez pas du tout la valeur du champ: <br><br><img src="https://habrastorage.org/webt/rd/dj/td/rddjtdebqiiyidg1vravbwzreli.jpeg"><br><br>  Avec chaque lien vers le champ lazilyCalculated, la m√©thode makeHeavyObject () sera √† nouveau ex√©cut√©e.  La valeur sera renvoy√©e au point de requ√™te, alors qu'elle ne sera pas plac√©e en m√©moire.  Comme vous pouvez le voir, le stockage d'une variable est facultatif. <br><br>  Quoi de plus cher - pour stocker un grand objet en m√©moire, mais pas pour perdre du temps CPU, ou pour appeler la m√©thode √† chaque fois que nous avons besoin de notre champ, tout en √©conomisant de la m√©moire?  Devriez-vous avoir une valeur pr√™te √† l'emploi ou la calculer √† la vol√©e?  Ce genre de dilemme survient assez souvent, o√π que vous effectuiez vos calculs - sur un serveur distant ou sur votre machine locale, quel que soit le cache avec lequel vous devez travailler.  Vous devez prendre une d√©cision en fonction des limites du syst√®me dans ce cas particulier. <br><br><h2>  Cycle d'optimisation </h2><br><br><img src="https://habrastorage.org/webt/3y/jb/tz/3yjbtzvba5c5cmvdmyxws4ubev8.jpeg"><br><br>  Quoi que vous optimisiez, votre travail, en r√®gle g√©n√©rale, sera construit sur le m√™me algorithme.  Tout d'abord, vous examinez le code, le profil / la mesure (dans Xcode en utilisant les outils appropri√©s), en essayant d'identifier ses goulots d'√©tranglement.  Essentiellement, organisez les m√©thodes en fonction de leur dur√©e d'ex√©cution.  Et puis regardez les premi√®res lignes pour d√©terminer ce qu'il faut optimiser. <br><br>  En choisissant un objet, vous vous fixez la t√¢che (ou, en parlant scientifiquement, vous √©mettez une hypoth√®se): en appliquant ces m√©thodes d'optimisation ou d'autres, vous pouvez acc√©l√©rer le travail du morceau de code s√©lectionn√©. <br><br>  Ensuite, vous essayez d'optimiser.  Apr√®s chaque modification, vous examinez les indicateurs de performance, √©valuant l'efficacit√© de la modification, combien vous avez r√©ussi √† avancer. <br><br>  Tout comme dans un travail scientifique: sp√©culation, exp√©rience, analyse des r√©sultats.  Vous passez ce cycle d'actions encore et encore.  La pratique montre que le travail ainsi construit vous permet d'√©liminer les botneks un par un. <br><br><h2>  Tests unitaires </h2><br><br><img src="https://habrastorage.org/webt/yp/c3/zl/ypc3zlrxtbnbkp9cwekladdj-ug.jpeg"><br><br>  En bref sur les tests unitaires: nous avons une fonction que nous testons, une entr√©e de donn√©es d'entr√©e et une sortie de donn√©es de sortie;  en recevant une entr√©e en entr√©e, notre fonction doit toujours renvoyer une sortie, et aucune de nos optimisations ne doit violer cette propri√©t√©. <br><br>  Les tests unitaires nous aident √† suivre la panne.  Si, en r√©ponse √† l'entr√©e, notre fonction a cess√© de renvoyer la sortie, alors, directement ou indirectement, nous avons chang√© l'ancien mode de fonctionnement de notre fonction. <br><br>  N'essayez m√™me pas de commencer √† optimiser si vous n'avez pas √©crit une g√©n√©reuse portion de tests unitaires dans votre code.  Vous devriez pouvoir effectuer un test de r√©gression.  Si vous regardez GitHub my commits dans mon exemple d'application, que je vais poursuivre, vous pouvez voir que certaines de mes optimisations ont apport√© des bogues avec elles. <br><br>  Et maintenant, pour la partie amusante, passons aux √©toiles. <br><br><h2>  Million d'√©toiles </h2><br>  Il existe une grande (√©norme) base de donn√©es d√©crivant un million d'√©toiles.  En plus, j'ai cr√©√© plusieurs applications.  L‚Äôun d‚Äôeux utilise la r√©alit√© augment√©e, en dessinant en temps r√©el des √©toiles sur l‚Äôimage de l‚Äôappareil photo du t√©l√©phone.  Je vais maintenant le d√©montrer en action: <br><br><img src="https://habrastorage.org/webt/cr/rs/jv/crrsjv1iezyd2hzyxdxpjricu0u.png"><br><br>  En l'absence de lumi√®res de la ville, une personne peut distinguer jusqu'√† 8 000 √©toiles dans le ciel.  J'aurais besoin d'environ 1,8 Mo pour stocker 8 000 enregistrements.  En principe, acceptable.  Mais je voulais ajouter ces √©toiles qu'une personne peut voir √† travers un t√©lescope - il s'est av√©r√© environ 120 000 √©toiles (selon le soi-disant catalogue Hipparcos, d√©sormais obsol√®te).  Cela n√©cessitait d√©j√† 27 Mo.  Et parmi les catalogues modernes du domaine public, vous pouvez en trouver un qui comptera environ 2 500 000 √©toiles.  Une telle base de donn√©es occuperait d√©j√† environ 560 Mo.  Comme vous pouvez le voir, beaucoup de m√©moire est d√©j√† requise.  Mais nous ne voulons pas seulement une base de donn√©es, mais une application bas√©e sur elle, o√π il y aura ARKit, SceneKit et d'autres choses qui n√©cessitent √©galement de la m√©moire. <br><br>  Que faire? <br>  Nous optimiserons les √©toiles. <br><br><h2>  Outil MemoryLayout </h2><br>  Vous pouvez √©valuer la taille du programme dans son ensemble.  Mais pour les travaux de bijouterie tels que l'optimisation, vous aurez besoin d'outils pour estimer la taille de chaque structure de donn√©es individuelle. <br><br>  Swift vous permet de le faire tr√®s simplement - en utilisant des objets MemoryLayout &lt;&gt;.  Vous d√©clarez un MemoryLayout &lt;&gt;, sp√©cifiant la structure de donn√©es qui vous int√©resse en tant que type g√©n√©rique.  Maintenant, en vous r√©f√©rant aux propri√©t√©s de l'objet re√ßu, vous pouvez recevoir une vari√©t√© d'informations utiles sur votre structure. <br><br><img src="https://habrastorage.org/webt/4b/dy/ki/4bdykiugciapow4d-avqvmfhp7e.jpeg"><br><br>  La propri√©t√© size nous donne le nombre d'octets occup√©s par une instance de la structure. <br>  Maintenant sur la propri√©t√© stride.  Vous avez peut-√™tre remarqu√© que la taille du tableau, en r√®gle g√©n√©rale, n'est pas √©gale √† la somme des tailles de ses √©l√©ments constitutifs, mais la d√©passe.  De toute √©vidence, un peu ¬´d'air¬ª est laiss√© entre les √©l√©ments de la m√©moire.  Pour estimer la distance entre des √©l√©ments cons√©cutifs dans un tableau adjacent, nous utilisons la propri√©t√© stride.  Si vous le multipliez par le nombre d'√©l√©ments dans le tableau, vous obtenez sa taille. <br><br><img src="https://habrastorage.org/webt/vo/9x/6i/vo9x6ivnzz5-nzdhowe4cvtox3u.jpeg"><br><br>  StarData, notre structure exp√©rimentale, dans son √©tat initial non optimis√©: <br><br><img src="https://habrastorage.org/webt/no/ku/51/noku51vmtamzm8yk1cclohg1-ea.jpeg"><br><br>  Voici une structure de donn√©es con√ßue pour stocker des donn√©es sur une √©toile.  Il n'est pas n√©cessaire de se pencher sur la signification de chacun de ces √©l√©ments.  Il est plus important maintenant de faire attention aux types: variables flottantes stockant les coordonn√©es de l'√©toile (en fait, latitude et longitude), plusieurs Int32 pour diff√©rents ID, cha√Æne pour stocker les noms et les noms de diverses classifications;  il y a une distance, une couleur et quelques autres quantit√©s n√©cessaires pour l'affichage correct d'une √©toile. <br><br>  Nous demandons la propri√©t√© stride: <br><br><img src="https://habrastorage.org/webt/ob/pu/l-/obpul-qs28mwnfqhfnay3b5ml-m.jpeg"><br><br>  √Ä l'heure actuelle, notre structure p√®se 208 octets.  Un million de ces structures n√©cessiteront 250 Mo - c'est, comme vous le savez, c'est trop.  Par cons√©quent, il est n√©cessaire d'optimiser. <br><br><h2>  Correct int </h2><br>  Le fait qu'il existe diff√©rentes vari√©t√©s d'Int est expliqu√© dans les premi√®res le√ßons de programmation.  L'Int le plus familier pour nous dans Swift s'appelle Int8.  Il occupe 8 bits (1 octet) et peut stocker des valeurs de -128 √† 127 inclus.  Il existe √©galement d'autres Ints: <br><ul><li>  Int16 d'une taille de 2 octets, la plage de valeurs va de -32 768 √† 32 767; </li><li>  Int32 d'une taille de 4 octets, la plage de valeurs va de -2 147 483 648 √† 2 147 483 647; </li><li>  Int64 (ou juste Int) a une taille de 8 octets, la plage de valeurs va de -9,223,372,036,854,775,808 √† 9,223,372,036,854,775,807. </li></ul><br><br>  Probablement ceux d'entre vous qui √©taient engag√©s dans le d√©veloppement Web et qui s'occupaient de SQL y r√©fl√©chissent d√©j√†.  Mais oui, tout d'abord, choisissez l'Int optimal.  Dans ce projet, avant m√™me d'avoir pens√© √† l'optimisation, je me suis lanc√© dans une optimisation pr√©matur√©e (ce qui, comme je viens de vous le dire, n'est pas n√©cessaire). <br><br>  Regardons, par exemple, les champs avec ID.  Nous savons que nous aurons environ un million d'√©toiles - pas quelques dizaines de milliers, mais pas un milliard.  Ainsi, pour de tels champs, il est pr√©f√©rable de choisir Int32.  Ensuite, j'ai r√©alis√© que 4 octets suffisent pour Float ici.  Double occupera 8, cha√Æne de 24 chacun, ajoutez tout - il s'av√®re 152 octets.  Si vous vous en souvenez, MemoryLayout nous a dit plus t√¥t que 208. Pourquoi?  Nous devons creuser plus profond√©ment. <br><br><img src="https://habrastorage.org/webt/ss/pd/-d/sspd-d52ece7xuninv1aivvbapi.jpeg"><br><br>  Tout d'abord, regardons Facultatif.  Les types facultatifs diff√®rent par le fait qu'en l'absence de valeur affect√©e, ils stockent z√©ro.  Cela garantit la s√©curit√© dans l'interaction avec les objets.  Mais comme vous le savez, une telle mesure ne co√ªte pas cher: en demandant la propri√©t√© size de tout type facultatif, vous verrez qu'un tel type prend toujours un octet de plus.  Nous payons pour la possibilit√© de vous inscrire au champ nul. <br><br>  Nous ne voudrions pas d√©penser un octet suppl√©mentaire sur une variable.  En m√™me temps, nous aimons vraiment l'id√©e incarn√©e en option.  Que proposer?  Essayons de mettre en ≈ìuvre notre structure. <br><br>  Choisissons une valeur qui peut raisonnablement √™tre consid√©r√©e comme ¬´non valide¬ª pour un champ donn√©, tout en convenant au type d√©clar√©.  Pour getHipId (Int32), il peut s'agir, par exemple, de la valeur "-1".  Cela signifiera que notre champ n'est pas initialis√©.  Voici un tel v√©lo en option, qui se passe d'un octet suppl√©mentaire sur z√©ro. <br><br>  De toute √©vidence, avec une telle astuce, nous avons √©galement une vuln√©rabilit√© potentielle.  Pour nous prot√©ger des erreurs, nous allons cr√©er un getter pour le champ, qui g√©rera ind√©pendamment notre nouvelle logique et v√©rifiera la validit√© du champ. <br><br><img src="https://habrastorage.org/webt/f8/_7/ar/f8_7ar0uns7lzeude7do0avszaw.jpeg"><br><br>  Un tel getter nous fait compl√®tement abstraction de la complexit√© d'une solution invent√©e. <br>  Tournez-vous vers nos StarData.  Remplacez tous les types facultatifs par des types r√©guliers et voyez ce que la foul√©e montre: <br><br><img src="https://habrastorage.org/webt/bw/v4/rf/bwv4rfqgdjkyle-jziflwtbdgjq.jpeg"><br>  Il s'av√®re qu'en √©liminant les options, nous avons √©conomis√© non pas 9 octets (un octet pour chacune des neuf options), mais jusqu'√† 48. La surprise est agr√©able, mais j'aimerais savoir pourquoi cela s'est produit.  Et c'est arriv√© √† cause de l'alignement des donn√©es en m√©moire. <br><br><h2>  Alignement des donn√©es </h2><br>  Rappelons qu'avant Swift, nous √©crivions dans Objective-C, et c'√©tait bas√© sur C - et cette situation remonte √©galement √† C. <br><br>  En pla√ßant des structures en m√©moire, les processeurs modernes placent leurs √©l√©ments non pas dans un flux continu (pas ¬´√©paule contre √©paule¬ª), mais dans une grille amincie de fa√ßon inhomog√®ne par des vides.  C'est l'alignement des donn√©es.  Il vous permet de simplifier et d'acc√©l√©rer l'acc√®s aux √©l√©ments de donn√©es n√©cessaires en m√©moire. <br>  Les r√®gles d'alignement des donn√©es s'appliquent √† chaque variable selon son type: <br><br><ul><li>  une variable de type char peut commencer √† partir des 1er, 2e, 3e, 4e, etc.  octets, car il ne prend qu'un seul octet en soi; </li><li>  une variable courte prend 2 octets, elle peut donc commencer √† partir du 2√®me, 4√®me, 6√®me, 8√®me, etc.  un octet (c'est-√†-dire de chaque octet pair); </li><li>  une variable de type float prend 4 octets, ce qui signifie qu'elle peut commencer tous les 4, 8, 12, 16, etc.  un octet (c'est-√†-dire tous les quatre octets); </li><li>  les variables de type Double et String occupent chacune 8 octets, elles peuvent donc commencer par les 8e, 16e, 24e, 32e, etc.  octets </li><li>  etc. </li></ul><br><br>  Les objets MemoryLayout &lt;&gt; ont une propri√©t√© d'alignement qui renvoie la r√®gle d'alignement correspondante pour le type sp√©cifi√©. <br><br>  Pourrions-nous appliquer la connaissance des r√®gles d'alignement pour optimiser le code?  Regardons un exemple.  Il existe une structure utilisateur: pour firstName et lastName, nous utilisons une cha√Æne r√©guli√®re, pour middleName - une cha√Æne facultative (l'utilisateur peut ne pas avoir un tel nom).  En m√©moire, une instance d'une telle structure sera plac√©e comme suit: <br><br><img src="https://habrastorage.org/webt/ah/2y/iz/ah2yizmjxwar-9d6gycudjcspv0.jpeg"><br><br>  Comme vous pouvez le voir, puisque le middleName facultatif prend 25 octets (au lieu de multiples de 8 24 octets), les r√®gles d'alignement vous obligent √† ignorer les 7 octets suivants et √† d√©penser 80 octets sur toute la structure.  Ici, peu importe comment vous √©changez des blocs avec des cha√Ænes, il est impossible de compter sur un plus petit nombre d'octets. <br><br>  Et maintenant un exemple d'alignement √©chou√©: <br><br><img src="https://habrastorage.org/webt/ea/ag/ch/eaagch2qax-7hpbvfbvrbkd4xog.jpeg"><br><br>  BadAligned   isHidden  Bool (1 ),  size  Double (8 ), isInteractable  bool (1 )   age  Int ( 8 ).    ,        ,     32 . <br><br>      ‚Äî         ,     . <br><br><img src="https://habrastorage.org/webt/qt/de/mw/qtdemwpwvb_tvkd-gnhmx1pfnbm.jpeg"><br><br>     32 ,  24.   25%. <br><br>     ,  ?    Swift   C ‚Äî  .       ,       ,   ,   .           ‚Äî  -   . <br><br>     StarData.         . <br><br><img src="https://habrastorage.org/webt/4r/jj/po/4rjjpozl7hnmfcnx9yb_e4q66xm.jpeg"><br><br>  Float  Int32,   Double  String.      ! <br>   stride  152 .  ,       ,       208  152 . <br><br>        ? ,  .    -,       ‚Äî -   ,       . <br><br><h2>    </h2><br>    ,     .     :    FPS,       ‚Äî         . <br><br>    StarData.   ¬´ ¬ª ‚Äî   String,      .     :        !    146   ¬´¬ª ,     properName.  gl_id ‚Äî ID      ,   3801 ,    . bayer_flamstedt ‚Äî   ‚Äî   3064- .   spectralType ‚Äî 4307-. ,         ,     24  . <br><br>      .       .    ‚Äî     Int16,   ,     - ‚Äî   ,  -1. <br><br>   StarData  properName, gl_id, bayer_flamstedt  spectralType   ,    .       -,       .     ‚Äî     : <br><br><img src="https://habrastorage.org/webt/n7/i5/bi/n7i5bilqodef52ninsnoilrneci.jpeg"><br><br>     ‚Äî       .      private,      . <br><br> ,      .         .            ;     ‚Äî ,           ¬´-1¬ª. <br><br>        .               ‚Äî             . <br><br>    ,  ,          .      .     unit- ‚Äî ,          . <br><br> : stride    64 ! <br><br>   ? ,       :    Int16 . <br><br><img src="https://habrastorage.org/webt/qs/yh/hs/qsyhhsoleaji_jnucoeew5fjguq.jpeg"><br><br>   .  ,               StarData  208  56 .      500 ,  130.    ! <br><br>      .     User    - 20 ,     ,      .  ,         . ,    ¬´    ,      ¬ª!      . ,     ‚Äî  ,  ,   . <br><br><h2>   Swift </h2><br>       ( )  .        ,      ,    . <br><br>      -     .    ,      . <br><br>      Xcode.       : <br><br><img src="https://habrastorage.org/webt/1x/36/j6/1x36j61elqsczwzbjldxjmdewtq.jpeg"><br><br>   ,  xCode           culprits.txt.    . <br><br><img src="https://habrastorage.org/webt/zz/ht/rp/zzhtrpbqbipvucqydinougkyzhu.jpeg"><br><br>    ,     .       2 ,       .    ? <br><br>  ,  ,    .      ,  Swift    .   ( , )    , ,    ,    .     ,         5  2 (!) . <br><br>    ¬´¬ª:      .        .    :        . <br><br><h2>   </h2><br>            .             Swift.    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   GitHub</a> .  API-,           .          ,      ARkit.           :      500 ,         Bluemix.  ,      . <br><br><h2>   </h2><br>  ,    ,      : <br><br><ul><li>       .      .      ,          ,     ,           ? </li><li>    ,     unit-. ,          unit-.    ,          . Unit-    ,     . </li><li>   .      ,        .   ,   :   ‚Äî  . </li><li>      .         .   ,    ‚Äî   ,   ¬´¬ª . </li><li> RAM vs. CPU.           .     ,           . </li></ul><br><br><blockquote>        Mobius ‚Äî  ,  8-9   <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mobius 2018 Moscow</a></b> ,     .  1    ,       ! </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr427845/">https://habr.com/ru/post/fr427845/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr427833/index.html">Rapport de la conf√©rence Joker 2018</a></li>
<li><a href="../fr427837/index.html">Les premiers jours dans l'√©quipe de d√©veloppement - comme cela arrive avec nous</a></li>
<li><a href="../fr427839/index.html">Autorisation utilisateur dans Django via GSSAPI et d√©l√©gation de droits utilisateur au serveur</a></li>
<li><a href="../fr427841/index.html">Escroquerie Magic Leap</a></li>
<li><a href="../fr427843/index.html">Comment bien dormir et bien dormir</a></li>
<li><a href="../fr427847/index.html">Curiosit√© et procrastination dans l'apprentissage automatique</a></li>
<li><a href="../fr427849/index.html">Ligne droite avec TM. v3.0</a></li>
<li><a href="../fr427853/index.html">R√©flexions sur TDD. Pourquoi cette m√©thodologie n'est pas largement reconnue</a></li>
<li><a href="../fr427855/index.html">Mitaps MOSDROID dans FunCorp</a></li>
<li><a href="../fr427857/index.html">Questions fiscales et juridiques pour les pigistes d√©butants</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>