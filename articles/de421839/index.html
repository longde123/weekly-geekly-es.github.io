<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗓️ 🕺🏿 👚 Funktionale Java-Programmierung mit Vavr 🤙🏼 👇🏾 🤴🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Viele haben von funktionalen Sprachen wie Haskell und Clojure gehört. Aber es gibt zum Beispiel Sprachen wie Scala. Es kombiniert sowohl OOP als auch ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funktionale Java-Programmierung mit Vavr</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421839/">  Viele haben von funktionalen Sprachen wie Haskell und Clojure gehört.  Aber es gibt zum Beispiel Sprachen wie Scala.  Es kombiniert sowohl OOP als auch einen funktionalen Ansatz.  Was ist mit dem guten alten Java?  Ist es möglich, Programme in einem funktionalen Stil darauf zu schreiben und wie sehr kann es weh tun?  Ja, es gibt Java 8 und Lambdas mit Streams.  Dies ist ein großer Schritt für die Sprache, aber es reicht immer noch nicht aus.  Ist es in dieser Situation möglich, sich etwas auszudenken?  Es stellt sich ja heraus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/u2/tp/cr/u2tpcrdrjmcmw9yvj9ptnbsuiwo.jpeg"></div><br><a name="habracut"></a><br>  Lassen Sie uns zunächst herausfinden, was das Schreiben von Code in einem funktionalen Stil bedeutet.  Erstens müssen wir nicht mit Variablen und Manipulationen mit ihnen arbeiten, sondern mit Ketten einiger Berechnungen.  Im Wesentlichen eine Folge von Funktionen.  Außerdem müssen wir spezielle Datenstrukturen haben.  Beispielsweise sind Standard-Java-Sammlungen nicht geeignet.  Es wird bald klar, warum. <br><br>  Betrachten wir funktionale Strukturen genauer.  Eine solche Struktur muss mindestens zwei Bedingungen erfüllen: <br><br><ul><li>  <b><i>unveränderlich</i></b> - die Struktur muss unveränderlich sein.  Dies bedeutet, dass wir den Zustand des Objekts im Stadium der Schöpfung festlegen und es als solches bis zum Ende seiner Existenz belassen.  Ein klares Beispiel für eine Bedingungsverletzung: Standard ArrayList. </li><li>  <b>persistent</b> - Die Struktur sollte so lange wie möglich im Speicher gespeichert werden.  Wenn wir ein Objekt erstellt haben, sollten wir anstelle eines neuen Objekts mit demselben Status das fertige verwenden.  Formal behalten solche Strukturen bei Modifikation alle ihre vorherigen Zustände bei.  Verweise auf diese Bedingungen müssen voll funktionsfähig bleiben. </li></ul><br>  Offensichtlich brauchen wir eine Lösung von Drittanbietern.  Und es gibt eine solche Lösung: die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vavr-</a> Bibliothek.  Heute ist es die beliebteste <i>Java-</i> Bibliothek für die Arbeit in einem funktionalen Stil.  Als nächstes werde ich die Hauptfunktionen der Bibliothek beschreiben.  Viele, aber keineswegs alle Beispiele und Beschreibungen wurden der offiziellen Dokumentation entnommen. <br><br><h2>  Die wichtigsten Datenstrukturen der <b>vavr-</b> Bibliothek </h2><br><h3>  Tupel </h3><br>  Eine der grundlegendsten und einfachsten funktionalen Datenstrukturen sind Tupel.  Ein Tupel ist ein geordneter Satz fester Länge.  Im Gegensatz zu Listen kann ein Tupel Daten eines beliebigen Typs enthalten. <br><br><pre><code class="java hljs">Tuple tuple = Tuple.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"blablabla"</span></span>, .<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">42L</span></span>); <span class="hljs-comment"><span class="hljs-comment">// (1, blablabla, 0.0, 42)</span></span></code> </pre> <br>  Das Abrufen des gewünschten Elements erfolgt durch Aufrufen des Felds mit der Artikelnummer im Tupel. <br><br><pre> <code class="java hljs">((Tuple4) tuple)._1 <span class="hljs-comment"><span class="hljs-comment">// 1</span></span></code> </pre> <br>  Bitte beachten Sie: Die Tupelindizierung beginnt bei 1!  Um das gewünschte Element zu erhalten, müssen wir unser Objekt mit den entsprechenden Methoden in den gewünschten Typ konvertieren.  Im obigen Beispiel haben wir ein Tupel mit 4 Elementen verwendet, was bedeutet, dass die Konvertierung vom Typ <i>Tuple4 sein muss</i> .  Tatsächlich hindert uns niemand daran, zunächst den richtigen Typ herzustellen. <br><br><pre> <code class="java hljs">Tuple4 tuple = Tuple.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"blablabla"</span></span>, .<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">42L</span></span>); <span class="hljs-comment"><span class="hljs-comment">// (1, blablabla, 0.0, 42) System.out.println(tuple._1); // 1</span></span></code> </pre> <br><h3>  Top 3 vavr Sammlungen </h3><br><h4>  Liste </h4><br>  Das Erstellen einer Liste mit vavr ist sehr einfach.  Noch einfacher als ohne <i>vavr</i> . <br><br><pre> <code class="java hljs">List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br>  Was können wir mit einer solchen Liste machen?  Nun, erstens können wir daraus eine Standard- <i>Java-</i> Liste machen. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> containThree = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) .asJava() .stream() .anyMatch(x -&gt; x == <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre><br>  Tatsächlich ist dies jedoch nicht sehr notwendig, da  Wir können zum Beispiel so vorgehen: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> containThree = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) .find(x -&gt; x == <span class="hljs-number"><span class="hljs-number">1</span></span>) .isDefined();</code> </pre> <br>  Im Allgemeinen enthält die Standardliste der <i>vavr-</i> Bibliothek viele nützliche Methoden.  Zum Beispiel gibt es eine ziemlich leistungsfähige Faltungsfunktion, mit der Sie eine Liste von Werten nach einer Regel und einem neutralen Element kombinieren können. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   final int zero = 0; //   final BiFunction&lt;Integer, Integer, Integer&gt; combine = (x, y) -&gt; x + y; //   final int sum = List.of(1, 2, 3) .fold(zero, combine); //  </span></span></code> </pre> <br>  Ein wichtiger Punkt sollte hier beachtet werden.  Wir haben funktionale Datenstrukturen, was bedeutet, dass wir ihren Zustand nicht ändern können.  Wie wird unsere Liste umgesetzt?  Arrays passen einfach nicht zu uns. <br><br>  <b>Verknüpfte Liste als Standardliste</b> <br><br>  Lassen Sie uns eine einfach verknüpfte Liste mit unveränderlichen Objekten erstellen.  Es wird ungefähr so ​​aussehen: <br><br><img src="https://habrastorage.org/webt/lr/4p/xn/lr4pxnezcvipnsgaownffgw6ewq.png" alt="Bild"><br><br><div class="spoiler">  <b class="spoiler_title">Codebeispiel</b> <div class="spoiler_text"><pre> <code class="java hljs">List list = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br></div></div><br>  Jedes Element der Liste hat zwei Hauptmethoden: Erhalten des Kopfelements (Kopf) und aller anderen (Schwanz). <br><br><div class="spoiler">  <b class="spoiler_title">Codebeispiel</b> <div class="spoiler_text"><pre> <code class="java hljs">list.head(); <span class="hljs-comment"><span class="hljs-comment">// 1 list.tail(); // List(2, 3)</span></span></code> </pre> <br></div></div><br>  Wenn wir nun das erste Element in der Liste ändern möchten (von 1 auf 0), müssen wir eine neue Liste mit der Wiederverwendung der fertigen Teile erstellen. <br><br><img src="https://habrastorage.org/webt/hu/xc/lp/huxclpxqlaunelfqyqu259ayj9o.png" alt="Bild"><br><div class="spoiler">  <b class="spoiler_title">Codebeispiel</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List tailList = list.tail(); <span class="hljs-comment"><span class="hljs-comment">//    tailList.prepend(0); //     </span></span></code> </pre> <br></div></div><br>  Und alle!  Da unsere Objekte im Arbeitsblatt unveränderlich sind, erhalten wir eine thread-sichere und wiederverwendbare Sammlung.  Elemente unserer Liste können überall in der Anwendung angewendet werden und sind absolut sicher! <br><br><h4>  Warteschlange </h4><br>  Eine weitere äußerst nützliche Datenstruktur ist die Warteschlange.  Wie erstelle ich eine Warteschlange, um effektive und zuverlässige Programme in einem funktionalen Stil zu erstellen?  Zum Beispiel können wir Datenstrukturen nehmen, die uns bereits bekannt sind: zwei Listen und ein Tupel. <br><br><img src="https://habrastorage.org/webt/bi/bp/sb/bibpsbx_odpxx2kdupxg0l4ufku.png" alt="Bild"><br><br><div class="spoiler">  <b class="spoiler_title">Codebeispiel</b> <div class="spoiler_text"><pre> <code class="java hljs">Queue&lt;Integer&gt; queue = Queue.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) .enqueue(<span class="hljs-number"><span class="hljs-number">4</span></span>) .enqueue(<span class="hljs-number"><span class="hljs-number">5</span></span>);</code> </pre> <br></div></div><br>  Wenn der erste endet, erweitern wir den zweiten und verwenden ihn zum Lesen. <br><br><img src="https://habrastorage.org/webt/b5/ho/zz/b5hozzqnmnm8fyhoebj3g3d7c_0.png" alt="Bild"><br><br><img src="https://habrastorage.org/webt/ld/_e/ly/ld_ely_1i5buzwbadpirjf0f1gc.png" alt="Bild"><br><br>  Es ist wichtig zu beachten, dass die Warteschlange wie alle anderen Strukturen unverändert bleiben muss.  Aber was nützt eine Warteschlange, die sich nicht ändert?  In der Tat gibt es einen Trick.  Als akzeptierten Wert der Warteschlange erhalten wir ein Tupel aus zwei Elementen.  Erstens: das gewünschte Warteschlangenelement, zweitens: Was ist mit der Warteschlange ohne dieses Element passiert? <br><br><pre> <code class="java hljs">System.out.println(queue); <span class="hljs-comment"><span class="hljs-comment">// Queue(1, 2, 3, 4, 5) Tuple2&lt;Integer, Queue&lt;Integer&gt;&gt; tuple2 = queue.dequeue(); System.out.println(tuple2._1); // 1 System.out.println(tuple2._2); // Queue(2, 3, 4, 5)</span></span></code> </pre> <br><h4>  Streams </h4><br>  Die nächste wichtige Datenstruktur ist der Stream.  Ein Stream ist ein Stream zur Ausführung einiger Aktionen für einen bestimmten, oft abstrakten Wertesatz. <br><br>  Jemand könnte sagen, dass <i>Java 8</i> bereits über vollwertige Streams verfügt und wir überhaupt keine neuen benötigen.  Ist es so? <br><br>  Stellen Sie zunächst sicher, dass der <i>Java-Stream</i> keine funktionierende Datenstruktur ist.  Überprüfen Sie die Struktur auf Veränderlichkeit.  Erstellen Sie dazu einen so kleinen Stream: <br><pre> <code class="java hljs">IntStream standardStream = IntStream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre> <br>  Wir werden alle Elemente im Stream sortieren: <br><br><pre> <code class="java hljs">standardStream.forEach(System.out::print);</code> </pre> <br>  Als Antwort erhalten wir die Ausgabe an die Konsole: <i>123456789</i> .  Wiederholen wir die Brute-Force-Operation: <br><br><pre> <code class="java hljs">standardStream.forEach(System.out::print);</code> </pre> <br>  Hoppla, der folgende Fehler ist aufgetreten: <br><br><pre> <code class="java hljs">java.lang.IllegalStateException: stream has already been operated upon or closed</code> </pre><br>  Tatsache ist, dass Standard-Streams nur eine Art Abstraktion über einen Iterator sind.  Obwohl die Streams äußerlich äußerst unabhängig und mächtig erscheinen, sind die Minuspunkte der Iteratoren nicht verschwunden. <br><br>  Zum Beispiel sagt die Definition eines Streams nichts über die Begrenzung der Anzahl von Elementen aus.  Leider ist es im Iterator vorhanden, was bedeutet, dass es sich um Standard-Streams handelt. <br><br>  Glücklicherweise löst die vavr-Bibliothek diese Probleme.  Stellen Sie Folgendes sicher: <br><br><pre> <code class="java hljs">Stream stream = Stream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>); stream.forEach(System.out::print); stream.forEach(System.out::print);</code> </pre> <br>  Als Antwort erhalten wir <i>123456789123456789</i> .  Dies bedeutet, dass die erste Operation unseren Stream nicht „verdorben“ hat. <br><br>  Versuchen wir, einen endlosen Stream zu erstellen: <br><br>  Stream infiniteStream = Stream.from (1); <br>  System.out.println (infiniteStream);  // Stream (1,?) <br><br>  Bitte beachten Sie: Beim Drucken eines Objekts erhalten wir keine unendliche Struktur, sondern das erste Element und ein Fragezeichen.  Tatsache ist, dass jedes nachfolgende Element im Stream im laufenden Betrieb generiert wird.  Dieser Ansatz wird als verzögerte Initialisierung bezeichnet.  Er ist es, der es Ihnen ermöglicht, sicher mit solchen Strukturen zu arbeiten. <br><br>  Wenn Sie noch nie mit unendlichen Datenstrukturen gearbeitet haben, denken Sie höchstwahrscheinlich: Warum ist das überhaupt notwendig?  Aber sie können sehr bequem sein.  Wir schreiben einen Stream, der eine beliebige Anzahl ungerader Zahlen zurückgibt, diese in eine Zeichenfolge konvertiert und ein Leerzeichen hinzufügt: <br><br><pre> <code class="java hljs">Stream oddNumbers = Stream .from(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  1   2 .map(x -&gt; x + " "); //  //   oddNumbers.take(5) .forEach(System.out::print); // 1 3 5 7 9 oddNumbers.take(10) .forEach(System.out::print); // 1 3 5 7 9 11 13 15 17 19</span></span></code> </pre> <br>  So einfach. <br><br><h3>  Allgemeine Struktur der Sammlungen </h3><br>  Nachdem wir die grundlegenden Strukturen besprochen haben, ist es Zeit, die allgemeine Architektur der <i>vavr-</i> Funktionssammlungen zu betrachten: <br><br><img src="https://habrastorage.org/webt/m2/ae/wl/m2aewlwyky8-r-dktx1asgvxqgy.png"><br><br>  Jedes Element der Struktur kann als iterierbar verwendet werden: <br><br><pre> <code class="java hljs">StringBuilder builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String word : List.of(<span class="hljs-string"><span class="hljs-string">"one"</span></span>, <span class="hljs-string"><span class="hljs-string">"two"</span></span>, <span class="hljs-string"><span class="hljs-string">"tree"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (builder.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { builder.append(<span class="hljs-string"><span class="hljs-string">", "</span></span>); } builder.append(word); } System.out.println(builder.toString()); <span class="hljs-comment"><span class="hljs-comment">// one, two, tree</span></span></code> </pre> <br>  Aber Sie sollten zweimal überlegen und das Dock sehen, bevor Sie es verwenden.  Mit der Bibliothek können Sie vertraute Dinge einfacher machen. <br><br><pre> <code class="java hljs">System.out.println(List.of(<span class="hljs-string"><span class="hljs-string">"one"</span></span>, <span class="hljs-string"><span class="hljs-string">"two"</span></span>, <span class="hljs-string"><span class="hljs-string">"tree"</span></span>).mkString(<span class="hljs-string"><span class="hljs-string">", "</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// one, two, tree</span></span></code> </pre> <br><h2>  Mit Funktionen arbeiten </h2><br>  Die Bibliothek verfügt über eine Reihe von Funktionen (8 Teile) und nützliche Methoden für die Arbeit mit ihnen.  Sie sind gewöhnliche funktionale Schnittstellen mit vielen interessanten Methoden.  Der Name der Funktionen hängt von der Anzahl der akzeptierten Argumente ab (von 0 bis 8).  Zum Beispiel <i>akzeptiert Function0</i> keine Argumente, <i>Function1</i> ein Argument, <i>Function2</i> zwei usw. <br><br><pre> <code class="java hljs">Function2&lt;String, String, String&gt; combineName = (lastName, firstName) -&gt; firstName + <span class="hljs-string"><span class="hljs-string">" "</span></span> + lastName; System.out.println(combineName.apply(<span class="hljs-string"><span class="hljs-string">"Griffin"</span></span>, <span class="hljs-string"><span class="hljs-string">"Peter"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// Peter Griffin</span></span></code> </pre> <br>  In den Funktionen der vavr-Bibliothek können wir viele coole Dinge tun.  In Bezug auf die Funktionalität gehen sie der Standardfunktion, der BiFunktion usw. weit voraus.  Zum Beispiel Curry.  Currying ist die Konstruktion von Funktionen in Teilen.  Schauen wir uns ein Beispiel an: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    Function2&lt;String, String, String&gt; combineName = (lastName, firstName) -&gt; firstName + " " + lastName; //           Function1&lt;String, String&gt; makeGriffinName = combineName .curried() .apply("Griffin"); //      System.out.println(makeGriffinName.apply("Peter")); // Peter Griffin System.out.println(makeGriffinName.apply("Lois")); // Lois Griffin</span></span></code> </pre> <br>  Wie Sie sehen können, ganz prägnant.  Die <i>Curry-</i> Methode ist extrem einfach, kann aber sehr nützlich sein. <br><br><div class="spoiler">  <b class="spoiler_title">Implementierung der Curry-Methode</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> Function1&lt;T1, Function1&lt;T2, R&gt;&gt; curried() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t1 -&gt; t2 -&gt; apply(t1, t2); }</code> </pre><br></div></div><br>  Es gibt viele weitere nützliche Methoden im <i>Funktionssatz</i> .  Sie können beispielsweise das Rückgabeergebnis einer Funktion zwischenspeichern: <br><br><pre> <code class="java hljs">Function0&lt;Double&gt; hashCache = Function0.of(Math::random).memoized(); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> randomValue1 = hashCache.apply(); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> randomValue2 = hashCache.apply(); System.out.println(randomValue1 == randomValue2); <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br><br><h2>  Kämpfe gegen Ausnahmen </h2><br>  Wie bereits erwähnt, muss der Programmiervorgang sicher sein.  Dazu müssen verschiedene Nebeneffekte vermieden werden.  Ausnahmen sind ihre expliziten Generatoren. <br><br>  Mit der <i>Try-</i> Klasse können Sie Ausnahmen in einem funktionalen Stil sicher behandeln.  In der Tat ist dies eine typische <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Monade</a> .  Es ist nicht notwendig, sich mit der Gebrauchstheorie auseinanderzusetzen.  Schauen Sie sich ein einfaches Beispiel an: <br><br><pre> <code class="java hljs">Try.of(() -&gt; <span class="hljs-number"><span class="hljs-number">4</span></span> / <span class="hljs-number"><span class="hljs-number">0</span></span>) .onFailure(System.out::println) .onSuccess(System.out::println);</code> </pre> <br>  Wie Sie dem Beispiel entnehmen können, ist alles recht einfach.  Wir hängen das Ereignis einfach an einen potenziellen Fehler und gehen nicht über die Grenzen der Berechnung hinaus. <br><br><h2>  Mustervergleich </h2><br>  Oft tritt eine Situation auf, in der wir den Wert einer Variablen überprüfen und das Verhalten des Programms abhängig vom Ergebnis modellieren müssen.  Gerade in solchen Situationen hilft eine wunderbare Vorlagensuchmaschine.  Sie müssen nicht mehr viel schreiben, <i>wenn sonst</i> , konfigurieren Sie einfach die gesamte Logik an einem Ort. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> io.vavr.API.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> io.vavr.Predicates.*; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PatternMatchingDemo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ String s = Match(<span class="hljs-number"><span class="hljs-number">1993</span></span>).of( Case($(<span class="hljs-number"><span class="hljs-number">42</span></span>), () -&gt; <span class="hljs-string"><span class="hljs-string">"one"</span></span>), Case($(anyOf(isIn(<span class="hljs-number"><span class="hljs-number">1990</span></span>, <span class="hljs-number"><span class="hljs-number">1991</span></span>, <span class="hljs-number"><span class="hljs-number">1992</span></span>), is(<span class="hljs-number"><span class="hljs-number">1993</span></span>))), <span class="hljs-string"><span class="hljs-string">"two"</span></span>), Case($(), <span class="hljs-string"><span class="hljs-string">"?"</span></span>) ); System.out.println(s); <span class="hljs-comment"><span class="hljs-comment">// two } }</span></span></code> </pre> <br>  Bitte beachten Sie, dass Case als aktiviert ist  case ist ein Schlüsselwort und wird bereits vergeben. <br><br><h2>  Fazit </h2><br>  Meiner Meinung nach ist die Bibliothek sehr cool, aber es lohnt sich, sie sehr sorgfältig zu verwenden.  Sie kann in <i>der ereignisgesteuerten</i> Entwicklung großartig <i>abschneiden</i> .  Die übermäßige und gedankenlose Verwendung in der Standardprogrammierung auf der Grundlage eines Thread-Pools kann jedoch viel Kopfzerbrechen verursachen.  Darüber hinaus verwenden wir in unseren Projekten häufig Spring und Hibernate, die für eine solche Anwendung nicht immer bereit sind.  Bevor Sie eine Bibliothek in Ihr Projekt importieren, müssen Sie genau wissen, wie und warum sie verwendet wird.  Worüber ich in einem meiner nächsten Artikel sprechen werde. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de421839/">https://habr.com/ru/post/de421839/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de421827/index.html">Was kann man jetzt über Java lesen?</a></li>
<li><a href="../de421829/index.html">Frangos Anomalie - eine fantastische Romanze mit echten IT-Leuten</a></li>
<li><a href="../de421833/index.html">Wir schreiben unser einfachstes Programm für ARM Cortex-M3</a></li>
<li><a href="../de421835/index.html">Die Interagency Commission entwickelt neue Technologien zur Blockierung von Telegrammen</a></li>
<li><a href="../de421837/index.html">Erstellen von 1k Intro Chaos für ZX-Spectrum</a></li>
<li><a href="../de421841/index.html">Robotaxi Waymo ist nicht ganz bereit für den Zugang zu öffentlichen Straßen</a></li>
<li><a href="../de421845/index.html">Was machen Datenanalysten eigentlich? Ergebnisse aus 35 Interviews</a></li>
<li><a href="../de421847/index.html">Springe in die Wolke. Erstellen einer kostengünstigen IoT-Lösung auf NodeMCU + Azure IoT Hub</a></li>
<li><a href="../de421849/index.html">Veranstaltungen für HR in der IT im September 2018: My Circle Digest</a></li>
<li><a href="../de421851/index.html">Probleme mit Eulen und Globus: Verbinden von zwei Assemblys mit identischen Namespaces und Klassennamen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>