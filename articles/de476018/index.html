<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🏭 👩‍👧‍👧 🎪 So funktioniert Flattern 🧚🏿 ◾️ 🛋️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wie funktioniert Flutter eigentlich? 


 Was sind Widgets, Elemente, BuildContext, RenderOject, Bindungen? .. 


 Schwierigkeit: Anfänger 
 Eintrag 

...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So funktioniert Flattern</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476018/"><p><img src="https://habrastorage.org/webt/xo/f8/wq/xof8wqtuioee7o5ztrhyyb7hriq.png"></p><br><p>  Wie funktioniert Flutter eigentlich? </p><br><p>  Was sind Widgets, Elemente, BuildContext, RenderOject, Bindungen? .. </p><br><p>  Schwierigkeit: <em>Anfänger</em> </p><br><h1 id="vstuplenie">  Eintrag </h1><br><p>  Letztes Jahr ( <em>Anmerkung: 2018</em> ), als ich meine Reise in die fabelhafte Welt von Flutter antrat, gab es im Internet nur sehr wenige Informationen im Vergleich zu dem, was es heute ist.  Trotz der Tatsache, dass bereits viele Materialien geschrieben wurden, spricht nur ein kleiner Teil davon darüber, wie Flutter tatsächlich funktioniert. </p><br><p>  Was sind Widgets ( <em>Widgets</em> ), Elemente ( <em>Elemente</em> ), BuildContext?  Warum flattert es so schnell?  Warum funktioniert es manchmal nicht wie erwartet?  Was sind Bäume und warum werden sie benötigt? </p><br><p>  In 95% der Fälle beschäftigen Sie sich beim Schreiben einer Anwendung nur mit Widgets, um etwas anzuzeigen oder damit zu interagieren.  Aber haben Sie sich nie wirklich gefragt, wie all diese Magie in Ihnen wirkt?  Woher weiß das System, wann der Bildschirm aktualisiert werden muss und welche Teile aktualisiert werden müssen? </p><br><p>  <strong>Inhalt:</strong> </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eintrag</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1: Hintergrund</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein bisschen über das Gerät</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schnittstelle zwischen Code und Gerät</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwalten des Flutter Framework Flutter Engine-Renderings</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RenderView und RenderObject</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Initialisierungsbindungen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SchedulerBinding</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gestenbindung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Renderer-Bindung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Widgets verbindlich</a> <a name="habracut"></a></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2. Von Widgets zu Pixeln</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unveränderliche Konfiguration</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die hierarchische Struktur von Widgets</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wald hinter den Bäumen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grundlegendes zum Element in einem Baum</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3 Kategorien von Widgets</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikeltypen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie Widgets und Elemente zusammenarbeiten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">onDrawFrame ()</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3: Umgang mit Gesten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 4: Animationen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vollbild</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Buildcontext</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie nützlich kann ein BuildContext sein?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zum Spaß</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fazit</a> </li></ul><br><h1 id="chast-1-predystoriya">  Teil 1: Hintergrund </h1><br><p>  Der erste Teil des Artikels stellt einige Schlüsselkonzepte vor, die im zweiten Teil des Materials verwendet werden und zum besseren Verständnis von Flutter beitragen. </p><br><h2 id="nemnogo-ob-ustroystve">  Ein bisschen über das Gerät </h2><br><p>  Beginnen wir am Ende und kehren zu den Grundlagen zurück. </p><br><p>  Wenn Sie sich Ihr Gerät oder genauer gesagt die Anwendung ansehen, die auf Ihrem Gerät ausgeführt wird, sehen Sie nur den Bildschirm. </p><br><p>  In der Tat sehen Sie nur die Pixel, die zusammen ein zweidimensionales Bild ergeben. Wenn Sie den Bildschirm mit dem Finger berühren, erkennt das Gerät nur die Position Ihres Fingers auf dem Glas. </p><br><p>  In den meisten Fällen besteht die Magie der Anwendung (visuell gesehen) darin, dieses Bild auf der Grundlage der folgenden Interaktionen zu aktualisieren: </p><br><ul><li>  mit dem Gerätebildschirm ( <em>zum Beispiel ein Finger auf dem Glas</em> ) </li><li>  mit dem Netzwerk ( <em>z. B. Kommunikation mit dem Server</em> ) </li><li>  im Laufe der Zeit ( <em>z. B. Animation</em> ) </li><li>  mit anderen externen Sensoren </li></ul><br><p>  Die Visualisierung des Bildes auf dem Bildschirm erfolgt durch Hardware (Display), die die Anzeige regelmäßig (in der Regel 60 Mal pro Sekunde) aktualisiert.  Dies wird als "Bildwiederholfrequenz" bezeichnet und in Hz (Hertz) ausgedrückt. </p><br><p>  Das Display erhält Informationen zur Anzeige von der GPU (Graphics Processing Unit), einer speziellen elektronischen Schaltung, die optimiert und so konzipiert ist, dass aus einigen Daten (Polygonen und Texturen) schnell Bilder erzeugt werden.  Die Anzahl der Male pro Sekunde, die der Grafikprozessor ein "Bild" (= Bildpuffer) erzeugen kann, um es anzuzeigen und an die Hardware zu senden, wird als Bildrate bezeichnet ( <em>Hinweis: Bildrate</em> ).  Dies wird unter Verwendung eines Blocks von Bildern pro Sekunde ( <em>z. B. 60 Bilder pro Sekunde oder 60 fps</em> ) <em>gemessen</em> . </p><br><p>  Sie mögen mich fragen, warum ich diesen Artikel mit den Konzepten eines zweidimensionalen Bildes begonnen habe, das von einer GPU / Hardware und einem physischen Glassensor angezeigt wird, und wie ist der Zusammenhang mit normalen Flutter-Widgets? </p><br><p>  Ich denke, es wird einfacher zu verstehen sein, wie Flutter tatsächlich funktioniert, wenn wir es aus dieser Sicht betrachten, da eines der Hauptziele der Flutter-Anwendung darin besteht, dieses zweidimensionale Bild zu erstellen und es ihm zu ermöglichen, damit zu interagieren.  Auch weil in Flutter, ob Sie es glauben oder nicht, ist fast alles auf die Notwendigkeit zurückzuführen, den Bildschirm schnell und zum richtigen Zeitpunkt zu aktualisieren! </p><br><h2 id="interfeys-mezhdu-kodom-i-ustroystvom">  Schnittstelle zwischen Code und Gerät </h2><br><p>  Jedenfalls hat jeder, der sich für Flutter interessiert, bereits das folgende Bild gesehen, das Flutters <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">High-Level-Architektur beschreibt</a> . </p><br><p><img src="https://habrastorage.org/webt/i0/tp/fo/i0tpfoumlz1ultkyzqywfm9-osa.png"></p><br><p>  Wenn wir eine Flutter-Anwendung mit Dart schreiben, bleiben wir auf der Ebene des <em>Flutter-Frameworks</em> (grün hervorgehoben). </p><br><p>  <em>Das Flutter Framework</em> interagiert mit der <em>Flutter Engine</em> (blau) über eine Abstraktionsebene namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Window</a> .  Diese Abstraktionsebene bietet eine Reihe von APIs für die indirekte Interaktion mit dem Gerät. </p><br><p>  Durch diese Abstraktionsebene benachrichtigt die <em>Flutter</em> <em>Engine</em> das <em>Flutter Framework,</em> wenn: </p><br><ul><li>  Ein Ereignis von Interesse tritt auf Geräteebene auf (Änderung der Ausrichtung, Änderung der Einstellungen, Speicherproblem, Betriebszustand der Anwendung ...) </li><li>  Ein Ereignis tritt auf der Glasebene auf (= Geste) </li><li>  Plattformkanal sendet einige Daten </li><li>  aber auch hauptsächlich, wenn die <strong>Flutter Engine bereit ist, einen neuen Frame zu rendern</strong> </li></ul><br><h2 id="upravlenie-flutter-framework-renderingom-flutter-engine">  Verwalten des Flutter Framework Flutter Engine-Renderings </h2><br><p>  Es ist schwer zu glauben, aber es ist wahr.  Mit Ausnahme einiger Fälle ( <em>siehe unten</em> ) wird kein <em>Flutter Framework-</em> Code ausgeführt, ohne das <em>Flutter Engine-</em> Rendering zu starten. </p><br><p>  Ausnahmen: </p><br><ul><li>  Geste / Geste (= Ereignis auf Glas) </li><li>  Plattformnachrichten (= von einem Gerät generierte Nachrichten, z. B. GPS) </li><li>  Gerätemeldungen (= Meldungen, die sich auf eine Änderung des Gerätestatus beziehen, z. B. Ausrichtung, im Hintergrund gesendete Anwendung, Speicherwarnungen, Geräteeinstellungen ...) </li><li>  Zukünftige oder http-Antworten </li></ul><br><p>  <em>(Zwischen uns können Sie tatsächlich eine visuelle Änderung vornehmen, ohne von der Flutter Engine aus aufzurufen. Dies wird jedoch <strong>nicht empfohlen.</strong> )</em> </p><br><p>  Sie fragen mich: "Wenn ein Code im Zusammenhang mit der <em>Geste</em> ausgeführt wird und eine visuelle Änderung verursacht, oder wenn ich einen <em>Timer verwende</em> , um die Häufigkeit der Aufgabe festzulegen, die zu visuellen Änderungen führt (z. B. Animation), wie funktioniert das?" </p><br><p>  Wenn Sie möchten, dass eine visuelle Änderung auftritt oder ein Code basierend auf einem Timer ausgeführt wird, müssen Sie der <em>Flutter-Engine</em> mitteilen, dass etwas gezeichnet werden muss. </p><br><p>  Normalerweise ruft die <em>Flutter Engine bei</em> der nächsten Aktualisierung das <em>Flutter Framework</em> auf, um Code auszuführen, und stellt schließlich eine neue Szene zum Rendern bereit. </p><br><p>  Daher ist eine wichtige Frage, wie die Flutter-Engine das gesamte Anwendungsverhalten basierend auf dem Rendern organisiert. </p><br><p>  Sehen Sie sich die folgende Animation an, um sich ein Bild von den internen Mechanismen zu machen: </p><br><p><img src="https://habrastorage.org/webt/zu/7s/ig/zu7sigrkekrmz8ha_83cvr88ynk.gif"></p><br><p>  Eine kurze Erklärung (weitere Details folgen später): </p><br><ul><li>  Einige externe Ereignisse (Gesten, HTTP-Antworten usw.) oder sogar Zukünfte können Aufgaben auslösen, die eine Aktualisierung der Anzeige erforderlich machen.  Die entsprechende Nachricht wird an die <em>Flutter Engine</em> gesendet (= <em>Schedule Frame</em> ) </li><li>  Wenn die <em>Flutter Engine</em> bereit ist, das Rendering zu aktualisieren, erstellt sie eine Anforderung für den <em>Frame-</em> Beginn </li><li>  Diese Anforderung für <em>Frame-Beginn</em> wird vom <em>Flutter Framework</em> abgefangen, das Aufgaben ausführt, die hauptsächlich mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Tickern zusammenhängen</a> (z. B. Animation). </li><li>  Diese Tasks können die Anforderung für ein späteres Rendern neu erstellen (Beispiel: Die Animation wurde noch nicht ausgeführt, und zum Abschluss muss zu einem späteren Zeitpunkt ein weiterer <em>Startframe abgerufen werden.</em> ) </li><li>  Als Nächstes sendet die <em>Flutter Engine</em> einen <em>Draw Frame</em> , der vom <em>Flutter Framework</em> abgefangen wird und nach Aufgaben sucht, die mit der Aktualisierung des Layouts in Bezug auf Struktur und Größe zusammenhängen </li><li>  Nachdem alle diese Aufgaben erledigt sind, fährt er mit den Aufgaben fort, die mit der Aktualisierung des Layouts in Bezug auf das Rendern verbunden sind </li><li>  Wenn auf dem Bildschirm etwas gezeichnet werden muss, wird eine neue Szene ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Scene</a> ) zur Visualisierung an die <em>Flutter Engine</em> gesendet, die den Bildschirm aktualisiert </li><li>  Das <em>Flutter Framework</em> führt <em>dann</em> alle Aufgaben aus, die nach dem Rendern ausgeführt werden (= PostFrame-Rückrufe), sowie alle weiteren nachfolgenden Aufgaben, die sich nicht auf das Rendern beziehen </li><li>  ... und dieser Prozess beginnt von vorne </li></ul><br><h2 id="renderview-i-renderobject">  RenderView und RenderObject </h2><br><p>  Bevor Sie sich mit den Details des Workflows befassen, ist es Zeit, das Konzept des <em>Rendering-Baums</em> vorzustellen. </p><br><p>  Wie bereits erwähnt, wird irgendwann alles in Pixel konvertiert, die auf dem Bildschirm angezeigt werden, und das <em>Flutter Framework</em> konvertiert die <em>Widgets</em> , mit denen wir die Anwendung entwickeln, in visuelle Blöcke, die auf dem Bildschirm angezeigt werden. </p><br><p>  Diese visuellen Teile entsprechen Objekten mit dem Namen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">RenderObject</a> , die verwendet werden, um: </p><br><ul><li>  Definieren eines bestimmten Bereichs des Bildschirms in Bezug auf Größe, Position, Geometrie sowie in Bezug auf <em>"gerenderten Inhalt"</em> </li><li>  Bereiche des Bildschirms identifizieren, die von Gesten betroffen sein können (= Fingerberührung) </li></ul><br><p>  Ein Satz aller <em>RenderObjects</em> bildet einen Baum, der als <em>Render Tree bezeichnet wird</em> .  Oben in diesem Baum (= <em>root</em> ) befindet sich eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">RenderView</a> . </p><br><p>  <em>RenderView</em> bietet eine gemeinsame Oberfläche für <em>Render Tree-</em> Objekte und ist eine spezielle Version von <em>RenderObject</em> . </p><br><p>  Optisch könnten wir das alles wie folgt darstellen: <br><img src="https://habrastorage.org/webt/yi/aq/6v/yiaq6vvo9ssed0qtewkftfwrmpy.png"></p><br><p>  Die Beziehung zwischen <em>Widget</em> und <em>RenderObject</em> wird später erläutert.  In der Zwischenzeit ist es Zeit, etwas tiefer zu gehen ... </p><br><h2 id="inicializaciya-bindings">  Initialisierungsbindungen </h2><br><p> Wenn die Flutter-Anwendung <code>runApp(Widget app)</code> wird, wird zuerst die <code>main()</code> -Funktion aufgerufen, die letztendlich die <code>runApp(Widget app)</code> Methode <code>runApp(Widget app)</code> . </p><br><p>  Wenn die <code>runApp()</code> -Methode <code>runApp()</code> initialisiert das <em>Flutter Framework</em> die Schnittstellen zwischen sich und der <em>Flutter Engine</em> .  Diese Schnittstellen werden <strong>Bindungen genannt</strong> ( <em>Anmerkung: Bindungen</em> ). </p><br><p>  <strong>Einführung in Bindungen</strong> </p><br><p>  Bindungen sind als Bindeglied zwischen dem Framework und der Flutter-Engine konzipiert.  Nur durch Bindungen können Daten zwischen dem <em>Flutter Framework</em> und der <em>Flutter Engine</em> ausgetauscht werden. <br>  <em>(Es gibt nur eine Ausnahme von dieser Regel -</em> RenderView <em>, aber wir werden dies später diskutieren).</em> </p><br><p>  Jede Bindung ist für die Verarbeitung einer Reihe spezifischer Aufgaben, Aktionen und Ereignisse verantwortlich, die nach Tätigkeitsbereichen gruppiert sind. </p><br><p>  Zum Zeitpunkt des Schreibens dieses <em>Dokuments</em> verfügt das <em>Flutter Framework</em> über 8 Bindungen. </p><br><p>  Im Folgenden sind 4 davon aufgeführt, die in diesem Artikel behandelt werden: </p><br><ul><li>  <em>SchedulerBinding</em> </li><li>  <em>Gestenbindung</em> </li><li>  <em>Renderer-Bindung</em> </li><li>  <em>Widgets verbindlich</em> </li></ul><br><p>  Der Vollständigkeit halber erwähne ich die restlichen 4: </p><br><ul><li>  <em>ServicesBinding</em> : Verantwortlich für die Verarbeitung der vom <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Plattformkanal gesendeten</a></em> Nachrichten </li><li>  <em>PaintingBinding</em> : Verantwortlich für die Verarbeitung des Bild-Cache </li><li>  <em>SemanticsBinding</em> : reserviert für die spätere Implementierung von allem, was mit Semantik zu tun hat </li><li>  <em>TestWidgetsFlutterBinding</em> : <em>Wird</em> von der Widget- <em>Testbibliothek</em> verwendet </li></ul><br><p>  Sie können auch <em>WidgetsFlutterBinding</em> erwähnen, dies ist jedoch nicht wirklich eine Bindung, sondern eher eine Art <em>"Bindungsinitialisierer".</em> </p><br><p>  Das folgende Diagramm zeigt die Interaktion zwischen den Bindungen, die ich als Nächstes betrachten werde, und der <em>Flutter-Engine</em> . </p><br><p><img src="https://habrastorage.org/webt/ws/ph/x_/wsphx_tme3caqf0qimfk0wxur9g.png"></p><br><p>  Schauen wir uns jede dieser „Kern“ -Bindungen an. </p><br><h3 id="schedulerbinding">  SchedulerBinding </h3><br><p>  Diese Bindung hat zwei Hauptaufgaben: </p><br><ul><li>  Sagen Sie " <em>Flutter Engine</em> <em>"</em> : <em>"Hey! Wenn Sie das nächste Mal nicht beschäftigt sind, wecken Sie mich auf, damit ich ein bisschen arbeiten und Ihnen sagen kann, was Sie rendern sollen, oder wenn Sie mich später anrufen müssen ..."</em> </li><li>  Hören Sie zu und reagieren Sie auf solche <em>„störenden Erwachen“</em> (siehe unten) </li></ul><br><p>  Wann <em>fordert SchedulerBinding</em> einen <em>Weckruf an</em> ? </p><br><ul><li><p>  Wann muss der <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Ticker</a></em> <em>einen</em> neuen <em>Tick</em> <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">ausarbeiten</a></em> <em>?</em> </p><br><p>  Wenn Sie beispielsweise eine Animation haben, starten Sie diese.  Die Animation wird mit dem <em>Ticker</em> beschnitten, der in regelmäßigen Abständen (= <em>Tick</em> ) aufgerufen wird, um einen <em>Callback</em> durchzuführen.  Um einen solchen <em>Callback</em> zu starten, müssen wir der <em>Flutter Engine</em> mitteilen, dass sie uns beim nächsten Update (= <em>Begin Frame</em> ) aufweckt.  Dadurch wird der <em>Ticker-</em> Rückruf gestartet, um seine Aufgabe abzuschließen.  Wenn der <em>Ticker</em> weiterhin ausgeführt werden muss, ruft er am Ende seiner Aufgabe <em>SchedulerBinding</em> auf, um einen weiteren Frame zu planen. </p><br></li><li><p>  Wann muss die Anzeige aktualisiert werden? </p><br><p>  Beispielsweise müssen wir ein Ereignis ausarbeiten, das zu einer visuellen Änderung führt (Beispiel: Aktualisieren der Farbe eines Teils des Bildschirms, Scrollen, Hinzufügen / Entfernen von Elementen vom Bildschirm). Dazu müssen wir die erforderlichen Schritte ausführen, um das aktualisierte Bild schließlich auf dem Bildschirm anzuzeigen.  In diesem Fall ruft das <em>Flutter Framework</em> bei einer solchen Änderung <em>SchedulerBinding</em> auf, um mithilfe der <em>Flutter Engine einen</em> anderen Frame zu planen.  <em>(Später werden wir sehen, wie das tatsächlich funktioniert)</em> </p><br></li></ul><br><h3 id="gesturebinding">  Gestenbindung </h3><br><p>  Diese Bindung lauscht der Interaktion mit der Engine im Sinne des <em>„Fingers“</em> (= <em>Geste</em> ). </p><br><p>  Insbesondere ist er dafür verantwortlich, <em>fingerbezogene</em> Daten zu empfangen und zu bestimmen, mit welchem ​​Teil des Bildschirms die Gesten arbeiten.  Er teilt diese Teile dann entsprechend mit. </p><br><h3 id="rendererbinding">  Renderer-Bindung </h3><br><p>  Diese Bindung ist die Verbindung zwischen der <em>Flutter-Engine</em> und dem <em>Render-Baum</em> .  Sie ist verantwortlich für: </p><br><ul><li>  Abhören von Ereignissen, die von der Engine generiert wurden, um über vom Benutzer durch Geräteeinstellungen vorgenommene Änderungen zu informieren, die sich auf visuelle Effekte und / oder Semantik auswirken </li><li>  Meldung an die Engine über Änderungen, die auf die Anzeige angewendet werden </li></ul><br><p>  Damit die Änderungen auf dem Bildschirm angezeigt werden, ist <em>RendererBinding</em> für die Verwaltung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">PipelineOwners</a> und die Initialisierung der <strong>RenderView verantwortlich</strong> . </p><br><p>  <em>PipelineOwner</em> ist eine Art <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Orchester</a> , das weiß, was mit <em>RenderObject</em> entsprechend der <em>Komponente</em> zu tun ist, und diese Aktionen koordiniert. </p><br><h3 id="widgetsbinding">  Widgets verbindlich </h3><br><p>  Diese Bindung wartet auf Änderungen, die vom Benutzer über Geräteeinstellungen vorgenommen wurden, die sich auf die Sprache (= <em>Gebietsschema</em> ) und die <em>Semantik</em> auswirken. </p><br><blockquote>  <em>Kleine Notiz</em> <br><br>  <em>Ich gehe davon aus, dass zu einem späteren Zeitpunkt in der Entwicklung von</em> Flutter <em>alle semantikbezogenen Ereignisse in das</em> SemanticsBinding übertragen werden <em>, aber zum Zeitpunkt dieses Schreibens ist dies nicht der Fall.</em> </blockquote><p>  Darüber hinaus ist <em>WidgetsBinding</em> die Verbindung zwischen Widgets und der <em>Flutter Engine</em> .  Sie ist verantwortlich für: </p><br><ul><li>  Verwaltung des Prozesses der Verarbeitung von Widget-Strukturänderungen </li><li>  Anruf tätigen </li></ul><br><p>  Die Bearbeitung von Änderungen an der Struktur von Widgets erfolgt mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">BuildOwner</a> . </p><br><p>  <em>BuildOwner</em> verfolgt, welche Widgets neu erstellt werden müssen, und verarbeitet andere Aufgaben, die für die Widgetstruktur insgesamt gelten. </p><br><h1 id="chast-2-ot-vidzhetov-k-pikselyam">  Teil 2. Von Widgets zu Pixeln </h1><br><p>  Nachdem wir nun die Grundlagen der internen Arbeit von <em>Flutter</em> kennen gelernt haben, ist es Zeit, über Widgets zu sprechen. </p><br><p>  In allen Flutter-Dokumentationen lesen Sie, dass alle <em>Widgets</em> (Widgets). </p><br><p>  Das ist fast richtig.  Aber um ein bisschen genauer zu sein, würde ich eher sagen: </p><br><blockquote>  Auf Entwicklerseite erfolgt alles, was in Bezug auf Layout und Interaktion mit der Benutzeroberfläche zu tun hat, über Widgets. </blockquote><p>  Warum so viel Genauigkeit?  Neben der Tatsache, dass <em>Widget</em> es dem Entwickler ermöglicht, einen Teil des Bildschirms in Bezug auf Größe, Inhalt, Layout und Interaktion zu bestimmen, <strong>steckt</strong> jedoch noch viel mehr dahinter.  Also, was ist <em>Widget</em> wirklich? </p><br><h2 id="neizmenyaemaya-konfiguraciya">  Unveränderliche Konfiguration </h2><br><p>  Wenn Sie sich den Quellcode von <em>Flutter</em> ansehen, werden Sie die folgende Definition der <em>Widget-</em> Klasse bemerken. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DiagnosticableTree</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({ </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.key })</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Key key; ... }</code> </pre> <br><p>  Was bedeutet das? </p><br><p>  Die Anmerkung <strong>"@immutable" ist</strong> sehr wichtig und besagt, dass <strong>jede Variable in der Widget-Klasse FINAL sein muss</strong> , mit anderen Worten: " <strong>EINMAL FÜR JEDEN</strong> definiert und zugewiesen."  Nach dem Erstellen einer Instanz kann Widget daher seine internen Variablen nicht mehr ändern. </p><br><blockquote>  <em>Da Widget unveränderlich ist, kann es als statische Konfiguration betrachtet werden.</em> </blockquote><br><h2 id="ierarhicheskaya-struktura-vidzhetov">  Die hierarchische Struktur von Widgets </h2><br><p>  Wenn Sie mit Flutter entwerfen, definieren Sie die Struktur Ihres Bildschirms (Ihrer Bildschirme) mit Widgets wie folgt: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SafeArea( child: Scaffold( appBar: AppBar( title: Text(<span class="hljs-string"><span class="hljs-string">'My title'</span></span>), ), body: Container( child: Center( child: Text(<span class="hljs-string"><span class="hljs-string">'Centered Text'</span></span>), ), ), ), ); }</code> </pre> <br><p>  In diesem Beispiel werden 7 Widgets verwendet, die zusammen eine hierarchische Struktur bilden.  Ein sehr vereinfachtes Schema, das auf diesem Code basiert, lautet wie folgt: </p><br><p><img src="https://habrastorage.org/webt/f2/ke/dt/f2kedtux7_ot2issfzbv64n3uak.png"></p><br><p>  Wie Sie sehen, sieht das dargestellte Diagramm wie ein Baum aus, in dem <em>SafeArea</em> die Wurzel ist. </p><br><h2 id="les-za-derevyami">  Wald hinter den Bäumen </h2><br><p>  Wie Sie bereits wissen, kann ein Widget selbst eine Zusammenfassung anderer Widgets sein.  Beispielsweise können Sie den vorherigen Code wie folgt ändern: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyOwnWidget(); }</code> </pre> <br><p>  Diese Option setzt voraus, dass das Widget <em>"MyOwnWidget"</em> selbst <em>SafeArea</em> , <em>Scaffold</em> <em>anzeigt</em> .  Aber das Wichtigste in diesem Beispiel ist das </p><br><blockquote>  <em>Ein Widget</em> kann ein Blatt, einen Knoten in einem Baum, sogar den Baum selbst oder, warum nicht, einen Wald von Bäumen darstellen ... </blockquote><br><h2 id="ponimanie-element-v-dereve">  Grundlegendes zum <em>Element</em> in einem Baum </h2><br><p>  Was hat das damit zu tun? </p><br><p>  Wie später noch gezeigt wird, muss <em>Flutter</em> alle kleinen Teile des Bildschirms im Detail kennen, um Pixel für das auf dem Gerät angezeigte Bild erzeugen zu können, und um alle Teile zu bestimmen, muss es die <strong>Erweiterung</strong> aller Widgets kennen. </p><br><p>  Um diesen Punkt zu veranschaulichen, betrachten Sie das Prinzip einer verschachtelten Puppe: Wenn sie geschlossen ist, sehen Sie nur eine Puppe, aber sie enthält eine andere, die wiederum eine andere enthält und so weiter ... </p><br><p><img src="https://habrastorage.org/webt/9x/kq/lb/9xkqlbngsofs0w7m71rx2yucnzy.png"></p><br><p>  Wenn <em>Flutter</em> alle Widgets <em>(Teil des Bildschirms) erweitert</em> , werden alle Puppen <em>(Teil des Ganzen) abgerufen</em> . </p><br><p>  Das folgende Bild zeigt einen Teil der endgültigen hierarchischen Struktur von Widgets, die dem vorherigen Code entsprechen.  In Gelb habe ich die zuvor im Code erwähnten Widgets hervorgehoben, damit Sie sie im endgültigen Baum definieren können. </p><br><p><img src="https://habrastorage.org/webt/mp/lw/-o/mplw-oisztyx_zvwf8kvpl2tpog.png"></p><br><blockquote>  <strong><em>Wichtige Klarstellung</em></strong> <br><br>  <em>Die Sprache "Widget-Baum" existiert nur, um das Verständnis zu erleichtern, da Programmierer Widgets verwenden, aber es gibt KEINEN Widget-Baum in Flutter!</em> <br><br>  <em>Tatsächlich wäre es richtiger, "Baum der Elemente" zu sagen.</em> </blockquote><p>  Es ist Zeit, das Konzept eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Elements</a> einzuführen. </p><br><blockquote>  <em><strong>Jedes</strong> Widget hat <strong>ein</strong> Element.</em>  <em>Elemente sind miteinander verbunden und bilden einen Baum.</em>  <em>Daher ist <strong>ein Element</strong> eine Referenz auf etwas im Baum.</em> </blockquote><p>  Stellen Sie sich ein Element zunächst als Knoten vor, der ein übergeordnetes und möglicherweise ein untergeordnetes Element hat.  Indem wir sie durch eine <em>Eltern-Kind-</em> Beziehung miteinander verbinden, erhalten wir eine Baumstruktur. </p><br><p><img src="https://habrastorage.org/webt/bd/cx/t4/bdcxt4slijkhhc5j0fnipnauyey.png"></p><br><p>  Wie Sie sehen, zeigt das Element auf ein Widget und <strong>kann</strong> auch auf ein <em>RenderObject zeigen</em> . </p><br><blockquote>  <em>Noch besser ... Element zeigt auf Widget, <strong>das</strong> dieses Element erstellt hat!</em> </blockquote><p>  Fassen wir zusammen: </p><br><ul><li>  Es gibt keinen Widgetbaum, aber einen Elementbaum </li><li>  Elemente werden von Widgets erstellt. </li><li>  Das Element bezieht sich auf das Widget, das es erstellt hat. </li><li>  Elemente, die mit übergeordneten Beziehungen verknüpft sind </li><li>  Ein Gegenstand kann ein "Baby" haben. </li><li>  Elemente können auch auf ein <em>RenderObject zeigen.</em> </li></ul><br><blockquote>  <em><strong>Elemente</strong> bestimmen, wie Teile der angezeigten Blöcke miteinander in Beziehung stehen.</em> </blockquote><p>  Um sich besser vorstellen zu können, wo das Konzept <em>eines Elements</em> passt, schauen wir uns die folgende visuelle Darstellung an: </p><br><p><img src="https://habrastorage.org/webt/x5/vb/jt/x5vbjtq_5fhuyhvc2s7jnt7pbai.png"></p><br><p>  Wie Sie sehen, ist der Elementbaum die tatsächliche Beziehung zwischen Widgets und <em>RenderObjects</em> . </p><br><p>  Aber warum erstellt <em>Widget</em> ein <em>Element</em> ? </p><br><h2 id="3-kategorii-vidzhetov">  3 Kategorien von Widgets </h2><br><p>  In Flutter sind Widgets in drei Kategorien unterteilt, die ich persönlich wie folgt nenne <em>(dies ist jedoch nur meine Art, sie zu klassifizieren)</em> : </p><br><ul><li><p>  Proxy </p><br><p>  Die Hauptaufgabe dieser Widgets besteht darin, einige Informationen zu speichern (auf die Widgets zugreifen können sollten), die Teil der auf Proxy basierenden Baumstruktur sind.  Ein Beispiel für solche Widgets ist <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">InheritedWidget</a></strong> oder <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">LayoutId</a></strong> . </p><br><p>  Diese Widgets sind nicht direkt an der Gestaltung der Benutzeroberfläche beteiligt, sondern werden verwendet, um die Informationen abzurufen, die sie bereitstellen können. </p><br></li><li><p>  Renderer </p><br><p>  Diese Widgets stehen in direktem Zusammenhang mit dem Layout des Bildschirms, da sie die <em>Größe</em> , <em>Position</em> und das <em>Rendering</em> bestimmen (oder dazu verwendet werden).  Typische Beispiele sind: <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Row</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Column</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Stack</a></strong> sowie <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Padding</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Align</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Opacity</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">RawImage</a></strong> ... </p><br></li><li><p>  Komponente </p><br><p>  Hierbei handelt es sich um andere Widgets, die nicht direkt die endgültigen Informationen zu Größe, Position und Erscheinungsbild bereitstellen, sondern vielmehr die Daten (oder Tipps), mit denen die endgültigen Informationen abgerufen werden.  Diese Widgets werden üblicherweise als Komponenten bezeichnet. </p><br><p>  Beispiele: <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">RaisedButton</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Scaffold</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Text</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">GestureDetector</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Container</a></strong> ... </p><br></li></ul><br><p><img src="https://habrastorage.org/webt/oe/j0/j7/oej0j75h_3ycogohqdckq5e03im.png"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">In dieser PDF-Datei</a> sind die meisten Widgets nach Kategorien gruppiert. </p><br><p>  Warum ist diese Trennung wichtig?  Weil abhängig von der Kategorie des Widgets der entsprechende Elementtyp mit ... </p><br><h2 id="tipy-elementov">  Artikeltypen </h2><br><p>  Es gibt verschiedene Arten von Elementen: </p><br><p><img src="https://habrastorage.org/webt/or/au/yc/orauycfegkvfnjlmjws4x4ftpuw.png"></p><br><p>  Wie Sie im obigen Bild sehen können, sind die Elemente in zwei Haupttypen unterteilt: </p><br><ul><li><p>  Komponentenbestandteil </p><br><p>  Diese Elemente <strong>sind</strong> nicht <strong>direkt</strong> für das Rendern eines Teils der Anzeige verantwortlich. </p><br></li><li><p>  RenderObjectElement </p><br><p>  Diese Elemente sind für Teile des angezeigten Bildes auf dem Bildschirm verantwortlich. </p><br></li></ul><br><p>  Großartig!  So viele Informationen, aber wie hängt das alles zusammen und warum ist es interessant, darüber zu sprechen? </p><br><h2 id="kak-vidzhety-i-elementy-rabotayut-vmeste">  Wie Widgets und Elemente zusammenarbeiten </h2><br><blockquote>  <em>In Flutter basieren alle Mechaniken auf der Ungültigmachung eines Elements oder Renderobjekts.</em> </blockquote><p>  Die Ungültigmachung von Elementen kann auf folgende Arten erfolgen: </p><br><ul><li>  Verwenden von <code>setState</code> , wodurch das gesamte <strong>StatefulElement</strong> ungültig wird (beachte, dass ich <em>StatefulWidget</em> absichtlich nicht sage) </li><li>  durch Benachrichtigungen, die von <strong>proxyElement</strong> verarbeitet werden (z. B. InheritedWidget), wodurch jedes <em>Element</em> ungültig wird <em>,</em> das von diesem <em>proxyElement abhängt</em> </li></ul><br><p>  Das Ergebnis der <em>Ungültigkeit</em> ist, dass in der Liste der <strong>fehlerhaften</strong> Elemente ein Link zu dem entsprechenden <em>Element</em> angezeigt wird. </p><br><p>  Die <em>Ungültigkeit von renderObject</em> bedeutet, dass sich die Struktur der Elemente überhaupt nicht ändert, aber es gibt eine Änderung auf der Ebene von <em>renderObject</em> , zum Beispiel: </p><br><ul><li>  Änderung seiner Größe, Position, Geometrie ... </li><li>  Etwas muss neu gestrichen werden, zum Beispiel, wenn Sie nur die Hintergrundfarbe, den Schriftstil ... ändern. </li></ul><br><p>  Das Ergebnis einer solchen <em>Invalidierung</em> ist eine Verknüpfung zu dem entsprechenden <em>RenderObject</em> in der Liste der <em>Renderobjekte (RenderObjects)</em> , die neu erstellt oder <em>überarbeitet werden</em> müssen. </p><br><p>  Unabhängig von der Art der Invalidierung wird <strong>SchedulerBinding</strong> aufgerufen (nicht vergessen?), Um die <strong>Flutter Engine aufzufordern</strong> , einen neuen Frame zu planen. </p><br><p>  Dies ist genau der Moment, in dem die <em>Flutter Engine</em> das <em>SchedulerBinding</em> "aufweckt" und all die Magie passiert ... </p><br><h2 id="ondrawframe">  onDrawFrame () </h2><br><p>  Weiter oben in diesem Artikel haben wir festgestellt, dass <em>SchedulerBinding</em> zwei Hauptaufgaben hat, von denen eine die Bereitschaft ist, Anforderungen von <em>Flutter Engine im</em> Zusammenhang mit der Frame-Neuerstellung zu verarbeiten.  Dies ist der perfekte Moment, um sich darauf zu konzentrieren. </p><br><p>  Das folgende Teilsequenzdiagramm zeigt, was passiert, wenn <em>SchedulerBinding</em> eine <em>onDrawFrame () -</em> Anforderung von der <em>Flutter Engine</em> empfängt. </p><br><p><img src="https://habrastorage.org/webt/b8/mz/ba/b8mzbav2krwuwat0ibyvd5gngs4.png"></p><br><p>  <strong>Schritt 1. Elemente</strong> </p><br><p>  <em>WidgetsBinding</em> wird <em>aufgerufen</em> und diese Bindung berücksichtigt zuerst die mit den Elementen verbundenen Änderungen.  <em>WidgetsBinding</em> ruft die <em>buildScope-</em> Methode des <em>buildOwner-</em> Objekts auf, da <strong>BuildOwner</strong> für die Verarbeitung des <strong>Elementbaums</strong> verantwortlich ist.  Diese Methode durchsucht die Liste der <em>fehlerhaften</em> Elemente und fordert deren <strong>Neuerstellung an</strong> . </p><br><p>  Die Hauptprinzipien dieser <code>rebuild()</code> ( <code>rebuild()</code> ) sind: </p><br><ol><li>  Es besteht eine Anforderung, das Element neu zu <code>build()</code> (dies wird die meiste Zeit in <code>Widget build (BuildContext context) {...}</code> nehmen), wobei die <code>build()</code> -Methode des Widgets <code>Widget build (BuildContext context) {...}</code> , auf das sich dieses Element bezieht (= <code>Widget build (BuildContext context) {...}</code> -Methode).  Diese <code>build()</code> -Methode gibt ein neues Widget zurück </li><li>  Wenn das Element keine <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">untergeordneten</a></em> Elemente hat, wird ein Element für das neue Widget erstellt (siehe unten) ( <em>Hinweis: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">inflateWidget</a></em> ), andernfalls </li><li>  Das neue Widget wird mit dem Widget verglichen, auf das das untergeordnete Element des Elements verweist <br><ul><li>  Wenn sie austauschbar sind (= <em>derselbe Widget-Typ und -Schlüssel</em> ), erfolgt die Aktualisierung und das untergeordnete Element wird gespeichert. </li><li>  Wenn sie nicht austauschbar sind, wird das untergeordnete Element verworfen ( <em>~ verworfen</em> ) und ein Element für das neue Widget erstellt </li></ul></li><li>  Dieses neue Element wird als untergeordnetes Element des Elements bereitgestellt.  ( <em>montiert)</em> = in den Elementbaum eingefügt) </li></ol><br><p>  Die folgende Animation soll diese Erklärung etwas klarer machen. </p><br><p><img src="https://habrastorage.org/webt/71/91/xc/7191xcnbg00lbho_ol_9vaczdca.gif"></p><br><p>  <strong>Hinweis zu Widgets und Elementen</strong> </p><br><p>  Für ein neues Widget wird ein Element eines <em>bestimmten Typs</em> erstellt, das <em>der</em> Widget- <em>Kategorie entspricht</em> , nämlich: </p><br><ul><li>  <em>InheritedWidget</em> -&gt; <em>InheritedElement</em> </li><li>  <em>StatefulWidget</em> -&gt; <em>StatefulElement</em> </li><li>  <em>StatelessWidget</em> -&gt; <em>StatelessElement</em> </li><li>  <em>InheritedModel</em> -&gt; <em>InheritedModelElement</em> </li><li>  <em>InheritedNotifier</em> -&gt; <em>InheritedNotifierElement</em> </li><li>  <em>LeafRenderObjectWidget</em> -&gt; <em>LeafRenderObjectElement</em> </li><li>  <em>SingleChildRenderObjectWidget</em> -&gt; <em>SingleChildRenderObjectElement</em> </li><li>  <em>MultiChildRenderObjectWidget</em> -&gt; <em>MultiChildRenderObjectElement</em> </li><li>  <em>ParentDataWidget</em> -&gt; <em>ParentDataElement</em> </li></ul><br><p>  Jeder dieser Elementtypen hat sein eigenes Verhalten.  Zum Beispiel: </p><br><ul><li>  <em>StatefulElement</em> ruft bei der Initialisierung die Methode <code>widget.createState()</code> auf, die einen <code>widget.createState()</code> erstellt und mit dem Element verknüpft </li><li>  Wenn ein Element vom Typ <em>RenderObjectElement</em> angehängt wird, wird ein <em>RenderObject erstellt</em> .  Dieses <em>renderObject</em> wird dem <em>Render Tree</em> hinzugefügt und dem Element zugeordnet. </li></ul><br><p>  <strong>Schritt 2. renderObjects</strong> </p><br><p>  Nachdem Sie nun alle mit <em>schmutzigen</em> Elementen verbundenen Aktionen ausgeführt haben, ist der Elementbaum stabil.  Es ist also Zeit, den Visualisierungsprozess zu betrachten. </p><br><p>  Da <em>RendererBinding</em> für das Rendern des <em>Renderbaums verantwortlich ist,</em> ruft <code>drawFrame</code> die <code>drawFrame</code> <em>RendererBinding-</em> Methode auf. </p><br><p>  Das folgende <em>Teildiagramm</em> zeigt die Reihenfolge der Aktionen, die während der <em>drawFrame () -</em> Anforderung ausgeführt wurden. </p><br><p><img src="https://habrastorage.org/webt/dp/sw/v3/dpswv3gszlwj3f_zwsak0xq91k0.png"></p><br><p>  In diesem Schritt werden die folgenden Aktionen ausgeführt: </p><br><ul><li>  Jedes als <em>unsauber</em> markierte <em>Renderobjekt</em> wird aufgefordert, es zu komponieren (d. H. Seine Größe und Geometrie zu berechnen). </li><li>  Jedes <em>RenderObject,</em> das als "neu zu zeichnen" markiert ist, wird mit seiner eigenen <em>Ebenenmethode</em> neu gezeichnet </li><li>  Die resultierende Szene wird gebildet und an die <em>Flutter Engine</em> gesendet, damit diese sie auf den <em>Gerätebildschirm</em> überträgt </li><li>  Schließlich wird auch die Semantik aktualisiert und an die <em>Flutter Engine</em> gesendet </li></ul><br><p>  Am Ende dieses Workflows wird der Gerätebildschirm aktualisiert. </p><br><h1 id="chast-3-obrabotka-zhestov">  Teil 3: Umgang mit Gesten </h1><br><p>  Gesten (= <em>Ereignisse im Zusammenhang</em> mit <em>Fingeraktionen</em> <em>auf dem Glas</em> ) werden mit <em>GestureBinding</em> verarbeitet. </p><br><p>  Wenn die <em>Flutter-Engine</em> Informationen zu einem Gestenereignis über die <em>window.onPointerDataPacket-</em> API <strong>sendet,</strong> fängt sie die <strong>GestureBinding ab</strong> , führt eine Pufferung durch und führt <strong>Folgendes aus</strong> : </p><br><ol><li>  konvertiert die von der <em>Flutter Engine</em> angegebenen Koordinaten so, dass sie dem <em>Pixelverhältnis</em> des <strong>Geräts entsprechen</strong> </li><li>  <em>Ruft</em> aus <em>renderView eine</em> Liste aller <em>RenderObjects ab</em> , die sich in dem Teil des Bildschirms befinden, der sich auf die Koordinaten des Ereignisses bezieht </li><li>  <em>Durchläuft</em> dann die resultierende Liste von <em>renderObjects</em> und sendet ein zugehöriges Ereignis an jedes von ihnen </li><li>  Wenn <em>renderObject</em> Ereignisse dieses Typs "abhört", verarbeitet es sie </li></ol><br><p>  Hoffentlich verstehe ich jetzt, wie wichtig <em>renderObjects ist</em> . </p><br><h1 id="chast-4-animacii">  Teil 4: Animationen </h1><br><p>  In diesem Teil des Artikels geht es um das Konzept der <strong>Animation</strong> und ein tiefes Verständnis des <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Tickers</a></strong> . </p><br><p>  Wenn Sie mit Animationen arbeiten, verwenden Sie normalerweise einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">AnimationController</a> oder ein anderes Widget für Animationen ( <em>Hinweis: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">AnimatedCrossFade</a></em> ). </p><br><p>  In <em>Flutter</em> bezieht sich alles <em>,</em> was mit Animationen zu <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">tun hat,</a></em> auf den <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Ticker</a></em> .  Wenn der <em>Ticker</em> aktiv ist, hat er nur eine Aufgabe: "Er fordert <em>SchedulerBinding auf</em> , einen Rückruf <em>zu</em> registrieren und die <em>Flutter Engine anzuweisen, ihn</em> zu aktivieren, wenn ein neuer Rückruf angezeigt wird."  Wenn die <em>Flutter Engine</em> bereit ist, ruft sie <em>SchedulerBinding</em> über eine Anforderung auf: " <em>onBeginFrame</em> ".  <em>SchedulerBinding</em> greift auf die <em>Ticker-</em> Rückrufliste zu und führt jede aus. </p><br><p>  Jeder <em>Tick ​​wird</em> von einem "interessierten" Controller abgefangen, um ihn zu verarbeiten.  Wenn die Animation abgeschlossen ist, ist der <em>Ticker</em> deaktiviert, andernfalls fordert der <em>Ticker</em> eine <em>SchedulerBinding</em> auf, einen neuen Rückruf zu planen.  Usw... </p><br><h1 id="polnaya-kartina">  Vollbild </h1><br><p>  Jetzt haben wir gelernt, wie <em>Flutter</em> funktioniert: </p><br><p><img src="https://habrastorage.org/webt/5s/tw/w7/5stww7o_izlc6ywpnkmcfkkllbk.png"></p><br><h1 id="buildcontext">  Buildcontext </h1><br><p>  Kehren Sie schließlich zu dem Diagramm zurück, das die verschiedenen Elementtypen zeigt, und betrachten Sie die Signatur des <em>Stammelements</em> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Element</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DiagnosticableTree</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BuildContext</span></span></span><span class="hljs-class"> </span></span>{ ... }</code> </pre> <br><p>  Wir sehen den sehr berühmten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">BuildContext</a> !  Aber was ist es </p><br><p>  <strong>BuildContext</strong> ist eine Schnittstelle, die eine Reihe von Gettern und Methoden definiert, die von einem Element implementiert werden können.  Meist wird <em>BuildContext</em> in der <code>build()</code> -Methode von <em>StatelessWidget</em> oder <em>State</em> für <em>StatefulWidget verwendet</em> . </p><br><blockquote>  <em><strong>BuildContext</strong> ist nichts anderes als das <strong>Element</strong> selbst, das übereinstimmt</em> <br><ul><li>  <em>Widget wird aktualisiert (innerhalb der <code>build</code> oder <code>builder</code> Methoden)</em> </li><li>  <em>StatefulWidget, das dem Status zugeordnet ist, in dem Sie auf die Kontextvariable verweisen.</em> </li></ul><br></blockquote><p>  Dies bedeutet, dass die meisten Entwickler ständig mit Elementen arbeiten, ohne es zu wissen. </p><br><h2 id="naskolko-poleznym-mozhet-byt-buildcontext">  Wie nützlich kann ein BuildContext sein? </h2><br><p>  <em>BuildContext</em>  ,   ,      ,  <em>BuildContext</em>   ,  : </p><br><ul><li>     <em>RenderObject</em> ,   (,     <em>Renderer</em> ,  -) </li><li>   <em>RenderObject</em> </li><li>   .     ,     <code>of</code> (, <code>MediaQuery.of(context)</code> , <code>Theme.of(context)</code> …) </li></ul><br><h2 id="zabavy-radi">   </h2><br><p> ,   ,  <em>BuildContext</em> –  <em></em> ,         .  <strong> </strong>   <em>StatelessWidget</em>   ,      <em>StatefulWidget</em> ,    <code>setState()</code> ,    <em>BuildContext</em> . </p><br><blockquote> <strong></strong> <br> <strong>,    !</strong> <br><br>    – ,  <em>StatelessWidget</em>   . <br>       , ,  <em>StatefulWidget</em> . </blockquote><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ runApp(MaterialApp(home: TestPage(),)); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestPage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// final because a Widget is immutable (remember?) final bag = {"first": true}; @override Widget build(BuildContext context){ return Scaffold( appBar: AppBar(title: Text('Stateless ??')), body: Container( child: Center( child: GestureDetector( child: Container( width: 50.0, height: 50.0, color: bag["first"] ? Colors.red : Colors.blue, ), onTap: (){ bag["first"] = !bag["first"]; // // This is the trick // (context as Element).markNeedsBuild(); } ), ), ), ); } }</span></span></code> </pre> <br><p> <em> ,    <code>setState()</code> ,         : <code>_element.markNeedsBuild()</code> .</em> </p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>  : "   ".   ,      ,    <em>Flutter</em> ,   ,    ,   ,      .  ,  ,   <em>Widget</em> , <em>Element</em> , <em>BuildContext</em> , <em>RenderObject</em> ,     .   ,       . </p><br><p>     .       . </p><br><p> PS  ,          () . <br> PSS       <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Flutter internals</a></strong>  Didier Boelens,           ) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de476018/">https://habr.com/ru/post/de476018/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de476000/index.html">ML.NET Model Builder-Aktualisierungen</a></li>
<li><a href="../de476002/index.html">Erfahrung in der Suche nach einer Doktorandenstelle in Deutschland</a></li>
<li><a href="../de476004/index.html">Projektleiter - Mythos oder Realität? Oder warum wird es im Bereich der visuellen Effekte benötigt?</a></li>
<li><a href="../de476006/index.html">Mythen und Legenden der SOC-Erbauer oder 3 Missverständnisse über Zentren zur Überwachung und Reaktion auf Cyberangriffe</a></li>
<li><a href="../de476008/index.html">MOSDROID Meetup: Verbinde dich mit dem Broadcast</a></li>
<li><a href="../de476022/index.html">Vue Storefront: Das Backend erweitern</a></li>
<li><a href="../de476024/index.html">Beste Architektur für MVP: Monolith, SOA, Microservices oder Serverless? Teil 1</a></li>
<li><a href="../de476026/index.html">Cool Life Hacks für die Arbeit mit WSL (Windows-Subsystem für Linux)</a></li>
<li><a href="../de476032/index.html">Brunner Elektronik - Vom CAD-System ins Cockpit</a></li>
<li><a href="../de476034/index.html">Am wehrlosesten ist der Wanderfalke</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>