<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçüè≠ üë©‚Äçüëß‚Äçüëß üé™ So funktioniert Flattern üßöüèø ‚óæÔ∏è üõãÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wie funktioniert Flutter eigentlich? 


 Was sind Widgets, Elemente, BuildContext, RenderOject, Bindungen? .. 


 Schwierigkeit: Anf√§nger 
 Eintrag 

...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So funktioniert Flattern</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476018/"><p><img src="https://habrastorage.org/webt/xo/f8/wq/xof8wqtuioee7o5ztrhyyb7hriq.png"></p><br><p>  Wie funktioniert Flutter eigentlich? </p><br><p>  Was sind Widgets, Elemente, BuildContext, RenderOject, Bindungen? .. </p><br><p>  Schwierigkeit: <em>Anf√§nger</em> </p><br><h1 id="vstuplenie">  Eintrag </h1><br><p>  Letztes Jahr ( <em>Anmerkung: 2018</em> ), als ich meine Reise in die fabelhafte Welt von Flutter antrat, gab es im Internet nur sehr wenige Informationen im Vergleich zu dem, was es heute ist.  Trotz der Tatsache, dass bereits viele Materialien geschrieben wurden, spricht nur ein kleiner Teil davon dar√ºber, wie Flutter tats√§chlich funktioniert. </p><br><p>  Was sind Widgets ( <em>Widgets</em> ), Elemente ( <em>Elemente</em> ), BuildContext?  Warum flattert es so schnell?  Warum funktioniert es manchmal nicht wie erwartet?  Was sind B√§ume und warum werden sie ben√∂tigt? </p><br><p>  In 95% der F√§lle besch√§ftigen Sie sich beim Schreiben einer Anwendung nur mit Widgets, um etwas anzuzeigen oder damit zu interagieren.  Aber haben Sie sich nie wirklich gefragt, wie all diese Magie in Ihnen wirkt?  Woher wei√ü das System, wann der Bildschirm aktualisiert werden muss und welche Teile aktualisiert werden m√ºssen? </p><br><p>  <strong>Inhalt:</strong> </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eintrag</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1: Hintergrund</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein bisschen √ºber das Ger√§t</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schnittstelle zwischen Code und Ger√§t</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwalten des Flutter Framework Flutter Engine-Renderings</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RenderView und RenderObject</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Initialisierungsbindungen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SchedulerBinding</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gestenbindung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Renderer-Bindung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Widgets verbindlich</a> <a name="habracut"></a></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2. Von Widgets zu Pixeln</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unver√§nderliche Konfiguration</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die hierarchische Struktur von Widgets</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wald hinter den B√§umen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grundlegendes zum Element in einem Baum</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3 Kategorien von Widgets</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikeltypen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie Widgets und Elemente zusammenarbeiten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">onDrawFrame ()</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3: Umgang mit Gesten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 4: Animationen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vollbild</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Buildcontext</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie n√ºtzlich kann ein BuildContext sein?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zum Spa√ü</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fazit</a> </li></ul><br><h1 id="chast-1-predystoriya">  Teil 1: Hintergrund </h1><br><p>  Der erste Teil des Artikels stellt einige Schl√ºsselkonzepte vor, die im zweiten Teil des Materials verwendet werden und zum besseren Verst√§ndnis von Flutter beitragen. </p><br><h2 id="nemnogo-ob-ustroystve">  Ein bisschen √ºber das Ger√§t </h2><br><p>  Beginnen wir am Ende und kehren zu den Grundlagen zur√ºck. </p><br><p>  Wenn Sie sich Ihr Ger√§t oder genauer gesagt die Anwendung ansehen, die auf Ihrem Ger√§t ausgef√ºhrt wird, sehen Sie nur den Bildschirm. </p><br><p>  In der Tat sehen Sie nur die Pixel, die zusammen ein zweidimensionales Bild ergeben. Wenn Sie den Bildschirm mit dem Finger ber√ºhren, erkennt das Ger√§t nur die Position Ihres Fingers auf dem Glas. </p><br><p>  In den meisten F√§llen besteht die Magie der Anwendung (visuell gesehen) darin, dieses Bild auf der Grundlage der folgenden Interaktionen zu aktualisieren: </p><br><ul><li>  mit dem Ger√§tebildschirm ( <em>zum Beispiel ein Finger auf dem Glas</em> ) </li><li>  mit dem Netzwerk ( <em>z. B. Kommunikation mit dem Server</em> ) </li><li>  im Laufe der Zeit ( <em>z. B. Animation</em> ) </li><li>  mit anderen externen Sensoren </li></ul><br><p>  Die Visualisierung des Bildes auf dem Bildschirm erfolgt durch Hardware (Display), die die Anzeige regelm√§√üig (in der Regel 60 Mal pro Sekunde) aktualisiert.  Dies wird als "Bildwiederholfrequenz" bezeichnet und in Hz (Hertz) ausgedr√ºckt. </p><br><p>  Das Display erh√§lt Informationen zur Anzeige von der GPU (Graphics Processing Unit), einer speziellen elektronischen Schaltung, die optimiert und so konzipiert ist, dass aus einigen Daten (Polygonen und Texturen) schnell Bilder erzeugt werden.  Die Anzahl der Male pro Sekunde, die der Grafikprozessor ein "Bild" (= Bildpuffer) erzeugen kann, um es anzuzeigen und an die Hardware zu senden, wird als Bildrate bezeichnet ( <em>Hinweis: Bildrate</em> ).  Dies wird unter Verwendung eines Blocks von Bildern pro Sekunde ( <em>z. B. 60 Bilder pro Sekunde oder 60 fps</em> ) <em>gemessen</em> . </p><br><p>  Sie m√∂gen mich fragen, warum ich diesen Artikel mit den Konzepten eines zweidimensionalen Bildes begonnen habe, das von einer GPU / Hardware und einem physischen Glassensor angezeigt wird, und wie ist der Zusammenhang mit normalen Flutter-Widgets? </p><br><p>  Ich denke, es wird einfacher zu verstehen sein, wie Flutter tats√§chlich funktioniert, wenn wir es aus dieser Sicht betrachten, da eines der Hauptziele der Flutter-Anwendung darin besteht, dieses zweidimensionale Bild zu erstellen und es ihm zu erm√∂glichen, damit zu interagieren.  Auch weil in Flutter, ob Sie es glauben oder nicht, ist fast alles auf die Notwendigkeit zur√ºckzuf√ºhren, den Bildschirm schnell und zum richtigen Zeitpunkt zu aktualisieren! </p><br><h2 id="interfeys-mezhdu-kodom-i-ustroystvom">  Schnittstelle zwischen Code und Ger√§t </h2><br><p>  Jedenfalls hat jeder, der sich f√ºr Flutter interessiert, bereits das folgende Bild gesehen, das Flutters <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">High-Level-Architektur beschreibt</a> . </p><br><p><img src="https://habrastorage.org/webt/i0/tp/fo/i0tpfoumlz1ultkyzqywfm9-osa.png"></p><br><p>  Wenn wir eine Flutter-Anwendung mit Dart schreiben, bleiben wir auf der Ebene des <em>Flutter-Frameworks</em> (gr√ºn hervorgehoben). </p><br><p>  <em>Das Flutter Framework</em> interagiert mit der <em>Flutter Engine</em> (blau) √ºber eine Abstraktionsebene namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Window</a> .  Diese Abstraktionsebene bietet eine Reihe von APIs f√ºr die indirekte Interaktion mit dem Ger√§t. </p><br><p>  Durch diese Abstraktionsebene benachrichtigt die <em>Flutter</em> <em>Engine</em> das <em>Flutter Framework,</em> wenn: </p><br><ul><li>  Ein Ereignis von Interesse tritt auf Ger√§teebene auf (√Ñnderung der Ausrichtung, √Ñnderung der Einstellungen, Speicherproblem, Betriebszustand der Anwendung ...) </li><li>  Ein Ereignis tritt auf der Glasebene auf (= Geste) </li><li>  Plattformkanal sendet einige Daten </li><li>  aber auch haupts√§chlich, wenn die <strong>Flutter Engine bereit ist, einen neuen Frame zu rendern</strong> </li></ul><br><h2 id="upravlenie-flutter-framework-renderingom-flutter-engine">  Verwalten des Flutter Framework Flutter Engine-Renderings </h2><br><p>  Es ist schwer zu glauben, aber es ist wahr.  Mit Ausnahme einiger F√§lle ( <em>siehe unten</em> ) wird kein <em>Flutter Framework-</em> Code ausgef√ºhrt, ohne das <em>Flutter Engine-</em> Rendering zu starten. </p><br><p>  Ausnahmen: </p><br><ul><li>  Geste / Geste (= Ereignis auf Glas) </li><li>  Plattformnachrichten (= von einem Ger√§t generierte Nachrichten, z. B. GPS) </li><li>  Ger√§temeldungen (= Meldungen, die sich auf eine √Ñnderung des Ger√§testatus beziehen, z. B. Ausrichtung, im Hintergrund gesendete Anwendung, Speicherwarnungen, Ger√§teeinstellungen ...) </li><li>  Zuk√ºnftige oder http-Antworten </li></ul><br><p>  <em>(Zwischen uns k√∂nnen Sie tats√§chlich eine visuelle √Ñnderung vornehmen, ohne von der Flutter Engine aus aufzurufen. Dies wird jedoch <strong>nicht empfohlen.</strong> )</em> </p><br><p>  Sie fragen mich: "Wenn ein Code im Zusammenhang mit der <em>Geste</em> ausgef√ºhrt wird und eine visuelle √Ñnderung verursacht, oder wenn ich einen <em>Timer verwende</em> , um die H√§ufigkeit der Aufgabe festzulegen, die zu visuellen √Ñnderungen f√ºhrt (z. B. Animation), wie funktioniert das?" </p><br><p>  Wenn Sie m√∂chten, dass eine visuelle √Ñnderung auftritt oder ein Code basierend auf einem Timer ausgef√ºhrt wird, m√ºssen Sie der <em>Flutter-Engine</em> mitteilen, dass etwas gezeichnet werden muss. </p><br><p>  Normalerweise ruft die <em>Flutter Engine bei</em> der n√§chsten Aktualisierung das <em>Flutter Framework</em> auf, um Code auszuf√ºhren, und stellt schlie√ülich eine neue Szene zum Rendern bereit. </p><br><p>  Daher ist eine wichtige Frage, wie die Flutter-Engine das gesamte Anwendungsverhalten basierend auf dem Rendern organisiert. </p><br><p>  Sehen Sie sich die folgende Animation an, um sich ein Bild von den internen Mechanismen zu machen: </p><br><p><img src="https://habrastorage.org/webt/zu/7s/ig/zu7sigrkekrmz8ha_83cvr88ynk.gif"></p><br><p>  Eine kurze Erkl√§rung (weitere Details folgen sp√§ter): </p><br><ul><li>  Einige externe Ereignisse (Gesten, HTTP-Antworten usw.) oder sogar Zuk√ºnfte k√∂nnen Aufgaben ausl√∂sen, die eine Aktualisierung der Anzeige erforderlich machen.  Die entsprechende Nachricht wird an die <em>Flutter Engine</em> gesendet (= <em>Schedule Frame</em> ) </li><li>  Wenn die <em>Flutter Engine</em> bereit ist, das Rendering zu aktualisieren, erstellt sie eine Anforderung f√ºr den <em>Frame-</em> Beginn </li><li>  Diese Anforderung f√ºr <em>Frame-Beginn</em> wird vom <em>Flutter Framework</em> abgefangen, das Aufgaben ausf√ºhrt, die haupts√§chlich mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Tickern zusammenh√§ngen</a> (z. B. Animation). </li><li>  Diese Tasks k√∂nnen die Anforderung f√ºr ein sp√§teres Rendern neu erstellen (Beispiel: Die Animation wurde noch nicht ausgef√ºhrt, und zum Abschluss muss zu einem sp√§teren Zeitpunkt ein weiterer <em>Startframe abgerufen werden.</em> ) </li><li>  Als N√§chstes sendet die <em>Flutter Engine</em> einen <em>Draw Frame</em> , der vom <em>Flutter Framework</em> abgefangen wird und nach Aufgaben sucht, die mit der Aktualisierung des Layouts in Bezug auf Struktur und Gr√∂√üe zusammenh√§ngen </li><li>  Nachdem alle diese Aufgaben erledigt sind, f√§hrt er mit den Aufgaben fort, die mit der Aktualisierung des Layouts in Bezug auf das Rendern verbunden sind </li><li>  Wenn auf dem Bildschirm etwas gezeichnet werden muss, wird eine neue Szene ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Scene</a> ) zur Visualisierung an die <em>Flutter Engine</em> gesendet, die den Bildschirm aktualisiert </li><li>  Das <em>Flutter Framework</em> f√ºhrt <em>dann</em> alle Aufgaben aus, die nach dem Rendern ausgef√ºhrt werden (= PostFrame-R√ºckrufe), sowie alle weiteren nachfolgenden Aufgaben, die sich nicht auf das Rendern beziehen </li><li>  ... und dieser Prozess beginnt von vorne </li></ul><br><h2 id="renderview-i-renderobject">  RenderView und RenderObject </h2><br><p>  Bevor Sie sich mit den Details des Workflows befassen, ist es Zeit, das Konzept des <em>Rendering-Baums</em> vorzustellen. </p><br><p>  Wie bereits erw√§hnt, wird irgendwann alles in Pixel konvertiert, die auf dem Bildschirm angezeigt werden, und das <em>Flutter Framework</em> konvertiert die <em>Widgets</em> , mit denen wir die Anwendung entwickeln, in visuelle Bl√∂cke, die auf dem Bildschirm angezeigt werden. </p><br><p>  Diese visuellen Teile entsprechen Objekten mit dem Namen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">RenderObject</a> , die verwendet werden, um: </p><br><ul><li>  Definieren eines bestimmten Bereichs des Bildschirms in Bezug auf Gr√∂√üe, Position, Geometrie sowie in Bezug auf <em>"gerenderten Inhalt"</em> </li><li>  Bereiche des Bildschirms identifizieren, die von Gesten betroffen sein k√∂nnen (= Fingerber√ºhrung) </li></ul><br><p>  Ein Satz aller <em>RenderObjects</em> bildet einen Baum, der als <em>Render Tree bezeichnet wird</em> .  Oben in diesem Baum (= <em>root</em> ) befindet sich eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">RenderView</a> . </p><br><p>  <em>RenderView</em> bietet eine gemeinsame Oberfl√§che f√ºr <em>Render Tree-</em> Objekte und ist eine spezielle Version von <em>RenderObject</em> . </p><br><p>  Optisch k√∂nnten wir das alles wie folgt darstellen: <br><img src="https://habrastorage.org/webt/yi/aq/6v/yiaq6vvo9ssed0qtewkftfwrmpy.png"></p><br><p>  Die Beziehung zwischen <em>Widget</em> und <em>RenderObject</em> wird sp√§ter erl√§utert.  In der Zwischenzeit ist es Zeit, etwas tiefer zu gehen ... </p><br><h2 id="inicializaciya-bindings">  Initialisierungsbindungen </h2><br><p> Wenn die Flutter-Anwendung <code>runApp(Widget app)</code> wird, wird zuerst die <code>main()</code> -Funktion aufgerufen, die letztendlich die <code>runApp(Widget app)</code> Methode <code>runApp(Widget app)</code> . </p><br><p>  Wenn die <code>runApp()</code> -Methode <code>runApp()</code> initialisiert das <em>Flutter Framework</em> die Schnittstellen zwischen sich und der <em>Flutter Engine</em> .  Diese Schnittstellen werden <strong>Bindungen genannt</strong> ( <em>Anmerkung: Bindungen</em> ). </p><br><p>  <strong>Einf√ºhrung in Bindungen</strong> </p><br><p>  Bindungen sind als Bindeglied zwischen dem Framework und der Flutter-Engine konzipiert.  Nur durch Bindungen k√∂nnen Daten zwischen dem <em>Flutter Framework</em> und der <em>Flutter Engine</em> ausgetauscht werden. <br>  <em>(Es gibt nur eine Ausnahme von dieser Regel -</em> RenderView <em>, aber wir werden dies sp√§ter diskutieren).</em> </p><br><p>  Jede Bindung ist f√ºr die Verarbeitung einer Reihe spezifischer Aufgaben, Aktionen und Ereignisse verantwortlich, die nach T√§tigkeitsbereichen gruppiert sind. </p><br><p>  Zum Zeitpunkt des Schreibens dieses <em>Dokuments</em> verf√ºgt das <em>Flutter Framework</em> √ºber 8 Bindungen. </p><br><p>  Im Folgenden sind 4 davon aufgef√ºhrt, die in diesem Artikel behandelt werden: </p><br><ul><li>  <em>SchedulerBinding</em> </li><li>  <em>Gestenbindung</em> </li><li>  <em>Renderer-Bindung</em> </li><li>  <em>Widgets verbindlich</em> </li></ul><br><p>  Der Vollst√§ndigkeit halber erw√§hne ich die restlichen 4: </p><br><ul><li>  <em>ServicesBinding</em> : Verantwortlich f√ºr die Verarbeitung der vom <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Plattformkanal gesendeten</a></em> Nachrichten </li><li>  <em>PaintingBinding</em> : Verantwortlich f√ºr die Verarbeitung des Bild-Cache </li><li>  <em>SemanticsBinding</em> : reserviert f√ºr die sp√§tere Implementierung von allem, was mit Semantik zu tun hat </li><li>  <em>TestWidgetsFlutterBinding</em> : <em>Wird</em> von der Widget- <em>Testbibliothek</em> verwendet </li></ul><br><p>  Sie k√∂nnen auch <em>WidgetsFlutterBinding</em> erw√§hnen, dies ist jedoch nicht wirklich eine Bindung, sondern eher eine Art <em>"Bindungsinitialisierer".</em> </p><br><p>  Das folgende Diagramm zeigt die Interaktion zwischen den Bindungen, die ich als N√§chstes betrachten werde, und der <em>Flutter-Engine</em> . </p><br><p><img src="https://habrastorage.org/webt/ws/ph/x_/wsphx_tme3caqf0qimfk0wxur9g.png"></p><br><p>  Schauen wir uns jede dieser ‚ÄûKern‚Äú -Bindungen an. </p><br><h3 id="schedulerbinding">  SchedulerBinding </h3><br><p>  Diese Bindung hat zwei Hauptaufgaben: </p><br><ul><li>  Sagen Sie " <em>Flutter Engine</em> <em>"</em> : <em>"Hey! Wenn Sie das n√§chste Mal nicht besch√§ftigt sind, wecken Sie mich auf, damit ich ein bisschen arbeiten und Ihnen sagen kann, was Sie rendern sollen, oder wenn Sie mich sp√§ter anrufen m√ºssen ..."</em> </li><li>  H√∂ren Sie zu und reagieren Sie auf solche <em>‚Äûst√∂renden Erwachen‚Äú</em> (siehe unten) </li></ul><br><p>  Wann <em>fordert SchedulerBinding</em> einen <em>Weckruf an</em> ? </p><br><ul><li><p>  Wann muss der <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Ticker</a></em> <em>einen</em> neuen <em>Tick</em> <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">ausarbeiten</a></em> <em>?</em> </p><br><p>  Wenn Sie beispielsweise eine Animation haben, starten Sie diese.  Die Animation wird mit dem <em>Ticker</em> beschnitten, der in regelm√§√üigen Abst√§nden (= <em>Tick</em> ) aufgerufen wird, um einen <em>Callback</em> durchzuf√ºhren.  Um einen solchen <em>Callback</em> zu starten, m√ºssen wir der <em>Flutter Engine</em> mitteilen, dass sie uns beim n√§chsten Update (= <em>Begin Frame</em> ) aufweckt.  Dadurch wird der <em>Ticker-</em> R√ºckruf gestartet, um seine Aufgabe abzuschlie√üen.  Wenn der <em>Ticker</em> weiterhin ausgef√ºhrt werden muss, ruft er am Ende seiner Aufgabe <em>SchedulerBinding</em> auf, um einen weiteren Frame zu planen. </p><br></li><li><p>  Wann muss die Anzeige aktualisiert werden? </p><br><p>  Beispielsweise m√ºssen wir ein Ereignis ausarbeiten, das zu einer visuellen √Ñnderung f√ºhrt (Beispiel: Aktualisieren der Farbe eines Teils des Bildschirms, Scrollen, Hinzuf√ºgen / Entfernen von Elementen vom Bildschirm). Dazu m√ºssen wir die erforderlichen Schritte ausf√ºhren, um das aktualisierte Bild schlie√ülich auf dem Bildschirm anzuzeigen.  In diesem Fall ruft das <em>Flutter Framework</em> bei einer solchen √Ñnderung <em>SchedulerBinding</em> auf, um mithilfe der <em>Flutter Engine einen</em> anderen Frame zu planen.  <em>(Sp√§ter werden wir sehen, wie das tats√§chlich funktioniert)</em> </p><br></li></ul><br><h3 id="gesturebinding">  Gestenbindung </h3><br><p>  Diese Bindung lauscht der Interaktion mit der Engine im Sinne des <em>‚ÄûFingers‚Äú</em> (= <em>Geste</em> ). </p><br><p>  Insbesondere ist er daf√ºr verantwortlich, <em>fingerbezogene</em> Daten zu empfangen und zu bestimmen, mit welchem ‚Äã‚ÄãTeil des Bildschirms die Gesten arbeiten.  Er teilt diese Teile dann entsprechend mit. </p><br><h3 id="rendererbinding">  Renderer-Bindung </h3><br><p>  Diese Bindung ist die Verbindung zwischen der <em>Flutter-Engine</em> und dem <em>Render-Baum</em> .  Sie ist verantwortlich f√ºr: </p><br><ul><li>  Abh√∂ren von Ereignissen, die von der Engine generiert wurden, um √ºber vom Benutzer durch Ger√§teeinstellungen vorgenommene √Ñnderungen zu informieren, die sich auf visuelle Effekte und / oder Semantik auswirken </li><li>  Meldung an die Engine √ºber √Ñnderungen, die auf die Anzeige angewendet werden </li></ul><br><p>  Damit die √Ñnderungen auf dem Bildschirm angezeigt werden, ist <em>RendererBinding</em> f√ºr die Verwaltung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">PipelineOwners</a> und die Initialisierung der <strong>RenderView verantwortlich</strong> . </p><br><p>  <em>PipelineOwner</em> ist eine Art <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Orchester</a> , das wei√ü, was mit <em>RenderObject</em> entsprechend der <em>Komponente</em> zu tun ist, und diese Aktionen koordiniert. </p><br><h3 id="widgetsbinding">  Widgets verbindlich </h3><br><p>  Diese Bindung wartet auf √Ñnderungen, die vom Benutzer √ºber Ger√§teeinstellungen vorgenommen wurden, die sich auf die Sprache (= <em>Gebietsschema</em> ) und die <em>Semantik</em> auswirken. </p><br><blockquote>  <em>Kleine Notiz</em> <br><br>  <em>Ich gehe davon aus, dass zu einem sp√§teren Zeitpunkt in der Entwicklung von</em> Flutter <em>alle semantikbezogenen Ereignisse in das</em> SemanticsBinding √ºbertragen werden <em>, aber zum Zeitpunkt dieses Schreibens ist dies nicht der Fall.</em> </blockquote><p>  Dar√ºber hinaus ist <em>WidgetsBinding</em> die Verbindung zwischen Widgets und der <em>Flutter Engine</em> .  Sie ist verantwortlich f√ºr: </p><br><ul><li>  Verwaltung des Prozesses der Verarbeitung von Widget-Struktur√§nderungen </li><li>  Anruf t√§tigen </li></ul><br><p>  Die Bearbeitung von √Ñnderungen an der Struktur von Widgets erfolgt mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">BuildOwner</a> . </p><br><p>  <em>BuildOwner</em> verfolgt, welche Widgets neu erstellt werden m√ºssen, und verarbeitet andere Aufgaben, die f√ºr die Widgetstruktur insgesamt gelten. </p><br><h1 id="chast-2-ot-vidzhetov-k-pikselyam">  Teil 2. Von Widgets zu Pixeln </h1><br><p>  Nachdem wir nun die Grundlagen der internen Arbeit von <em>Flutter</em> kennen gelernt haben, ist es Zeit, √ºber Widgets zu sprechen. </p><br><p>  In allen Flutter-Dokumentationen lesen Sie, dass alle <em>Widgets</em> (Widgets). </p><br><p>  Das ist fast richtig.  Aber um ein bisschen genauer zu sein, w√ºrde ich eher sagen: </p><br><blockquote>  Auf Entwicklerseite erfolgt alles, was in Bezug auf Layout und Interaktion mit der Benutzeroberfl√§che zu tun hat, √ºber Widgets. </blockquote><p>  Warum so viel Genauigkeit?  Neben der Tatsache, dass <em>Widget</em> es dem Entwickler erm√∂glicht, einen Teil des Bildschirms in Bezug auf Gr√∂√üe, Inhalt, Layout und Interaktion zu bestimmen, <strong>steckt</strong> jedoch noch viel mehr dahinter.  Also, was ist <em>Widget</em> wirklich? </p><br><h2 id="neizmenyaemaya-konfiguraciya">  Unver√§nderliche Konfiguration </h2><br><p>  Wenn Sie sich den Quellcode von <em>Flutter</em> ansehen, werden Sie die folgende Definition der <em>Widget-</em> Klasse bemerken. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DiagnosticableTree</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({ </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.key })</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Key key; ... }</code> </pre> <br><p>  Was bedeutet das? </p><br><p>  Die Anmerkung <strong>"@immutable" ist</strong> sehr wichtig und besagt, dass <strong>jede Variable in der Widget-Klasse FINAL sein muss</strong> , mit anderen Worten: " <strong>EINMAL F√úR JEDEN</strong> definiert und zugewiesen."  Nach dem Erstellen einer Instanz kann Widget daher seine internen Variablen nicht mehr √§ndern. </p><br><blockquote>  <em>Da Widget unver√§nderlich ist, kann es als statische Konfiguration betrachtet werden.</em> </blockquote><br><h2 id="ierarhicheskaya-struktura-vidzhetov">  Die hierarchische Struktur von Widgets </h2><br><p>  Wenn Sie mit Flutter entwerfen, definieren Sie die Struktur Ihres Bildschirms (Ihrer Bildschirme) mit Widgets wie folgt: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SafeArea( child: Scaffold( appBar: AppBar( title: Text(<span class="hljs-string"><span class="hljs-string">'My title'</span></span>), ), body: Container( child: Center( child: Text(<span class="hljs-string"><span class="hljs-string">'Centered Text'</span></span>), ), ), ), ); }</code> </pre> <br><p>  In diesem Beispiel werden 7 Widgets verwendet, die zusammen eine hierarchische Struktur bilden.  Ein sehr vereinfachtes Schema, das auf diesem Code basiert, lautet wie folgt: </p><br><p><img src="https://habrastorage.org/webt/f2/ke/dt/f2kedtux7_ot2issfzbv64n3uak.png"></p><br><p>  Wie Sie sehen, sieht das dargestellte Diagramm wie ein Baum aus, in dem <em>SafeArea</em> die Wurzel ist. </p><br><h2 id="les-za-derevyami">  Wald hinter den B√§umen </h2><br><p>  Wie Sie bereits wissen, kann ein Widget selbst eine Zusammenfassung anderer Widgets sein.  Beispielsweise k√∂nnen Sie den vorherigen Code wie folgt √§ndern: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyOwnWidget(); }</code> </pre> <br><p>  Diese Option setzt voraus, dass das Widget <em>"MyOwnWidget"</em> selbst <em>SafeArea</em> , <em>Scaffold</em> <em>anzeigt</em> .  Aber das Wichtigste in diesem Beispiel ist das </p><br><blockquote>  <em>Ein Widget</em> kann ein Blatt, einen Knoten in einem Baum, sogar den Baum selbst oder, warum nicht, einen Wald von B√§umen darstellen ... </blockquote><br><h2 id="ponimanie-element-v-dereve">  Grundlegendes zum <em>Element</em> in einem Baum </h2><br><p>  Was hat das damit zu tun? </p><br><p>  Wie sp√§ter noch gezeigt wird, muss <em>Flutter</em> alle kleinen Teile des Bildschirms im Detail kennen, um Pixel f√ºr das auf dem Ger√§t angezeigte Bild erzeugen zu k√∂nnen, und um alle Teile zu bestimmen, muss es die <strong>Erweiterung</strong> aller Widgets kennen. </p><br><p>  Um diesen Punkt zu veranschaulichen, betrachten Sie das Prinzip einer verschachtelten Puppe: Wenn sie geschlossen ist, sehen Sie nur eine Puppe, aber sie enth√§lt eine andere, die wiederum eine andere enth√§lt und so weiter ... </p><br><p><img src="https://habrastorage.org/webt/9x/kq/lb/9xkqlbngsofs0w7m71rx2yucnzy.png"></p><br><p>  Wenn <em>Flutter</em> alle Widgets <em>(Teil des Bildschirms) erweitert</em> , werden alle Puppen <em>(Teil des Ganzen) abgerufen</em> . </p><br><p>  Das folgende Bild zeigt einen Teil der endg√ºltigen hierarchischen Struktur von Widgets, die dem vorherigen Code entsprechen.  In Gelb habe ich die zuvor im Code erw√§hnten Widgets hervorgehoben, damit Sie sie im endg√ºltigen Baum definieren k√∂nnen. </p><br><p><img src="https://habrastorage.org/webt/mp/lw/-o/mplw-oisztyx_zvwf8kvpl2tpog.png"></p><br><blockquote>  <strong><em>Wichtige Klarstellung</em></strong> <br><br>  <em>Die Sprache "Widget-Baum" existiert nur, um das Verst√§ndnis zu erleichtern, da Programmierer Widgets verwenden, aber es gibt KEINEN Widget-Baum in Flutter!</em> <br><br>  <em>Tats√§chlich w√§re es richtiger, "Baum der Elemente" zu sagen.</em> </blockquote><p>  Es ist Zeit, das Konzept eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Elements</a> einzuf√ºhren. </p><br><blockquote>  <em><strong>Jedes</strong> Widget hat <strong>ein</strong> Element.</em>  <em>Elemente sind miteinander verbunden und bilden einen Baum.</em>  <em>Daher ist <strong>ein Element</strong> eine Referenz auf etwas im Baum.</em> </blockquote><p>  Stellen Sie sich ein Element zun√§chst als Knoten vor, der ein √ºbergeordnetes und m√∂glicherweise ein untergeordnetes Element hat.  Indem wir sie durch eine <em>Eltern-Kind-</em> Beziehung miteinander verbinden, erhalten wir eine Baumstruktur. </p><br><p><img src="https://habrastorage.org/webt/bd/cx/t4/bdcxt4slijkhhc5j0fnipnauyey.png"></p><br><p>  Wie Sie sehen, zeigt das Element auf ein Widget und <strong>kann</strong> auch auf ein <em>RenderObject zeigen</em> . </p><br><blockquote>  <em>Noch besser ... Element zeigt auf Widget, <strong>das</strong> dieses Element erstellt hat!</em> </blockquote><p>  Fassen wir zusammen: </p><br><ul><li>  Es gibt keinen Widgetbaum, aber einen Elementbaum </li><li>  Elemente werden von Widgets erstellt. </li><li>  Das Element bezieht sich auf das Widget, das es erstellt hat. </li><li>  Elemente, die mit √ºbergeordneten Beziehungen verkn√ºpft sind </li><li>  Ein Gegenstand kann ein "Baby" haben. </li><li>  Elemente k√∂nnen auch auf ein <em>RenderObject zeigen.</em> </li></ul><br><blockquote>  <em><strong>Elemente</strong> bestimmen, wie Teile der angezeigten Bl√∂cke miteinander in Beziehung stehen.</em> </blockquote><p>  Um sich besser vorstellen zu k√∂nnen, wo das Konzept <em>eines Elements</em> passt, schauen wir uns die folgende visuelle Darstellung an: </p><br><p><img src="https://habrastorage.org/webt/x5/vb/jt/x5vbjtq_5fhuyhvc2s7jnt7pbai.png"></p><br><p>  Wie Sie sehen, ist der Elementbaum die tats√§chliche Beziehung zwischen Widgets und <em>RenderObjects</em> . </p><br><p>  Aber warum erstellt <em>Widget</em> ein <em>Element</em> ? </p><br><h2 id="3-kategorii-vidzhetov">  3 Kategorien von Widgets </h2><br><p>  In Flutter sind Widgets in drei Kategorien unterteilt, die ich pers√∂nlich wie folgt nenne <em>(dies ist jedoch nur meine Art, sie zu klassifizieren)</em> : </p><br><ul><li><p>  Proxy </p><br><p>  Die Hauptaufgabe dieser Widgets besteht darin, einige Informationen zu speichern (auf die Widgets zugreifen k√∂nnen sollten), die Teil der auf Proxy basierenden Baumstruktur sind.  Ein Beispiel f√ºr solche Widgets ist <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">InheritedWidget</a></strong> oder <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">LayoutId</a></strong> . </p><br><p>  Diese Widgets sind nicht direkt an der Gestaltung der Benutzeroberfl√§che beteiligt, sondern werden verwendet, um die Informationen abzurufen, die sie bereitstellen k√∂nnen. </p><br></li><li><p>  Renderer </p><br><p>  Diese Widgets stehen in direktem Zusammenhang mit dem Layout des Bildschirms, da sie die <em>Gr√∂√üe</em> , <em>Position</em> und das <em>Rendering</em> bestimmen (oder dazu verwendet werden).  Typische Beispiele sind: <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Row</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Column</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Stack</a></strong> sowie <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Padding</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Align</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Opacity</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">RawImage</a></strong> ... </p><br></li><li><p>  Komponente </p><br><p>  Hierbei handelt es sich um andere Widgets, die nicht direkt die endg√ºltigen Informationen zu Gr√∂√üe, Position und Erscheinungsbild bereitstellen, sondern vielmehr die Daten (oder Tipps), mit denen die endg√ºltigen Informationen abgerufen werden.  Diese Widgets werden √ºblicherweise als Komponenten bezeichnet. </p><br><p>  Beispiele: <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">RaisedButton</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Scaffold</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Text</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">GestureDetector</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Container</a></strong> ... </p><br></li></ul><br><p><img src="https://habrastorage.org/webt/oe/j0/j7/oej0j75h_3ycogohqdckq5e03im.png"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">In dieser PDF-Datei</a> sind die meisten Widgets nach Kategorien gruppiert. </p><br><p>  Warum ist diese Trennung wichtig?  Weil abh√§ngig von der Kategorie des Widgets der entsprechende Elementtyp mit ... </p><br><h2 id="tipy-elementov">  Artikeltypen </h2><br><p>  Es gibt verschiedene Arten von Elementen: </p><br><p><img src="https://habrastorage.org/webt/or/au/yc/orauycfegkvfnjlmjws4x4ftpuw.png"></p><br><p>  Wie Sie im obigen Bild sehen k√∂nnen, sind die Elemente in zwei Haupttypen unterteilt: </p><br><ul><li><p>  Komponentenbestandteil </p><br><p>  Diese Elemente <strong>sind</strong> nicht <strong>direkt</strong> f√ºr das Rendern eines Teils der Anzeige verantwortlich. </p><br></li><li><p>  RenderObjectElement </p><br><p>  Diese Elemente sind f√ºr Teile des angezeigten Bildes auf dem Bildschirm verantwortlich. </p><br></li></ul><br><p>  Gro√üartig!  So viele Informationen, aber wie h√§ngt das alles zusammen und warum ist es interessant, dar√ºber zu sprechen? </p><br><h2 id="kak-vidzhety-i-elementy-rabotayut-vmeste">  Wie Widgets und Elemente zusammenarbeiten </h2><br><blockquote>  <em>In Flutter basieren alle Mechaniken auf der Ung√ºltigmachung eines Elements oder Renderobjekts.</em> </blockquote><p>  Die Ung√ºltigmachung von Elementen kann auf folgende Arten erfolgen: </p><br><ul><li>  Verwenden von <code>setState</code> , wodurch das gesamte <strong>StatefulElement</strong> ung√ºltig wird (beachte, dass ich <em>StatefulWidget</em> absichtlich nicht sage) </li><li>  durch Benachrichtigungen, die von <strong>proxyElement</strong> verarbeitet werden (z. B. InheritedWidget), wodurch jedes <em>Element</em> ung√ºltig wird <em>,</em> das von diesem <em>proxyElement abh√§ngt</em> </li></ul><br><p>  Das Ergebnis der <em>Ung√ºltigkeit</em> ist, dass in der Liste der <strong>fehlerhaften</strong> Elemente ein Link zu dem entsprechenden <em>Element</em> angezeigt wird. </p><br><p>  Die <em>Ung√ºltigkeit von renderObject</em> bedeutet, dass sich die Struktur der Elemente √ºberhaupt nicht √§ndert, aber es gibt eine √Ñnderung auf der Ebene von <em>renderObject</em> , zum Beispiel: </p><br><ul><li>  √Ñnderung seiner Gr√∂√üe, Position, Geometrie ... </li><li>  Etwas muss neu gestrichen werden, zum Beispiel, wenn Sie nur die Hintergrundfarbe, den Schriftstil ... √§ndern. </li></ul><br><p>  Das Ergebnis einer solchen <em>Invalidierung</em> ist eine Verkn√ºpfung zu dem entsprechenden <em>RenderObject</em> in der Liste der <em>Renderobjekte (RenderObjects)</em> , die neu erstellt oder <em>√ºberarbeitet werden</em> m√ºssen. </p><br><p>  Unabh√§ngig von der Art der Invalidierung wird <strong>SchedulerBinding</strong> aufgerufen (nicht vergessen?), Um die <strong>Flutter Engine aufzufordern</strong> , einen neuen Frame zu planen. </p><br><p>  Dies ist genau der Moment, in dem die <em>Flutter Engine</em> das <em>SchedulerBinding</em> "aufweckt" und all die Magie passiert ... </p><br><h2 id="ondrawframe">  onDrawFrame () </h2><br><p>  Weiter oben in diesem Artikel haben wir festgestellt, dass <em>SchedulerBinding</em> zwei Hauptaufgaben hat, von denen eine die Bereitschaft ist, Anforderungen von <em>Flutter Engine im</em> Zusammenhang mit der Frame-Neuerstellung zu verarbeiten.  Dies ist der perfekte Moment, um sich darauf zu konzentrieren. </p><br><p>  Das folgende Teilsequenzdiagramm zeigt, was passiert, wenn <em>SchedulerBinding</em> eine <em>onDrawFrame () -</em> Anforderung von der <em>Flutter Engine</em> empf√§ngt. </p><br><p><img src="https://habrastorage.org/webt/b8/mz/ba/b8mzbav2krwuwat0ibyvd5gngs4.png"></p><br><p>  <strong>Schritt 1. Elemente</strong> </p><br><p>  <em>WidgetsBinding</em> wird <em>aufgerufen</em> und diese Bindung ber√ºcksichtigt zuerst die mit den Elementen verbundenen √Ñnderungen.  <em>WidgetsBinding</em> ruft die <em>buildScope-</em> Methode des <em>buildOwner-</em> Objekts auf, da <strong>BuildOwner</strong> f√ºr die Verarbeitung des <strong>Elementbaums</strong> verantwortlich ist.  Diese Methode durchsucht die Liste der <em>fehlerhaften</em> Elemente und fordert deren <strong>Neuerstellung an</strong> . </p><br><p>  Die Hauptprinzipien dieser <code>rebuild()</code> ( <code>rebuild()</code> ) sind: </p><br><ol><li>  Es besteht eine Anforderung, das Element neu zu <code>build()</code> (dies wird die meiste Zeit in <code>Widget build (BuildContext context) {...}</code> nehmen), wobei die <code>build()</code> -Methode des Widgets <code>Widget build (BuildContext context) {...}</code> , auf das sich dieses Element bezieht (= <code>Widget build (BuildContext context) {...}</code> -Methode).  Diese <code>build()</code> -Methode gibt ein neues Widget zur√ºck </li><li>  Wenn das Element keine <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">untergeordneten</a></em> Elemente hat, wird ein Element f√ºr das neue Widget erstellt (siehe unten) ( <em>Hinweis: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">inflateWidget</a></em> ), andernfalls </li><li>  Das neue Widget wird mit dem Widget verglichen, auf das das untergeordnete Element des Elements verweist <br><ul><li>  Wenn sie austauschbar sind (= <em>derselbe Widget-Typ und -Schl√ºssel</em> ), erfolgt die Aktualisierung und das untergeordnete Element wird gespeichert. </li><li>  Wenn sie nicht austauschbar sind, wird das untergeordnete Element verworfen ( <em>~ verworfen</em> ) und ein Element f√ºr das neue Widget erstellt </li></ul></li><li>  Dieses neue Element wird als untergeordnetes Element des Elements bereitgestellt.  ( <em>montiert)</em> = in den Elementbaum eingef√ºgt) </li></ol><br><p>  Die folgende Animation soll diese Erkl√§rung etwas klarer machen. </p><br><p><img src="https://habrastorage.org/webt/71/91/xc/7191xcnbg00lbho_ol_9vaczdca.gif"></p><br><p>  <strong>Hinweis zu Widgets und Elementen</strong> </p><br><p>  F√ºr ein neues Widget wird ein Element eines <em>bestimmten Typs</em> erstellt, das <em>der</em> Widget- <em>Kategorie entspricht</em> , n√§mlich: </p><br><ul><li>  <em>InheritedWidget</em> -&gt; <em>InheritedElement</em> </li><li>  <em>StatefulWidget</em> -&gt; <em>StatefulElement</em> </li><li>  <em>StatelessWidget</em> -&gt; <em>StatelessElement</em> </li><li>  <em>InheritedModel</em> -&gt; <em>InheritedModelElement</em> </li><li>  <em>InheritedNotifier</em> -&gt; <em>InheritedNotifierElement</em> </li><li>  <em>LeafRenderObjectWidget</em> -&gt; <em>LeafRenderObjectElement</em> </li><li>  <em>SingleChildRenderObjectWidget</em> -&gt; <em>SingleChildRenderObjectElement</em> </li><li>  <em>MultiChildRenderObjectWidget</em> -&gt; <em>MultiChildRenderObjectElement</em> </li><li>  <em>ParentDataWidget</em> -&gt; <em>ParentDataElement</em> </li></ul><br><p>  Jeder dieser Elementtypen hat sein eigenes Verhalten.  Zum Beispiel: </p><br><ul><li>  <em>StatefulElement</em> ruft bei der Initialisierung die Methode <code>widget.createState()</code> auf, die einen <code>widget.createState()</code> erstellt und mit dem Element verkn√ºpft </li><li>  Wenn ein Element vom Typ <em>RenderObjectElement</em> angeh√§ngt wird, wird ein <em>RenderObject erstellt</em> .  Dieses <em>renderObject</em> wird dem <em>Render Tree</em> hinzugef√ºgt und dem Element zugeordnet. </li></ul><br><p>  <strong>Schritt 2. renderObjects</strong> </p><br><p>  Nachdem Sie nun alle mit <em>schmutzigen</em> Elementen verbundenen Aktionen ausgef√ºhrt haben, ist der Elementbaum stabil.  Es ist also Zeit, den Visualisierungsprozess zu betrachten. </p><br><p>  Da <em>RendererBinding</em> f√ºr das Rendern des <em>Renderbaums verantwortlich ist,</em> ruft <code>drawFrame</code> die <code>drawFrame</code> <em>RendererBinding-</em> Methode auf. </p><br><p>  Das folgende <em>Teildiagramm</em> zeigt die Reihenfolge der Aktionen, die w√§hrend der <em>drawFrame () -</em> Anforderung ausgef√ºhrt wurden. </p><br><p><img src="https://habrastorage.org/webt/dp/sw/v3/dpswv3gszlwj3f_zwsak0xq91k0.png"></p><br><p>  In diesem Schritt werden die folgenden Aktionen ausgef√ºhrt: </p><br><ul><li>  Jedes als <em>unsauber</em> markierte <em>Renderobjekt</em> wird aufgefordert, es zu komponieren (d. H. Seine Gr√∂√üe und Geometrie zu berechnen). </li><li>  Jedes <em>RenderObject,</em> das als "neu zu zeichnen" markiert ist, wird mit seiner eigenen <em>Ebenenmethode</em> neu gezeichnet </li><li>  Die resultierende Szene wird gebildet und an die <em>Flutter Engine</em> gesendet, damit diese sie auf den <em>Ger√§tebildschirm</em> √ºbertr√§gt </li><li>  Schlie√ülich wird auch die Semantik aktualisiert und an die <em>Flutter Engine</em> gesendet </li></ul><br><p>  Am Ende dieses Workflows wird der Ger√§tebildschirm aktualisiert. </p><br><h1 id="chast-3-obrabotka-zhestov">  Teil 3: Umgang mit Gesten </h1><br><p>  Gesten (= <em>Ereignisse im Zusammenhang</em> mit <em>Fingeraktionen</em> <em>auf dem Glas</em> ) werden mit <em>GestureBinding</em> verarbeitet. </p><br><p>  Wenn die <em>Flutter-Engine</em> Informationen zu einem Gestenereignis √ºber die <em>window.onPointerDataPacket-</em> API <strong>sendet,</strong> f√§ngt sie die <strong>GestureBinding ab</strong> , f√ºhrt eine Pufferung durch und f√ºhrt <strong>Folgendes aus</strong> : </p><br><ol><li>  konvertiert die von der <em>Flutter Engine</em> angegebenen Koordinaten so, dass sie dem <em>Pixelverh√§ltnis</em> des <strong>Ger√§ts entsprechen</strong> </li><li>  <em>Ruft</em> aus <em>renderView eine</em> Liste aller <em>RenderObjects ab</em> , die sich in dem Teil des Bildschirms befinden, der sich auf die Koordinaten des Ereignisses bezieht </li><li>  <em>Durchl√§uft</em> dann die resultierende Liste von <em>renderObjects</em> und sendet ein zugeh√∂riges Ereignis an jedes von ihnen </li><li>  Wenn <em>renderObject</em> Ereignisse dieses Typs "abh√∂rt", verarbeitet es sie </li></ol><br><p>  Hoffentlich verstehe ich jetzt, wie wichtig <em>renderObjects ist</em> . </p><br><h1 id="chast-4-animacii">  Teil 4: Animationen </h1><br><p>  In diesem Teil des Artikels geht es um das Konzept der <strong>Animation</strong> und ein tiefes Verst√§ndnis des <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Tickers</a></strong> . </p><br><p>  Wenn Sie mit Animationen arbeiten, verwenden Sie normalerweise einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">AnimationController</a> oder ein anderes Widget f√ºr Animationen ( <em>Hinweis: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">AnimatedCrossFade</a></em> ). </p><br><p>  In <em>Flutter</em> bezieht sich alles <em>,</em> was mit Animationen zu <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">tun hat,</a></em> auf den <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Ticker</a></em> .  Wenn der <em>Ticker</em> aktiv ist, hat er nur eine Aufgabe: "Er fordert <em>SchedulerBinding auf</em> , einen R√ºckruf <em>zu</em> registrieren und die <em>Flutter Engine anzuweisen, ihn</em> zu aktivieren, wenn ein neuer R√ºckruf angezeigt wird."  Wenn die <em>Flutter Engine</em> bereit ist, ruft sie <em>SchedulerBinding</em> √ºber eine Anforderung auf: " <em>onBeginFrame</em> ".  <em>SchedulerBinding</em> greift auf die <em>Ticker-</em> R√ºckrufliste zu und f√ºhrt jede aus. </p><br><p>  Jeder <em>Tick ‚Äã‚Äãwird</em> von einem "interessierten" Controller abgefangen, um ihn zu verarbeiten.  Wenn die Animation abgeschlossen ist, ist der <em>Ticker</em> deaktiviert, andernfalls fordert der <em>Ticker</em> eine <em>SchedulerBinding</em> auf, einen neuen R√ºckruf zu planen.  Usw... </p><br><h1 id="polnaya-kartina">  Vollbild </h1><br><p>  Jetzt haben wir gelernt, wie <em>Flutter</em> funktioniert: </p><br><p><img src="https://habrastorage.org/webt/5s/tw/w7/5stww7o_izlc6ywpnkmcfkkllbk.png"></p><br><h1 id="buildcontext">  Buildcontext </h1><br><p>  Kehren Sie schlie√ülich zu dem Diagramm zur√ºck, das die verschiedenen Elementtypen zeigt, und betrachten Sie die Signatur des <em>Stammelements</em> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Element</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DiagnosticableTree</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BuildContext</span></span></span><span class="hljs-class"> </span></span>{ ... }</code> </pre> <br><p>  Wir sehen den sehr ber√ºhmten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">BuildContext</a> !  Aber was ist es </p><br><p>  <strong>BuildContext</strong> ist eine Schnittstelle, die eine Reihe von Gettern und Methoden definiert, die von einem Element implementiert werden k√∂nnen.  Meist wird <em>BuildContext</em> in der <code>build()</code> -Methode von <em>StatelessWidget</em> oder <em>State</em> f√ºr <em>StatefulWidget verwendet</em> . </p><br><blockquote>  <em><strong>BuildContext</strong> ist nichts anderes als das <strong>Element</strong> selbst, das √ºbereinstimmt</em> <br><ul><li>  <em>Widget wird aktualisiert (innerhalb der <code>build</code> oder <code>builder</code> Methoden)</em> </li><li>  <em>StatefulWidget, das dem Status zugeordnet ist, in dem Sie auf die Kontextvariable verweisen.</em> </li></ul><br></blockquote><p>  Dies bedeutet, dass die meisten Entwickler st√§ndig mit Elementen arbeiten, ohne es zu wissen. </p><br><h2 id="naskolko-poleznym-mozhet-byt-buildcontext">  Wie n√ºtzlich kann ein BuildContext sein? </h2><br><p>  <em>BuildContext</em>  ,   ,      ,  <em>BuildContext</em>   ,  : </p><br><ul><li>     <em>RenderObject</em> ,   (,     <em>Renderer</em> ,  -) </li><li>   <em>RenderObject</em> </li><li>   .     ,     <code>of</code> (, <code>MediaQuery.of(context)</code> , <code>Theme.of(context)</code> ‚Ä¶) </li></ul><br><h2 id="zabavy-radi">   </h2><br><p> ,   ,  <em>BuildContext</em> ‚Äì  <em></em> ,         .  <strong> </strong>   <em>StatelessWidget</em>   ,      <em>StatefulWidget</em> ,    <code>setState()</code> ,    <em>BuildContext</em> . </p><br><blockquote> <strong></strong> <br> <strong>,    !</strong> <br><br>    ‚Äì ,  <em>StatelessWidget</em>   . <br>       , ,  <em>StatefulWidget</em> . </blockquote><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ runApp(MaterialApp(home: TestPage(),)); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestPage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// final because a Widget is immutable (remember?) final bag = {"first": true}; @override Widget build(BuildContext context){ return Scaffold( appBar: AppBar(title: Text('Stateless ??')), body: Container( child: Center( child: GestureDetector( child: Container( width: 50.0, height: 50.0, color: bag["first"] ? Colors.red : Colors.blue, ), onTap: (){ bag["first"] = !bag["first"]; // // This is the trick // (context as Element).markNeedsBuild(); } ), ), ), ); } }</span></span></code> </pre> <br><p> <em> ,    <code>setState()</code> ,         : <code>_element.markNeedsBuild()</code> .</em> </p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>  : "   ".   ,      ,    <em>Flutter</em> ,   ,    ,   ,      .  ,  ,   <em>Widget</em> , <em>Element</em> , <em>BuildContext</em> , <em>RenderObject</em> ,     .   ,       . </p><br><p>     .       . </p><br><p> PS  ,          () . <br> PSS       <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Flutter internals</a></strong>  Didier Boelens,           ) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de476018/">https://habr.com/ru/post/de476018/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de476000/index.html">ML.NET Model Builder-Aktualisierungen</a></li>
<li><a href="../de476002/index.html">Erfahrung in der Suche nach einer Doktorandenstelle in Deutschland</a></li>
<li><a href="../de476004/index.html">Projektleiter - Mythos oder Realit√§t? Oder warum wird es im Bereich der visuellen Effekte ben√∂tigt?</a></li>
<li><a href="../de476006/index.html">Mythen und Legenden der SOC-Erbauer oder 3 Missverst√§ndnisse √ºber Zentren zur √úberwachung und Reaktion auf Cyberangriffe</a></li>
<li><a href="../de476008/index.html">MOSDROID Meetup: Verbinde dich mit dem Broadcast</a></li>
<li><a href="../de476022/index.html">Vue Storefront: Das Backend erweitern</a></li>
<li><a href="../de476024/index.html">Beste Architektur f√ºr MVP: Monolith, SOA, Microservices oder Serverless? Teil 1</a></li>
<li><a href="../de476026/index.html">Cool Life Hacks f√ºr die Arbeit mit WSL (Windows-Subsystem f√ºr Linux)</a></li>
<li><a href="../de476032/index.html">Brunner Elektronik - Vom CAD-System ins Cockpit</a></li>
<li><a href="../de476034/index.html">Am wehrlosesten ist der Wanderfalke</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>