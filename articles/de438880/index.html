<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚋 🧑🏿‍🤝‍🧑🏽 🚖 Wann man var, let und const in Javascript verwendet [Übersetzung aus dem Artikel von Tyler McGinnis] 💟 🚥 🐆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Ich präsentiere Ihnen die Übersetzung des Artikels "var vs let vs const in JavaScript" von Tyler McGinnis. 



 In diesem Artikel lernen S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wann man var, let und const in Javascript verwendet [Übersetzung aus dem Artikel von Tyler McGinnis]</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438880/"> Hallo Habr!  Ich präsentiere Ihnen die Übersetzung des Artikels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"var vs let vs const in JavaScript"</a> von Tyler McGinnis. <br><br><img src="https://cdn-images-1.medium.com/max/2600/1*bPIf2_HXNUG4O_tSvWKYsg.png" alt="Bild"><br><br>  In diesem Artikel lernen Sie zwei neue Möglichkeiten zum Erstellen von Variablen in Javascript (ES6) kennen: let und const.  In diesem Artikel werden die Unterschiede zwischen <i>var</i> , <i>let</i> und <i>const</i> sowie verwandte Themen wie "Funktionsumfang versus Blockumfang", "Erhöhen" von Variablen und Unveränderlichkeit untersucht. <br><a name="habracut"></a><br>  Wenn Sie ein Video bevorzugen, schauen Sie sich dieses an (Original in Englisch): <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/6vBYfLCE9-Q" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  ES2015 (oder ES6) führte uns in zwei neue Möglichkeiten ein, Variablen zu erstellen: <i>let</i> und <i>const</i> .  Bevor wir uns jedoch mit den Unterschieden zwischen <i>var</i> , <i>let</i> und <i>const</i> befassen, sollten Sie zunächst einige Themen kennen.  Dies sind die Deklaration von Variablen und deren Initialisierung, Umfang (ein besonderer Umfang der Funktion) und "Erhöhen". <br><br><h3>  Variablen deklarieren und initialisieren </h3><br>  Eine Variablendeklaration führt einen neuen Bezeichner ein. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> declaration</code> </pre> <br>  Oben erstellen wir einen neuen Bezeichner, den wir "Deklaration" genannt haben.  In Javascript werden Variablen beim Erstellen mit einem <i>undefinierten</i> Wert initialisiert.  Dies bedeutet, dass wir <i>undefiniert werden</i> , wenn wir versuchen, unsere <i>Deklarationsvariable</i> auszugeben. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> declaration <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(declaration)</code> </pre> <br>  Also haben wir die <i>Deklarationsvariable abgeleitet</i> und wurden <i>undefiniert</i> . <br><br>  Im Vergleich zum Deklarieren einer Variablen ist das Initialisieren einer Variablen das erste Mal, dass Sie den Wert dieser Variablen festlegen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> declaration <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(declaration) <span class="hljs-comment"><span class="hljs-comment">// undefined declaration = '  '</span></span></code> </pre> <br>  Und so haben wir hier die <i>Deklarationsvariable</i> initialisiert, indem wir eine Zeichenfolge darauf geschrieben haben. <br><br>  Dies führt uns zum nächsten Konzept, dem Umfang. <br><cut><br><h3>  Geltungsbereich </h3><br>  Ein Bereich beschreibt, wo auf die Variablen und Funktionen in unserem Programm zugegriffen werden kann.  In Javascript gibt es zwei Arten von Bereichen - den <b>globalen Bereich</b> und <b>den Bereich einer Funktion</b> .  Nach der offiziellen Spezifikation, <br><blockquote>  "Wenn eine Variablendeklaration innerhalb einer Funktionsdeklaration auftritt, wird die Variable im lokalen Bereich dieser Funktion definiert ..." </blockquote>  Dies bedeutet, dass, wenn Sie eine Variable mit <i>var</i> erstellen, der Bereich dieser Variablen die Funktion ist, in der sie erstellt wurde, und nur innerhalb dieser Funktion oder einer anderen verschachtelten Funktion verfügbar ist. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> date = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> date } getDate() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(date) <span class="hljs-comment"><span class="hljs-comment">// NOT OK: Reference Error</span></span></code> </pre> <br>  Oben haben wir versucht, von außerhalb der Funktion, in der sie deklariert wurde, auf die Variable zuzugreifen.  Da der Gültigkeitsbereich der <i>Datumsvariablen die</i> Funktion <i>getDate</i> ist, ist sie nur innerhalb dieser Funktion oder in einer anderen in <i>getDate</i> verschachtelten Funktion <i>verfügbar</i> (siehe Abbildung unten). <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> date = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">formatDate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> date.toDateString().slice(<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-comment"><span class="hljs-comment">// OK } return formatDate() } getDate() console.log(date) // NOT OK: Reference Error</span></span></code> </pre> <br>  Schauen wir uns nun ein fortgeschritteneres Beispiel an.  Nehmen wir an, wir haben eine Reihe von Preisen und benötigen eine Funktion, die diese Reihe sowie eine <i>Rabattvariable verwendet</i> und uns eine neue Reihe von Preisen mit Rabatten zurückgibt.  Das Endziel könnte ungefähr so ​​aussehen: <br><br><pre> <code class="javascript hljs">discountPrices([<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">300</span></span>], <span class="hljs-number"><span class="hljs-number">.5</span></span>)</code> </pre> <br>  Und die Implementierung könnte ungefähr so ​​aussehen: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discountPrices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prices, discount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> discounted = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; prices.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> discountedPrice = prices[i] * (<span class="hljs-number"><span class="hljs-number">1</span></span> - discount) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> finalPrice = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(discountedPrice * <span class="hljs-number"><span class="hljs-number">100</span></span>) / <span class="hljs-number"><span class="hljs-number">100</span></span> discounted.push(finalPrice) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> discounted }</code> </pre> <br>  Es sieht einfach aus, aber was hat das mit dem Umfang des Blocks zu tun?  Schauen Sie sich diese <i>for-</i> Schleife an.  Sind darin deklarierte Variablen außerhalb zugänglich?  Es stellt sich heraus, verfügbar. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discountPrices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prices, discount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> discounted = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; prices.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> discountedPrice = prices[i] * (<span class="hljs-number"><span class="hljs-number">1</span></span> - discount) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> finalPrice = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(discountedPrice * <span class="hljs-number"><span class="hljs-number">100</span></span>) / <span class="hljs-number"><span class="hljs-number">100</span></span> discounted.push(finalPrice) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i) <span class="hljs-comment"><span class="hljs-comment">// 3 console.log(discountedPrice) // 150 console.log(finalPrice) // 150 return discounted }</span></span></code> </pre> <br>  Wenn JavaScript die einzige Programmiersprache ist, die Sie kennen, müssen Sie sich möglicherweise nicht so viele Sorgen machen.  Wenn Sie jedoch von einer anderen Programmiersprache zu JavaScript gekommen sind, insbesondere von einer Programmiersprache, die den Gültigkeitsbereich blockiert, sind Sie wahrscheinlich ein wenig besorgt darüber, was hier passiert. <br><br>  Es ist nicht kaputt, es funktioniert nur ein wenig seltsam.  Es gibt wirklich keinen Grund, außerhalb der <i>for-</i> Schleife auf <i>i</i> , <i>discountPrice</i> und <i>finalPrice</i> zuzugreifen.  Es nützt uns nichts und kann uns in manchen Situationen sogar schaden.  Da Variablen jedoch mit <i>var</i> deklariert werden, fallen sie in den Funktionsumfang und Sie können darauf zugreifen. <br><br>  Jetzt haben wir die Deklaration und Initialisierung von Variablen sowie den Umfang besprochen. Eine weitere Sache, mit der wir uns befassen müssen, bevor wir uns mit den Unterschieden zwischen <i>let</i> und <i>const</i> befassen, ist das „Erhöhen“. <br><br><h3>  "Heben" </h3><br>  Denken Sie daran, dass zuvor gesagt wurde: „In Javascript werden Variablen beim Erstellen mit dem undefinierten Wert initialisiert.“  Es stellt sich heraus, dass dies "Hebung" bedeutet.  Der JavaScript-Interpreter setzt die deklarierten Variablen während einer Phase namens "Erstellung" auf <i>undefiniert</i> . <br><br>  Lesen Sie diesen Artikel, um eine detailliertere Übersicht über die Erstellungsphase „Erhöhen“ und Bereiche zu erhalten: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Der ultimative Leitfaden zum Heben, Umfang und Schließen in JavaScript“</a> . <br><br>  Schauen wir uns das vorherige Beispiel an und sehen, wie sich „Uplift“ darauf auswirkt. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discountPrices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prices, discount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> discounted = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> discountedPrice = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> finalPrice = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> discounted = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; prices.length; i++) { discountedPrice = prices[i] * (<span class="hljs-number"><span class="hljs-number">1</span></span> - discount) finalPrice = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(discountedPrice * <span class="hljs-number"><span class="hljs-number">100</span></span>) / <span class="hljs-number"><span class="hljs-number">100</span></span> discounted.push(finalPrice) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i) <span class="hljs-comment"><span class="hljs-comment">// 3 console.log(discountedPrice) // 150 console.log(finalPrice) // 150 return discounted }</span></span></code> </pre> <br>  Beachten Sie, dass alle deklarierten Variablen auf <i>undefiniert gesetzt wurden</i> .  Wenn Sie versuchen, auf eines davon zuzugreifen, bevor es tatsächlich angekündigt wird, werden Sie einfach <i>undefiniert</i> . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discountPrices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prices, discount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(discounted) <span class="hljs-comment"><span class="hljs-comment">// undefined var discounted = [] for (var i = 0; i &lt; prices.length; i++) { var discountedPrice = prices[i] * (1 - discount) var finalPrice = Math.round(discountedPrice * 100) / 100 discounted.push(finalPrice) } console.log(i) // 3 console.log(discountedPrice) // 150 console.log(finalPrice) // 150 return discounted }</span></span></code> </pre> <br>  Jetzt wissen Sie alles, was Sie über <i>var</i> brauchen. Lassen Sie uns nun endlich über das Hauptziel sprechen, für das wir hier sind: Was ist der Unterschied zwischen <i>var</i> , <i>let</i> und <i>const</i> ? <br><br><h3>  var, let oder const </h3><br>  Vergleichen <i>wir zunächst</i> <i>var</i> und <i>let</i> .  Der Hauptunterschied zwischen <i>var</i> und <i>let</i> besteht darin, dass <i>Sie</i> neben dem globalen Bereich und dem Bereich der Funktion auch Variablen im Bereich des Blocks definieren können.  Dies bedeutet, dass die mit dem Schlüsselwort <i>let</i> erstellte Variable sowohl in dem Block, in dem sie erstellt wurde, als auch in verschachtelten Blöcken verfügbar ist.  Als ich "block" sagte, meinte ich etwas, das von geschweiften Klammern {} umgeben ist, wie eine for-Schleife oder eine <i>if-Anweisung</i> . <br><br>  Kehren wir also zum letzten Mal zu unserer Funktion <i>discountPrices</i> zurück. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discountPrices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prices, discount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> discounted = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; prices.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> discountedPrice = prices[i] * (<span class="hljs-number"><span class="hljs-number">1</span></span> - discount) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> finalPrice = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(discountedPrice * <span class="hljs-number"><span class="hljs-number">100</span></span>) / <span class="hljs-number"><span class="hljs-number">100</span></span> discounted.push(finalPrice) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i) <span class="hljs-comment"><span class="hljs-comment">// 3 console.log(discountedPrice) // 150 console.log(finalPrice) // 150 return discounted }</span></span></code> </pre> <br>  Denken Sie daran, dass wir das Recht haben, <i>i</i> , <i>discountPrice</i> und <i>finalPrice</i> außerhalb der <i>for-</i> Schleife auszugeben, da sie mit <i>var</i> deklariert wurden und Variablen, die mit dem Schlüsselwort <i>var</i> deklariert wurden, auf den Funktionsumfang beschränkt sind.  Aber was passiert jetzt, wenn wir <i>var</i> ändern, um unseren Code laufen zu <i>lassen</i> und zu versuchen? <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discountPrices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prices, discount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> discounted = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; prices.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> discountedPrice = prices[i] * (<span class="hljs-number"><span class="hljs-number">1</span></span> - discount) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> finalPrice = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(discountedPrice * <span class="hljs-number"><span class="hljs-number">100</span></span>) / <span class="hljs-number"><span class="hljs-number">100</span></span> discounted.push(finalPrice) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i) <span class="hljs-comment"><span class="hljs-comment">// 3 console.log(discountedPrice) // 150 console.log(finalPrice) // 150 return discounted } discountPrices([100, 200, 300], .5) // NOT OK: ReferenceError: i is not defined</span></span></code> </pre> <br>  Wir haben <i>ReferenceError: i ist nicht definiert</i> .  Was uns sagt, dass die mit <i>let</i> deklarierte Variable auf den Umfang des Blocks beschränkt ist, nicht auf die Funktion.  Versuchen Sie, <i>i</i> (oder <i>discountedPrice</i> oder <i>finalPrice</i> ) außerhalb des "Blocks" aufzurufen, in dem sie deklariert wurden. Dies führt zu einem Anruffehler, wie wir gerade gesehen haben. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> VS <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>:     <span class="hljs-keyword"><span class="hljs-keyword">let</span></span>:    </code> </pre> <br>  Die folgenden Unterschiede beziehen sich auf die „Hebung“.  Wir haben bereits gesagt, dass die Definition von "Uplift" lautet: "Der JavaScript-Interpreter setzt die deklarierten Variablen während der Phase" Creation "auf <i>undefined</i> ." Wir haben dies auch in Aktion gesehen, indem wir die Variable vor ihrer Deklaration aufgerufen haben (Sie wurden <i>undefiniert</i> ). <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discountPrices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prices, discount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(discounted) <span class="hljs-comment"><span class="hljs-comment">// undefined var discounted = [] for (var i = 0; i &lt; prices.length; i++) { var discountedPrice = prices[i] * (1 - discount) var finalPrice = Math.round(discountedPrice * 100) / 100 discounted.push(finalPrice) } console.log(i) // 3 console.log(discountedPrice) // 150 console.log(finalPrice) // 150 return discounted }</span></span></code> </pre> <br>  Ich kann mich nicht an einen einzelnen Anwendungsfall erinnern, in dem Sie wirklich auf eine Variable zugreifen möchten, bevor Sie sie deklarieren.  Es scheint, dass es besser wäre, einen <i>ReferenceError</i> zu erhalten, als <i>undefiniert zu werden</i> . <br><br>  In der Tat ist es das <i>,</i> was <i>wir</i> tun.  Wenn Sie versuchen, auf eine Variable vor ihrer Deklaration mit <i>let</i> zuzugreifen, anstatt <i>undefiniert zu werden</i> (wie beim Deklarieren mit <i>var</i> ), erhalten Sie einen <i>ReferenceError</i> . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discountPrices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prices, discount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(discounted) <span class="hljs-comment"><span class="hljs-comment">// NOT OK: ReferenceError let discounted = [] for (let i = 0; i &lt; prices.length; i++) { let discountedPrice = prices[i] * (1 - discount) let finalPrice = Math.round(discountedPrice * 100) / 100 discounted.push(finalPrice) } console.log(i) // 3 console.log(discountedPrice) // 150 console.log(finalPrice) // 150 return discounted }</span></span></code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> VS <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>:        <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>         . let:       <span class="hljs-built_in"><span class="hljs-built_in">ReferenceError</span></span>        .</code> </pre> <br><h3>  let oder const </h3><br>  Jetzt verstehst du den Unterschied zwischen var und let. Was ist mit const?  Es stellt sich heraus, dass const fast dasselbe ist wie let.  Es gibt jedoch einen Unterschied: Wenn Sie einmal einen Wert mit const zugewiesen haben, können Sie ihn nicht in einen anderen ändern. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-string"><span class="hljs-string">'Tyler'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handle = <span class="hljs-string"><span class="hljs-string">'tylermcginnis'</span></span> name = <span class="hljs-string"><span class="hljs-string">'Tyler McGinnis'</span></span> <span class="hljs-comment"><span class="hljs-comment">// OK handle = '@tylermcginnis' // NOT OK: TypeError: Assignment to constant variable.</span></span></code> </pre> <br>  Die Schlussfolgerung aus dem Obigen ist, dass mit <i>let</i> deklarierte Variablen überschrieben werden können und mit <i>const</i> deklarierte Variablen nicht. <br><br>  Großartig, jetzt, da Sie möchten, dass Ihre Variable unveränderlich ist, können Sie sie mit <i>const</i> deklarieren.  Oder nicht wirklich.  Nur weil eine Variable mit <i>const</i> deklariert wurde, bedeutet dies nicht, dass sie unveränderlich ist. Das bedeutet nur, dass sie nicht überschrieben werden kann.  Unten ist ein gutes Beispiel. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Kim Kardashian'</span></span> } person.name = <span class="hljs-string"><span class="hljs-string">'Kim Kardashian West'</span></span> <span class="hljs-comment"><span class="hljs-comment">// OK person = {} // NOT OK: Assignment to constant variable.</span></span></code> </pre> <br>  Beachten Sie, dass das Ändern der Eigenschaft eines Objekts kein Überschreiben ist. Selbst wenn das Objekt mit <i>const</i> deklariert wird, bedeutet dies nicht, dass Sie keine seiner Eigenschaften ändern können.  Dies bedeutet nur, dass Sie dieses Objekt nicht überschreiben können. <br><br>  Nun die wichtigste Frage, die noch nicht beantwortet wurde: Was soll ich <i>var</i> , <i>let</i> oder <i>const verwenden</i> ?  Die beliebteste Meinung, an die ich mich halte, ist, immer <i>const zu verwenden,</i> bis Sie wissen, ob sich die Variable ändern wird.  Der Grund dafür ist, dass Sie mit <i>const</i> Ihnen und zukünftigen Entwicklern, die Ihren Code lesen sollten, klar machen, dass diese Variable nicht geändert werden sollte.  Wenn Sie es ändern müssen (zum Beispiel in einer <i>for-</i> Schleife), verwenden Sie einfach <i>let</i> . <br><br>  Es gibt nicht mehr viele Fälle zwischen Variablen, die sich ändern, und Variablen, die sich nicht ändern.  Dies bedeutet, dass Sie <i>var</i> nie wieder verwenden müssen. <br><br>  Nun ist die unpopuläre Meinung, obwohl sie immer noch gerechtfertigt ist, dass Sie niemals <i>const verwenden sollten</i> , obwohl Sie versuchen zu zeigen, dass diese Variable unveränderlich ist, wie wir oben gesehen haben, ist dies nicht ganz richtig.  Entwickler, die diese Meinung vertreten, verwenden <i>let</i> immer <i>,</i> solange es keine Variablen gibt, die tatsächlich Konstanten sind, wie z. B. _LOCATION_ = .... <br><br>  Lassen Sie uns eine Zusammenfassung des oben <i>Gesagten</i> machen. <i>Var ist</i> durch den Umfang der Funktion begrenzt. Wenn Sie versuchen, vor der Deklaration auf eine solche Variable zuzugreifen, werden Sie <i>undefiniert</i> .  <i>const</i> und <i>let sind</i> durch den Umfang des Blocks begrenzt. Wenn Sie versuchen, auf diese Variablen zuzugreifen, bevor Sie sie deklarieren, erhalten Sie einen <i>ReferenceError</i> .  Und der Unterschied zwischen <i>const</i> und <i>let</i> besteht darin, dass der Wert, der <i>const</i> zugewiesen wurde, im Gegensatz zu <i>let</i> nicht überschrieben werden kann. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> VS <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> VS <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>:        <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>         . let:       <span class="hljs-built_in"><span class="hljs-built_in">ReferenceError</span></span>        . const:       <span class="hljs-built_in"><span class="hljs-built_in">ReferenceError</span></span>        .    </code> </pre> <br>  Dieser Artikel wurde ursprünglich auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tylermcginnis.com</a> als Teil des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Modern JavaScript-</a> Kurses veröffentlicht. <br><br>  <i>Vielen Dank, dass Sie diese Übersetzung gelesen haben. Ich hoffe, Sie haben etwas Neues und Nützliches für sich kennengelernt.</i>  <i>Ich freue mich über das Feedback!</i> </cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438880/">https://habr.com/ru/post/de438880/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438868/index.html">Sicherheitswoche 06: Live auf FaceTime</a></li>
<li><a href="../de438870/index.html">Lombok gibt die Größe von Java zurück</a></li>
<li><a href="../de438874/index.html">Eine Freundschaft mit VkNet beginnen</a></li>
<li><a href="../de438876/index.html">So verkürzen Sie die Markteinführungszeit: eine Geschichte über die Testautomatisierung in M. Video</a></li>
<li><a href="../de438878/index.html">Das Erscheinen des Films in Strömen nach der Premiere erhöht die Abendkasse um 3%</a></li>
<li><a href="../de438882/index.html">Die Wahrscheinlichkeit, ein Match mit einer bekannten Wahrscheinlichkeit, einen Punkt zu gewinnen, zu gewinnen</a></li>
<li><a href="../de438884/index.html">Wahre Begebenheit einer Outback-Werbeagentur: Höhen, Tiefen und CRM-Implementierung</a></li>
<li><a href="../de438886/index.html">Morty, wir sind bei UltraHD! So schauen Sie sich einen Film in 4K an und vervollständigen ihn über ein wenig bekanntes neuronales Netzwerk</a></li>
<li><a href="../de438890/index.html">Postgres im Nachhinein</a></li>
<li><a href="../de438892/index.html">Was ist eine Unternehmensblockchain?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>