<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì© üëßüèΩ üçÉ NewSQL = NoSQL + ACID üôÜüèø üôâ üåÉ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jusqu'√† r√©cemment, √† Odnoklassniki, environ 50 To de donn√©es en temps r√©el √©taient stock√©es dans SQL Server. Pour un tel volume, il est presque imposs...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>NewSQL = NoSQL + ACID</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odnoklassniki/blog/417593/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/t5/hc/h2/t5hch2mr-lw9ffeahr_9gaxizlg.jpeg" width="600"></div><br>  Jusqu'√† r√©cemment, √† Odnoklassniki, environ 50 To de donn√©es en temps r√©el √©taient stock√©es dans SQL Server.  Pour un tel volume, il est presque impossible de fournir un acc√®s au centre de donn√©es rapide, fiable et m√™me √† s√©curit√© int√©gr√©e √† l'aide de SGBD SQL.  Habituellement, dans de tels cas, ils utilisent l'un des r√©f√©rentiels NoSQL, mais tout ne peut pas √™tre transf√©r√© vers NoSQL: certaines entit√©s exigent des garanties de transactions ACID. <br><br>  Cela nous a amen√©s √† utiliser le stockage NewSQL, c'est-√†-dire un SGBD qui offre la tol√©rance aux pannes, l'√©volutivit√© et les performances des syst√®mes NoSQL, tout en pr√©servant les garanties ACID famili√®res aux syst√®mes classiques.  Il y a peu de syst√®mes industriels qui fonctionnent dans cette nouvelle classe, nous avons donc impl√©ment√© un tel syst√®me nous-m√™mes et l'avons mis en service commercial. <br><br>  Comment cela fonctionne et ce qui s'est pass√© - lire sous la coupe. <br><a name="habracut"></a><br>  Aujourd'hui, l'audience mensuelle d'Odnoklassniki est de plus de 70 millions de visiteurs uniques.  Nous sommes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">parmi les cinq</a> plus grands r√©seaux sociaux du monde et les vingt sites sur lesquels les utilisateurs passent le plus de temps.  L'infrastructure "OK" g√®re des charges tr√®s √©lev√©es: plus d'un million de requ√™tes HTTP / sec vers les fronts.  Des parties du parc de serveurs de plus de 8 000 pi√®ces sont situ√©es √† proximit√© les unes des autres - dans quatre centres de donn√©es de Moscou, ce qui permet une latence du r√©seau de moins de 1 ms entre elles. <br><br>  Nous utilisons Cassandra depuis 2010, √† partir de la version 0.6.  Aujourd'hui, plusieurs dizaines de clusters sont en activit√©.  Le cluster le plus rapide traite plus de 4 millions d'op√©rations par seconde et le plus grand stocke 260 To. <br><br>  Cependant, tous ces clusters NoSQL ordinaires sont utilis√©s pour stocker <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des</a> donn√©es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">peu coh√©rentes</a> .  Mais nous voulions remplacer le principal stockage coh√©rent, Microsoft SQL Server, qui est utilis√© depuis la fondation d'Odnoklassniki.  Le stockage comprenait plus de 300 machines SQL Server Standard Edition, qui contenaient 50 To de donn√©es - entit√©s commerciales.  Ces donn√©es sont modifi√©es dans le cadre des transactions ACID et n√©cessitent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une coh√©rence √©lev√©e</a> . <br><br>  Pour r√©partir les donn√©es entre les n≈ìuds SQL Server, nous avons utilis√© un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partitionnement</a> vertical et horizontal ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partitionnement</a> ).  Historiquement, nous avons utilis√© un sch√©ma de partage de donn√©es simple: chaque entit√© √©tait associ√©e √† un jeton - une fonction de l'ID de l'entit√©.  Les entit√©s avec le m√™me jeton ont √©t√© plac√©es sur le m√™me serveur SQL.  La relation de type ma√Ætre-d√©tail a √©t√© impl√©ment√©e de sorte que les jetons des enregistrements principaux et g√©n√©r√©s co√Øncident toujours et se trouvent sur le m√™me serveur.  Dans un r√©seau social, presque tous les enregistrements sont g√©n√©r√©s au nom d'un utilisateur, ce qui signifie que toutes les donn√©es utilisateur d'un m√™me sous-syst√®me fonctionnel sont stock√©es sur un serveur.  Autrement dit, les tables d'un serveur SQL ont presque toujours particip√© √† une transaction commerciale, ce qui a permis d'assurer la coh√©rence des donn√©es √† l'aide de transactions ACID locales, sans avoir besoin de transactions ACID distribu√©es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lentes et peu fiables</a> . <br><br>  Gr√¢ce au sharding et √† l'acc√©l√©ration de SQL: <br><br><ul><li>  Nous n'utilisons pas de contraintes de cl√© √©trang√®re, car lors du partage, l'ID d'entit√© peut √™tre sur un autre serveur. </li><li>  Nous n'utilisons pas de proc√©dures stock√©es et de d√©clencheurs en raison de la charge suppl√©mentaire sur le processeur du SGBD. </li><li>  Nous n'utilisons pas de JOIN √† cause de tout ce qui pr√©c√®de et de nombreuses lectures al√©atoires √† partir du disque. </li><li>  En dehors d'une transaction, pour r√©duire les blocages, nous utilisons le niveau d'isolement Read Uncommitted. </li><li>  Nous n'effectuons que des transactions courtes (en moyenne, inf√©rieures √† 100 ms). </li><li>  Nous n'utilisons pas UPDATE et DELETE sur plusieurs lignes en raison du grand nombre de blocages - nous mettons √† jour un seul enregistrement. </li><li>  Nous n'ex√©cutons toujours les requ√™tes que par index - une requ√™te avec un plan pour une analyse compl√®te de la table signifie pour nous une surcharge de la base de donn√©es et son √©chec. </li></ul><br>  Ces √©tapes ont permis d'extraire des performances presque maximales des serveurs SQL.  Cependant, les probl√®mes sont devenus de plus en plus.  Regardons-les. <br><br><h2>  Probl√®mes SQL </h2><br><ul><li>  Depuis que nous avons utilis√© le partage propri√©taire, les administrateurs ont ajout√© manuellement de nouveaux fragments.  Pendant tout ce temps, les r√©pliques de donn√©es √©volutives n'ont pas r√©pondu aux demandes. </li><li>  √Ä mesure que le nombre d'enregistrements dans la table augmente, la vitesse d'insertion et de modification diminue, lors de l'ajout d'index √† une table existante, la vitesse diminue plusieurs fois, la cr√©ation et la recr√©ation d'index s'accompagnent de temps d'arr√™t. </li><li>  Avoir peu de Windows pour SQL Server en production rend la gestion de votre infrastructure difficile </li></ul><br>  Mais le principal probl√®me est <br><br><h2>  Tol√©rance aux pannes </h2><br>  Classic SQL Server a une faible tol√©rance aux pannes.  Supposons que vous n'ayez qu'un seul serveur de base de donn√©es et qu'il √©choue une fois tous les trois ans.  Pour le moment, le site ne fonctionne pas pendant 20 minutes, c'est acceptable.  Si vous avez 64 serveurs, le site ne fonctionne pas une fois toutes les trois semaines.  Et si vous avez 200 serveurs, le site ne fonctionne pas toutes les semaines.  C'est un probl√®me. <br><br>  Que peut-on faire pour am√©liorer la r√©silience de SQL Server?  Wikipedia nous propose de construire un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cluster hautement accessible</a> : l√† o√π en cas de panne de l'un des composants il y en a un en double. <br><br>  Cela n√©cessite une flotte d'√©quipements co√ªteux: redondance multiple, fibre, stockage partag√©, et l'inclusion d'une r√©serve ne fonctionne pas de mani√®re fiable: environ 10% des inclusions √©chouent avec un n≈ìud de sauvegarde par le moteur derri√®re le n≈ìud principal. <br><br>  Mais le principal inconv√©nient d'un tel cluster hautement accessible est la disponibilit√© nulle en cas de panne du datacenter dans lequel il se trouve.  Odnoklassniki dispose de quatre centres de donn√©es, et nous devons fournir du travail en cas d'accident complet dans l'un d'entre eux. <br><br>  Pour ce faire, vous pouvez utiliser la r√©plication multima√Ætre int√©gr√©e √† SQL Server.  Cette solution est beaucoup plus co√ªteuse en raison du co√ªt du logiciel et souffre de probl√®mes bien connus de r√©plication - des retards de transaction impr√©visibles pendant la r√©plication synchrone et des retards dans l'utilisation de la r√©plication (et, par cons√©quent, des modifications perdues) pendant asynchrone.  La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©solution manuelle</a> implicite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des conflits</a> rend cette option totalement inapplicable pour nous. <br><br>  Tous ces probl√®mes n√©cessitaient une solution radicale et nous en avons proc√©d√© √† une analyse d√©taill√©e.  Ici, nous devons nous familiariser avec ce que fait essentiellement SQL Server - les transactions. <br><br><h2>  Transaction simple </h2><br>  Consid√©rez la plus simple, du point de vue d'un programmeur SQL appliqu√©, la transaction: ajouter une photo √† un album.  Les albums et les photos sont stock√©s dans diff√©rentes plaques.  L'album a un comptoir photo public.  Une telle transaction est ensuite divis√©e en plusieurs √©tapes: <br><br><ol><li>  Nous verrouillons l'album par cl√©. </li><li>  Cr√©ez une entr√©e dans le tableau de photos. </li><li>  Si la photo a un statut public, nous liquidons le compteur de photos public dans l'album, mettons √† jour l'enregistrement et validons la transaction. </li></ol><br>  Ou sous forme de pseudo-code: <br><br><pre><code class="hljs pgsql">TX.<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>("Albums", id); Album album = albums.<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(id); Photo photo = photos.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(‚Ä¶); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (photo.status == <span class="hljs-built_in"><span class="hljs-built_in">PUBLIC</span></span> ) { album.incPublicPhotosCount(); } album.<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>(); TX.<span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>();</code> </pre> <br>  Nous constatons que le sc√©nario de transaction commerciale le plus courant consiste √† lire les donn√©es de la base de donn√©es dans la m√©moire du serveur d'applications, √† modifier quelque chose et √† enregistrer les nouvelles valeurs dans la base de donn√©es.  Habituellement, dans une telle transaction, nous mettons √† jour plusieurs entit√©s, plusieurs tables. <br><br>  Lors de l'ex√©cution d'une transaction, une modification comp√©titive des m√™mes donn√©es d'un autre syst√®me peut se produire.  Par exemple, Antispam peut d√©cider que l'utilisateur est suspect et donc toutes les photos de l'utilisateur ne devraient plus √™tre publiques, elles doivent √™tre envoy√©es pour mod√©ration, ce qui signifie changer photo.status √† une autre valeur et d√©visser les compteurs correspondants.  √âvidemment, si cette op√©ration se produit sans garantie d'atomicit√© d'application et d'isolement des modifications concurrentes, comme dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ACID</a> , le r√©sultat ne sera pas ce qui est n√©cessaire - soit le compteur de photos affichera la mauvaise valeur, soit toutes les photos ne seront pas envoy√©es pour mod√©ration. <br><br>  Il y a beaucoup de code similaire qui manipule diverses entit√©s commerciales dans le cadre d'une transaction pendant toute l'existence d'Odnoklassniki.  De l'exp√©rience de la migration vers NoSQL avec une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">coh√©rence √©ventuelle,</a> nous savons que les plus grandes difficult√©s (et les co√ªts en temps) sont la n√©cessit√© de d√©velopper un code visant √† maintenir la coh√©rence des donn√©es.  Par cons√©quent, nous avons consid√©r√© la principale exigence d'un nouveau r√©f√©rentiel pour fournir des transactions ACID logiques r√©elles pour la logique d'application. <br><br>  D'autres exigences tout aussi importantes √©taient: <br><br><ul><li>  Si le centre de donn√©es tombe en panne, la lecture et l'√©criture sur le nouveau stockage doivent √™tre disponibles. </li><li>  Garder la vitesse de d√©veloppement actuelle.  Autrement dit, lorsque vous travaillez avec un nouveau r√©f√©rentiel, la quantit√© de code doit √™tre √† peu pr√®s la m√™me, il ne devrait pas √™tre n√©cessaire d'ajouter quelque chose au r√©f√©rentiel, de d√©velopper des algorithmes pour r√©soudre les conflits, maintenir des index secondaires, etc. </li><li>  La vitesse du nouveau stockage devrait √™tre suffisamment √©lev√©e √† la fois lors de la lecture des donn√©es et lors du traitement des transactions, ce qui signifiait effectivement l'inapplicabilit√© de solutions universellement rigoureuses, universelles mais lentes, telles que, par exemple, les validations en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deux phases</a> . </li><li>  Mise √† l'√©chelle automatique √† la vol√©e. </li><li>  Utiliser des serveurs ordinaires bon march√©, sans avoir besoin d'acheter des morceaux de fer exotiques. </li><li>  La possibilit√© de d√©velopper le stockage par les d√©veloppeurs de l'entreprise.  En d'autres termes, la priorit√© a √©t√© donn√©e √† leurs propres solutions ou √† des solutions open source, de pr√©f√©rence en Java. </li></ul><br><h2>  D√©cisions, d√©cisions </h2><br>  En analysant les solutions possibles, nous sommes arriv√©s √† deux choix d'architecture possibles: <br><br>  La premi√®re consiste √† prendre n'importe quel serveur SQL et √† impl√©menter la tol√©rance aux pannes, le m√©canisme de mise √† l'√©chelle, le cluster de basculement, la r√©solution des conflits et les transactions ACID distribu√©s, fiables et rapides.  Nous avons √©valu√© cette option comme √©tant tr√®s simple et longue. <br><br>  La deuxi√®me option consiste √† prendre un r√©f√©rentiel NoSQL pr√™t √† l'emploi avec mise √† l'√©chelle impl√©ment√©e, un cluster de basculement, la r√©solution des conflits et √† impl√©menter nous-m√™mes les transactions et SQL.  √Ä premi√®re vue, m√™me la t√¢che d'impl√©mentation de SQL, sans parler des transactions ACID, ressemble √† une t√¢che pendant des ann√©es.  Mais ensuite, nous avons r√©alis√© que l'ensemble de fonctionnalit√©s SQL que nous utilisons dans la pratique est aussi loin de ANSI SQL que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cassandra CQL est</a> loin de ANSI SQL.  En examinant de plus pr√®s le CQL, nous avons r√©alis√© qu'il √©tait suffisamment proche de ce dont nous avions besoin. <br><br><h2>  Cassandra et CQL </h2><br>  Alors, qu'est-ce qui est int√©ressant avec Cassandra, quelles sont ses capacit√©s? <br><br>  Tout d'abord, ici, vous pouvez cr√©er des tableaux avec la prise en charge de divers types de donn√©es, vous pouvez faire SELECT ou UPDATE sur la cl√© primaire. <br><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> photos (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span> <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span>, owner <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span>,‚Ä¶); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> photos <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>=?; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> photos <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>=?;</code> </pre> <br>  Pour garantir la coh√©rence des donn√©es de r√©plique, Cassandra utilise une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">approche de quorum</a> .  Dans le cas le plus simple, cela signifie que lorsque trois r√©pliques de la m√™me ligne sont plac√©es sur des n≈ìuds diff√©rents du cluster, l'enregistrement est consid√©r√© comme r√©ussi si la plupart des n≈ìuds (c'est-√†-dire deux sur trois) confirment le succ√®s de cette op√©ration d'√©criture.  Les donn√©es d'une s√©rie sont consid√©r√©es comme coh√©rentes si, √† la lecture, la plupart des n≈ìuds ont √©t√© interrog√©s et confirm√©s.  Ainsi, avec la pr√©sence de trois r√©pliques, la coh√©rence compl√®te et instantan√©e des donn√©es est garantie en cas de d√©faillance d'un n≈ìud.  Cette approche nous a permis de mettre en ≈ìuvre un sch√©ma encore plus fiable: toujours envoyer des demandes aux trois r√©pliques, en attendant une r√©ponse des deux plus rapides.  La r√©ponse tardive de la troisi√®me r√©plique est ensuite ignor√©e.  Un n≈ìud en retard avec une r√©ponse peut avoir de graves probl√®mes - freins, r√©cup√©ration de place dans la JVM, r√©cup√©ration directe de m√©moire dans le noyau linux, panne mat√©rielle, d√©connexion du r√©seau.  Cependant, cela n'affecte pas les op√©rations ou les donn√©es du client. <br><br>  L'approche lorsque nous nous tournons vers trois n≈ìuds et obtenons une r√©ponse de deux s'appelle la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sp√©culation</a> : une demande de remarques suppl√©mentaires est envoy√©e avant m√™me qu'elle ne ¬´tombe¬ª. <br><br>  Un autre avantage de Cassandra est Batchlog - un m√©canisme qui garantit soit une application compl√®te, soit une non-application compl√®te de l'ensemble des modifications que vous apportez.  Cela nous permet de r√©soudre A dans ACID - atomicit√© hors de la bo√Æte. <br><br>  Les transactions les plus proches de Cassandra sont les ¬´ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">transactions l√©g√®res</a> ¬ª.  Mais ils sont loin d'√™tre des transactions "r√©elles" ACID: en fait, c'est l'occasion de faire du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CAS</a> sur des donn√©es d'un seul enregistrement, en utilisant le consensus sur le lourd protocole Paxos.  Par cons√©quent, la vitesse de ces transactions est faible. <br><br><h2>  Ce que nous avons manqu√© √† Cassandra </h2><br>  Nous avons donc d√ª impl√©menter de v√©ritables transactions ACID √† Cassandra.  √Ä l'aide de laquelle nous pourrions facilement impl√©menter deux autres fonctionnalit√©s pratiques du SGBD classique: des index rapides et coh√©rents, qui nous permettraient d'effectuer un √©chantillonnage de donn√©es non seulement sur la cl√© primaire et le g√©n√©rateur habituel d'ID d'auto-incr√©mentation monotone. <br><br><h4>  C * un </h4><br>  Ainsi, le nouveau SGBD <b>C * One</b> est n√©, compos√© de trois types de n≈ìuds de serveur: <br><br><ul><li>  Stockage - les serveurs Cassandra (presque) standard charg√©s du stockage des donn√©es sur les disques locaux.  √Ä mesure que la charge et la quantit√© de donn√©es augmentent, leur nombre peut facilement √™tre mis √† l'√©chelle √† des dizaines ou des centaines. </li><li>  Coordinateurs de transactions - Permet l'ex√©cution de transactions. </li><li>  Les clients sont des serveurs d'applications qui mettent en ≈ìuvre des op√©rations commerciales et initient des transactions.  Il peut y avoir des milliers de ces clients. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/eb6/f4f/498/eb6f4f4983f44dcbe63cd545e87f8d1a.png"><br><br>  Tous les types de serveurs sont dans un cluster commun, utilisez le protocole de message interne Cassandra pour communiquer entre eux et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">potins</a> pour √©changer des informations sur le cluster.  Avec l'aide de Heartbeat, les serveurs apprennent les d√©faillances mutuelles, prennent en charge un sch√©ma de donn√©es unique - les tables, leur structure et leur r√©plication;  sch√©ma de partitionnement, topologie de cluster, etc. <br><br><h4>  Les clients </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/b83/9ff/971/b839ff971b0049d56d55bd309f44ae4e.png"><br><br>  Au lieu des pilotes standard, le mode Fat Client est utilis√©.  Un tel n≈ìud ne stocke pas de donn√©es, mais peut agir en tant que coordinateur de l'ex√©cution des requ√™tes, c'est-√†-dire que le Client lui-m√™me remplit la fonction de coordinateur de ses requ√™tes: il interroge les r√©f√©rentiels de r√©pliques et r√©sout les conflits.  Ceci est non seulement plus fiable et plus rapide qu'un pilote standard qui n√©cessite une communication avec un coordinateur distant, mais vous permet √©galement de contr√¥ler le transfert des demandes.  En dehors d'une transaction ouverte sur le client, les demandes sont envoy√©es au stockage.  Si le client a ouvert la transaction, toutes les demandes de la transaction sont envoy√©es au coordinateur de transaction. <br><img src="https://habrastorage.org/getpro/habr/post_images/d39/d43/483/d39d43483590319f4d49e41a25316058.png"><br><br><h2>  Coordinateur de transactions C * One </h2><br>  Le coordinateur est ce que nous avons impl√©ment√© pour C * One √† partir de z√©ro.  Il est responsable de la gestion des transactions, des verrous et de l'ordre dans lequel les transactions sont appliqu√©es. <br><br>  Pour chaque transaction trait√©e, le coordinateur g√©n√®re un horodatage: chaque horodatage suivant est sup√©rieur √† la transaction pr√©c√©dente.  √âtant donn√© que le syst√®me de r√©solution des conflits de Cassandra est bas√© sur des horodatages (sur deux enregistrements en conflit, l'actuel avec le dernier horodatage est consid√©r√© comme pertinent), le conflit sera toujours r√©solu en faveur de la transaction suivante.  Ainsi, nous avons impl√©ment√© les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">montres Lamport</a> - un moyen peu co√ªteux de r√©soudre les conflits dans un syst√®me distribu√©. <br><br><h2>  Serrures </h2><br>  Pour garantir l'isolement, nous avons d√©cid√© d'utiliser la m√©thode la plus simple: des verrous pessimistes sur la cl√© primaire de l'enregistrement.  En d'autres termes, dans une transaction, l'enregistrement doit d'abord √™tre verrouill√©, puis lu, modifi√© et sauvegard√©.  Ce n'est qu'apr√®s une validation r√©ussie qu'un enregistrement peut √™tre d√©verrouill√© afin que les transactions concurrentes puissent l'utiliser. <br><br>  L'impl√©mentation de ce verrou est simple dans un environnement non allou√©.  Il existe deux fa√ßons principales dans un syst√®me distribu√©: soit d'impl√©menter un verrouillage distribu√© sur le cluster, soit de r√©partir les transactions de sorte que les transactions impliquant un seul enregistrement soient toujours g√©r√©es par le m√™me coordinateur. <br><br>  √âtant donn√© que dans notre cas, les donn√©es sont d√©j√† distribu√©es par des groupes de transactions locaux dans SQL, il a √©t√© d√©cid√© d'affecter des groupes de transactions locaux aux coordinateurs: un coordinateur effectue toutes les transactions avec un token de 0 √† 9, le second avec un token de 10 √† 19, etc.  Par cons√©quent, chacune des instances de coordinateur devient un ma√Ætre de groupe de transactions. <br><br>  Ensuite, les verrous peuvent √™tre impl√©ment√©s comme un HashMap banal dans la m√©moire du coordinateur. <br><br><h2>  √âchecs du coordinateur </h2><br>  √âtant donn√© qu'un coordinateur dessert exclusivement un groupe de transactions, il est tr√®s important de d√©terminer rapidement le fait de son √©chec, afin qu'une tentative r√©p√©t√©e d'ex√©cuter la transaction soit expir√©e.  Pour le rendre rapide et fiable, nous avons appliqu√© un protocole de rythme cardiaque de quorum enti√®rement connect√©: <br><br>  Chaque centre de donn√©es poss√®de au moins deux n≈ìuds coordinateurs.  P√©riodiquement, chaque coordinateur envoie un message de pulsation aux autres coordinateurs et les informe de leur fonctionnement, ainsi que les messages de pulsation √† partir desquels les coordinateurs du cluster pour la derni√®re fois. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cde/1e4/ccd/cde1e4ccd6d23620eda08adc231aeec7.jpg"><br><br>  Apr√®s avoir re√ßu des informations similaires des autres dans la composition de leurs messages de pulsation, chaque coordinateur d√©cide lui-m√™me quels n≈ìuds de cluster fonctionnent et lesquels ne sont pas guid√©s par le principe du quorum: si le n≈ìud X a re√ßu des informations de la majorit√© des n≈ìuds du cluster sur la r√©ception normale des messages du n≈ìud Y, alors , Y fonctionne.  Inversement, d√®s que la majorit√© signale la perte de messages du n≈ìud Y, alors Y a √©chou√©.  Il est curieux que si un quorum indique au n≈ìud X qu'il n'en re√ßoit pas plus de messages, le n≈ìud X lui-m√™me se consid√©rera comme ayant √©chou√©. <br><br>  Les messages de pulsation sont envoy√©s √† une fr√©quence √©lev√©e, environ 20 fois par seconde, avec une p√©riode de 50 ms.  En Java, il est difficile de garantir une r√©ponse d'application de 50 ms en raison de la dur√©e comparable des pauses provoqu√©es par le garbage collector.  Nous avons pu atteindre un tel temps de r√©ponse en utilisant le garbage collector G1, ce qui nous permet de sp√©cifier la cible pour la dur√©e des pauses du GC.  Cependant, parfois, assez rarement, la pause du collecteur d√©passe 50 ms, ce qui peut conduire √† une fausse d√©tection d'√©chec.  Pour √©viter cela, le coordinateur ne signale pas l'√©chec du n≈ìud distant lorsque le premier message de pulsation en dispara√Æt, seulement si plusieurs disparaissent cons√©cutivement. Nous avons donc r√©ussi √† d√©tecter l'√©chec du n≈ìud du coordinateur en 200 ms. <br><br>  Mais il ne suffit pas de comprendre rapidement quel n≈ìud a cess√© de fonctionner.  Vous devez y faire quelque chose. <br><br><h2>  R√©servation </h2><br>  Le sch√©ma classique suppose qu'en cas de refus d'un ma√Ætre de lancer une nouvelle √©lection en utilisant l'un des algorithmes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">universels</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√†</a> la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mode</a> .  Cependant, ces algorithmes ont des probl√®mes bien connus avec la convergence temporelle et la dur√©e du processus √©lectoral lui-m√™me.  Nous avons r√©ussi √† √©viter de tels retards suppl√©mentaires en utilisant le circuit √©quivalent de coordinateurs dans un r√©seau enti√®rement connect√©: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e90/45e/007/e9045e00777362a5846eb78ef15bedea.png"><br><br>  Supposons que nous voulons ex√©cuter une transaction dans le groupe 50. Nous d√©terminerons √† l'avance un sch√©ma de substitution, c'est-√†-dire quels n≈ìuds ex√©cuteront les transactions du groupe 50 en cas de d√©faillance du coordinateur principal.  Notre objectif est de maintenir le syst√®me op√©rationnel en cas de panne du centre de donn√©es.  Nous d√©terminons que la premi√®re r√©serve sera un n≈ìud d'un autre centre de donn√©es, et la deuxi√®me r√©serve sera un n≈ìud du troisi√®me.  Ce sch√©ma est s√©lectionn√© une fois et ne change pas tant que la topologie du cluster ne change pas, c'est-√†-dire jusqu'√† ce que de nouveaux n≈ìuds y entrent (ce qui arrive tr√®s rarement).  La proc√©dure pour choisir un nouveau ma√Ætre actif en cas de d√©faillance de l'ancien sera toujours la suivante: la premi√®re r√©serve deviendra le ma√Ætre actif, et si elle a cess√© de fonctionner, la deuxi√®me r√©serve deviendra. <br><br>  Un tel sch√©ma est plus fiable que l'algorithme universel, car pour activer un nouveau ma√Ætre, il suffit de d√©terminer le fait de l'√©chec de l'ancien. <br><br>  Mais comment les clients comprendront-ils lequel des ma√Ætres travaille actuellement?  Pendant 50 ms, il n'est pas possible d'envoyer des informations √† des milliers de clients.  Une situation est possible lorsqu'un client envoie une demande d'ouverture de transaction, ne sachant pas encore que cet assistant ne fonctionne plus et que la demande se bloque sur un d√©lai d'attente.  Pour √©viter que cela ne se produise, les clients envoient de mani√®re sp√©culative une demande d'ouverture imm√©diate d'une transaction au ma√Ætre de groupe et √† ses deux r√©serves, mais seul celui qui est actuellement le ma√Ætre actif r√©pondra √† cette demande.  Le client effectuera toutes les communications ult√©rieures au sein de la transaction uniquement avec le ma√Ætre actif. <br><br>  Les ma√Ætres de sauvegarde re√ßoivent des demandes de transactions non propres dans la file d'attente des transactions √† na√Ætre, o√π elles sont stock√©es pendant un certain temps.  Si le ma√Ætre actif d√©c√®de, le nouveau ma√Ætre traite les demandes d'ouverture de transactions de sa file d'attente et r√©pond au client.  Si le client a d√©j√† r√©ussi √† ouvrir une transaction avec l'ancien ma√Ætre, alors la deuxi√®me r√©ponse est ignor√©e (et, √©videmment, une telle transaction ne sera pas termin√©e et sera r√©p√©t√©e par le client). <br><br><h2>  Fonctionnement d'une transaction </h2><br>  Supposons qu'un client envoie au coordinateur une demande d'ouverture d'une transaction pour une telle entit√© avec une telle cl√© primaire.  Le coordinateur verrouille cette entit√© et la place dans la table des verrous en m√©moire.  Si n√©cessaire, le coordinateur lit cette entit√© dans la m√©moire et stocke les donn√©es re√ßues dans un √©tat de transaction dans la m√©moire du coordinateur. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4d1/dfb/dcd/4d1dfbdcd92e4b05ca49ef5168177eb8.png"><br><br>  Lorsque le client souhaite modifier les donn√©es de la transaction, il envoie au coordinateur une demande de mise √† jour de l'entit√©, et il place les nouvelles donn√©es dans la table d'√©tat de la transaction en m√©moire.  Ceci termine l'enregistrement - l'enregistrement n'est pas effectu√© dans le r√©f√©rentiel. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/00e/803/570/00e803570a0fbe19cb76786cbc6f0142.png"><br><br>  Lorsqu'un client demande, dans le cadre d'une transaction active, ses propres donn√©es modifi√©es, le coordinateur agit ainsi: <br><br><ul><li>  si l'ID est d√©j√† dans la transaction, les donn√©es sont extraites de la m√©moire; </li><li>  s'il n'y a pas d'ID dans la m√©moire, les donn√©es manquantes sont lues √† partir des n≈ìuds de stockage, combin√©es avec celles d√©j√† en m√©moire, et le r√©sultat est renvoy√© au client. </li></ul><br>  Ainsi, le client peut lire ses propres modifications, tandis que d'autres clients ne voient pas ces modifications, car elles ne sont stock√©es que dans la m√©moire du coordinateur, elles ne sont pas encore dans les n≈ìuds Cassandra. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d8e/140/5f7/d8e1405f7995228ec3d061af59f1f685.png"><br><br>  Lorsque le client envoie une validation, l'√©tat dans la m√©moire du service est enregistr√© par le coordinateur dans le lot enregistr√©, et d√©j√† sous la forme d'un lot enregistr√©, il est envoy√© aux r√©f√©rentiels Cassandra.  Les r√©f√©rentiels font tout ce qui est n√©cessaire pour que ce package soit appliqu√© (enti√®rement) atomiquement et retournent une r√©ponse au coordinateur, qui lib√®re les verrous et confirme le succ√®s de la transaction au client. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/090/739/9fc/0907399fc025879f16174ff26163a937.png"><br><br>  Et pour revenir au coordinateur, il suffit de lib√©rer la m√©moire occup√©e par l'√©tat de la transaction. <br><br>  √Ä la suite des am√©liorations ci-dessus, nous avons mis en ≈ìuvre les principes de l'ACID: <br><br><ul><li>  <b>Atomicit√©</b> .  Ceci est une garantie qu'aucune transaction ne sera partiellement engag√©e dans le syst√®me, toutes ses sous-op√©rations seront termin√©es, ou pas une seule ne sera ex√©cut√©e.  Nous respectons ce principe en raison du lot enregistr√© √† Cassandra. </li><li>  <b>Coh√©rence</b> .  Chaque transaction r√©ussie, par d√©finition, ne capture que des r√©sultats acceptables.  Si, apr√®s l'ouverture d'une transaction et l'ex√©cution d'une partie des op√©rations, il s'av√®re que le r√©sultat n'est pas valide, une restauration est effectu√©e. </li><li>  <b>Isolement</b> .  Lorsqu'une transaction est ex√©cut√©e, les transactions parall√®les ne doivent pas affecter son r√©sultat.  Les transactions concurrentes sont isol√©es √† l'aide de verrous pessimistes sur le coordinateur.  Pour les lectures en dehors de la transaction, le principe d'isolement au niveau Read Committed est respect√©. </li><li>  <b>Durabilit√©</b> .  Ind√©pendamment des probl√®mes aux niveaux inf√©rieurs - mise hors tension du syst√®me, d√©faillance mat√©rielle, - les modifications apport√©es par une transaction r√©ussie doivent rester enregistr√©es apr√®s la reprise de l'op√©ration. </li></ul><br><h2>  Lecture d'index </h2><br>  Prenez un tableau simple: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> photos ( id <span class="hljs-type"><span class="hljs-type">bigint</span></span> <span class="hljs-keyword"><span class="hljs-keyword">primary key</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">owner</span></span> <span class="hljs-type"><span class="hljs-type">bigint</span></span>, modified <span class="hljs-type"><span class="hljs-type">timestamp</span></span>, ‚Ä¶)</code> </pre> <br>  Elle a un identifiant (cl√© primaire), un propri√©taire et une date de changement.  Vous devez faire une demande tr√®s simple - s√©lectionnez les informations du propri√©taire avec la date de changement "pour le dernier jour". <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> owner=? <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> modified&gt;?</code> </pre> <br>  Pour qu'une telle requ√™te fonctionne rapidement, dans le SGBD SQL classique, vous devez cr√©er un index par colonnes (propri√©taire, modifi√©).  Nous pouvons le faire tout simplement, puisque nous avons maintenant des garanties ACID! <br><br><h2>  Indices en C * One </h2><br>  Il existe une table source avec des photos, dans laquelle l'ID d'enregistrement est la cl√© primaire. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/039/5b3/a78/0395b3a784329992b88ba0618a94a7f1.jpg"><br><br>  Pour l'index C *, One cr√©e une nouvelle table, qui est une copie de l'original.  La cl√© correspond √† l'expression d'index et comprend √©galement la cl√© primaire de l'enregistrement de la table source: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/92a/8c2/93e/92a8c293e8c145dc37f49a5126e68095.jpg"><br><br>  Maintenant, la demande pour le "propri√©taire du dernier jour" peut √™tre r√©√©crite en s√©lectionnant dans une autre table: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> i1_test <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> owner=? <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> modified&gt;?</code> </pre> <br>  La coh√©rence des donn√©es de la table de photos d'origine et de l'index i1 est maintenue automatiquement par le coordinateur.  Sur la base du sch√©ma de donn√©es seul, lorsque le changement est re√ßu, le coordinateur g√©n√®re et se souvient du changement non seulement dans le tableau principal, mais √©galement dans les copies.  Aucune action suppl√©mentaire n'est effectu√©e avec la table d'index, les journaux ne sont pas lus, les verrous ne sont pas utilis√©s.  En d'autres termes, l'ajout d'index ne consomme presque pas de ressources et n'affecte pratiquement pas la vitesse d'application des modifications. <br><br>  En utilisant ACID, nous avons pu impl√©menter des index ¬´comme en SQL¬ª.  Ils ont une coh√©rence, peuvent √™tre mis √† l'√©chelle, fonctionnent rapidement, peuvent √™tre composites et int√©gr√©s dans le langage de requ√™te CQL.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour prendre en charge les index, vous n'avez pas besoin de modifier le code d'application. </font><font style="vertical-align: inherit;">Tout est simple, comme en SQL. </font><font style="vertical-align: inherit;">Et surtout, les index n'affectent pas la vitesse d'ex√©cution des modifications apport√©es √† la table de transactions d'origine.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Qu'est-il arriv√©? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons d√©velopp√© C * One il y a trois ans et l'avons mis en service commercial. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'avons-nous finalement obtenu? √âvaluons cela en utilisant l'exemple d'un sous-syst√®me de traitement et de stockage de photos, l'un des types de donn√©es les plus importants d'un r√©seau social. Il ne s'agit pas du corps des photos elles-m√™mes, mais de toutes sortes de m√©ta-informations. Or, √† Odnoklassniki, il existe environ 20 milliards de ces enregistrements, le syst√®me traite 80 000 demandes de lecture par seconde, jusqu'√† 8 000 transactions ACID par seconde associ√©es √† la modification des donn√©es. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque nous avons utilis√© SQL avec un facteur de r√©plication = 1 (mais en RAID 10), les m√©ta-informations photo ont √©t√© stock√©es sur un cluster hautement accessible de 32 machines avec Microsoft SQL Server (plus 11 de sauvegarde). Il a √©galement allou√© 10 serveurs pour le stockage des sauvegardes. Un total de 50 voitures ch√®res. Dans le m√™me temps, le syst√®me fonctionnait √† charge nominale, sans r√©serve.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s la migration vers le nouveau syst√®me, nous avons obtenu un facteur de r√©plication = 3 - une copie dans chaque centre de donn√©es. Le syst√®me comprend 63 n≈ìuds de stockage Cassandra et 6 machines coordinatrices, totalisant 69 serveurs. Mais ces machines sont beaucoup moins ch√®res, leur co√ªt total est d'environ 30% du co√ªt du syst√®me en SQL. Dans ce cas, la charge est maintenue √† 30%. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avec l'introduction de C * One, les retards ont √©galement diminu√©: en SQL, l'op√©ration d'√©criture prenait environ 4,5 ms. En C * One - environ 1,6 ms. La dur√©e de la transaction est en moyenne inf√©rieure √† 40 ms, la validation est effectu√©e en 2 ms, la dur√©e de lecture et d'√©criture est en moyenne de 2 ms. Le 99e centile - seulement 3-3,1 ms, le nombre de d√©lais d'attente a diminu√© de 100 fois - tout cela en raison de l'utilisation g√©n√©ralis√©e de la sp√©culation.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä ce jour, la plupart des n≈ìuds SQL Server ont √©t√© mis hors service; les nouveaux produits sont d√©velopp√©s uniquement √† l'aide de C * One. </font><font style="vertical-align: inherit;">Nous avons adapt√© C * One pour travailler dans notre </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cloud unique</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ce qui nous a permis d'acc√©l√©rer le d√©ploiement de nouveaux clusters, de simplifier la configuration et d'automatiser le fonctionnement. </font><font style="vertical-align: inherit;">Sans code source, ce serait beaucoup plus difficile et difficile √† r√©aliser. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous travaillons sur le transfert de nos autres installations de stockage vers le cloud - mais c'est une histoire compl√®tement diff√©rente.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr417593/">https://habr.com/ru/post/fr417593/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr417583/index.html">Tomorrow ICFP Contest 2018, cheers! (+ utile pour participer pour la premi√®re fois)</a></li>
<li><a href="../fr417585/index.html">Comment int√©grer le comit√© de programme d'une conf√©rence de classe et pourquoi en avez-vous besoin</a></li>
<li><a href="../fr417587/index.html">M√©dias: les cyberattaques √† grande √©chelle ont acc√©l√©r√© la croissance de la capitalisation des entreprises du secteur de la s√©curit√© de l'information</a></li>
<li><a href="../fr417589/index.html">Sept r√®gles simples pour rendre Internet accessible √† tous</a></li>
<li><a href="../fr417591/index.html">Comment "apprendre" l'anglais en un an par vous-m√™me ou un article pour ceux qui ne s'entra√Ænent pas avec l'anglais</a></li>
<li><a href="../fr417595/index.html">Antiquit√©s: Palm OS, code efficace et photos d√©go√ªtantes</a></li>
<li><a href="../fr417597/index.html">Stockage s√©curis√© avec DRBD9 et Proxmox (Partie 2: iSCSI + LVM)</a></li>
<li><a href="../fr417599/index.html">Recueil Fintech: les r√©gulateurs financiers ont besoin de l'IA pour travailler dans des conditions modernes</a></li>
<li><a href="../fr417601/index.html">Choisissez un serveur. Que chercher? Liste de contr√¥le</a></li>
<li><a href="../fr417603/index.html">Annonce d'un mitap mobile: que faire lorsque l'application est devenue volumineuse?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>