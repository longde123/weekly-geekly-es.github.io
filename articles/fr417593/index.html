<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📩 👧🏽 🍃 NewSQL = NoSQL + ACID 🙆🏿 🙉 🌃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jusqu'à récemment, à Odnoklassniki, environ 50 To de données en temps réel étaient stockées dans SQL Server. Pour un tel volume, il est presque imposs...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>NewSQL = NoSQL + ACID</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odnoklassniki/blog/417593/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/t5/hc/h2/t5hch2mr-lw9ffeahr_9gaxizlg.jpeg" width="600"></div><br>  Jusqu'à récemment, à Odnoklassniki, environ 50 To de données en temps réel étaient stockées dans SQL Server.  Pour un tel volume, il est presque impossible de fournir un accès au centre de données rapide, fiable et même à sécurité intégrée à l'aide de SGBD SQL.  Habituellement, dans de tels cas, ils utilisent l'un des référentiels NoSQL, mais tout ne peut pas être transféré vers NoSQL: certaines entités exigent des garanties de transactions ACID. <br><br>  Cela nous a amenés à utiliser le stockage NewSQL, c'est-à-dire un SGBD qui offre la tolérance aux pannes, l'évolutivité et les performances des systèmes NoSQL, tout en préservant les garanties ACID familières aux systèmes classiques.  Il y a peu de systèmes industriels qui fonctionnent dans cette nouvelle classe, nous avons donc implémenté un tel système nous-mêmes et l'avons mis en service commercial. <br><br>  Comment cela fonctionne et ce qui s'est passé - lire sous la coupe. <br><a name="habracut"></a><br>  Aujourd'hui, l'audience mensuelle d'Odnoklassniki est de plus de 70 millions de visiteurs uniques.  Nous sommes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">parmi les cinq</a> plus grands réseaux sociaux du monde et les vingt sites sur lesquels les utilisateurs passent le plus de temps.  L'infrastructure "OK" gère des charges très élevées: plus d'un million de requêtes HTTP / sec vers les fronts.  Des parties du parc de serveurs de plus de 8 000 pièces sont situées à proximité les unes des autres - dans quatre centres de données de Moscou, ce qui permet une latence du réseau de moins de 1 ms entre elles. <br><br>  Nous utilisons Cassandra depuis 2010, à partir de la version 0.6.  Aujourd'hui, plusieurs dizaines de clusters sont en activité.  Le cluster le plus rapide traite plus de 4 millions d'opérations par seconde et le plus grand stocke 260 To. <br><br>  Cependant, tous ces clusters NoSQL ordinaires sont utilisés pour stocker <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des</a> données <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">peu cohérentes</a> .  Mais nous voulions remplacer le principal stockage cohérent, Microsoft SQL Server, qui est utilisé depuis la fondation d'Odnoklassniki.  Le stockage comprenait plus de 300 machines SQL Server Standard Edition, qui contenaient 50 To de données - entités commerciales.  Ces données sont modifiées dans le cadre des transactions ACID et nécessitent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une cohérence élevée</a> . <br><br>  Pour répartir les données entre les nœuds SQL Server, nous avons utilisé un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partitionnement</a> vertical et horizontal ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partitionnement</a> ).  Historiquement, nous avons utilisé un schéma de partage de données simple: chaque entité était associée à un jeton - une fonction de l'ID de l'entité.  Les entités avec le même jeton ont été placées sur le même serveur SQL.  La relation de type maître-détail a été implémentée de sorte que les jetons des enregistrements principaux et générés coïncident toujours et se trouvent sur le même serveur.  Dans un réseau social, presque tous les enregistrements sont générés au nom d'un utilisateur, ce qui signifie que toutes les données utilisateur d'un même sous-système fonctionnel sont stockées sur un serveur.  Autrement dit, les tables d'un serveur SQL ont presque toujours participé à une transaction commerciale, ce qui a permis d'assurer la cohérence des données à l'aide de transactions ACID locales, sans avoir besoin de transactions ACID distribuées <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lentes et peu fiables</a> . <br><br>  Grâce au sharding et à l'accélération de SQL: <br><br><ul><li>  Nous n'utilisons pas de contraintes de clé étrangère, car lors du partage, l'ID d'entité peut être sur un autre serveur. </li><li>  Nous n'utilisons pas de procédures stockées et de déclencheurs en raison de la charge supplémentaire sur le processeur du SGBD. </li><li>  Nous n'utilisons pas de JOIN à cause de tout ce qui précède et de nombreuses lectures aléatoires à partir du disque. </li><li>  En dehors d'une transaction, pour réduire les blocages, nous utilisons le niveau d'isolement Read Uncommitted. </li><li>  Nous n'effectuons que des transactions courtes (en moyenne, inférieures à 100 ms). </li><li>  Nous n'utilisons pas UPDATE et DELETE sur plusieurs lignes en raison du grand nombre de blocages - nous mettons à jour un seul enregistrement. </li><li>  Nous n'exécutons toujours les requêtes que par index - une requête avec un plan pour une analyse complète de la table signifie pour nous une surcharge de la base de données et son échec. </li></ul><br>  Ces étapes ont permis d'extraire des performances presque maximales des serveurs SQL.  Cependant, les problèmes sont devenus de plus en plus.  Regardons-les. <br><br><h2>  Problèmes SQL </h2><br><ul><li>  Depuis que nous avons utilisé le partage propriétaire, les administrateurs ont ajouté manuellement de nouveaux fragments.  Pendant tout ce temps, les répliques de données évolutives n'ont pas répondu aux demandes. </li><li>  À mesure que le nombre d'enregistrements dans la table augmente, la vitesse d'insertion et de modification diminue, lors de l'ajout d'index à une table existante, la vitesse diminue plusieurs fois, la création et la recréation d'index s'accompagnent de temps d'arrêt. </li><li>  Avoir peu de Windows pour SQL Server en production rend la gestion de votre infrastructure difficile </li></ul><br>  Mais le principal problème est <br><br><h2>  Tolérance aux pannes </h2><br>  Classic SQL Server a une faible tolérance aux pannes.  Supposons que vous n'ayez qu'un seul serveur de base de données et qu'il échoue une fois tous les trois ans.  Pour le moment, le site ne fonctionne pas pendant 20 minutes, c'est acceptable.  Si vous avez 64 serveurs, le site ne fonctionne pas une fois toutes les trois semaines.  Et si vous avez 200 serveurs, le site ne fonctionne pas toutes les semaines.  C'est un problème. <br><br>  Que peut-on faire pour améliorer la résilience de SQL Server?  Wikipedia nous propose de construire un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cluster hautement accessible</a> : là où en cas de panne de l'un des composants il y en a un en double. <br><br>  Cela nécessite une flotte d'équipements coûteux: redondance multiple, fibre, stockage partagé, et l'inclusion d'une réserve ne fonctionne pas de manière fiable: environ 10% des inclusions échouent avec un nœud de sauvegarde par le moteur derrière le nœud principal. <br><br>  Mais le principal inconvénient d'un tel cluster hautement accessible est la disponibilité nulle en cas de panne du datacenter dans lequel il se trouve.  Odnoklassniki dispose de quatre centres de données, et nous devons fournir du travail en cas d'accident complet dans l'un d'entre eux. <br><br>  Pour ce faire, vous pouvez utiliser la réplication multimaître intégrée à SQL Server.  Cette solution est beaucoup plus coûteuse en raison du coût du logiciel et souffre de problèmes bien connus de réplication - des retards de transaction imprévisibles pendant la réplication synchrone et des retards dans l'utilisation de la réplication (et, par conséquent, des modifications perdues) pendant asynchrone.  La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">résolution manuelle</a> implicite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des conflits</a> rend cette option totalement inapplicable pour nous. <br><br>  Tous ces problèmes nécessitaient une solution radicale et nous en avons procédé à une analyse détaillée.  Ici, nous devons nous familiariser avec ce que fait essentiellement SQL Server - les transactions. <br><br><h2>  Transaction simple </h2><br>  Considérez la plus simple, du point de vue d'un programmeur SQL appliqué, la transaction: ajouter une photo à un album.  Les albums et les photos sont stockés dans différentes plaques.  L'album a un comptoir photo public.  Une telle transaction est ensuite divisée en plusieurs étapes: <br><br><ol><li>  Nous verrouillons l'album par clé. </li><li>  Créez une entrée dans le tableau de photos. </li><li>  Si la photo a un statut public, nous liquidons le compteur de photos public dans l'album, mettons à jour l'enregistrement et validons la transaction. </li></ol><br>  Ou sous forme de pseudo-code: <br><br><pre><code class="hljs pgsql">TX.<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>("Albums", id); Album album = albums.<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(id); Photo photo = photos.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(…); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (photo.status == <span class="hljs-built_in"><span class="hljs-built_in">PUBLIC</span></span> ) { album.incPublicPhotosCount(); } album.<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>(); TX.<span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>();</code> </pre> <br>  Nous constatons que le scénario de transaction commerciale le plus courant consiste à lire les données de la base de données dans la mémoire du serveur d'applications, à modifier quelque chose et à enregistrer les nouvelles valeurs dans la base de données.  Habituellement, dans une telle transaction, nous mettons à jour plusieurs entités, plusieurs tables. <br><br>  Lors de l'exécution d'une transaction, une modification compétitive des mêmes données d'un autre système peut se produire.  Par exemple, Antispam peut décider que l'utilisateur est suspect et donc toutes les photos de l'utilisateur ne devraient plus être publiques, elles doivent être envoyées pour modération, ce qui signifie changer photo.status à une autre valeur et dévisser les compteurs correspondants.  Évidemment, si cette opération se produit sans garantie d'atomicité d'application et d'isolement des modifications concurrentes, comme dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ACID</a> , le résultat ne sera pas ce qui est nécessaire - soit le compteur de photos affichera la mauvaise valeur, soit toutes les photos ne seront pas envoyées pour modération. <br><br>  Il y a beaucoup de code similaire qui manipule diverses entités commerciales dans le cadre d'une transaction pendant toute l'existence d'Odnoklassniki.  De l'expérience de la migration vers NoSQL avec une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cohérence éventuelle,</a> nous savons que les plus grandes difficultés (et les coûts en temps) sont la nécessité de développer un code visant à maintenir la cohérence des données.  Par conséquent, nous avons considéré la principale exigence d'un nouveau référentiel pour fournir des transactions ACID logiques réelles pour la logique d'application. <br><br>  D'autres exigences tout aussi importantes étaient: <br><br><ul><li>  Si le centre de données tombe en panne, la lecture et l'écriture sur le nouveau stockage doivent être disponibles. </li><li>  Garder la vitesse de développement actuelle.  Autrement dit, lorsque vous travaillez avec un nouveau référentiel, la quantité de code doit être à peu près la même, il ne devrait pas être nécessaire d'ajouter quelque chose au référentiel, de développer des algorithmes pour résoudre les conflits, maintenir des index secondaires, etc. </li><li>  La vitesse du nouveau stockage devrait être suffisamment élevée à la fois lors de la lecture des données et lors du traitement des transactions, ce qui signifiait effectivement l'inapplicabilité de solutions universellement rigoureuses, universelles mais lentes, telles que, par exemple, les validations en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deux phases</a> . </li><li>  Mise à l'échelle automatique à la volée. </li><li>  Utiliser des serveurs ordinaires bon marché, sans avoir besoin d'acheter des morceaux de fer exotiques. </li><li>  La possibilité de développer le stockage par les développeurs de l'entreprise.  En d'autres termes, la priorité a été donnée à leurs propres solutions ou à des solutions open source, de préférence en Java. </li></ul><br><h2>  Décisions, décisions </h2><br>  En analysant les solutions possibles, nous sommes arrivés à deux choix d'architecture possibles: <br><br>  La première consiste à prendre n'importe quel serveur SQL et à implémenter la tolérance aux pannes, le mécanisme de mise à l'échelle, le cluster de basculement, la résolution des conflits et les transactions ACID distribués, fiables et rapides.  Nous avons évalué cette option comme étant très simple et longue. <br><br>  La deuxième option consiste à prendre un référentiel NoSQL prêt à l'emploi avec mise à l'échelle implémentée, un cluster de basculement, la résolution des conflits et à implémenter nous-mêmes les transactions et SQL.  À première vue, même la tâche d'implémentation de SQL, sans parler des transactions ACID, ressemble à une tâche pendant des années.  Mais ensuite, nous avons réalisé que l'ensemble de fonctionnalités SQL que nous utilisons dans la pratique est aussi loin de ANSI SQL que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cassandra CQL est</a> loin de ANSI SQL.  En examinant de plus près le CQL, nous avons réalisé qu'il était suffisamment proche de ce dont nous avions besoin. <br><br><h2>  Cassandra et CQL </h2><br>  Alors, qu'est-ce qui est intéressant avec Cassandra, quelles sont ses capacités? <br><br>  Tout d'abord, ici, vous pouvez créer des tableaux avec la prise en charge de divers types de données, vous pouvez faire SELECT ou UPDATE sur la clé primaire. <br><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> photos (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span> <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span>, owner <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span>,…); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> photos <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>=?; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> photos <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> … <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>=?;</code> </pre> <br>  Pour garantir la cohérence des données de réplique, Cassandra utilise une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">approche de quorum</a> .  Dans le cas le plus simple, cela signifie que lorsque trois répliques de la même ligne sont placées sur des nœuds différents du cluster, l'enregistrement est considéré comme réussi si la plupart des nœuds (c'est-à-dire deux sur trois) confirment le succès de cette opération d'écriture.  Les données d'une série sont considérées comme cohérentes si, à la lecture, la plupart des nœuds ont été interrogés et confirmés.  Ainsi, avec la présence de trois répliques, la cohérence complète et instantanée des données est garantie en cas de défaillance d'un nœud.  Cette approche nous a permis de mettre en œuvre un schéma encore plus fiable: toujours envoyer des demandes aux trois répliques, en attendant une réponse des deux plus rapides.  La réponse tardive de la troisième réplique est ensuite ignorée.  Un nœud en retard avec une réponse peut avoir de graves problèmes - freins, récupération de place dans la JVM, récupération directe de mémoire dans le noyau linux, panne matérielle, déconnexion du réseau.  Cependant, cela n'affecte pas les opérations ou les données du client. <br><br>  L'approche lorsque nous nous tournons vers trois nœuds et obtenons une réponse de deux s'appelle la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">spéculation</a> : une demande de remarques supplémentaires est envoyée avant même qu'elle ne «tombe». <br><br>  Un autre avantage de Cassandra est Batchlog - un mécanisme qui garantit soit une application complète, soit une non-application complète de l'ensemble des modifications que vous apportez.  Cela nous permet de résoudre A dans ACID - atomicité hors de la boîte. <br><br>  Les transactions les plus proches de Cassandra sont les « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">transactions légères</a> ».  Mais ils sont loin d'être des transactions "réelles" ACID: en fait, c'est l'occasion de faire du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CAS</a> sur des données d'un seul enregistrement, en utilisant le consensus sur le lourd protocole Paxos.  Par conséquent, la vitesse de ces transactions est faible. <br><br><h2>  Ce que nous avons manqué à Cassandra </h2><br>  Nous avons donc dû implémenter de véritables transactions ACID à Cassandra.  À l'aide de laquelle nous pourrions facilement implémenter deux autres fonctionnalités pratiques du SGBD classique: des index rapides et cohérents, qui nous permettraient d'effectuer un échantillonnage de données non seulement sur la clé primaire et le générateur habituel d'ID d'auto-incrémentation monotone. <br><br><h4>  C * un </h4><br>  Ainsi, le nouveau SGBD <b>C * One</b> est né, composé de trois types de nœuds de serveur: <br><br><ul><li>  Stockage - les serveurs Cassandra (presque) standard chargés du stockage des données sur les disques locaux.  À mesure que la charge et la quantité de données augmentent, leur nombre peut facilement être mis à l'échelle à des dizaines ou des centaines. </li><li>  Coordinateurs de transactions - Permet l'exécution de transactions. </li><li>  Les clients sont des serveurs d'applications qui mettent en œuvre des opérations commerciales et initient des transactions.  Il peut y avoir des milliers de ces clients. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/eb6/f4f/498/eb6f4f4983f44dcbe63cd545e87f8d1a.png"><br><br>  Tous les types de serveurs sont dans un cluster commun, utilisez le protocole de message interne Cassandra pour communiquer entre eux et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">potins</a> pour échanger des informations sur le cluster.  Avec l'aide de Heartbeat, les serveurs apprennent les défaillances mutuelles, prennent en charge un schéma de données unique - les tables, leur structure et leur réplication;  schéma de partitionnement, topologie de cluster, etc. <br><br><h4>  Les clients </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/b83/9ff/971/b839ff971b0049d56d55bd309f44ae4e.png"><br><br>  Au lieu des pilotes standard, le mode Fat Client est utilisé.  Un tel nœud ne stocke pas de données, mais peut agir en tant que coordinateur de l'exécution des requêtes, c'est-à-dire que le Client lui-même remplit la fonction de coordinateur de ses requêtes: il interroge les référentiels de répliques et résout les conflits.  Ceci est non seulement plus fiable et plus rapide qu'un pilote standard qui nécessite une communication avec un coordinateur distant, mais vous permet également de contrôler le transfert des demandes.  En dehors d'une transaction ouverte sur le client, les demandes sont envoyées au stockage.  Si le client a ouvert la transaction, toutes les demandes de la transaction sont envoyées au coordinateur de transaction. <br><img src="https://habrastorage.org/getpro/habr/post_images/d39/d43/483/d39d43483590319f4d49e41a25316058.png"><br><br><h2>  Coordinateur de transactions C * One </h2><br>  Le coordinateur est ce que nous avons implémenté pour C * One à partir de zéro.  Il est responsable de la gestion des transactions, des verrous et de l'ordre dans lequel les transactions sont appliquées. <br><br>  Pour chaque transaction traitée, le coordinateur génère un horodatage: chaque horodatage suivant est supérieur à la transaction précédente.  Étant donné que le système de résolution des conflits de Cassandra est basé sur des horodatages (sur deux enregistrements en conflit, l'actuel avec le dernier horodatage est considéré comme pertinent), le conflit sera toujours résolu en faveur de la transaction suivante.  Ainsi, nous avons implémenté les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">montres Lamport</a> - un moyen peu coûteux de résoudre les conflits dans un système distribué. <br><br><h2>  Serrures </h2><br>  Pour garantir l'isolement, nous avons décidé d'utiliser la méthode la plus simple: des verrous pessimistes sur la clé primaire de l'enregistrement.  En d'autres termes, dans une transaction, l'enregistrement doit d'abord être verrouillé, puis lu, modifié et sauvegardé.  Ce n'est qu'après une validation réussie qu'un enregistrement peut être déverrouillé afin que les transactions concurrentes puissent l'utiliser. <br><br>  L'implémentation de ce verrou est simple dans un environnement non alloué.  Il existe deux façons principales dans un système distribué: soit d'implémenter un verrouillage distribué sur le cluster, soit de répartir les transactions de sorte que les transactions impliquant un seul enregistrement soient toujours gérées par le même coordinateur. <br><br>  Étant donné que dans notre cas, les données sont déjà distribuées par des groupes de transactions locaux dans SQL, il a été décidé d'affecter des groupes de transactions locaux aux coordinateurs: un coordinateur effectue toutes les transactions avec un token de 0 à 9, le second avec un token de 10 à 19, etc.  Par conséquent, chacune des instances de coordinateur devient un maître de groupe de transactions. <br><br>  Ensuite, les verrous peuvent être implémentés comme un HashMap banal dans la mémoire du coordinateur. <br><br><h2>  Échecs du coordinateur </h2><br>  Étant donné qu'un coordinateur dessert exclusivement un groupe de transactions, il est très important de déterminer rapidement le fait de son échec, afin qu'une tentative répétée d'exécuter la transaction soit expirée.  Pour le rendre rapide et fiable, nous avons appliqué un protocole de rythme cardiaque de quorum entièrement connecté: <br><br>  Chaque centre de données possède au moins deux nœuds coordinateurs.  Périodiquement, chaque coordinateur envoie un message de pulsation aux autres coordinateurs et les informe de leur fonctionnement, ainsi que les messages de pulsation à partir desquels les coordinateurs du cluster pour la dernière fois. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cde/1e4/ccd/cde1e4ccd6d23620eda08adc231aeec7.jpg"><br><br>  Après avoir reçu des informations similaires des autres dans la composition de leurs messages de pulsation, chaque coordinateur décide lui-même quels nœuds de cluster fonctionnent et lesquels ne sont pas guidés par le principe du quorum: si le nœud X a reçu des informations de la majorité des nœuds du cluster sur la réception normale des messages du nœud Y, alors , Y fonctionne.  Inversement, dès que la majorité signale la perte de messages du nœud Y, alors Y a échoué.  Il est curieux que si un quorum indique au nœud X qu'il n'en reçoit pas plus de messages, le nœud X lui-même se considérera comme ayant échoué. <br><br>  Les messages de pulsation sont envoyés à une fréquence élevée, environ 20 fois par seconde, avec une période de 50 ms.  En Java, il est difficile de garantir une réponse d'application de 50 ms en raison de la durée comparable des pauses provoquées par le garbage collector.  Nous avons pu atteindre un tel temps de réponse en utilisant le garbage collector G1, ce qui nous permet de spécifier la cible pour la durée des pauses du GC.  Cependant, parfois, assez rarement, la pause du collecteur dépasse 50 ms, ce qui peut conduire à une fausse détection d'échec.  Pour éviter cela, le coordinateur ne signale pas l'échec du nœud distant lorsque le premier message de pulsation en disparaît, seulement si plusieurs disparaissent consécutivement. Nous avons donc réussi à détecter l'échec du nœud du coordinateur en 200 ms. <br><br>  Mais il ne suffit pas de comprendre rapidement quel nœud a cessé de fonctionner.  Vous devez y faire quelque chose. <br><br><h2>  Réservation </h2><br>  Le schéma classique suppose qu'en cas de refus d'un maître de lancer une nouvelle élection en utilisant l'un des algorithmes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">universels</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">à</a> la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mode</a> .  Cependant, ces algorithmes ont des problèmes bien connus avec la convergence temporelle et la durée du processus électoral lui-même.  Nous avons réussi à éviter de tels retards supplémentaires en utilisant le circuit équivalent de coordinateurs dans un réseau entièrement connecté: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e90/45e/007/e9045e00777362a5846eb78ef15bedea.png"><br><br>  Supposons que nous voulons exécuter une transaction dans le groupe 50. Nous déterminerons à l'avance un schéma de substitution, c'est-à-dire quels nœuds exécuteront les transactions du groupe 50 en cas de défaillance du coordinateur principal.  Notre objectif est de maintenir le système opérationnel en cas de panne du centre de données.  Nous déterminons que la première réserve sera un nœud d'un autre centre de données, et la deuxième réserve sera un nœud du troisième.  Ce schéma est sélectionné une fois et ne change pas tant que la topologie du cluster ne change pas, c'est-à-dire jusqu'à ce que de nouveaux nœuds y entrent (ce qui arrive très rarement).  La procédure pour choisir un nouveau maître actif en cas de défaillance de l'ancien sera toujours la suivante: la première réserve deviendra le maître actif, et si elle a cessé de fonctionner, la deuxième réserve deviendra. <br><br>  Un tel schéma est plus fiable que l'algorithme universel, car pour activer un nouveau maître, il suffit de déterminer le fait de l'échec de l'ancien. <br><br>  Mais comment les clients comprendront-ils lequel des maîtres travaille actuellement?  Pendant 50 ms, il n'est pas possible d'envoyer des informations à des milliers de clients.  Une situation est possible lorsqu'un client envoie une demande d'ouverture de transaction, ne sachant pas encore que cet assistant ne fonctionne plus et que la demande se bloque sur un délai d'attente.  Pour éviter que cela ne se produise, les clients envoient de manière spéculative une demande d'ouverture immédiate d'une transaction au maître de groupe et à ses deux réserves, mais seul celui qui est actuellement le maître actif répondra à cette demande.  Le client effectuera toutes les communications ultérieures au sein de la transaction uniquement avec le maître actif. <br><br>  Les maîtres de sauvegarde reçoivent des demandes de transactions non propres dans la file d'attente des transactions à naître, où elles sont stockées pendant un certain temps.  Si le maître actif décède, le nouveau maître traite les demandes d'ouverture de transactions de sa file d'attente et répond au client.  Si le client a déjà réussi à ouvrir une transaction avec l'ancien maître, alors la deuxième réponse est ignorée (et, évidemment, une telle transaction ne sera pas terminée et sera répétée par le client). <br><br><h2>  Fonctionnement d'une transaction </h2><br>  Supposons qu'un client envoie au coordinateur une demande d'ouverture d'une transaction pour une telle entité avec une telle clé primaire.  Le coordinateur verrouille cette entité et la place dans la table des verrous en mémoire.  Si nécessaire, le coordinateur lit cette entité dans la mémoire et stocke les données reçues dans un état de transaction dans la mémoire du coordinateur. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4d1/dfb/dcd/4d1dfbdcd92e4b05ca49ef5168177eb8.png"><br><br>  Lorsque le client souhaite modifier les données de la transaction, il envoie au coordinateur une demande de mise à jour de l'entité, et il place les nouvelles données dans la table d'état de la transaction en mémoire.  Ceci termine l'enregistrement - l'enregistrement n'est pas effectué dans le référentiel. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/00e/803/570/00e803570a0fbe19cb76786cbc6f0142.png"><br><br>  Lorsqu'un client demande, dans le cadre d'une transaction active, ses propres données modifiées, le coordinateur agit ainsi: <br><br><ul><li>  si l'ID est déjà dans la transaction, les données sont extraites de la mémoire; </li><li>  s'il n'y a pas d'ID dans la mémoire, les données manquantes sont lues à partir des nœuds de stockage, combinées avec celles déjà en mémoire, et le résultat est renvoyé au client. </li></ul><br>  Ainsi, le client peut lire ses propres modifications, tandis que d'autres clients ne voient pas ces modifications, car elles ne sont stockées que dans la mémoire du coordinateur, elles ne sont pas encore dans les nœuds Cassandra. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d8e/140/5f7/d8e1405f7995228ec3d061af59f1f685.png"><br><br>  Lorsque le client envoie une validation, l'état dans la mémoire du service est enregistré par le coordinateur dans le lot enregistré, et déjà sous la forme d'un lot enregistré, il est envoyé aux référentiels Cassandra.  Les référentiels font tout ce qui est nécessaire pour que ce package soit appliqué (entièrement) atomiquement et retournent une réponse au coordinateur, qui libère les verrous et confirme le succès de la transaction au client. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/090/739/9fc/0907399fc025879f16174ff26163a937.png"><br><br>  Et pour revenir au coordinateur, il suffit de libérer la mémoire occupée par l'état de la transaction. <br><br>  À la suite des améliorations ci-dessus, nous avons mis en œuvre les principes de l'ACID: <br><br><ul><li>  <b>Atomicité</b> .  Ceci est une garantie qu'aucune transaction ne sera partiellement engagée dans le système, toutes ses sous-opérations seront terminées, ou pas une seule ne sera exécutée.  Nous respectons ce principe en raison du lot enregistré à Cassandra. </li><li>  <b>Cohérence</b> .  Chaque transaction réussie, par définition, ne capture que des résultats acceptables.  Si, après l'ouverture d'une transaction et l'exécution d'une partie des opérations, il s'avère que le résultat n'est pas valide, une restauration est effectuée. </li><li>  <b>Isolement</b> .  Lorsqu'une transaction est exécutée, les transactions parallèles ne doivent pas affecter son résultat.  Les transactions concurrentes sont isolées à l'aide de verrous pessimistes sur le coordinateur.  Pour les lectures en dehors de la transaction, le principe d'isolement au niveau Read Committed est respecté. </li><li>  <b>Durabilité</b> .  Indépendamment des problèmes aux niveaux inférieurs - mise hors tension du système, défaillance matérielle, - les modifications apportées par une transaction réussie doivent rester enregistrées après la reprise de l'opération. </li></ul><br><h2>  Lecture d'index </h2><br>  Prenez un tableau simple: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> photos ( id <span class="hljs-type"><span class="hljs-type">bigint</span></span> <span class="hljs-keyword"><span class="hljs-keyword">primary key</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">owner</span></span> <span class="hljs-type"><span class="hljs-type">bigint</span></span>, modified <span class="hljs-type"><span class="hljs-type">timestamp</span></span>, …)</code> </pre> <br>  Elle a un identifiant (clé primaire), un propriétaire et une date de changement.  Vous devez faire une demande très simple - sélectionnez les informations du propriétaire avec la date de changement "pour le dernier jour". <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> owner=? <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> modified&gt;?</code> </pre> <br>  Pour qu'une telle requête fonctionne rapidement, dans le SGBD SQL classique, vous devez créer un index par colonnes (propriétaire, modifié).  Nous pouvons le faire tout simplement, puisque nous avons maintenant des garanties ACID! <br><br><h2>  Indices en C * One </h2><br>  Il existe une table source avec des photos, dans laquelle l'ID d'enregistrement est la clé primaire. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/039/5b3/a78/0395b3a784329992b88ba0618a94a7f1.jpg"><br><br>  Pour l'index C *, One crée une nouvelle table, qui est une copie de l'original.  La clé correspond à l'expression d'index et comprend également la clé primaire de l'enregistrement de la table source: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/92a/8c2/93e/92a8c293e8c145dc37f49a5126e68095.jpg"><br><br>  Maintenant, la demande pour le "propriétaire du dernier jour" peut être réécrite en sélectionnant dans une autre table: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> i1_test <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> owner=? <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> modified&gt;?</code> </pre> <br>  La cohérence des données de la table de photos d'origine et de l'index i1 est maintenue automatiquement par le coordinateur.  Sur la base du schéma de données seul, lorsque le changement est reçu, le coordinateur génère et se souvient du changement non seulement dans le tableau principal, mais également dans les copies.  Aucune action supplémentaire n'est effectuée avec la table d'index, les journaux ne sont pas lus, les verrous ne sont pas utilisés.  En d'autres termes, l'ajout d'index ne consomme presque pas de ressources et n'affecte pratiquement pas la vitesse d'application des modifications. <br><br>  En utilisant ACID, nous avons pu implémenter des index «comme en SQL».  Ils ont une cohérence, peuvent être mis à l'échelle, fonctionnent rapidement, peuvent être composites et intégrés dans le langage de requête CQL.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour prendre en charge les index, vous n'avez pas besoin de modifier le code d'application. </font><font style="vertical-align: inherit;">Tout est simple, comme en SQL. </font><font style="vertical-align: inherit;">Et surtout, les index n'affectent pas la vitesse d'exécution des modifications apportées à la table de transactions d'origine.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Qu'est-il arrivé? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons développé C * One il y a trois ans et l'avons mis en service commercial. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'avons-nous finalement obtenu? Évaluons cela en utilisant l'exemple d'un sous-système de traitement et de stockage de photos, l'un des types de données les plus importants d'un réseau social. Il ne s'agit pas du corps des photos elles-mêmes, mais de toutes sortes de méta-informations. Or, à Odnoklassniki, il existe environ 20 milliards de ces enregistrements, le système traite 80 000 demandes de lecture par seconde, jusqu'à 8 000 transactions ACID par seconde associées à la modification des données. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque nous avons utilisé SQL avec un facteur de réplication = 1 (mais en RAID 10), les méta-informations photo ont été stockées sur un cluster hautement accessible de 32 machines avec Microsoft SQL Server (plus 11 de sauvegarde). Il a également alloué 10 serveurs pour le stockage des sauvegardes. Un total de 50 voitures chères. Dans le même temps, le système fonctionnait à charge nominale, sans réserve.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après la migration vers le nouveau système, nous avons obtenu un facteur de réplication = 3 - une copie dans chaque centre de données. Le système comprend 63 nœuds de stockage Cassandra et 6 machines coordinatrices, totalisant 69 serveurs. Mais ces machines sont beaucoup moins chères, leur coût total est d'environ 30% du coût du système en SQL. Dans ce cas, la charge est maintenue à 30%. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avec l'introduction de C * One, les retards ont également diminué: en SQL, l'opération d'écriture prenait environ 4,5 ms. En C * One - environ 1,6 ms. La durée de la transaction est en moyenne inférieure à 40 ms, la validation est effectuée en 2 ms, la durée de lecture et d'écriture est en moyenne de 2 ms. Le 99e centile - seulement 3-3,1 ms, le nombre de délais d'attente a diminué de 100 fois - tout cela en raison de l'utilisation généralisée de la spéculation.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À ce jour, la plupart des nœuds SQL Server ont été mis hors service; les nouveaux produits sont développés uniquement à l'aide de C * One. </font><font style="vertical-align: inherit;">Nous avons adapté C * One pour travailler dans notre </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cloud unique</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ce qui nous a permis d'accélérer le déploiement de nouveaux clusters, de simplifier la configuration et d'automatiser le fonctionnement. </font><font style="vertical-align: inherit;">Sans code source, ce serait beaucoup plus difficile et difficile à réaliser. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous travaillons sur le transfert de nos autres installations de stockage vers le cloud - mais c'est une histoire complètement différente.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr417593/">https://habr.com/ru/post/fr417593/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr417583/index.html">Tomorrow ICFP Contest 2018, cheers! (+ utile pour participer pour la première fois)</a></li>
<li><a href="../fr417585/index.html">Comment intégrer le comité de programme d'une conférence de classe et pourquoi en avez-vous besoin</a></li>
<li><a href="../fr417587/index.html">Médias: les cyberattaques à grande échelle ont accéléré la croissance de la capitalisation des entreprises du secteur de la sécurité de l'information</a></li>
<li><a href="../fr417589/index.html">Sept règles simples pour rendre Internet accessible à tous</a></li>
<li><a href="../fr417591/index.html">Comment "apprendre" l'anglais en un an par vous-même ou un article pour ceux qui ne s'entraînent pas avec l'anglais</a></li>
<li><a href="../fr417595/index.html">Antiquités: Palm OS, code efficace et photos dégoûtantes</a></li>
<li><a href="../fr417597/index.html">Stockage sécurisé avec DRBD9 et Proxmox (Partie 2: iSCSI + LVM)</a></li>
<li><a href="../fr417599/index.html">Recueil Fintech: les régulateurs financiers ont besoin de l'IA pour travailler dans des conditions modernes</a></li>
<li><a href="../fr417601/index.html">Choisissez un serveur. Que chercher? Liste de contrôle</a></li>
<li><a href="../fr417603/index.html">Annonce d'un mitap mobile: que faire lorsque l'application est devenue volumineuse?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>