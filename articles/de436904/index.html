<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•° üë©üèæ‚Äçü§ù‚Äçüë®üèø üôéüèª 32K-Schwellenwert f√ºr Daten im AVR-Mikrocontroller-ROM ‚ôèÔ∏è üëñ üì∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Was k√∂nnte schlimmer sein als Kr√ºcken? Nur unvollst√§ndig dokumentierte Kr√ºcken. 





 Hier ist ein Screenshot der neuesten offiziellen integrierten E...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>32K-Schwellenwert f√ºr Daten im AVR-Mikrocontroller-ROM</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436904/"><p>  Was k√∂nnte schlimmer sein als Kr√ºcken?  Nur unvollst√§ndig dokumentierte Kr√ºcken. </p><br><p><img src="https://habrastorage.org/webt/cg/o9/jm/cgo9jmcqnhx5xev3pyizgfemlw4.png" alt="Bild"></p><br><p>  Hier ist ein Screenshot der neuesten offiziellen integrierten Entwicklungsumgebung f√ºr 8-Bit-AVR-Mikrocontroller, Atmel Studio 7, der Programmiersprache C.  Wie Sie in der Spalte Wert sehen k√∂nnen, enth√§lt die Variable my_array die Nummer 0x8089.  Mit anderen Worten, das Array my_array befindet sich ab der Adresse 0x8089 im Speicher. </p><br><p>  Gleichzeitig gibt uns die Spalte Typ etwas andere Informationen: my_array ist ein Array von 4 Elementen vom Typ int16_t im ROM (dies wird im Gegensatz zu Daten f√ºr RAM durch das Wort prog angezeigt), beginnend mit der Adresse 0x18089.  H√∂r auf, aber immerhin 0x8089! = 0x18089.  Wie lautet die tats√§chliche Adresse des Arrays? </p><a name="habracut"></a><br><h2 id="yazyk-si-i-garvardskaya-arhitektura">  C-Sprache und Harvard-Architektur </h2><br><p>  8-Bit-AVR-Mikrocontroller, die fr√ºher von Atmel und jetzt von Microchip hergestellt wurden, sind insbesondere deshalb beliebt, weil sie die Grundlage von Arduino bilden, das auf der Harvard-Architektur basiert, dh Code und Daten befinden sich in verschiedenen Adressr√§umen.  Die offizielle Dokumentation enth√§lt Codebeispiele in zwei Sprachen: Assembler und C.  Zuvor bot der Hersteller eine kostenlose integrierte Entwicklungsumgebung an, die nur Assembler unterst√ºtzt.  Aber was ist mit denen, die in C oder sogar C ++ programmieren m√∂chten?  Es gab kostenpflichtige L√∂sungen, zum Beispiel IAR AVR und CodeVisionAVR.  Pers√∂nlich habe ich es nie benutzt, denn als ich 2008 mit der Programmierung von AVR begann, gab es bereits kostenloses WinAVR mit der M√∂glichkeit, es in AVR Studio 4 zu integrieren, und es ist einfach im aktuellen Atmel Studio 7 enthalten. </p><br><p>  Das WinAVR-Projekt basiert auf dem GNU GCC-Compiler, der f√ºr die von Neumann-Architektur entwickelt wurde und einen einzigen Adressraum f√ºr Code und Daten impliziert.  Bei der Anpassung von GCC an AVR wurde die folgende Kr√ºcke angewendet: Die Adressen 0 bis 0x007fffff werden f√ºr den Code (ROM, Flash) und 0x00800100 f√ºr 0x0080ffff f√ºr Daten (RAM, SRAM) zugewiesen.  Es gab alle m√∂glichen anderen Tricks, zum Beispiel Adressen von 0x00800000 bis 0x008000ff, die Register darstellten, auf die mit denselben Opcodes wie RAM zugegriffen werden kann.  Wenn Sie ein einfacher Programmierer wie ein Arduino-Anf√§nger und kein Hacker sind, der Assembler und C / C ++ in derselben Firmware mischt, m√ºssen Sie dies im Prinzip nicht wissen. </p><br><p>  Neben dem eigentlichen Compiler enth√§lt WinAVR verschiedene Bibliotheken (Teil der Standard-C-Bibliothek und AVR-spezifische Module) in Form des AVR Libc-Projekts.  Die neueste Version 2.0.0 wurde vor fast drei Jahren ver√∂ffentlicht. Die Dokumentation ist nicht nur auf der Website des Projekts selbst, sondern auch auf der Website des Herstellers des Mikrocontrollers verf√ºgbar.  Es gibt auch inoffizielle russische √úbersetzungen. </p><br><h2 id="dannye-v-adresnom-prostranstve-koda">  Daten im Adressraum des Codes </h2><br><p>  Manchmal m√ºssen Sie in einem Mikrocontroller nicht nur viele, sondern auch viele Daten speichern: so viele, dass sie einfach nicht in den Arbeitsspeicher passen.  Dar√ºber hinaus sind diese Daten unver√§nderlich, zum Zeitpunkt der Firmware bekannt.  Zum Beispiel ein Rasterbild, eine Melodie oder eine Art Tisch.  Gleichzeitig nimmt der Code oft nur einen kleinen Teil des verf√ºgbaren ROM ein.  Warum also nicht den verbleibenden Speicherplatz f√ºr Daten nutzen?  Einfach!  Die Dokumentation zu avr-libc 2.0.0 umfasst ein ganzes Kapitel mit 5 Daten im Programmbereich.  Wenn Sie den Teil √ºber die Zeilen weglassen, ist alles sehr einfach.  Betrachten Sie ein Beispiel.  F√ºr RAM schreiben wir wie folgt: </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> array2d[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">3</span></span>] = {...}; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> element = array2d[i][j];</code> </pre> <br><p>  Und f√ºr ROM wie dieses: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;avr/pgmspace.h&gt; const unsigned char array2d[2][3] PROGMEM = {...}; unsigned char element = pgm_read_byte(&amp;(array2d[i][j]));</span></span></span></span></code> </pre> <br><p>  Es ist so einfach, dass diese Technologie auch in RuNet wiederholt behandelt wurde. </p><br><h2 id="tak-v-chyom-zhe-problema">  Was ist das Problem? </h2><br><p>  Erinnern Sie sich an die Aussage, dass 640 KB f√ºr alle ausreichen?  Erinnern Sie sich, wie Sie von 16-Bit-Architektur auf 32-Bit und von 32-Bit auf 64-Bit umgestellt haben?  Wie hat Windows 98 auf mehr als 512 MB RAM instabil funktioniert, w√§hrend es f√ºr 2 GB ausgelegt war?  Haben Sie jemals das BIOS aktualisiert, sodass das Motherboard mit Festplatten mit mehr als 8 GB funktioniert?  Erinnern Sie sich an die Jumper auf 80 GB Festplatten, die ihre Lautst√§rke auf 32 GB reduzieren? </p><br><p>  Das erste Problem √ºberkam mich, als ich versuchte, ein Array von mindestens 32 KB im ROM zu erstellen.  Warum im ROM und nicht im RAM?  Denn derzeit existieren 8-Bit-AVRs mit mehr als 32 KB RAM einfach nicht.  Und mit mehr als 256 B - existieren.  Dies ist wahrscheinlich der Grund, warum die Ersteller des Compilers 16 b (2 B) f√ºr Zeiger im RAM (und gleichzeitig f√ºr den Int-Typ) ausgew√§hlt haben. Dies finden Sie im Abschnitt "Datentypen" in Kapitel 11.14. Welche Register werden vom C-Compiler verwendet?  AVR Libc-Dokumentation.  Oh, und wir wollten nicht hacken, aber hier sind die Register ... Aber zur√ºck zum Array.  Es stellte sich heraus, dass Sie kein Objekt erstellen k√∂nnen, das gr√∂√üer als 32.767 B (2 ^ (16 - 1) - 1 B) ist.  Ich wei√ü nicht, warum es notwendig war, die L√§nge des Objekts signifikant zu machen, aber das ist eine Tatsache: Kein Objekt, selbst ein mehrdimensionales Array, kann eine L√§nge von 32.768 B oder mehr haben.  Ein bisschen wie eine Einschr√§nkung des Adressraums von 32-Bit-Anwendungen (4 GB) in einem 64-Bit-Betriebssystem, nicht wahr? </p><br><p>  Soweit ich wei√ü, hat dieses Problem keine L√∂sung.  Wenn Sie ein Objekt mit einer L√§nge von 32.768 im ROM platzieren m√∂chten, teilen Sie es in kleinere Objekte auf. </p><br><p>  Wir wenden uns wieder dem Absatz Datentypen zu: Zeiger sind 16 Bit.  Wir wenden dieses Wissen auf Kapitel 5 von Daten im Programmraum an.  Nein, Theorie ist unverzichtbar, Praxis ist erforderlich.  Ich habe ein Testprogramm geschrieben, einen Debugger gestartet (leider Software, keine Hardware) und <code>pgm_read_byte</code> dass die Funktion <code>pgm_read_byte</code> nur Daten zur√ºckgeben kann, deren Adressen in 16 Bit passen (64 KB; danke, nicht 15).  Dann tritt ein √úberlauf auf, der √§ltere Teil wird verworfen.  Es ist logisch, wenn Zeiger 16-Bit sind.  Es stellen sich jedoch zwei Fragen: Warum ist dies nicht in Kapitel 5 geschrieben (eine rhetorische Frage, aber er hat mich dazu veranlasst, diesen Artikel zu schreiben) und wie man das 64-KB-ROM-Limit √ºberwindet, ohne zum Assembler zu wechseln. </p><br><p>  Gl√ºcklicherweise gibt es zus√§tzlich zu Kapitel 5 eine weitere 25.18 pgmspace.h-Dateireferenz, aus der wir erfahren, dass die Funktionsfamilie <code>pgm_read_*</code> nur eine <code>pgm_read_*_near</code> f√ºr <code>pgm_read_*_near</code> , die 16-Bit-Adressen akzeptiert, und es gibt auch <code>pgm_read_*_far</code> , und Sie k√∂nnen senden 32-Bit-Adresse  Eureka! </p><br><p>  Wir schreiben den Code: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> element = pgm_read_byte_far(&amp;(array2d[i][j]));</code> </pre> <br><p>  Es wird kompiliert, funktioniert aber nicht wie gew√ºnscht (wenn sich Array2d nach 32 KB befindet).  Warum?  Ja, da die <code>&amp;</code> -Operation eine vorzeichenbehaftete 16-Bit-Nummer zur√ºckgibt!  Es ist lustig, dass die <code>pgm_read_*_near</code> Familie vorzeichenlose 16-Bit-Adressen akzeptiert, <code>pgm_read_*_near</code> sie kann mit 64 KB Daten arbeiten, und die Operation <code>&amp;</code> ist nur f√ºr 32 KB n√ºtzlich. </p><br><p>  Lass uns weitermachen.  Was haben wir in pgmspace.h au√üer <code>pgm_read_*</code> ?  Die Funktion <code>pgm_get_far_address(var)</code> , die bereits eine halbe Seite Beschreibung enth√§lt und die Operation <code>&amp;</code> ersetzt. </p><br><p>  Wahrscheinlich richtig: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> element = pgm_read_byte_far(pgm_get_far_address(array2d[i][j]));</code> </pre> <br><p>  Kompilierungsfehler.  Wir lesen die Beschreibung: 'var' muss zum Zeitpunkt der Verkn√ºpfung als vorhandenes Symbol aufgel√∂st werden, dh als einfacher Typvariablenname, als Arrayname (kein indiziertes Element des Arrays, wenn der Index eine Konstante ist, beschwert sich der Compiler nicht, aber kann die Adresse nicht erhalten, wenn die Optimierung aktiviert ist), einen Strukturnamen oder einen Strukturfeldnamen, eine Funktionskennung, eine vom Linker definierte Kennung, ... </p><br><p>  Wir setzen eine weitere Kr√ºcke: Wir wechseln von Array-Indizes zur Zeigerarithmetik: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> element = pgm_read_byte_far(pgm_get_far_address(array2d) + i*<span class="hljs-number"><span class="hljs-number">3</span></span>*<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>) + j*<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>));</code> </pre> <br><p>  Jetzt funktioniert alles. </p><br><h2 id="vyvody">  Schlussfolgerungen </h2><br><p>  Wenn Sie mit dem GCC-Compiler in C / C ++ f√ºr 8-Bit-AVR-Mikrocontroller schreiben und die Daten im ROM speichern, dann: </p><br><ul><li>  Bei einer ROM-Gr√∂√üe von nicht mehr als 32 KB treten keine Probleme auf, wenn Sie nur Kapitel 5 Daten im Programmbereich lesen. </li><li>  F√ºr ROMs, die gr√∂√üer als 32 KB sind, sollten Sie die Funktionsfamilie <code>pgm_read_*_far</code> , die Funktion <code>pgm_get_far_address</code> anstelle von <code>&amp;</code> , die Zeigerarithmetik anstelle von Array-Indizes verwenden und die Gr√∂√üe eines Objekts darf 32.767 B nicht √ºberschreiten. </li></ul><br><h2 id="ssylki">  Referenzen </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Microchip</a> - AVR Microcontroller Maker und IDE Atmel Studio Developer </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AVR Libc Homepage</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AVR</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schulungskurs.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C-Programmierung.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arbeiten mit Speicher, Adressen und Zeigern</a> - DI HALT erw√§hnte im Prinzip keine gro√üen Adressen, sondern irgendwo tief in den Kommentaren, die sie √ºber <code>pgm_get_far_address</code> , aber das Beispiel war kaputt </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436904/">https://habr.com/ru/post/de436904/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436890/index.html">React Tutorial Teil 10: Workshop zum Arbeiten mit Komponenteneigenschaften und zum Styling</a></li>
<li><a href="../de436892/index.html">React Tutorial Teil 11: Dynamische Markup-Bildung und die Map-Array-Methode</a></li>
<li><a href="../de436894/index.html">Kriechende IT-Apokalypse. Neue Cloud-Dienste werden einige Ingenieure arbeitslos machen</a></li>
<li><a href="../de436896/index.html">Docker-Pretty-Ps - endlich ein lesbarer Docker-PS</a></li>
<li><a href="../de436900/index.html">FunTech ML-Treffen</a></li>
<li><a href="../de436908/index.html">6 M√∂glichkeiten, Daten in einer Android-Anwendung auszublenden</a></li>
<li><a href="../de436910/index.html">Tipps zum Erstellen benutzerdefinierter Workflows in GitLab CI</a></li>
<li><a href="../de436912/index.html">2019 CRM-Trends: Spa√ü beim Lesen, gef√§hrlich zu glauben</a></li>
<li><a href="../de436914/index.html">Probleme mit dem Startwachstum - √úberwachung</a></li>
<li><a href="../de436916/index.html">VShard - horizontale Skalierung in Tarantool</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>