<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÉüèº üë©üèΩ‚Äçüé§ üà∫ Wie wir PHP 7 doppelt so schnell wie PHP 5 gemacht haben. Teil 1: Optimierung von Datenstrukturen ‚ôèÔ∏è üí∏ ‚ôèÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im Dezember 2015 wurde PHP 7.0 ver√∂ffentlicht. Unternehmen, die auf die "Sieben" umgestiegen sind, haben festgestellt, dass die Produktivit√§t gestiege...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie wir PHP 7 doppelt so schnell wie PHP 5 gemacht haben. Teil 1: Optimierung von Datenstrukturen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/444508/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Im Dezember 2015</a> wurde PHP 7.0 ver√∂ffentlicht.  Unternehmen, die auf die "Sieben" umgestiegen sind, haben festgestellt, dass die Produktivit√§t gestiegen ist und die Belastung des Servers gesunken ist.  Die ersten, die zu den Sieben wechselten, waren Vebia und Etsy, und wir haben Badoo, Avito und OLX.  F√ºr Badoo kostete der Wechsel zu den sieben eine Million US-Dollar an Servereinsparungen.  Dank PHP 7 in OLX konnte die durchschnittliche Serverlast um das Dreifache gesenkt, die Effizienz gesteigert und Ressourcen gespart werden. <br><br>  <strong>Dmitry Stogov</strong> von Zend Technologies <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sprach</a> bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HighLoad ++</a> , was die Produktivit√§t steigerte.  Bei der Dekodierung: √ºber die interne Struktur von PHP, √ºber die Ideen im Herzen von Version 7.0, √ºber √Ñnderungen in den grundlegenden Datenstrukturen und Algorithmen, die den Erfolg bestimmten. <br><br>  <em>Haftungsausschluss: Ab M√§rz 2019</em> <em>laufen</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>80% der Websites</em></a> <em>mit PHP und</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>70% mit</em></a> <em>PHP 5, obwohl</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>diese Version</em></a> <em>seit dem 1. Januar 2019</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>nicht mehr unterst√ºtzt</em></a> <em>wird</em> <em>.</em>  <em>Der Bericht von Dmitry aus dem Jahr 2016 √ºber die Grunds√§tze, aufgrund derer die Produktivit√§t zwischen PHP 5 und 7 doppelt gestiegen ist, ist auch im M√§rz 2019 relevant. F√ºr die H√§lfte der Standorte sicher.</em> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/tHapNKpacSQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>  <strong>√úber den Sprecher: Dmitry Stogov</strong> begann bereits in den 80er Jahren mit der Programmierung: ‚ÄûElectronics B3-34‚Äú, Basic, Assembler.  Im Jahr 2002 lernte Dmitry PHP kennen und begann bald daran zu arbeiten, es zu verbessern: Er entwickelte Turck MMCache f√ºr PHP, leitete das PHPNG-Projekt und spielte eine wichtige Rolle bei der Arbeit an JIT f√ºr PHP.  Die letzten 14 Jahre als Principal Engineer bei Zend Technologies. <br><br>  Darauf aufbauend entwickelt Zend Technologies PHP und kommerzielle L√∂sungen.  1999 wurde es von den israelischen Programmierern Andy Gutmans und Zeev Suraski gegr√ºndet, die vor zwei Jahren PHP 3 entwickelten. Diese Personen standen an der Spitze der PHP-Entwicklung und bestimmten ma√ügeblich das aktuelle Erscheinungsbild der Sprache und den Erfolg der Technologie. <br><br>  Zend Technologies entwickelt den PHP-Kern und die Anwendungen daf√ºr. W√§hrend der Arbeit musste ich Erweiterungen schreiben, in alle Subsysteme einsteigen und sogar kommerzielle Projekte durchf√ºhren, die manchmal √ºberhaupt nicht mit PHP verbunden sind.  Das interessanteste Thema f√ºr mich war jedoch immer die <strong>Leistung</strong> . <br><br>  Ich suchte nach M√∂glichkeiten, PHP zu beschleunigen, noch bevor ich zu Zend kam, und arbeitete an meinem eigenen Projekt, das mit dem Unternehmen konkurrierte.  W√§hrend der Arbeit an dem Projekt habe ich die Sprache gr√ºndlich verstanden und festgestellt, dass Sie, wenn Sie nicht mit dem Mainstream-Projekt arbeiten, nur bestimmte Aspekte der Skriptausf√ºhrung beeinflussen k√∂nnen und die interessantesten und effektivsten <strong>nur im Kernel erstellt werden k√∂nnen</strong> .  Dieses Verst√§ndnis und Zufall f√ºhrte mich zu Zend. <br><br><h2>  Ein kleiner Exkurs in die Geschichte von PHP </h2><br>  PHP ist nicht nur und <strong>nicht nur eine Programmiersprache</strong> .  PHP steht f√ºr Personal Home Page - ein Tool zum Erstellen pers√∂nlicher Webseiten und dynamischer Websites.  Die Sprache ist nur einer ihrer Hauptteile.  PHP ist eine riesige Bibliothek von Funktionen, viele Erweiterungen f√ºr die Arbeit mit anderen Bibliotheken von Drittanbietern, zum Beispiel f√ºr den Zugriff auf die Datenbank oder XML-Parser, sowie eine Reihe von Modulen f√ºr die Kommunikation mit verschiedenen Webservern. <br><br>  Der d√§nische Programmierer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rasmus Lerdorf</a> f√ºhrte PHP <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Juni 1995 ein</a> .  Zu dieser Zeit war es nur eine <strong>Sammlung von CGI-Skripten, die in Perl geschrieben wurden</strong> .  Im April 96 f√ºhrte Rasmus PHP / FI ein und im Juni wurde PHP / FI 2.0 ver√∂ffentlicht.  Anschlie√üend wurde diese Version von Andy Gutmans und Zeev Surasky grundlegend √ºberarbeitet und im 98. PHP 3.0 ver√∂ffentlicht.  Bis zum Jahr 2000 kam die Sprache zu der Art, wie wir sie heute sowohl in Bezug auf die Sprache als auch auf die interne Architektur gewohnt sind - PHP 4, basierend auf der Zend Engine. <br><br>  Seit Version 4 hat sich PHP weiterentwickelt.  Der Wendepunkt war die Ver√∂ffentlichung von PHP 5 im Jahr 2004, als das <strong>Objektmodell vollst√§ndig aktualisiert wurde</strong> .  Sie hat die √Ñra der PHP-Frameworks er√∂ffnet und die Frage nach der Leistung auf ein neues Niveau gebracht.  Unmittelbar nach der Ver√∂ffentlichung von 5.0 haben wir bei Zend dar√ºber nachgedacht, PHP zu beschleunigen, und begonnen, an der Verbesserung der Produktivit√§t zu arbeiten. <br><br>  Die Version 7.1, die im November 2016 f√ºr synthetische Tests ver√∂ffentlicht wurde, <strong>ist 25-mal schneller als die Version 2002</strong> .  Gem√§√ü dem Diagramm der Leistungs√§nderungen in verschiedenen Zweigen sind die wichtigsten Durchbr√ºche in 5.1 und 7.0 sichtbar. <br><br><img src="https://habrastorage.org/webt/ao/_s/mp/ao_smpopukfzjmclxqqu83xefvo.png"><br><br>  In Version 5.1 haben wir gerade angefangen, an der Leistung zu arbeiten, und alles, was wir √ºbernommen haben - es stellte sich heraus, aber nach 5.3 stie√üen wir auf eine Wand, und alle Versuche, den Interpreter zu verbessern, scheiterten. <br><br>  Trotzdem fanden wir heraus, wo wir graben konnten, und bekamen sogar mehr als erwartet - 2,5-fache Beschleunigung im Vergleich zur vorherigen Version 5.6 bei Tests.  Das Interessanteste ist jedoch, dass wir bei unver√§nderten realen Anwendungen die gleiche 2,5-fache Beschleunigung erhalten haben.  Dies ist ein Ph√§nomen, da wir den vorherigen Faktor 2 w√§hrend der gesamten Lebensdauer der f√ºnf in 10 Jahren entwickelt haben. <br><br><img src="https://habrastorage.org/webt/ge/9j/n_/ge9jn_isn9hxm-gbrk0ahaexfms.png"><br><br>  Der enorme Sprung in 5.1 bei synthetischen Tests ist bei realen Anwendungen nicht sp√ºrbar.  Der Grund daf√ºr ist, dass bei unterschiedlichen Verwendungszwecken die PHP-Leistung auf den Bremsen beruht, die mit verschiedenen Subsystemen verbunden sind. <br><br>  <strong>Die Geschichte von PHP 7 beginnt mit einer dreij√§hrigen Stagnation</strong> , die 2012 begann und 2015 mit der Ver√∂ffentlichung der siebten Version endete.  Dann stellten wir fest, dass wir mit kleinen Verbesserungen unseres Dolmetschers die Produktivit√§t nicht mehr steigern konnten, und wandten uns der JIT-Seite zu. <br><br><h2>  JIT umherwandern </h2><br>  Fast zwei Jahre haben wir am JIT-Prototyp f√ºr PHP-5.5 gearbeitet.  Zuerst haben wir einen sehr einfachen Code generiert - eine Folge von Aufrufen f√ºr Standard-Handler, so etwas wie einen zusammengef√ºgten Fort-Code.  Dann schrieben sie ihren eigenen <strong>Runtime Assembler</strong> , einen separaten Inline-Code f√ºr Problemumgehungen, stellten jedoch fest, dass solche <strong>Optimierungen auf niedriger Ebene</strong> selbst bei Tests <strong>keine praktischen</strong> Auswirkungen hatten. <br><br>  Dann haben wir dar√ºber nachgedacht, Variablentypen mithilfe statischer Analysemethoden abzuleiten.  Nachdem wir die Schlussfolgerung gezogen hatten, erhielten wir <strong>in Tests</strong> sofort eine <strong>zweifache Beschleunigung.</strong>  Ermutigt versuchten sie, globale Registerzuordnungen zu schreiben, scheiterten jedoch.  Wir haben eine ziemlich hochrangige Darstellung verwendet, und es war fast unm√∂glich, sie f√ºr die Registerzuordnung zu verwenden. <br><br>  Um Probleme auf niedriger Ebene zu vermeiden, haben wir uns f√ºr LLVM entschieden und ein Jahr sp√§ter eine <strong>10-fache Beschleunigung f√ºr Bench.php erhalten</strong> , aber nichts f√ºr echte Anwendungen.  Dar√ºber hinaus dauerte das Kompilieren realer Anwendungen jetzt Minuten. Beispielsweise dauerte die erste <strong>Anforderung an Wordpress 2 Minuten und f√ºhrte zu keiner Beschleunigung.</strong>  Dies war nat√ºrlich f√ºr die Praxis v√∂llig ungeeignet. <br><br><blockquote>  Guter Code ist mit einer korrekten Typvorhersage m√∂glich, die in realen Anwendungen schlecht funktioniert, und die Verwendung von PHP-Datenstrukturen macht den generierten Code ineffizient. </blockquote><br><h3>  Was verlangsamt sich? </h3><br>  Wir haben die Gr√ºnde f√ºr die Fehler √ºberdacht und uns erneut entschlossen zu sehen, warum PHP langsam ist.  Das Bild zeigt das Ergebnis der Profilerstellung mehrerer Anforderungen an die Wordpress-Startseite. <br><br><img src="https://habrastorage.org/webt/3w/dh/7v/3wdh7vd40xumtwtyqgshsdan-a8.png"><br><br>  Weniger als 30% werden f√ºr die Interpretation von Bytecode ausgegeben, 20% sind der Overhead des Speichermanagers, 13% arbeiten mit Hash-Tabellen und 5% arbeiten mit regul√§ren Ausdr√ºcken. <br><br>  Bei JIT haben wir nur die ersten 30% losgeworden, und alles andere lag tot.  Fast √ºberall waren wir gezwungen, Standard-PHP-Datenstrukturen zu verwenden, was Overhead mit sich brachte: Speicherzuweisung, Referenzz√§hlung usw.  Dieses Verst√§ndnis f√ºhrte zu der Schlussfolgerung, dass wichtige Datenstrukturen in PHP ersetzt werden m√ºssen.  Mit dieser <strong>Ersetzung der Stiftung</strong> begann das <strong>PHPNG-</strong> Projekt <strong>.</strong> <br><br><h2>  Phpng  Neue Generation </h2><br>  Das Projekt wurde nach erfolglosen Versuchen entwickelt, JIT f√ºr PHP zu erstellen.  Hauptziel ist <strong>es, ein neues Produktivit√§tsniveau zu erreichen und den Grundstein f√ºr zuk√ºnftige Verbesserungen zu legen</strong> . <br><br>  Wir haben uns f√ºr einige Zeit versprochen, keine synthetischen Tests mehr zur Messung der Leistung zu verwenden. Dies sind normalerweise kleine Computerprogramme, die eine begrenzte Datenmenge verwenden, die vollst√§ndig in den Cache des Prozessors passt.  Im Gegensatz dazu unterliegen reale Anwendungen den mit dem Subsystemspeicher verbundenen Bremsen, und ein einzelnes Lesen aus dem Speicher kann 100 Rechenanweisungen kosten.  <strong>Das PHPNG-Projekt ist ein Refactoring der wichtigsten PHP-Datenstrukturen, um den Speicherzugriff zu optimieren</strong> .  Keine Innovation, 100% PHP 5-kompatibel. <br><br>  Wie man diese Strukturen √§ndert, war klar.  Das Volumen der abh√§ngigen √Ñnderungen war jedoch enorm, da der <strong>Kern von PHP</strong> selbst <strong>150.000 Zeilen umfasst</strong> und fast jedes Drittel ge√§ndert werden musste.  F√ºgen Sie hundert weitere Erweiterungen hinzu, die in der Basisverteilung enthalten sind, ein Dutzend Module f√ºr verschiedene Webserver, und Sie werden die Gr√∂√üe des Projekts erkennen. <br><br>  Wir waren uns nicht einmal sicher, ob wir das Projekt abschlie√üen w√ºrden.  Daher starteten sie das Projekt im Geheimen und er√∂ffneten es erst, als die ersten optimistischen Ergebnisse erschienen.  Es dauerte zwei Wochen, <strong>um den Kernel</strong> einfach zu <strong>kompilieren</strong> .  Zwei Wochen sp√§ter verdient Bench.php.  Wir haben anderthalb Monate damit verbracht, die Arbeit von Wordpress sicherzustellen.  Einen Monat sp√§ter haben wir das Projekt er√∂ffnet - es war Mai 2014.  Zu diesem Zeitpunkt hatten wir eine <strong>Beschleunigung von 30% auf Wordpress</strong> .  Es schien bereits ein gro√ües Ereignis zu sein. <br><br>  PHPNG erregte sofort eine Welle des Interesses und wurde im August 2014 <strong>als Grundlage f√ºr die Zukunft von PHP 7 angenommen</strong> .  Es war bereits ein weiteres Projekt mit anderen Zielen, bei dem die Produktivit√§t nur eines davon war. <br><br><h2>  PHP 7.0 </h2><br>  Die Versionsnummer 7 selbst war zweifelhaft.  Die vorherige Version war die f√ºnfte.  Die sechste wurde vor einigen Jahren entwickelt und war vollst√§ndig der nativen <strong>Unicode-</strong> Unterst√ºtzung gewidmet. Die erfolglosen Entscheidungen in den fr√ºhen Entwicklungsstadien f√ºhrten jedoch zu einer √ºberm√§√üigen Komplexit√§t des Kernel-Codes und jeder Erweiterung.  Am Ende wurde beschlossen, das Projekt einzufrieren. <br><br>  Zu diesem Zeitpunkt war bereits viel Material f√ºr PHP 6 angesammelt: Reden auf Konferenzen, ver√∂ffentlichte B√ºcher.  Um niemanden zu verwirren, haben wir das Projekt PHP 7 genannt und PHP 6 √ºbersprungen. Diese Version hatte viel mehr Gl√ºck - PHP 7 wurde im Dezember 2015 fast planm√§√üig ver√∂ffentlicht. <br><br>  Neben der Leistung erschienen in PHP 7 einige lang ersehnte Innovationen: <br><br><ul><li>  M√∂glichkeit, skalare Parametertypen und R√ºckgabewerte zu definieren. </li><li>  Ausnahmen statt Fehler - jetzt k√∂nnen wir sie abfangen und verarbeiten. </li><li> <code>Zero-cost assert()</code> , anonyme Klassen, Reinigungsinkonsistenzen, neue Operatoren und Funktionen (&lt;=&gt;, ??) wurden angezeigt. </li></ul><br>  Innovation ist gut, aber zur√ºck zu den internen Ver√§nderungen.  Lassen Sie uns √ºber den Weg sprechen, den PHP 7 eingeschlagen hat und wohin uns dieser Weg f√ºhren kann. <br><br><h2>  zval </h2><br>  Dies ist die grundlegende PHP-Datenstruktur.  Es wird verwendet, <strong>um einen beliebigen Wert in PHP darzustellen</strong> .  Da unsere Sprache dynamisch typisiert wird und sich der Variablentyp w√§hrend der Programmausf√ºhrung √§ndern kann, m√ºssen wir ein Typfeld (Typ zend_uchar) speichern, das die Werte IS_NULL, IS_BOOL, IS_LONG, IS_DOUBLE, IS_ARRAY, IS_OBJECT usw. annehmen kann Der durch Union (Wert) dargestellte Wert, in dem eine Ganzzahl, eine reelle Zahl, eine Zeichenfolge, ein Array oder ein Objekt gespeichert werden kann. <br><br><h3>  zval in PHP 5 </h3><br>  Der Speicher f√ºr jede solche Struktur wurde separat in Heap zugewiesen.  Neben Typ und Wert wurde auch der Verweisz√§hler auf die Struktur darin gespeichert.  Die Struktur ben√∂tigte also 24 Bytes, ohne den Overhead des Speichermanagers und den Zeiger darauf. <br><br>  Das Bild oben rechts zeigt die Datenstrukturen, die im Speicher von PHP 5 f√ºr ein einfaches Skript erstellt wurden. <br><br><img src="https://habrastorage.org/webt/m8/km/ix/m8kmixgehjrhtxthe-gefmmi86i.png"><br><br>  Auf dem Stapel wurde Speicher f√ºr 4 Variablen zugewiesen, die durch Zeiger dargestellt werden.  Die Werte selbst (zval) befinden sich auf dem Heap.  In unserem Fall sind dies nur zwei zval, auf die jeweils von zwei Variablen verwiesen wird, und dementsprechend werden ihre Referenzz√§hler auf 2 gesetzt. <br><br>  Um auf einen Typ oder einen Skalarwert zuzugreifen, ben√∂tigen Sie mindestens zwei Messwerte: Lesen Sie zuerst den Wert des Zeigers und dann den Wert der Struktur.  Wenn Sie keinen skalaren Wert lesen m√ºssen, sondern beispielsweise einen Teil eines Strings oder Arrays, m√ºssen Sie mindestens einen weiteren Messwert lesen. <br><br><h3>  zval in PHP 7 </h3><br>  Wo wir vorher Zeiger verwendet haben, haben wir in den sieben begonnen, zval einzubetten.  Wir haben uns von der Referenzz√§hlung f√ºr Skalartypen entfernt.  Der Feldtyp und der Wert blieben ohne wesentliche √Ñnderungen, aber es wurden einige weitere Flags und ein reservierter Platz hinzugef√ºgt, √ºber die ich etwas sp√§ter sprechen werde. <br><br><img src="https://habrastorage.org/webt/tz/we/yn/tzweyn8n32_rntdwwjxhz-fbwc4.png"><br><br>  Links sieht es in PHP 5 aus und rechts in PHP 7. <br><br><img src="https://habrastorage.org/webt/5n/wl/4h/5nwl4hrqaqr2kb4pmenzvbtrnh4.png"><br><br>  Jetzt sind zval selbst auf dem Stapel.  Zum Lesen von Typen und Skalarwerten reicht nur eine Maschinenanweisung aus.  Alle Werte sind in einem Speicherbereich zusammengefasst. Dies bedeutet, dass wir bei der Arbeit mit lokalen Variablen praktisch keine Verluste aufgrund von Fehlern im Prozessor-Cache haben.  Die wahre Leistung der neuen Leistung ist jedoch enthalten, wenn ein Kopiervorgang erforderlich ist. <br><br><h3>  Datensatz kopieren </h3><br>  In der obersten Zeile des Skripts wurde eine weitere Zuordnung hinzugef√ºgt. <br><br><img src="https://habrastorage.org/webt/kb/yr/ww/kbyrwwvzaeuqpt8quf1lyujztjo.png"><br><br>  In PHP5 haben wir dem neuen zval Speicher aus dem Heap zugewiesen, sein int (2) initialisiert, den Wert des Zeigers auf die Variable b ge√§ndert und den Referenzz√§hler des Werts verringert, auf den sich b zuvor bezogen hatte. <br><br>  In PHP 7 haben wir <strong>die Variable b</strong> einfach <strong>mit ein paar Anweisungen direkt an Ort und Stelle initialisiert</strong> , w√§hrend in PHP 5 Hunderte von Anweisungen erforderlich waren.  Also schaut zval jetzt in Erinnerung. <br><br><img src="https://habrastorage.org/webt/ax/ab/sa/axabsadvso8c49azoqvvks5jsfc.png"><br><br>  Dies sind zwei 64-Bit-W√∂rter.  Das erste Wort <strong>bedeutet:</strong> Ganzzahl, Real oder Zeiger.  Im zweiten Wort der <strong>Typ</strong> (es gibt an, wie die Bedeutung zu interpretieren ist), Flags und ein reservierter Platz, der beim Ausrichten noch hinzugef√ºgt wird.  Es verschwindet jedoch nicht, sondern wird von verschiedenen Subsystemen zum Speichern indirekt verwandter Werte verwendet. <br><br>  <strong>Flags sind eine Reihe von Bits,</strong> wobei jedes Bit angibt, ob zval ein Protokoll unterst√ºtzt.  Wenn es sich beispielsweise um <code>IS_TYPE_REFCOUNTED</code> handelt, sollte die Engine bei der Arbeit mit diesem zval auf den Wert des Referenzz√§hlers achten.  Beim Zuweisen erh√∂hen, beim Verlassen des Bereichs verringern, wenn der Referenzz√§hler Null erreicht, die abh√§ngige Struktur zerst√∂ren. <br><br>  Von den Typen erschienen im Vergleich zu PHP 5 mehrere neue. <br><br><ul><li>  <code>IS_UNDEF</code> - ein Marker f√ºr eine nicht initialisierte Variable. </li><li>  Das einzelne <code>IS_BOOL</code> durch separate <code>IS_FALSE</code> und <code>IS_TRUE</code> . </li><li>  Ein separater Typ f√ºr Links und einige weitere magische Typen wurden hinzugef√ºgt. </li></ul><br>  Typen von <code>IS_UNDEF</code> bis <code>IS_DOUBLE</code> sind skalar und ben√∂tigen keinen zus√§tzlichen Speicher.  Um sie zu kopieren, reicht es aus, das 64-Bit-Wort des ersten Computers mit einem Wert und das halbe zweite mit einem Typ und Flags zu kopieren. <br><br><h3>  Nachgez√§hlt </h3><br>  Bei anderen Typen schwieriger.  Sie werden alle durch eine untergeordnete Struktur dargestellt, und zval speichert einfach einen Verweis auf diese Struktur.  F√ºr jeden Typ ist diese Struktur unterschiedlich, aber in Bezug auf OOP haben alle einen gemeinsamen abstrakten Vorfahren oder eine gemeinsame abstrakte Struktur zend_refcounted.  Es bestimmt das Format des ersten <strong>64-Bit-Wortes</strong> , in dem der Referenzz√§hler und andere Informationen f√ºr den Garbage Collector gespeichert sind. <br><br><img src="https://habrastorage.org/webt/vn/zm/yy/vnzmyywum831lpzipgxtenm_98s.png"><br><br>  Dieses Wort kann einfach als Information f√ºr den Garbage Collector betrachtet werden, und Strukturen f√ºr bestimmte Typen f√ºgen ihre Felder nach diesem ersten Wort hinzu. <br><br><h3>  Linien </h3><br>  In den sieben f√ºr die Zeichenfolge speichern wir den berechneten Wert der Hash-Funktion, ihre L√§nge und die Zeichen selbst.  Die Gr√∂√üe einer solchen Struktur ist variabel und h√§ngt von der L√§nge der Zeichenfolge ab.  Die Hash-Funktion wird bei Bedarf einmal f√ºr den String berechnet.  In PHP 5 wurde es bei jedem Bedarf neu berechnet. <br><br><img src="https://habrastorage.org/webt/em/2t/ax/em2tax1wdnckpbzqxjh1tlqn37o.png"><br><br>  Jetzt sind die Zeichenfolgen referenzz√§hlbar geworden. Wenn wir in PHP 5 die Zeichen selbst kopiert haben, reicht es jetzt aus, die Referenzanzahl f√ºr diese Struktur zu erh√∂hen. <br><br>  Wie in PHP 5 haben wir immer noch das Konzept <strong>unver√§nderlicher oder internierter Zeichenfolgen</strong> .  Sie existieren normalerweise in einer Instanz, leben bis zum Ende der Abfrage und k√∂nnen sich wie skalare Werte verhalten.  Wir m√ºssen uns nicht um den Z√§hler der Links zu ihnen k√ºmmern, und zum Kopieren reicht es aus, nur zval selbst mit vier Maschinenanweisungen zu kopieren. <br><br><h3>  Arrays </h3><br>  Arrays werden durch eine integrierte Hash-Tabelle dargestellt und unterscheiden sich nicht wesentlich von PHP 5. Die Hash-Tabelle selbst hat sich ge√§ndert, aber mehr dazu separat. <br><br><img src="https://habrastorage.org/webt/_u/kn/ls/_uknlsdbw247d7whq_-euez8zuw.png"><br><br>  Arrays sind jetzt eine <strong>adaptive Struktur</strong> , die ihre interne Struktur und ihr Verhalten in Abh√§ngigkeit von den gespeicherten Daten geringf√ºgig √§ndert.  Wenn wir nur Elemente mit engen numerischen Schl√ºsseln speichern, erhalten wir direkten Zugriff auf die Elemente per Index mit einer Geschwindigkeit, die mit der Geschwindigkeit von Arrays in C vergleichbar ist. Wenn Sie jedoch ein Array mit einem Zeichenfolgenschl√ºssel zum selben Array hinzuf√ºgen, wird es zu einem echten Hash mit Kollisionsaufl√∂sung. <br><br>  So sieht die Hash-Tabelle in PHP 5 aus. <br><br><img src="https://habrastorage.org/webt/d6/c-/6r/d6c-6rvue6zlsyyhnscfyjtnjj4.png"><br><br>  Dies ist eine klassische Implementierung einer Hash-Tabelle mit Kollisionsaufl√∂sung unter Verwendung linearer Listen (in der oberen rechten Ecke gezeigt).  Jeder Artikel wird durch einen Eimer dargestellt.  Alle Buckets sind durch doppelt verkn√ºpfte Listen verkn√ºpft, um Kollisionen aufzul√∂sen, und durch eine andere doppelt verkn√ºpfte Liste, um die Reihenfolge zu durchlaufen.  Die Werte f√ºr jedes zval werden separat zugeordnet - in Bucket speichern wir nur einen Link dazu.  Zeichenfolgenschl√ºssel k√∂nnen auch separat zugewiesen werden. <br><br>  Daher m√ºssen Sie f√ºr jede Hash-Tabelle viele kleine Speicherbl√∂cke zuweisen, und um sp√§ter etwas zu finden, m√ºssen Sie entlang der Zeiger laufen.  Jeder solche √úbergang kann zu einem Cahce-Miss und einer Verz√∂gerung von ~ 10-100 Prozessorzyklen f√ºhren. <br><br>  Dies ist, was in PHP 7 passiert ist. <br><br><img src="https://habrastorage.org/webt/g_/mk/ax/g_mkaxt7a0ua8shao-rzketmjag.png"><br><br>  Die logische Struktur blieb unver√§ndert, nur die physische √§nderte sich.  Unter einer Hash-Tabelle wird nun Speicher mit einer Operation zugewiesen. <br><br>  Im Bild befinden sich am unteren Rand des Basiszeigers Elemente und am oberen Rand ein Hash-Array, das von einer Hash-Funktion angesprochen wird.  Wenn wir bei flachen oder gepackten Arrays nur Elemente mit numerischen Indizes speichern, wird der obere Teil √ºberhaupt nicht zugewiesen, und wir adressieren den Bucket direkt anhand der Nummer. <br><br>  Um Elemente zu umgehen, sortieren wir sie nacheinander von oben nach unten oder von unten nach oben, was moderne Prozessoren fehlerfrei tun.  Die Werte sind in Buckets integriert, aber der reservierte Speicherplatz in ihnen wird nur zum Aufl√∂sen von Kollisionen verwendet.  Es speichert den Index eines anderen Buckets mit demselben Hash-Funktionswert oder dem Ende der Listenmarkierung. <br><br>  Der Speicher f√ºr die Zeichenfolgenwerte der Schl√ºssel wird separat zugewiesen, aber es ist immer noch der gleiche zend_string.  Beim Einf√ºgen in ein Array reicht es aus, den Referenzz√§hler der Zeichenfolge zu erh√∂hen, obwohl wir zuvor die Zeichen direkt kopieren mussten und bei der Suche jetzt nicht die Zeichen, sondern die Zeiger auf die Zeichenfolgen selbst vergleichen k√∂nnen. <br><br><h3>  Unver√§nderliche Arrays </h3><br>  Fr√ºher hatten wir unver√§nderliche Zeichenfolgen, jetzt sind auch unver√§nderliche Arrays erschienen.  Wie Zeichenfolgen verwenden sie nicht den Referenzz√§hler und werden erst am Ende der Anforderung zerst√∂rt.  Dies ist ein einfaches Skript, das ein Array mit einer Million Elementen erstellt. Jedes Element ist dasselbe Array mit einem einzelnen "Hallo" -Element. <br><br><img src="https://habrastorage.org/webt/uv/sm/lu/uvsmluqtfldezjnbbfdqvd83sr8.png"><br><br>  In PHP 5 wurde bei jeder Schleifeniteration ein neues leeres Array erstellt, "Hallo" wurde darauf geschrieben und all dies wurde dem resultierenden Array hinzugef√ºgt.  In PHP 7 <strong>erstellen</strong> wir in der Kompilierungsphase <strong>nur ein unver√§nderliches Array</strong> , das sich wie ein Skalar verh√§lt, und f√ºgen es dem resultierenden hinzu.  Im vorliegenden Beispiel k√∂nnen wir so den Speicherverbrauch um mehr als das Zehnfache und die Beschleunigung um das Zehnfache reduzieren. <br><br>  Konstante Anordnungen von Millionen von Elementen in realen Anwendungen werden nat√ºrlich nicht oft gefunden, aber kleine sind ziemlich h√§ufig.  Auf jedem von ihnen erhalten Sie einen kleinen, aber einen Gewinn. <br><br><h3>  Die Objekte </h3><br>  Links zu allen Objekten in PHP 5 befanden sich in einem separaten Repository, und in zval gab es nur ein Handle - eine eindeutige Objekt-ID. <br><br><img src="https://habrastorage.org/webt/in/lo/dq/inlodqhjne7lo12nslgcuqrckvy.png"><br><br>  Um zum Objekt zu gelangen, haben wir mindestens 3 Messungen durchgef√ºhrt.  Au√üerdem wurde der Speicher f√ºr den Wert jeder Eigenschaft des Objekts separat zugewiesen, und wir ben√∂tigten mindestens zwei weitere Lesungen, um es zu lesen. <br><br>  In PHP 7 konnten wir zur direkten Adressierung √ºbergehen. <br><br><img src="https://habrastorage.org/webt/zm/vp/vv/zmvpvvqlmybttr3zvze6gzglin4.png"><br><br>  Auf <code>zend_object</code> Adresse <code>zend_object</code> mit einer einzigen Maschinenanweisung <code>zend_object</code> .  Und Property ist integriert und um sie zu lesen, ben√∂tigen Sie nur eine zus√§tzliche Lesung.  Sie sind auch gruppiert, was <strong>die Datenlokalit√§t verbessert</strong> und modernen Prozessoren hilft, nicht zu stolpern. <br><br>  Neben der vordefinierten Eigenschaft wird hier auch ein Link zur Klasse dieses Objekts gespeichert, einige Handler - ein Analogon zu virtuellen Methodentabellen und eine Hash-Tabelle f√ºr Eigenschaften, die nicht definiert wurden.  In PHP k√∂nnen Sie jedem Objekt, das urspr√ºnglich nicht definiert wurde, eine Eigenschaft hinzuf√ºgen. Wenn mehrere Maschinenanweisungen ausreichen, um auf die vordefinierte Eigenschaft zuzugreifen, m√ºssen Sie f√ºr nicht vordefinierte Eigenschaften eine Hash-Tabelle verwenden, f√ºr die Dutzende von Maschinenanweisungen erforderlich sind.  Das ist nat√ºrlich viel teurer. <br><br><h3>  Referenz </h3><br>  Schlie√ülich mussten wir einen <strong>separaten Typ</strong> einf√ºhren, um PHP-Links darzustellen. <br><br><img src="https://habrastorage.org/webt/yk/jj/ng/ykjjngfnlq8sefuvmwzjfxwjz7g.png"><br><br>  Dies ist ein vollst√§ndig transparenter Typ.  Es ist f√ºr PHP-Skripte nicht sichtbar.  Skripte sehen ein anderes zval, das in die zend_reference-Struktur integriert ist.  Es versteht sich, dass wir uns von mindestens zwei Stellen auf eine solche Struktur beziehen und der Referenzz√§hler dieser Struktur immer gr√∂√üer als 1 ist. Sobald der Z√§hler auf 1 f√§llt, verwandelt sich die Verkn√ºpfung in einen regul√§ren Skalarwert.  Das in den Link eingebettete zval wird in das letzte zval kopiert, das darauf verweist, und die Struktur selbst wird gel√∂scht. <br><br>  Es scheint, dass das Arbeiten mit Referenzen jetzt viel komplizierter ist als mit anderen Typen (und das ist wahr), aber tats√§chlich mussten wir in PHP 5 Arbeiten von vergleichbarer Komplexit√§t ausf√ºhren, wenn wir auf einen Wert zugreifen (sogar eine Primzahl).  Jetzt wenden wir komplexere Protokolle nur auf einen Typ an und beschleunigen so die Arbeit mit allen anderen, insbesondere mit skalaren Werten. <br><br><h3>  IS_FALSE und IS_TRUE </h3><br>  Ich habe bereits gesagt, dass der einzelne Typ IS_BOOL in separate IS_FALSE und IS_TRUE aufgeteilt wurde.  Diese Idee wurde in der LuaJIT-Implementierung ausspioniert und wurde entwickelt, um eine der h√§ufigsten Operationen zu beschleunigen - den bedingten √úbergang. <br><br><img src="https://habrastorage.org/webt/fv/5j/-z/fv5j-zx0u_2kfmtmxjwce4uzetk.png"><br><br>  Wenn es in PHP 5 erforderlich war, den Typ zu lesen, nach Booleschen Werten zu suchen, den Wert zu lesen, herauszufinden, ob er wahr oder falsch ist, und darauf basierend einen √úbergang vorzunehmen, reicht es jetzt aus, den Typ einfach zu √ºberpr√ºfen und mit true zu vergleichen: <br><br><ul><li>  wenn es wahr ist, dann gehen wir entlang eines Zweigs; </li><li>  Wenn es weniger als wahr ist, gehen Sie zu einem anderen Zweig. </li><li>  Wenn es mehr als wahr ist, gehen Sie zum sogenannten langsamen Pfad (langsamer Pfad) und dort √ºberpr√ºfen wir, von welchem ‚Äã‚ÄãTyp es kam und was damit zu tun ist: Wenn es eine ganze Zahl ist, m√ºssen wir seinen Wert mit 0 vergleichen, wenn float - wieder mit 0 ( aber echt) usw. </li></ul><br><h2>  Aufruf Konvention </h2><br>  Eine √Ñnderung der Aufrufkonvention oder der Funktionsaufrufkonvention ist eine wichtige Optimierung, die nicht nur Datenstrukturen, sondern auch zugrunde liegende Algorithmen betrifft.  Im Bild links ist ein kleines Skript zu sehen, das aus der Funktion foo () und ihrem Aufruf besteht.  Unten finden Sie den Bytecode, in den dieses Skript von PHP 5 kompiliert wurde. <br><br><img src="https://habrastorage.org/webt/bn/fw/a4/bnfwa4e5ifjqs6rd6cp66uctega.png"><br><br>  Zuerst werde ich Ihnen sagen, wie es in PHP 5 funktioniert hat. <br><br><h3>  Calling Convention in PHP 5 </h3><br>  Die erste <code>SEND_VAL</code> Anweisung bestand darin, den Wert "3" an die foo-Funktion zu senden.  Zu diesem Zweck musste sie dem Heap ein neues zval zuweisen, den Wert (3) dort kopieren und den Wert des Zeigers auf diese Struktur auf den Stapel schreiben. <br><br><img src="https://habrastorage.org/webt/mt/vu/d3/mtvud3tb2ljaijnwecbmvnqepjs.png"><br><br>  √Ñhnliches gilt f√ºr die zweite Anweisung.  Weiter hat <code>DO_FCALL</code> <code>CALL FRAME</code> initialisiert, einen Platz f√ºr lokale und tempor√§re Variablen reserviert und die Steuerung an die aufgerufene Funktion √ºbertragen. <br><br><img src="https://habrastorage.org/webt/rx/rw/qo/rxrwqogtbhgd0q9tsd7wnw2r4og.png"><br><br>  Die erste <code>RECV</code> √ºberpr√ºfte das erste Argument und initialisierte den Slot auf dem Stapel mit der entsprechenden lokalen Variablen ($ a).  Hier haben wir auf das Kopieren verzichtet und einfach den Referenzz√§hler des entsprechenden Parameters (zval mit einem Wert von 3) erh√∂ht.  In √§hnlicher Weise stellte die zweite <code>RECV</code> eine Verbindung zwischen der Variablen $ b und Parameter 5 her. <br><br><img src="https://habrastorage.org/webt/lw/c1/zw/lwc1zw26uby_oj54yjzu7yz-vus.png"><br><br>  Weitere K√∂rperfunktionen.  3 + 5 Addition geschah - es stellte sich heraus 8. Dies ist eine tempor√§re Variable und ihr Wert wurde direkt auf dem Stapel gespeichert. <br><br><img src="https://habrastorage.org/webt/d0/xj/s5/d0xjs5j2c0i6qgioybezypay9k4.png"><br><br>  RETURN und wir kehren von der Funktion zur√ºck. <br><br><img src="https://habrastorage.org/webt/zd/cc/nb/zdccnbal1xuynwdcymbrwcf2fmq.png"><br><br>  Bei der R√ºckgabe geben wir alle Variablen und Argumente frei, die au√üerhalb des G√ºltigkeitsbereichs liegen.  Dazu gehen wir alle Zval durch, auf die durch Slots aus dem freigegebenen Frame verwiesen wird, und verringern f√ºr jeden den Referenzz√§hler.  Wenn es 0 erreicht, zerst√∂ren Sie die entsprechende Struktur. <br><br>  Wie Sie sehen k√∂nnen, erfordert selbst eine so einfache Operation wie das Senden einer Konstante an eine Funktion das Zuweisen von neuem Speicher, das Kopieren und Erh√∂hen des Referenzz√§hlers sowie das doppelte Verringern und L√∂schen. <br><br><h3>  Calling Convention in PHP 7 </h3><br>  In PHP 7 wurden diese Probleme behoben - jetzt speichern wir auf dem Stapel nicht die Zval-Zeiger, sondern die Zval-Zeiger selbst. <br><br><img src="https://habrastorage.org/webt/xc/ek/ls/xceklspoxwmga__zvpeat1a4plw.png"><br><br>  Wir haben auch eine neue Anweisung eingef√ºhrt, <code>INIT_FCALL</code> , die jetzt f√ºr die Initialisierung und Zuweisung von Speicher unter <code>CALL FRAME</code> ist und Platz f√ºr Argumente und tempor√§re Variablen reserviert. <br><br><img src="https://habrastorage.org/webt/yi/gd/a5/yigda5wg7xswdcyadip7euboboa.png"><br><br>  <code>SEND_VAL 3</code> kopiert das Argument jetzt nur noch in den ersten Slot nach dem <code>CALL FRAME</code> .  Weiter <code>SEND_VAL 5</code> zum zweiten Slot. <br><br><img src="https://habrastorage.org/webt/-0/es/8_/-0es8_skigjtyvja3vzzegwo-su.png"><br><br>  Dann das interessanteste.  Es scheint, dass <code>DO_FCALL</code> die Kontrolle an den ersten Befehl der aufgerufenen Funktion √ºbergeben sollte.  Aber die Argumente haben bereits die Slots getroffen, die f√ºr die variablen Parameter $ a und $ b reserviert sind, und die <code>RECV</code> Anweisungen tun einfach nichts.  Daher k√∂nnen Sie sie einfach √ºberspringen.  Wir haben zwei Parameter gesendet, also √ºberspringen wir zwei Anweisungen.  Wenn sie drei geschickt h√§tten, h√§tten sie drei verpasst. <br><br><img src="https://habrastorage.org/webt/4z/vm/gj/4zvmgjldpmtfpgprtvqoks__-km.png"><br><br>  Also gehen wir direkt zum Hauptteil der Funktion, machen Addition und kehren zur√ºck. <br><br><img src="https://habrastorage.org/webt/zh/j1/yf/zhj1yfwxp5kf1s4xxlyoasy170i.png"><br><br>  Bei der R√ºckkehr l√∂schen wir alle lokalen Variablen, aber jetzt nur f√ºr zwei Slots, und da wir dort Skalare haben, m√ºssen wir wieder nichts tun. <br><br><img src="https://habrastorage.org/webt/wy/dh/2p/wydh2pvz_hpawjivtoxx3hmxoqa.png"><br><br>  Meine Geschichte ist leicht vereinfacht, sie ber√ºcksichtigt keine Funktionen mit einer variablen Anzahl von Argumenten und die Notwendigkeit der Typpr√ºfung und einige andere Punkte. <br><br>  <strong>Die neue Calling Convention hat die Kompatibilit√§t etwas gebrochen</strong> .  PHP hat Funktionen wie <code>func_get_arg</code> und <code>func_get_args</code> .  Wenn sie fr√ºher den urspr√ºnglichen Wert des gesendeten Parameters zur√ºckgegeben haben, geben sie jetzt den aktuellen Wert der entsprechenden lokalen Variablen zur√ºck, da wir die urspr√ºnglichen Werte einfach nicht speichern.  Genau wie bei C. Debuggern <br><br><img src="https://habrastorage.org/webt/5r/n2/6j/5rn26j24gjyfolmeu07qgv1wmxu.png"><br><br>  Au√üerdem kann die Funktion nicht mehr mehrere Parameter mit demselben Namen haben.  Es hatte vorher keinen Sinn, aber ich traf solchen PHP-Code <code>foo($_, $_)</code> .  Wie sieht es aus?  (Ich erkannte Prolog) <br><br><h2>  Neuer Speichermanager </h2><br>  Nachdem wir die Optimierung der Datenstrukturen und der grundlegenden Algorithmen abgeschlossen hatten, machten wir erneut auf alle Bremssubsysteme aufmerksam.  Der Speichermanager in PHP 5 nahm in Wordpress <strong>fast 20% der Prozessorzeit</strong> in Anspruch. <br><br>  Nachdem wir viele Zuweisungen beseitigt hatten, wurden seine Gemeinkosten geringer, aber immer noch erheblich - und zwar nicht, weil er bedeutende Arbeit leistete, sondern weil er √ºber den Cache stolperte.  Dies lag an der Tatsache, dass wir den klassischen Malloc-Algorithmus von Doug Lea verwendeten, bei dem geeignete freie Speicherorte durch Reisen durch Links und B√§ume gefunden wurden, und all diese Fahrten zwangsl√§ufig zu Cache-Fehlern f√ºhrten. <br><br>  Heute gibt es neue Speicherverwaltungsalgorithmen, die die Merkmale moderner Prozessoren ber√ºcksichtigen.  Zum Beispiel: <strong>jemalloc</strong> und <strong>ptmalloc von Google</strong> .  Zuerst haben wir versucht, sie unver√§ndert zu verwenden, aber keinen Gewinn erzielt, da das Fehlen spezifischer PHP-Funktionen es am Ende der Anforderung teurer machte, Speicher vollst√§ndig freizugeben.  Infolgedessen haben wir dlmalloc aufgegeben und etwas Eigenes geschrieben, indem wir Ideen aus dem alten Speichermanager und jemalloc kombiniert haben. <br><br>  Wir haben <strong>den Overhead von Memory Manager auf 5%</strong> reduziert, den Speicher-Overhead f√ºr Serviceinformationen reduziert und die Verwendung des CPU-Cache verbessert.  Geeignete Speicherbl√∂cke werden jetzt durch Bitmaps durchsucht, Speicher f√ºr kleine Bl√∂cke wird von separaten Seiten zugewiesen und bei der Freigabe zwischengespeichert, spezielle Funktionen f√ºr h√§ufig verwendete Blockgr√∂√üen werden hinzugef√ºgt. <br><br><h2>  Viele kleine Verbesserungen </h2><br>  Ich habe nur √ºber die wichtigsten Verbesserungen gesprochen, aber es gab viel kleinere.  Ich kann einige davon erw√§hnen. <br><br><ul><li>  Schnelle API zum Parsen von Parametern interner Funktionen und eine neue API zum Iterieren √ºber HashTable. </li><li>  Neue VM-Anweisungen: Verkettung von Zeichenfolgen, Spezialisierung, Super-Anweisungen. </li><li>  Einige interne Funktionen wurden in VM-Anweisungen umgewandelt: strlen, is_int. </li><li>  Verwenden von CPU-Registern f√ºr VM-Register: IP und FP. </li><li>  Optimierung der Vervielf√§ltigung und L√∂schung von Arrays. </li><li>  Verwenden Sie die Anzahl der Links, anstatt zu kopieren, wo immer Sie k√∂nnen. </li><li>  PCRE JIT. </li><li>  Optimierung interner Funktionen und Serialisierung (). </li><li>  Reduzierte Codegr√∂√üe und verarbeitete Daten. </li></ul><br>  Einige waren sehr einfach, zum Beispiel waren nur drei Codezeilen erforderlich, um JIT in regul√§ren Perl-Ausdr√ºcken zu aktivieren, und dies brachte fast allen Anwendungen sofort eine sichtbare Beschleunigung (2-3%).  Andere Optimierungen haben einige enge Aspekte bestimmter PHP-Funktionen ber√ºhrt und sind nicht besonders interessant, obwohl der Gesamtbeitrag all dieser geringf√ºgigen Verbesserungen ziemlich bedeutend ist. <br><br><h2>  Zu was bist du gekommen? </h2><br>  Dies ist der Beitrag verschiedener Subsysteme unter WordPress / PHP 7.0. <br><br><img src="https://habrastorage.org/webt/7q/r4/d0/7qr4d08m8yhid4rngwh9-gffxbu.png"><br><br>  Der Beitrag der virtuellen Maschine stieg auf 50%. Memory Manager    5% ‚Äî         Memory Manager,        .         130 . ,    10 .  ,           Memory Manager           ,         . <br><br><img src="https://habrastorage.org/webt/kk/nq/5p/kknq5ppnd1ihr8wjw9xfv38boyy.png"><br>   : <br><br><ul><li>      2 . </li><li>   MM   17 . </li><li> -     4 . </li><li>    WordPress   3,5 . </li></ul><br>       2,5-  ,    .  ?   ,         ,        CPU time,   ‚Äî  ,    .  PHP     ,        . <br><br><h3>  PHP 7 </h3><br> WordPress 3.6      ‚Äî         .  - ,   PHP 7   mysql,     ,     . <br><br><img src="https://habrastorage.org/webt/bs/x9/pa/bsx9pa3fc3ccedmnajaj1h5dm0q.png"><br><br>   ,          PHPNG.     2/3 .     ,    . <br><br> ,       WordPress,      ,      ‚Äî  1,5  2- . <br><br><h3> PHP 7  HHVM </h3><br>              HHVM. <br><br><img src="https://habrastorage.org/webt/fs/vg/ot/fsvgotogozunvqed7dwflmmef1u.png"><br><br>      ‚Äî  .     .   Facebook   .   HHVM   . ,      ,     ,    ,      . <br><br><img src="https://habrastorage.org/webt/c_/pg/jv/c_pgjvoejr-q3o5sgvgtplxkbm0.png"><br><br>  PHP 7 ‚Äî    .    Vebia,  Etsy  Badoo. Highload-    ,       . <br><br>   PHP 7.0  Etsy  Badoo       -. Badoo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>    . <br><br><img src="https://habrastorage.org/webt/pn/rv/rj/pnrvrjrzp9re46lbmngnyddzu44.png"><br><br>  ,          2 ,    ‚Äî   7 . <br><br>         PHP 7.0.     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ,  PHP 7.1,        . <br><br><blockquote>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PHP Russia</a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>        <b>PHP 8</b> .         PHP,  ,    ,      ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>  1 .  , ,    ‚Äî   ,    ,     ,  . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444508/">https://habr.com/ru/post/de444508/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444494/index.html">La Moto Volante (Lazareth LMV 496) - fliegendes Transformatormotorrad</a></li>
<li><a href="../de444496/index.html">Neue Tools zum Erkennen des Abfangens von HTTPS</a></li>
<li><a href="../de444500/index.html">29. M√§rz, Moskau - Backend Stories 3.0</a></li>
<li><a href="../de444502/index.html">Ist die Quantenkryptographie wirklich zuverl√§ssig?</a></li>
<li><a href="../de444504/index.html">Verwenden Sie jetzt das lokale Paketverzeichnis in Python</a></li>
<li><a href="../de444512/index.html">Erstellen einer grafischen Anwendung zur L√∂sung des Pferdefortschritts</a></li>
<li><a href="../de444514/index.html">Webinar "Sicherheit beim maschinellen Lernen: Nat√ºrliche Probleme der k√ºnstlichen Intelligenz"</a></li>
<li><a href="../de444516/index.html">Wolfenstein 3D: Raytracing mit WebGL1</a></li>
<li><a href="../de444518/index.html">Auf dem Weg zu einer grundlegenden Theorie des Bewusstseins</a></li>
<li><a href="../de444520/index.html">2. Check Point Erste Schritte R80.20. L√∂sungsarchitektur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>