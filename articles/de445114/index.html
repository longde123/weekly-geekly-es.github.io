<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÜò üéûÔ∏è üìΩÔ∏è Verbessertes Sandboxing f√ºr groovige Skripte üë®üèº‚Äç‚öñÔ∏è üë®üèΩ‚Äç‚öïÔ∏è ‚õπüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Von einem √úbersetzer: Bei der Entwicklung der CUBA-Plattform haben wir in dieses Framework die M√∂glichkeit integriert, benutzerdefinierte Skripts f√ºr ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verbessertes Sandboxing f√ºr groovige Skripte</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/haulmont/blog/445114/"><p><img src="https://habrastorage.org/webt/l7/d9/cg/l7d9cgoh4tjgptdfr68phnooab4.jpeg"></p><br><p>  <em>Von einem √úbersetzer: Bei der Entwicklung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CUBA-Plattform haben</a> wir in dieses Framework die M√∂glichkeit integriert, benutzerdefinierte Skripts f√ºr eine flexiblere Konfiguration der Gesch√§ftslogik der Anwendung auszuf√ºhren.</em>  <em>Ob diese Gelegenheit gut oder schlecht ist (und wir sprechen nicht nur √ºber CUBA), wird lange diskutiert, aber die Tatsache, dass die Kontrolle √ºber die Ausf√ºhrung von Benutzerskripten notwendig ist, wirft keine Fragen auf.</em>  <em>Eine der n√ºtzlichen Funktionen von Groovy zum Verwalten der benutzerdefinierten Skriptausf√ºhrung wird in dieser √úbersetzung von C√©dric Champeau vorgestellt.</em>  <em>Trotz der Tatsache, dass er k√ºrzlich das Groovy-Entwicklungsteam verlassen hat, scheint die Community der Programmierer seine Arbeit noch lange zu nutzen.</em> </p><br><p>  Eine der am h√§ufigsten verwendeten Methoden zur Verwendung von Groovy ist die Skripterstellung, da Groovy die dynamische Ausf√ºhrung von Code zur Laufzeit vereinfacht.  Abh√§ngig von der Anwendung k√∂nnen sich die Skripte an verschiedenen Orten befinden: im Dateisystem, in der Datenbank, in den Remotediensten ... aber am wichtigsten ist, dass der Entwickler der Anwendung, die die Skripte ausf√ºhrt, sie nicht unbedingt schreibt.  Dar√ºber hinaus k√∂nnen Skripte in einer begrenzten Umgebung (begrenzter Speicher, Begrenzung der Anzahl der Dateideskriptoren, Laufzeit ...) ausgef√ºhrt werden, oder Sie m√∂chten den Benutzer m√∂glicherweise daran hindern, alle Sprachfunktionen des Skripts zu verwenden. </p><br><p>  <strong>Dieser Beitrag wird es Ihnen sagen.</strong> </p><br><ul><li>  warum groovy ist gut f√ºr das schreiben von internen dsl </li><li>  Was sind seine Funktionen in Bezug auf die Sicherheit Ihrer Anwendung </li><li>  Konfigurieren der Kompilierung zur Verbesserung von DSL </li><li> √ºber den Wert von <code>SecureASTCustomizer</code> </li><li>  √ºber Typsteuerungserweiterungen </li><li>  Verwendung von Typsteuerungserweiterungen, um Sandboxing effektiv zu machen </li></ul><a name="habracut"></a><br><p>  Stellen Sie sich beispielsweise vor, was Sie tun m√ºssen, damit der Benutzer mathematische Ausdr√ºcke berechnen kann.  Eine Implementierungsoption besteht darin, ein internes DSL einzubetten, einen Parser und schlie√ülich einen Interpreter f√ºr diese Ausdr√ºcke zu erstellen.  Dazu m√ºssen Sie nat√ºrlich arbeiten. Wenn Sie jedoch die Produktivit√§t steigern m√ºssen, indem Sie beispielsweise Bytecode f√ºr Ausdr√ºcke generieren, anstatt sie im Interpreter zu berechnen, oder das Zwischenspeichern von zur Laufzeit generierten Klassen verwenden, ist Groovy eine gro√üartige Option. </p><br><p>  In der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> werden viele Optionen beschrieben, aber das einfachste Beispiel ist die Verwendung der <code>Eval</code> Klasse: </p><br><p> <code>Example.java</code> </p> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum = (Integer) Eval.me(<span class="hljs-string"><span class="hljs-string">"1+1"</span></span>);</code> </pre> <br><p>  Der <code>1+1</code> Code wird analysiert, zu Bytecode kompiliert, von Groovy zur Laufzeit geladen und ausgef√ºhrt.  Nat√ºrlich ist der Code in diesem Beispiel sehr einfach und Sie m√ºssen Parameter hinzuf√ºgen, aber die Idee ist, dass der ausf√ºhrbare Code beliebig sein kann.  Und das ist m√∂glicherweise nicht genau das, was Sie brauchen.  Im Taschenrechner m√ºssen Sie Folgendes zulassen: </p><br><pre> <code class="plaintext hljs">1+1 x+y 1+(2*x)**y cos(alpha)*r v=1+x</code> </pre> <br><p>  aber schon gar nicht </p><br><pre> <code class="plaintext hljs">println 'Hello' (0..100).each { println 'Blah' } Pong p = new Pong() println(new File('/etc/passwd').text) System.exit(-1) Eval.me('System.exit(-1)') // a script within a script!</code> </pre> <br><p>  Hier beginnen Schwierigkeiten, und es wird auch klar, dass wir mehrere Probleme l√∂sen m√ºssen: </p><br><ul><li>  Beschr√§nken Sie die Grammatik einer Sprache auf eine Teilmenge ihrer F√§higkeiten </li><li>  verhindern, dass Benutzer den Code ausf√ºhren </li><li>  Verhindern Sie die Ausf√ºhrung von Schadcode </li></ul><br><p>  Das Taschenrechner-Beispiel ist recht einfach, aber bei komplexeren DSLs bemerken die Benutzer m√∂glicherweise nicht, dass sie problematischen Code schreiben, insbesondere wenn DSL so einfach ist, dass es von <em>Nicht-Entwicklern verwendet werden kann</em> . </p><br><p>  Vor ein paar Jahren war ich in dieser Situation.  Ich habe eine Engine entwickelt, die Groovy-Skripte ausf√ºhrt, die von Linguisten geschrieben wurden.  Ein Problem war zum Beispiel, dass sie versehentlich eine Endlosschleife erzeugen konnten.  Der Code wurde auf dem Server ausgef√ºhrt, und es wurde ein Thread angezeigt, der 100% der CPU verschlingt. Danach musste der Anwendungsserver neu gestartet werden.  Ich musste nach einer M√∂glichkeit suchen, das Problem zu l√∂sen, ohne die Leistung von DSL, Tools oder Anwendungen zu beeintr√§chtigen. </p><br><p>  In der Tat haben viele Menschen √§hnliche Bed√ºrfnisse.  In den letzten 4 Jahren habe ich mit vielen Leuten gesprochen, die die gleiche Frage hatten: <em>Wie kann ich verhindern, dass Benutzer in Groovy-Skripten Unsinn machen?</em> </p><br><h2 id="kastomayzery-kompilyacii">  Anpassungs-Compiler </h2><br><p>  Zu dieser Zeit hatte ich bereits meine eigene Entscheidung und ich wusste, dass auch andere Leute etwas √Ñhnliches entwickelten.  Am Ende schlug Guillaume Laforge vor, einen Mechanismus im Groovy-Kernel zu erstellen, um diese Probleme zu l√∂sen.  Es erschien in Groovy 1.8.0 als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Compilation-Customizer</a> . </p><br><p>  Kompilierungsanpassungsprogramme sind eine Reihe von Klassen, die den Kompilierungsprozess von Groovy-Skripten √§ndern.  Sie k√∂nnen Ihren eigenen Customizer schreiben, aber Groovy liefert: </p><br><ul><li>  Import-Customizer, der Skripten implizit Importe hinzuf√ºgt, sodass Benutzer keine Importbeschreibungen hinzuf√ºgen m√ºssen </li><li>  Customizer-AST-Transformationen (Abstract Syntax Tree), mit denen Sie AST-Transformationen direkt zu Skripten hinzuf√ºgen k√∂nnen </li><li>  Sicherer AST-Customizer, der Grammatik- und Syntaxkonstrukte einer Sprache einschr√§nkt </li></ul><br><p>  Der Customizer von AST-Transformationen hat mir geholfen, das Endlosschleifenproblem mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>@ThreadInterrupt</code></a> Transformation zu l√∂sen, aber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SecureASTCustomizer</a> wird in den allermeisten F√§llen wahrscheinlich am meisten missverstanden. </p><br><p>  Ich sollte mich daf√ºr entschuldigen.  Dann k√∂nnte ich mir keinen besseren Namen einfallen lassen.  Der wichtigste Teil im Namen ‚ÄûSecureASTCustomizer‚Äú ist der <strong>AST</strong> .  Der Zweck dieses Mechanismus bestand darin, den Zugriff auf bestimmte AST-Funktionen zu beschr√§nken.  Das Wort "sicher" im Titel ist im Allgemeinen √ºberfl√ºssig, und ich werde erkl√§ren, warum.  Es gibt sogar einen Blog-Beitrag von Jenkins ber√ºhmtem Kosuke Kawaguchi mit dem Titel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûFatal Groovy SecureASTCustomizer‚Äú</a> .  Und dort ist alles sehr richtig geschrieben.  SecureASTCustomizer wurde nicht f√ºr Sandboxing entwickelt.  Es wurde erstellt, um die Sprache beim Kompilieren einzuschr√§nken, jedoch nicht die Ausf√ºhrung.  Jetzt denke ich, der beste Name w√§re <em>GrammarCustomizer</em> .  Wie Sie sicherlich wissen, gibt es in der Informatik drei Schwierigkeiten: die Ung√ºltigmachung des Caches, das Erfinden von Namen und einen Fehler pro Einheit. </p><br><p>  Stellen Sie sich nun vor, Sie erw√§gen einen sicheren AST-Customizer, um die Sicherheit Ihres Skripts zu gew√§hrleisten, und Ihre Aufgabe besteht darin, zu verhindern, dass der Benutzer <code>System.exit</code> √ºber das Skript <code>System.exit</code> .  Die Dokumentation besagt, dass Anrufe in speziellen Empf√§ngern durch Erstellen von schwarzen oder wei√üen Listen gesperrt werden k√∂nnen.  Wenn Sicherheit ben√∂tigt wird, empfehle ich immer Whitelists, die genau angeben, was erlaubt ist, aber keine Blacklists, die irgendetwas verbieten.  Weil Hacker immer dar√ºber nachdenken, was Sie vielleicht nicht in Betracht gezogen haben.  Ich werde ein Beispiel geben. </p><br><p>  Hier <code>SecureASTCustomizer</code> , wie Sie mit <code>SecureASTCustomizer</code> eine primitive Sandbox-Skript-Engine <code>SecureASTCustomizer</code> .  Obwohl ich sie in Groovy schreiben k√∂nnte, gebe ich Java-Konfigurationsbeispiele, um den Unterschied zwischen Integrationscode und Skripten deutlicher zu machen. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sandbox</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ CompilerConfiguration conf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompilerConfiguration(); SecureASTCustomizer customizer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecureASTCustomizer(); customizer.setReceiversBlackList(Arrays.asList(System.class.getName())); conf.addCompilationCustomizers(customizer); GroovyShell shell = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GroovyShell(conf); Object v = shell.evaluate(<span class="hljs-string"><span class="hljs-string">"System.exit(-1)"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"Result = "</span></span> +v); } }</code> </pre> <br><ol><li>  Compilerkonfiguration erstellen </li><li>  Erstellen Sie einen sicheren AST-Customizer </li><li>  Deklarieren Sie, dass die <code>System</code> als Empf√§nger von Methodenaufrufen auf der schwarzen Liste steht </li><li>  F√ºgen Sie der Compilerkonfiguration einen Customizer hinzu </li><li>  Binden Sie die Konfiguration mit dem Shell-Skript, dh versuchen Sie, eine Sandbox zu erstellen </li><li>  F√ºhren Sie das "schlechte" Skript aus </li><li>  Zeigen Sie das Ergebnis der Ausf√ºhrung des Skripts an </li></ol><br><p>  Wenn Sie diese Klasse ausf√ºhren, tritt w√§hrend der Skriptausf√ºhrung ein Fehler auf: </p><br><pre> <code class="plaintext hljs">General error during canonicalization: Method calls not allowed on [java.lang.System] java.lang.SecurityException: Method calls not allowed on [java.lang.System]</code> </pre> <br><p>  Diese Schlussfolgerung wird von einer Anwendung mit einem sicheren AST-Customizer ausgegeben, der die Ausf√ºhrung von Methoden der Systemklasse nicht zul√§sst.  Erfolg!  Also haben wir unser Skript gesch√ºtzt!  Aber warte mal ... </p><br><h2 id="secureastcustomizer-vzloman">  SecureASTCustomizer wird gehackt! </h2><br><p>  Schutz, sagen wir?  Aber was ist, wenn ich das mache: </p><br><pre> <code class="java hljs">def c = System c.exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  Wenn Sie das Programm erneut ausf√ºhren, werden Sie feststellen, dass es <strong>ohne</strong> Fehler und <strong>ohne</strong> Anzeige des Ergebnisses auf dem Bildschirm abst√ºrzt.  Der Prozess-Exit-Code lautet -1, was bedeutet, dass das Benutzerskript ausgef√ºhrt wurde!  Was ist passiert?  Zum Zeitpunkt der Kompilierung kann der sichere AST-Customizer nicht erkennen, dass <code>c.exit</code> im Prinzip ein Aufruf der <code>System</code> , da er auf AST-Ebene funktioniert!  Es analysiert den Methodenaufruf und in diesem Fall lautet der Methodenaufruf <code>c.exit(-1)</code> . Anschlie√üend wird der Empf√§nger ermittelt und gepr√ºft, ob er in der wei√üen (oder schwarzen) Liste enthalten ist.  In diesem Fall ist der Empf√§nger <code>c</code> , diese Variable wird <strong>√ºber def deklariert</strong> , und dies entspricht der Deklaration als <code>Object</code> , und der sichere AST-Customizer glaubt, dass der Typ der Variablen <code>c</code> <code>Object</code> und nicht <code>System</code> ! </p><br><p>  Im Allgemeinen gibt es <strong>viele</strong> M√∂glichkeiten, um die verschiedenen Konfigurationen zu umgehen, die im sicheren AST-Customizer erstellt wurden.  Hier sind einige coole: </p><br><pre> <code class="java hljs">((Object)System).exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>) Class.forName(<span class="hljs-string"><span class="hljs-string">'java.lang.System'</span></span>).exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-string"><span class="hljs-string">'java.lang.System'</span></span> as Class).exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> java.lang.System.<span class="hljs-function"><span class="hljs-function">exit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre> <br><p>  und es kann noch <strong>viel</strong> mehr geben.  Die Dynamik von Groovy schlie√üt die M√∂glichkeit aus, diese Probleme beim Kompilieren zu beheben.  Es gibt jedoch eine L√∂sung.  Eine M√∂glichkeit besteht darin, sich auf den Standard-JVM-Sicherheitsmanager zu verlassen.  Dies ist jedoch sofort eine schwere und volumin√∂se L√∂sung f√ºr das gesamte System, und dies entspricht dem Abfeuern einer Kanone auf Spatzen.  Dar√ºber hinaus funktioniert es nicht in allen F√§llen, wenn Sie beispielsweise das Lesen von Dateien verbieten, aber nicht ... </p><br><p>  Diese Einschr√§nkung - f√ºr viele von uns eher ein √Ñrger - f√ºhrte zur Schaffung einer L√∂sung, die auf <strong>√úberpr√ºfungen zur Laufzeit</strong> basiert.  Diese Art der Pr√ºfung weist keine derartigen Probleme auf.  Zum Beispiel, weil Sie den tats√§chlichen Empf√§ngertyp der Nachricht kennen, bevor Sie mit der Validierung des Methodenaufrufs beginnen.  Von besonderem Interesse sind folgende Implementierungen: </p><br><ul><li>  <a href="">SecureScript</a> von Jim White </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Groovy Sandbox</a> von Kosuke Kawaguchi </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Groovy Sandbox</a> von Simon Temple </li></ul><br><p>  Keine dieser Implementierungen ist jedoch absolut zuverl√§ssig und sicher.  Zum Beispiel basiert die Version von Kosuke auf dem Hack der internen Implementierung der Caching-Call-Site.  Das Problem ist, dass es nicht mit der aufgerufenen dynamischen Version von Groovy kompatibel ist und diese inneren Klassen in zuk√ºnftigen Versionen von Groovy nicht mehr vorhanden sein werden.  Simons Version hingegen basiert auf AST-Transformationen, hinterl√§sst jedoch viele potenzielle L√ºcken. </p><br><p>  Infolgedessen haben meine Freunde Corinne Crisch, Fabrice Matrat und Sebastian Blanc und ich beschlossen, zur Laufzeit einen neuen Sandbox-Mechanismus zu erstellen, der keine Probleme wie diese Projekte haben wird.  Wir haben bei einem Hackathon in Nizza damit begonnen, und auf der Greach-Konferenz im letzten Jahr haben wir dar√ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">berichtet</a> .  Dieser Mechanismus basiert auf AST-Transformationen und schreibt den zu √ºberpr√ºfenden Code vor jedem Methodenaufruf im Wesentlichen neu, versucht, auf das Klassenfeld zuzugreifen, erh√∂ht eine Variable, einen bin√§ren Ausdruck ... Diese <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implementierung</a> ist noch nicht fertig und es wurde nicht viel daran gearbeitet als ich feststellte, dass das Problem mit Methoden und Parametern, die durch "implicit this" aufgerufen werden, noch nicht gel√∂st wurde, wie zum Beispiel bei Buildern: </p><br><pre> <code class="plaintext hljs">xml { cars { // cars is a method call on an implicit this: "this".cars(...) car(make:'Renault', model: 'Clio') } }</code> </pre> <br><p>  Bisher habe ich aufgrund der Architektur des Metaobjektprotokolls in Groovy, die auf der Tatsache basiert, dass der Empf√§nger eine Ausnahme ausl√∂st, wenn er die Methode nicht finden kann, noch keine M√∂glichkeit gefunden, dieses Problem zu l√∂sen, bevor er zu einem anderen Empf√§nger wechselt.  Kurz gesagt bedeutet dies, dass Sie den Empf√§ngertyp vor dem eigentlichen Methodenaufruf nicht herausfinden k√∂nnen.  Und wenn der Anruf bestanden hat, ist es zu sp√§t ... </p><br><p>  Und bis vor kurzem hatte ich keine optimale L√∂sung f√ºr dieses Problem f√ºr den Fall, dass das ausf√ºhrbare Skript die dynamischen Eigenschaften der Sprache verwendet.  Jetzt ist es an der Zeit zu erkl√§ren, wie Sie die Situation erheblich verbessern k√∂nnen, wenn Sie bereit sind, ein wenig von der Dynamik der Sprache zu opfern. </p><br><h2 id="proverka-tipov">  Typpr√ºfung </h2><br><p>  Kehren wir zum Hauptproblem mit SecureASTCustomizer zur√ºck: Es funktioniert mit einem abstrakten Syntaxbaum und enth√§lt keine Informationen zu bestimmten Nachrichtentypen und Empf√§ngern.  Mit Groovy 2 hat Groovy die Kompilierung hinzugef√ºgt, und in Groovy 2.1 haben wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erweiterungen f√ºr die Typpr√ºfung</a> hinzugef√ºgt. </p><br><p>  Erweiterungen f√ºr die Typpr√ºfung sind sehr leistungsf√§hig: Sie erm√∂glichen es dem Groovy DSL-Entwickler, dem Compiler bei der Typinferenz zu helfen, und erm√∂glichen auch die Generierung von Kompilierungsfehlern in F√§llen, in denen sie normalerweise nicht auftreten.  Diese Erweiterungen werden von Groovy intern verwendet, um einen statischen Compiler zu unterst√ºtzen, beispielsweise bei der Implementierung von Merkmalen oder einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Markup-Template-Engine</a> . </p><br><p>  Was w√§re, wenn wir uns anstelle der Ergebnisse des Parsers auf Informationen aus dem Typpr√ºfungsmechanismus verlassen k√∂nnten?  Nehmen Sie den Code, den unser Hacker zu schreiben versucht hat: </p><br><p> <code>((Object)System).exit(-1)</code> </p> <br><p>  Wenn Sie Typpr√ºfungen aktivieren, wird der Code nicht kompiliert: </p><br><pre> <code class="plaintext hljs">1 compilation error: [Static type checking] - Cannot find matching method java.lang.Object#exit(java.lang.Integer). Please check if the declared type is right and if the method exists.</code> </pre> <br><p>  Dieser Code wird also nicht mehr kompiliert.  Und was ist, wenn wir diesen Code nehmen: </p><br><pre> <code class="java hljs">def c = System c.exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  Wie Sie sehen k√∂nnen, besteht es die Typpr√ºfung, wird in eine Methode eingeschlossen und mit dem Befehl <code>groovy</code> ausgef√ºhrt: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@groovy</span></span>.transform.TypeChecked <span class="hljs-comment"><span class="hljs-comment">// or even @CompileStatic void foo() { def c = System c.exit(-1) } foo()</span></span></code> </pre> <br><p>  Die Typpr√ºfung erkennt, dass die <code>exit</code> Methode von der <code>System</code> Klasse aufgerufen wird und g√ºltig ist.  Dies wird uns hier nicht helfen.  Wir wissen jedoch, dass wenn dieser Code die Typpr√ºfung besteht, der Compiler den Anruf an den Empf√§nger mit dem Typ <code>System</code> erkennt.  Im Allgemeinen besteht die Idee darin, einen Anruf mit einer Nebenstelle zur Typpr√ºfung zu verbieten. </p><br><h2 id="prostoe-rasshirenie-dlya-proverki-tipov">  Einfache Erweiterung zur Typpr√ºfung </h2><br><p>  Bevor wir uns ausf√ºhrlich mit Sandboxing befassen, versuchen wir, unser Skript mit Hilfe einer Standarderweiterung f√ºr die Typpr√ºfung zu "sichern".  Das Registrieren einer solchen Erweiterung ist einfach: <code>@CompileStatic</code> Sie einfach den <code>extensions</code> f√ºr die Annotation <code>@TypeChecked</code> (oder <code>@CompileStatic</code> wenn Sie die statische Kompilierung verwenden): </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@TypeChecked</span></span>(extensions=[<span class="hljs-string"><span class="hljs-string">'SecureExtension1.groovy'</span></span>]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ def c = System c.exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>) } foo()</code> </pre> <br><p>  Die Erweiterungssuche findet im Klassenpfad im Quellcodeformat statt (Sie k√∂nnen vorkompilierte Erweiterungen f√ºr die Typpr√ºfung erstellen, diese werden in diesem Artikel jedoch nicht ber√ºcksichtigt): </p><br><p> <code>SecureExtension1.groovy</code> </p> <br><pre> <code class="java hljs">onMethodSelection { expr, methodNode -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (methodNode.declaringClass.name==<span class="hljs-string"><span class="hljs-string">'java.lang.System'</span></span>) { addStaticTypeError(<span class="hljs-string"><span class="hljs-string">"Method call is not allowed!"</span></span>, expr) } }</code> </pre> <br><ol><li>  Wenn die Typpr√ºfung eine aufzurufende Methode ausw√§hlt </li><li>  wenn die Methode zur Klasse <code>System</code> </li><li>  Lassen Sie dann die Typpr√ºfung einen Fehler generieren </li></ol><br><p>  Das ist alles was Sie brauchen.  F√ºhren Sie nun den Code erneut aus und Sie werden einen Kompilierungsfehler sehen! </p><br><pre> <code class="plaintext hljs">/home/cchampeau/tmp/securetest.groovy: 6: [Static type checking] - Method call is not allowed! @ line 6, column 3. c.exit(-1) ^ 1 error</code> </pre> <br><p>  Dieses Mal wird <code>c</code> dank der Typpr√ºfung als Instanz der Systemklasse erkannt, und wir k√∂nnen den Aufruf verbieten.  Dies ist ein sehr einfaches Beispiel, und es zeigt nicht alles, was mit dem sicheren AST-Customizer in Bezug auf die Konfiguration m√∂glich ist.  In der Erweiterung, die wir <strong>geschrieben haben</strong> , sind die Pr√ºfungen fest <strong>codiert</strong> , aber es ist m√∂glicherweise besser, sie anpassbar zu machen.  Lassen Sie uns das Beispiel komplizierter machen. </p><br><p>  Angenommen, Ihre Anwendung berechnet bestimmte Metriken f√ºr ein Dokument und erm√∂glicht es Benutzern, diese anzupassen.  In diesem Fall DSL: </p><br><ul><li>  wird (mindestens) die <code>score</code> Variable bedienen </li><li>  erm√∂glicht Benutzern das Ausf√ºhren mathematischer Operationen (einschlie√ülich des Aufrufs von <em>cos-</em> , <em>abs-</em> , ... -Methoden) </li><li>  muss alle anderen Methoden verbieten </li></ul><br><p>  Beispiel f√ºr ein Benutzerskript: </p><br><p> <code>abs(cos(1+score))</code> </p> <br><p>  Dieses DSL ist einfach zu konfigurieren.  Dies ist eine Variante dessen, was wir oben definiert haben: </p><br><p> <code>Sandbox.java</code> </p> <br><pre> <code class="java hljs">CompilerConfiguration conf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompilerConfiguration(); ImportCustomizer customizer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImportCustomizer(); customizer.addStaticStars(<span class="hljs-string"><span class="hljs-string">"java.lang.Math"</span></span>); conf.addCompilationCustomizers(customizer); Binding binding = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Binding(); binding.setVariable(<span class="hljs-string"><span class="hljs-string">"score"</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>d); GroovyShell shell = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GroovyShell(binding,conf); Double userScore = (Double) shell.evaluate(<span class="hljs-string"><span class="hljs-string">"abs(cos(1+score))"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"userScore = "</span></span> + userScore);</code> </pre> <br><ol><li>  F√ºgen Sie den Import-Customizer hinzu, der allen Skripten den <code>import static java.lang.Math.*</code> hinzuf√ºgt </li><li>  <code>score</code> Variable f√ºr Skript verf√ºgbar machen </li><li>  Skript ausf√ºhren </li></ol><br><p>  <em>Es gibt M√∂glichkeiten, Skripte zwischenzuspeichern, anstatt sie jedes Mal zu analysieren und zu kompilieren.</em>  <em>Einzelheiten finden Sie in der Dokumentation.</em> </p><br><p>  Unser Skript funktioniert also, aber nichts hindert den Hacker daran, sch√§dlichen Code zu starten.  Da wir die Typpr√ºfung verwenden m√∂chten, w√ºrde ich die Verwendung der <code>@CompileStatic</code> Transformation empfehlen: </p><br><ul><li>  Es aktiviert die Typpr√ºfung im Skript, und dank der Erweiterung f√ºr die Typpr√ºfung k√∂nnen wir zus√§tzliche Pr√ºfungen durchf√ºhren </li><li>  Verbessern Sie die Skriptleistung </li></ul><br><p>  Das implizite Hinzuf√ºgen der Annotation <code>@CompileStatic</code> zu Ihren Skripten ist ziemlich einfach.  Sie m√ºssen nur die Compilerkonfiguration aktualisieren: </p><br><pre> <code class="java hljs">ASTTransformationCustomizer astcz = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ASTTransformationCustomizer(CompileStatic.class); conf.addCompilationCustomizers(astcz);</code> </pre> <br><p>  Wenn Sie nun versuchen, das Skript erneut auszuf√ºhren, wird ein Kompilierungsfehler angezeigt: </p><br><pre> <code class="plaintext hljs">Script1.groovy: 1: [Static type checking] - The variable [score] is undeclared. @ line 1, column 11. abs(cos(1+score)) ^ Script1.groovy: 1: [Static type checking] - Cannot find matching method int#plus(java.lang.Object). Please check if the declared type is right and if the method exists. @ line 1, column 9. abs(cos(1+score)) ^ 2 errors</code> </pre> <br><p>  Was ist passiert?  Wenn Sie das Skript aus Sicht des Compilers lesen, wird klar, dass er nichts √ºber die Variable "score" wei√ü.  Als Entwickler wissen Sie jedoch, dass dies eine <code>double</code> ist, die der Compiler jedoch nicht ausgeben kann.  Dazu werden Erweiterungen f√ºr die Typpr√ºfung erstellt: Sie k√∂nnen dem Compiler zus√§tzliche Informationen geben, und die Kompilierung funktioniert einwandfrei.  In diesem Fall m√ºssen wir angeben, dass die <code>score</code> vom Typ <code>double</code> . </p><br><p>  Daher k√∂nnen Sie die Art und Weise, <code>@CompileStatic</code> Annotation <code>@CompileStatic</code> geringf√ºgig √§ndern: </p><br><pre> <code class="java hljs">ASTTransformationCustomizer astcz = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ASTTransformationCustomizer( singletonMap(<span class="hljs-string"><span class="hljs-string">"extensions"</span></span>, singletonList(<span class="hljs-string"><span class="hljs-string">"SecureExtension2.groovy"</span></span>)), CompileStatic.class);</code> </pre> <br><p>  Dies "emuliert" den von <code>@CompileStatic(extensions=['SecureExtension2.groovy'])</code> Anmerkungen versehenen <code>@CompileStatic(extensions=['SecureExtension2.groovy'])</code> .  Jetzt m√ºssen wir nat√ºrlich eine Erweiterung schreiben, die die <code>score</code> erkennt: </p><br><p> <code>SecureExtension2.groovy</code> </p> <br><pre> <code class="java hljs">unresolvedVariable { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.name==<span class="hljs-string"><span class="hljs-string">'score'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> makeDynamic(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, double_TYPE) } }</code> </pre> <br><ol><li>  falls die Typpr√ºfung die Variable nicht ermitteln kann </li><li>  wenn der Variablenname <code>score</code> </li><li>  Lassen Sie den Compiler die Variable dynamisch mit dem Typ <code>double</code> </li></ol><br><p>  Eine vollst√§ndige Beschreibung der DSL-Erweiterungen f√ºr die Typpr√ºfung finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in diesem Abschnitt der Dokumentation</a> . Es gibt jedoch ein Beispiel f√ºr einen kombinierten Kompilierungsmodus: Der Compiler kann keine <code>score</code> definieren.  Als DSL-Entwickler <strong>wissen Sie,</strong> dass die Variable tats√§chlich vom Typ <code>double</code> ist. Der Aufruf von <code>makeDynamic</code> daher: "Okay, keine Sorge, ich wei√ü, was ich tue. Diese Variable kann dynamisch mit dem Typ <code>double</code> definiert werden." ""  Das ist alles! </p><br><h2 id="pervoe-zavershennoe-secure-rasshirenie">  Erste abgeschlossene "sichere" Erweiterung </h2><br><p>  Lassen Sie uns jetzt alles zusammenf√ºgen.  Wir haben eine Typpr√ºfungserweiterung geschrieben, die einerseits das Aufrufen von Methoden der Systemklasse verhindert, und eine andere, die andererseits die <code>score</code> definiert.  Wenn wir sie verbinden, erhalten wir die erste vollst√§ndige Erweiterung f√ºr die Typpr√ºfung: </p><br><p> <code>SecureExtension3.groovy</code> </p> <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// disallow calls on System onMethodSelection { expr, methodNode -&gt; if (methodNode.declaringClass.name=='java.lang.System') { addStaticTypeError("Method call is not allowed!", expr) } } // resolve the score variable unresolvedVariable { var -&gt; if (var.name=='score') { return makeDynamic(var, double_TYPE) } }</span></span></code> </pre> <br><p>  Denken Sie daran, die Konfiguration in Ihrer Java-Klasse zu aktualisieren, um die neue Erweiterung f√ºr die Typpr√ºfung zu verwenden: </p><br><pre> <code class="java hljs">ASTTransformationCustomizer astcz = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ASTTransformationCustomizer( singletonMap(<span class="hljs-string"><span class="hljs-string">"extensions"</span></span>, singletonList(<span class="hljs-string"><span class="hljs-string">"SecureExtension3.groovy"</span></span>)), CompileStatic.class);</code> </pre> <br><p>  F√ºhren Sie den Code erneut aus - es funktioniert immer noch.  Versuchen Sie nun Folgendes: </p><br><pre> <code class="plaintext hljs">abs(cos(1+score)) System.exit(-1)</code> </pre> <br><p>  Die Kompilierung des Skripts st√ºrzt mit einem Fehler ab: </p><br><pre> <code class="plaintext hljs">Script1.groovy: 1: [Static type checking] - Method call is not allowed! @ line 1, column 19. abs(cos(1+score));System.exit(-1) ^ 1 error</code> </pre> <br><p>  Herzlichen Gl√ºckwunsch, Sie haben gerade die erste Erweiterung zur Typpr√ºfung geschrieben, die verhindert, dass b√∂sartiger Code ausgef√ºhrt wird! </p><br><h2 id="uluchshenie-konfiguracii-rasshireniya">  Erweiterte Erweiterungskonfiguration </h2><br><p>  Also l√§uft alles gut, wir k√∂nnen Aufrufe von Methoden der <code>System</code> verbieten, aber es scheint, dass bald neue Schwachstellen entdeckt werden und wir den Start von Schadcode verhindern m√ºssen.  Anstatt alles in der Erweiterung fest zu codieren, werden wir versuchen, unsere Erweiterung universell und anpassbar zu machen.  Dies ist wahrscheinlich die schwierigste, da es keine direkte M√∂glichkeit gibt, den Kontext zur Typpr√ºfung an die Erweiterung zu √ºbergeben.  Die Idee basiert daher auf der Verwendung einer lokalen Thread-Variablen (Kurvenmethode, ja), um Konfigurationsdaten an Typpr√ºfer zu √ºbergeben. </p><br><p>  Zun√§chst werden wir die Liste der Variablen anpassbar machen.  So sieht der Java-Code aus: </p><br><p> <code>Sandbox.java</code> </p> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sandbox</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String VAR_TYPES = <span class="hljs-string"><span class="hljs-string">"sandboxing.variable.types"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ThreadLocal&lt;Map&lt;String, Object&gt;&gt; COMPILE_OPTIONS = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ThreadLocal&lt;&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ CompilerConfiguration conf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompilerConfiguration(); ImportCustomizer customizer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImportCustomizer(); customizer.addStaticStars(<span class="hljs-string"><span class="hljs-string">"java.lang.Math"</span></span>); ASTTransformationCustomizer astcz = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ASTTransformationCustomizer( singletonMap(<span class="hljs-string"><span class="hljs-string">"extensions"</span></span>, singletonList(<span class="hljs-string"><span class="hljs-string">"SecureExtension4.groovy"</span></span>)), CompileStatic.class); conf.addCompilationCustomizers(astcz); conf.addCompilationCustomizers(customizer); Binding binding = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Binding(); binding.setVariable(<span class="hljs-string"><span class="hljs-string">"score"</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>d); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Map&lt;String,ClassNode&gt; variableTypes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;String, ClassNode&gt;(); variableTypes.put(<span class="hljs-string"><span class="hljs-string">"score"</span></span>, ClassHelper.double_TYPE); Map&lt;String,Object&gt; options = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;String, Object&gt;(); options.put(VAR_TYPES, variableTypes); COMPILE_OPTIONS.set(options); GroovyShell shell = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GroovyShell(binding, conf); Double userScore = (Double) shell.evaluate(<span class="hljs-string"><span class="hljs-string">"abs(cos(1+score));System.exit(-1)"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"userScore = "</span></span> + userScore); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { COMPILE_OPTIONS.remove(); } } }</code> </pre> <br><ol><li>  <code>ThreadLocal</code> ,          </li><li>    ‚Äî <code>SecureExtension4.groovy</code> </li><li> <code>variableTypes</code> ‚Äî   ‚Äú  ‚Üí  ‚Äù </li><li>      <code>score</code> </li><li> <code>options</code> ‚Äî     </li><li>   "variable types"     VAR_TYPES </li><li>     thread local </li><li> ,    ,     thread local </li></ol><br><p>          : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Sandbox.* def typesOfVariables = COMPILE_OPTIONS.get()[VAR_TYPES] unresolvedVariable { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (typesOfVariables[<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.name]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> makeDynamic(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, typesOfVariables[<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.name]) } }</code> </pre> <br><ol><li>        thread local </li><li>      ,      , </li><li>   type checker       </li></ol><br><p>         thread local,    ,  type checker  . ,      <code>unresolvedVariable</code> ,    ,  ,    type checker,   .  ,     .   ! </p><br><p>           .        ,       . </p><br><h2 id="konfiguraciya-belogo-spiska-metodov">     </h2><br><p>    .   ,       .      ,         ,     . ,  <code>System.exit</code> ,   : </p><br><pre> <code class="plaintext hljs">java.lang.System#exit(int)</code> </pre> <br><p> ,     Java,    : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sandbox</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String WHITELIST_PATTERNS = <span class="hljs-string"><span class="hljs-string">"sandboxing.whitelist.patterns"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... public static void main(String[] args) { // ... try { Map&lt;String,ClassNode&gt; variableTypes = new HashMap&lt;String, ClassNode&gt;(); variableTypes.put("score", ClassHelper.double_TYPE); Map&lt;String,Object&gt; options = new HashMap&lt;String, Object&gt;(); List&lt;String&gt; patterns = new ArrayList&lt;String&gt;(); patterns.add("java\\.lang\\.Math#"); options.put(VAR_TYPES, variableTypes); options.put(WHITELIST_PATTERNS, patterns); COMPILE_OPTIONS.set(options); GroovyShell shell = new GroovyShell(binding, conf); Double userScore = (Double) shell.evaluate("abs(cos(1+score));System.exit(-1)"); System.out.println("userScore = " + userScore); } finally { COMPILE_OPTIONS.remove(); } } }</span></span></code> </pre> <br><ol><li>    </li><li>    <code>java.lang.Math</code>   </li><li>        </li></ol><br><p>       : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> groovy.transform.CompileStatic <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.ClassNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.MethodNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.Parameter <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.transform.stc.ExtensionMethodNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Sandbox.* <span class="hljs-meta"><span class="hljs-meta">@CompileStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prettyPrint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClassNode node)</span></span></span><span class="hljs-function"> </span></span>{ node.isArray()?<span class="hljs-string"><span class="hljs-string">"${prettyPrint(node.componentType)}[]"</span></span>:node.toString(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } <span class="hljs-meta"><span class="hljs-meta">@CompileStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toMethodDescriptor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MethodNode node)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ExtensionMethodNode) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> toMethodDescriptor(node.extensionMethodNode) } def sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder() sb.append(node.declaringClass.toString(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>)) sb.append(<span class="hljs-string"><span class="hljs-string">"#"</span></span>) sb.append(node.name) sb.append(<span class="hljs-string"><span class="hljs-string">'('</span></span>) sb.append(node.parameters.collect { Parameter it -&gt; prettyPrint(it.originType) }.join(<span class="hljs-string"><span class="hljs-string">','</span></span>)) sb.append(<span class="hljs-string"><span class="hljs-string">')'</span></span>) sb } def typesOfVariables = COMPILE_OPTIONS.get()[VAR_TYPES] def whiteList = COMPILE_OPTIONS.get()[WHITELIST_PATTERNS] onMethodSelection { expr, MethodNode methodNode -&gt; def descr = toMethodDescriptor(methodNode) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!whiteList.any { descr =~ it }) { addStaticTypeError(<span class="hljs-string"><span class="hljs-string">"You tried to call a method which is not allowed, what did you expect?: $descr"</span></span>, expr) } } unresolvedVariable { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (typesOfVariables[<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.name]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> makeDynamic(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, typesOfVariables[<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.name]) } }</code> </pre> <br><ol><li>       <code>MethodNode</code> </li><li>     thread local </li><li>       </li><li>        ,   </li></ol><br><p>      ,    : </p><br><pre> <code class="plaintext hljs">Script1.groovy: 1: [Static type checking] - You tried to call a method which is not allowed, what did you expect?: java.lang.System#exit(int) @ line 1, column 19. abs(cos(1+score));System.exit(-1) ^ 1 error</code> </pre> <br><p> ,  !        ,   <strong>  </strong> , <strong>  </strong>  .    ,      !     ,       ,       . ,   (  <code>foo.text</code> ,     <code>foo.getText()</code> ). </p><br><h2 id="sobiraem-vse-vmeste">    </h2><br><p>     ,    type checker'    "property selection", ,   .      ,         ,  .         ,     ,       ‚Äî    .     . </p><br><p> <code>SandboxingTypeCheckingExtension.groovy</code> </p> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> groovy.transform.CompileStatic <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.ClassCodeVisitorSupport <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.ClassHelper <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.ClassNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.MethodNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.Parameter <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.expr.PropertyExpression <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.control.SourceUnit <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.transform.sc.StaticCompilationMetadataKeys <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.transform.stc.ExtensionMethodNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.transform.stc.GroovyTypeCheckingExtensionSupport <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Sandbox.* <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SandboxingTypeCheckingExtension</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroovyTypeCheckingExtensionSupport</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeCheckingDSL</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@CompileStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prettyPrint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClassNode node)</span></span></span><span class="hljs-function"> </span></span>{ node.isArray()?<span class="hljs-string"><span class="hljs-string">"${prettyPrint(node.componentType)}[]"</span></span>:node.toString(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } <span class="hljs-meta"><span class="hljs-meta">@CompileStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toMethodDescriptor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MethodNode node)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ExtensionMethodNode) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> toMethodDescriptor(node.extensionMethodNode) } def sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder() sb.append(node.declaringClass.toString(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>)) sb.append(<span class="hljs-string"><span class="hljs-string">"#"</span></span>) sb.append(node.name) sb.append(<span class="hljs-string"><span class="hljs-string">'('</span></span>) sb.append(node.parameters.collect { Parameter it -&gt; prettyPrint(it.originType) }.join(<span class="hljs-string"><span class="hljs-string">','</span></span>)) sb.append(<span class="hljs-string"><span class="hljs-string">')'</span></span>) sb } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Fetch white list of regular expressions of authorized method calls def whiteList = COMPILE_OPTIONS.get()[WHITELIST_PATTERNS] def typesOfVariables = COMPILE_OPTIONS.get()[VAR_TYPES] onMethodSelection { expr, MethodNode methodNode -&gt; def descr = toMethodDescriptor(methodNode) if (!whiteList.any { descr =~ it }) { addStaticTypeError("You tried to call a method which is not allowed, what did you expect?: $descr", expr) } } unresolvedVariable { var -&gt; if (isDynamic(var) &amp;&amp; typesOfVariables[var.name]) { storeType(var, typesOfVariables[var.name]) handled = true } } // handling properties (like foo.text) is harder because the type checking extension // does not provide a specific hook for this. Harder, but not impossible! afterVisitMethod { methodNode -&gt; def visitor = new PropertyExpressionChecker(context.source, whiteList) visitor.visitMethod(methodNode) } } private class PropertyExpressionChecker extends ClassCodeVisitorSupport { private final SourceUnit unit private final List&lt;String&gt; whiteList PropertyExpressionChecker(final SourceUnit unit, final List&lt;String&gt; whiteList) { this.unit = unit this.whiteList = whiteList } @Override protected SourceUnit getSourceUnit() { unit } @Override void visitPropertyExpression(final PropertyExpression expression) { super.visitPropertyExpression(expression) ClassNode owner = expression.objectExpression.getNodeMetaData(StaticCompilationMetadataKeys.PROPERTY_OWNER) if (owner) { if (expression.spreadSafe &amp;&amp; StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(owner, classNodeFor(Collection))) { owner = typeCheckingVisitor.inferComponentType(owner, ClassHelper.int_TYPE) } def descr = "${prettyPrint(owner)}#${expression.propertyAsString}" if (!whiteList.any { descr =~ it }) { addStaticTypeError("Property is not allowed: $descr", expression) } } } } }```     sandbox',     assert' ,  ,     : ``Sandbox.java`` ```java public class Sandbox { public static final String WHITELIST_PATTERNS = "sandboxing.whitelist.patterns"; public static final String VAR_TYPES = "sandboxing.variable.types"; public static final ThreadLocal&lt;Map&lt;String, Object&gt;&gt; COMPILE_OPTIONS = new ThreadLocal&lt;Map&lt;String, Object&gt;&gt;(); public static void main(String[] args) { CompilerConfiguration conf = new CompilerConfiguration(); ImportCustomizer customizer = new ImportCustomizer(); customizer.addStaticStars("java.lang.Math"); ASTTransformationCustomizer astcz = new ASTTransformationCustomizer( singletonMap("extensions", singletonList("SandboxingTypeCheckingExtension.groovy")), CompileStatic.class); conf.addCompilationCustomizers(astcz); conf.addCompilationCustomizers(customizer); Binding binding = new Binding(); binding.setVariable("score", 2.0d); try { Map&lt;String, ClassNode&gt; variableTypes = new HashMap&lt;String, ClassNode&gt;(); variableTypes.put("score", ClassHelper.double_TYPE); Map&lt;String, Object&gt; options = new HashMap&lt;String, Object&gt;(); List&lt;String&gt; patterns = new ArrayList&lt;String&gt;(); // allow method calls on Math patterns.add("java\\.lang\\.Math#"); // allow constructors calls on File patterns.add("File#&lt;init&gt;"); // because we let the user call each/times/... patterns.add("org\\.codehaus\\.groovy\\.runtime\\.DefaultGroovyMethods"); options.put(VAR_TYPES, variableTypes); options.put(WHITELIST_PATTERNS, patterns); COMPILE_OPTIONS.set(options); GroovyShell shell = new GroovyShell(binding, conf); Object result; try { result = shell.evaluate("Eval.me('1')"); // error assert false; } catch (MultipleCompilationErrorsException e) { System.out.println("Successful sandboxing: "+e.getMessage()); } try { result = shell.evaluate("System.exit(-1)"); // error assert false; } catch (MultipleCompilationErrorsException e) { System.out.println("Successful sandboxing: "+e.getMessage()); } try { result = shell.evaluate("((Object)Eval).me('1')"); // error assert false; } catch (MultipleCompilationErrorsException e) { System.out.println("Successful sandboxing: "+e.getMessage()); } try { result = shell.evaluate("new File('/etc/passwd').getText()"); // getText is not allowed assert false; } catch (MultipleCompilationErrorsException e) { System.out.println("Successful sandboxing: "+e.getMessage()); } try { result = shell.evaluate("new File('/etc/passwd').text"); // getText is not allowed assert false; } catch (MultipleCompilationErrorsException e) { System.out.println("Successful sandboxing: "+e.getMessage()); } Double userScore = (Double) shell.evaluate("abs(cos(1+score))"); System.out.println("userScore = " + userScore); } finally { COMPILE_OPTIONS.remove(); } } }</span></span></code> </pre> <br><h2 id="zaklyuchenie">  Fazit </h2><br><p>      Groovy       JVM.        ,      . ,    ,    ,      .  ,    Groovy,      sandboxing'          (,       ,   ). </p><br><p>  ,            ,          .      ,            .  ,      ,        . </p><br><p>    ,   sandboxing',   , ‚Äî  <strong></strong>  <code>SecureASTCustomizer</code> .    <strong> ,  </strong> ,       : secure AST customizer    ,      (,       ),              (   ,   ). </p><br><p> ,    : ,   , .   Groovy   .          Groovy,   ,  -      pull request,      -  ! <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445114/">https://habr.com/ru/post/de445114/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445104/index.html">Eine kurze Geschichte der Audiomarke Klipsch</a></li>
<li><a href="../de445106/index.html">Runder Tisch: Additive Technologie als Alternative zur traditionellen Fertigung</a></li>
<li><a href="../de445108/index.html">Kein einziger Falke - grundlegend andere wiederverwendbare ESA- und ULA-Projekte</a></li>
<li><a href="../de445110/index.html">Ein Computer mit einem Terminal-Laufwerk im Fallout-Stil</a></li>
<li><a href="../de445112/index.html">Aufdecken eines Gewirrs von Schwachstellen auf Websites</a></li>
<li><a href="../de445116/index.html">Die US Air Force arbeitet an einer KI-Drohne namens Skyborg</a></li>
<li><a href="../de445118/index.html">In einem privaten Telegramm-Chat k√∂nnen Sie alle Nachrichten l√∂schen - auch Fremde (ein Abstimmungsergebnis wurde hinzugef√ºgt).</a></li>
<li><a href="../de445120/index.html">Frontend Weekly Digest (18. - 24. M√§rz 2019)</a></li>
<li><a href="../de445122/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 357 (18.-24. M√§rz 2019)</a></li>
<li><a href="../de445124/index.html">M√§√üige H√§rtung f√ºr Firefox</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>