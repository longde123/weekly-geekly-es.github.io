<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔔 🤶🏿 🔓 如何通过改善性能来降低性能 🐛 🦋 👇🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我们想要最好的，但结果却一如既往。 
 Victor Chernomyrdin， 
 俄罗斯政治家 


 在生活中，有时候似乎一切都做对了，但是出了点问题。 
 这个故事就是关于这种情况的。 


 一旦我看了一下这段代码并考虑过要加快速度： 


public String appendBoun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如何通过改善性能来降低性能</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436746/"><p> <em>我们想要最好的，但结果却一如既往。</em> <br>  Victor Chernomyrdin， <br> 俄罗斯政治家 </p><br><p> 在生活中，有时候似乎一切都做对了，但是出了点问题。 <br> 这个故事就是关于这种情况的。 </p><a name="habracut"></a><br><p> 一旦我看了一下这段代码并考虑过要加快速度： </p><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">appendBounds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginIndex = data.beginIndex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endIndex = data.endIndex; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder() .append(<span class="hljs-string"><span class="hljs-string">'L'</span></span>) .append(data.str, beginIndex, endIndex) .append(<span class="hljs-string"><span class="hljs-string">';'</span></span>) .toString(); }</code> </pre> <br><p> 首先，我想使用<code>beginIndex</code>和<code>endIndex</code>变量（以及除截断的字符串外还将向<code>StringBuilder</code>添加2个字符的事实）来计算字符串的总长度，并将此值传递给<code>StringBuilder</code>构造函数以立即选择所需大小的数组。 这个想法对我来说似乎太明显了，所以我决定尝试其他方法。 尽管“聪明”女孩通常建议使用<code>StringBuilder::append</code>的短字符串替换为字符串，但该代码并未被“ Idea”突出显示，这使我想到了正确的想法，因为字符串较短，而且更易于阅读。 </p><br><p> 这种简化的障碍是使用<code>StringBuilder.append(CharSequence, int, int)</code>方法。 假设<code>data.str</code>字段是一个字符串，则使用<code>String.substring(beginIndex, endIndex)</code>可以从中选择一个子字符串并将其传递给<code>StringBuilder.append(String)</code> 。 </p><br><p> 转换后的代码： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">appendBounds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginIndex = data.beginIndex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endIndex = data.endIndex; String subString = data.str.substring(beginIndex, endIndex); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder() .append(<span class="hljs-string"><span class="hljs-string">'L'</span></span>) .append(subString) .append(<span class="hljs-string"><span class="hljs-string">';'</span></span>) .toString(); }</code> </pre> <br><p> 现在，该想法提供了一个简化： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">appendBounds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginIndex = data.beginIndex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endIndex = data.endIndex; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'L'</span></span> + data.str.substring(beginIndex, endIndex) + <span class="hljs-string"><span class="hljs-string">';'</span></span>; }</code> </pre> <br><p> 但是，在这种情况下，我们的目标不是提高可读性，而是提高生产率。 比较两种方法： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BenchmarkMode</span></span>(Mode.AverageTime) <span class="hljs-meta"><span class="hljs-meta">@OutputTimeUnit</span></span>(TimeUnit.NANOSECONDS) <span class="hljs-meta"><span class="hljs-meta">@Fork</span></span>(jvmArgsAppend = {<span class="hljs-string"><span class="hljs-string">"-Xms2g"</span></span>, <span class="hljs-string"><span class="hljs-string">"-Xmx2g"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilderAppendBenchmark</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">appendSubString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data data)</span></span></span><span class="hljs-function"> </span></span>{ String latinStr = data.latinStr; String nonLatinStr = data.nonLatinStr; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginIndex = data.beginIndex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endIndex = data.endIndex; String substring = data.nonLatin ? nonLatinStr.substring(beginIndex, endIndex) : latinStr.substring(beginIndex, endIndex); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder() .append(<span class="hljs-string"><span class="hljs-string">'L'</span></span>) .append(substring) .append(<span class="hljs-string"><span class="hljs-string">';'</span></span>) .toString(); } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">appendBounds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data data)</span></span></span><span class="hljs-function"> </span></span>{ String latinStr = data.latinStr; String nonLatinStr = data.nonLatinStr; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginIndex = data.beginIndex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endIndex = data.endIndex; String appended = data.nonLatin ? nonLatinStr : latinStr; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder() .append(<span class="hljs-string"><span class="hljs-string">'L'</span></span>) .append(appended, beginIndex, endIndex) .append(<span class="hljs-string"><span class="hljs-string">';'</span></span>) .toString(); } <span class="hljs-meta"><span class="hljs-meta">@State</span></span>(Scope.Thread) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Data</span></span></span><span class="hljs-class"> </span></span>{ String latinStr; String nonLatinStr; <span class="hljs-meta"><span class="hljs-meta">@Param</span></span>({<span class="hljs-string"><span class="hljs-string">"true"</span></span>, <span class="hljs-string"><span class="hljs-string">"false"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> nonLatin; <span class="hljs-meta"><span class="hljs-meta">@Param</span></span>({<span class="hljs-string"><span class="hljs-string">"5"</span></span>, <span class="hljs-string"><span class="hljs-string">"10"</span></span>, <span class="hljs-string"><span class="hljs-string">"50"</span></span>, <span class="hljs-string"><span class="hljs-string">"100"</span></span>, <span class="hljs-string"><span class="hljs-string">"500"</span></span>, <span class="hljs-string"><span class="hljs-string">"1000"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginIndex; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endIndex; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ThreadLocalRandom random = ThreadLocalRandom.current(); <span class="hljs-meta"><span class="hljs-meta">@Setup</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ latinStr = randomString(<span class="hljs-string"><span class="hljs-string">"abcdefghijklmnopqrstuvwxyz"</span></span>); nonLatinStr = randomString(<span class="hljs-string"><span class="hljs-string">""</span></span>); beginIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; endIndex = length + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randomString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String alphabet)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] chars = alphabet.toCharArray(); StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(length + <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length + <span class="hljs-number"><span class="hljs-number">2</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = chars[random.nextInt(chars.length)]; sb.append(c); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sb.toString(); } } }</code> </pre> <br><p> 基准测试只需两个便士：将一个随机字符串添加到<code>StringBuilder</code> ，其大小由<code>length</code>字段决定，并且由于码是2019，因此您需要将其检查为仅包含主要拉丁字母字符的字符串（所谓的压缩行，其中每个字符对应于1个字节），以及一个包含非拉丁字符的字符串（每个字符由2个字节表示）。 </p><br><p> 粗略地检查一下， <code>appendSubString</code>方法在我们<code>appendSubString</code>较慢，因为要粘贴的数据量与<code>appendBounds</code>方法的量一致，但是，在<code>appendSubString</code>方法中<code>appendSubString</code>还明确创建了一个子字符串，即为新对象分配内存并将其内容从<code>data.latinStr</code>复制到其中/ <code>data.nonLatinStr</code> 。 </p><br><p> 我在家用计算机（Intel Core i5-4690，3.50 GHz）上使用JDK11执行的测量结果更令人惊讶（但乍看之下）似乎是： </p><br><pre> <code class="plaintext hljs">Benchmark nonLatin length Score Error Units appendBounds true 5 44,6 ± 0,4 ns/op appendBounds true 10 45,7 ± 0,7 ns/op appendBounds true 50 129,0 ± 0,5 ns/op appendBounds true 100 218,7 ± 0,8 ns/op appendBounds true 500 907,1 ± 5,5 ns/op appendBounds true 1000 1626,4 ± 13,0 ns/op appendSubString true 5 28,6 ± 0,2 ns/op appendSubString true 10 30,8 ± 0,2 ns/op appendSubString true 50 65,6 ± 0,4 ns/op appendSubString true 100 106,6 ± 0,6 ns/op appendSubString true 500 430,1 ± 2,4 ns/op appendSubString true 1000 839,1 ± 8,6 ns/op appendBounds:·gc.alloc.rate.norm true 5 184,0 ± 0,0 B/op appendBounds:·gc.alloc.rate.norm true 10 200,0 ± 0,0 B/op appendBounds:·gc.alloc.rate.norm true 50 688,0 ± 0,0 B/op appendBounds:·gc.alloc.rate.norm true 100 1192,0 ± 0,0 B/op appendBounds:·gc.alloc.rate.norm true 500 5192,0 ± 0,0 B/op appendBounds:·gc.alloc.rate.norm true 1000 10200,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm true 5 136,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm true 10 160,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm true 50 360,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm true 100 608,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm true 500 2608,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm true 1000 5104,0 ± 0,0 B/op appendBounds false 5 20,8 ± 0,1 ns/op appendBounds false 10 24,0 ± 0,2 ns/op appendBounds false 50 66,4 ± 0,4 ns/op appendBounds false 100 111,0 ± 0,8 ns/op appendBounds false 500 419,2 ± 2,7 ns/op appendBounds false 1000 840,4 ± 7,8 ns/op appendSubString false 5 25,3 ± 0,3 ns/op appendSubString false 10 25,7 ± 0,2 ns/op appendSubString false 50 36,0 ± 0,1 ns/op appendSubString false 100 52,8 ± 0,4 ns/op appendSubString false 500 206,1 ± 6,1 ns/op appendSubString false 1000 388,1 ± 1,6 ns/op appendBounds:·gc.alloc.rate.norm false 5 80,0 ± 0,0 B/op appendBounds:·gc.alloc.rate.norm false 10 88,0 ± 0,0 B/op appendBounds:·gc.alloc.rate.norm false 50 320,0 ± 0,0 B/op appendBounds:·gc.alloc.rate.norm false 100 544,0 ± 0,0 B/op appendBounds:·gc.alloc.rate.norm false 500 2144,0 ± 0,0 B/op appendBounds:·gc.alloc.rate.norm false 1000 4152,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm false 5 96,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm false 10 112,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm false 50 192,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm false 100 288,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm false 500 1088,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm false 1000 2088,0 ± 0,0 B/op</code> </pre> <br><p> 驳斥我们的假设，在大多数情况下（包括总是针对非拉丁字符串） <code>appendSubString</code>方法被证明是更快，更轻松（即使<code>String::substring</code>返回一个新对象）。 怎么发生的？ </p><br><h2 id="smotryu-v-knigu-vizhu-figu"> 我看书，看到无花果 </h2><br><p> 学习<code>StringBuilder</code>源代码将有助于揭开保密<code>StringBuilder</code>面纱。 两种使用的方法都将调用传递给<code>AbstractStringBuilder</code>的相同方法： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilder</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractStringBuilder</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">io</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comparable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilder</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CharSequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.append(str); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CharSequence s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> end)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.append(s, start, end); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }</code> </pre> <br><p> 转到<code>AbstractStringBuilder.append(String)</code> ： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> AbstractStringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> appendNull(); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len = str.length(); ensureCapacityInternal(count + len); putStringAt(count, str); count += len; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">putStringAt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, String str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getCoder() != str.coder()) { inflate(); } str.getBytes(value, index, coder); }</code> </pre> <br><p> 这里有趣的是什么？ 顾名思义， <code>AbstractStringBuilder::inflate</code>在组合不同的字符串时会扩展<code>AbstractStringBuilder.value</code>数组。 数据在<code>String::getBytes</code> ： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBytes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] dst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dstBegin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> coder)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (coder() == coder) { System.arraycopy(value, <span class="hljs-number"><span class="hljs-number">0</span></span>, dst, dstBegin &lt;&lt; coder, value.length); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// this.coder == LATIN &amp;&amp; coder == UTF16 StringLatin1.inflate(value, 0, dst, dstBegin, value.length); } }</span></span></code> </pre> <br><p> 重要的是什么？ 如果字符串是同质的，则使用固有的<code>System::arraycopy</code>来移动数据，否则使用<code>StringLatin1::inflate</code> ，它通过委托将我们<code>StringUTF16::inflate</code> ： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// inflatedCopy byte[] -&gt; byte[] @HotSpotIntrinsicCandidate public static void inflate(byte[] src, int srcOff, byte[] dst, int dstOff, int len) { // We need a range check here because 'putChar' has no checks checkBoundsOffCount(dstOff, len, dst); for (int i = 0; i &lt; len; i++) { putChar(dst, dstOff++, src[srcOff++] &amp; 0xff); } } @HotSpotIntrinsicCandidate static void putChar(byte[] val, int index, int c) { assert index &gt;= 0 &amp;&amp; index &lt; length(val) : "Trusted caller missed bounds check"; index &lt;&lt;= 1; val[index++] = (byte)(c &gt;&gt; HI_BYTE_SHIFT); val[index] = (byte)(c &gt;&gt; LO_BYTE_SHIFT); }</span></span></code> </pre> <br><p> 因此，如果行是同质的，则使用依赖于平台的方法<code>System::arraycopy</code>来移动数据，否则使用循环（也是固有的）。 这意味着，当粘贴两行时，所有字符都位于主拉丁字母的集合中（换句话说，适合1个字节），其性能应比粘贴异构行时好得多。 基准测试确认了这一点（请参见<code>nonLatin = false</code>输出）。 </p><br><p> 现在， <code>AbstractStringBuilder.append(CharSequence, int, int)</code>方法<code>AbstractStringBuilder.append(CharSequence, int, int)</code> ： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> AbstractStringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CharSequence s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> end)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { s = <span class="hljs-string"><span class="hljs-string">"null"</span></span>; } checkRange(start, end, s.length()); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len = end - start; ensureCapacityInternal(count + len); appendChars(s, start, end); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">appendChars</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CharSequence s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> off, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> end)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isLatin1()) { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] val = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = off, j = count; i &lt; end; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = s.charAt(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (StringLatin1.canEncode(c)) { val[j++] = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)c; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { count = j; inflate(); StringUTF16.putCharsSB(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value, j, s, i, end); count += end - i; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { StringUTF16.putCharsSB(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value, count, s, off, end); } count += end - off; }</code> </pre> <br><p> 在这里，该方法类似于上一个示例中的方法：对于同构字符串，使用一种更简单的机制（此处是循环中的符号复制），对于异类字符串，我们使用<code>StringUTF16</code> ，但是请注意，并未固有地调用<code>StringUTF16::putCharsSB</code> 。 </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">putCharsSB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] val, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, CharSequence s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> off, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> end)</span></span></span><span class="hljs-function"> </span></span>{ checkBoundsBeginEnd(index, index + end - off, val); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = off; i &lt; end; i++) { putChar(val, index++, s.charAt(i)); } }</code> </pre> <br><p> 因此，这两种方法的内部结构以及它们不同性能的原因对我们来说还是差不多的。 问题自然而然地出现了-如何处理接下来获得的知识？ 一次有几个选项： </p><br><p>  1）请记住这一点，当它检测到可疑代码时，请用手进行更改 <br>  2）前往塔吉尔（Tagir）并要求他提交支票，代替我们来做 <br>  3）对JDK进行更改，以使代码完全不变。 </p><br><p> 当然，我们从第三个开始。 准备好冒险了吗？ </p><br><h2 id="pogruzhenie-v-puchinu"> 深渊 </h2><br><p> 我们将训练 <del> 在猫上 </del> 有关第11个Java的源代码，可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>下载。 </p><br><p> 最简单，最明显的改进方法是选择一个位于<code>AbstractStringBuilder.append(CharSequence, int, int)</code>方法内部的子字符串： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  public AbstractStringBuilder append(CharSequence s, int start, int end) { if (s == null) { s = "null"; } checkRange(start, end, s.length()); int len = end - start; ensureCapacityInternal(count + len); appendChars(s, start, end); return this; } //  public AbstractStringBuilder append(CharSequence s, int start, int end) { if (s == null) { s = "null"; } checkRange(start, end, s.length()); return append(s.subSequence(start, end).toString()); }</span></span></code> </pre> <br><p> 现在，您需要构建JDK，运行测试并在其上运行<code>StringBuilderAppendBenchmark::appendBounds</code>基准测试，需要将其结果与原始JDK上相同基准测试的结果进行比较： </p><br><pre> <code class="plaintext hljs">#   before      JDK, # after -   Benchmark nonLatin length before after Units avgt true 5 44,6 64,4 ns/op avgt true 10 45,7 66,3 ns/op avgt true 50 129,0 168,9 ns/op avgt true 100 218,7 281,9 ns/op avgt true 500 907,1 1116,2 ns/op avgt true 1000 1626,4 2002,5 ns/op gc.alloc.rate.norm true 5 184,0 264,0 B/op gc.alloc.rate.norm true 10 200,0 296,0 B/op gc.alloc.rate.norm true 50 688,0 904,0 B/op gc.alloc.rate.norm true 100 1192,0 1552,0 B/op gc.alloc.rate.norm true 500 5192,0 6752,0 B/op gc.alloc.rate.norm true 1000 10200,0 13256,0 B/op avgt false 5 20,8 38,0 ns/op avgt false 10 24,0 37,8 ns/op avgt false 50 66,4 82,9 ns/op avgt false 100 111,0 138,8 ns/op avgt false 500 419,2 531,9 ns/op avgt false 1000 840,4 1002,7 ns/op gc.alloc.rate.norm false 5 80,0 152,0 B/op gc.alloc.rate.norm false 10 88,0 168,0 B/op gc.alloc.rate.norm false 50 320,0 440,0 B/op gc.alloc.rate.norm false 100 544,0 688,0 B/op gc.alloc.rate.norm false 500 2144,0 2688,0 B/op gc.alloc.rate.norm false 1000 4152,0 5192,0 B/op</code> </pre> <br><p> 什么叫突然！ 不仅没有改善，而且恶化了。 该死的，但是怎么办？ </p><br><p> 事实是，在一开始，在<code>StringBuilder::append</code>方法的描述中<code>StringBuilder::append</code>我做了一个小但至关重要的遗漏。 方法描述如下： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.append(str); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }</code> </pre> <br><p> 这是其完整视图： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@HotSpotIntrinsicCandidate</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.append(str); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }</code> </pre> <br><p> 我们上面检查过的Java代码（在C2级别上进行了加热和编译）并不重要，因为它不是执行的，而是内在的。 通过使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">async-profiler</a>删除配置文件很容易证明这一点。 此后，将删除<code>length = 1000</code>且<code>nonLatin = true</code>的配置文件： </p><br><pre> <code class="plaintext hljs">#   `appendSubString`, JDK    ns percent samples top ---------- ------- ------- --- 19096340914 43.57% 1897673 jbyte_disjoint_arraycopy &lt;--------- 13500185356 30.80% 1343343 jshort_disjoint_arraycopy &lt;--------- 4124818581 9.41% 409533 java.lang.String.&lt;init&gt; #   2177311938 4.97% 216375 java.lang.StringUTF16.compress #   1557269661 3.55% 154253 java.util.Arrays.copyOfRange #   349344451 0.80% 34823 appendSubString_avgt_jmhStub 279803769 0.64% 27862 java.lang.StringUTF16.newString 274388920 0.63% 27312 org.openjdk.jmh.infra.Blackhole.consume 160962540 0.37% 15946 SpinPause 122418222 0.28% 11795 __memset_avx2</code> </pre> <br><p>  <code>StringBuilder</code> （和<code>AbstractStringBuilder</code> ）的代码在这里甚至都没有味道，几乎3/4的配置文件被一个内部函数占用。 我想在我们“改进的” <code>StringBuilder.append(CharSequence, int, int)</code>的配置文件中观察到大约相同的图片。 </p><br><p> 实际上，我们有： </p><br><pre> <code class="plaintext hljs"> ns percent samples top ---------- ------- ------- --- 19071221451 43.78% 1897827 jbyte_disjoint_arraycopy 6409223440 14.71% 638348 jlong_disjoint_arraycopy 3933622128 9.03% 387403 java.lang.StringUTF16.newBytesFor 2067248311 4.75% 204193 java.lang.AbstractStringBuilder.ensureCapacityInternal 1929218737 4.43% 194751 java.lang.StringUTF16.compress 1678321343 3.85% 166458 java.util.Arrays.copyOfRange 1621470408 3.72% 160849 java.lang.String.checkIndex 969180099 2.22% 96018 java.util.Arrays.copyOf 581600786 1.34% 57818 java.lang.AbstractStringBuilder.&lt;init&gt; 417818533 0.96% 41611 appendBounds_jmhTest 406565329 0.93% 40479 java.lang.String.&lt;init&gt; 340972882 0.78% 33727 java.lang.AbstractStringBuilder.append 299895915 0.69% 29982 java.lang.StringBuilder.toString 183885595 0.42% 18136 SpinPause 168666033 0.39% 16755 org.openjdk.jmh.infra.Blackhole.consume</code> </pre> <br><p> 您会说：“它们在内部，在最顶层！” 实际上，只有这些不是相同的内在函数（包括从上面比较第二个的名称）。 回想一下： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@HotSpotIntrinsicCandidate</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.append(str); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }</code> </pre> <br><p> 在此，内在函数替换了对<code>StringBuilder.append(String)</code>的调用，但是在我们的补丁程序中，此调用不是！ 称为<code>AbstractStringBuilder.append(String)</code> 。 我们<code>jbyte_disjoint_arraycopy</code>的<code>jbyte_disjoint_arraycopy</code>调用是<code>StringLatin1::inflate</code>的内在调用，它是通过<code>String::getBytes</code>从<code>AbstractStringBuider::putStringAt</code> <code>jbyte_disjoint_arraycopy</code>调用的。 也就是说，与<code>StringBuilder::append</code>不同<code>StringBuilder::append</code>不仅处理特定于平台的代码，还处理Java代码， </p><br><p> 了解失败的原因，否则请尝试成功。 很容易猜到我们需要以某种方式引用<code>StringBuilder::append</code> 。 您可以通过撕下以前的补丁并对<code>StringBuilder</code>本身进行更改来做到这一点： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  @Override public StringBuilder append(CharSequence s, int start, int end) { super.append(s, start, end); return this; } //  @Override public StringBuilder append(CharSequence s, int start, int end) { if (s == null) { s = "null"; } checkRange(start, end, s.length()); return this.append(s.subSequence(start, end).toString()); } }</span></span></code> </pre> <br><p> 现在，一切都明智地完成了：内在的StringBuilder :: append被调用。 <br> 重建，运行，比较： </p><br><pre> <code class="plaintext hljs">#   before      JDK, # after -   Benchmark nonLatin length before after Units avgt true 5 44,6 60,2 ns/op avgt true 10 45,7 59,1 ns/op avgt true 50 129,0 164,6 ns/op avgt true 100 218,7 276,2 ns/op avgt true 500 907,1 1088,8 ns/op avgt true 1000 1626,4 1959,4 ns/op gc.alloc.rate.norm true 5 184,0 264,0 B/op gc.alloc.rate.norm true 10 200,0 296,0 B/op gc.alloc.rate.norm true 50 688,0 904,0 B/op gc.alloc.rate.norm true 100 1192,0 1552,0 B/op gc.alloc.rate.norm true 500 5192,0 6752,0 B/op gc.alloc.rate.norm true 1000 10200,0 13256,0 B/op avgt false 5 20,8 37,9 ns/op avgt false 10 24,0 37,9 ns/op avgt false 50 66,4 80,9 ns/op avgt false 100 111,0 125,6 ns/op avgt false 500 419,2 483,6 ns/op avgt false 1000 840,4 893,8 ns/op gc.alloc.rate.norm false 5 80,0 152,0 B/op gc.alloc.rate.norm false 10 88,0 168,0 B/op gc.alloc.rate.norm false 50 320,0 440,0 B/op gc.alloc.rate.norm false 100 544,0 688,0 B/op gc.alloc.rate.norm false 500 2144,0 2688,0 B/op gc.alloc.rate.norm false 1000 4152,0 5187,2 B/op</code> </pre><br><p> 我真的感到非常难过，但并没有好转。 现在是一个新的配置文件： </p><br><pre> <code class="plaintext hljs"> ns percent samples top ---------- ------- ------- --- 19614374885 44.12% 1953620 jbyte_disjoint_arraycopy 6645299702 14.95% 662146 jlong_disjoint_arraycopy 4065789919 9.15% 400167 java.lang.StringUTF16.newBytesFor 2374627822 5.34% 234746 java.lang.AbstractStringBuilder.ensureCapacityInternal 1837858014 4.13% 183822 java.lang.StringUTF16.compress 1472039604 3.31% 145956 java.util.Arrays.copyOfRange 1316397864 2.96% 130747 appendBounds_jmhTest 956823151 2.15% 94959 java.util.Arrays.copyOf 573091712 1.29% 56933 java.lang.AbstractStringBuilder.&lt;init&gt; 434454076 0.98% 43202 java.lang.String.&lt;init&gt; 368480388 0.83% 36439 java.lang.AbstractStringBuilder.append 304409057 0.68% 30442 java.lang.StringBuilder.toString 272437989 0.61% 26833 SpinPause 201051696 0.45% 19985 java.lang.StringBuilder.&lt;init&gt; 198934052 0.45% 19810 appendBounds_avgt_jmhStub</code> </pre> <br><p> 几乎没有改变。 对我来说，目前尚不清楚为什么从<code>StringBuilder</code>访问<code>StringBuilder.append(String)</code>时内在函数为什么不起作用。 有人怀疑将<code>StringBuilder.append(String)</code>方法的主体粘贴（内联）到<code>StringBuilder.append(CharSequence, int, int)</code>的主体中会改变VM方法调用的处理过程。 </p><br><p> 无论如何，这是惨败，兄弟。 无法修补JDK，但是我们仍然可以在需要的地方手动进行替换。 </p><br><div class="spoiler">  <b class="spoiler_title">失败文学撤退</b> <div class="spoiler_text"><blockquote> 响应加密在两天内完成。 航海家不想与Oto Velara分手，后者的公司制造出了惊人的快速而强大的军舰。 导航器不想向我读取加密。 他只是简单地从命令栏中重复响应：“否”。 加密不能解释为什么“不”。 无论如何，“否”表示他是大型计算机所认识的人。 如果对他一无所知，答案是肯定的：尝试一下。 太可惜了 失去这么有趣的人真可惜。 指挥官一定为我感到抱歉 也许第一次是可惜的。 他看到我闯入维京人。 他不想再把我逼入猎狗犬。 <br> 他保持沉默。 但是我知道在提供大量的工人短缺时： <br>  -我，同志，明天工作。 放开我 <br>  -继续  -突然她笑了。  “你知道，每一朵云都有一线希望。” <br>  “我，将军同志，总是生病没有好处。” <br>  “就在这里。” 你被禁止见他，这很糟糕。  <strong>但是，除了我们的经验宝藏外，我们还添加了另一种谷物。</strong> </blockquote></div></div><br><p> 结论： </p><br><ul><li> 在某些情况下，JDK方法的代码与实际执行无关，因为可以代替方法的主体而执行内部函数，该内部函数隐藏在VM的肠道中。 </li><li> 可以识别出此类方法，特别是<code>@HotSpotIntrinsicCandidate</code>标签指向它们，尽管某些方法被内化而没有任何提示，例如<code>String::equals</code> （以及<a href="">许多其他</a> ）。 </li><li> 从前两个得出的结论是，我们对JDK代码如何工作的讨论可能与现实相反。  Cestest vie </li></ul><br><p> 聚苯乙烯 <br> 另一种可能的替代方法： </p><br><pre> <code class="java hljs">StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); sb.append(str, <span class="hljs-number"><span class="hljs-number">0</span></span>, endIndex); <span class="hljs-comment"><span class="hljs-comment">// --&gt; StringBuilder sb = new StringBuilder(str.substring(o, endIndex));</span></span></code> </pre> <br><p>  PPS <br>  Oracle开发人员正确地指出 </p><br><blockquote> 在我看来，将代码路径引入 <br>  sb.append（cs，int，int）分配内存以便获得一个 <br> 只是有时候会使事情运行得更快。 如您所见，性能 <br> 权衡并不明显。 <br><br> 相反，如果我们要优化sb.append（cs，int，int），也许我们应该去 <br> 并通过添加或重新排列内在函数来做到这一点。 </blockquote><p> 提出的解决方案是<code>StringBuilder.append(CharSequence, int, int)</code>的内在化。 </p><br><p>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">讨论</a> </p><br><p>  <strong>PPS</strong> <br> 有趣的是，目前，当写类似 </p><br><pre> <code class="java hljs">StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); sb.append(str.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, endIndex));</code> </pre> <br><p>  “想法”建议将代码简化为 </p><br><pre> <code class="java hljs">StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); sb.append(s, <span class="hljs-number"><span class="hljs-number">0</span></span>, endIndex);</code> </pre> <br><p> 如果此位置的性能对您而言不是很重要，则使用第二个简化版本可能更正确。 尽管如此，我们编写的大多数代码是给我们的战友而不是机器的。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN436746/">https://habr.com/ru/post/zh-CN436746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN436726/index.html">用户报告称，由于聪明地窃取了Electrum钱包，导致比特币损失</a></li>
<li><a href="../zh-CN436738/index.html">再次预测，第2部分</a></li>
<li><a href="../zh-CN436740/index.html">自己的研究，开源能告诉我们什么？</a></li>
<li><a href="../zh-CN436742/index.html">直到2019年的Android机器人技术：真实的故事； 分5部分； 第一部分</a></li>
<li><a href="../zh-CN436744/index.html">使用Neural Compute Stick和OpenVINO在Raspberry Pi上启动神经网络检测器</a></li>
<li><a href="../zh-CN436748/index.html">从零开始开发六脚架（第3部分）-运动学</a></li>
<li><a href="../zh-CN436750/index.html">2018年俄罗斯YouTube趋势分析</a></li>
<li><a href="../zh-CN436752/index.html">蛋糕是骗人的</a></li>
<li><a href="../zh-CN436754/index.html">Q2VKPT：完全重写的Quake II，具有逼真的照明</a></li>
<li><a href="../zh-CN436756/index.html">同构急救</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>