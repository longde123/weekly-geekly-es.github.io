<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌿 🦗 👨🏻‍🍳 C ++编程中的问题 👐🏼 ⏰ 🧑🏽‍🤝‍🧑🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在C ++中，有许多功能可能被认为具有潜在的危险-由于设计错误或编码不正确，它们很容易导致错误。 本文提供了一些此类功能，并提供了有关如何减少其负面影响的提示。 
 

 目录 
 目录 

 引言 
 1.类型 
 1.1。 有条件的指令和运算符 
 1.2。 隐式转换 
 2.名称解析 
 2....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++编程中的问题</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428898/"><hr><p>  <i>在C ++中，有许多功能可能被认为具有潜在的危险-由于设计错误或编码不正确，它们很容易导致错误。</i>  <i>本文提供了一些此类功能，并提供了有关如何减少其负面影响的提示。</i> <i><br></i> </p><hr><br><a name="habracut"></a><br><h1> 目录 </h1><br><div class="spoiler">  <b class="spoiler_title">目录</b> <div class="spoiler_text"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">引言</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.类型</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.1。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有条件的指令和运算符</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.2。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">隐式转换</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.名称解析</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.1。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在嵌套作用域中隐藏变量</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.2。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">函数重载</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.构造函数，析构函数，初始化，删除</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.1。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">编译器生成的类成员函数</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.2。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">未初始化的变量</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.3。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">基类和非静态类成员的初始化过程</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.4。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">静态类成员和全局变量的初始化过程</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.5。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">析构函数中的异常</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.6。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">删除动态对象和数组</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.7。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">类声明不完整时删除</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.运算符，表达式</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.1。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">操作员优先</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.2。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">操作员超载</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.3。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">计算子表达式的过程</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">5.虚拟功能</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">5.1覆盖虚拟功能</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">5.2重载和使用默认参数</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">5.3在构造函数和析构函数中调用虚函数</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">5.4虚拟析构函数</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">6.直接使用内存</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">6.1缓冲区溢出</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">6.2 Z端接的琴弦</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">6.3参数数量可变的功能</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">7.语法</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">7.1复杂的公告</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">7.2语法歧义</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">8.杂项</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">8.1关键字内联和ODR</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">8.2头文件</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">8.3切换语句</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">8.4按值传递参数</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">8.5资源管理</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">8.6拥有和非拥有链接</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">8.7二进制兼容性</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">8.8巨集</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">9.总结</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">参考文献</a> <br></p><br></div></div><br><p>  <i>Praemonitus，praemunitus。</i> <i><br></i>  <i>预知意味着武装。</i>  <i>（晚）</i> <br></p><br><a name="id-introdaction"></a><br><h1> 引言 </h1><br><p> 在C ++中，有许多功能可能被认为具有潜在的危险-由于设计错误或编码不正确，它们很容易导致错误。 其中一些可以归因于童年的艰难，一些归因于过时的C ++ 98标准，但其他归因于现代C ++的功能。 考虑主要因素，并就如何减少其负面影响提出建议。 </p><br><a name="id-1"></a><br><h1>  1.类型 </h1><br><a name="id-1-1"></a><br><h2>  1.1。 有条件的指令和运算符 </h2><br><p>与C兼容性的需求导致这样的事实，即在<code>if(...)</code>之类的语句中，您可以替换任何数值表达式或指针，而不仅仅是<code>bool</code>表达式。 在<code>bool</code>表达式到<code>bool</code>表达式的隐式转换以及某些运算符的优先级使问题更加复杂。 例如，这导致以下错误： </p><br><p>  <code>if(a=b)</code>何时正确<code>if(a==b)</code> ， <br>  <code>if(a&lt;x&lt;b)</code> ，如果正确， <code>if(a&lt;x &amp;&amp; x&lt;b)</code> ， <br>  <code>if(a&amp;x==0)</code> ，如果正确， <code>if((a&amp;x)==0)</code> ， <br>  <code>if(Foo)</code>正确， <code>if(Foo())</code> ， <br>  <code>if(arr)</code>正确时<code>if(arr[0])</code> ， <br>  <code>if(strcmp(s,r))</code>正确时<code>if(strcmp(s,r)==0)</code> 。 </p><br><p> 其中一些错误会引起编译器警告，但不会导致错误。 代码分析器有时也可以提供帮助。 在C＃中，这样的错误几乎是不可能的， <code>if(...)</code>等需要<code>bool</code>类型，则不能在算术表达式中混合<code>bool</code>类型和数字类型。 </p><br><p> 怎么打： </p><br><ul><li> 程序无警告。 不幸的是，这并不总是有帮助；上述某些错误不会发出警告。 </li><li> 使用静态代码分析器。 </li><li> 老式的接收技术：与常量比较时，将其放在左侧，例如<code>if(MAX_PATH==x)</code> 。 它看起来很漂亮（甚至有自己的名字-“ Yoda符号”），并且在考虑的少数情况下有帮助。 </li><li> 尽可能广泛地使用<code>const</code>限定词。 同样，它并不总是有帮助。 </li><li> 习惯于编写正确的逻辑表达式： <code>if(x!=0)</code>而不是<code>if(x)</code> 。  （尽管您可以在此处陷入操作员优先级的陷阱，请参阅第三个示例。） </li><li> 非常专心。 </li></ul><br><a name="id-1-2"></a><br><h2>  1.2。 隐式转换 </h2><br><p>  C ++指的是强类型语言，但是隐式类型转换被广泛用于使代码更短。 这些隐式转换在某些情况下可能导致错误。 </p><br><p> 最烦人的隐式转换是数值类型或指针到<code>bool</code>以及从<code>bool</code>到<code>int</code> 。 这些转换（与C兼容所必需）导致了1.1节中描述的问题。 隐式转换（例如，从<code>double</code>精度到<code>int</code> ）可能会导致数值数据的准确性下降（缩小的转换）也不总是合适的。 在许多情况下，编译器会生成警告（特别是在数值数据的准确性可能会降低的情况下），但是警告不是错误。 在C＃中，禁止在数字类型和<code>bool</code>之间进行转换（甚至是显式的转换），并且可能导致数字数据精度下降的转换几乎总是错误。 </p><br><p> 程序员可以添加其他隐式转换：（1）使用一个参数而不使用<code>explicit</code>关键字定义一个构造函数；  （2）类型转换运算符的定义。 这些转换打破了基于强类型原则的其他安全漏洞。 </p><br><p> 在C＃中，内置隐式转换的数量要少得多；必须使用<code>implicit</code>关键字声明自定义的隐式转换。 </p><br><p> 怎么打： </p><br><ul><li> 程序无警告。 </li><li> 请特别注意上述设计，不要在没有极端需要的情况下使用它们。 </li></ul><br><a name="id-2"></a><br><h1>  2.名称解析 </h1><br><a name="id-2-1"></a><br><h2>  2.1。 在嵌套作用域中隐藏变量 </h2><br><p> 在C ++中，以下规则适用。 让 </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   {    int x;    // ... //  ,       {        int x;        // ...    } }</span></span></code> </pre> <br><p> 根据C ++规则， <code></code>声明的变量<code></code>隐藏<code></code>声明的变量<code></code> <code></code> 第一个声明<code>x</code>不必在块中：它可以是类的成员或全局变量，只需要在块<code></code>可见即可<code></code> </p><br><p> 现在想象一下当您需要重构以下代码时的情况 </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   {    int x;    // ... //  ,       {    // -         } }</span></span></code> </pre> <br><p> 错误地进行了更改： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   {    //  , :    int x;    // -         // ...    //  :    // -      }</span></span></code> </pre> <br><p> 现在，代码“正在用来自<code></code> <code></code>完成某件事”将对来自<code></code> <code></code>有所帮助！ 显然，一切都无法像以前那样工作，并且发现通常很难的东西。  C＃中禁止隐藏局部变量（尽管类成员可以）并不是徒劳的。 请注意，几乎所有编程语言都使用一种以另一种形式隐藏变量的机制。 </p><br><p> 怎么打： </p><br><ul><li> 在尽可能小的范围内声明变量。 </li><li> 不要写长而深的嵌套块。 </li><li> 使用编码约定在视觉上区分不同范围的标识符。 </li><li> 非常专心。 </li></ul><br><a name="id-2-2"></a><br><h2>  2.2。 函数重载 </h2><br><p> 函数重载是许多编程语言不可或缺的功能，C ++也不例外。 但是这个机会必须谨慎使用，否则会遇到麻烦。 在某些情况下，例如，当构造函数重载时，程序员别无选择，但在其他情况下，拒绝重载是合理的。 考虑使用重载函数时出现的问题。 </p><br><p> 如果尝试考虑解决过载时可能出现的所有可能选项，那么解决过载的规则就会变得非常复杂，因此很难预测。 模板功能和内置运算符的重载引入了更高的复杂性。  C ++ 11增加了右值链接和初始化列表的问题。 </p><br><p> 搜索算法可能会为候选人解决​​问题，以解决嵌套可见性区域中的过载问题。 如果编译器在当前范围内找到任何候选者，则进一步搜索终止。 如果找到的候选者不合适，冲突，被删除或无法访问，则会生成错误，但不会尝试进一步搜索。 并且只有在当前范围内没有候选者时，搜索才移至下一个更大的范围。 名称隐藏机制的工作原理与第2.1节中讨论的基本相同，请参见[Dewhurst]。 </p><br><p> 重载功能会降低代码的可读性，这会引发错误。 </p><br><p> 使用带有默认参数的函数看起来像使用重载函数，尽管当然，潜在问题更少。 但是可读性差和可能存在错误的问题仍然存在。 </p><br><p> 要格外小心，应使用虚拟函数的重载和默认参数，请参见第5.2节。 </p><br><p>  C＃还支持函数重载，但是解决重载的规则略有不同。 </p><br><p> 怎么打： </p><br><ul><li> 不要滥用函数重载，也不要滥用带有默认参数的函数。 </li><li> 如果函数被重载，则在解决重载时使用毫无疑问的签名。 </li><li> 不要在嵌套作用域中声明相同名称的函数。 </li><li> 不要忘记，C ++ 11中出现的远程函数机制（ <code>=delete</code> ）可用于禁止某些重载选项。 </li></ul><br><a name="id-3"></a><br><h1>  3.构造函数，析构函数，初始化，删除 </h1><br><a name="id-3-1"></a><br><h2>  3.1。 编译器生成的类成员函数 </h2><br><p> 如果程序员尚未从以下列表中定义该类的成员函数-默认构造函数，复制构造函数，复制赋值运算符，析构函数-则编译器可以为他执行此操作。  C ++ 11在此列表中添加了移动构造函数和移动赋值运算符。 这些成员函数称为特殊成员函数。 仅在使用它们并且满足每个功能特定的附加条件时才生成它们。 我们提请注意以下事实：这种用法可能被隐藏起来（例如，在实现继承时）。 如果无法生成所需的功能，则会生成错误。  （除重定位操作外，它们均由复制操作代替。）编译器生成的成员函数是公共的并且是可嵌入的。 特殊成员功能的详细信息可以在[Meyers2]中找到。 </p><br><p> 在某些情况下，来自编译器的此类帮助可能是“负担服务”。 缺少自定义特殊成员函数会导致创建琐碎的类型，而这又导致未初始化变量的问题，请参阅第3.2节。 生成的成员函数是公共的，并且这并不总是与类的设计一致。 在基类中，必须保护构造函数；有时，为了更好地控制对象的生命周期，需要一个受保护的析构函数。 如果类具有原始资源描述符作为成员并拥有此资源，则程序员需要实现一个复制构造函数，复制赋值运算符和析构函数。 所谓的“三巨头规则”是众所周知的，它指出，如果程序员定义了三个操作（复制构造函数，复制赋值运算符或析构函数）中的至少一个，则他必须定义所有三个操作。 编译器生成的move构造函数和move赋值运算符也不总是您所需要的。 在某些情况下，由编译器生成的析构函数会导致非常细微的问题，其结果可能是资源泄漏，请参见3.7节。 </p><br><p> 程序员可以禁止生成特殊的成员函数，在C ++ 11中声明时，必须使用<code>"=delete"</code>构造，在C ++ 98中，声明相应的成员函数为private而不定义。 </p><br><p> 如果程序员对编译器生成的成员函数感到满意，那么在C ++ 11中，他可以明确地指出这一点，而不仅仅是删除声明。 为此，在声明时必须使用<code>"=default"</code>构造，这样可以更好地阅读代码，并且出现与管理访问级别有关的其他功能。 </p><br><p> 在C＃中，编译器可以生成一个默认的构造函数，通常这不会引起任何问题。 </p><br><p> 怎么打： </p><br><ul><li> 控制编译器生成特殊的成员函数。 如有必要，请自己实施或禁止实施。 </li></ul><br><a name="id-3-2"></a><br><h2>  3.2。 未初始化的变量 </h2><br><p> 构造函数和析构函数可以称为C ++对象模型的关键元素。 创建对象时，必须调用构造函数，而在删除对象时，必须调用析构函数。 但是C的兼容性问题已经强制了一些异常，该异常称为琐碎类型。 引入它们是为了模拟sichny类型和变量的系统生命周期，而无需构造函数和析构函数的强制调用。  C代码如果在C ++中编译和执行，则应与C语言一样工作。普通类型包括数字类型，指针，枚举以及由普通类型组成的类，结构，联合和数组。 类和结构必须满足一些附加条件：缺少自定义构造函数，析构函数，复制，虚函数。 对于平凡的类，编译器可以生成默认的构造函数和析构函数。 默认构造函数将对象清零，析构函数不执行任何操作。 但是，只有在初始化变量时显式调用此构造函数时，才会生成和使用该构造函数。 如果您不使用显式初始化的某些变体，那么琐碎类型的变量将不会被初始化。 初始化语法取决于变量声明的类型和上下文。 声明时将初始化静态和局部变量。 对于类，直接基类和非静态类成员在构造函数初始化列表中初始化。  （C ++ 11允许您在声明时初始化非静态类成员，请参见下文。）对于动态对象，表达式<code>new T()</code>创建一个由默认构造函数初始化的对象，而对于普通类型的<code>new T</code>创建一个未初始化的对象。 创建简单类型的动态数组<code>new T[N]</code> ，其元素将始终未初始化。 如果创建或扩展了<code>std::vector&lt;T&gt;</code>的实例，并且未提供用于元素的显式初始化的参数，则可以保证它们调用默认构造函数。  C ++ 11引入了新的初始化语法-使用花括号。 一对空括号表示使用默认构造函数进行初始化。 在使用传统初始化的任何地方，这种初始化都是可能的，此外，在声明时可以初始化类的非静态成员，从而代替了构造函数初始化列表中的初始化。 </p><br><p> 未初始化的变量的结构如下：如果在<code>namespace</code>范围（全局）中定义，则所有位为零，如果是本地或动态创建，则将接收随机位。 显然，使用此类变量可能导致程序的行为无法预测。 </p><br><p> 没错，进展不会停滞不前，现代编译器在某些情况下会检测未初始化的变量并引发错误。 未初始化的代码分析器可以更好地检测。 </p><br><p>  C ++ 11标准库具有称为类型属性的模板（头文件<code>&lt;type_traits&gt;</code> ）。 其中之一可让您确定类型是否琐碎。 如果<code>T</code>琐碎的类型，则表达式<code>std::is_trivial&lt;&gt;::value</code>为<code>true</code>否则<code>T</code> <code>false</code> 。 </p><br><p> 收缩结构也通常称为普通旧数据（POD）。 我们可以假设POD和“琐碎的类型”几乎是等效的。 </p><br><p> 在C＃中，未初始化的变量会导致错误；这是由编译器控制的。 如果未执行显式初始化，则默认情况下将初始化引用类型的对象的字段。 重要类型的对象的字段默认情况下全部初始化，或者必须显式初始化所有字段。 </p><br><p> 怎么打： </p><br><ul><li> 养成显式初始化变量的习惯。 未初始化的变量应“吸引眼球”。 </li><li> 在尽可能小的范围内声明变量。 </li><li> 使用静态代码分析器。 </li><li> 不要设计琐碎的类型。 为了确保类型不是无关紧要的，定义一个自定义构造函数就足够了。 </li></ul><br><a name="id-3-3"></a><br><h2>  3.3。 基类和非静态类成员的初始化过程 </h2><br><p> 在实现类构造函数时，将初始化直接基类和非静态类成员。 初始化顺序由标准确定：首先按在基类列表中声明基类的顺序创建基类，然后按声明顺序依次声明该类的非静态成员。 如有必要，基类和非静态成员的显式初始化使用构造函数初始化列表。 不幸的是，该列表中的项目不需要按照初始化发生的顺序进行。 如果在初始化期间列表项使用对其他列表项的引用，则必须考虑到这一点。 错误时，链接可能指向尚未初始化的对象。  C ++ 11允许您在声明（使用花括号）时初始化非静态类成员。 在这种情况下，不需要在构造函数初始化列表中对其进行初始化，并且可以部分解决问题。 </p><br><p> 在C＃中，对象的初始化过程如下：首先对字段进行初始化，从基础子对象到最后一个派生对象，然后按相同顺序调用构造函数。 不会发生所描述的问题。 </p><br><p> 怎么打： </p><br><ul><li> 按声明顺序维护构造函数初始化列表。 </li><li> 尝试使基类和类成员的初始化独立。 </li><li> 声明时，请使用非静态成员的初始化。 </li></ul><br><a name="id-3-4"></a><br><h2>  3.4。 静态类成员和全局变量的初始化过程 </h2><br><p> 静态类成员以及在不同编译单元（文件）中的作用域<code>namespace</code> （全局）中定义的变量，将按实现确定的顺序进行初始化。 如果在初始化期间此类变量使用相互引用，则应考虑到这一点。 链接可能指向未初始化的变量。 </p><br><p> 怎么打： </p><br><ul><li> 采取特殊措施来防止这种情况。 例如，使用局部静态变量（单例），它们在首次使用时被初始化。 </li></ul><br><a name="id-3-5"></a><br><h2>  3.5。 析构函数中的异常 </h2><br><p> 析构函数不应引发异常。 如果违反此规则，则可能会出现不确定的行为，通常是异常终止。 </p><br><p> 怎么打： </p><br><ul><li> 避免在析构函数中引发异常。 </li></ul><br><a name="id-3-6"></a><br><h2>  3.6。 删除动态对象和数组 </h2><br><p> 如果<code>T</code>了某种类型<code>T</code>的动态对象 </p><br><pre> <code class="cpp hljs">T* pt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>);</code> </pre> <br><p> 然后使用<code>delete</code>运算符将其<code>delete</code> </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> pt;</code> </pre> <br><p> 如果创建了动态数组 </p><br><pre> <code class="cpp hljs">T* pt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T[N];</code> </pre> <br><p> 然后使用<code>delete[]</code>运算符将其<code>delete[]</code> </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[] pt;</code> </pre> <br><p> 如果不遵循此规则，则可能会得到未定义的行为，即可能发生任何事情：内存泄漏，崩溃等。 有关详细信息，请参见[Meyers1]。 </p><br><p> 怎么打： </p><br><ul><li> 使用正确的<code>delete</code>表格。 </li></ul><br><a name="id-3-7"></a><br><h2>  3.7。 类声明不完整时删除 </h2><br><p>  <code>delete</code>运算符的杂项性可能会导致某些问题；可以将其应用于<code>void*</code>类型的指针或具有不完整（抢先）声明的类的指针。 应用于类指针的<code>delete</code>运算符是两阶段操作；首先，调用析构函数，然后释放内存。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果将运算符应用于</font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有不完整声明的类的指针，则不会发生错误，编译器仅跳过对析构函数的调用（尽管会发出警告）。</font></font>考虑一个例子： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">//   X* CreateX(); void Foo() {    X* p = CreateX();    delete p; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">即使在Dial-peer上</font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有完整的类声明，</font><font style="vertical-align: inherit;">该代码也会编译</font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">Visual Studio显示以下警告：</font></font><br><p> <code>warning C4150: deletion of pointer to incomplete type 'X'; no destructor called</code> <br> </p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果有一个执行</font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>CreateX()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">随后的代码链接，如果该</font></font><code>CreateX()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数返回一个指针由运营商创建的对象</font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，调用</font></font><code>Foo()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">成功，析构函数没有被调用。</font><font style="vertical-align: inherit;">显然，这可能会导致资源的消耗，因此再次需要注意警告。</font></font></p><br><p>    ,           -.      ,  .       ,      ,   ,   ,   .        [Meyers2]. </p><br><p>  : </p><br><ul><li>   . </li><li>            . </li><li>     . </li></ul><br><a name="id-4"></a><br><h1> 4. ,  </h1><br><a name="id-4-1"></a><br><h2>  4.1。   </h2><br><p>   ++ ,     .      .       .   ,    1.1. </p><br><p> 这是一个例子： </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::out&lt;&lt;c?x:y;</code> </pre> <br><p>        </p><br><pre> <code class="cpp hljs">(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::out&lt;&lt;c)?x:y;</code> </pre> <br><p>   </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::out&lt;&lt;(c?x:y);</code> </pre> <br><p> ,  ,  . </p><br><p>         .            <code>&lt;&lt;</code>      <code>?:</code>      <code>std::out</code>  <code>void*</code> .  ++            ,     . -,          ,    .    <code>?:</code>      .       ,     (  ). </p><br><p>   :  <code>x&amp;f==0</code>    <code>x&amp;(f==0)</code> ,   <code>(x&amp;f)==0</code> , ,  ,  .     -  , ,     ,         ,   . </p><br><p>  . /          .  /    ,  /,    . ,     <code>x/4+1</code>  <code>x&gt;&gt;2+1</code> ,   <code>x&gt;&gt;(2+1)</code> ,   <code>(x&gt;&gt;2)+1</code> ,  . </p><br><p> C#      ,   C++,      ,    -      . </p><br><p>  : </p><br><ul><li>   ,     . , ,    . </li></ul><br><a name="id-4-2"></a><br><h2>  4.2。   </h2><br><p> ++     ,      .        .        ,          , .  4.1.    —    <code>+</code>  <code>+=</code>   .     . ,   : <code>,</code> (), <code>&amp;&amp;</code> , <code>||</code>  。   ,         (-),            (short-circuit evaluation semantics),        ,        .      &amp; ( ).     &amp;    , ..       . </p><br><p>        ,  -    (-) ,  .      . </p><br><p>  -  ,    ,    .  . [Dewhurst]. </p><br><p> C#    ,     , ,   . </p><br><p>  : </p><br><ul><li>    . </li><li>       . </li></ul><br><a name="id-4-3"></a><br><h2>  4.3。    </h2><br><p>   ++           ,         . (   : <code>,</code> (), <code>&amp;&amp;</code> , <code>||</code> , <code>?:</code> .)     ,  ,   ,    .    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y=(++x*<span class="hljs-number"><span class="hljs-number">2</span></span>)+(++x*<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br><p>  <code>y</code>     . </p><br><p>      ,        .  . </p><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Y</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;X&gt;, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Y&gt;)</span></span></span></span>;</code> </pre> <br><p>  <code>Foo()</code>   : </p><br><pre> <code class="cpp hljs">Foo(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;X&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X()), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Y&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Y()));</code> </pre> <br><p>     :  <code>X</code> ,  <code>Y</code> ,  <code>std::shared_ptr&lt;X&gt;</code> ,  <code>std::shared_ptr&lt;Y&gt;</code> .   <code>Y</code>  ,   <code>X</code>   . </p><br><p>     : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p1 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;X&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X()); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p2 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Y&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Y()); Foo(p1, p2);</code> </pre> <br><p>     <code>std::make_shared&lt;Y&gt;</code> (    ,     ): </p><br><pre> <code class="cpp hljs">Foo(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;X&gt;(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;Y&gt;());</code> </pre> <br><p>  . [Meyers2]. </p><br><p>  : </p><br><ul><li>    . </li></ul><br><a name="id-5"></a><br><h1> 5.   </h1><br><a name="id-5-1"></a><br><h2>  5.1。    </h2><br><p>  ++98  ,           ( ), ,     (     ,    ).      <code>virtual</code> ,   ,    .   ( ),   ,   ,     . ,     ,  .  ,  ++11    <code>override</code> ,    ,    ,       .          . </p><br><p>  : </p><br><ul><li>    <code>override</code> . </li><li>    .    ,         . </li></ul><br><a name="id-5-2"></a><br><h2>  5.2。       </h2><br><p>            .   ,              ,     .               .    . [Dewhurst]. </p><br><p>  : </p><br><ul><li>           . </li></ul><br><a name="id-5-3"></a><br><h2>  5.3。        </h2><br><p> ,     ,          . , ,     post_construct  pre_destroy. ,      —         .    .   ,        :     ( )   . (, ,      .)     ,           ( ),    ( ).  . [Dewhurst]. ,         ,  . </p><br><p>       —  -         . </p><br><p> ,   C#  ,     ,   ,     .  C#    :   ,      ,       .  ,           ( ,    ). </p><br><p>  : </p><br><ul><li>        ,     ,   . </li></ul><br><a name="id-5-4"></a><br><h2>  5.4。   </h2><br><p>     ,        ,           <code>delete</code>     .          , -    . </p><br><p>  : </p><br><ul><li>     . </li></ul><br><a name="id-6"></a><br><h1> 6.     </h1><br><p>        —      C/C++,        .           .        .     «  ». </p><br><p>  C#        unsafe mode,    . </p><br><a name="id-6-1"></a><br><h2> 6.1.     </h2><br><p>    /++  ,        : <code>strcpy()</code> , <code>strcat()</code> , <code>sprinf()</code> , etc.    ( <code>std::vector&lt;&gt;</code> , etc.)         ,    . (,         ,         ,     . . <strong>Checked Iterators</strong>  MSDN.)      ,      :   ,      ,     ;     ,      . </p><br><p>  C#,   unsafe mode,      . </p><br><p>  : </p><br><ul><li>    , . </li><li>     . </li><li>   z-terminated   ,    <code>_s</code> (.   ). </li></ul><br><a name="id-6-2"></a><br><h2> 6.2. Z-terminated  </h2><br><p>       ,  .    ,  : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">strncpy</span></span>(dst,src,n);</code> </pre> <br><p>  <code>strlen(src)&gt;=n</code> ,  <code>dst</code>     (,      ).      ,       , .  .       —       .   <code>if(*str)</code> ,  <code>if(strlen(str)&gt;0)</code> ,           .         [Spolsky]. </p><br><p>  C#  <code>string</code>      . </p><br><p>  : </p><br><ul><li>    . </li><li>     z-terminated   ,    <code>_s</code> (.   ). </li></ul><br><a name="id-6-3"></a><br><h2> 6.3.      </h2><br><p>    <code>...</code>    .      <code>printf</code> - ,     C.          , ,  ,     ,      .         ,       . </p><br><p>  C#    <code>printf</code> ,     . </p><br><p>  : </p><br><ul><li>     . ,  <code>printf</code> -    /. </li><li>   . </li></ul><br><a name="id-7"></a><br><h1> 7.  </h1><br><a name="id-7-1"></a><br><h2> 7.1.   </h2><br><p>  ++     , ,   ,        . 这是一个例子： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N = <span class="hljs-number"><span class="hljs-number">4</span></span>, M = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x,                <span class="hljs-comment"><span class="hljs-comment">// 1    *px,              // 2    ax[N],            // 3    *apx[N],          // 4    F(char),          // 5    *G(char),          // 6    (*pF)(char),      // 7    (*apF[N])(char),  // 8    (*pax)[N],        // 9    (*apax[M])[N],    // 10    (*H(char))(long);  // 11</span></span></code> </pre> <br><p>        : </p><br><ol><li>   <code>int</code> ; </li><li>   <code>int</code> ; </li><li>   <code>N</code>   <code>int</code> ; </li><li>   <code>N</code>     <code>int</code> ; </li><li> ,  <code>char</code>   <code>int</code> ; </li><li> ,  <code>char</code>     <code>int</code> ; </li><li>   ,  <code>char</code>   <code>int</code> ; </li><li>   <code>N</code>     ,  <code>char</code>   <code>int</code> ; </li><li>     <code>N</code>   <code>int</code> ; </li><li>   <code>M</code>       <code>N</code>   <code>int</code> ; </li><li> ,  <code>char</code>     ,  <code>long</code>   <code>int</code> . </li></ol><br><p> ,             . (     .) </p><br><p>     <code>*</code>    <code>&amp;</code>     . (    .) </p><br><p>        <code>typedef</code> ( <code>using</code> -). ,       : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*P)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; PH(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>);</code> </pre> <br><p>      ,     . </p><br><p>  C#    ,    . </p><br><p>  : </p><br><ul><li>   . </li></ul><br><a name="id-7-2"></a><br><h2> 7.2.   </h2><br><p>           .     </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val = <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>     </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">X </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre> <br><p>    <code>x</code>  <code>X</code> ,   5.    </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">X </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br><p>    <code>x</code> ,    <code>X</code>    ,     <code>x</code>  <code>X</code> ,    .     <code>X</code> ,    ,     : </p><br><pre> <code class="cpp hljs">X x; X x = X(); X x{};    <span class="hljs-comment"><span class="hljs-comment">//   C++11</span></span></code> </pre> <br><p>   ,    ,          ,   .         [Sutter]. </p><br><p>  ,  ,   C++     (      ).         . (    C++  .) </p><br><p>  , ,      ,       ,         . </p><br><p>  C#   ,         ,      . </p><br><p>  : </p><br><ul><li>    . </li></ul><br><a name="id-8"></a><br><h1> 8.  </h1><br><a name="id-8-1"></a><br><h2> 8.1.   <code>inline</code>  ODR </h2><br><p>   ,    <code>inline</code> —             .  ,     .   <code>inline</code>          (One Defenition Rule, ODR).  .            ,   .          ,  ODR.       <code>static</code> :    ,       ,   .   <code>static</code>  <code>inline</code> .      ,        ,  ODR,     . ,       .   - ,          -.         . </p><br><p>  : </p><br><ul><li>  «» <code>inline</code> .          <code>namespace</code> .      ,     . </li><li>        —  <code>namespace</code> . </li></ul><br><a name="id-8-2"></a><br><h2> 8.2.   </h2><br><p>        .        .    ,    ,     ,   ,      . </p><br><p>  : </p><br><ul><li>     ,     . </li><li>  ,     :  () ,    -. </li><li>            <code>using</code> -: <code>using namespace <i></i></code> ,   <code>using</code> -. </li><li>           . </li></ul><br><a name="id-8-3"></a><br><h2> 8.3.  <code>switch</code> <br></h2><br><p>   —  <code>break</code>    <code>case</code> . (  .)  C#     . </p><br><p>  : </p><br><ul><li>   . </li></ul><br><a name="id-8-4"></a><br><h2> 8.4.     </h2><br><p>  ++    ,      —     , —       .    (  <code>class</code>  <code>struct</code> )    ,         . (      ,      #  Java.)    —   ,     . </p><br><ol><li>      ,   .           (  <code>std::string</code> , <code>std::vector</code> , etc.),    ,           . </li><li>    ,        ,     . </li><li>          ,      (slicing),      ,       . </li></ol><br><p>     ,      ,  ,     .      . ,       ,         . ,          .           .    —     ( <code>=delete</code> ),   —     <code>explicit</code> . </p><br><p>  C#      ,           . </p><br><p>  : </p><br><ul><li>   ,     . </li><li>       . </li></ul><br><a name="id-8-5"></a><br><h2> 8.5. 资源管理 </h2><br><p>  ++         .     ,     . -       (    ),   ++11   ,        ,   ,           . </p><br><p>      C++   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> . </p><br><p>  C#   ,       .        ,     .        (using-)      Basic Dispose. </p><br><p>  : </p><br><ul><li>  -       . </li></ul><br><a name="id-8-6"></a><br><h2> 8.6.     </h2><br><p>     «»     .     ,  , C++ , STL-   - . </p><br><p>       .         .     ,        .      .        «»,      .          COM-      . (,    .)      ,    C++   .      —      .        .            .  ,      («»     )    ,      .        . </p><br><p>  #    ,     .     —    . </p><br><p>  : </p><br><ul><li>   . </li><li>        . </li></ul><br><a name="id-8-7"></a><br><h2> 8.7.   </h2><br><p>  C++      ,     :   ,    ,   . (     !)      .        ,      .     ,   .     ,   ,     . (,           .) </p><br><p>      C (    ),   C++       C  (   <code>extern "C"</code> ).      C/C++ . </p><br><p>          -.   <code>#pragma</code> -    ,    ,   . </p><br><p>        , ,    ,    . </p><br><p>     , ,    COM. COM-,    ,   (     ,      ).  COM     ,   ,     . </p><br><p>  C#     . ,   —    ,      C#,    C#  C/C++. </p><br><p>  : </p><br><ul><li>        . </li></ul><br><a name="id-8-8"></a><br><h2> 8.8.  </h2><br><p>        ,         .    ,       .  C++    . 相反 </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> XXL 32</span></span></code> </pre> <br><p>   </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> XXL=<span class="hljs-number"><span class="hljs-number">32</span></span>;</code> </pre> <br><p>   .       <code>inline</code>   . </p><br><p>  #   (   ). </p><br><p>  : </p><br><ul><li>       . </li></ul><br><a name="id-conclusion"></a><br><h1> 9.  </h1><br><ol><li>      .       .   .      ,       . </li><li>    . </li><li>    .   ++      — ++11/14/17. </li><li>   - ,  -   . </li><li>        . </li></ol><br><a name="id-refs"></a><br><h1> 参考文献 </h1><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><p> [Dewhurst] <br> ,  .   C++.         .: .  . — .:  , 2012. </p><br><p> [Meyers1] <br> , .   C++. 55        .: .  . — .:  , 2014. </p><br><p> [Meyers2] <br> , .    C++: 42    C++11  C++14.: .  . — .:  «.. », 2016. </p><br><p> [Sutter] <br> , .     C++.: .  . — :  «.. », 2015. </p><br><p> [Spolsky] <br> , .   .: .  . — .: -, 2008. </p><br></div></div><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN428898/">https://habr.com/ru/post/zh-CN428898/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN428888/index.html">QML：强大而简单</a></li>
<li><a href="../zh-CN428890/index.html">关于RTOS的全部真相。 第十八条 事件标志组：助手服务和数据结构</a></li>
<li><a href="../zh-CN428892/index.html">如何创建游戏AI：初学者指南</a></li>
<li><a href="../zh-CN428894/index.html">国内购买的增值税</a></li>
<li><a href="../zh-CN428896/index.html">无尽审查神经网络</a></li>
<li><a href="../zh-CN428900/index.html">轮式机器人开始向美国和英国居民运送货物</a></li>
<li><a href="../zh-CN428902/index.html">NFC无线标签</a></li>
<li><a href="../zh-CN428904/index.html">金融科技文摘：中央银行机器人，以太坊2.0，通过Rosfinmonitoring进行的加密货币控制和金融科技趋势</a></li>
<li><a href="../zh-CN428906/index.html">在拼图脚本上创建拼图游戏</a></li>
<li><a href="../zh-CN428908/index.html">寒霜朋克：拆解机制</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>