<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕵️ 💃🏼 👨‍👦 Erstellen von Karten aus Rauschfunktionen 💪🏻 🥀 🕓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einer der beliebtesten Artikel auf meiner Website befasst sich mit der Erstellung polygonaler Karten ( Übersetzung in Habré). Das Erstellen solcher Ka...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen von Karten aus Rauschfunktionen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430384/">  Einer der beliebtesten Artikel auf meiner Website befasst sich mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erstellung polygonaler Karten</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Übersetzung</a> in Habré).  Das Erstellen solcher Karten erfordert viel Aufwand.  Aber ich habe nicht damit begonnen, sondern mit einer <em>viel</em> einfacheren Aufgabe, die ich hier beschreiben werde.  Mit dieser einfachen Technik können Sie solche Karten in weniger als 50 Codezeilen erstellen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b16/95e/c42/b1695ec42f626197fddd201f7f40fa8a.png"></div><br>  Ich werde nicht erklären, wie man solche Karten zeichnet: Es hängt von der Sprache, der Grafikbibliothek, der Plattform usw. ab.  Ich werde nur erklären, wie <em>das Array</em> mit Kartendaten gefüllt wird. <br><br><h2>  Der Lärm </h2><br>  Eine Standardmethode zum Generieren von 2D-Karten besteht darin, Rauschen mit einem begrenzten Frequenzband als Baustein zu verwenden, z. B. Perlin-Rauschen oder Simplex-Rauschen.  So sieht die Rauschfunktion aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/855/159/49e/85515949e4c77ba82599050333ec79fa.png" alt="Bild"></div><br>  Wir weisen jedem Punkt auf der Karte eine Zahl von 0,0 bis 1,0 zu.  In diesem Bild ist 0.0 schwarz und 1.0 weiß. <a name="habracut"></a>  So legen Sie die Farbe jedes Rasterpunkts in der Syntax einer C-ähnlichen Sprache fest: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; height; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; width; x++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> nx = x/width - <span class="hljs-number"><span class="hljs-number">0.5</span></span>, ny = y/height - <span class="hljs-number"><span class="hljs-number">0.5</span></span>; value[y][x] = noise(nx, ny); } }</code> </pre> <br>  Die Schleife funktioniert genauso in Javascript, Python, Haxe, C ++, C #, Java und den meisten anderen gängigen Sprachen. Daher werde ich sie in einer C-ähnlichen Syntax anzeigen, damit Sie sie in die gewünschte Sprache konvertieren können.  Im Rest des Tutorials werde ich zeigen, wie sich der Zykluskörper ändert ( <code>value[y][x]=…</code> ), wenn neue Funktionen hinzugefügt werden.  Die Demo zeigt ein vollständiges Beispiel. <br><br>  In einigen Bibliotheken müssen die resultierenden Werte verschoben oder multipliziert werden, um sie im Bereich von 0,0 bis 1,0 zurückzugeben. <br><br><h2>  Höhe </h2><br>  Lärm an sich ist nur eine Sammlung von Zahlen.  Wir müssen ihm einen <em>Sinn geben</em> .  Das erste, woran Sie denken können, ist, den Rauschwert an die Höhe zu binden (dies wird als „Höhenkarte“ bezeichnet).  Nehmen wir das oben gezeigte Geräusch und zeichnen es als Höhen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/047/4bf/8d9/0474bf8d9dd73ad63fefc84140385f50.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b14/cb9/c53/b14cb9c535820e30c6eab79dda6322ec.png"></div><br>  Der Code blieb mit Ausnahme der inneren Schleife fast gleich.  Jetzt sieht es so aus: <br><br><pre> <code class="cpp hljs">elevation[y][x] = noise(nx, ny);</code> </pre> <br>  Ja, und das war's.  Die Kartendaten blieben gleich, aber jetzt werde ich sie <code>elevation</code> (Höhe) nennen, nicht <code>value</code> . <br><br>  Wir haben viele Hügel, aber nichts weiter.  Was ist los? <br><br><h3>  Frequenz </h3><br>  Rauschen kann mit jeder <em>Frequenz</em> erzeugt werden.  Bisher habe ich nur eine Frequenz gewählt.  Mal sehen, wie es sich auswirkt. <br><br>  <strong>Versuchen Sie, den Wert mit dem Schieberegler</strong> (im Originalartikel) zu <strong>ändern,</strong> und sehen Sie, was bei verschiedenen Frequenzen passiert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pu/ox/dh/puoxdhmnucu5e3miflqogwqddwq.gif"></div><br>  Es ändert nur die Skala.  Dies scheint zunächst nicht sehr nützlich zu sein, ist es aber nicht.  Ich habe noch ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tutorial</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Übersetzung</a> in Habré), das die <em>Theorie</em> erklärt: Konzepte wie Frequenz, Amplitude, Oktaven, rosa und blaues Rauschen und so weiter. <br><br><pre> <code class="cpp hljs">elevation[y][x] = noise(freq * nx, freq * ny);</code> </pre> <br>  Manchmal ist es auch nützlich, sich an die <em>Wellenlänge</em> zu erinnern, die der Kehrwert der Größe ist.  Wenn die Frequenz verdoppelt wird, wird die Größe nur halbiert.  Verdoppelung der Wellenlänge verdoppelt sich.  Die Wellenlänge ist die Entfernung, die in Pixel / Kacheln / Metern oder anderen Einheiten gemessen wird, die Sie für Karten ausgewählt haben.  Es hängt mit der Frequenz zusammen: <code>wavelength = map_size / frequency</code> . <br><br><h3>  Oktaven </h3><br>  Um die Höhenkarte interessanter zu gestalten, <em>fügen</em> wir <em>Rauschen mit unterschiedlichen Frequenzen hinzu</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dr/wt/uj/drwtujuho39t3uluoanf5vthl6o.png"></div><br><br><pre> <code class="cpp hljs">elevation[y][x] = <span class="hljs-number"><span class="hljs-number">1</span></span> * noise(<span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.5</span></span> * noise(<span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.25</span></span> * noise(<span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny);</code> </pre> <br>  Mischen wir große Niederfrequenzhügel mit kleinen Hochfrequenzhügeln in einer Karte.  <strong>Bewegen Sie den Schieberegler</strong> (im Originalartikel), um der Mischung kleine Hügel hinzuzufügen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/km/wh/bb/kmwhbbf29gwpdqcwtrbrnsighhw.gif"></div><br>  Jetzt ist es viel mehr wie das fraktale Relief, das wir brauchen!  Wir können Hügel und raue Berge bekommen, aber wir haben immer noch keine flachen Ebenen.  Dazu benötigen Sie etwas anderes. <br><br><h3>  Umverteilung </h3><br>  Die Rauschfunktion gibt Werte zwischen 0 und 1 an (oder von -1 bis +1, abhängig von der Bibliothek).  Um flache Ebenen zu schaffen, können wir <em>die Höhe auf eine Kraft erhöhen</em> .  <strong>Bewegen Sie den Schieberegler</strong> (im Originalartikel), um unterschiedliche Grade zu erhalten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3d/px/wc/3dpxwcatvtjknukqlih0hs7fecs.gif"></div><br><pre> <code class="cpp hljs">e = <span class="hljs-number"><span class="hljs-number">1</span></span> * noise(<span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.5</span></span> * noise(<span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.25</span></span> * noise(<span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny); elevation[y][x] = Math.<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(e, exponent);</code> </pre> <br>  Hohe Werte <em>senken die durchschnittliche Höhe in die Ebene</em> , und niedrige Werte erhöhen die durchschnittliche Höhe in Richtung Berggipfel.  Wir müssen sie weglassen.  Ich benutze Potenzfunktionen, weil sie einfacher sind, aber Sie können jede Kurve verwenden.  Ich habe eine kompliziertere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo</a> . <br><br>  Nachdem wir nun eine realistische Höhenkarte haben, fügen wir Biomes hinzu! <br><br><h2>  Biomes </h2><br>  Lärm gibt Zahlen, aber wir brauchen eine Karte mit Wäldern, Wüsten und Ozeanen.  Das erste, was Sie tun können, ist, kleine Höhen in Wasser zu verwandeln: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/et/hu/hv/ethuhvixmvjso_zt-_ev3gtu-tu.gif"></div><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">biome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; waterlevel) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WATER; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LAND; }</code> </pre> <br>  Wow, das wird schon wie eine prozedural erzeugte Welt!  Wir haben Wasser, Gras und Schnee.  Aber was ist, wenn wir mehr brauchen?  Machen wir eine Sequenz aus Wasser, Sand, Gras, Wald, Savanne, Wüste und Schnee: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5fd/aa0/237/5fdaa023713e487a95fed02484380d03.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/1d9/8b4/6561d98b4ceda31b7ff49ece890e4e83.png"></div><br>  <i>Erleichterung aufgrund der Höhe</i> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">biome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WATER; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BEACH; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FOREST; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> JUNGLE; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.7</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SAVANNAH; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.9</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DESERT; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SNOW; }</code> </pre> <br>  Wow, das sieht toll aus!  Für Ihr Spiel können Sie die Werte und Biomes ändern.  Crysis wird viel mehr Dschungel haben;  Skyrim hat viel mehr Eis und Schnee.  Unabhängig davon, wie Sie die Zahlen ändern, ist dieser Ansatz recht begrenzt.  Reliefarten entsprechen Höhen, bilden also Streifen.  Um sie interessanter zu machen, müssen wir Biome basierend auf etwas anderem auswählen.  Lassen Sie uns eine <em>zweite</em> Geräuschkarte für die Luftfeuchtigkeit erstellen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f4/1e3/de8/4f41e3de81e756ee9097be620ff5e08e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c7c/b6a/317/c7cb6a31702505881dbbf3d2ddb1244b.png"></div><br>  <i>Oben ist das Höhengeräusch;</i>  <i>Boden - Feuchtigkeitsgeräusch</i> <br><br>  Verwenden wir nun Höhe und Luftfeuchtigkeit <em>zusammen</em> .  Im ersten Bild unten ist die y-Achse die Höhe (aus dem obigen Bild) und die x-Achse die Luftfeuchtigkeit (das zweite Bild ist höher).  Dies gibt uns eine überzeugende Karte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e9/34c/6c1/0e934c6c1358e89adc1b8e4e11b4b21c.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ca/d11/e8e/3cad11e8edae614c2600342c37d6d4eb.png"></div><br>  <i>Entlastung basierend auf zwei Geräuschwerten</i> <br><br>  Kleine Höhen sind Ozeane und Küsten.  Große Höhen sind felsig und schneebedeckt.  Dazwischen erhalten wir eine breite Palette von Biomen.  Der Code sieht folgendermaßen aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">biome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e, m)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> OCEAN; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.12</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BEACH; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &gt; <span class="hljs-number"><span class="hljs-number">0.8</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SCORCHED; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BARE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TUNDRA; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SNOW; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &gt; <span class="hljs-number"><span class="hljs-number">0.6</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.33</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_DESERT; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.66</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SHRUBLAND; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TAIGA; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &gt; <span class="hljs-number"><span class="hljs-number">0.3</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.16</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_DESERT; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.50</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GRASSLAND; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.83</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_DECIDUOUS_FOREST; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_RAIN_FOREST; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.16</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUBTROPICAL_DESERT; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.33</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GRASSLAND; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.66</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TROPICAL_SEASONAL_FOREST; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TROPICAL_RAIN_FOREST; }</code> </pre> <br>  Bei Bedarf können Sie alle diese Werte entsprechend den Anforderungen Ihres Spiels ändern. <br><br>  Wenn wir keine Biome benötigen, können glatte Farbverläufe (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen Artikel</a> ) Farben erzeugen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd4/963/61d/bd496361d481367788a33ebece885cb6.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28e/799/58e/28e79958eb0b9990fa9e1978fa727def.png"></div><br>  Sowohl für Biome als auch für Gradienten bietet ein einzelner Rauschwert keine ausreichende Variabilität, aber zwei sind ausreichend. <br><br><h2>  Klima </h2><br>  Im vorherigen Abschnitt habe ich die <em>Höhe</em> als <em>Temperaturersatz verwendet</em> .  Je höher die Höhe, desto niedriger die Temperatur.  Der geografische Breitengrad beeinflusst jedoch auch die Temperaturen.  Verwenden wir sowohl Höhe als auch Breite, um die Temperatur zu steuern: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mr/fz/qn/mrfzqnq2ouo7zupt4kscz5a2gv8.png"></div><br>  In der Nähe der Pole (große Breiten) ist das Klima kälter, und auf den Gipfeln der Berge (große Höhen) ist das Klima auch kälter.  Bisher habe ich es nicht sehr schwer herausgearbeitet: Für die richtige Herangehensweise an diese Parameter benötigen Sie viele subtile Einstellungen. <br><br>  Es gibt auch <em>saisonalen</em> Klimawandel.  Im Sommer und Winter werden die nördlichen und südlichen Hemisphären wärmer und kälter, aber am Äquator ändert sich nicht viel.  Hier kann auch viel getan werden, zum Beispiel ist es möglich, die vorherrschenden Winde und Meeresströmungen, die Auswirkung von Biomes auf das Klima und die durchschnittliche Auswirkung von Ozeanen auf die Temperatur zu simulieren. <br><br><h2>  Die Inseln </h2><br>  In einigen Projekten brauchte ich die Ränder der Karte als Wasser.  Dies macht die Welt zu einer oder mehreren Inseln.  Es gibt viele Möglichkeiten, dies zu tun, aber ich habe in meinem Polygonkartengenerator eine ziemlich einfache Lösung verwendet: Ich habe die Höhe als <code>e = e + a - b*d^c</code> geändert, wobei <code>d</code> der Abstand vom Zentrum ist (auf einer Skala von 0-1).  Eine andere Möglichkeit besteht darin, <code>e = (e + a) * (1 - b*d^c)</code> zu ändern.  Die Konstante <code>a</code> erhöht alles nach oben, <code>b</code> senkt die Kanten nach unten und <code>c</code> steuert die Abnahmerate. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uq/gb/s4/uqgbs4h2ifsrwd2hsfvrrhue3ju.png"></div><br>  <em>Ich bin damit nicht ganz zufrieden</em> und es bleibt noch viel zu erforschen.  Sollte es Manhattan oder euklidische Entfernung sein?  Sollte es vom Abstand zum Zentrum oder vom Abstand zum Rand abhängen?  Sollte der Abstand quadratisch oder linear sein oder einen anderen Grad haben?  Sollte es Addition / Subtraktion oder Multiplikation / Division oder etwas anderes sein?  <b>Versuchen</b> Sie im Originalartikel Hinzufügen, a = 0,1, b = 0,3, c = 2,0 oder Multiplizieren, a = 0,05, b = 1,00, c = 1,5.  Welche Optionen zu Ihnen passen, hängt von Ihrem Projekt ab. <br><br>  Warum überhaupt an Standard-Mathematikfunktionen festhalten?  Wie ich in meinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel über Schäden in RPG</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Übersetzung</a> auf Habré) sagte, verwendet jeder (einschließlich ich) mathematische Funktionen wie Polynome, Exponentialverteilungen usw., aber auf dem Computer können wir nicht auf sie beschränkt sein.  Wir können <em>jede</em> Formationsfunktion verwenden und sie hier verwenden, indem wir die Nachschlagetabelle <code>e = e + height_adjust[d]</code> .  Bisher habe ich dieses Thema nicht untersucht. <br><br><h2>  Stacheliges Geräusch </h2><br>  Anstatt die Höhe auf eine Potenz zu erhöhen, können wir den absoluten Wert verwenden, um scharfe Spitzen zu erzeugen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ridgenoise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> * (<span class="hljs-number"><span class="hljs-number">0.5</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-number"><span class="hljs-number">0.5</span></span> - noise(nx, ny))); }</code> </pre> <br>  Um Oktaven hinzuzufügen, können wir die Amplituden hoher Frequenzen so variieren, dass nur Berge das zusätzliche Rauschen empfangen: <br><br><pre> <code class="cpp hljs">e0 = <span class="hljs-number"><span class="hljs-number">1</span></span> * ridgenoise(<span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny); e1 = <span class="hljs-number"><span class="hljs-number">0.5</span></span> * ridgenoise(<span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny) * e0; e2 = <span class="hljs-number"><span class="hljs-number">0.25</span></span> * ridgenoise(<span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny) * (e0+e1); e = e0 + e1 + e2; elevation[y][x] = Math.<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(e, exponent);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/co/ku/kg/cokukg_3lgom28_bnm3cu4u-4dc.gif"></div><br>  Ich habe nicht viel Erfahrung mit dieser Technik, daher muss ich experimentieren, um zu lernen, wie man sie gut benutzt.  Es kann auch interessant sein, stacheliges Niederfrequenzrauschen mit nicht stacheligem Hochfrequenzrauschen zu mischen. <br><br><h2>  Terrassen </h2><br>  Wenn wir die Höhe auf die nächsten n Ebenen runden, erhalten wir Terrassen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zv/bo/5k/zvbo5k_de80zv8utx6fxorpxfha.png"></div><br>  Dies ist das Ergebnis der Anwendung der Höhenumverteilungsfunktion in der Form <code>e = f(e)</code> .  Oben haben wir <code>e = Math.pow(e, exponent)</code> , um die Berggipfel zu schärfen.  hier verwenden wir <code>e = Math.round(e * n) / n</code> , um Terrassen zu erstellen.  Wenn Sie eine Nicht-Stufen-Funktion verwenden, können die Terrassen abgerundet sein oder nur in bestimmten Höhen auftreten. <br><br><h2>  Baumplatzierung </h2><br>  Normalerweise haben wir fraktales Rauschen für Höhe und Luftfeuchtigkeit verwendet, aber es kann auch verwendet werden, um ungleichmäßig verteilte Objekte wie Bäume und Steine ​​zu platzieren.  Für die Höhe verwenden wir hohe Amplituden mit niedrigen Frequenzen („rotes Rauschen“).  Um Objekte zu platzieren, müssen Sie hohe Amplituden mit hohen Frequenzen verwenden ("blaues Rauschen").  Links ist ein blaues Rauschmuster;  Auf der rechten Seite befinden sich Stellen, an denen das Rauschen größer ist als benachbarte Werte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xo/u4/ze/xou4zen4vzp46h3l7ecmcmdqsda.png"></div><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> yc = <span class="hljs-number"><span class="hljs-number">0</span></span>; yc &lt; height; yc++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xc = <span class="hljs-number"><span class="hljs-number">0</span></span>; xc &lt; width; xc++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> max = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     for (int yn = yc - R; yn &lt;= yc + R; yn++) { for (int xn = xc - R; xn &lt;= xc + R; xn++) { double e = value[yn][xn]; if (e &gt; max) { max = e; } } } if (value[yc][xc] == max) { //    xc,yc } } }</span></span></code> </pre> <br>  Wenn wir für jedes Biom ein anderes R wählen, können wir eine variable Baumdichte erhalten: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/764/e0e/32a/764e0e32ac9171654161a94a29f66118.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa1/940/61f/aa194061fd97796c08238123b57199c7.png"></div><br>  Es ist großartig, dass solches Rauschen zum Platzieren von Bäumen verwendet werden kann, aber andere Algorithmen sind oft effektiver und sorgen für eine gleichmäßigere Verteilung: Poisson-Spots, Van-Kacheln oder grafisches Dithering. <br><br><h2>  Bis ins Unendliche und darüber hinaus </h2><br>  Die Berechnungen des Bioms an der Position (x, y) sind unabhängig von den Berechnungen aller anderen Positionen.  Diese <strong>lokale Berechnung</strong> hat zwei praktische Eigenschaften: Sie kann parallel berechnet und für endloses Gelände verwendet werden.  <strong>Platzieren Sie den Mauszeiger auf der Minikarte</strong> (im Originalartikel) links, um die Karte rechts zu <strong>erstellen</strong> .  Sie können einen beliebigen Teil der Karte generieren, ohne die gesamte Karte zu generieren (und sogar ohne sie zu speichern). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/98b/932/152/98b932152f6c24f496034283fa904499.png"><img src="https://habrastorage.org/getpro/habr/post_images/6a5/811/c84/6a5811c84c56c1706aedbc505fc32aa9.png"><br><br><h2>  Implementierung </h2><br>  Die Verwendung von Lärm zur Erzeugung von Gelände ist eine beliebte Lösung. Im Internet finden Sie Tutorials für viele verschiedene Sprachen und Plattformen.  Der Code zum Generieren von Karten in verschiedenen Sprachen ist ungefähr gleich.  Hier ist die einfachste Schleife in drei verschiedenen Sprachen: <br><br><ul><li>  <b>Javascript:</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gen = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimplexNoise(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">nx, ny</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Rescale from -1.0:+1.0 to 0.0:1.0 return gen.noise2D(nx, ny) / 2 + 0.5; } let value = []; for (let y = 0; y &lt; height; y++) { value[y] = []; for (let x = 0; x &lt; width; x++) { let nx = x/width - 0.5, ny = y/height - 0.5; value[y][x] = noise(nx, ny); } }</span></span></code> </pre> </li><li>  <b>C ++:</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::Perlin gen; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Rescale from -1.0:+1.0 to 0.0:1.0 return gen.GetValue(nx, ny, 0) / 2.0 + 0.5; } double value[height][width]; for (int y = 0; y &lt; height; y++) { for (int x = 0; x &lt; width; x++) { double nx = x/width - 0.5, ny = y/height - 0.5; value[y][x] = noise(nx, ny); } }</span></span></code> </pre> </li><li>  <b>Python:</b> <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> opensimplex <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> OpenSimplex gen = OpenSimplex() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Rescale from -1.0:+1.0 to 0.0:1.0 return gen.noise2d(nx, ny) / 2.0 + 0.5 value = [] for y in range(height): value.append([0] * width) for x in range(width): nx = x/width - 0.5 ny = y/height - 0.5 value[y][x] = noise(nx, ny)</span></span></code> </pre> </li></ul><br>  Alle Rauschbibliotheken sind ziemlich ähnlich.  Versuchen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenSimplex für Python</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Libnoise für C ++</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Simplex-Noise</a> für Javascript.  Für die meisten gängigen Sprachen gibt es viele Rauschbibliotheken.  Oder Sie können lernen, wie Perlin-Rauschen funktioniert, oder das Rauschen selbst realisieren.  <em>Ich habe es nicht getan.</em> <br><br>  In verschiedenen Rauschbibliotheken für Ihre Sprache können die Anwendungsdetails geringfügig variieren (einige Rückgabewerte liegen im Bereich von 0,0 bis 1,0, andere im Bereich von -1,0 bis +1,0), aber die Grundidee ist dieselbe.  Für ein reales Projekt müssen Sie möglicherweise die <code>noise</code> und das <code>gen</code> Objekt in eine Klasse <code>gen</code> , aber diese Details sind irrelevant, daher habe ich sie global gemacht. <br><br>  Für ein so einfaches Projekt spielt es keine Rolle, welches Rauschen Sie verwenden: Perlin-Rauschen, Simplex-Rauschen, OpenSimplex-Rauschen, Wertrauschen, Mittelpunktversatz, Diamantalgorithmus oder die inverse Fourier-Transformation.  Jeder von ihnen hat seine Vor- und Nachteile, aber für einen ähnlichen Kartengenerator erzeugen alle mehr oder weniger die gleichen Ausgabewerte. <br><br>  <em>Das Rendern der</em> Karte hängt von der Plattform und dem Spiel ab, daher habe ich sie nicht implementiert.  Dieser Code wird nur benötigt, um Höhen und Biomes zu generieren, deren Darstellung vom im Spiel verwendeten Stil abhängt.  Sie können es kopieren, portieren und in Ihren Projekten verwenden. <br><br><h2>  Die Experimente </h2><br>  Ich habe mir überlegt, wie man Oktaven mischt, Grad zu einer Potenz erhöht und Höhen mit Feuchtigkeit kombiniert, um ein Biom zu erzeugen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier können</a> Sie ein interaktives Diagramm studieren, mit dem Sie mit all diesen Parametern experimentieren können. Es zeigt, woraus der Code besteht: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lh/yq/xn/lhyqxnbeaj0friycenleop7mcdw.png"></div><br>  Hier ist ein Beispielcode: <br><br><pre> <code class="cpp hljs">var rng1 = PM_PRNG.create(seed1); var rng2 = PM_PRNG.create(seed2); var gen1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimplexNoise(rng1.nextDouble.bind(rng1)); var gen2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimplexNoise(rng2.nextDouble.bind(rng2)); <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gen1.noise2D(nx, ny)/<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gen2.noise2D(nx, ny)/<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; height; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; width; x++) { var nx = x/width - <span class="hljs-number"><span class="hljs-number">0.5</span></span>, ny = y/height - <span class="hljs-number"><span class="hljs-number">0.5</span></span>; var e = (<span class="hljs-number"><span class="hljs-number">1.00</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.50</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.25</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.13</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">8</span></span> * nx, <span class="hljs-number"><span class="hljs-number">8</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.06</span></span> * noise1(<span class="hljs-number"><span class="hljs-number">16</span></span> * nx, <span class="hljs-number"><span class="hljs-number">16</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.03</span></span> * noise1(<span class="hljs-number"><span class="hljs-number">32</span></span> * nx, <span class="hljs-number"><span class="hljs-number">32</span></span> * ny)); e /= (<span class="hljs-number"><span class="hljs-number">1.00</span></span>+<span class="hljs-number"><span class="hljs-number">0.50</span></span>+<span class="hljs-number"><span class="hljs-number">0.25</span></span>+<span class="hljs-number"><span class="hljs-number">0.13</span></span>+<span class="hljs-number"><span class="hljs-number">0.06</span></span>+<span class="hljs-number"><span class="hljs-number">0.03</span></span>); e = Math.<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(e, <span class="hljs-number"><span class="hljs-number">5.00</span></span>); var m = (<span class="hljs-number"><span class="hljs-number">1.00</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.75</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.33</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.33</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">8</span></span> * nx, <span class="hljs-number"><span class="hljs-number">8</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.33</span></span> * noise2(<span class="hljs-number"><span class="hljs-number">16</span></span> * nx, <span class="hljs-number"><span class="hljs-number">16</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.50</span></span> * noise2(<span class="hljs-number"><span class="hljs-number">32</span></span> * nx, <span class="hljs-number"><span class="hljs-number">32</span></span> * ny)); m /= (<span class="hljs-number"><span class="hljs-number">1.00</span></span>+<span class="hljs-number"><span class="hljs-number">0.75</span></span>+<span class="hljs-number"><span class="hljs-number">0.33</span></span>+<span class="hljs-number"><span class="hljs-number">0.33</span></span>+<span class="hljs-number"><span class="hljs-number">0.33</span></span>+<span class="hljs-number"><span class="hljs-number">0.50</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* draw biome(e, m) at x,y */</span></span> } }</code> </pre> <br>  Es gibt eine Schwierigkeit: Für Höhen- und Feuchtigkeitsgeräusche muss ein anderes Saatgut verwendet werden, da es sich sonst als gleich herausstellt und die Karten nicht so interessant aussehen.  In Javascript verwende ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Prng-Parkmiller-Bibliothek</a> .  In C ++ können Sie zwei separate <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Objekte linear_congruential_engine verwenden</a> .  In Python können Sie zwei separate Instanzen einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">random.Random-Klasse erstellen</a> . <br><br><h2>  Gedanken </h2><br>  Ich mag diesen Ansatz zur Kartengenerierung wegen seiner <b>Einfachheit</b> .  Es ist schnell und erfordert sehr wenig Code, um anständige Ergebnisse zu erzielen. <br><br>  Ich mag seine Grenzen in diesem Ansatz nicht.  Lokale Berechnungen bedeuten, dass jeder Punkt unabhängig von allen anderen ist.  Verschiedene Bereiche der Karte sind <em>nicht miteinander verbunden</em> .  Jeder Ort auf der Karte „scheint“ gleich zu sein.  Es gibt keine globalen Einschränkungen, z. B. "Es sollten 3 bis 5 Seen auf der Karte sein" oder globale Merkmale wie einen Fluss, der von der Spitze des höchsten Gipfels in den Ozean fließt.  Ich mag auch nicht die Tatsache, dass Sie die Parameter für eine lange Zeit konfigurieren müssen, um ein gutes Bild zu erhalten. <br><br>  Warum empfehle ich es?  Ich denke, dies ist ein guter Ausgangspunkt, insbesondere für Indie-Spiele und Game-Jams.  Zwei meiner Freunde haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in</a> nur 30 Tagen die erste Version von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Realm of the Mad God</a> für einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spielewettbewerb geschrieben</a> .  Sie baten mich, beim Erstellen von Karten zu helfen.  Ich habe diese Technik verwendet (plus ein paar weitere Funktionen, die sich als nicht sehr nützlich erwiesen haben) und eine Karte für sie erstellt.  Einige Monate später, nachdem wir Feedback von den Spielern erhalten und das Design des Spiels sorgfältig studiert hatten, erstellten wir einen fortschrittlicheren Kartengenerator auf der Basis der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> beschriebenen Voronoi-Polygone ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Übersetzung</a> in Habré).  Dieser Kartengenerator verwendet nicht die in diesem Artikel beschriebenen Techniken.  Es verwendet Rauschen, um Karten auf ganz andere Weise zu erstellen. <br><br><h2>  Weitere Informationen </h2><br>  Es gibt <em>viele</em> coole Dinge, die Sie mit Rauschfunktionen tun können.  Wenn Sie im Internet suchen, finden Sie Optionen wie Turbulenzen, Wogen, geriffelte Multifraktale, Amplitudendämpfung, Terrassen-, Voronoi-Rauschen, analytische Derivate, Domain Warping und andere.  Sie können <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese Seite</a> als Inspirationsquelle verwenden.  Ich betrachte sie hier nicht, mein Artikel konzentriert sich auf Einfachheit. <br><br>  Dieses Projekt wurde von meinen vorherigen Kartengenerierungsprojekten beeinflusst: <br><br><ul><li>  Ich habe Perlins Gesamtrauschen für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meinen ersten Realm of the Mad God-Kartengenerator verwendet</a> .  Wir haben es in den ersten sechs Monaten des Alpha-Tests verwendet und es dann durch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Kartengenerator für Voronoi-Polygone ersetzt</a> , der speziell für die Gameplay-Anforderungen entwickelt wurde, die wir während des Alpha-Tests ermittelt haben.  Biomes und ihre Farben für den Artikel stammen aus diesen Projekten. </li><li>  Beim Studium der Verarbeitung von Audiosignalen habe ich ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rausch-Tutorial geschrieben</a> , in dem Konzepte wie Frequenz, Amplitude, Oktaven und die „Farbe“ des Rauschens erläutert werden.  Die gleichen Konzepte, die für Sound gelten, gelten auch für die rauschbasierte Kartenerzeugung.  Zu dieser Zeit habe ich eine rohe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo-Relief-Generation erstellt</a> , aber ich habe sie nicht fertiggestellt. </li><li>  Manchmal experimentiere ich, um Grenzen zu finden.  Ich wollte wissen, wie viel Code minimal benötigt wird, um überzeugende Karten zu erstellen.  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Miniprojekt habe</a> ich <b>null</b> Codezeilen erreicht - alles wird mit Bildfiltern (Turbulenzen, Schwellenwerte, Farbverläufe) gemacht.  Das hat mich glücklich und traurig gemacht.  Inwieweit kann die Kartenerzeugung durch Bildfilter durchgeführt werden?  In groß genug.  Alles, was oben über das "Schema glatter Farbverläufe" beschrieben wurde, stammt aus diesem Experiment.  Die Rauschschicht ist ein Turbulenzbildfilter;  Oktaven sind einander überlagerte Bilder;  Das Grad-Werkzeug wird in Photoshop als „Kurvenkorrektur“ bezeichnet. </li></ul><br>  Was mich ein bisschen stört, ist, dass der größte Teil des Codes, den Spieleentwickler für die rauschbasierte Geländegenerierung (einschließlich der Verschiebung des Mittelpunkts) schreiben, der gleiche ist wie bei Ton- und Bildfiltern.  Auf der anderen Seite werden in nur wenigen Codezeilen recht anständige Ergebnisse erzielt, weshalb ich diesen Artikel geschrieben habe.  Dies ist ein <em>schneller und einfacher Bezugspunkt</em> .  Normalerweise benutze ich solche Karten nicht lange, sondern ersetze sie durch einen komplexeren Kartengenerator, sobald ich herausfinde, welche Kartentypen besser für das Design des Spiels geeignet sind.  Für mich ist dies ein Standardmuster: Beginnen Sie mit etwas extrem Einfachem und ersetzen Sie es erst, nachdem ich das System, mit dem ich arbeite, besser verstanden habe. <br><br>  Es gibt noch <em>viel</em> mehr Dinge, die mit Lärm gemacht werden können, in dem Artikel habe ich nur einige erwähnt.  Probieren Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Noise Studio aus</a> , um verschiedene Funktionen interaktiv zu testen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430384/">https://habr.com/ru/post/de430384/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430374/index.html">Data Engineering und mehr: Wrike-Videobänder und -Dias aus dem Meeting</a></li>
<li><a href="../de430376/index.html">JavaScript-Handbuch Teil 6: Ausnahmen, Semikolons, Vorlagenliterale</a></li>
<li><a href="../de430378/index.html">J2CL - Besser spät als nie</a></li>
<li><a href="../de430380/index.html">JavaScript-Handbuch Teil 5: Arrays und Loops</a></li>
<li><a href="../de430382/index.html">JavaScript-Handbuch Teil 4: Funktionen</a></li>
<li><a href="../de430386/index.html">Festkörperspeicherkraftwerk in Indien gebaut werden</a></li>
<li><a href="../de430388/index.html">Web Summit Unconference</a></li>
<li><a href="../de430392/index.html">Wie ich APIs mit meinem PieceofScript-Fahrrad entwickle und teste</a></li>
<li><a href="../de430394/index.html">Implementierung der Sofort-Suche in Android mit RxJava</a></li>
<li><a href="../de430396/index.html">Kettenreplikation: Aufbau eines effektiven KV-Repositorys (Teil 1/2)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>