<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïµÔ∏è üíÉüèº üë®‚Äçüë¶ Erstellen von Karten aus Rauschfunktionen üí™üèª ü•Ä üïì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einer der beliebtesten Artikel auf meiner Website befasst sich mit der Erstellung polygonaler Karten ( √úbersetzung in Habr√©). Das Erstellen solcher Ka...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen von Karten aus Rauschfunktionen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430384/">  Einer der beliebtesten Artikel auf meiner Website befasst sich mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erstellung polygonaler Karten</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úbersetzung</a> in Habr√©).  Das Erstellen solcher Karten erfordert viel Aufwand.  Aber ich habe nicht damit begonnen, sondern mit einer <em>viel</em> einfacheren Aufgabe, die ich hier beschreiben werde.  Mit dieser einfachen Technik k√∂nnen Sie solche Karten in weniger als 50 Codezeilen erstellen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b16/95e/c42/b1695ec42f626197fddd201f7f40fa8a.png"></div><br>  Ich werde nicht erkl√§ren, wie man solche Karten zeichnet: Es h√§ngt von der Sprache, der Grafikbibliothek, der Plattform usw. ab.  Ich werde nur erkl√§ren, wie <em>das Array</em> mit Kartendaten gef√ºllt wird. <br><br><h2>  Der L√§rm </h2><br>  Eine Standardmethode zum Generieren von 2D-Karten besteht darin, Rauschen mit einem begrenzten Frequenzband als Baustein zu verwenden, z. B. Perlin-Rauschen oder Simplex-Rauschen.  So sieht die Rauschfunktion aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/855/159/49e/85515949e4c77ba82599050333ec79fa.png" alt="Bild"></div><br>  Wir weisen jedem Punkt auf der Karte eine Zahl von 0,0 bis 1,0 zu.  In diesem Bild ist 0.0 schwarz und 1.0 wei√ü. <a name="habracut"></a>  So legen Sie die Farbe jedes Rasterpunkts in der Syntax einer C-√§hnlichen Sprache fest: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; height; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; width; x++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> nx = x/width - <span class="hljs-number"><span class="hljs-number">0.5</span></span>, ny = y/height - <span class="hljs-number"><span class="hljs-number">0.5</span></span>; value[y][x] = noise(nx, ny); } }</code> </pre> <br>  Die Schleife funktioniert genauso in Javascript, Python, Haxe, C ++, C #, Java und den meisten anderen g√§ngigen Sprachen. Daher werde ich sie in einer C-√§hnlichen Syntax anzeigen, damit Sie sie in die gew√ºnschte Sprache konvertieren k√∂nnen.  Im Rest des Tutorials werde ich zeigen, wie sich der Zyklusk√∂rper √§ndert ( <code>value[y][x]=‚Ä¶</code> ), wenn neue Funktionen hinzugef√ºgt werden.  Die Demo zeigt ein vollst√§ndiges Beispiel. <br><br>  In einigen Bibliotheken m√ºssen die resultierenden Werte verschoben oder multipliziert werden, um sie im Bereich von 0,0 bis 1,0 zur√ºckzugeben. <br><br><h2>  H√∂he </h2><br>  L√§rm an sich ist nur eine Sammlung von Zahlen.  Wir m√ºssen ihm einen <em>Sinn geben</em> .  Das erste, woran Sie denken k√∂nnen, ist, den Rauschwert an die H√∂he zu binden (dies wird als ‚ÄûH√∂henkarte‚Äú bezeichnet).  Nehmen wir das oben gezeigte Ger√§usch und zeichnen es als H√∂hen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/047/4bf/8d9/0474bf8d9dd73ad63fefc84140385f50.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b14/cb9/c53/b14cb9c535820e30c6eab79dda6322ec.png"></div><br>  Der Code blieb mit Ausnahme der inneren Schleife fast gleich.  Jetzt sieht es so aus: <br><br><pre> <code class="cpp hljs">elevation[y][x] = noise(nx, ny);</code> </pre> <br>  Ja, und das war's.  Die Kartendaten blieben gleich, aber jetzt werde ich sie <code>elevation</code> (H√∂he) nennen, nicht <code>value</code> . <br><br>  Wir haben viele H√ºgel, aber nichts weiter.  Was ist los? <br><br><h3>  Frequenz </h3><br>  Rauschen kann mit jeder <em>Frequenz</em> erzeugt werden.  Bisher habe ich nur eine Frequenz gew√§hlt.  Mal sehen, wie es sich auswirkt. <br><br>  <strong>Versuchen Sie, den Wert mit dem Schieberegler</strong> (im Originalartikel) zu <strong>√§ndern,</strong> und sehen Sie, was bei verschiedenen Frequenzen passiert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pu/ox/dh/puoxdhmnucu5e3miflqogwqddwq.gif"></div><br>  Es √§ndert nur die Skala.  Dies scheint zun√§chst nicht sehr n√ºtzlich zu sein, ist es aber nicht.  Ich habe noch ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tutorial</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úbersetzung</a> in Habr√©), das die <em>Theorie</em> erkl√§rt: Konzepte wie Frequenz, Amplitude, Oktaven, rosa und blaues Rauschen und so weiter. <br><br><pre> <code class="cpp hljs">elevation[y][x] = noise(freq * nx, freq * ny);</code> </pre> <br>  Manchmal ist es auch n√ºtzlich, sich an die <em>Wellenl√§nge</em> zu erinnern, die der Kehrwert der Gr√∂√üe ist.  Wenn die Frequenz verdoppelt wird, wird die Gr√∂√üe nur halbiert.  Verdoppelung der Wellenl√§nge verdoppelt sich.  Die Wellenl√§nge ist die Entfernung, die in Pixel / Kacheln / Metern oder anderen Einheiten gemessen wird, die Sie f√ºr Karten ausgew√§hlt haben.  Es h√§ngt mit der Frequenz zusammen: <code>wavelength = map_size / frequency</code> . <br><br><h3>  Oktaven </h3><br>  Um die H√∂henkarte interessanter zu gestalten, <em>f√ºgen</em> wir <em>Rauschen mit unterschiedlichen Frequenzen hinzu</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dr/wt/uj/drwtujuho39t3uluoanf5vthl6o.png"></div><br><br><pre> <code class="cpp hljs">elevation[y][x] = <span class="hljs-number"><span class="hljs-number">1</span></span> * noise(<span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.5</span></span> * noise(<span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.25</span></span> * noise(<span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny);</code> </pre> <br>  Mischen wir gro√üe Niederfrequenzh√ºgel mit kleinen Hochfrequenzh√ºgeln in einer Karte.  <strong>Bewegen Sie den Schieberegler</strong> (im Originalartikel), um der Mischung kleine H√ºgel hinzuzuf√ºgen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/km/wh/bb/kmwhbbf29gwpdqcwtrbrnsighhw.gif"></div><br>  Jetzt ist es viel mehr wie das fraktale Relief, das wir brauchen!  Wir k√∂nnen H√ºgel und raue Berge bekommen, aber wir haben immer noch keine flachen Ebenen.  Dazu ben√∂tigen Sie etwas anderes. <br><br><h3>  Umverteilung </h3><br>  Die Rauschfunktion gibt Werte zwischen 0 und 1 an (oder von -1 bis +1, abh√§ngig von der Bibliothek).  Um flache Ebenen zu schaffen, k√∂nnen wir <em>die H√∂he auf eine Kraft erh√∂hen</em> .  <strong>Bewegen Sie den Schieberegler</strong> (im Originalartikel), um unterschiedliche Grade zu erhalten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3d/px/wc/3dpxwcatvtjknukqlih0hs7fecs.gif"></div><br><pre> <code class="cpp hljs">e = <span class="hljs-number"><span class="hljs-number">1</span></span> * noise(<span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.5</span></span> * noise(<span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.25</span></span> * noise(<span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny); elevation[y][x] = Math.<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(e, exponent);</code> </pre> <br>  Hohe Werte <em>senken die durchschnittliche H√∂he in die Ebene</em> , und niedrige Werte erh√∂hen die durchschnittliche H√∂he in Richtung Berggipfel.  Wir m√ºssen sie weglassen.  Ich benutze Potenzfunktionen, weil sie einfacher sind, aber Sie k√∂nnen jede Kurve verwenden.  Ich habe eine kompliziertere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo</a> . <br><br>  Nachdem wir nun eine realistische H√∂henkarte haben, f√ºgen wir Biomes hinzu! <br><br><h2>  Biomes </h2><br>  L√§rm gibt Zahlen, aber wir brauchen eine Karte mit W√§ldern, W√ºsten und Ozeanen.  Das erste, was Sie tun k√∂nnen, ist, kleine H√∂hen in Wasser zu verwandeln: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/et/hu/hv/ethuhvixmvjso_zt-_ev3gtu-tu.gif"></div><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">biome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; waterlevel) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WATER; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LAND; }</code> </pre> <br>  Wow, das wird schon wie eine prozedural erzeugte Welt!  Wir haben Wasser, Gras und Schnee.  Aber was ist, wenn wir mehr brauchen?  Machen wir eine Sequenz aus Wasser, Sand, Gras, Wald, Savanne, W√ºste und Schnee: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5fd/aa0/237/5fdaa023713e487a95fed02484380d03.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/1d9/8b4/6561d98b4ceda31b7ff49ece890e4e83.png"></div><br>  <i>Erleichterung aufgrund der H√∂he</i> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">biome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WATER; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BEACH; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FOREST; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> JUNGLE; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.7</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SAVANNAH; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.9</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DESERT; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SNOW; }</code> </pre> <br>  Wow, das sieht toll aus!  F√ºr Ihr Spiel k√∂nnen Sie die Werte und Biomes √§ndern.  Crysis wird viel mehr Dschungel haben;  Skyrim hat viel mehr Eis und Schnee.  Unabh√§ngig davon, wie Sie die Zahlen √§ndern, ist dieser Ansatz recht begrenzt.  Reliefarten entsprechen H√∂hen, bilden also Streifen.  Um sie interessanter zu machen, m√ºssen wir Biome basierend auf etwas anderem ausw√§hlen.  Lassen Sie uns eine <em>zweite</em> Ger√§uschkarte f√ºr die Luftfeuchtigkeit erstellen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f4/1e3/de8/4f41e3de81e756ee9097be620ff5e08e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c7c/b6a/317/c7cb6a31702505881dbbf3d2ddb1244b.png"></div><br>  <i>Oben ist das H√∂henger√§usch;</i>  <i>Boden - Feuchtigkeitsger√§usch</i> <br><br>  Verwenden wir nun H√∂he und Luftfeuchtigkeit <em>zusammen</em> .  Im ersten Bild unten ist die y-Achse die H√∂he (aus dem obigen Bild) und die x-Achse die Luftfeuchtigkeit (das zweite Bild ist h√∂her).  Dies gibt uns eine √ºberzeugende Karte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e9/34c/6c1/0e934c6c1358e89adc1b8e4e11b4b21c.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ca/d11/e8e/3cad11e8edae614c2600342c37d6d4eb.png"></div><br>  <i>Entlastung basierend auf zwei Ger√§uschwerten</i> <br><br>  Kleine H√∂hen sind Ozeane und K√ºsten.  Gro√üe H√∂hen sind felsig und schneebedeckt.  Dazwischen erhalten wir eine breite Palette von Biomen.  Der Code sieht folgenderma√üen aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">biome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e, m)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> OCEAN; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.12</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BEACH; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &gt; <span class="hljs-number"><span class="hljs-number">0.8</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SCORCHED; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BARE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TUNDRA; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SNOW; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &gt; <span class="hljs-number"><span class="hljs-number">0.6</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.33</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_DESERT; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.66</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SHRUBLAND; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TAIGA; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &gt; <span class="hljs-number"><span class="hljs-number">0.3</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.16</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_DESERT; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.50</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GRASSLAND; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.83</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_DECIDUOUS_FOREST; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_RAIN_FOREST; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.16</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUBTROPICAL_DESERT; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.33</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GRASSLAND; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.66</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TROPICAL_SEASONAL_FOREST; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TROPICAL_RAIN_FOREST; }</code> </pre> <br>  Bei Bedarf k√∂nnen Sie alle diese Werte entsprechend den Anforderungen Ihres Spiels √§ndern. <br><br>  Wenn wir keine Biome ben√∂tigen, k√∂nnen glatte Farbverl√§ufe (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen Artikel</a> ) Farben erzeugen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd4/963/61d/bd496361d481367788a33ebece885cb6.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28e/799/58e/28e79958eb0b9990fa9e1978fa727def.png"></div><br>  Sowohl f√ºr Biome als auch f√ºr Gradienten bietet ein einzelner Rauschwert keine ausreichende Variabilit√§t, aber zwei sind ausreichend. <br><br><h2>  Klima </h2><br>  Im vorherigen Abschnitt habe ich die <em>H√∂he</em> als <em>Temperaturersatz verwendet</em> .  Je h√∂her die H√∂he, desto niedriger die Temperatur.  Der geografische Breitengrad beeinflusst jedoch auch die Temperaturen.  Verwenden wir sowohl H√∂he als auch Breite, um die Temperatur zu steuern: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mr/fz/qn/mrfzqnq2ouo7zupt4kscz5a2gv8.png"></div><br>  In der N√§he der Pole (gro√üe Breiten) ist das Klima k√§lter, und auf den Gipfeln der Berge (gro√üe H√∂hen) ist das Klima auch k√§lter.  Bisher habe ich es nicht sehr schwer herausgearbeitet: F√ºr die richtige Herangehensweise an diese Parameter ben√∂tigen Sie viele subtile Einstellungen. <br><br>  Es gibt auch <em>saisonalen</em> Klimawandel.  Im Sommer und Winter werden die n√∂rdlichen und s√ºdlichen Hemisph√§ren w√§rmer und k√§lter, aber am √Ñquator √§ndert sich nicht viel.  Hier kann auch viel getan werden, zum Beispiel ist es m√∂glich, die vorherrschenden Winde und Meeresstr√∂mungen, die Auswirkung von Biomes auf das Klima und die durchschnittliche Auswirkung von Ozeanen auf die Temperatur zu simulieren. <br><br><h2>  Die Inseln </h2><br>  In einigen Projekten brauchte ich die R√§nder der Karte als Wasser.  Dies macht die Welt zu einer oder mehreren Inseln.  Es gibt viele M√∂glichkeiten, dies zu tun, aber ich habe in meinem Polygonkartengenerator eine ziemlich einfache L√∂sung verwendet: Ich habe die H√∂he als <code>e = e + a - b*d^c</code> ge√§ndert, wobei <code>d</code> der Abstand vom Zentrum ist (auf einer Skala von 0-1).  Eine andere M√∂glichkeit besteht darin, <code>e = (e + a) * (1 - b*d^c)</code> zu √§ndern.  Die Konstante <code>a</code> erh√∂ht alles nach oben, <code>b</code> senkt die Kanten nach unten und <code>c</code> steuert die Abnahmerate. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uq/gb/s4/uqgbs4h2ifsrwd2hsfvrrhue3ju.png"></div><br>  <em>Ich bin damit nicht ganz zufrieden</em> und es bleibt noch viel zu erforschen.  Sollte es Manhattan oder euklidische Entfernung sein?  Sollte es vom Abstand zum Zentrum oder vom Abstand zum Rand abh√§ngen?  Sollte der Abstand quadratisch oder linear sein oder einen anderen Grad haben?  Sollte es Addition / Subtraktion oder Multiplikation / Division oder etwas anderes sein?  <b>Versuchen</b> Sie im Originalartikel Hinzuf√ºgen, a = 0,1, b = 0,3, c = 2,0 oder Multiplizieren, a = 0,05, b = 1,00, c = 1,5.  Welche Optionen zu Ihnen passen, h√§ngt von Ihrem Projekt ab. <br><br>  Warum √ºberhaupt an Standard-Mathematikfunktionen festhalten?  Wie ich in meinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel √ºber Sch√§den in RPG</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úbersetzung</a> auf Habr√©) sagte, verwendet jeder (einschlie√ülich ich) mathematische Funktionen wie Polynome, Exponentialverteilungen usw., aber auf dem Computer k√∂nnen wir nicht auf sie beschr√§nkt sein.  Wir k√∂nnen <em>jede</em> Formationsfunktion verwenden und sie hier verwenden, indem wir die Nachschlagetabelle <code>e = e + height_adjust[d]</code> .  Bisher habe ich dieses Thema nicht untersucht. <br><br><h2>  Stacheliges Ger√§usch </h2><br>  Anstatt die H√∂he auf eine Potenz zu erh√∂hen, k√∂nnen wir den absoluten Wert verwenden, um scharfe Spitzen zu erzeugen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ridgenoise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> * (<span class="hljs-number"><span class="hljs-number">0.5</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-number"><span class="hljs-number">0.5</span></span> - noise(nx, ny))); }</code> </pre> <br>  Um Oktaven hinzuzuf√ºgen, k√∂nnen wir die Amplituden hoher Frequenzen so variieren, dass nur Berge das zus√§tzliche Rauschen empfangen: <br><br><pre> <code class="cpp hljs">e0 = <span class="hljs-number"><span class="hljs-number">1</span></span> * ridgenoise(<span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny); e1 = <span class="hljs-number"><span class="hljs-number">0.5</span></span> * ridgenoise(<span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny) * e0; e2 = <span class="hljs-number"><span class="hljs-number">0.25</span></span> * ridgenoise(<span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny) * (e0+e1); e = e0 + e1 + e2; elevation[y][x] = Math.<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(e, exponent);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/co/ku/kg/cokukg_3lgom28_bnm3cu4u-4dc.gif"></div><br>  Ich habe nicht viel Erfahrung mit dieser Technik, daher muss ich experimentieren, um zu lernen, wie man sie gut benutzt.  Es kann auch interessant sein, stacheliges Niederfrequenzrauschen mit nicht stacheligem Hochfrequenzrauschen zu mischen. <br><br><h2>  Terrassen </h2><br>  Wenn wir die H√∂he auf die n√§chsten n Ebenen runden, erhalten wir Terrassen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zv/bo/5k/zvbo5k_de80zv8utx6fxorpxfha.png"></div><br>  Dies ist das Ergebnis der Anwendung der H√∂henumverteilungsfunktion in der Form <code>e = f(e)</code> .  Oben haben wir <code>e = Math.pow(e, exponent)</code> , um die Berggipfel zu sch√§rfen.  hier verwenden wir <code>e = Math.round(e * n) / n</code> , um Terrassen zu erstellen.  Wenn Sie eine Nicht-Stufen-Funktion verwenden, k√∂nnen die Terrassen abgerundet sein oder nur in bestimmten H√∂hen auftreten. <br><br><h2>  Baumplatzierung </h2><br>  Normalerweise haben wir fraktales Rauschen f√ºr H√∂he und Luftfeuchtigkeit verwendet, aber es kann auch verwendet werden, um ungleichm√§√üig verteilte Objekte wie B√§ume und Steine ‚Äã‚Äãzu platzieren.  F√ºr die H√∂he verwenden wir hohe Amplituden mit niedrigen Frequenzen (‚Äûrotes Rauschen‚Äú).  Um Objekte zu platzieren, m√ºssen Sie hohe Amplituden mit hohen Frequenzen verwenden ("blaues Rauschen").  Links ist ein blaues Rauschmuster;  Auf der rechten Seite befinden sich Stellen, an denen das Rauschen gr√∂√üer ist als benachbarte Werte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xo/u4/ze/xou4zen4vzp46h3l7ecmcmdqsda.png"></div><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> yc = <span class="hljs-number"><span class="hljs-number">0</span></span>; yc &lt; height; yc++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xc = <span class="hljs-number"><span class="hljs-number">0</span></span>; xc &lt; width; xc++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> max = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     for (int yn = yc - R; yn &lt;= yc + R; yn++) { for (int xn = xc - R; xn &lt;= xc + R; xn++) { double e = value[yn][xn]; if (e &gt; max) { max = e; } } } if (value[yc][xc] == max) { //    xc,yc } } }</span></span></code> </pre> <br>  Wenn wir f√ºr jedes Biom ein anderes R w√§hlen, k√∂nnen wir eine variable Baumdichte erhalten: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/764/e0e/32a/764e0e32ac9171654161a94a29f66118.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa1/940/61f/aa194061fd97796c08238123b57199c7.png"></div><br>  Es ist gro√üartig, dass solches Rauschen zum Platzieren von B√§umen verwendet werden kann, aber andere Algorithmen sind oft effektiver und sorgen f√ºr eine gleichm√§√üigere Verteilung: Poisson-Spots, Van-Kacheln oder grafisches Dithering. <br><br><h2>  Bis ins Unendliche und dar√ºber hinaus </h2><br>  Die Berechnungen des Bioms an der Position (x, y) sind unabh√§ngig von den Berechnungen aller anderen Positionen.  Diese <strong>lokale Berechnung</strong> hat zwei praktische Eigenschaften: Sie kann parallel berechnet und f√ºr endloses Gel√§nde verwendet werden.  <strong>Platzieren Sie den Mauszeiger auf der Minikarte</strong> (im Originalartikel) links, um die Karte rechts zu <strong>erstellen</strong> .  Sie k√∂nnen einen beliebigen Teil der Karte generieren, ohne die gesamte Karte zu generieren (und sogar ohne sie zu speichern). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/98b/932/152/98b932152f6c24f496034283fa904499.png"><img src="https://habrastorage.org/getpro/habr/post_images/6a5/811/c84/6a5811c84c56c1706aedbc505fc32aa9.png"><br><br><h2>  Implementierung </h2><br>  Die Verwendung von L√§rm zur Erzeugung von Gel√§nde ist eine beliebte L√∂sung. Im Internet finden Sie Tutorials f√ºr viele verschiedene Sprachen und Plattformen.  Der Code zum Generieren von Karten in verschiedenen Sprachen ist ungef√§hr gleich.  Hier ist die einfachste Schleife in drei verschiedenen Sprachen: <br><br><ul><li>  <b>Javascript:</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gen = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimplexNoise(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">nx, ny</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Rescale from -1.0:+1.0 to 0.0:1.0 return gen.noise2D(nx, ny) / 2 + 0.5; } let value = []; for (let y = 0; y &lt; height; y++) { value[y] = []; for (let x = 0; x &lt; width; x++) { let nx = x/width - 0.5, ny = y/height - 0.5; value[y][x] = noise(nx, ny); } }</span></span></code> </pre> </li><li>  <b>C ++:</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::Perlin gen; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Rescale from -1.0:+1.0 to 0.0:1.0 return gen.GetValue(nx, ny, 0) / 2.0 + 0.5; } double value[height][width]; for (int y = 0; y &lt; height; y++) { for (int x = 0; x &lt; width; x++) { double nx = x/width - 0.5, ny = y/height - 0.5; value[y][x] = noise(nx, ny); } }</span></span></code> </pre> </li><li>  <b>Python:</b> <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> opensimplex <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> OpenSimplex gen = OpenSimplex() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Rescale from -1.0:+1.0 to 0.0:1.0 return gen.noise2d(nx, ny) / 2.0 + 0.5 value = [] for y in range(height): value.append([0] * width) for x in range(width): nx = x/width - 0.5 ny = y/height - 0.5 value[y][x] = noise(nx, ny)</span></span></code> </pre> </li></ul><br>  Alle Rauschbibliotheken sind ziemlich √§hnlich.  Versuchen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenSimplex f√ºr Python</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Libnoise f√ºr C ++</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Simplex-Noise</a> f√ºr Javascript.  F√ºr die meisten g√§ngigen Sprachen gibt es viele Rauschbibliotheken.  Oder Sie k√∂nnen lernen, wie Perlin-Rauschen funktioniert, oder das Rauschen selbst realisieren.  <em>Ich habe es nicht getan.</em> <br><br>  In verschiedenen Rauschbibliotheken f√ºr Ihre Sprache k√∂nnen die Anwendungsdetails geringf√ºgig variieren (einige R√ºckgabewerte liegen im Bereich von 0,0 bis 1,0, andere im Bereich von -1,0 bis +1,0), aber die Grundidee ist dieselbe.  F√ºr ein reales Projekt m√ºssen Sie m√∂glicherweise die <code>noise</code> und das <code>gen</code> Objekt in eine Klasse <code>gen</code> , aber diese Details sind irrelevant, daher habe ich sie global gemacht. <br><br>  F√ºr ein so einfaches Projekt spielt es keine Rolle, welches Rauschen Sie verwenden: Perlin-Rauschen, Simplex-Rauschen, OpenSimplex-Rauschen, Wertrauschen, Mittelpunktversatz, Diamantalgorithmus oder die inverse Fourier-Transformation.  Jeder von ihnen hat seine Vor- und Nachteile, aber f√ºr einen √§hnlichen Kartengenerator erzeugen alle mehr oder weniger die gleichen Ausgabewerte. <br><br>  <em>Das Rendern der</em> Karte h√§ngt von der Plattform und dem Spiel ab, daher habe ich sie nicht implementiert.  Dieser Code wird nur ben√∂tigt, um H√∂hen und Biomes zu generieren, deren Darstellung vom im Spiel verwendeten Stil abh√§ngt.  Sie k√∂nnen es kopieren, portieren und in Ihren Projekten verwenden. <br><br><h2>  Die Experimente </h2><br>  Ich habe mir √ºberlegt, wie man Oktaven mischt, Grad zu einer Potenz erh√∂ht und H√∂hen mit Feuchtigkeit kombiniert, um ein Biom zu erzeugen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier k√∂nnen</a> Sie ein interaktives Diagramm studieren, mit dem Sie mit all diesen Parametern experimentieren k√∂nnen. Es zeigt, woraus der Code besteht: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lh/yq/xn/lhyqxnbeaj0friycenleop7mcdw.png"></div><br>  Hier ist ein Beispielcode: <br><br><pre> <code class="cpp hljs">var rng1 = PM_PRNG.create(seed1); var rng2 = PM_PRNG.create(seed2); var gen1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimplexNoise(rng1.nextDouble.bind(rng1)); var gen2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimplexNoise(rng2.nextDouble.bind(rng2)); <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gen1.noise2D(nx, ny)/<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gen2.noise2D(nx, ny)/<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; height; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; width; x++) { var nx = x/width - <span class="hljs-number"><span class="hljs-number">0.5</span></span>, ny = y/height - <span class="hljs-number"><span class="hljs-number">0.5</span></span>; var e = (<span class="hljs-number"><span class="hljs-number">1.00</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.50</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.25</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.13</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">8</span></span> * nx, <span class="hljs-number"><span class="hljs-number">8</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.06</span></span> * noise1(<span class="hljs-number"><span class="hljs-number">16</span></span> * nx, <span class="hljs-number"><span class="hljs-number">16</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.03</span></span> * noise1(<span class="hljs-number"><span class="hljs-number">32</span></span> * nx, <span class="hljs-number"><span class="hljs-number">32</span></span> * ny)); e /= (<span class="hljs-number"><span class="hljs-number">1.00</span></span>+<span class="hljs-number"><span class="hljs-number">0.50</span></span>+<span class="hljs-number"><span class="hljs-number">0.25</span></span>+<span class="hljs-number"><span class="hljs-number">0.13</span></span>+<span class="hljs-number"><span class="hljs-number">0.06</span></span>+<span class="hljs-number"><span class="hljs-number">0.03</span></span>); e = Math.<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(e, <span class="hljs-number"><span class="hljs-number">5.00</span></span>); var m = (<span class="hljs-number"><span class="hljs-number">1.00</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.75</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.33</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.33</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">8</span></span> * nx, <span class="hljs-number"><span class="hljs-number">8</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.33</span></span> * noise2(<span class="hljs-number"><span class="hljs-number">16</span></span> * nx, <span class="hljs-number"><span class="hljs-number">16</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.50</span></span> * noise2(<span class="hljs-number"><span class="hljs-number">32</span></span> * nx, <span class="hljs-number"><span class="hljs-number">32</span></span> * ny)); m /= (<span class="hljs-number"><span class="hljs-number">1.00</span></span>+<span class="hljs-number"><span class="hljs-number">0.75</span></span>+<span class="hljs-number"><span class="hljs-number">0.33</span></span>+<span class="hljs-number"><span class="hljs-number">0.33</span></span>+<span class="hljs-number"><span class="hljs-number">0.33</span></span>+<span class="hljs-number"><span class="hljs-number">0.50</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* draw biome(e, m) at x,y */</span></span> } }</code> </pre> <br>  Es gibt eine Schwierigkeit: F√ºr H√∂hen- und Feuchtigkeitsger√§usche muss ein anderes Saatgut verwendet werden, da es sich sonst als gleich herausstellt und die Karten nicht so interessant aussehen.  In Javascript verwende ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Prng-Parkmiller-Bibliothek</a> .  In C ++ k√∂nnen Sie zwei separate <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Objekte linear_congruential_engine verwenden</a> .  In Python k√∂nnen Sie zwei separate Instanzen einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">random.Random-Klasse erstellen</a> . <br><br><h2>  Gedanken </h2><br>  Ich mag diesen Ansatz zur Kartengenerierung wegen seiner <b>Einfachheit</b> .  Es ist schnell und erfordert sehr wenig Code, um anst√§ndige Ergebnisse zu erzielen. <br><br>  Ich mag seine Grenzen in diesem Ansatz nicht.  Lokale Berechnungen bedeuten, dass jeder Punkt unabh√§ngig von allen anderen ist.  Verschiedene Bereiche der Karte sind <em>nicht miteinander verbunden</em> .  Jeder Ort auf der Karte ‚Äûscheint‚Äú gleich zu sein.  Es gibt keine globalen Einschr√§nkungen, z. B. "Es sollten 3 bis 5 Seen auf der Karte sein" oder globale Merkmale wie einen Fluss, der von der Spitze des h√∂chsten Gipfels in den Ozean flie√üt.  Ich mag auch nicht die Tatsache, dass Sie die Parameter f√ºr eine lange Zeit konfigurieren m√ºssen, um ein gutes Bild zu erhalten. <br><br>  Warum empfehle ich es?  Ich denke, dies ist ein guter Ausgangspunkt, insbesondere f√ºr Indie-Spiele und Game-Jams.  Zwei meiner Freunde haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in</a> nur 30 Tagen die erste Version von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Realm of the Mad God</a> f√ºr einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spielewettbewerb geschrieben</a> .  Sie baten mich, beim Erstellen von Karten zu helfen.  Ich habe diese Technik verwendet (plus ein paar weitere Funktionen, die sich als nicht sehr n√ºtzlich erwiesen haben) und eine Karte f√ºr sie erstellt.  Einige Monate sp√§ter, nachdem wir Feedback von den Spielern erhalten und das Design des Spiels sorgf√§ltig studiert hatten, erstellten wir einen fortschrittlicheren Kartengenerator auf der Basis der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> beschriebenen Voronoi-Polygone ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úbersetzung</a> in Habr√©).  Dieser Kartengenerator verwendet nicht die in diesem Artikel beschriebenen Techniken.  Es verwendet Rauschen, um Karten auf ganz andere Weise zu erstellen. <br><br><h2>  Weitere Informationen </h2><br>  Es gibt <em>viele</em> coole Dinge, die Sie mit Rauschfunktionen tun k√∂nnen.  Wenn Sie im Internet suchen, finden Sie Optionen wie Turbulenzen, Wogen, geriffelte Multifraktale, Amplitudend√§mpfung, Terrassen-, Voronoi-Rauschen, analytische Derivate, Domain Warping und andere.  Sie k√∂nnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese Seite</a> als Inspirationsquelle verwenden.  Ich betrachte sie hier nicht, mein Artikel konzentriert sich auf Einfachheit. <br><br>  Dieses Projekt wurde von meinen vorherigen Kartengenerierungsprojekten beeinflusst: <br><br><ul><li>  Ich habe Perlins Gesamtrauschen f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meinen ersten Realm of the Mad God-Kartengenerator verwendet</a> .  Wir haben es in den ersten sechs Monaten des Alpha-Tests verwendet und es dann durch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Kartengenerator f√ºr Voronoi-Polygone ersetzt</a> , der speziell f√ºr die Gameplay-Anforderungen entwickelt wurde, die wir w√§hrend des Alpha-Tests ermittelt haben.  Biomes und ihre Farben f√ºr den Artikel stammen aus diesen Projekten. </li><li>  Beim Studium der Verarbeitung von Audiosignalen habe ich ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rausch-Tutorial geschrieben</a> , in dem Konzepte wie Frequenz, Amplitude, Oktaven und die ‚ÄûFarbe‚Äú des Rauschens erl√§utert werden.  Die gleichen Konzepte, die f√ºr Sound gelten, gelten auch f√ºr die rauschbasierte Kartenerzeugung.  Zu dieser Zeit habe ich eine rohe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo-Relief-Generation erstellt</a> , aber ich habe sie nicht fertiggestellt. </li><li>  Manchmal experimentiere ich, um Grenzen zu finden.  Ich wollte wissen, wie viel Code minimal ben√∂tigt wird, um √ºberzeugende Karten zu erstellen.  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Miniprojekt habe</a> ich <b>null</b> Codezeilen erreicht - alles wird mit Bildfiltern (Turbulenzen, Schwellenwerte, Farbverl√§ufe) gemacht.  Das hat mich gl√ºcklich und traurig gemacht.  Inwieweit kann die Kartenerzeugung durch Bildfilter durchgef√ºhrt werden?  In gro√ü genug.  Alles, was oben √ºber das "Schema glatter Farbverl√§ufe" beschrieben wurde, stammt aus diesem Experiment.  Die Rauschschicht ist ein Turbulenzbildfilter;  Oktaven sind einander √ºberlagerte Bilder;  Das Grad-Werkzeug wird in Photoshop als ‚ÄûKurvenkorrektur‚Äú bezeichnet. </li></ul><br>  Was mich ein bisschen st√∂rt, ist, dass der gr√∂√üte Teil des Codes, den Spieleentwickler f√ºr die rauschbasierte Gel√§ndegenerierung (einschlie√ülich der Verschiebung des Mittelpunkts) schreiben, der gleiche ist wie bei Ton- und Bildfiltern.  Auf der anderen Seite werden in nur wenigen Codezeilen recht anst√§ndige Ergebnisse erzielt, weshalb ich diesen Artikel geschrieben habe.  Dies ist ein <em>schneller und einfacher Bezugspunkt</em> .  Normalerweise benutze ich solche Karten nicht lange, sondern ersetze sie durch einen komplexeren Kartengenerator, sobald ich herausfinde, welche Kartentypen besser f√ºr das Design des Spiels geeignet sind.  F√ºr mich ist dies ein Standardmuster: Beginnen Sie mit etwas extrem Einfachem und ersetzen Sie es erst, nachdem ich das System, mit dem ich arbeite, besser verstanden habe. <br><br>  Es gibt noch <em>viel</em> mehr Dinge, die mit L√§rm gemacht werden k√∂nnen, in dem Artikel habe ich nur einige erw√§hnt.  Probieren Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Noise Studio aus</a> , um verschiedene Funktionen interaktiv zu testen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430384/">https://habr.com/ru/post/de430384/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430374/index.html">Data Engineering und mehr: Wrike-Videob√§nder und -Dias aus dem Meeting</a></li>
<li><a href="../de430376/index.html">JavaScript-Handbuch Teil 6: Ausnahmen, Semikolons, Vorlagenliterale</a></li>
<li><a href="../de430378/index.html">J2CL - Besser sp√§t als nie</a></li>
<li><a href="../de430380/index.html">JavaScript-Handbuch Teil 5: Arrays und Loops</a></li>
<li><a href="../de430382/index.html">JavaScript-Handbuch Teil 4: Funktionen</a></li>
<li><a href="../de430386/index.html">Festk√∂rperspeicherkraftwerk in Indien gebaut werden</a></li>
<li><a href="../de430388/index.html">Web Summit Unconference</a></li>
<li><a href="../de430392/index.html">Wie ich APIs mit meinem PieceofScript-Fahrrad entwickle und teste</a></li>
<li><a href="../de430394/index.html">Implementierung der Sofort-Suche in Android mit RxJava</a></li>
<li><a href="../de430396/index.html">Kettenreplikation: Aufbau eines effektiven KV-Repositorys (Teil 1/2)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>