<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚗️ 🧐 🚧 Jet-Frontend. Die Geschichte, wie wir alles wieder neu geschrieben haben 🕰️ ⛔️ 👨🏿‍🤝‍👨🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo, das ist wieder Katya von Yandex.Money. Ich setze meine Geschichte darüber fort, wie ich aufgehört habe mich zu schminken und angefangen habe zu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jet-Frontend. Die Geschichte, wie wir alles wieder neu geschrieben haben</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yamoney/blog/414183/">  Hallo, das ist wieder Katya von Yandex.Money.  Ich setze meine Geschichte darüber fort, wie ich aufgehört habe mich zu schminken und angefangen habe zu leben.  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten</a> Teil habe ich erzählt, wie ich hierher gekommen bin und was unsere Front-End-Entwickler tun.  Heute - über den Frontstack, woher kommt React und wohin ist BEM gegangen? <br><br>  Spoiler: BEM ist nirgendwo hingegangen ¯ \ _ (ツ) _ / ¯.  Lass uns gehen! <br><br><img src="https://habrastorage.org/webt/en/f4/oz/enf4ozorjurjqvgcr5nozsfcmfi.jpeg"><br><br>  Achtung: hohe Konzentration des Frontends.  Viel Text, Bilder und Code, wie versprochen. <br><a name="habracut"></a><br><h1>  Teil 2. Über Technologie </h1><br>  Far 2016. Der Versuch, in React zu schreiben, stellt sich als ziemlich erträglich heraus.  Ich vermute immer noch nicht, dass ich in einem Jahr ganze Dienste an React übertragen werde.  2017 beginnt auf Yandex.Money, ich habe einen BEM des Gehirns und ich vermute immer noch nicht. <br><br><h1>  Backend auf Node.js, mein erstes Mal </h1><br>  Um sich mit dem Projekt vertraut zu machen, erhält ein neuer Entwickler eine Testaufgabe.  Ich hatte Glück: Ich hatte diese Aufgabe aus dem Rückstand.  Und am ersten Tag traf ich auf Node.js. <br><br>  Das Front-End in Yandex.Money ist nicht nur für die Clientseite verantwortlich, sondern auch für die Serverschicht als Node.js-Anwendung.  Die Aufgabe der Anwendung besteht darin, Daten aus dem Java-Backend für die Vorbereitung in einer ansichtsorientierten Form sowie für das Rendern und Routing von Servern zu orchestrieren.  Sie hätten dies vor ein paar Jahren erfahren, ich hätte nichts verstanden, und alles ist ganz einfach: Wenn eine Anfrage vom Browser an den Server kommt, generiert Node.js HTTP-Anfragen für das Backend, empfängt die erforderlichen Daten und Vorlagen-Webseiten.  Wir verwenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Express</a> als Server-Framework und für die Entwicklung interner Anwendungen ohne Legacy- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link haben wir uns</a> für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Koa2 entschieden</a> .  Die Entwickler waren vom Design des Frameworks begeistert, und wir entschieden uns, kein Downgrade auf Express durchzuführen, sodass Koa2 auf dem Stack blieb.  Wir stellen Koa2-Code jedoch nicht für externe Benutzer bereit: Das Framework bietet nicht genügend Unterstützung, es gibt jedoch offene Sicherheitslücken. <br><br>  Wir haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bereits</a> über den Platz von Node.js in unserem Frontend geschrieben, aber seitdem hat sich etwas geändert.  Node.js 8 wurde zu LTS und läuft bereits auf unseren Produktionsservern.  Wir möchten auch Nginx-Server aufgeben, die wir auf jedem Host zur Verteilung der Statik aufrufen. Sie werden durch separate Server mit Nginx und eines Tages CDN ersetzt. <br><br>  Um Code zwischen Projekten zu fummeln, aber nicht öffentlich verfügbar zu machen, verwenden wir eine ganze Reihe von Tools: Speichern Sie die Module in Bitbucket und sammeln Sie sie in Jenkins.  Wir verwenden auch die lokale Registrierung von Paketen und gehen dank dieser nicht zum externen Netzwerk - dies beschleunigt die Montage und erhöht die Sicherheit des gesamten Systems.  Dieser Ansatz wurde uns von den Javisten vorgeschlagen, sie sind cool.  Liebe deine Backender;) <br><br>  Wir haben auch ein Experiment durchgeführt - wir haben einen Prozessmanager in eine der Anwendungen eingeführt, der die Verwaltung von Diensten auf Node.js vereinfacht hat.  Er half beim Clustering und rettete uns auch vor einem alten Bash-Skript, auf dem Anwendungen ausgeführt wurden. <br><br><h1>  Und der ganze Stapel reicht nicht aus </h1><br>  Wir haben überall im Frontend Javascript.  Und auf dem Server und auf dem Client und unter der Haube interner Tools.  Wir kennen andere Sprachen, aber Javascript macht einen tollen Job. <br><br>  Aber BEM im Rahmen unserer Aufgaben bewältigt nicht alles. <br><br><div class="spoiler">  <b class="spoiler_title">Was ist BEM?</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BEM</a> ist ein Webentwicklungsansatz, den Yandex während der Lebensdauer statischer HTML-Seiten und CSS-Kaskaden erfunden hat.  Es gab noch keinen Komponentenansatz, und es war notwendig, die Einheitlichkeit vieler Dienste aufrechtzuerhalten.  Yandex war nicht überrascht und entwickelte einen eigenen Komponentenansatz, mit dem Sie heute isolierte Komponenten erstellen und flexiblen deklarativen Code schreiben können. <br><br>  BEM ist nicht nur eine Methodik, sondern auch eine Vielzahl von Technologien und Bibliotheken.  Einige von ihnen sind auf die Besonderheiten von BEM zugeschnitten, andere können möglicherweise isoliert von der BEM-Architektur verwendet werden.  Wenn Sie eine leistungsstarke Template-Engine oder ein würdiges Beispiel für die Komponentenabstraktion über das DOM in Ihrem Projekt benötigen, wissen Sie, wo Sie sie finden können;) <br></div></div><br>  Aus diesem Grund haben wir begonnen, Dienste an React zu übertragen.  Einige von ihnen leben bereits in zwei Anwendungen, die auf unterschiedlichen Stapeln basieren: <br><br>  - eine Plattform speziell für Yandex BEM; <br>  - Das junge und modische Ökosystem von React. <br><br><h1>  Yandex Technologies </h1><br>  Es ist Zeit, Ihnen zu sagen, warum ich mich in BEM verliebt habe. <br><br><h2>  Neudefinitionsebenen </h2><br>  Levels, Levels, Levels ... BEM!  Gewinn! <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Überschreibende Ebenen</a> sind eines der Hauptmerkmale der BEM-Methodik.  Schauen Sie sich das Bild an, um zu verstehen, wie sie funktionieren: <br><img src="https://habrastorage.org/webt/qs/a5/yd/qsa5yducqqeejyft1ymikcjhaxy.gif"><br><br>  Das Bild wird durch Überlagern von Ebenen erzeugt.  Jede Ebene ändert das endgültige Bild, die anderen Ebenen jedoch nicht.  Die Ebene kann leicht herausgezogen oder hinzugefügt werden, und das Bild ändert sich. <br>  Override-Levels machen dasselbe mit Code: <br><img src="https://habrastorage.org/webt/yt/x3/gt/ytx3gt_yik0xil0lw281v6xmjhy.gif"><br><br>  Das Verhalten der Komponente wird während der Code-Assemblierung gebildet.  Um zusätzliches Verhalten hinzuzufügen, verbinden Sie einfach die gewünschte Ebene mit der Baugruppe.  Der Code des Moduls aus verschiedenen Ebenen, als ob er übereinander geschichtet wäre.  In diesem Fall ändert sich der Quellcode nicht, aber wir erhalten ein unterschiedliches Verhalten, indem wir verschiedene Ebenen kombinieren. <br><br><div class="spoiler">  <b class="spoiler_title">Was sind die Ebenen</b> <div class="spoiler_text">  Das Bild oben zeigt mehrere Neudefinitionsstufen: <br><ul><li>  Die Basisebene - die Bibliothek - liefert das Quellcodemodul; <br></li><li>  Die nächste Ebene - das Projekt - passt dieses Modul an die Anforderungen des Projekts an. <br></li><li>  Eine höhere Ebene - Plattform - macht dasselbe Modul für verschiedene Geräte spezifisch. <br></li><li>  Die Kirsche auf dem Kuchen - das Niveau der Experimente - ändert das Modul für A / B-Tests. <br></li></ul><br><br>  Die Projektebene ist unabhängig von der Bibliotheksebene, sodass die Bibliothek leicht aktualisiert werden kann.  Auf der Plattformebene können Sie eine andere Baugruppe für verschiedene Geräte verwenden.  Und die Ebene mit dem Experiment ist zum Testen an Benutzern verbunden und lässt sich auch leicht ausschalten, wenn die Ergebnisse erhalten werden. <br><br>  Der Entwickler entscheidet selbst, welche Ebenen er benötigt: Sie können eine Ebene mit einem Thema oder eine Ebene mit demselben Code in einem anderen Framework erstellen. <br></div></div><br>  Mit Ebenen können Sie komplexe Module basierend auf einfachen Modulen schreiben, das Verhalten einfach kombinieren und denselben Code zwischen Diensten fummeln.  Und dieser Code wird von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ENB</a> - Webpack in der BEM-Welt gesammelt. <br><br>  Als ich BEM kennenlernte, war ich besonders zufrieden mit den UI-Bibliotheken, in denen fertige Komponenten liegen.  Wir erweitern diese Komponenten im Rahmen neuer Bibliotheken und teilen sie zwischen Projekten.  Das macht das Leben einfacher: Ich mache selten Make-up, schreibe nicht den gleichen JS-Typ und baue schnell Schnittstellen aus vorgefertigten Blöcken zusammen. <br><br><img src="https://habrastorage.org/webt/wq/rg/gp/wqrggp5qnt1zkunnz73xagsgjpk.png"><br><br>  Jetzt werden wir uns die Tools der BEM-Plattform genauer ansehen, um zu verstehen, was BEM nicht gut genug macht und warum es nicht zu unseren Aufgaben passt. <br><br><h2>  BEM-XJST </h2><br>  Ich werde mit meiner Lieblings- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bem-xjst-</a> Template-Engine beginnen.  Vor Yandex.Money habe ich Jade verwendet, und Bem-xjst hat die Minuspunkte von Jade, die ich damals nicht gesehen habe, perfekt illustriert.  Die bem-xjst-Vorlagen sind deklarativ [1], haben keine if-Hölle [2] und erfüllen perfekt die Anforderungen des Komponentenansatzes [3].  All dies ist im Beispiel deutlich zu sehen: <br><br><img src="https://habrastorage.org/webt/d_/hh/bz/d_hhbzkdjx9uj-fpr9olmhe8xty.png"><br><br>  In der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sandbox können</a> Sie das Ergebnis der Vorlage sehen und damit spielen. <br><br><div class="spoiler">  <b class="spoiler_title">Wie funktioniert es</b>  <b class="spoiler_title">Im Inneren steckt das Geheimnis perfekter Architektur;)</b> <div class="spoiler_text"><ul><li>  schreibe BEMJSON.  BEMJSON ist ein JSON, der einen BEM-Baum beschreibt.  Ein BEM-Baum ist eine Darstellung des DOM-Baums als unabhängige Komponenten. <br></li><li>  bem-xjst akzeptiert BEMJSON als Eingabe und wendet Muster an.  Dieser Vorgang kann mit dem Rendern in einem Browser verglichen werden.  Der Browser umgeht den DOM-Baum und wendet nach und nach CSS-Regeln auf seine DOM-Knoten an: Größe, Textfarbe, Einzug.  Bem-xjst umgeht auch BEMJSON, sucht nach Vorlagen, die seinen Knoten entsprechen, und wendet sie schrittweise an: Tag, Attribute, Inhalt.  "Vorlage anwenden" bedeutet, daraus eine HTML-Zeichenfolge zu generieren.  Die HTML-Generierung aus BEMJSON wird von einer der Vorlagen-Engines - BEMHTML - ausgeführt. <br></li></ul><br><br>  Das Schreiben von Vorlagen ist einfach: Wählen Sie die Entität aus und schreiben Sie die Funktionen, die die Vorlagen-Engine aufruft, um Teile der HTML-Zeichenfolge zu rendern.  Am schwierigsten ist es, die Essenz hervorzuheben.  Richtige Entitäten sind der Schlüssel zu einer guten Architektur! <br><br>  Je länger Ihr Bart ist, desto höher ist die Wahrscheinlichkeit, dass Sie bereits einen Verweis im Vorlagennamen bemerkt haben: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">XSLT</a> (eXtensible Stylesheet Language Transformations) =&gt; XJST (eXtensible JavaScript Transformations).  Es verwendet die Prinzipien von XSLT und ist daher so deklarativ.  Wenn Sie nicht wissen, was XSLT ist, können Sie sich glücklich schätzen :) <br></div></div><br>  Bem-xjst ist isomorph.  Wir rendern HTML-Seiten auf dem Server und ändern sie dynamisch auf dem Client.  Für die Vorlage zur Laufzeit bietet bem-xjst eine API, die wir beim Schreiben von clientseitigem Javascript-Code verwenden. <br><br><h2>  Ich-bem </h2><br>  Mit bem-xjst beschreiben wir die Ansicht und die Logik mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">i-bem</a> .  I-bem ist eine Abstraktion über das DOM, die eine allgemeine API für die Arbeit mit Komponenten bietet.  Einfach ausgedrückt, schreiben wir Folgendes: <br><br><img src="https://habrastorage.org/webt/nb/mv/en/nbmvenurba_qz14drptqcrp_wmc.png"><br><br>  stattdessen: <br><br><img src="https://habrastorage.org/webt/ev/2e/5g/ev2e5ggz8xgrzwhc6pfsqrjowiq.png"><br><br>  Um Code zu schreiben, müssen Sie nicht über die interne Implementierung der Komponente informiert sein.  Wir arbeiten mit Entitäten, die wir in der Vorlage beschrieben haben: Auf jeden Fall handelt es sich um einen jQuery-Selektor oder ein DOM-Element.  Wir können benutzerdefinierte Ereignisse erstellen, die für ein bestimmtes Objektmodell geeignet sind, und die Arbeit mit nativen Ereignissen und Schnittstellen wird in der internen Implementierung ausgeblendet.  Dort wird auch die Logik auf niedriger Ebene beschrieben, was bedeutet, dass wir den Code nicht mit der Hauptlogik mit unnötigen Überprüfungen laden.  Infolgedessen ist der Code leicht zu lesen und hängt nicht von einer bestimmten Technologie ab. <br><br>  Mit I-bem können Sie die Logik der Komponente als eine Reihe von Zuständen beschreiben [1].  Dies ist deklaratives Javascript.  I-bem implementiert seinen eigenen Event Emitter: Wenn sich Zustände ändern, generieren Komponenten automatisch Ereignisse, die eine andere Komponente abonnieren kann [2]. <br><br>  So sieht der größte Teil des clientseitigen BEM-Javascript-Codes aus: <br><br><img src="https://habrastorage.org/webt/fm/_j/bl/fm_jbln_7fjprukofbrmlj_ycrq.png"><br><br><div class="spoiler">  <b class="spoiler_title">Wie funktioniert es?</b> <div class="spoiler_text"><ul><li>  Durch das Ereignis domReady i-bem werden Komponenten (Blöcke) im DOM-Baum gefunden und initialisiert. Es wird ein js-Objekt im Browserspeicher erstellt, das dem Block entspricht. <br></li><li>  Beim Auftreten der erforderlichen Ereignisse setzen wir die Blockmarkierungen, die den Status widerspiegeln.  Die Rolle von Markern wird von CSS-Klassen übernommen.  Wenn wir beispielsweise auf Eingabe klicken, fügen wir die Klasse "input_focused" hinzu, die als Markierung dient. <br></li><li>  Beim Setzen solcher Markierungen startet i-bem die Rückrufe, die in der Javascript-Implementierung des Blocks angegeben sind. <br></li></ul><br>  Das Schreiben von Logik ist einfach: Sie müssen die möglichen Zustände des Blocks beschreiben (dieselben Markierungen) und Handler zum Ändern dieser Zustände festlegen (dieselben Rückrufe). <br></div></div><br>  Mit i-bem können wir das Verhalten von Komponenten einfach neu definieren, eine wohlgeformte API für ihre Interaktion erstellen und sie zur Laufzeit dynamisch ändern.  Was fehlt also? <br>  Wir lieben BEM wegen seiner Deklarativität, einfachen Skalierbarkeit und Abstraktionen auf hoher Ebene, sind aber nicht mehr bereit, seine Einschränkungen in Kauf zu nehmen.  Im Folgenden werden wir das Problem des Client-Renderings, der Datenspeicherung und anderer Einschränkungen der BEM-Plattform betrachten.  Im Laufe der Zeit können diese Probleme von BEM-Mitarbeitern gelöst werden, aber wir sind nicht bereit zu warten. <br><br>  Modernes Web mit SPA und Anpassungsfähigkeit für mobile Geräte erfordert auch Anpassungsfähigkeit von uns.  Aus diesem Grund haben wir uns entschlossen, auf unseren eigenen Stack umzusteigen.  Und sie entschieden sich für React. <br><br><h1>  Neuer React Maple Stack </h1><br>  React brachte ein virtuelles DOM, Hot Reload, CSS in JS und eine große Community, zu der wir gehören, in unser Leben. <br><br>  Die Migration unserer Dienste zu React ist in vollem Gange. Einige Anwendungen wurden bereits ganz oder teilweise in React umgeschrieben.  Wir lernen neue Ansätze und Tools kennen und verbessern die Architektur unserer Anwendungen. <br><br><h2>  Bibliotheken </h2><br>  Das Partitionieren von Schnittstellenentitäten in unabhängige BEM-Blöcke ist mit dem React-Komponentenansatz sehr benutzerfreundlich.  Yandex-Entwickler haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bem-react-core geschrieben</a> und die UI-Bibliothek der Basiskomponente an React übertragen.  Wir haben darüber eine Adapterbibliothek geschrieben, die die Besonderheiten dieser Komponenten berücksichtigt und als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HOC bereitstellt</a> : <br><br><img src="https://habrastorage.org/webt/2y/yg/26/2yyg26edgfevpttq3qpgl8s-alg.png"><br><br>  Solche Bibliotheken sind nicht in der Anwendung, sondern in der Hauptbibliothek der Komponente verbunden: <br><br><img src="https://habrastorage.org/webt/wc/xh/h9/wcxhh9dhwnp-qmd30tnrazsjlko.png"><br><br>  Die Anwendung hängt nur von der Hauptbibliothek ab und bezieht alle Komponenten daraus: <br><br><img src="https://habrastorage.org/webt/ub/rs/4-/ubrs4-p8-pedgu7lqrqvx81-vlu.png"><br><br>  Dadurch wird die Anzahl der Anwendungsabhängigkeiten verringert, und Bibliotheken werden unter verschiedenen Versionen nicht zweimal in das Bundle aufgenommen. <br><br><h2>  Technologie </h2><br>  React ist nicht an bestimmte Technologien gebunden und wir wählen selbst Tools und Bibliotheken aus.  Es gibt Axios, Redux, Redux-Form, Redux-Thunk, Styled-Komponenten, TypeScript, Flow, Scherz und andere coole Sachen in meiner Bewaffnung.  Um den Zoo zu verhindern, koordinieren wir den Einsatz neuer Technologien mit anderen Entwicklern. Wir senden eine Pull-Anfrage an ein spezielles Repository mit einer Analyse, wie nützlich die Technologie ist und warum sie ausgewählt wurde. <br><br><h2>  Das Frontend kommt in die Bar und der Barkeeper sagt es ihm </h2><br>  Für Anwendungen auf React erstellen wir eine Plattform, die Bibliotheken und Prozesse zusammenführt, um sie zu erstellen und zu unterstützen.  Das Herzstück dieser Plattform ist das Frontend Bar-Konsolendienstprogramm.  Bar kann viele leckere Stücke kochen. <br><br>  Im Menü: <br><br><ol><li>  Config with ice: bar mischt und schüttelt Ihre yml-Variablen und bereitet eine Konfigurationsvorlage für ansible vor. <br></li><li>  Saft mit dem Aroma von Konfiguratoren: Bar erstellt eine neue Anwendung basierend auf einem modularen Rohling - Saft. <br></li><li>  Grundlegende Bibliothekseinstellungen.  Bald erhältlich. <br></li></ol><br>  Das Erstellen einer saftigen App ist jetzt ganz einfach - Frontend-Bar macht Saft.  Saft machen, nicht Krieg!  Wenn Bar eine neue Anwendung bereitstellt, führt es eine Reihe von Konfigurationen aus Juice aus: package.json, .babelrc wird generiert, Key Middleware und Routencode, Root-Komponentencode.  Die Frontend Bar erleichtert die Zuweisung neuer Microservices und hilft, einheitliche Regeln für das Schreiben von Code einzuhalten. <br><br>  Beim Wechsel zu einem neuen Stack haben wir begonnen, die Serverarchitektur von Anwendungen zu verbessern. Wir haben einen neuen Logger für den Client und eine Bibliothek mit einer Reihe von Abstraktionen für die Implementierung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MVC geschrieben</a> .  Heute entscheiden wir über die neue Serverarchitektur. <br><br><img src="https://habrastorage.org/webt/qd/wb/ib/qdwbib4ee20flundgjx-3d1m4q0.png"><br><br>  Spoiler: Zwiebel wählen. <br><br><h1>  Was ist passiert und ist es besser geworden?  Lass uns verstehen </h1><br><h2>  Dynamische Schnittstellen </h2><br><h4>  War </h4><br>  Ich habe oben geschrieben, dass bem-xjst eine API für Vorlagen zur Laufzeit bereitstellt.  I-bem kann wiederum mit dem DOM-Baum arbeiten.  Wir werden sie zu Freunden machen und in der Lage sein, HTML dynamisch zu generieren und zu ändern.  Versuchen wir, die Schaltfläche nach Ereignis zu ändern: <br><br><img src="https://habrastorage.org/webt/bg/9b/4d/bg9b4d3tz7svwiifnivmacarf38.png"><br><img src="https://habrastorage.org/webt/bo/y5/1e/boy51ea8-l77moeaa4ogstifwz8.png"><br><br>  In diesem Beispiel ist die schwache Seite von BEM sichtbar: i-bem möchte nicht mit bem-xjst befreundet sein und möchte nichts über Vorlagen wissen.  Es fügt dem Block eine Klasse hinzu, wendet jedoch die Vorlage nicht an [1].  Wir rendern die Komponente manuell neu [2]: <br><br><ul><li>  beschreibe ein neues Stück BEM-Baum [3]; </li><li>  Wenden Sie dann eine neue Vorlage an [4]. </li><li>  und initialisieren Sie eine andere Komponente auf dem aktuellen DOM-Knoten [5]. </li></ul><br>  Außerdem erstellt i-bem keinen Unterschied zwischen BEM-Bäumen. Daher wird die gesamte Komponente gerendert, nicht die Teile, die sich geändert haben.  Stellen Sie sich ein einfaches Beispiel vor: Rendern Sie den Inhalt eines modalen Fensters bei Bedarf neu.  Es besteht aus drei Elementen: <br><br><img src="https://habrastorage.org/webt/47/zo/it/47zoit3kwi5fq9idjqxluxuube0.png"><br><br>  Der Einfachheit halber nehmen wir an, dass sich nur ein Element ändern kann. <br><br><img src="https://habrastorage.org/webt/fe/kv/cf/fekvcf9j8mxnenc8v01lj29rgjm.png"><br><br>  Ich möchte [1] tun und mich entspannen.  Aber i-bem wird nicht verstehen, was sich geändert hat, die gesamte Komponente komplett neu rendern und sich auch entspannen.  In diesem Beispiel gibt es keine schwerwiegenden Konsequenzen, aber was ist, wenn die gesamten Formulare so ungenau wiedergegeben werden?  Dies verschlechtert die Leistung und verursacht unangenehme Nebenwirkungen: Irgendwo flackert die Eingabe, irgendwo hängt der inhaberlose Tooltip.  Aus diesem Grund sind wir traurig und steuern Teile der Komponenten manuell, um einen Punktrenderer zu erstellen [2].  Dies erschwert die Entwicklung und wir sind wieder traurig. <br><br><h4>  Ist geworden </h4><br>  Die Reaktion kam und ruinierte alles.  Er selbst überwacht den Status der Komponenten, wir verwalten das manuelle Rendern nicht mehr und denken nicht an die Interaktion mit dem DOM.  React enthält eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">virtuelle DOM-</a> Implementierung.  Durch Aufrufen von React.createElement wird ein js-Objekt des DOM-Knotens mit seinen Eigenschaften und Nachkommen erstellt - das virtuelle DOM dieser Komponente, das in React gespeichert ist.  Wenn sich eine Komponente ändert, berechnet React das neue virtuelle DOM und dann den Unterschied zwischen gespeichert und neu und aktualisiert nur den Teil des DOM, der sich geändert hat.  Alles fliegt und wir können komplexe Logik nur mit shouldComponentUpdate optimieren.  Es ist ein Erfolg! <br><br><h2>  Datenspeicherung </h2><br><h4>  War </h4><br>  In BEM bereiten wir alle Daten auf dem Server vor und übertragen sie auf die Seitenkomponenten: <br><br><img src="https://habrastorage.org/webt/2b/c5/kj/2bc5kjxp0jasbh4l3q4ympbiuki.png"><br><br>  Die Komponenten sind isoliert und teilen keine Daten miteinander, was bedeutet, dass dieselben Daten in verschiedene Komponenten geworfen werden müssen [1].  Wir können sie nicht auf den Client übertragen, daher akzeptiert jede Komponente im Voraus einen Datensatz, der für alle möglichen Szenarien ihres Betriebs benötigt wird.  Dies bedeutet, dass wir die Komponente mit Daten laden, die sie möglicherweise nicht benötigt [2]. <br><br>  Manchmal rettet uns eine globale Entität, in der ein Teil der gemeinsamen Daten gespeichert ist, aber die globale Speicherung von Variablen passt nicht gut zum BEM-Konzept.  Deshalb haben wir einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bem-redux geschrieben</a> , der Redux für BEM anpasst.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Redux</a> ist ein Statusmanager, der den Datenfluss verwaltet.  Es verwaltet unsere Daten perfekt über einfache Schnittstellen, aber bei der Entwicklung einer komplexen Komponente stoßen wir auf das oben beschriebene Rendering-Problem.  Redux ist nicht freundlich zu i-bem, wir beheben Fehler und sind traurig. <br><br><h4>  Ist geworden </h4><br>  <i>Redux + React = &lt;3</i> <br>  Redux speichert Daten für die gesamte Anwendung an einem Ort [1]: <br><br><img src="https://habrastorage.org/webt/xv/k8/if/xvk8ifh8_9faxrwnmoeddps_wtm.png"><br><br>  Die Komponente selbst entscheidet, wann und welche Daten sie benötigt [2]: <br><br><img src="https://habrastorage.org/webt/wj/5j/l_/wj5jl_ffgk5f-7ql1mhno59hnd0.png"><br><br>  Wir müssen nur die Szenarien der Komponente [3] beschreiben und angeben, woher die Daten für ihre Ausführung stammen [4]: <br><br><img src="https://habrastorage.org/webt/jx/jh/kl/jxjhklr4appyvnlmv9r23jde3x0.png"><br><br>  Und React wird den Rest erledigen [5]: <br><br><img src="https://habrastorage.org/webt/zw/2t/iu/zw2tiux44khisns5fuem8ny7av8.png"><br><br>  Mit diesem Ansatz können Sie dem Prinzip der Einzelverantwortung folgen und die Logik der Komponente in der Komponente selbst kapseln, anstatt sie im Seitencode zu verbreiten.  Es ist ein Erfolg! <br><br><h2>  Sie müssen für alles bezahlen </h2><br>  Für den Erfolg haben wir eine Menge Vermächtnis für React bezahlt.  Es ist schmerzhaft zu sehen, wie Ihr Code, der vor ein paar Monaten geschrieben wurde, reibungslos veraltet wird. <br><br>  Tatsache ist, dass React eine Bibliothek auf Ansichtsebene ist, kein vollwertiges Framework.  Sie können alle Werkzeuge auswählen, müssen jedoch alle Werkzeuge auswählen.  Und auch, um den Code selbst zu organisieren, Ansätze zur Lösung typischer Probleme zu formulieren, eine Reihe von Vereinbarungen zu entwickeln und die fehlenden Plugins zu schreiben.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir schreiben unsere eigenen Validatoren für Redux-Formulare und haben noch nicht gelernt, wie man mit komplexen Animationen arbeitet. </font><font style="vertical-align: inherit;">Und wir versuchen rauszuwerfen, zu schreiben und neu zu schreiben. </font><font style="vertical-align: inherit;">Und wir schreiben es nicht immer neu, weshalb unser Rückstand wächst. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">React ist jung genug und im Gegensatz zu BEM nicht bereit für die Unternehmensentwicklung. </font><font style="vertical-align: inherit;">Und während wir lernten, wie man es kocht, haben wir unsere gesamte Küche und uns selbst bis zum Ellbogen durcheinander gebracht. </font><font style="vertical-align: inherit;">Und wir diskutieren immer noch, ob wir Flow benötigen oder nicht, und verstehen immer noch nicht vollständig, was im Geschäft und was im lokalen Geschäft gespeichert werden soll. </font><font style="vertical-align: inherit;">Wir schreiben nach Bedarf und gehen zu Konferenzen, um herauszufinden, wie es geht. </font><font style="vertical-align: inherit;">Wir haben die Zapfen geschlagen, sind aber zuversichtlich vorwärts gegangen.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unerwartete Brötchen </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mit dem neuen Stack konnten wir eine Reihe von Aufgaben neu betrachten und auf einfache Weise lösen. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CSS in JS </font></font></h2><br><h4>  War </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie sich einen einfachen Fall aus dem Leben vor: Um ein Symbol durch ein Ereignis zu kolorieren und zu animieren, etwa so: </font></font><br><br><img src="https://habrastorage.org/webt/vf/py/hx/vfpyhxhdazg6fjxqoehf7rrxatk.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alles Code ist nichts: </font></font><br><br><img src="https://habrastorage.org/webt/ep/8c/ft/ep8cfthhe8trsxv3hes_vnblydu.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richtig, gemäß den Regeln von BEM müssen Sie ihn in drei Verzeichnisse </font></font><br><br><img src="https://habrastorage.org/webt/5y/7g/vg/5y7gvgsg4rg--bdw4ksuqymoyuq.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sortieren </font><font style="vertical-align: inherit;">: </font><font style="vertical-align: inherit;">Overshot? Ein strittiger Punkt. Noch wichtiger ist, dass wir in js diese Klassen manuell hinzufügen, wenn die erforderlichen Ereignisse auftreten. Die übliche Situation, aber je benutzerdefinierter oder komplexer die Benutzeroberfläche ist, desto häufiger müssen Sie Klassen hinzufügen und entfernen. Und wenn Sie nicht nur das Symbol, sondern auch den Text ändern müssen? Nicht genau die Logik, die Sie im js-Code sehen möchten: </font></font><br><br><img src="https://habrastorage.org/webt/ft/u9/bn/ftu9bn7g6ghzbepl6gomyezebyy.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber was ist, wenn die Dauer der Animation von etwas abhängt und dynamisch eingestellt wird? Dann werden wir die CSS-Animation in jQuery umschreiben und ein wenig traurig sein.</font></font><br><br><h4>  Ist geworden </h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Styled-Komponenten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ich liebe dich! </font><font style="vertical-align: inherit;">CSS in JS - eine Liebe! </font><font style="vertical-align: inherit;">Mein innerer Schriftsetzer freut sich: Die </font></font><br><br><img src="https://habrastorage.org/webt/pi/gp/b_/pigpb_it2ewws2q0ehn_oxsu_p8.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modularität bleibt erhalten, CSS-Animation funktioniert und keine manuelle Arbeit mit Klassen. </font><font style="vertical-align: inherit;">Ein schöner Bonus für den neuen Stack.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tippen </font></font></h2><br><h4>  War </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben Tonnen von jsDoc geschrieben. </font><font style="vertical-align: inherit;">Mal sehen, ob es nützlich ist: </font></font><br><br><img src="https://habrastorage.org/webt/9-/fd/nf/9-fdnf3jssnze_gloxnkforgp6u.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieses Beispiel stammt aus dem Produktionscode. </font><font style="vertical-align: inherit;">Was enthält der Staat? </font><font style="vertical-align: inherit;">Ich habe keine Ahnung. </font><font style="vertical-align: inherit;">Ja, es gibt eine Readme-Datei, aber leider ist sie etwas veraltet. </font><font style="vertical-align: inherit;">Ja, wir schämen uns, aber mit Dokumentationen und Kommentaren, die häufig vorkommen, sind sie unzuverlässig. </font><font style="vertical-align: inherit;">Muss in den Code eintauchen. </font><font style="vertical-align: inherit;">Oder gehen Sie nicht tief und brechen Sie versehentlich alles. </font><font style="vertical-align: inherit;">Wir haben es eilig, gehen nicht tief, brechen und fühlen uns traurig.</font></font><br><br><h4>  Ist geworden </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Tippen kam zur Rettung. </font><font style="vertical-align: inherit;">"Tyk" über den Typ und alle Vor- und Nachteile der Methode vor meinen Augen. </font><font style="vertical-align: inherit;">Zu faul um zu verstehen? </font><font style="vertical-align: inherit;">Precommit Checker startet den </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und Sie müssen es noch herausfinden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich mochte Flow auf den ersten Blick nicht. </font><font style="vertical-align: inherit;">Termine sind an, der Manager pingt, und Sie haben "kann kein Eigentum bekommen", und hier "Eigentum fehlt". </font><font style="vertical-align: inherit;">Aber kürzlich wurde mir gesagt, dass Typen von O_o entworfen werden können. Wie kann man nach Typen entwerfen? </font><font style="vertical-align: inherit;">So etwas in der Art: </font></font><br><br><img src="https://habrastorage.org/webt/_d/ud/_4/_dud_4ofrwr_idp9qdxmqoejdlg.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meine Welt hat sich auf den Kopf gestellt. </font><font style="vertical-align: inherit;">Flow ist kein Albtraum mehr. </font><font style="vertical-align: inherit;">Es war praktisch und nützlich, die API-Module vor dem Schreiben des Codes mit Typen zu beschreiben. </font><font style="vertical-align: inherit;">Zuverlässiger Code - ein schöner Bonus!</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Also kein BEM mehr? </font></font></h1><br>  Nein.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BEM lebt und wir unterstützen weiterhin Anwendungen auf dem BEM-Stack. </font><font style="vertical-align: inherit;">Mit der Zeit werden sie auch zu React wechseln, aber jetzt bereiten wir den Weg dafür vor: Wir übersetzen Komponentenbibliotheken, bilden eine Reihe von Tools und Vereinbarungen und lernen, wie Migrationsdaten geplant werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei BEM ist unsere E-Mail-Newsletter-Vorlagen-Engine implementiert. </font><font style="vertical-align: inherit;">Wir bereiten Briefe auf dem Server vor, und die oben beschriebenen Einschränkungen der BEM-Plattform wirken sich nicht auf diese Anwendung aus. </font><font style="vertical-align: inherit;">Die Verwendung von BEM zur Entwicklung ist eine geeignete elegante Lösung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Darüber hinaus verwenden unsere Designer </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prototypen mit BEM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und bringen uns manchmal vormontierte Komponenten anstelle von Layouts. </font><font style="vertical-align: inherit;">Und selbst wenn wir aufhören, über BEM zu schreiben, wird er uns immer noch finden :)</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe den ersten Teil gelesen. </font><font style="vertical-align: inherit;">Was ist mit Codierern?</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe an der Übersetzung einer der Anwendungen von BEM nach React teilgenommen und eine wichtige Sache herausgefunden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor ich zu Yandex.Money kam, war ich ein einfacher Schriftsetzer und verbrachte mehr als ein Jahr, kilometerlange Tonnen von HTML und JSX. Ich habe die Front-End-Community und ihre sich verändernde Welt nicht ernst genommen. Ich verstand nicht, warum ich den ersten Winkel studieren sollte, um ihn morgen zu vergessen und den zweiten zu studieren. Ich habe nicht verstanden, warum jQuery.Ajax in Fetch geändert und dann Fetch durch Axios ersetzt wird.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es stellte sich heraus, dass Sie beim Übertragen eines Projekts von einem Framework auf ein anderes nicht nur den Code portieren. </font><font style="vertical-align: inherit;">Wir müssen die Architektur der Anwendung analysieren und verbessern, die Logik begradigen, den Refactor. </font><font style="vertical-align: inherit;">Ein ständiger Werkzeugwechsel ist kein Versuch, die Hype-Welle zu bewältigen, sondern eine ständige Suche nach der besten Lösung, die den Anforderungen der Zeit entspricht. </font><font style="vertical-align: inherit;">Ein sich dynamisch entwickelndes Feld wie nichts anderes trägt zur Entwicklung Ihres Produkts bzw. Ihrer beruflichen Entwicklung bei. </font><font style="vertical-align: inherit;">Und das Frontend ist genau so ein Bereich. </font><font style="vertical-align: inherit;">Lasst uns gemeinsam dafür kämpfen! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reagiere auf alle!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414183/">https://habr.com/ru/post/de414183/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414173/index.html">Atmosphärische Lichtstreuung in weniger als vier Kilobyte</a></li>
<li><a href="../de414175/index.html">Extrahieren Sie Entitäten aus dem Text mit Stanford NLP von Grund auf neu</a></li>
<li><a href="../de414177/index.html">Animierte Übergänge in mobilen Anwendungen</a></li>
<li><a href="../de414179/index.html">Oh, mein Code: Wie man ein IT-Leader wird</a></li>
<li><a href="../de414181/index.html">Großer CreatBot D600 3D-Drucker</a></li>
<li><a href="../de414185/index.html">Zellschlüssel: wie man ein lebendes Membrantor öffnet</a></li>
<li><a href="../de414187/index.html">Warum zu einem IT-Master gehen?</a></li>
<li><a href="../de414189/index.html">Die Boring Company verbindet die Innenstadt von Chicago über Tunnel mit dem Flughafen</a></li>
<li><a href="../de414195/index.html">Cisco StealthWatch oder klassische Sicherheitsfunktionen für Unternehmensnetzwerke (FW, IPS, ACL, NAC, AV, SIEM)?</a></li>
<li><a href="../de414197/index.html">Schwarze Markierung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>