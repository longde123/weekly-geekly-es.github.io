<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🈲 🌺 🏆 Pendekatan sistematis untuk mempercepat: pengukuran online di ujung depan 🧣 📛 ↕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Perintah kecepatan Yandex secara manual mengoptimalkan hasil pencarian. Melakukannya secara membabi buta itu sulit dan seringkali tidak berguna. Oleh ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pendekatan sistematis untuk mempercepat: pengukuran online di ujung depan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/426571/"> Perintah kecepatan Yandex secara manual mengoptimalkan hasil pencarian.  Melakukannya secara membabi buta itu sulit dan seringkali tidak berguna.  Oleh karena itu, perusahaan membangun infrastruktur untuk mengumpulkan metrik, menguji kecepatan, dan menganalisis data. <br><br>  Tentang metrik mana yang harus digunakan dan bagaimana mengoptimalkan semuanya, pengembang antarmuka Yandex <b>Andrei Prokopyuk</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Andre_487</a> ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">tahu</a> . <br><br><img src="https://habrastorage.org/webt/jh/gn/r4/jhgnr48w9fhjphnfjkjcggtsdds.png"><br><br>  Materi ini didasarkan pada pidato Andrey di konferensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HolyJS</a> .  Di bawah cut - and video, dan versi teks laporan. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Whm2FMBIgA0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><blockquote>  Selain laporan pengukuran online ini, ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan oleh Alexei Kalmakov</a> (juga dari Yandex) tentang pengukuran offline, dalam kasusnya tidak ada versi teks, tetapi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">video</a> tersedia. </blockquote><br><br>  Hasil pencarian Yandex terdiri dari banyak blok berbeda, kelas jawaban untuk pertanyaan pengguna.  Lebih dari 50 orang mengerjakannya di perusahaan, dan agar tingkat penerbitannya tidak turun, kami terus-menerus menjaga perkembangannya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/044/4e1/e2a/0444e1e2a6db39e37b9c2a085c7433db.jpg"><br><br>  Tidak ada yang akan berpendapat bahwa pengguna lebih suka antarmuka cepat daripada yang lambat.  Tetapi sebelum Anda mulai mengoptimalkan, penting untuk memahami bagaimana ini akan memengaruhi bisnis Anda.  Apakah pengembang perlu menghabiskan waktu mempercepat antarmuka jika ini tidak memengaruhi metrik bisnis? <br><br>  Untuk menjawab pertanyaan ini, saya akan menceritakan dua kisah. <br><br><h2>  Sejarah pengenalan font web spesifik pada penerbitan </h2><br>  Setelah membuat percobaan dengan font, kami menemukan bahwa waktu rata-rata untuk merender konten memburuk sebesar 3%, sebesar 62 milidetik.  Tidak terlalu banyak jika Anda mengambilnya untuk delta dalam ruang hampa.  Penundaan yang terlihat dengan mata telanjang dimulai dengan hanya 100 milidetik - namun waktu hingga klik pertama segera meningkat satu setengah persen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ef/2b5/548/4ef2b5548ae1789980552312d0b92857.jpg"><br><br>  Pengguna mulai berinteraksi kemudian dengan halaman.  Jumlah halaman yang diklik menurun hampir setengah persen.  Waktu kehadiran pada layanan berkurang dan waktu ketidakhadiran meningkat. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c15/215/b5f/c15215b5fb72633582890da9e018d4a4.jpg"><br><br>  Kami tidak memulai fitur dengan font.  Bagaimanapun, angka-angka ini tampak kecil sampai Anda ingat skala layanan.  Pada kenyataannya, satu setengah persen - ratusan ribu orang. <br><br>  Selain itu, kecepatan memiliki efek kumulatif.  Untuk satu pembaruan dengan bagian yang tidak diklaim - 0,4% akan mengikuti semakin banyak.  Di Yandex, fitur-fitur seperti itu diluncurkan dalam lusinan per hari, dan jika Anda tidak berjuang untuk setiap bagian, itu tidak akan bertahan lama dan mencapai 10%. <br><br><h2>  Sejarah Caching LS </h2><br>  Kisah ini terkait dengan fakta bahwa kami memasukkan banyak konten statis ke halaman. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c33/3fd/7d2/c333fd7d205cc0695c8934cb0111c820.jpg"><br><br>  Karena variabilitasnya yang tinggi, kami tidak dapat mengompilasinya menjadi satu bundel atau mengirimkannya dengan sumber daya eksternal.  Praktek telah menunjukkan bahwa dengan pengiriman inline, rendering, dan inisialisasi JavaScript adalah yang tercepat. <br><br>  Setelah kami memutuskan bahwa menggunakan repositori browser akan menjadi ide yang bagus.  Masukkan semua yang ada di localStorage dan, setelah entri berikutnya ke halaman, muat dari sana, dan tidak mengirimkannya melalui jaringan. <br><br>  Kemudian kami berfokus terutama pada metrik "ukuran HTML" dan "waktu pengiriman HTML" dan mendapatkan hasil yang baik.  Seiring berjalannya waktu, kami menemukan metode baru untuk mengukur kecepatan, memperoleh pengalaman, dan memutuskan untuk mengecek, melakukan eksperimen terbalik, mematikan optimisasi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3b9/37c/2c9/3b937c2c9c4f0a85c2e76a26d6fdfacf.jpg"><br><br>  Waktu pengiriman HTML rata-rata (metrik kunci pada saat pengembangan optimasi) meningkat sebesar 12%, yang banyak.  Tetapi pada saat yang sama, waktu sampai header diambil, sebelum penguraian konten dimulai, dan sebelum JavaScript diinisialisasi.  Juga mengurangi waktu untuk klik pertama.  Persentasenya kecil - 0,6, tetapi jika Anda ingat skalanya ... <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f88/35c/0fd/f8835c0fdce5780914f129f41f445f8d.jpg"><br><br>  Dengan menonaktifkan pengoptimalan, kami mendapatkan metrik yang memburuk, hanya terlihat oleh spesialis, dan pada saat yang sama, peningkatan terlihat oleh pengguna. <br><br>  Kesimpulan berikut dapat ditarik dari ini: <br><br>  Pertama, kecepatan sangat memengaruhi metrik bisnis dan bisnis. <br><br>  Kedua, optimasi harus didahului dengan pengukuran.  Jika Anda menerapkan sesuatu, setelah melakukan pengukuran yang buruk, kemungkinan Anda tidak akan melakukan sesuatu yang bermanfaat.  Komposisi audiens, armada perangkat, skenario interaksi, dan jaringan berbeda di mana-mana, dan Anda perlu memeriksa apa yang akan bekerja untuk Anda. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0bf/2c6/06b/0bf2c606bacfb7bc5769594fbc326a52.jpg"><br><br>  Suatu kali, Ash mengajar kita dari kematian yang jahat pertama-tama untuk menembak, lalu berpikir atau tidak berpikir sama sekali.  Anda tidak harus melakukan ini dengan cepat. <br><br>  Dan poin ketiga: pengukuran harus mencerminkan pengalaman pengguna.  Misalnya, ukuran HTML dan waktu pengiriman adalah metrik kecepatan yang buruk karena pengguna tidak duduk dengan devTools dan tidak memilih layanan dengan penundaan lebih sedikit.  Tetapi metrik apa yang baik dan benar - kami akan memberi tahu lebih lanjut. <br><br><h2>  Apa dan bagaimana mengukur? </h2><br>  Pengukuran harus dimulai dengan beberapa metrik kunci yang, tidak seperti, misalnya, ukuran HTML, dekat dengan pengalaman pengguna. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec1/3c5/783/ec13c57830d7b1b3b8380273dda5bbc8.jpg"><br><br>  Jika TTFCP (time to first contentfull paint) dan TTFMP (time to first paintfull) menunjukkan waktu hingga rendering pertama konten dan waktu sebelum rendering konten yang signifikan, maka yang ketiga adalah waktu sebelum kerangka kerja diinisialisasi, perlu dijelaskan. <br><br>  Ini adalah waktu ketika kerangka kerja telah melewati halaman, mengumpulkan semua data yang diperlukan dan menggantung penangannya.  Jika pengguna mengklik suatu tempat pada saat itu, ia akan menerima respons dinamis. <br><br>  Dan yang terakhir, metrik keempat, waktu hingga interaktivitas pertama, biasanya disebut sebagai waktu untuk interaktif (TTI). <br><br>  Metrik ini, tidak seperti ukuran html atau waktu pengiriman, dekat dengan pengalaman pengguna. <br><br><h2>  Saatnya pertama puas cat </h2><br>  Untuk mengukur waktu ketika pengguna melihat konten pertama pada halaman, ada API Paint Timing, sejauh ini hanya tersedia dalam chromium.  Data dari itu dapat diperoleh dengan cara berikut. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e16/80a/c27/e1680ac270e35eaad20070c90e47066d.jpg"><br><br>  Dengan panggilan ini, kami mendapatkan serangkaian acara rendering.  Sejauh ini, dua jenis acara didukung: cat pertama - render apa saja dan cat pertama puas - render konten apa pun selain latar belakang putih dari tab kosong dan konten latar belakang halaman. <br><br>  Jadi kami mendapatkan berbagai acara, memfilter cat pertama yang puas dan mengirim dengan ID tertentu. <br><br><h2>  Saatnya untuk melukis bermakna pertama </h2><br>  Tidak ada kejadian dalam Paint Timing API yang menandakan bahwa konten signifikan telah diberikan pada halaman.  Ini disebabkan oleh kenyataan bahwa konten tersebut pada setiap halaman berbeda.  Jika kita berbicara tentang layanan video, maka yang utama adalah pemutar, dalam hasil pencarian - hasil non-iklan pertama.  Ada banyak layanan, dan API universal belum dikembangkan.  Tapi di sini bagus, kruk terbukti terbukti ikut bermain. <br><br>  Ada dua sekolah kruk di Yandex untuk mengukur metrik ini: menggunakan RequestAnimationFrame dan mengukur dengan InterceptionObserver. <br><br>  Di RequestAnimationFrame, rendering diukur menggunakan interval. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/22b/dfe/945/22bdfe945df84617220936267638cc21.jpg"><br><br>  Misalkan ada beberapa konten yang signifikan.  Berikut adalah div dengan konten utama kelas.  Sebuah skrip ditempatkan di depannya, di mana RequestAnimationFrame dipanggil dua kali. <br><br>  Dalam panggilan balik dari panggilan pertama, tulis batas bawah dari interval.  Dalam panggilan balik yang kedua - atas.  Ini disebabkan oleh struktur bingkai yang dibuat oleh browser. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/79d/783/a88/79d783a883b6a718095228cfbea29469.jpg"><br><br>  Yang pertama adalah eksekusi JavaScript, kemudian analisis gaya, lalu perhitungan Layout, rendering, dan komposisi. <br><br>  Callback, memanggil RequestAnimationFrame, diaktifkan pada tahap yang sama dengan JavaScript, dan konten ditampilkan di bagian terakhir frame selama komposisi.  Oleh karena itu, dalam panggilan pertama, kita hanya mendapatkan batas bawah, yang secara nyata dihapus dalam waktu dari output piksel pada layar. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/81c/788/f38/81c788f38c68e241cf3a34612503f9d0.jpg"><br><br>  Tempatkan dua bingkai berdampingan.  Dapat dilihat bahwa pada akhir yang pertama kontennya diberikan.  Kami menuliskan batas bawah RequestAnimationFrame, dipanggil di dalam panggilan balik pertama, dan panggilan balik di bingkai kedua.  Dengan demikian, kita mendapatkan interval dari JavaScript yang disebut dalam bingkai tempat konten diberikan ke JavaScript di bingkai kedua. <br><br><h2>  InterceptionObserver </h2><br>  Tongkat kedua kami dengan konten yang sama berfungsi berbeda.  Kali ini skrip ditempatkan di bawah.  Di dalamnya kita membuat InterceptionObserver dan berlangganan domNode. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd6/dea/87d/fd6dea87dd53e374e2ba19aa79d4a379.jpg"><br><br>  Kami tidak melewati parameter tambahan, jadi kami mengukur persimpangannya dengan viewport.  Waktu ini dicatat sebagai waktu rendering yang tepat. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/549/5ab/d02/5495abd0268d0d59077d00ade282989a.jpg"><br><br>  Ini berfungsi karena persimpangan konten utama dan viewport adalah persimpangan persis yang dilihat pengguna.  API ini dirancang untuk mengetahui secara pasti kapan pengguna melihat iklan, tetapi penelitian kami menunjukkan bahwa ini juga berfungsi pada unit non-iklan. <br><br>  Dari dua metode ini, masih lebih baik untuk menggunakan RequestAnimationFrame: dukungannya lebih luas, dan dalam praktiknya lebih baik diuji oleh kami. <br><br><h2>  Js inited </h2><br>  Bayangkan sebuah kerangka kerja yang memiliki semacam acara "init" yang dapat Anda ikuti, tetapi ingatlah bahwa dalam praktiknya JS Inited adalah metrik yang sederhana dan kompleks. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3bf/6fe/85c/3bf6fe85c743f0ad6c255d8e4c448eae.jpg"><br><br>  Sederhana - karena Anda hanya perlu menemukan momen ketika kerangka kerja telah menyelesaikan pengaturan acara.  Kompleks - karena Anda harus mencari titik ini sendiri untuk setiap kerangka kerja. <br><br><h2>  Saatnya interaktif </h2><br>  TTI sering bingung dengan metrik sebelumnya, tetapi sebenarnya ini merupakan indikator saat arus utama peramban dirilis.  Selama pemuatan halaman, banyak tugas dilakukan: dari merender berbagai elemen hingga menginisialisasi kerangka kerja.  Hanya ketika diturunkan, saatnya tiba untuk interaktivitas pertama. <br><br>  Konsep tugas panjang dan API Tugas Panjang membantu mengukur hal ini. <br><br>  Pertama tentang tugas panjang. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f79/67b/828/f7967b8283a7302b1d8d9b1bd076cfac.jpg"><br><br>  Di antara tugas singkat yang ditunjukkan oleh panah, browser dapat dengan mudah menjejalkan pemrosesan acara pengguna, misalnya, input, karena memiliki prioritas tinggi.  Tetapi dengan tugas panjang yang ditunjukkan oleh panah merah, ini tidak akan berhasil. <br><br>  Pengguna harus menunggu sampai kehabisan, dan hanya setelah browser melakukan pemrosesan inputnya.  Pada saat yang sama, kerangka kerja sudah dapat diinisialisasi, dan tombol-tombol akan bekerja, tetapi perlahan.  Respons yang ditangguhkan seperti itu adalah pengalaman pengguna yang agak tidak menyenangkan.  Saat ketika Tugas Panjang terakhir selesai dan utas kosong untuk waktu yang lama, ilustrasi muncul pada 7 detik dan 300 milidetik. <br><br>  Bagaimana cara mengukur interval ini di dalam JavaScript? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/66f/f1b/114/66ff1b114d718aa4e31cf8c2f1094525.jpg"><br><br>  Langkah pertama secara kondisional ditetapkan sebagai tag badan pembuka, setelah itu muncul skrip.  Ini menciptakan PerformanceObserver yang berlangganan acara Tugas Panjang.  Di dalam callback PerformanceObserver, informasi acara dikumpulkan ke dalam array. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3e3/1c4/c60/3e31c4c60298c19431ca84a93c908394.jpg"><br><br>  Setelah mengumpulkan data, saatnya tiba untuk langkah kedua.  Ini ditetapkan secara kondisional sebagai tag tubuh penutup.  Kami mengambil elemen terakhir dari array, tugas panjang terakhir, melihat saat penyelesaiannya dan memeriksa apakah cukup waktu telah berlalu. <br><br>  Dalam karya asli pada metrik ini, 5 detik diambil sebagai konstanta, tetapi pilihannya tidak dibuktikan dengan cara apa pun.  Ternyata cukup untuk 3 detik.  Jika 3 detik berlalu, kami menghitung waktu hingga interaktivitas pertama, jika tidak, kami menyetel TimeTime dan memeriksa konstanta ini lagi. <br><br><h2>  Bagaimana cara mengolah data? </h2><br>  Data perlu diterima dari pelanggan, diproses dan disajikan dengan cara yang mudah.  Konsep kami mengirim data cukup sederhana.  Ini disebut penghitung. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/38f/158/cba/38f158cbaf1233223fdca1ba255f9e25.jpg"><br><br>  Kami mentransfer data metrik tertentu ke pena khusus di backend dan mengumpulkannya di repositori. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/884/cda/04a/884cda04a3b619b084dfde376a0645cc.jpg"><br><br>  Di sini, agregasi data secara konvensional ditetapkan sebagai kueri SQL.  Berikut adalah agregasi utama yang biasanya kita pertimbangkan dengan metrik kecepatan: rata-rata aritmatika dan kelompok persentil (50, 75, 95, 99). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/354/84a/d7c/35484ad7c51d967118abb42646a09801.jpg"><br><br>  Rata-rata aritmatika dalam seri numerik kami hampir 1900. Ini terasa lebih besar daripada sebagian besar elemen himpunan, karena agregasi ini sangat sensitif terhadap pencilan.  Properti ini masih berguna bagi kami. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d6b/2ac/b00/d6b2acb00b844c6294fa80a50e03495c.jpg"><br><br>  Untuk menghitung persentil untuk set yang sama, urutkan dan masukkan pointer ke indeks persentil.  Katakanlah yang ke-50, yang juga disebut median.  Kami jatuh di antara elemen-elemen.  Dalam hal ini, Anda dapat keluar dari situasi dengan berbagai cara, kami menghitung rata-rata di antara mereka.  Kami mendapat 150. Bila dibandingkan dengan rata-rata aritmatika, terlihat jelas bahwa persentil tidak peka terhadap pencilan. <br><br>  Kami mempertimbangkan dan menggunakan fitur agregasi ini.  Sensitivitas aritmatika dari emisi adalah kelemahan jika Anda mencoba untuk mengevaluasi pengalaman pengguna dengannya.  Memang, pengguna selalu dapat terhubung ke jaringan, misalnya, dari kereta, dan merusak pilihan. <br><br>  Tetapi sensitivitas yang sama adalah keuntungan dalam hal pemantauan.  Agar tidak ketinggalan masalah penting, kami menggunakan rata-rata aritmatika.  Ini mudah berubah, tetapi risiko false positive dalam kasus ini bukan masalah besar.  Lebih baik diabaikan daripada diabaikan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dcb/e92/a6b/dcbe92a6baf2a4ec1e2ef01580dd948d.jpg"><br><br>  Selain itu, kami mempertimbangkan median (jika kami lampirkan ini ke metrik waktu, median adalah indikator waktu di mana 50% dari permintaan cocok) dan persentil ke-75.  75% permintaan sesuai pada saat ini, kami menganggapnya sebagai perkiraan kecepatan keseluruhan.  Persentil ke-95 dan ke-99 dianggap untuk mengukur ekor lambat yang panjang.  Ini jumlah yang sangat besar.  95 dianggap sebagai permintaan paling lambat.  Persentil ke-99 tidak normal. <br><br>  Tidak ada gunanya menghitung maksimum.  Inilah cara menuju kegilaan.  Setelah menghitung maksimum, mungkin ternyata pengguna telah menunggu halaman memuat selama 20 tahun. <br><br>  Setelah mempertimbangkan agregasi, tetap hanya menerapkan angka-angka ini, dan hal yang paling jelas yang dapat dilakukan dengannya adalah menyajikannya dalam grafik. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e8d/552/3e9/e8d5523e9eeebf2545a7f214b75b8ede.jpg"><br><br>  Pada grafik, waktu nyata kami untuk pertama kali menyelesaikan metrik cat untuk pencarian.  Garis biru mencerminkan dinamika untuk desktop, merah untuk perangkat seluler. <br><br>  Kami harus terus memantau grafik kecepatan, dan kami mempercayakan tugas ini kepada robot. <br><br><h2>  Pemantauan </h2><br>  Karena kecepatan metrik berubah-ubah dan berfluktuasi terus-menerus dengan periode yang berbeda, pemantauan perlu disesuaikan.  Untuk ini kami menggunakan konsep frustrasi. <br><br>  Debugging adalah momen ketika proses acak mengubah karakteristiknya, seperti varians atau ekspektasi matematis.  Dalam kasus kami, ini adalah sampel rata-rata.  Seperti disebutkan, rerata sensitif terhadap emisi dan cocok untuk pemantauan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/621/9a7/c0b/6219a7c0bc99aef5991cda07179a487a.jpg"><br><br>  Berikut adalah contoh grafik di mana penyelarasan terjadi dan robot merekam kejadian tersebut.  Bagaimana dia mengisolasi momen ini dari sejumlah keraguan lainnya?  Untuk memahami ini, kami memberlakukan data tambahan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/93e/d21/ec4/93ed21ec4f2a624e3d703dc90b2c2530.jpg"><br><br>  Grafik kuning adalah indikator metrik, dan grafik biru adalah rata-rata bergerak dengan periode yang cukup besar.  Merah adalah rata-rata ditambah tiga standar deviasi.  Hijau sama, hanya dengan tanda minus. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4c8/899/b90/4c8899b90f7e2696100aa4c7069a868c.jpg"><br><br>  Indikator merah dan hijau membentuk koridor yang aman.  Sementara metrik dan rata-rata bergerak berfluktuasi di antara mereka - semuanya normal, ini adalah fluktuasi biasa.  Tetapi jika mereka meninggalkan zona aman, pemantauan dipicu. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9fb/d41/25e/9fbd4125ece689bd90a84e520304fd3a.jpg"><br><br><h2>  Memeriksa fitur untuk kecepatan </h2><br>  Semua yang dibahas adalah bekerja dengan data kecepatan dari proyek yang sudah diluncurkan, tetapi saya ingin mengukur kecepatan fitur individu sebelum mengirimnya ke produksi besar.  Untuk melakukan ini, kami menggunakan pengujian A / B - perbandingan metrik untuk kelompok kontrol dan eksperimen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/819/128/e94/819128e94c08fec52e22da5914d28cbe.jpg"><br><br>  Kami membagi pengguna menjadi grup kontrol dan eksperimental.  Pembacaan masing-masing slot dikumpulkan secara terpisah, dikumpulkan dan ditabulasi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/31d/89b/1eb/31d89b1eb1915e2a0f8f29bc986f0521.jpg"><br><br>  Dalam pengujian A / B, sebagai aturan, rata-rata aritmatika juga digunakan.  Di sini kita melihat delta dan, untuk menentukan secara akurat apakah itu kecelakaan atau hasil yang signifikan, uji statistik diterapkan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e78/37d/134/e7837d1340c59e00cf61a132c6ac72c9.jpg"><br><br>  Ini ditunjuk sebagai “MW” karena tes Mann-Whitney digunakan dalam perhitungan.  Dengan bantuannya, apa yang disebut "persentase kebenaran" dihitung.  Indikator ini memiliki ambang, setelah itu kita menganggap delta sebagai benar.  Ini sudah diatur pada 99,9%. <br><br>  Ketika tes mencapai nilai ini, delta disorot di antarmuka.  Kami menyebutnya pewarnaan.  Di sini kita melihat hijau, yaitu pewarnaan yang tepat waktu untuk melukis penuh konten pertama.  Waktu untuk cat bermakna pertama tidak mencapai nilai ini, yaitu, delta juga baik, tetapi tidak 99,9%.  Benar-benar mustahil untuk memercayainya.  Setelah inisialisasi kerangka kerja dan waktu untuk interaktif, pewarnaan merah buruk percaya diri diamati.  Dari sini kita dapat menarik kesimpulan yang sama seperti pada font. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/25b/415/b14/25b415b14b30b25549f514aced7b52dd.jpg"><br><br><h2>  Bagaimana cara melakukannya sendiri? </h2><br>  Anda dapat menerapkan pengukuran kecepatan dengan dua cara.  Yang pertama adalah melakukan semuanya sendiri. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e30/344/cb5/e30344cb56179ed9a633ff26c187291e.jpg"><br><br>  Pegangan untuk menerima data dari klien, backend, yang menempatkan semua ini ke dalam basis data, MongoDB, PostgreSQL, MySQL, semua DBMS (mereka memiliki agregasi di luar kotak), ditambah salah satu dari banyak solusi open source - untuk menggambar grafik dan mengatur pemantauan. <br><br>  Solusi kedua adalah menggunakan Yandex Metric atau sistem analisis Google Analytics.  Pada contoh Metrik Yandex, terlihat seperti ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/424/a97/f61/424a97f61a797dff9419d7df8828046b.jpg"><br><br>  Berikut adalah metrik yang disediakan pengguna dari kotak.  Tentu saja, ini bukan semuanya di atas, tetapi sudah sesuatu.  Sisanya dapat ditambahkan secara manual melalui pengaturan pengguna.  Pengujian dan pemantauan A / B juga tersedia. <br><br><h2>  Kesimpulan </h2><br>  Konsep pengukuran kecepatan online yang kita bicarakan dikenal sebagai RUM - Pemantauan Pengguna Nyata.  Kami sangat mencintainya sehingga kami bahkan membuat logo dengan umlaut rock and roll yang keren. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e5f/8a9/448/e5f8a94489f01743c09e5ec04453cc56.jpg"><br><br>  Pendekatan ini baik karena didasarkan pada angka-angka dari dunia nyata, indikator-indikator yang dimiliki oleh audiens layanan Anda.  Dengan menggunakan metrik, Anda tampaknya mendapat umpan balik dari setiap pengguna.  Jadi mulailah mengoptimalkan dan jangan berhenti. <br><blockquote>  Pengumuman di akhir.  Jika Anda menyukai pembicaraan ini dengan <b>HolyJS 2018 Piter</b> , Anda mungkin akan tertarik dengan <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HolyJS 2018 Moscow</a></b> yang akan datang, yang akan <b>diadakan 24-25 November</b> .  Di sana Anda tidak hanya dapat melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">banyak</a> laporan JS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lainnya</a> , tetapi juga meminta pembicara apa pun di area diskusi setelah laporan.  Dan besok, mulai 1 November, harga tiket akan naik ke final, jadi hari ini adalah kesempatan terakhir untuk membelinya dengan diskon! </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id426571/">https://habr.com/ru/post/id426571/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id426559/index.html">Jaringan saraf untuk pemrosesan gambar. Kata Alexander Savsunenko dari Skylum Software</a></li>
<li><a href="../id426561/index.html">Lima Besar: harus memiliki alat untuk mempercepat pembangunan</a></li>
<li><a href="../id426563/index.html">Buku alamat hierarki, perubahan email primer dan inovasi lainnya di Zimbra 8.8.10</a></li>
<li><a href="../id426565/index.html">“Dunia Jawa tidak akan pernah sama lagi” - wawancara dengan Alexander Belokrylov dan Alexey Voitilov dari BellSoft</a></li>
<li><a href="../id426567/index.html">Buku “Kekacauan matematika. Dari Matematika Dasar hingga Abstraksi Sublim ”</a></li>
<li><a href="../id426573/index.html">ZeroNights 2018. Reload</a></li>
<li><a href="../id426575/index.html">Laporan Club of Rome 2018, Bab 1.12: “Dari Dunia yang Kosong ke Dunia yang Lengkap”</a></li>
<li><a href="../id426579/index.html">Engie dan Ledger mengembangkan solusi blockchain perangkat keras untuk menyimpan data yang dihasilkan oleh sumber energi hijau</a></li>
<li><a href="../id426581/index.html">Buka pelajaran "Gambaran Umum fitur Node.js"</a></li>
<li><a href="../id426583/index.html">Sepuluh orang di 90 ribu situs: bagaimana tidak menjadi gila</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>