<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕦 🥢 📒 Unité: dessinez plusieurs barres de vie en un seul appel 📿 👨🏻‍🚀 🤹🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Récemment, j'ai dû résoudre un problème qui est assez courant dans de nombreux jeux avec une vue de dessus: pour afficher à l'écran tout un tas de bar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unité: dessinez plusieurs barres de vie en un seul appel</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447716/">  Récemment, j'ai dû résoudre un problème qui est assez courant dans de nombreux jeux avec une vue de dessus: pour afficher à l'écran tout un tas de barres de santé ennemies.  Quelque chose comme ça: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/14e/081/95e/14e08195e0e331c7f24a8ba50c556d7e.png"></div><br>  Évidemment, je voulais le faire le plus efficacement possible, de préférence en un seul appel.  Comme d'habitude, avant de commencer le travail, j'ai fait une petite recherche en ligne sur les décisions des autres et les résultats étaient très différents. <br><br>  Je ne ferai honte à personne pour le code, mais il suffit de dire que certaines des solutions n'étaient pas entièrement brillantes, par exemple, quelqu'un a ajouté un objet Canvas à chaque ennemi (ce qui est très inefficace). <br><br>  En conséquence, la méthode à laquelle je suis arrivé est légèrement différente de tout ce que j'ai vu dans d'autres, et n'utilise aucune classe d'interface utilisateur (y compris Canvas), j'ai donc décidé de la documenter pour le public.  Et pour ceux qui veulent apprendre le code source, je l'ai posté <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur Github</a> . <br><a name="habracut"></a><br><h2>  Pourquoi ne pas utiliser Canvas? </h2><br>  Une toile pour chaque ennemi est évidemment une mauvaise décision, mais je pourrais utiliser une toile commune pour tous les ennemis;  un seul canevas entraînerait également le rendu des lots d'appels. <br><br>  Cependant, je n'aime pas la quantité de travail effectuée dans chaque cadre lié à cette approche.  Si vous utilisez Canvas, dans chaque cadre, vous devez effectuer les opérations suivantes: <br><br><ul><li>  Déterminez quels ennemis sont à l'écran et sélectionnez chacun d'eux dans la bande d'interface utilisateur du pool. </li><li>  Projetez la position de l'ennemi dans la caméra pour positionner la bande. </li><li>  Redimensionnez la partie "remplissage" de la bande, probablement comme Image. </li><li>  Très susceptible de changer la taille des bandes en fonction du type d'ennemis;  par exemple, les grands ennemis devraient avoir de larges bandes pour ne pas avoir l'air idiot. </li></ul><br>  Quoi qu'il en soit, tout cela contaminerait les tampons de géométrie Canvas et conduirait à une reconstruction de toutes les données de vertex dans le processeur.  Je ne voulais pas que tout cela soit fait pour un élément aussi simple. <br><br><h2>  En bref sur ma décision </h2><br>  Une brève description de mon processus de travail: <br><br><ul><li>  Nous attachons des objets de bandes d'énergie aux ennemis en 3D. <br><ul><li>  Cela vous permet d'organiser et de couper automatiquement les bandes. </li><li>  La position / taille de la bande peut être ajustée en fonction du type d'ennemi. </li><li>  Nous dirigerons les bandes vers la caméra dans le code en utilisant la transformation, qui est toujours là. </li><li>  Le shader garantit qu'ils restituent toujours au-dessus de tout. </li></ul></li><li>  Nous utilisons Instancing pour rendre toutes les bandes en un seul appel de tirage. </li><li>  Nous utilisons des coordonnées UV procédurales simples pour afficher le niveau de plénitude de la bande. </li></ul><br>  Examinons maintenant la solution plus en détail. <br><br><h2>  Qu'est-ce que l'instanciation? </h2><br>  En travaillant avec des graphiques, la technique standard est utilisée depuis longtemps: plusieurs objets sont combinés ensemble afin d'avoir des données de sommet et des matériaux communs et ils peuvent être rendus en un seul appel de dessin.  C'est exactement ce dont nous avons besoin, car chaque appel de tirage est une charge supplémentaire sur le CPU et le GPU.  Au lieu de faire un seul appel de dessin pour chaque objet, nous les rendons tous en même temps et utilisons un shader pour ajouter de la variabilité à chaque copie. <br><br>  Vous pouvez le faire manuellement en dupliquant les données du sommet du maillage X fois dans un tampon, où X est le nombre maximal de copies pouvant être rendues, puis en utilisant le tableau de paramètres de shader pour convertir / colorer / varier chaque copie.  Chaque copie doit stocker des informations sur son instance numérotée afin d'utiliser cette valeur comme index du tableau.  Ensuite, nous pouvons utiliser l'appel de rendu indexé, qui ordonne de «rendre uniquement à N», où N est le nombre d'instances <em>réellement</em> nécessaires dans la trame actuelle, inférieur au nombre maximal de X. <br><br>  La plupart des API modernes ont déjà du code pour cela, vous n'avez donc pas besoin de le faire manuellement.  Cette opération est appelée "Instanciation";  en fait, il automatise le processus décrit ci-dessus avec des restrictions prédéfinies. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le moteur Unity prend également en charge l'instanciation</a> , il possède sa propre API et un ensemble de macros de shader qui aident à sa mise en œuvre.  Il utilise certaines hypothèses, par exemple, que chaque instance nécessite une transformation 3D complète.  À strictement parler, pour les bandes 2D, ce n'est pas complètement nécessaire - nous pouvons faire des simplifications, mais comme elles le sont, nous les utiliserons.  Cela simplifiera notre shader et fournira également la possibilité d'utiliser des indicateurs 3D, par exemple des cercles ou des arcs. <br><br><h2>  Classe endommageable </h2><br>  Nos ennemis auront un composant appelé <code>Damageable</code> , leur donnant de la santé et leur permettant de subir des dégâts de collisions.  Dans notre exemple, c'est assez simple: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Damageable</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MaxHealth; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DamageForceThreshold = <span class="hljs-number"><span class="hljs-number">1f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DamageForceScale = <span class="hljs-number"><span class="hljs-number">5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CurrentHealth { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CurrentHealth = MaxHealth; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCollisionEnter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Collision other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Collision would usually be on another component, putting it all here for simplicity float force = other.relativeVelocity.magnitude; if (force &gt; DamageForceThreshold) { CurrentHealth -= (int)((force - DamageForceThreshold) * DamageForceScale); CurrentHealth = Mathf.Max(0, CurrentHealth); } } }</span></span></code> </pre> <br><h2>  Objet HealthBar: Position / Turn </h2><br>  L'objet de barre de santé est très simple: en fait, ce n'est qu'un Quad attaché à l'ennemi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/be5/2ef/6e2/be52ef6e247fca661f9136e2835bb5dc.png"><br><br>  Nous utilisons l' <strong>échelle de</strong> cet objet pour rendre la bande longue et mince et la placer directement au-dessus de l'ennemi.  Ne vous inquiétez pas de sa rotation, nous le corrigerons en utilisant le code attaché à l'objet dans <code>HealthBar.cs</code> : <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AlignCamera</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mainCamera != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> camXform = mainCamera.transform; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> forward = transform.position - camXform.position; forward.Normalize(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> up = Vector3.Cross(forward, camXform.right); transform.rotation = Quaternion.LookRotation(forward, up); } }</code> </pre> <br>  Ce code dirige toujours le quad vers la caméra.  Nous <em>pouvons</em> effectuer un redimensionnement et une rotation dans le shader, mais je les implémente ici pour deux raisons. <br><br>  Tout d'abord, l'instanciation d'Unity utilise toujours la transformation complète de chaque objet, et puisque nous transférons toutes les données de toute façon, vous pouvez l'utiliser.  Deuxièmement, le réglage de l'échelle / rotation ici garantit que le parallélogramme de délimitation pour rogner la bande sera toujours vrai.  Si nous avons fait de la tâche de taille et de rotation la responsabilité du shader, alors Unity pourrait tronquer les bandes qui devraient être visibles lorsqu'elles sont proches des bords de l'écran, car la taille et la rotation de leur parallélogramme de délimitation ne correspondront pas à ce que nous allons rendre.  Bien sûr, nous pourrions implémenter notre propre méthode de troncature, mais il est généralement préférable d'utiliser ce que nous avons si possible (le code Unity est natif et a accès à plus de données spatiales que nous). <br><br>  Je vais expliquer comment la bande est rendue après avoir regardé le shader. <br><br><h2>  Shader HealthBar </h2><br>  Dans cette version, nous allons créer une simple bande rouge-vert classique. <br><br>  J'utilise une texture 2x1 avec un pixel vert à gauche et un rouge à droite.  Naturellement, j'ai désactivé le mipmapping, le filtrage et la compression, et défini le paramètre du mode d'adressage sur Clamp, ce qui signifie que les pixels de notre bande seront toujours parfaitement verts ou rouges et ne se répandront pas sur les bords.  Cela nous permettra de modifier les coordonnées de la texture dans le shader pour décaler la ligne séparant les pixels rouges et verts de haut en bas de la bande. <br><br>  <em>(Puisqu'il n'y a que deux couleurs ici, je pourrais simplement utiliser la fonction de pas dans le shader pour revenir au point de l'une ou de l'autre. Cependant, cette méthode est pratique car vous pouvez utiliser une texture plus complexe si vous le souhaitez, et cela fonctionnera de manière similaire pendant la transition. texture moyenne.)</em> <br><br>  Tout d'abord, nous déclarerons les propriétés dont nous avons besoin: <br><br><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"UI/HealthBar"</span></span> { Properties { _MainTex (<span class="hljs-string"><span class="hljs-string">"Texture"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} _Fill (<span class="hljs-string"><span class="hljs-string">"Fill"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) = <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br>  <code>_MainTex</code> est une texture rouge-vert, et <code>_Fill</code> est une valeur de 0 à 1, où 1 est une santé complète. <br><br>  Ensuite, nous devons ordonner le rendu de la bande dans la file d'attente de superposition, ce qui signifie ignorer toute la profondeur de la scène et effectuer le rendu par-dessus tout: <br><br><pre> <code class="cpp hljs"> SubShader { Tags { <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Overlay"</span></span> } Pass { ZTest Off</code> </pre> <br>  La partie suivante est le code du shader lui-même.  Nous écrivons un shader sans éclairage (non éclairé), nous n'avons donc pas à nous soucier de l'intégration avec divers shaders de surface Unity, ce ne sont que quelques shaders de vertex / fragment.  Tout d'abord, écrivez bootstrap: <br><br><pre> <code class="cpp hljs"> CGPROGRAM <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> vertex vert #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> fragment frag #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> multi_compile_instancing #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"UnityCG.cginc"</span></span></span></span></code> </pre> <br>  Pour la plupart, il s'agit d'un amorçage standard, à l'exception de <code>#pragma multi_compile_instancing</code> , qui indique au compilateur Unity ce qui doit être compilé pour Instancing. <br><br>  La structure des sommets doit inclure des données d'instance, nous allons donc procéder comme suit: <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">appdata</span></span></span><span class="hljs-class"> {</span></span> float4 vertex : POSITION; float2 uv : TEXCOORD0; UNITY_VERTEX_INPUT_INSTANCE_ID };</code> </pre> <br>  Nous devons également spécifier ce qui sera exactement dans les données des instances, en plus des processus Unity (transform) pour nous: <br><br><pre> <code class="cpp hljs"> UNITY_INSTANCING_BUFFER_START(Props) UNITY_DEFINE_INSTANCED_PROP(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, _Fill) UNITY_INSTANCING_BUFFER_END(Props)</code> </pre> <br>  Nous signalons donc que Unity doit créer un tampon appelé «Props» pour stocker les données de chaque instance, et à l'intérieur, nous utiliserons un flottant par instance pour une propriété appelée <code>_Fill</code> . <br><br>  Vous pouvez utiliser plusieurs tampons;  cela vaut la peine si vous avez plusieurs propriétés mises à jour à différentes fréquences;  en les divisant, vous pouvez, par exemple, ne pas changer un tampon lorsque vous en changez un autre, ce qui est plus efficace.  Mais nous n'en avons pas besoin. <br><br>  Notre vertex shader fait presque entièrement le travail standard, car la taille, la position et la rotation sont déjà transférées pour se transformer.  Ceci est implémenté en utilisant <code>UnityObjectToClipPos</code> , qui utilise automatiquement la transformation de chaque instance.  On pourrait imaginer que sans instanciation, cela serait généralement une simple utilisation d'une seule propriété de matrice.  mais lorsque vous utilisez l'instanciation à l'intérieur du moteur, il ressemble à un tableau de matrices, et Unity sélectionne indépendamment une matrice appropriée pour cette instance. <br><br>  En outre, vous devez changer UV pour changer l'emplacement du point de transition du rouge au vert conformément à la propriété <code>_Fill</code> .  Voici l'extrait de code correspondant: <br><br><pre> <code class="cpp hljs"> UNITY_SETUP_INSTANCE_ID(v); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fill = UNITY_ACCESS_INSTANCED_PROP(Props, _Fill); <span class="hljs-comment"><span class="hljs-comment">// generate UVs from fill level (assumed texture is clamped) o.uv = v.uv; o.uv.x += 0.5 - fill;</span></span></code> </pre> <br>  <code>UNITY_SETUP_INSTANCE_ID</code> et <code>UNITY_ACCESS_INSTANCED_PROP</code> font toute la magie en accédant à la version correcte de la propriété <code>_Fill</code> partir du tampon constant pour cette instance. <br><br>  On sait qu'à l'état normal, les coordonnées UV d'un quadrilatère couvrent tout l'intervalle de texture, et que la ligne de division de la bande est au milieu de la texture horizontalement.  Par conséquent, de petits calculs mathématiques décalent horizontalement la bande vers la gauche ou la droite, et la valeur de serrage de la texture assure le remplissage de la partie restante. <br><br>  Le fragment shader ne pourrait pas être plus simple car tout le travail a déjà été fait: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tex2D(_MainTex, i.uv);</code> </pre> <br>  Le code de nuanceur de commentaires complet est disponible dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le référentiel GitHub</a> . <br><br><h2>  Matériel Healthbar </h2><br>  Ensuite, tout est simple - il suffit d'affecter à notre bande le matériau utilisé par ce shader.  Il n'y a presque plus rien à faire, il suffit de sélectionner le shader souhaité dans la partie supérieure, d'attribuer une texture rouge-vert et, plus important encore, de <strong>cocher la case «Activer l'instance GPU»</strong> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/06e/6e0/dcd/06e6e0dcd1965aa73f1dbbcf64e90a22.png" alt="image"><br><br><h2>  Mise à jour de la propriété de remplissage HealthBar </h2><br>  Donc, nous avons l'objet barre de santé, le shader et le matériau à rendre, nous devons maintenant définir la propriété <code>_Fill</code> pour chaque instance.  Nous faisons cela dans <code>HealthBar.cs</code> comme suit: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateParams</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { meshRenderer.GetPropertyBlock(matBlock); matBlock.SetFloat(<span class="hljs-string"><span class="hljs-string">"_Fill"</span></span>, damageable.CurrentHealth / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)damageable.MaxHealth); meshRenderer.SetPropertyBlock(matBlock); }</code> </pre> <br>  Nous transformons le <code>CurrentHealth</code> classe <code>CurrentHealth</code> en une valeur de 0 à 1, en le divisant par <code>MaxHealth</code> .  Ensuite, nous le transmettons à la propriété <code>_Fill</code> aide de <code>MaterialPropertyBlock</code> . <br><br>  Si vous n'avez pas utilisé <code>MaterialPropertyBlock</code> pour transférer des données vers des shaders, même sans instanciation, vous devez les étudier.  Il n'est pas bien expliqué dans la documentation Unity, mais c'est le moyen le plus efficace pour transférer des données de chaque objet vers des shaders. <br><br>  Dans notre cas, lorsque l'instanciation est utilisée, les valeurs de toutes les barres de santé sont regroupées dans un tampon constant afin qu'elles puissent être transférées ensemble et dessinées à la fois. <br><br>  Il n'y a presque rien ici, sauf un passe-partout pour définir des variables, et le code est plutôt ennuyeux;  voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le référentiel GitHub pour</a> plus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de</a> détails. <br><br><h2>  Démo </h2><br>  Le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">référentiel GitHub</a> a une démo de test dans laquelle un tas de cubes bleus maléfiques sont détruits par des sphères rouges héroïques (hourra!), Prenant les dégâts affichés par les rayures décrites dans l'article.  Démo écrite en Unity 2018.3.6f1. <br><br>  L'effet de l'instanciation peut être observé de deux manières: <br><br><h3>  Panneau Statistiques </h3><br>  Après avoir cliqué sur Play, cliquez sur le bouton Stats au-dessus du panneau Game.  Ici, vous pouvez voir combien d'appels de tirage sont enregistrés grâce à l'instanciation: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad0/f25/204/ad0f25204bb3daf73a2c3700fd185938.png" alt="image"><br><br>  Après avoir lancé le jeu, vous pouvez cliquer sur le matériel HealthBar et <em>décocher la case</em> «Activer l'instance GPU», après quoi le nombre d'appels enregistrés sera réduit à zéro. <br><br><h3>  Débogueur d'images </h3><br>  Après avoir lancé le jeu, allez dans Fenêtre&gt; Analyse&gt; Débogueur d'images, puis cliquez sur «Activer» dans la fenêtre qui apparaît. <br><br>  En bas à gauche, vous verrez toutes les opérations de rendu effectuées.  Notez que bien qu'il existe de nombreux défis distincts pour les ennemis et les obus (si vous le souhaitez, vous pouvez également implémenter l'instanciation pour eux).  Si vous faites défiler vers le bas, vous verrez l'élément "Draw Health Mesh (instanced) Healthbar". <br><br>  Cet appel unique rend toutes les bandes.  Si vous cliquez sur cette opération, puis sur l'opération, vous verrez que toutes les bandes disparaissent, car elles sont dessinées en un seul appel.  Si vous êtes dans le débogueur de trame, vous décochez la case Activer l'instance GPU du matériau, vous verrez qu'une ligne se transforme en plusieurs, et après avoir défini à nouveau l'indicateur en une. <br><br><h2>  Comment étendre ce système </h2><br>  Comme je l'ai déjà dit, puisque ces barres de santé sont de vrais objets, rien ne vous empêche de transformer de simples barres 2D en quelque chose de plus complexe.  Ils peuvent être des demi-cercles sous les ennemis qui diminuent en arc ou des losanges en rotation au-dessus de leur tête.  En utilisant la même approche, vous pouvez toujours les rendre tous en un seul appel. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr447716/">https://habr.com/ru/post/fr447716/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr447704/index.html">Escalade d'Elbrus - Reconnaissance au combat. Partie technique 1. Registres, piles et autres détails techniques</a></li>
<li><a href="../fr447706/index.html">Pas un seul ORM</a></li>
<li><a href="../fr447708/index.html">Yandex a remis aux jeunes scientifiques et leaders scientifiques les premiers prix Ilya Segalovich</a></li>
<li><a href="../fr447712/index.html">Salut, SaaS | Russian SaaS 2018 - résultats</a></li>
<li><a href="../fr447714/index.html">Sur l'application de la théorie des processus ARMA dans la pratique de l'ingénierie</a></li>
<li><a href="../fr447718/index.html">Tout se passera comme prévu</a></li>
<li><a href="../fr447720/index.html">Sécurité IoT. Numéro 2. Smart Home</a></li>
<li><a href="../fr447724/index.html">Comment naissent les villes intelligentes</a></li>
<li><a href="../fr447728/index.html">Nous calculons le bilan énergétique d'une ligne radio pour un satellite au format CubeSat</a></li>
<li><a href="../fr447730/index.html">L'évolution de l'email marketing: de QWERTYUIOP au GDPR</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>