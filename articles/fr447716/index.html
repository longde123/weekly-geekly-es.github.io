<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï¶ ü•¢ üìí Unit√©: dessinez plusieurs barres de vie en un seul appel üìø üë®üèª‚ÄçüöÄ ü§πüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="R√©cemment, j'ai d√ª r√©soudre un probl√®me qui est assez courant dans de nombreux jeux avec une vue de dessus: pour afficher √† l'√©cran tout un tas de bar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unit√©: dessinez plusieurs barres de vie en un seul appel</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447716/">  R√©cemment, j'ai d√ª r√©soudre un probl√®me qui est assez courant dans de nombreux jeux avec une vue de dessus: pour afficher √† l'√©cran tout un tas de barres de sant√© ennemies.  Quelque chose comme √ßa: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/14e/081/95e/14e08195e0e331c7f24a8ba50c556d7e.png"></div><br>  √âvidemment, je voulais le faire le plus efficacement possible, de pr√©f√©rence en un seul appel.  Comme d'habitude, avant de commencer le travail, j'ai fait une petite recherche en ligne sur les d√©cisions des autres et les r√©sultats √©taient tr√®s diff√©rents. <br><br>  Je ne ferai honte √† personne pour le code, mais il suffit de dire que certaines des solutions n'√©taient pas enti√®rement brillantes, par exemple, quelqu'un a ajout√© un objet Canvas √† chaque ennemi (ce qui est tr√®s inefficace). <br><br>  En cons√©quence, la m√©thode √† laquelle je suis arriv√© est l√©g√®rement diff√©rente de tout ce que j'ai vu dans d'autres, et n'utilise aucune classe d'interface utilisateur (y compris Canvas), j'ai donc d√©cid√© de la documenter pour le public.  Et pour ceux qui veulent apprendre le code source, je l'ai post√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur Github</a> . <br><a name="habracut"></a><br><h2>  Pourquoi ne pas utiliser Canvas? </h2><br>  Une toile pour chaque ennemi est √©videmment une mauvaise d√©cision, mais je pourrais utiliser une toile commune pour tous les ennemis;  un seul canevas entra√Ænerait √©galement le rendu des lots d'appels. <br><br>  Cependant, je n'aime pas la quantit√© de travail effectu√©e dans chaque cadre li√© √† cette approche.  Si vous utilisez Canvas, dans chaque cadre, vous devez effectuer les op√©rations suivantes: <br><br><ul><li>  D√©terminez quels ennemis sont √† l'√©cran et s√©lectionnez chacun d'eux dans la bande d'interface utilisateur du pool. </li><li>  Projetez la position de l'ennemi dans la cam√©ra pour positionner la bande. </li><li>  Redimensionnez la partie "remplissage" de la bande, probablement comme Image. </li><li>  Tr√®s susceptible de changer la taille des bandes en fonction du type d'ennemis;  par exemple, les grands ennemis devraient avoir de larges bandes pour ne pas avoir l'air idiot. </li></ul><br>  Quoi qu'il en soit, tout cela contaminerait les tampons de g√©om√©trie Canvas et conduirait √† une reconstruction de toutes les donn√©es de vertex dans le processeur.  Je ne voulais pas que tout cela soit fait pour un √©l√©ment aussi simple. <br><br><h2>  En bref sur ma d√©cision </h2><br>  Une br√®ve description de mon processus de travail: <br><br><ul><li>  Nous attachons des objets de bandes d'√©nergie aux ennemis en 3D. <br><ul><li>  Cela vous permet d'organiser et de couper automatiquement les bandes. </li><li>  La position / taille de la bande peut √™tre ajust√©e en fonction du type d'ennemi. </li><li>  Nous dirigerons les bandes vers la cam√©ra dans le code en utilisant la transformation, qui est toujours l√†. </li><li>  Le shader garantit qu'ils restituent toujours au-dessus de tout. </li></ul></li><li>  Nous utilisons Instancing pour rendre toutes les bandes en un seul appel de tirage. </li><li>  Nous utilisons des coordonn√©es UV proc√©durales simples pour afficher le niveau de pl√©nitude de la bande. </li></ul><br>  Examinons maintenant la solution plus en d√©tail. <br><br><h2>  Qu'est-ce que l'instanciation? </h2><br>  En travaillant avec des graphiques, la technique standard est utilis√©e depuis longtemps: plusieurs objets sont combin√©s ensemble afin d'avoir des donn√©es de sommet et des mat√©riaux communs et ils peuvent √™tre rendus en un seul appel de dessin.  C'est exactement ce dont nous avons besoin, car chaque appel de tirage est une charge suppl√©mentaire sur le CPU et le GPU.  Au lieu de faire un seul appel de dessin pour chaque objet, nous les rendons tous en m√™me temps et utilisons un shader pour ajouter de la variabilit√© √† chaque copie. <br><br>  Vous pouvez le faire manuellement en dupliquant les donn√©es du sommet du maillage X fois dans un tampon, o√π X est le nombre maximal de copies pouvant √™tre rendues, puis en utilisant le tableau de param√®tres de shader pour convertir / colorer / varier chaque copie.  Chaque copie doit stocker des informations sur son instance num√©rot√©e afin d'utiliser cette valeur comme index du tableau.  Ensuite, nous pouvons utiliser l'appel de rendu index√©, qui ordonne de ¬´rendre uniquement √† N¬ª, o√π N est le nombre d'instances <em>r√©ellement</em> n√©cessaires dans la trame actuelle, inf√©rieur au nombre maximal de X. <br><br>  La plupart des API modernes ont d√©j√† du code pour cela, vous n'avez donc pas besoin de le faire manuellement.  Cette op√©ration est appel√©e "Instanciation";  en fait, il automatise le processus d√©crit ci-dessus avec des restrictions pr√©d√©finies. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le moteur Unity prend √©galement en charge l'instanciation</a> , il poss√®de sa propre API et un ensemble de macros de shader qui aident √† sa mise en ≈ìuvre.  Il utilise certaines hypoth√®ses, par exemple, que chaque instance n√©cessite une transformation 3D compl√®te.  √Ä strictement parler, pour les bandes 2D, ce n'est pas compl√®tement n√©cessaire - nous pouvons faire des simplifications, mais comme elles le sont, nous les utiliserons.  Cela simplifiera notre shader et fournira √©galement la possibilit√© d'utiliser des indicateurs 3D, par exemple des cercles ou des arcs. <br><br><h2>  Classe endommageable </h2><br>  Nos ennemis auront un composant appel√© <code>Damageable</code> , leur donnant de la sant√© et leur permettant de subir des d√©g√¢ts de collisions.  Dans notre exemple, c'est assez simple: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Damageable</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MaxHealth; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DamageForceThreshold = <span class="hljs-number"><span class="hljs-number">1f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DamageForceScale = <span class="hljs-number"><span class="hljs-number">5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CurrentHealth { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CurrentHealth = MaxHealth; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCollisionEnter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Collision other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Collision would usually be on another component, putting it all here for simplicity float force = other.relativeVelocity.magnitude; if (force &gt; DamageForceThreshold) { CurrentHealth -= (int)((force - DamageForceThreshold) * DamageForceScale); CurrentHealth = Mathf.Max(0, CurrentHealth); } } }</span></span></code> </pre> <br><h2>  Objet HealthBar: Position / Turn </h2><br>  L'objet de barre de sant√© est tr√®s simple: en fait, ce n'est qu'un Quad attach√© √† l'ennemi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/be5/2ef/6e2/be52ef6e247fca661f9136e2835bb5dc.png"><br><br>  Nous utilisons l' <strong>√©chelle de</strong> cet objet pour rendre la bande longue et mince et la placer directement au-dessus de l'ennemi.  Ne vous inqui√©tez pas de sa rotation, nous le corrigerons en utilisant le code attach√© √† l'objet dans <code>HealthBar.cs</code> : <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AlignCamera</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mainCamera != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> camXform = mainCamera.transform; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> forward = transform.position - camXform.position; forward.Normalize(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> up = Vector3.Cross(forward, camXform.right); transform.rotation = Quaternion.LookRotation(forward, up); } }</code> </pre> <br>  Ce code dirige toujours le quad vers la cam√©ra.  Nous <em>pouvons</em> effectuer un redimensionnement et une rotation dans le shader, mais je les impl√©mente ici pour deux raisons. <br><br>  Tout d'abord, l'instanciation d'Unity utilise toujours la transformation compl√®te de chaque objet, et puisque nous transf√©rons toutes les donn√©es de toute fa√ßon, vous pouvez l'utiliser.  Deuxi√®mement, le r√©glage de l'√©chelle / rotation ici garantit que le parall√©logramme de d√©limitation pour rogner la bande sera toujours vrai.  Si nous avons fait de la t√¢che de taille et de rotation la responsabilit√© du shader, alors Unity pourrait tronquer les bandes qui devraient √™tre visibles lorsqu'elles sont proches des bords de l'√©cran, car la taille et la rotation de leur parall√©logramme de d√©limitation ne correspondront pas √† ce que nous allons rendre.  Bien s√ªr, nous pourrions impl√©menter notre propre m√©thode de troncature, mais il est g√©n√©ralement pr√©f√©rable d'utiliser ce que nous avons si possible (le code Unity est natif et a acc√®s √† plus de donn√©es spatiales que nous). <br><br>  Je vais expliquer comment la bande est rendue apr√®s avoir regard√© le shader. <br><br><h2>  Shader HealthBar </h2><br>  Dans cette version, nous allons cr√©er une simple bande rouge-vert classique. <br><br>  J'utilise une texture 2x1 avec un pixel vert √† gauche et un rouge √† droite.  Naturellement, j'ai d√©sactiv√© le mipmapping, le filtrage et la compression, et d√©fini le param√®tre du mode d'adressage sur Clamp, ce qui signifie que les pixels de notre bande seront toujours parfaitement verts ou rouges et ne se r√©pandront pas sur les bords.  Cela nous permettra de modifier les coordonn√©es de la texture dans le shader pour d√©caler la ligne s√©parant les pixels rouges et verts de haut en bas de la bande. <br><br>  <em>(Puisqu'il n'y a que deux couleurs ici, je pourrais simplement utiliser la fonction de pas dans le shader pour revenir au point de l'une ou de l'autre. Cependant, cette m√©thode est pratique car vous pouvez utiliser une texture plus complexe si vous le souhaitez, et cela fonctionnera de mani√®re similaire pendant la transition. texture moyenne.)</em> <br><br>  Tout d'abord, nous d√©clarerons les propri√©t√©s dont nous avons besoin: <br><br><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"UI/HealthBar"</span></span> { Properties { _MainTex (<span class="hljs-string"><span class="hljs-string">"Texture"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} _Fill (<span class="hljs-string"><span class="hljs-string">"Fill"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) = <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br>  <code>_MainTex</code> est une texture rouge-vert, et <code>_Fill</code> est une valeur de 0 √† 1, o√π 1 est une sant√© compl√®te. <br><br>  Ensuite, nous devons ordonner le rendu de la bande dans la file d'attente de superposition, ce qui signifie ignorer toute la profondeur de la sc√®ne et effectuer le rendu par-dessus tout: <br><br><pre> <code class="cpp hljs"> SubShader { Tags { <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Overlay"</span></span> } Pass { ZTest Off</code> </pre> <br>  La partie suivante est le code du shader lui-m√™me.  Nous √©crivons un shader sans √©clairage (non √©clair√©), nous n'avons donc pas √† nous soucier de l'int√©gration avec divers shaders de surface Unity, ce ne sont que quelques shaders de vertex / fragment.  Tout d'abord, √©crivez bootstrap: <br><br><pre> <code class="cpp hljs"> CGPROGRAM <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> vertex vert #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> fragment frag #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> multi_compile_instancing #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"UnityCG.cginc"</span></span></span></span></code> </pre> <br>  Pour la plupart, il s'agit d'un amor√ßage standard, √† l'exception de <code>#pragma multi_compile_instancing</code> , qui indique au compilateur Unity ce qui doit √™tre compil√© pour Instancing. <br><br>  La structure des sommets doit inclure des donn√©es d'instance, nous allons donc proc√©der comme suit: <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">appdata</span></span></span><span class="hljs-class"> {</span></span> float4 vertex : POSITION; float2 uv : TEXCOORD0; UNITY_VERTEX_INPUT_INSTANCE_ID };</code> </pre> <br>  Nous devons √©galement sp√©cifier ce qui sera exactement dans les donn√©es des instances, en plus des processus Unity (transform) pour nous: <br><br><pre> <code class="cpp hljs"> UNITY_INSTANCING_BUFFER_START(Props) UNITY_DEFINE_INSTANCED_PROP(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, _Fill) UNITY_INSTANCING_BUFFER_END(Props)</code> </pre> <br>  Nous signalons donc que Unity doit cr√©er un tampon appel√© ¬´Props¬ª pour stocker les donn√©es de chaque instance, et √† l'int√©rieur, nous utiliserons un flottant par instance pour une propri√©t√© appel√©e <code>_Fill</code> . <br><br>  Vous pouvez utiliser plusieurs tampons;  cela vaut la peine si vous avez plusieurs propri√©t√©s mises √† jour √† diff√©rentes fr√©quences;  en les divisant, vous pouvez, par exemple, ne pas changer un tampon lorsque vous en changez un autre, ce qui est plus efficace.  Mais nous n'en avons pas besoin. <br><br>  Notre vertex shader fait presque enti√®rement le travail standard, car la taille, la position et la rotation sont d√©j√† transf√©r√©es pour se transformer.  Ceci est impl√©ment√© en utilisant <code>UnityObjectToClipPos</code> , qui utilise automatiquement la transformation de chaque instance.  On pourrait imaginer que sans instanciation, cela serait g√©n√©ralement une simple utilisation d'une seule propri√©t√© de matrice.  mais lorsque vous utilisez l'instanciation √† l'int√©rieur du moteur, il ressemble √† un tableau de matrices, et Unity s√©lectionne ind√©pendamment une matrice appropri√©e pour cette instance. <br><br>  En outre, vous devez changer UV pour changer l'emplacement du point de transition du rouge au vert conform√©ment √† la propri√©t√© <code>_Fill</code> .  Voici l'extrait de code correspondant: <br><br><pre> <code class="cpp hljs"> UNITY_SETUP_INSTANCE_ID(v); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fill = UNITY_ACCESS_INSTANCED_PROP(Props, _Fill); <span class="hljs-comment"><span class="hljs-comment">// generate UVs from fill level (assumed texture is clamped) o.uv = v.uv; o.uv.x += 0.5 - fill;</span></span></code> </pre> <br>  <code>UNITY_SETUP_INSTANCE_ID</code> et <code>UNITY_ACCESS_INSTANCED_PROP</code> font toute la magie en acc√©dant √† la version correcte de la propri√©t√© <code>_Fill</code> partir du tampon constant pour cette instance. <br><br>  On sait qu'√† l'√©tat normal, les coordonn√©es UV d'un quadrilat√®re couvrent tout l'intervalle de texture, et que la ligne de division de la bande est au milieu de la texture horizontalement.  Par cons√©quent, de petits calculs math√©matiques d√©calent horizontalement la bande vers la gauche ou la droite, et la valeur de serrage de la texture assure le remplissage de la partie restante. <br><br>  Le fragment shader ne pourrait pas √™tre plus simple car tout le travail a d√©j√† √©t√© fait: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tex2D(_MainTex, i.uv);</code> </pre> <br>  Le code de nuanceur de commentaires complet est disponible dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le r√©f√©rentiel GitHub</a> . <br><br><h2>  Mat√©riel Healthbar </h2><br>  Ensuite, tout est simple - il suffit d'affecter √† notre bande le mat√©riau utilis√© par ce shader.  Il n'y a presque plus rien √† faire, il suffit de s√©lectionner le shader souhait√© dans la partie sup√©rieure, d'attribuer une texture rouge-vert et, plus important encore, de <strong>cocher la case ¬´Activer l'instance GPU¬ª</strong> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/06e/6e0/dcd/06e6e0dcd1965aa73f1dbbcf64e90a22.png" alt="image"><br><br><h2>  Mise √† jour de la propri√©t√© de remplissage HealthBar </h2><br>  Donc, nous avons l'objet barre de sant√©, le shader et le mat√©riau √† rendre, nous devons maintenant d√©finir la propri√©t√© <code>_Fill</code> pour chaque instance.  Nous faisons cela dans <code>HealthBar.cs</code> comme suit: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateParams</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { meshRenderer.GetPropertyBlock(matBlock); matBlock.SetFloat(<span class="hljs-string"><span class="hljs-string">"_Fill"</span></span>, damageable.CurrentHealth / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)damageable.MaxHealth); meshRenderer.SetPropertyBlock(matBlock); }</code> </pre> <br>  Nous transformons le <code>CurrentHealth</code> classe <code>CurrentHealth</code> en une valeur de 0 √† 1, en le divisant par <code>MaxHealth</code> .  Ensuite, nous le transmettons √† la propri√©t√© <code>_Fill</code> aide de <code>MaterialPropertyBlock</code> . <br><br>  Si vous n'avez pas utilis√© <code>MaterialPropertyBlock</code> pour transf√©rer des donn√©es vers des shaders, m√™me sans instanciation, vous devez les √©tudier.  Il n'est pas bien expliqu√© dans la documentation Unity, mais c'est le moyen le plus efficace pour transf√©rer des donn√©es de chaque objet vers des shaders. <br><br>  Dans notre cas, lorsque l'instanciation est utilis√©e, les valeurs de toutes les barres de sant√© sont regroup√©es dans un tampon constant afin qu'elles puissent √™tre transf√©r√©es ensemble et dessin√©es √† la fois. <br><br>  Il n'y a presque rien ici, sauf un passe-partout pour d√©finir des variables, et le code est plut√¥t ennuyeux;  voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le r√©f√©rentiel GitHub pour</a> plus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de</a> d√©tails. <br><br><h2>  D√©mo </h2><br>  Le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©f√©rentiel GitHub</a> a une d√©mo de test dans laquelle un tas de cubes bleus mal√©fiques sont d√©truits par des sph√®res rouges h√©ro√Øques (hourra!), Prenant les d√©g√¢ts affich√©s par les rayures d√©crites dans l'article.  D√©mo √©crite en Unity 2018.3.6f1. <br><br>  L'effet de l'instanciation peut √™tre observ√© de deux mani√®res: <br><br><h3>  Panneau Statistiques </h3><br>  Apr√®s avoir cliqu√© sur Play, cliquez sur le bouton Stats au-dessus du panneau Game.  Ici, vous pouvez voir combien d'appels de tirage sont enregistr√©s gr√¢ce √† l'instanciation: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad0/f25/204/ad0f25204bb3daf73a2c3700fd185938.png" alt="image"><br><br>  Apr√®s avoir lanc√© le jeu, vous pouvez cliquer sur le mat√©riel HealthBar et <em>d√©cocher la case</em> ¬´Activer l'instance GPU¬ª, apr√®s quoi le nombre d'appels enregistr√©s sera r√©duit √† z√©ro. <br><br><h3>  D√©bogueur d'images </h3><br>  Apr√®s avoir lanc√© le jeu, allez dans Fen√™tre&gt; Analyse&gt; D√©bogueur d'images, puis cliquez sur ¬´Activer¬ª dans la fen√™tre qui appara√Æt. <br><br>  En bas √† gauche, vous verrez toutes les op√©rations de rendu effectu√©es.  Notez que bien qu'il existe de nombreux d√©fis distincts pour les ennemis et les obus (si vous le souhaitez, vous pouvez √©galement impl√©menter l'instanciation pour eux).  Si vous faites d√©filer vers le bas, vous verrez l'√©l√©ment "Draw Health Mesh (instanced) Healthbar". <br><br>  Cet appel unique rend toutes les bandes.  Si vous cliquez sur cette op√©ration, puis sur l'op√©ration, vous verrez que toutes les bandes disparaissent, car elles sont dessin√©es en un seul appel.  Si vous √™tes dans le d√©bogueur de trame, vous d√©cochez la case Activer l'instance GPU du mat√©riau, vous verrez qu'une ligne se transforme en plusieurs, et apr√®s avoir d√©fini √† nouveau l'indicateur en une. <br><br><h2>  Comment √©tendre ce syst√®me </h2><br>  Comme je l'ai d√©j√† dit, puisque ces barres de sant√© sont de vrais objets, rien ne vous emp√™che de transformer de simples barres 2D en quelque chose de plus complexe.  Ils peuvent √™tre des demi-cercles sous les ennemis qui diminuent en arc ou des losanges en rotation au-dessus de leur t√™te.  En utilisant la m√™me approche, vous pouvez toujours les rendre tous en un seul appel. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr447716/">https://habr.com/ru/post/fr447716/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr447704/index.html">Escalade d'Elbrus - Reconnaissance au combat. Partie technique 1. Registres, piles et autres d√©tails techniques</a></li>
<li><a href="../fr447706/index.html">Pas un seul ORM</a></li>
<li><a href="../fr447708/index.html">Yandex a remis aux jeunes scientifiques et leaders scientifiques les premiers prix Ilya Segalovich</a></li>
<li><a href="../fr447712/index.html">Salut, SaaS | Russian SaaS 2018 - r√©sultats</a></li>
<li><a href="../fr447714/index.html">Sur l'application de la th√©orie des processus ARMA dans la pratique de l'ing√©nierie</a></li>
<li><a href="../fr447718/index.html">Tout se passera comme pr√©vu</a></li>
<li><a href="../fr447720/index.html">S√©curit√© IoT. Num√©ro 2. Smart Home</a></li>
<li><a href="../fr447724/index.html">Comment naissent les villes intelligentes</a></li>
<li><a href="../fr447728/index.html">Nous calculons le bilan √©nerg√©tique d'une ligne radio pour un satellite au format CubeSat</a></li>
<li><a href="../fr447730/index.html">L'√©volution de l'email marketing: de QWERTYUIOP au GDPR</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>