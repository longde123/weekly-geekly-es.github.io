<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✋🏿 🎏 🔝 Pemrograman relasional: rasa sakit, minat, dan rasa sakit lagi 📍 👩🏿‍🤝‍👩🏽 👈🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam posting sebelumnya kami memberi tahu secara rinci apa yang kami ajarkan kepada siswa di bidang "Pemrograman Industri". Bagi mereka yang bidang m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pemrograman relasional: rasa sakit, minat, dan rasa sakit lagi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hsespb/blog/441114/"> Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting</a> sebelumnya kami memberi tahu secara rinci apa yang kami ajarkan kepada siswa di bidang "Pemrograman Industri".  Bagi mereka yang bidang minatnya terletak pada bidang yang lebih teoretis, misalnya, tertarik oleh paradigma pemrograman baru atau matematika abstrak yang digunakan dalam penelitian teoritis tentang pemrograman, ada spesialisasi lain - “Bahasa pemrograman”. <br><br>  Hari ini saya akan berbicara tentang penelitian saya di bidang pemrograman relasional, yang saya lakukan di universitas dan sebagai mahasiswa-peneliti di laboratorium alat bahasa JetBrains Research. <br><br>  Apa itu pemrograman relasional?  Biasanya kita menjalankan fungsi dengan argumen dan mendapatkan hasilnya.  Dan dalam kasus relasional, Anda dapat melakukan yang sebaliknya: perbaiki hasil dan satu argumen, dan dapatkan argumen kedua.  Yang utama adalah menulis kode dengan benar dan bersabar dan memiliki cluster yang baik. <br><br><img src="https://habrastorage.org/webt/_u/8b/t2/_u8bt2bceznm8e2ujbrvhwn8awy.jpeg"><br><a name="habracut"></a><br><h2>  Tentang diri saya </h2><br>  Nama saya Dmitry Rozplokhas, saya adalah mahasiswa tahun pertama HSE St. Petersburg, dan tahun lalu saya lulus dari program sarjana di Universitas Akademik di bidang “Bahasa Pemrograman”.  Sejak tahun ketiga studi sarjana, saya juga seorang mahasiswa peneliti di laboratorium alat bahasa Penelitian JetBrains. <br><br><h2>  Pemrograman relasional </h2><br><h3>  Fakta umum </h3><br>  Pemrograman relasional adalah ketika, alih-alih fungsi, Anda menggambarkan hubungan antara argumen dan hasilnya.  Jika bahasa diasah untuk ini, Anda bisa mendapatkan bonus tertentu, misalnya, kemampuan untuk menjalankan fungsi dalam arah yang berlawanan (mengembalikan nilai yang mungkin dari argumen sebagai hasilnya). <br><br>  Secara umum, ini dapat dilakukan dalam bahasa logis apa pun, tetapi minat dalam pemrograman relasional muncul bersamaan dengan munculnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">miniKanren</a> bahasa logis murni minimalis sekitar sepuluh tahun yang lalu, yang memungkinkan untuk dengan mudah menggambarkan dan menggunakan hubungan seperti itu. <br><br>  Berikut adalah beberapa kasus penggunaan paling canggih: Anda dapat menulis pemeriksa bukti dan menggunakannya untuk menemukan bukti ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Near et al., 2008</a> ), atau membuat penerjemah untuk beberapa bahasa dan menggunakannya untuk menghasilkan program suite uji ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Byrd et al., 2017</a> ). <br><br><h3>  Sintaks dan Contoh Mainan </h3><br>  miniKanren adalah bahasa kecil, hanya konstruksi matematika dasar yang digunakan untuk menggambarkan hubungan.  Ini adalah bahasa yang disematkan, primitifnya adalah perpustakaan untuk beberapa bahasa eksternal, dan program miniKanren kecil dapat digunakan di dalam suatu program dalam bahasa lain. <br><br>  Bahasa asing cocok untuk miniKanren, sejumlah besar.  Awalnya, ada Skema, kami bekerja dengan versi untuk Ocaml ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OCanren</a> ), dan daftar lengkapnya dapat dilihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">minikanren.org</a> .  Contoh dalam artikel ini juga ada di OCanren.  Banyak implementasi menambahkan fungsi pembantu, tetapi kami hanya akan fokus pada bahasa inti. <br><br>  Mari kita mulai dengan tipe data.  Secara konvensional, mereka dapat dibagi menjadi dua jenis: <br><br><ul><li>  Konstanta adalah beberapa data dari bahasa yang menjadi asal kita.  String, angka, bahkan array.  Tetapi untuk miniKanren dasar, ini semua kotak hitam, konstanta hanya dapat diperiksa untuk kesetaraan. <br></li><li>  "Istilah" adalah tupel dari beberapa elemen.  Umumnya digunakan dengan cara yang sama seperti konstruktor data di Haskell: konstruktor data (string) ditambah nol atau lebih parameter.  OCanren menggunakan konstruktor data reguler dari OCaml. <br></li></ul><br>  Misalnya, jika kita ingin bekerja dengan array di miniKanren itu sendiri, maka harus dijelaskan dalam istilah yang mirip dengan bahasa fungsional - sebagai daftar yang terhubung secara tunggal.  Daftar adalah daftar kosong (ditunjukkan oleh beberapa istilah sederhana), atau sepasang elemen pertama dari daftar ("head") dan elemen lainnya ("tail"). <br><br><pre><code class="plaintext hljs">let emptyList = Nil let list_123 = Cons (1, Cons (2, Cons (3, Nil)))</code> </pre> <br>  Program miniKanren adalah hubungan antara beberapa variabel.  Saat startup, program memberikan semua nilai yang mungkin dari variabel dalam bentuk umum.  Seringkali implementasi memungkinkan Anda membatasi jumlah jawaban dalam output, misalnya, hanya temukan yang pertama - pencarian tidak selalu berhenti setelah menemukan semua solusi. <br><br>  Anda dapat menulis beberapa hubungan yang didefinisikan melalui satu sama lain dan bahkan disebut secara rekursif sebagai fungsi.  Misalnya, di bawah ini kita bukan fungsi <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>a</mi><mi>p</mi><mi>p</mi><mi>e</mi><mi>n</mi><mi>d</mi><mo stretchy=&quot;false&quot;>(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy=&quot;false&quot;>)</mo><mo stretchy=&quot;false&quot;>&amp;#x2192;</mo><mi>d</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>a</mi><mi>n</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="23.382ex" height="2.66ex" viewBox="0 -832 10067.2 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-61" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-70" x="529" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-70" x="1033" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-65" x="1536" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-6E" x="2003" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-64" x="2603" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMAIN-28" x="3127" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-61" x="3516" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMAIN-2C" x="4046" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-62" x="4491" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMAIN-29" x="4920" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMAIN-2192" x="5587" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-64" x="6866" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-65" x="7389" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-6E" x="7856" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-67" x="8456" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-61" x="8937" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-6E" x="9466" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi><mi>p</mi><mi>p</mi><mi>e</mi><mi>n</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">)</mo><mo stretchy="false">→</mo><mi>d</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>a</mi><mi>n</mi></math></span></span><script type="math/tex" id="MathJax-Element-1"> append (a, b) → dengan </script>  tentukan hubungannya <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>a</mi><mi>p</mi><mi>p</mi><mi>e</mi><mi>n</mi><mi>d</mi><mi>o</mi><mo stretchy=&quot;false&quot;>(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="15.502ex" height="2.66ex" viewBox="0 -832 6674.3 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-61" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-70" x="529" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-70" x="1033" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-65" x="1536" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-6E" x="2003" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-64" x="2603" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-6F" x="3127" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMAIN-28" x="3612" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-61" x="4002" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMAIN-2C" x="4531" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-62" x="4976" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMAIN-2C" x="5406" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-63" x="5851" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMAIN-29" x="6284" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi><mi>p</mi><mi>p</mi><mi>e</mi><mi>n</mi><mi>d</mi><mi>o</mi><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-2"> appendo (a, b, c) </script>  : daftar <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>c</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.007ex" height="1.455ex" viewBox="0 -520.7 433.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-63" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>c</mi></math></span></span><script type="math/tex" id="MathJax-Element-3"> c </script>  adalah gabungan daftar <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>a</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.23ex" height="1.455ex" viewBox="0 -520.7 529.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-61" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi></math></span></span><script type="math/tex" id="MathJax-Element-4"> a </script>  dan <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>b</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="0.998ex" height="2.057ex" viewBox="0 -780.1 429.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-62" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>b</mi></math></span></span><script type="math/tex" id="MathJax-Element-5"> b </script>  .  Fungsi yang mengembalikan hubungan secara tradisional diakhiri dengan "o" untuk membedakannya dari fungsi biasa. <br><br>  Suatu relasi ditulis sebagai beberapa pernyataan mengenai argumennya.  Kami memiliki <b>empat operasi dasar</b> : <br><br><ul><li>  Penyatuan atau persamaan (===) dari dua istilah, istilah dapat mencakup variabel.  Misalnya, Anda dapat menulis daftar relasi <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>l</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="0.693ex" height="2.057ex" viewBox="0 -780.1 298.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-6C" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>l</mi></math></span></span><script type="math/tex" id="MathJax-Element-6"> l </script>  terdiri dari satu elemen <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.455ex" viewBox="0 -520.7 572.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-78" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></span></span><script type="math/tex" id="MathJax-Element-7"> x </script>  ": <br><br><pre> <code class="plaintext hljs">let isSingletono xl = l === Cons (x, Nil)</code> </pre></li><li>  Konjungsi (logis "dan") dan disjungsi (logis "atau") - seperti dalam logika biasa.  OCanren disebut sebagai &amp;&amp;&amp; dan |||.  Tetapi pada dasarnya tidak ada penolakan logis dalam MiniKanren. <br></li><li>  Menambahkan variabel baru.  Dalam logika, ini adalah penjumlahan keberadaan.  Misalnya, untuk memeriksa daftar untuk ketidak-kosongan, Anda perlu memeriksa bahwa daftar itu terdiri atas kepala dan ekor.  Mereka bukan argumen hubungan, jadi Anda perlu membuat variabel baru: <br><br><pre> <code class="plaintext hljs">let nonEmptyo l = fresh (ht) (l === Cons (h, t))</code> </pre></li></ul><br>  Suatu hubungan dapat memunculkan dirinya secara rekursif.  Misalnya, Anda perlu mendefinisikan elemen "hubungan <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.455ex" viewBox="0 -520.7 572.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-78" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></span></span><script type="math/tex" id="MathJax-Element-8"> x </script>  terletak pada daftar. "  Kami akan memecahkan masalah ini dengan menganalisis kasus-kasus sepele, seperti dalam bahasa fungsional: <br><br><ol><li>  Atau kepala daftar adalah <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.455ex" viewBox="0 -520.7 572.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-78" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></span></span><script type="math/tex" id="MathJax-Element-9"> x </script><br></li><li>  Baik <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.455ex" viewBox="0 -520.7 572.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-78" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></span></span><script type="math/tex" id="MathJax-Element-10"> x </script>  terletak di ekor <br></li></ol><br><pre> <code class="plaintext hljs">let membero lx = fresh (ht) ( (l === Cons (h, t)) &amp;&amp;&amp; (x === h ||| membero tx) )</code> </pre><br>  Versi dasar bahasa dibangun pada empat operasi ini.  Ada juga ekstensi yang memungkinkan Anda menggunakan operasi lain.  Yang paling berguna dari mereka adalah kendala ketidaksetaraan untuk mengatur ketidaksetaraan dua istilah (= / =). <br><br>  Meskipun minimalis, miniKanren adalah bahasa yang cukup ekspresif.  Sebagai contoh, lihatlah gabungan dari dua daftar relasional.  Fungsi dua argumen berubah menjadi hubungan rangkap tiga " <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>a</mi><mi>b</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.227ex" height="2.057ex" viewBox="0 -780.1 959 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-61" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-62" x="529" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi><mi>b</mi></math></span></span><script type="math/tex" id="MathJax-Element-11"> ab </script>  adalah gabungan daftar <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>a</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.23ex" height="1.455ex" viewBox="0 -520.7 529.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-61" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi></math></span></span><script type="math/tex" id="MathJax-Element-12"> a </script>  dan <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>b</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="0.998ex" height="2.057ex" viewBox="0 -780.1 429.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-62" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>b</mi></math></span></span><script type="math/tex" id="MathJax-Element-13"> b </script>  ". <br><br><pre> <code class="plaintext hljs">let appendo ab ab = (a === Nil &amp;&amp;&amp; ab === b) ||| (fresh (ht tb) (*  :  fresh   &amp;&amp;&amp; *) (a = Cons (h, t)) (appendo tb tb) (ab === Cons (h, tb)))</code> </pre><br>  Solusinya secara struktural tidak berbeda dari bagaimana kita akan menulisnya dalam bahasa fungsional.  Kami menganalisis dua kasus yang disatukan oleh klausa: <br><br><ol><li>  Jika daftar pertama kosong, maka daftar kedua dan hasil gabungan adalah sama. <br></li><li>  Jika daftar pertama tidak kosong, maka kami menguraikannya ke kepala dan ekor dan membangun hasilnya menggunakan panggilan relasional rekursif. <br></li></ol><br>  Kami dapat membuat permintaan untuk relasi ini, memperbaiki argumen pertama dan kedua - kami mendapatkan rangkaian daftar: <br><br><pre> <code class="plaintext hljs">run 1 (λ q -&gt; appendo (Cons (1, Cons (2, Nil))) (Cons (3, Cons (4, Nil))) q)</code> </pre> <br>  ⇒ <br><pre> <code class="plaintext hljs">q = Cons (1, Cons (2, Cons (3, Cons (4, Nil))))</code> </pre> <br>  Kami dapat memperbaiki argumen terakhir - kami membuat semua partisi daftar ini menjadi dua. <br><br><pre> <code class="plaintext hljs">run 4 (λ qr -&gt; appendo qr (Cons (1, Cons (2, Cons (3, Nil)))))</code> </pre> <br>  ⇒ <br><pre> <code class="plaintext hljs">q = Nil, r = Cons (1, Cons (2, Cons (3, Nil))) | q = Cons (1, Nil), r = Cons (2, Cons (3, Nil)) | q = Cons (1, Cons (2, Nil)), r = Cons (3, Nil) | q = Cons (1, Cons (2, Cons (3, Nil))), r = Nil</code> </pre><br>  Anda dapat melakukan hal lain.  Contoh yang sedikit lebih tidak standar, di mana kami hanya memperbaiki sebagian dari argumen: <br><br><pre> <code class="plaintext hljs">run 1 (λ qr -&gt; appendo (Cons (1, Cons (q, Nil))) r (Cons (1, Cons (2, Cons (3, Cons (4, Nil))))))</code> </pre> <br>  ⇒ <br><pre> <code class="plaintext hljs">q = 2, r = Cons (3, Cons (4, Nil))</code> </pre> <br><br><h3>  Bagaimana cara kerjanya </h3><br>  Dari sudut pandang teori, tidak ada yang mengesankan di sini: Anda selalu dapat mulai mencari semua opsi yang mungkin untuk semua argumen, memeriksa setiap set apakah mereka berperilaku sehubungan dengan fungsi / hubungan yang diberikan seperti yang kita inginkan (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Algoritma Museum Inggris"</a> ) .  Yang menarik adalah fakta bahwa di sini pencarian (dengan kata lain, pencarian solusi) hanya menggunakan struktur hubungan yang dijelaskan, karena itu dapat relatif efektif dalam praktik. <br><br>  Pencarian terkait dengan mengumpulkan informasi tentang berbagai variabel dalam kondisi saat ini.  Kami tidak tahu apa-apa tentang setiap variabel, atau kami tahu bagaimana itu dinyatakan dalam istilah, nilai, dan variabel lainnya.  Sebagai contoh: <br><br> <code>b = Cons (x, y) <br> c = Cons (10, z) <br> x = ? <br> y = ? <br> z = ? <br></code> <br>  Melewati penyatuan, kami melihat dua istilah dengan informasi ini dalam pikiran dan memperbarui keadaan atau menghentikan pencarian jika dua istilah tidak dapat disatukan.  Misalnya, menyelesaikan penyatuan b = c, kami mendapatkan informasi baru: x = 10, y = z.  Tetapi penyatuan b = Nihil akan menyebabkan kontradiksi. <br><br>  Kami mencari dalam konjungsi secara berurutan (sehingga informasi terakumulasi), dan dalam disjungsi kami membagi pencarian menjadi dua cabang paralel dan melanjutkan, bergantian langkah di dalamnya - inilah yang disebut pencarian interleaving.  Berkat pergantian ini, pencarian selesai - setiap solusi yang cocok akan ditemukan setelah waktu yang terbatas.  Misalnya, dalam bahasa Prolog ini tidak demikian.  Ia melakukan sesuatu seperti perayapan yang dalam (yang dapat bertahan di cabang yang tak terbatas), dan pencarian yang saling terkait pada dasarnya adalah modifikasi perayapan yang rumit dan rumit. <br><br>  Sekarang mari kita lihat bagaimana kueri pertama dari bagian sebelumnya bekerja.  Karena appendo memiliki panggilan rekursif, kami akan menambahkan indeks ke variabel untuk membedakannya.  Gambar di bawah ini menunjukkan pohon enumerasi.  Panah menunjukkan arah penyebaran informasi (kecuali untuk pengembalian dari rekursi).  Di antara disjungsi, informasi tidak didistribusikan, dan di antara konjungsi didistribusikan dari kiri ke kanan. <br><br><img src="https://habrastorage.org/webt/3j/np/fg/3jnpfgkkgbyyf5-or5g_noicxg4.png"><br><br><ol><li>  Kami mulai dengan panggilan eksternal untuk menambah.  Cabang disjungsi kiri mati karena kontroversi: daftar <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>a</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.23ex" height="1.455ex" viewBox="0 -520.7 529.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-61" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi></math></span></span><script type="math/tex" id="MathJax-Element-14"> a </script>  tidak kosong. <br></li><li>  Di cabang kanan variabel tambahan diperkenalkan, yang kemudian digunakan untuk "mem-parsing" daftar <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>a</mi><mn>1</mn></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.284ex" height="1.696ex" viewBox="0 -520.7 983.4 730.2" role="img" focusable="false" style="vertical-align: -0.487ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-61" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMAIN-31" x="748" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>a</mi><mn>1</mn></msub></math></span></span><script type="math/tex" id="MathJax-Element-15"> a_1 </script>  di kepala dan ekor. <br></li><li>  Setelah ini, appendo recursive call terjadi untuk a = [2], b = [3, 4], ab = ?, di mana operasi serupa terjadi. <br></li><li>  Tetapi dalam panggilan ketiga untuk appendo kita sudah memiliki a = [], b = [3,4], ab =?, Dan kemudian disjungsi kiri hanya berfungsi, setelah itu kita mendapatkan informasi ab = b.  Tetapi di cabang kanan ada kontradiksi. <br></li><li>  Sekarang kita dapat menuliskan semua informasi yang tersedia dan mengembalikan jawabannya dengan mengganti nilai-nilai variabel: <br><br> <code>a_1 = [1, 2] <br> b_1 = [3, 4] <br> ab_1 = Cons h_1 tb_1 <br> h_1 = 1 <br> a_2 = t_1 = [2] <br> b_2 = b_1 = [3, 4] <br> ab_2 = tb_1 = Cons h_2 tb_2 <br> h_2 = 2 <br> a_3 = t_2 = Nil <br> b_3 = b_2 = b_1 = [3, 4] <br> ab_3 = tb_2 = b_3 = [3, 4] <br></code> <br></li><li>  Karena itu <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>a</mi><msub><mi>b</mi><mn>1</mn></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.282ex" height="2.298ex" viewBox="0 -780.1 1412.9 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-61" x="0" y="0"></use><g transform="translate(529,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-62" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMAIN-31" x="607" y="-213"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi><msub><mi>b</mi><mn>1</mn></msub></math></span></span><script type="math/tex" id="MathJax-Element-16"> ab_1 </script>  = Kontra (1, Kontra (2, [3, 4]))) = [1, 2, 3, 4], sesuai kebutuhan. <br></li></ol><br><br><h2>  Apa yang saya lakukan di sarjana </h2><br><h3>  Semuanya melambat </h3><br>  Seperti biasa: mereka berjanji kepada Anda bahwa semuanya akan menjadi super deklaratif, tetapi dalam kenyataannya Anda perlu beradaptasi dengan bahasa dan menulis semuanya dengan cara khusus (dengan mengingat bagaimana semuanya akan dieksekusi) agar setidaknya ada sesuatu yang berfungsi, kecuali untuk contoh sederhana.  Ini mengecewakan. <br><br>  Salah satu masalah pertama yang dihadapi oleh seorang programmer miniKanren pemula adalah bahwa hal itu sangat tergantung pada urutan di mana Anda menggambarkan kondisi (konjungsi) dalam program.  Dengan satu urutan, semuanya baik-baik saja, tetapi dua konjungsi ditukar dan semuanya mulai bekerja sangat lambat atau tidak selesai sama sekali.  Ini tidak terduga. <br><br>  Bahkan dalam contoh dengan appendo, meluncurkan ke arah yang berlawanan (menghasilkan pemisahan daftar menjadi dua) tidak berakhir kecuali Anda secara eksplisit menentukan berapa banyak jawaban yang Anda inginkan (maka pencarian akan berakhir setelah nomor yang diperlukan ditemukan). <br><br>  Misalkan kita memperbaiki variabel asli sebagai berikut: a =?, B =?, Ab = [1, 2, 3] (lihat gambar di bawah) Di cabang kedua, informasi ini tidak akan digunakan dengan cara apa pun selama panggilan rekursif (variabel ab dan batasan pada <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-17-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>h</mi><mn>1</mn></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.393ex" height="2.298ex" viewBox="0 -780.1 1030.4 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-68" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMAIN-31" x="815" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>h</mi><mn>1</mn></msub></math></span></span><script type="math/tex" id="MathJax-Element-17"> h_1 </script>  dan <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-18-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>t</mi><msub><mi>b</mi><mn>1</mn></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.891ex" height="2.298ex" viewBox="0 -780.1 1244.9 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-74" x="0" y="0"></use><g transform="translate(361,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-62" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMAIN-31" x="607" y="-213"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>t</mi><msub><mi>b</mi><mn>1</mn></msub></math></span></span><script type="math/tex" id="MathJax-Element-18"> tb_1 </script>  hanya muncul setelah panggilan ini).  Oleh karena itu, pada panggilan rekursif pertama, semua argumennya akan menjadi variabel bebas.  Panggilan ini akan menghasilkan semua jenis tiga kali lipat dari dua daftar dan rangkaiannya (dan generasi ini tidak akan pernah berakhir), dan kemudian di antara mereka akan dipilih yang mana elemen ketiga adalah persis yang kita butuhkan. <br><br><img src="https://habrastorage.org/webt/pg/gn/jg/pggnjghrld84iyiybo9au0nyilk.png"><br><br>  Semuanya tidak seburuk kelihatannya pada pandangan pertama, karena kita akan memilah tiga kali lipat dalam kelompok besar.  Daftar dengan panjang yang sama tetapi elemen yang berbeda tidak berbeda dari sudut pandang fungsi, oleh karena itu mereka akan jatuh ke dalam satu solusi - akan ada variabel bebas di tempat elemen.  Namun demikian, kami masih akan memilah-milah semua daftar panjang yang mungkin, meskipun kami hanya membutuhkan satu, dan kami tahu yang mana.  Ini adalah penggunaan informasi yang sangat tidak rasional (tidak digunakan) dalam pencarian. <br><br>  Contoh khusus ini mudah diperbaiki: Anda hanya perlu memindahkan panggilan rekursif ke akhir dan semuanya akan berfungsi sebagaimana mestinya.  Sebelum panggilan rekursif, penyatuan dengan variabel ab akan terjadi dan panggilan rekursif akan dilakukan dari ekor daftar yang diberikan (sebagai fungsi rekursif normal).  Definisi ini dengan panggilan rekursif pada akhirnya akan bekerja dengan baik di semua arah: untuk panggilan rekursif, kami berhasil mengumpulkan semua informasi yang mungkin tentang argumen. <br><br>  Namun, dalam contoh yang sedikit lebih kompleks, ketika ada beberapa panggilan yang bermakna, satu urutan khusus yang semuanya akan baik-baik saja tidak ada.  Contoh paling sederhana: memperluas daftar menggunakan gabungan.  Kami memperbaiki argumen pertama - kami membutuhkan pesanan khusus ini, kami memperbaiki yang kedua - kami perlu menukar panggilan.  Kalau tidak, itu dicari untuk waktu yang lama dan pencarian tidak berakhir. <br><br><pre> <code class="plaintext hljs">reverso x xr = (x === Nil &amp;&amp;&amp; xr == Nil) ||| (fresh (ht tr) (x === Cons (h, t)) (reverso t tr) (appendo tr (Cons (h, Nil)) xr))</code> </pre><br>  Ini karena interleaving proses pencarian berhubungan secara berurutan, dan tidak ada yang bisa memikirkan bagaimana melakukannya secara berbeda tanpa kehilangan efisiensi yang dapat diterima, meskipun mereka mencoba.  Tentu saja, semua solusi suatu hari nanti akan ditemukan, tetapi dengan urutan yang salah, mereka akan dicari begitu lama sehingga tidak ada arti praktis dalam hal ini. <br><br>  Ada teknik untuk menulis program untuk menghindari masalah ini.  Tetapi banyak dari mereka membutuhkan keterampilan dan imajinasi khusus untuk digunakan, dan hasilnya adalah program yang sangat besar.  Contohnya adalah teknik batasan ukuran istilah dan definisi pembagian biner dengan sisa melalui perkalian dengan bantuannya.  Alih-alih bodoh menulis definisi matematika <br><br><pre> <code class="plaintext hljs">divo nmqr = (fresh (mq) (multo mq mq) (pluso mq rn) (lto rm))</code> </pre><br>  Saya harus menulis definisi rekursif 20 baris + fungsi bantu besar yang tidak realistis untuk dibaca (saya masih tidak mengerti apa yang sedang dilakukan di sana).  Ini dapat ditemukan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">disertasi</a> Will Bird di bagian Aritmatika Biner Murni. <br><br>  Mengingat hal tersebut di atas, saya ingin membuat semacam modifikasi pencarian sehingga program yang ditulis dengan sederhana dan alami juga berfungsi. <br><br><h3>  Optimalkan </h3><br>  Kami perhatikan bahwa ketika semuanya buruk, pencarian tidak akan berakhir kecuali Anda secara eksplisit menunjukkan jumlah jawaban dan memecahkannya.  Oleh karena itu, mereka memutuskan untuk bertarung tepat dengan ketidaklengkapan pencarian - jauh lebih mudah untuk dikonkritkan daripada “itu bekerja untuk waktu yang lama”.  Secara umum, tentu saja, saya hanya ingin mempercepat pencarian, tetapi jauh lebih sulit untuk diformalkan, jadi kami mulai dengan tugas yang kurang ambisius. <br><br>  Dalam kebanyakan kasus, ketika pencarian berbeda, terjadi situasi yang mudah dilacak.  Jika suatu fungsi disebut rekursif, dan dalam panggilan rekursif, argumennya sama atau kurang spesifik, maka dalam panggilan rekursif yang lain subtugas tersebut dihasilkan lagi dan rekursi tak terbatas terjadi.  Secara formal, kedengarannya seperti ini: ada substitusi, yang berlaku untuk argumen baru, kita mendapatkan yang lama.  Misalnya, pada gambar di bawah ini, panggilan rekursif adalah generalisasi dari aslinya: Anda dapat menggantinya <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>c</mi><mn>2</mn></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.061ex" height="1.696ex" viewBox="0 -520.7 887.4 730.2" role="img" focusable="false" style="vertical-align: -0.487ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-63" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMAIN-32" x="613" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>c</mi><mn>2</mn></msub></math></span></span><script type="math/tex" id="MathJax-Element-19"> c_2 </script>  = [x, 3], <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-20-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>d</mi><mn>2</mn></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.263ex" height="2.298ex" viewBox="0 -780.1 974.4 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMATHI-64" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/hsespb/blog/441114/&amp;usg=ALkJrhjq58RUadfxWXaPtyQwHwgQfza5nA#MJMAIN-32" x="736" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>d</mi><mn>2</mn></msub></math></span></span><script type="math/tex" id="MathJax-Element-20"> d_2 </script>  = x dan dapatkan panggilan asli. <br><br><img src="https://habrastorage.org/webt/kh/22/mk/kh22mkjyiwzn3as3manr6jftdrm.png"><br><br>  Dapat ditelusuri bahwa situasi ini juga terjadi dalam contoh divergensi yang telah kita temui.  Seperti yang saya tulis sebelumnya, ketika Anda menjalankan appendo ke arah yang berlawanan, panggilan rekursif akan dibuat dengan variabel bebas, bukan semua variabel, yang, tentu saja, kurang spesifik daripada panggilan asli, di mana argumen ketiga diperbaiki. <br><br>  Jika kita menjalankan reverso dengan x =?  dan xr = [1, 2, 3], dapat dilihat bahwa panggilan rekursif pertama akan kembali terjadi dengan dua variabel bebas, sehingga argumen baru jelas dapat ditransfer kembali ke yang sebelumnya. <br><br><pre> <code class="plaintext hljs">reverso x x_r  (* x = ?, x_r = [1, 2, 3] *) fresh (ht t_r) (x === Cons (h, t)) (* x_r = [1, 2, 3] = Cons 1 (Cons 2 (Cons 3 Nil))) x = Cons (h, t) *) (reverso t t_r) (* :   t=x, t_r=[1,2,3],    *)</code> </pre><br>  Dengan menggunakan kriteria ini, kita dapat mendeteksi divergensi dalam proses eksekusi program, memahami bahwa semuanya buruk dengan urutan ini, dan secara dinamis mengubahnya ke yang lain.  Berkat ini, idealnya, urutan yang tepat akan dipilih untuk setiap panggilan. <br>  Anda dapat melakukannya dengan naif: jika perbedaan ditemukan dalam kata sambung, maka kami memalu semua jawaban yang telah ia temukan dan menunda pelaksanaannya sampai nanti, "melewatkan" konjungsi berikutnya.  Kemudian, mungkin, ketika kita terus menjalankannya, lebih banyak informasi akan diketahui dan perbedaan tidak akan muncul.  Dalam contoh kami, ini akan mengarah pada konjungsi swap yang diinginkan. <br><br>  Ada cara yang kurang naif yang memungkinkan, misalnya, untuk tidak kehilangan pekerjaan yang sudah dilakukan, menunda kinerja.  Sudah dengan varian paling bodoh dari mengubah urutan, divergensi telah menghilang dalam semua contoh sederhana yang menderita non-komutatif dari konjungsi, yang kita tahu, termasuk: <br><br><ul><li>  menyortir daftar angka (ini juga merupakan generasi dari semua permutasi daftar), <br></li><li>  Aritmetika peano dan aritmetika biner, <br></li><li>  generasi pohon biner dengan ukuran tertentu. <br></li></ul><br>  Ini merupakan kejutan yang tidak terduga bagi kami.  Selain perbedaan, pengoptimalan juga berjuang melawan perlambatan program.  Diagram di bawah ini menunjukkan waktu eksekusi program dengan dua perintah yang berbeda dalam hubungannya (relatif berbicara, salah satu yang terbaik dan satu dari banyak yang buruk).  Diluncurkan pada komputer dengan konfigurasi Intel Core i7 CPU M 620, 2,67GHz x 4, 8GB RAM dengan sistem operasi Ubuntu 16.04. <br><br>  Ketika <b>pesanan sudah optimal</b> (kami memilihnya dengan tangan), optimasi sedikit memperlambat eksekusi, tetapi tidak kritis <br><img src="https://habrastorage.org/webt/3a/si/4z/3asi4zevbggj_7hmjk6j2lilk0u.png"><br><br>  Tetapi ketika <b>urutannya tidak optimal</b> (misalnya, hanya cocok untuk diluncurkan pada arah yang berlawanan), dengan pengoptimalan ternyata jauh lebih cepat.  Persilangan berarti bahwa kita tidak bisa menunggu sampai akhir, itu bekerja lebih lama <br><img src="https://habrastorage.org/webt/yw/-_/sn/yw-_snesnrnadqet8zmgbbpk3la.png"><br><br><h3>  Cara memecahkan apa pun </h3><br>  Semua ini didasarkan pada intuisi dan kami ingin membuktikannya dengan ketat.  Teori setelah semua. <br><br>  Untuk membuktikan sesuatu, kita perlu semantik formal bahasa.  Kami menggambarkan semantik operasional untuk miniKanren.  Ini adalah versi yang disederhanakan dan secara matematis dari implementasi bahasa nyata.  Ini menggunakan versi yang sangat terbatas (karena itu mudah digunakan), di mana Anda hanya dapat menentukan eksekusi akhir program (pencarian harus final).  Tetapi untuk tujuan kita, inilah yang dibutuhkan. <br><br>  Untuk membuktikan kriteria, lemma pertama kali dirumuskan: pelaksanaan program dari keadaan yang lebih umum akan bekerja lebih lama.  Secara formal: pohon output dalam semantik memiliki ketinggian besar.  Ini dibuktikan dengan induksi, tetapi pernyataan itu harus digeneralisasikan dengan sangat hati-hati, jika tidak, hipotesis induktif tidak akan cukup kuat.  Ini mengikuti dari lemma ini bahwa jika kriteria bekerja selama eksekusi program, maka pohon output memiliki subtree sendiri lebih tinggi atau sama tinggi.  Ini memberikan kontradiksi, karena untuk semantik yang diberikan secara induktif semua pohon terbatas.  Ini berarti bahwa dalam semantik kami, eksekusi program ini tidak dapat diekspresikan, yang menyiratkan bahwa pencarian di dalamnya tidak berakhir. <br><br>  Metode yang diusulkan adalah konservatif: kita mengubah sesuatu hanya ketika kita yakin bahwa semuanya sudah benar-benar buruk dan tidak mungkin menjadi lebih buruk, oleh karena itu kita tidak merusak apa pun dalam hal penyelesaian program. <br><br>  Bukti utama berisi banyak detail, jadi kami memiliki keinginan untuk memverifikasinya secara formal dengan menulis ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Coq</a> .  Namun, ternyata secara teknis cukup sulit, jadi kami mendinginkan semangat kami dan secara serius terlibat dalam verifikasi otomatis hanya di lembaga magistrasi. <br><br><h3>  Posting </h3><br>  Di tengah pekerjaan, kami mempresentasikan studi ini di sesi poster <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ICFP-2017 di Kompetisi Penelitian Mahasiswa</a> .  Di sana kami bertemu dengan pencipta bahasa - Will Bird dan Daniel Friedman - dan mereka mengatakan bahwa itu bermakna dan kita perlu melihatnya secara lebih rinci.  Ngomong-ngomong, Will umumnya berteman dengan laboratorium kami di JetBrains Research.  Semua penelitian kami tentang miniKanren dimulai ketika, pada 2015, Will mengadakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sekolah musim panas</a> dalam pemrograman relasional di St. Petersburg. <br><br>  Setahun kemudian, kami membawa karya kami ke bentuk yang kurang lebih lengkap dan mempresentasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> di Prinsip dan Praktek Pemrograman Deklaratif 2018. <br><br><h2>  Apa yang saya lakukan di sekolah pascasarjana </h2><br>  Kami ingin terus terlibat dalam semantik formal untuk mini Kanren dan bukti kuat semua propertinya.  Dalam literatur, biasanya properti (seringkali jauh dari jelas) hanya dipostulatkan dan didemonstrasikan menggunakan contoh, tetapi tidak ada yang membuktikan apa pun.  Misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buku utama</a> tentang pemrograman relasional adalah daftar pertanyaan dan jawaban, yang masing-masing dikhususkan untuk bagian kode tertentu.  Bahkan untuk pernyataan kelengkapan pencarian interleaving (dan ini adalah salah satu keuntungan paling penting dari miniKanren atas Prolog standar), tidak mungkin untuk menemukan kata-kata yang ketat.  Anda tidak bisa hidup seperti itu, kami memutuskan, dan, setelah menerima berkah dari Will, kami mulai bekerja. <br><br>  Biarkan saya mengingatkan Anda bahwa semantik yang kami kembangkan pada tahap sebelumnya memiliki batasan yang signifikan: hanya program dengan pencarian terbatas yang dijelaskan.  Di miniKanren, menjalankan program juga menarik karena mereka dapat mendaftar dengan jumlah jawaban yang tak terbatas.  Oleh karena itu, kami membutuhkan semantik yang lebih keren. <br><br>  Ada banyak cara standar yang berbeda untuk mendefinisikan semantik bahasa pemrograman, kami hanya harus memilih salah satunya dan menyesuaikannya dengan kasus tertentu.  Kami menggambarkan semantik sebagai sistem transisi berlabel - satu set keadaan yang mungkin dalam proses pencarian dan transisi antara negara-negara ini, beberapa di antaranya ditandai, yang berarti bahwa pada tahap pencarian ini, jawaban lain ditemukan.  Eksekusi program tertentu dengan demikian ditentukan oleh urutan transisi tersebut.  Urutan-urutan ini dapat terbatas (datang ke keadaan terminal) atau tidak terbatas, menggambarkan secara simultan mengakhiri dan tidak menyelesaikan program.  Untuk benar-benar menentukan objek seperti itu secara matematis, kita perlu menggunakan definisi koinduktif. <br><br>     <b></b> —     .      <b></b> ,            (,          ,  —     ..).          ,   miniKanren'      (   ). <br><br>      ,    ,        —        .    .  (  ),       ,       . <br>            (    ):        , ,        ,      . <br><br>           , ,  /     . <br><br>             Coq'a.        ,             ,      «. Qed».      . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id441114/">https://habr.com/ru/post/id441114/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id441098/index.html">Kedalaman SIEM: korelasi out-of-box. Bagian 4. Model sistem sebagai konteks aturan korelasi</a></li>
<li><a href="../id441102/index.html">Kaspersky Mobile Talks - pertemuan untuk pengembang tingkat lanjut</a></li>
<li><a href="../id441104/index.html">Memperoleh informasi dan melewati otentikasi dua faktor pada kartu bank dari TOP-10 (Ukraina)</a></li>
<li><a href="../id441108/index.html">Sudah bukan konsep: Samsung memperkenalkan telepon lipat Galaxy Fold seharga $ 1980</a></li>
<li><a href="../id441112/index.html">Kami mempercepat otorisasi LDAP ke Kubernetes</a></li>
<li><a href="../id441116/index.html">KubeSail dan kluster Kubernetes gratis untuk pengembang</a></li>
<li><a href="../id441122/index.html">Magento 2 EAV: Gambaran Umum Struktur Data</a></li>
<li><a href="../id441124/index.html">Positif Salah di PVS-Studio: Seberapa Jauh Lubang Kelinci Berlangsung</a></li>
<li><a href="../id441126/index.html">Positif palsu di PVS-Studio: seberapa dalam lubang kelinci</a></li>
<li><a href="../id441128/index.html">Pilihan yang tepat: studi langsung tentang kemampuan kognitif kera antropoid</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>