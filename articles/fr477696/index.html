<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçüåæ üññüèº ‚óºÔ∏è Domaine frontal bas√© sur TLS 1.3. 2e partie ü§ûüèª üë´ ‚ÅâÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©sentation 
 Dans la premi√®re partie de l' article, nous avons donn√© une br√®ve description du m√©canisme SNI chiffr√© (eSNI). Ils ont montr√© comment, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Domaine frontal bas√© sur TLS 1.3. 2e partie</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477696/"><h3>  Pr√©sentation </h3><br>  Dans la premi√®re partie de l' <a href="https://habr.com/ru/post/475372/">article,</a> nous avons donn√© une br√®ve description du m√©canisme SNI chiffr√© (eSNI).  Ils ont montr√© comment, sur sa base, il est possible d'√©chapper √† la d√©tection par les syst√®mes DPI modernes (en utilisant le DPI Beeline et le rutracker ILV interdit comme exemple), ainsi qu'en explorant une nouvelle version du front-end de domaine bas√© sur ce m√©canisme. <br><br>  Dans la deuxi√®me partie de l'article, nous allons passer √† des choses plus pratiques que RedTeam sera utile aux sp√©cialistes dans leur travail difficile.  En fin de compte, notre objectif n'est pas d'acc√©der aux ressources bloqu√©es (pour de telles choses courantes, nous avons un bon vieux VPN).  Heureusement, il existe de nombreux fournisseurs de VPN, comme on dit, pour tous les go√ªts, couleurs et budgets. <br><br>  Nous essaierons d'appliquer le m√©canisme de gestion de domaine aux outils RedTeam modernes, tels que Cobalt Strike, Empire, etc., et leur donnerons des opportunit√©s suppl√©mentaires pour imiter et √©chapper aux syst√®mes de filtrage de contenu modernes. <br><a name="habracut"></a><br>  La derni√®re fois, nous avons impl√©ment√© le m√©canisme eSNI dans la biblioth√®que OpenSSL et l'avons utilis√© avec succ√®s dans l'utilitaire curl familier.  Mais une boucle, comme on dit, ne sera pas pleine.  Bien s√ªr, je veux impl√©menter quelque chose de similaire dans les langages de haut niveau.  Mais, malheureusement, une recherche rapide de l'immensit√© du r√©seau nous d√©√ßoit, car la prise en charge du m√©canisme eSNI n'est pleinement impl√©ment√©e que dans GOLANG.  Ainsi, notre choix n'est pas tr√®s large: soit nous √©crivons en C ou C ++ pur en utilisant la biblioth√®que OpenSSL patch√©, soit nous utilisons un fork GOLANG distinct de CloudFlare et essayons d'y porter nos outils.  En principe, il existe une autre option, plus classique, mais qui prend √©galement beaucoup de temps - est d'impl√©menter le support eSNI pour python.  Apr√®s tout, Python utilise √©galement OpenSSL pour fonctionner avec https.  Mais nous laisserons cette option de d√©veloppement √† quelqu'un d'autre, et nous nous contenterons de la mise en ≈ìuvre sur le Golang, d'autant plus que notre bien-aim√© Cobalt Strike est parfaitement capable de travailler avec un canal de communication construit par des outils tiers (canal C2 externe) - nous en parlerons √† la fin de l'article. <br><br><h3>  Essayez plus fort ... </h3><br>  L'un des outils mis en ≈ìuvre sur Go est notre d√©veloppement pour pivoter √† l'int√©rieur du r√©seau - le <a href="https://github.com/mis-team/rsockstun">tuner</a> rsockstun, qui, incidemment, est maintenant d√©tect√© par les outils Microsoft et Symantec comme un logiciel tr√®s malveillant visant √† violer la stabilit√© mondiale ... <br><br><img src="https://habrastorage.org/webt/fg/mu/z4/fgmuz4c7bq1aazvf6su5qjbh32o.png"><br><br>  Ce serait formidable d'utiliser le d√©veloppement pr√©c√©dent dans ce cas.  Mais ici, un petit probl√®me se pose.  Le fait est que rsockstun implique initialement l'utilisation d'un canal de communication SSL synchrone avec le serveur.  Cela signifie que la connexion est √©tablie une fois et existe pour toute la dur√©e de l'op√©ration du tunnel.  Et, comme vous le comprenez, le protocole https n'est pas con√ßu pour ce mode de fonctionnement - il fonctionne dans le mode requ√™te-r√©ponse, o√π chaque nouvelle requ√™te http existe dans le cadre d'une nouvelle connexion TCP. <br><br>  Le principal inconv√©nient de ce sch√©ma est que le serveur ne peut pas transf√©rer de donn√©es au client jusqu'√† ce que le client envoie une nouvelle requ√™te http.  Mais, heureusement, il existe de nombreuses options pour r√©soudre ce probl√®me - la diffusion de donn√©es via le protocole http (√† la fin, nous parvenons √† regarder nos √©missions de t√©l√©vision pr√©f√©r√©es et √† √©couter de la musique √† partir de portails fonctionnant sur https, et la transmission vid√©o et audio n'est pas que autres que le streaming de donn√©es).  L'une des technologies permettant d'√©muler le fonctionnement d'une connexion TCP √† part enti√®re sur le protocole http est la technologie WebSockets, dont l'essence principale est l'organisation d'une connexion r√©seau √† part enti√®re entre le client et le serveur Web. <br><br>  √Ä notre chance (hourra hourra !!!), cette technologie est incluse par d√©faut dans tous les plans tarifaires CloudFlare et fonctionne tr√®s bien en combinaison avec eSNI.  C'est exactement ce que nous allons utiliser pour apprendre √† notre tunnel √† utiliser les fronts de domaine et √† se cacher des DPI modernes. <br><br><h3>  Un peu sur les WebSockets </h3><br>  Tout d'abord, nous parlerons bri√®vement et en termes simples des sockets Web afin que tout le monde ait une id√©e de ce avec quoi nous travaillerons. <br><br>  La technologie de socket Web vous permet de passer temporairement d'une connexion http √† des donn√©es de streaming standard sur une socket r√©seau sans interrompre la connexion TCP √©tablie.  Lorsqu'un client souhaite passer √† une socket Web, il d√©finit plusieurs en-t√™tes http dans sa requ√™te http.  Deux en-t√™tes requis sont <i><b>Connection: Upgrade</b></i> et <i><b>Upgrade: websocket</b></i> .  Il peut √©galement forcer la version du protocole websocket ( <i><b>Sec-Websockset-Version: 13</b></i> ) et quelque chose comme l'identificateur de socket web base64 ( <i><b>Sec-WebSocket-Key: DAGDJSiREI3 + KjDfwxm1FA ==</b></i> ).  Le serveur r√©pond avec des protocoles de commutation http-code 101 et d√©finit √©galement les en <i><b>-</b></i> t√™tes <i><b>Connection, Upgrade</b></i> et <i><b>Sec-WebSocket-Accept</b></i> .  Le processus de commutation est illustr√© dans la capture d'√©cran ci-dessous: <br><br><img src="https://habrastorage.org/webt/ci/tp/bg/citpbgee5m4fyv9-w5akwwq5t8q.png"><br><br>  Apr√®s cela, la connexion WebSocket peut √™tre consid√©r√©e comme termin√©e.  Toutes les donn√©es du client et du serveur seront d√©sormais fournies non pas avec http, mais avec les en-t√™tes WebSocket (ils commencent par l'octet 0x82).  Maintenant, le serveur n'a pas besoin d'attendre une demande du client pour transf√©rer des donn√©es, comme  la connexion TCP n'est pas interrompue. <br><br>  Il existe plusieurs biblioth√®ques dans le gang des sockets Web.  Les plus populaires d'entre eux sont <a href="https://github.com/gorilla/websocket">Gorilla WebSocket</a> et <a href="https://godoc.org/golang.org/x/net/websocket">WebSocket</a> standard.  Nous utiliserons ce dernier, car  il est plus simple, plus petit et fonctionne, comme on dit, un peu plus vite. <br><br>  Dans le code client rsockstun, nous devons remplacer les appels net.dial ou tls.dial par les appels WebSocket correspondants: <br><br><img src="https://habrastorage.org/webt/ye/dw/vy/yedwvync3yktwhl_ssd2vm8eniy.png"><br><br><img src="https://habrastorage.org/webt/mw/j3/fw/mwj3fwfivbj7aqqsbg7whlkt9ai.png"><br><br>  Nous voulons rendre la partie client de notre tunnel universelle et capable de fonctionner √† la fois via une connexion SSL directe et via le protocole WebSockset.  Pour ce faire, nous allons cr√©er une fonction distincte <i><b>func connectForWsSocks (cha√Æne d'adresse, cha√Æne proxy) erreur {...}</b></i> par analogie avec <i><b>connectForSocks ()</b></i> et nous l'utiliserons pour travailler avec les sockets Web si l'adresse du serveur sp√©cifi√©e au d√©marrage du client commence par ws: ou wss: (dans le cas de Secure WebSocket). <br><br>  Pour le c√¥t√© serveur du tunnel, nous allons √©galement cr√©er une fonction distincte pour travailler avec les sockets Web.  Une instance de la classe http y sera cr√©√©e et un gestionnaire de connexion http (fonction wsHandler) sera d√©fini: <br><br><img src="https://habrastorage.org/webt/2a/r7/cv/2ar7cvjzjc7wauwsb45ursxie2q.png"><br><br>  Et nous mettrons toute la logique de traitement de la connexion (autoriser le client avec un mot de passe, installer et terminer la session yamux) dans le gestionnaire de connexion WebSocket: <br><br><img src="https://habrastorage.org/webt/6r/kz/ay/6rkzays7haarsd9vyhak3xe4kbw.png"><br><br>  Nous compilons le projet, d√©marrons la partie serveur: <br><br><pre><code class="go hljs">./rsockstun ‚Äìlisten ws:<span class="hljs-number"><span class="hljs-number">127.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>:<span class="hljs-number"><span class="hljs-number">8080</span></span> ‚Äìpass P@ssw0rd</code> </pre> <br>  Et puis la partie client: <br><br><pre> <code class="go hljs">./rsockstun -connect ws:<span class="hljs-number"><span class="hljs-number">127.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>:<span class="hljs-number"><span class="hljs-number">8080</span></span> ‚Äìpass P@ssw0rd</code> </pre> <br>  Et nous v√©rifions le travail sur l'h√¥te local: <br><br><img src="https://habrastorage.org/webt/ci/tl/jh/citljhc7govgdkorfy6xm--c-dw.png"><br><br><img src="https://habrastorage.org/webt/cp/6m/mu/cp6mmuhm2xk5iaupu2wh0kato2s.png"><br><br><h3>  On passe au domaine-fronting </h3><br>  Nous semblons avoir r√©gl√© les sockets Web.  Passons maintenant directement √† l'eSNI et aux fronts de domaine.  Comme mentionn√© pr√©c√©demment, pour travailler avec DoH et eSNI, nous devons prendre une branche sp√©ciale du golang de <a href="https://github.com/cloudflare/tls-tris">CloudFlare</a> .  Nous avons besoin d'une branche avec le support eSNI (pwu / esni). <br><br>  Nous le clonons pour nous localement ou t√©l√©chargeons et d√©veloppons le zip correspondant: <br><br><pre> <code class="plaintext hljs">git clone -b pwu/esni https://github.com/cloudflare/tls-tris.git</code> </pre> <br>  Ensuite, nous devons copier le r√©pertoire GOROOT, remplacer les fichiers correspondants de la branche clon√©e et le d√©finir comme principal.  Pour sauver le d√©veloppeur de ce mal de t√™te, les gars de CloudFlare ont pr√©par√© un script sp√©cial - _dev / go.sh.  Il suffit de l'ex√©cuter.  Le script et le makefile feront tout eux-m√™mes.  Pour le plaisir - vous pouvez regarder √† l'int√©rieur du makefile pour plus de d√©tails. <br><br>  Apr√®s avoir √©labor√© le script, lors de la compilation du projet, nous devrons indiquer comme GOROOT le r√©pertoire local pr√©par√© par le script.  Dans notre cas, cela ressemble √† ceci: <br><br><pre> <code class="plaintext hljs">GOROOT="/opt/tls-tris/_dev/GOROOT/linux_amd64" go build ‚Ä¶.</code> </pre> <br>  Ensuite, nous devons impl√©menter dans le tunnel la fonctionnalit√© de demande et d'analyse des cl√©s eSNI publiques pour le domaine souhait√©.  Dans notre cas, il s'agira de cl√©s eSNI publiques des serveurs frontaux CloudFlare.  Pour ce faire, nous allons cr√©er trois fonctions: <br><br><pre> <code class="plaintext hljs">func makeDoTQuery(dnsName string) ([]byte, error) func parseTXTResponse(buf []byte, wantName string) (string, error) func QueryESNIKeysForHost(hostname string) ([]byte, error)</code> </pre> <br>  Les noms des fonctions parlent en principe d'eux-m√™mes.  Nous prendrons le remplissage du fichier esni_query.go, qui fait partie de tls-tris.  La premi√®re fonction cr√©e un paquet r√©seau avec une demande au serveur DNS CloudFlare en utilisant le protocole DoH (DNS-over-HTTPS), la seconde analyse les r√©sultats de la requ√™te et re√ßoit les valeurs des cl√©s du domaine public, et la troisi√®me est un conteneur pour les deux premi√®res. <br><br>  Ensuite, nous <i><b>introduisons la</b></i> fonction de demande de cl√©s eSNI pour le domaine dans notre fonction de connexion nouvellement cr√©√©e pour la socket Web <i><b>connectForWsSocks</b></i> .  Lorsque la partie serveur fonctionne, d√©finissez les param√®tres TLS et d√©finissez √©galement le nom du faux "domaine de couverture": <br><br><img src="https://habrastorage.org/webt/s0/kk/vu/s0kkvu24eh0wc7olaeffffknrck.png"><br><br>  Il convient de noter ici qu'au d√©part, la branche tls-tris n'a pas √©t√© con√ßue pour l'utilisation de la fa√ßade de domaine.  Par cons√©quent, il ne fait pas attention au faux nom du serveur (un champ serverName vide est transmis dans le cadre du package client-hello).  Afin de r√©soudre ce probl√®me, nous devrons ajouter le champ FakeServerName correspondant √† la structure TlsConfig.  Nous ne pouvons pas utiliser le champ ServerName standard de la structure, car  il est utilis√© par les m√©canismes internes tls et s'il diff√®re de l'original, la poign√©e de main tls se terminera par une erreur.  La description de la structure TlsConfig est contenue dans le <b>fichier tls / common.go</b> - nous devons la corriger: <br><br><img src="https://habrastorage.org/webt/pu/2l/f4/pu2lf425co5cex8zfa-h2ewdbw8.png"><br><br><img src="https://habrastorage.org/webt/q1/jk/2i/q1jk2iiwpohss6nhr1uanlnkqp8.png"><br><br>  De plus, nous devrons apporter des modifications au fichier <b>tls / handshake_client.go</b> pour utiliser notre champ FakeServerName lors de la g√©n√©ration de la n√©gociation TLS: <br><br><img src="https://habrastorage.org/webt/fy/nq/ln/fynqlnmskvfz0exd4im58vzpwfi.png"><br><br>  C‚Äôest tout!  Vous pouvez compiler le projet et v√©rifier le travail.  Mais avant d'ex√©cuter le test, vous devez configurer votre compte CloudFlare.  Eh bien, comment dites-vous de configurer - cr√©ez simplement un compte cloudflare et liez votre domaine √† celui-ci.  Toutes les puces li√©es √† DoH, WebSocket et ESNI sont incluses dans CloudFlare par d√©faut.  Une fois les enregistrements DNS mis √† jour - vous pouvez v√©rifier le domaine en ex√©cutant la demande de cl√© eSNI: <br><br><pre> <code class="plaintext hljs">dig +short txt _esni.df13tester.info</code> </pre> <br><img src="https://habrastorage.org/webt/xh/9a/6g/xh9a6gmmlc1jg-deqesdliip09a.png"><br><br>  Si vous voyez quelque chose de similaire pour votre domaine, alors tout fonctionne pour vous et vous pouvez proc√©der aux tests. <br><br>  Lancez Ubuntu VPS, par exemple, sur DigitalOcean.  PS Dans notre cas, l'adresse IP VPS qui vient d'√™tre √©mise par le fournisseur figurait dans les listes noires ILV.  Ne soyez donc pas surpris si quelque chose de similaire vous arrive.  J'ai d√ª utiliser un VPN pour acc√©der √† mon VPS. <br><br>  Nous copions le rsockstun compil√© sur VPS (c'est d'ailleurs un autre charme du golang - vous pouvez compiler le projet par vous-m√™me et l'ex√©cuter sur n'importe quel Linux, en observant uniquement la capacit√© en bits du syst√®me) et d√©marrer la partie serveur: <br><br><img src="https://habrastorage.org/webt/kx/-w/th/kx-wth7rif35is4bd5_flfmkjzq.png"><br><br>  Et puis la partie client: <br><br><img src="https://habrastorage.org/webt/sf/er/7d/sfer7dpqq1lumfaxmzzxn1n_pfs.png"><br><br>  Comme nous pouvons le voir, le client s'est connect√© avec succ√®s au serveur via le serveur frontal CloudFlare √† l'aide d'un socket Web.  Pour v√©rifier que le tunnel fonctionne exactement comme un tunnel, vous pouvez faire une demande de boucle via les socks5 locaux ouverts sur le serveur: <br><br><img src="https://habrastorage.org/webt/qg/na/ti/qgnati8zvd8jc9okh4bei0kbihm.png"><br><br>  Voyons maintenant ce que DPI voit dans le canal de communication: <br><br><img src="https://habrastorage.org/webt/0p/ph/av/0pphavhdhhnrtfxfkzxsf7vjcxs.png"><br><br>  Tout d'abord, le tuner tunnel, en utilisant le m√©canisme DoH, acc√®de au serveur DNS Cloudflare pour les cl√©s eSNI pour le domaine de destination (packages n ¬∞ 1-19), puis acc√®de au serveur frontal et √©tablit une connexion TLS, se cachant sous le domaine <a href="http://www.google.com/">www.google.com</a> (cette valeur par d√©faut, lorsqu'un faux domaine n'est pas d√©fini au d√©marrage du client).  Pour sp√©cifier votre faux domaine, vous devez utiliser le param√®tre -fronfDomain: <br><br><img src="https://habrastorage.org/webt/zp/8l/0_/zp8l0_a_cktaz6rrrgao4qo8c2g.png"><br><br><img src="https://habrastorage.org/webt/cq/gn/wn/cqgnwnp9bzo7hzjpb8gcgvqfd6i.png"><br><br>  Maintenant encore une chose.  Par d√©faut, les param√®tres de compte de CloudFalre sont d√©finis sur SSL flexible.  Cela signifie que les demandes https vers les serveurs frontaux Cloudflare des clients seront redirig√©es sous forme non chiffr√©e (http) vers notre serveur.  C'est pourquoi nous avons lanc√© la partie serveur du tunnel en mode non ssl (-listen ws: 0.0.0.0), et non (-listen wss: 0.0.0.0). <br><br><img src="https://habrastorage.org/webt/4j/fy/5n/4jfy5nl5csmeqc6bxd7vbgdhm7a.png"><br><br>  Afin de passer en mode de cryptage complet, vous devez s√©lectionner <b>Complet</b> , ou <b>Complet (strict)</b> en cas de pr√©sence de ce certificat sur le serveur.  Apr√®s avoir chang√© de mode, nous pourrons accepter les connexions de CloudFlare via le protocole https.  N'oubliez pas de g√©n√©rer un certificat auto-sign√© pour le c√¥t√© serveur du tunnel. <br><br><img src="https://habrastorage.org/webt/ou/9x/9i/ou9x9ihogwotva8y-xwda5v12ps.png"><br><br>  Un lecteur ennuyeux demandera: ¬´Qu'en est-il du compte client sous Windows?  En effet, √† coup s√ªr, l'application principale du tunnel est de relancer la connexion √† partir des machines et des serveurs d'entreprise, et l√†, en r√®gle g√©n√©rale, c'est toujours Windows.  Comment puis-je compiler un tunnel pour Windows, et m√™me avec une pile TLS sp√©cifique? ¬ªEt maintenant, nous allons pr√©senter une autre puce qui montre √† quel point le golang est pratique.  Nous compilons pour les fen√™tres directement √† partir de Kali, simplement en ajoutant le param√®tre GOOS = windows: <br><br><pre> <code class="plaintext hljs">GOARCH=amd64 GOROOT="/opt/tls-tris/_dev/GOROOT/linux_amd64" GOOS=windows go build -ldflags="-s -w"</code> </pre> <br>  Ou une option 32 bits: <br><br><pre> <code class="plaintext hljs">GOARCH=386 GOROOT="/opt/tls-tris/_dev/GOROOT/linux_amd64" GOOS=windows go build -ldflags="-s -w"</code> </pre> <br>  C‚Äôest tout!  Et plus aucun probl√®me n'est n√©cessaire.  √áa marche vraiment! <br><br><img src="https://habrastorage.org/webt/hq/cc/qf/hqccqf4y2sim1yutlrdduo3kmom.png"><br><br>  Les indicateurs de compilateur ‚Äìw et ‚Äìs sont n√©cessaires pour supprimer les d√©chets exc√©dentaires du fichier ex√©cutable, ce qui le r√©duit de quelques m√©gaoctets.  De plus, il peut ensuite √™tre conditionn√© √† l'aide d'UPX pour r√©duire davantage la taille. <br><br><h3>  Au lieu d'une conclusion </h3><br>  Dans l'article, nous, en utilisant un exemple de tuner √©crit sur un golang, avons clairement d√©montr√© l'utilisation de la nouvelle technologie de fronting de domaine, impl√©ment√©e sur une fonctionnalit√© plut√¥t int√©ressante du protocole TLS 1.3.  De m√™me, vous pouvez adapter la bo√Æte √† outils existante √©crite sur le golang pour qu'elle fonctionne via le serveur CloudFlare, par exemple <a href="https://github.com/Ne0nd0g/merlin">Merlin</a> , le c√©l√®bre C2, ou forcer CobaltStrike Beacon √† utiliser les fronts de domaine eSNI lorsque vous travaillez avec Teamserver via le <a href="https://github.com/ryhanson/ExternalC2">canal C2 externe</a> , impl√©ment√© sur le golang, ou sur le C ++ standard √† l'aide de la version corrig√©e d'OpenSSL, dont nous avons parl√© dans la derni√®re partie de l'article.  En g√©n√©ral, la fantaisie n'a pas de limites. <br><br>  L'exemple du tunnel et de CloudFlare est pr√©sent√© sous la forme d'un concept et il est encore difficile de dire sur les perspectives lointaines de ce type de front de domaine.  Pour le moment, la prise en charge eSNI n'est disponible que sur CloudFlare et, en principe, rien ne les emp√™che de d√©sactiver ce type de front-end et, par exemple, de rompre les connexions tls lorsque les SNI et eSNI ne correspondent pas.  En g√©n√©ral, l'avenir se montrera.  Mais pour l'instant, la perspective de travailler sous le couvert de kremlin.ru semble assez attrayante.  Non? <br><br>  Le code tunnel mis √† jour, ainsi que les fichiers ex√©cutables ex√©cutables compil√©s, sont situ√©s dans une branche de projet distincte sur <a href="https://github.com/mis-team/rsockstun">github</a> .  Il est pr√©f√©rable d'√©crire un probl√®me sur tous les probl√®mes de tunnel possibles sur la page du projet sur GitHub. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr477696/">https://habr.com/ru/post/fr477696/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr477684/index.html">Angular: le meilleur compagnon de construction pour les applications interactives</a></li>
<li><a href="../fr477686/index.html">Notre √† la conf√©rence AI Journey</a></li>
<li><a href="../fr477688/index.html">R√©capitulatif des √©v√©nements informatiques de d√©cembre</a></li>
<li><a href="../fr477692/index.html">Exp√©rience avec ZGC et Shenandoah GC en production</a></li>
<li><a href="../fr477694/index.html">JavaScript n'a pas besoin d'√™tre remplac√© par quoi que ce soit - d'autres langues seront √©galement confront√©es aux m√™mes probl√®mes</a></li>
<li><a href="../fr477700/index.html">Principe d'Hollywood (IoC)</a></li>
<li><a href="../fr477704/index.html">CodeSide. Nouveau jeu pour la c√©l√®bre comp√©tition russe AI Cup</a></li>
<li><a href="../fr477706/index.html">Contenu mixte lors du t√©l√©chargement depuis HTTPS: comment trouver et surmonter</a></li>
<li><a href="../fr477710/index.html">Ce qu'ils n'enseignent pas √† l'√©cole: comment nous formons les ing√©nieurs de support technique</a></li>
<li><a href="../fr477712/index.html">Objets contre structures de donn√©es</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>