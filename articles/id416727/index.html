<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ¾â€ğŸ¤ âœğŸ» ğŸ‘¨â€ğŸ‘¨â€ğŸ‘¦â€ğŸ‘¦ Kursus MIT "Keamanan Sistem Komputer". Kuliah 2: "Kontrol serangan hacker", bagian 3 ğŸ§“ğŸ¿ ğŸ¥‰ ğŸ‘©ğŸ½â€ğŸ’¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Institut Teknologi Massachusetts. Kursus Kuliah # 6.858. "Keamanan sistem komputer." Nikolai Zeldovich, James Mickens. Tahun 2014 
 Keamanan Sistem Ko...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kursus MIT "Keamanan Sistem Komputer". Kuliah 2: "Kontrol serangan hacker", bagian 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/416727/"><h3>  Institut Teknologi Massachusetts.  Kursus Kuliah # 6.858.  "Keamanan sistem komputer."  Nikolai Zeldovich, James Mickens.  Tahun 2014 </h3><br>  Keamanan Sistem Komputer adalah kursus tentang pengembangan dan implementasi sistem komputer yang aman.  Ceramah mencakup model ancaman, serangan yang membahayakan keamanan, dan teknik keamanan berdasarkan pada karya ilmiah baru-baru ini.  Topik meliputi keamanan sistem operasi (OS), fitur, manajemen aliran informasi, keamanan bahasa, protokol jaringan, keamanan perangkat keras, dan keamanan aplikasi web. <br><br>  Kuliah 1: â€œPendahuluan: model ancamanâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 2: "Kontrol serangan hacker" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <a name="habracut"></a><br><br>  Bisakah Anda memberi tahu saya apa kurangnya pendekatan keamanan yang menggunakan <b>halaman penjaga</b> ? <br><br>  <b>Pemirsa:</b> butuh waktu lebih lama! <br><br>  <b>Profesor:</b> tepatnya!  Jadi, bayangkan tumpukan ini sangat, sangat kecil, tetapi saya memilih seluruh halaman untuk memastikan bahwa benda kecil ini tidak diserang oleh pointer.  Ini adalah proses yang sangat intensif secara spasial, dan orang-orang tidak benar-benar menyebarkan sesuatu seperti ini di lingkungan kerja.  Ini mungkin berguna untuk menguji "bug", tetapi Anda tidak akan pernah melakukannya untuk program nyata.  Saya pikir sekarang Anda mengerti apa debugger memori <b>pagar listrik</b> . <br><br>  <b>Hadirin:</b> Mengapa <b>halaman penjaga</b> harus begitu besar? <br><br>  <b>Profesor:</b> Alasannya adalah bahwa mereka biasanya mengandalkan perangkat keras, seperti perlindungan tingkat halaman, untuk menentukan ukuran halaman.  Untuk sebagian besar komputer, 2 halaman berukuran 4 KB dialokasikan untuk setiap buffer yang dialokasikan, berjumlah 8 KB.  Karena heap terdiri dari objek, halaman terpisah dialokasikan untuk setiap fungsi <b>malloc</b> .  Dalam beberapa mode, debugger ini tidak mengembalikan ruang yang disediakan ke program, sehingga <b>pagar listrik</b> sangat lahap dalam hal memori dan tidak boleh dikompilasi dengan kode kerja. <br><br><img src="https://habrastorage.org/webt/cm/l6/oh/cml6ohlrz3im72yoa5u_6n9pomg.jpeg"><br><br>  Pendekatan keamanan lain yang layak untuk dilihat adalah <b>Fat pointer</b> , atau "pointer tebal."  Dalam hal ini, istilah "tebal" berarti bahwa sejumlah besar data dilampirkan ke pointer.  Dalam hal ini, idenya adalah kita ingin mengubah representasi pointer untuk memasukkan informasi tentang batas-batas dalam komposisinya. <br><br>  Pointer 32-bit reguler terdiri dari 32 bit, dan alamat berada di dalamnya.  Jika kita menganggap "pointer tebal", maka itu terdiri dari 3 bagian.  Bagian pertama adalah basis 4-byte, yang berakhiran 4 byte juga dilampirkan.  Di bagian pertama, objek dimulai, di bagian kedua berakhir, dan di bagian ketiga, juga 4 byte, <b>skr</b> alamat tertutup.  Dan dalam batas-batas umum ini adalah sebuah pointer. <br><br><img src="https://habrastorage.org/webt/jd/2o/83/jd2o83flkobiu3caqetom5wpwj8.jpeg"><br><br>  Jadi, ketika kompiler membuat kode akses untuk "penunjuk tebal" ini, ia memperbarui konten dari bagian terakhir dari <b>alamat skr</b> dan secara bersamaan memeriksa konten dari dua bagian pertama untuk memastikan bahwa tidak ada yang buruk terjadi dengan pointer selama proses pembaruan. <br><br>  Bayangkan saya memiliki kode ini: <b>int * ptr = malloc (8)</b> , ini adalah pointer yang dialokasikan 8 byte.  Selanjutnya, saya memiliki beberapa <b>while</b> yang baru saja akan memberikan beberapa nilai ke pointer dan kemudian kenaikan <b>ptr ++</b> pointer berikut.  Setiap kali kode ini dieksekusi pada alamat saat ini dari pointer <b>alamat cur</b> , itu memeriksa apakah pointer berada dalam batas yang ditentukan dalam bagian pertama dan kedua. <br><br>  Ini adalah kasus dalam kode baru yang dihasilkan oleh kompiler.  Grup daring sering menimbulkan pertanyaan tentang apa itu "kode alat".  Ini adalah kode yang dihasilkan oleh kompiler.  Anda, sebagai programmer, hanya melihat apa yang ditampilkan di sebelah kanan - 4 baris ini.  Tetapi sebelum operasi ini, kompiler memasukkan beberapa kode C baru ke dalam <b>alamat skr</b> , memberikan nilai ke pointer dan memeriksa batas setiap waktu. <br><br><img src="https://habrastorage.org/webt/w7/am/vx/w7amvxvkol7dhdi3qdrpkupsgga.jpeg"><br><br>  Dan jika, ketika menggunakan kode baru, nilainya melampaui batas, fungsi terputus.  Ini disebut "kode alat."  Ini berarti bahwa Anda mengambil kode sumber menggunakan program C, lalu menambahkan kode sumber C baru, dan kemudian mengkompilasi program baru.  Jadi ide dasar di balik <b>Fat pointer</b> cukup sederhana. <br><br>  Ada beberapa kelemahan dari pendekatan ini.  Kelemahan terbesar adalah ukuran besar pointer.  Dan ini berarti bahwa Anda tidak bisa hanya mengambil "penunjuk tebal" dan meneruskannya tidak berubah, di luar perpustakaan shell.  Karena mungkin ada harapan bahwa pointer memiliki ukuran standar, dan program akan menyediakannya dengan ukuran ini, yang "tidak akan cocok", karena semuanya akan meledak.  Ada juga masalah jika Anda ingin memasukkan pointer dari tipe ini dalam sebuah <b>struct</b> atau sesuatu seperti itu, karena mereka dapat mengubah ukuran <b>struct</b> . <br><br>  Oleh karena itu, hal yang sangat populer dalam kode C adalah mengambil sesuatu seukuran <b>struct</b> , dan kemudian melakukan sesuatu berdasarkan ukuran ini - simpan ruang disk untuk struktur dengan ukuran ini, dan seterusnya. <br><br>  Dan satu hal yang lebih rumit adalah bahwa petunjuk ini, sebagai suatu peraturan, tidak dapat diperbarui dengan cara atom.  Untuk arsitektur 32-bit, biasanya menulis variabel 32-bit yang bersifat atomik.  Tapi "pointer tebal" berisi 3 ukuran <b>integer</b> , jadi jika Anda memiliki kode yang mengharapkan pointer memiliki nilai atom, Anda mungkin mendapat masalah.  Karena untuk melakukan beberapa pemeriksaan ini, Anda harus melihat alamat saat ini dan kemudian melihat ukurannya, dan kemudian Anda mungkin harus menambahnya, dan seterusnya dan seterusnya.  Dengan demikian, ini dapat menyebabkan kesalahan yang sangat halus jika Anda menggunakan kode yang mencoba untuk menarik paralel antara pointer biasa dan tebal.  Dengan demikian, Anda dapat menggunakan <b>Fat pointer</b> dalam beberapa kasus, seperti <b>pagar Electroc</b> , tetapi efek samping dari penggunaannya sangat signifikan sehingga dalam praktik normal pendekatan ini tidak digunakan. <br><br>  Dan sekarang kita akan berbicara tentang memeriksa batas terkait dengan struktur data bayangan.  Gagasan utama dari struktur ini adalah Anda tahu seberapa besar setiap objek yang akan Anda tempatkan, yaitu, Anda tahu ukuran yang Anda butuhkan untuk memesan objek ini.  Jadi, misalnya, jika Anda memiliki pointer yang Anda panggil dengan fungsi <b>malloc</b> , Anda perlu menentukan ukuran objek: <b>char xp = malloc (size)</b> . <br><br><img src="https://habrastorage.org/webt/40/5x/vq/405xvqrcdftphffsqkxgqxprhfo.jpeg"><br><br>  Jika Anda memiliki sesuatu seperti variabel statis seperti <b>karakter</b> ini <b>[256]</b> , kompiler dapat secara otomatis mengetahui batas-batas yang seharusnya untuk penempatannya. <br><br>  Oleh karena itu, untuk masing-masing petunjuk ini, Anda perlu memasukkan dua operasi.  Ini terutama aritmatika, seperti <b>q = p + 7</b> , atau yang serupa.  Penyisipan ini dilakukan dengan mereferensikan tautan tipe <b>deref * q = 'q'</b> .  Anda mungkin bertanya-tanya mengapa Anda tidak bisa mengandalkan tautan saat menempel?  Mengapa kita perlu melakukan aritmatika ini?  Faktanya adalah bahwa ketika menggunakan C dan c ++, Anda memiliki pointer yang menunjuk ke satu lintasan ke ujung objek yang benar di sebelah kanan, setelah itu Anda menggunakannya sebagai kondisi berhenti.  Jadi, Anda pergi ke objek dan segera setelah Anda mencapai trailing pointer ini, Anda benar-benar menghentikan loop atau membatalkan operasi. <br><br>  Jadi, jika kita mengabaikan aritmatika, kita selalu menyebabkan kesalahan serius, di mana pointer melampaui batas, yang sebenarnya dapat mengganggu pekerjaan banyak aplikasi.  Jadi kami tidak bisa hanya menyisipkan tautan, karena bagaimana Anda tahu bahwa ini terjadi di luar batas yang ditetapkan?  Aritmatika memungkinkan kita untuk mengatakan apakah itu benar atau tidak, dan di sini semuanya akan sah dan benar.  Karena wedging ini menggunakan aritmatika memungkinkan Anda untuk melacak di mana pointer berada relatif terhadap baseline aslinya. <br><br>  Jadi pertanyaan selanjutnya adalah: bagaimana kita benar-benar menerapkan validasi perbatasan?  Karena kita perlu entah bagaimana mencocokkan alamat spesifik dari pointer dengan beberapa jenis informasi batas untuk pointer itu.  Dan oleh karena itu, banyak keputusan Anda sebelumnya menggunakan hal-hal seperti, misalnya, tabel hash, atau pohon, yang memungkinkan Anda untuk melakukan pencarian yang benar.  Jadi, mengingat alamat penunjuk, saya melakukan beberapa pencarian dalam struktur data ini dan mencari tahu batas-batas yang dimilikinya.  Dengan batasan-batasan ini, saya memutuskan apakah saya dapat membiarkan tindakan itu terjadi atau tidak.  Masalahnya adalah ini adalah pencarian yang lambat, karena struktur data ini bercabang, dan ketika memeriksa pohon, Anda perlu memeriksa banyak cabang seperti itu sampai Anda menemukan nilai yang tepat.  Dan bahkan jika itu adalah tabel hash, Anda harus mengikuti rantai kode dan sebagainya.  Jadi, kita perlu mendefinisikan struktur data yang sangat efektif yang melacak batas-batas mereka, yang akan membuat verifikasi ini sangat sederhana dan jelas.  Jadi mari kita mulai sekarang. <br><br>  Tetapi sebelum kita melakukannya, izinkan saya memberi tahu Anda secara singkat tentang cara kerja pendekatan <b>alokasi memori teman</b> .  Karena ini adalah salah satu hal yang sering ditanyakan. <br>  <b>Alokasi memori teman</b> membagi memori menjadi beberapa partisi yang merupakan kelipatan dari kekuatan 2, dan mencoba mengalokasikan permintaan memori di dalamnya.  Mari kita lihat cara kerjanya.  Pada awalnya, <b>alokasi teman</b> memperlakukan memori yang tidak terisi sebagai satu blok besar - ini adalah persegi panjang 128-bit atas.  Kemudian, ketika Anda meminta blok yang lebih kecil untuk alokasi dinamis, ia mencoba untuk membagi ruang alamat ini menjadi bagian-bagian dengan peningkatan 2 sampai menemukan blok yang cukup untuk kebutuhan Anda. <br><br>  Misalkan permintaan tipe <b>a = malloc (28)</b> tiba, yaitu permintaan untuk mengalokasikan 28 byte.  Kami memiliki blok 128 byte yang terlalu boros untuk dialokasikan untuk permintaan ini.  Oleh karena itu, blok kami dibagi menjadi dua blok 64 byte - dari 0 hingga 64 byte dan dari 64 byte hingga 128 byte.  Dan ukuran ini juga besar untuk permintaan kami, jadi <b>sobat</b> lagi membagi satu blok 64 byte menjadi 2 bagian dan menerima 2 blok 32 byte. <br><br><img src="https://habrastorage.org/webt/uj/mt/er/ujmter8tqrakf5gu4pel0v8eawc.jpeg"><br><br>  Kurang tidak mungkin, karena 28 byte tidak akan cocok, dan 32 adalah ukuran minimum yang paling cocok.  Jadi sekarang blok 32 byte ini akan dialokasikan ke alamat kami a.  Misalkan kita memiliki permintaan lain untuk <b>b = malloc (50)</b> .  <b>Sobat</b> memeriksa blok yang dipilih, dan karena 50 lebih besar dari setengah dari 64, tetapi kurang dari 64, menempatkan nilai b di blok paling kanan. <br><br>  Akhirnya, kami memiliki permintaan lain untuk 20 byte: <b>c = malloc (20)</b> , nilai ini ditempatkan di blok tengah. <br><br><img src="https://habrastorage.org/webt/mu/zh/cm/muzhcmr1dbp7u7fhz6myj4d1iom.jpeg"><br><br>  <b>Buddy</b> memiliki properti yang menarik: ketika Anda membebaskan memori di blok dan di sebelahnya adalah blok dengan ukuran yang sama, setelah membebaskan kedua blok, <b>buddy</b> menggabungkan dua blok tetangga yang kosong menjadi satu. <br><br><img src="https://habrastorage.org/webt/72/0z/9t/720z9tqbxfmo-umch8rnd9uffry.jpeg"><br><br>  Misalnya, ketika kita memberikan perintah <b>Â© gratis</b> , kita akan <b>membebaskan</b> blok tengah, tetapi penyatuan tidak akan terjadi, sehingga blok di sebelahnya masih sibuk.  Tetapi setelah membebaskan blok pertama menggunakan perintah <b>(a) gratis</b> , kedua blok akan bergabung menjadi satu.  Kemudian, jika kita membebaskan nilai b, blok tetangga akan digabungkan lagi dan kita akan mendapatkan seluruh blok dengan ukuran 128 byte, seperti pada awalnya.  Keuntungan dari pendekatan ini adalah bahwa Anda dapat dengan mudah menemukan di mana sobat adalah dengan aritmatika sederhana dan menentukan batas-batas memori.  Inilah cara alokasi memori bekerja dengan pendekatan <b>alokasi memori Sobat</b> . <br><br>  Semua kuliah saya sering ditanyakan, bukankah pendekatan seperti itu sia-sia?  Bayangkan bahwa pada awalnya saya memiliki permintaan 65 byte, saya harus mengalokasikan seluruh blok 128 byte untuk itu.  Ya, ini boros, sebenarnya Anda tidak memiliki memori dinamis dan Anda tidak dapat lagi mengalokasikan sumber daya di blok yang sama.  Tapi sekali lagi, ini kompromi, karena sangat mudah untuk membuat perhitungan, cara membuat merger dan sejenisnya.  Jadi, jika Anda menginginkan alokasi memori yang lebih akurat, Anda perlu menggunakan pendekatan yang berbeda. <br><br>  Jadi, apa yang sistem <b>Buggy bouncing checking (BBC)</b> lakukan? <br><br><img src="https://habrastorage.org/webt/bw/ps/a9/bwpsa9a28xloyxprpcco0vw79ca.jpeg"><br><br>  Dia melakukan beberapa trik, salah satunya adalah pemisahan blok memori menjadi 2 bagian, salah satunya berisi objek, dan yang kedua adalah tambahan untuk itu.  Jadi, kita memiliki 2 jenis batas - batas objek dan batas distribusi memori.  Keuntungannya adalah tidak perlu menyimpan alamat dasar, dan pencarian cepat menggunakan tabel garis dimungkinkan. <br><br>  Semua ukuran distribusi kami adalah 2 pangkat dari <b>n</b> , di mana <b>n</b> adalah bilangan bulat.  Prinsip <b>2n</b> ini disebut <b>kekuatan dua</b> .  Oleh karena itu, kita tidak perlu banyak bit untuk membayangkan seberapa besar ukuran distribusi tertentu.  Sebagai contoh, jika ukuran cluster adalah 16, maka Anda hanya perlu memilih 4 bit - ini adalah konsep logaritma, yaitu, 4 adalah eksponen <b>n</b> , di mana Anda perlu menaikkan angka 2 untuk mendapatkan 16. <br><br>  Ini adalah pendekatan yang cukup ekonomis untuk alokasi memori, karena jumlah minimum byte yang digunakan, tetapi harus kelipatan 2, yaitu, Anda dapat memiliki 16 atau 32, tetapi tidak 33 byte.  Selain itu, <b>pemeriksaan bouncing Buggy</b> memungkinkan Anda untuk menyimpan informasi tentang nilai batas dalam array linier (1 byte per catatan) dan memungkinkan Anda untuk mengalokasikan memori dalam 1 slot dengan ukuran 16 byte.  mengalokasikan memori dengan granularity slot.  Apa artinya ini? <br><br><img src="https://habrastorage.org/webt/3w/26/nm/3w26nmli9ja80jxthanvcktdhqq.jpeg"><br><br>  Jika kita memiliki slot 16-byte di mana kita akan meletakkan nilai <b>p = malloc (16)</b> , maka nilai dalam tabel akan terlihat seperti <b>tabel [p / slot.size] = 4</b> . <br><br><img src="https://habrastorage.org/webt/al/x7/vj/alx7vjrhny1zzkkjusqvt3iuv3c.jpeg"><br><br>  Misalkan kita sekarang perlu menempatkan nilai 32 byte dalam ukuran <b>p = malloc (32)</b> .  Kami perlu memperbarui tabel perbatasan agar sesuai dengan ukuran baru.  Dan ini dilakukan dua kali: pertama sebagai <b>tabel [p / slot.size] = 5</b> , dan kemudian sebagai <b>tabel [(p / slot.size) + 1] = 5</b> - pertama kali untuk slot pertama, yang dialokasikan untuk memori ini, dan yang kedua kali - untuk slot kedua.  Jadi kami mengalokasikan 32 byte memori.  Inilah yang tampak seperti log distribusi ukuran.  Jadi, untuk dua slot alokasi memori, tabel batas diperbarui dua kali.  Apakah itu jelas?  Contoh ini ditujukan untuk orang yang meragukan apakah log dan tabel memiliki arti atau tidak.  Karena tabel dikalikan setiap kali alokasi memori terjadi. <br><br>  Mari kita lihat apa yang terjadi dengan tabel perbatasan.  Misalkan kita memiliki kode C yang terlihat seperti ini: <b>p '= p + i</b> , yaitu, pointer <b>p'</b> diperoleh dari <b>p dengan</b> menambahkan beberapa variabel <b>i</b> .  Jadi bagaimana kita mendapatkan ukuran memori yang dialokasikan untuk <b>p</b> ?  Untuk melakukan ini, Anda melihat tabel menggunakan kondisi logis berikut: <br><br>  <b>size = 1 &lt;&lt; tabel [p &gt;&gt; log slot_size]</b> <br><br><img src="https://habrastorage.org/webt/bo/pw/nv/bopwnvj0ek93xhrzu4vqwhcqcf8.jpeg"><br><br>  Di sebelah kanan kita memiliki ukuran data yang dialokasikan untuk <b>p</b> , yang seharusnya 1. Kemudian Anda memindahkannya ke kiri dan melihat tabel, ambil ukuran pointer ini, lalu pindah ke kanan, di mana log dari tabel ukuran slot berada.  Jika aritmatika berfungsi, maka kita mengikat pointer dengan benar ke tabel batas.  Artinya, ukuran penunjuk harus lebih besar dari 1, tetapi lebih kecil dari ukuran slot.  Di sebelah kiri kita memiliki nilai, dan di sebelah kanan - ukuran slot, dan nilai pointer terletak di antara mereka. <br><br>  Misalkan ukuran pointer adalah 32 byte, maka dalam tabel, di dalam tanda kurung, kita akan memiliki angka 5. <br><br>  Misalkan kita ingin menemukan kata kunci dasar dari penunjuk ini: <b>base = p &amp; n (ukuran - 1)</b> .  Apa yang akan kita lakukan memberi kita massa tertentu, dan massa ini akan memungkinkan kita untuk mengembalikan <b>basis yang</b> terletak di sini.  Bayangkan ukuran kita 16, dalam biner 16 = ... 0010000.  Ellipsis berarti masih ada banyak nol, tetapi kami tertarik pada unit ini dan nol di belakangnya.  Jika kita mempertimbangkan (16 -1), maka akan terlihat seperti ini: (16 - 1) = ... 0001111.  Dalam kode biner, kebalikan dari ini akan terlihat seperti ini: ~ (16-1) ... 1110000. <br><br><img src="https://habrastorage.org/webt/8q/yj/xz/8qyjxz4dqge5f0oygbg1bhszkks.jpeg"><br><br><img src="https://habrastorage.org/webt/ue/2h/hb/ue2hhb2uzpelqgvzpmzi75c6-mo.jpeg"><br><br>  Dengan demikian, hal ini memungkinkan kita untuk pada dasarnya menghapus bit, yang pada dasarnya akan diberikan dari pointer saat ini dan memberi kita <b>basisnya</b> .  Berkat ini, akan sangat mudah bagi kami untuk memeriksa apakah pointer ini berada dalam batas.  Jadi kita cukup memeriksa bahwa <b>(p ')&gt; = basis</b> dan apakah nilai ( <b>p'</b> - basis) lebih kecil dari ukuran yang dipilih. <br><br><img src="https://habrastorage.org/webt/x6/w8/il/x6w8ilmsiya6i3irbyat6nd51cy.jpeg"><br><br>  Ini adalah hal yang cukup sederhana untuk mengetahui apakah pointer berada dalam batas memori.  Saya tidak akan masuk ke rincian, cukuplah untuk mengatakan bahwa semua aritmatika biner diselesaikan dengan cara yang sama.  Trik semacam itu memungkinkan Anda menghindari perhitungan yang lebih rumit. <br><br>  Ada satu lagi, properti kelima dari <b>pemeriksaan bouncing Buggy</b> - ia menggunakan sistem memori virtual untuk mencegah melampaui batas yang ditetapkan untuk pointer.  Gagasan utamanya adalah jika kita memiliki aritmatika untuk pointer yang kita tentukan jalan keluarnya, maka kita dapat mengatur bit orde tinggi untuk pointer. <br><br><img src="https://habrastorage.org/webt/ns/56/tz/ns56tz8drovqvtuwnrsc6qanksc.jpeg"><br><br>  Dengan demikian, kami menjamin bahwa penereferensi pointer tidak akan menyebabkan masalah perangkat keras.  Menyetel <b>urutan tinggi agak tinggi</b> dengan sendirinya tidak menyebabkan masalah, dereferensi penunjuk dapat menyebabkan masalah. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/r4KjHEgg9Wg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Versi lengkap dari kursus ini tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Terima kasih telah tinggal bersama kami.  Apakah Anda suka artikel kami?  Ingin melihat materi yang lebih menarik?  Dukung kami dengan melakukan pemesanan atau merekomendasikannya kepada teman-teman Anda, <b>diskon 30% untuk pengguna Habr pada analog unik dari server entry-level yang kami temukan untuk Anda:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Seluruh kebenaran tentang VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps dari $ 20 atau bagaimana membagi server?</a>  (opsi tersedia dengan RAID1 dan RAID10, hingga 24 core dan hingga 40GB DDR4). <br><br>  <b>Dell R730xd 2 kali lebih murah?</b>  Hanya kami yang memiliki <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2 x Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 TV dari $ 249</a> di Belanda dan Amerika Serikat!</b>  Baca tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara Membangun Infrastruktur Bldg.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kelas menggunakan server Dell R730xd E5-2650 v4 seharga 9.000 euro untuk satu sen?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id416727/">https://habr.com/ru/post/id416727/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id416713/index.html">Laporan Club of Rome 2018, Bab 3.14: â€œBukan PDB tunggal ...â€</a></li>
<li><a href="../id416719/index.html">Ekstensi PHP dan Kotlin Asli. Bagian Dua, Sadar</a></li>
<li><a href="../id416721/index.html">Rumah DIY: rumah boneka untuk dewasa</a></li>
<li><a href="../id416723/index.html">Aksesibilitas API: Antarmuka Bahasa Alami</a></li>
<li><a href="../id416725/index.html">Kotlin DSL: Teori dan Praktek</a></li>
<li><a href="../id416729/index.html">Program PYCON RUSSIA siap: 25 laporan dan 3 lokakarya dari para pembicara dari Google, Red Hat, Yelp, Yandex</a></li>
<li><a href="../id416731/index.html">Frost on glass: cara membuat plastik metglass tugas berat</a></li>
<li><a href="../id416737/index.html">A * Path Finding Algorithm dalam Voxel 3d Unity Game</a></li>
<li><a href="../id416739/index.html">ASUS baru di Computex 2018</a></li>
<li><a href="../id416741/index.html">Penyerang menggunakan sertifikat D-Link curian dalam perangkat lunak pencurian kata sandi mereka</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>