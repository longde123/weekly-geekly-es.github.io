<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçπ üî∂ üë∂üèæ Traitement concurrentiel h√©t√©rog√®ne et en temps r√©el des donn√©es strictement une fois üêÇ üåö üõåüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Annotation 


 Le traitement des donn√©es en temps r√©el exactement une fois ( exactement une fois ) est une t√¢che extr√™mement simple et n√©cessite une a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Traitement concurrentiel h√©t√©rog√®ne et en temps r√©el des donn√©es strictement une fois</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413817/"><p><img src="https://habrastorage.org/webt/uf/mh/m-/ufmhm-q0wjfbdgbv4jn4ece8duw.jpeg" alt="Saucisse comp√©titive"></p><br><h2 id="annotaciya">  Annotation </h2><br><p>  Le traitement des donn√©es en temps r√©el exactement une fois ( <em>exactement une fois</em> ) est une t√¢che extr√™mement simple et n√©cessite une approche s√©rieuse et r√©fl√©chie tout au long de la cha√Æne de calculs.  Certains pensent m√™me qu'une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">telle t√¢che est impossible</a> .  En r√©alit√©, je veux avoir une approche qui fournit un traitement tol√©rant aux pannes sans aucun d√©lai et l'utilisation de divers stockages de donn√©es, ce qui met en avant de nouvelles exigences encore plus strictes pour le syst√®me: <em>simultan√© une seule fois</em> et l'h√©t√©rog√©n√©it√© de la couche persistante.  √Ä ce jour, une telle exigence ne prend en charge aucun des syst√®mes existants. </p><br><p>  L'approche propos√©e r√©v√©lera de mani√®re coh√©rente les ingr√©dients secrets et les concepts n√©cessaires qui facilitent la mise en ≈ìuvre d' <em>un</em> traitement <em>simultan√©</em> h√©t√©rog√®ne <em>simultan√© √†</em> partir de deux composants. </p><br><h2 id="vvedenie">  Pr√©sentation </h2><br><p>  Le d√©veloppeur de syst√®mes distribu√©s passe par plusieurs √©tapes: </p><br><p>  <em>√âtape 1: algorithmes</em> .  Voici l'√©tude des algorithmes de base, des structures de donn√©es, des approches de programmation telles que la POO, etc.  Le code est exclusivement monothread.  La phase initiale d'entr√©e dans la profession.  Cependant, c'est assez compliqu√© et peut durer des ann√©es. </p><br><p>  <em>√âtape 2: Multithreading</em> .  Ensuite, des questions se posent pour extraire une efficacit√© maximale du fer, il y a le multithreading, l'asynchronie, la course, le d√©bogage, le strace, les nuits blanches ... Beaucoup sont bloqu√©s √† ce stade et commencent m√™me √† ressentir un frisson inexplicable √† un moment donn√©.  Mais seuls quelques-uns parviennent √† comprendre l'architecture de la m√©moire virtuelle et des mod√®les de m√©moire, des algorithmes sans verrouillage / sans attente et divers mod√®les asynchrones.  Et presque personne jamais - la v√©rification de code multi-thread. </p><br><p>  <em>√âtape 3: Distribution</em> .  Ici, une telle poubelle se produit que ni dans un conte de f√©es ni un stylo √† d√©crire. </p><a name="habracut"></a><br><p>  Il semblerait que quelque chose de compliqu√©.  Nous faisons la transformation: plusieurs threads -&gt; de nombreux processus -&gt; de nombreux serveurs.  Mais chaque √©tape de la transformation entra√Æne des changements qualitatifs, et ils tombent tous sur le syst√®me, l'√©crasant et le transformant en poussi√®re. </p><br><p>  Et le point ici est de changer le domaine de gestion des erreurs et la disponibilit√© de la m√©moire partag√©e.  Si auparavant, il y avait toujours un morceau de m√©moire qui √©tait disponible dans chaque thread, et si vous le souhaitez, dans chaque processus, maintenant il n'y a pas un tel morceau et ne peut pas l'√™tre.  Chacun pour soi, ind√©pendant et fier. </p><br><p>  Si plus t√¥t, une d√©faillance du flux a enterr√© le flux et le processus en m√™me temps, et c'√©tait bien, car  n'a pas conduit √† des √©checs partiels, maintenant les √©checs partiels deviennent la norme et √† chaque fois avant chaque action, vous pensez: "Et si?".  C'est tellement ennuyeux et distrayant d'√©crire, en fait, les actions elles-m√™mes que le code √† cause de cela cro√Æt non pas parfois, mais par ordre de grandeur.  Tout se transforme en nouilles de gestion des erreurs, de changement d'√©tat et de pr√©servation du contexte, de restauration en raison de d√©faillances d'un composant, d'un autre composant, de l'inaccessibilit√© de certains services, etc.  etc.  Apr√®s avoir rat√© la surveillance de tout cela, vous pouvez passer une bonne nuit de sommeil sur votre ordinateur portable pr√©f√©r√©. </p><br><p>  Que ce soit une question de multithreading: j'ai pris le mutex et suis all√© d√©chiqueter la m√©moire partag√©e pour le plaisir.  La beaut√©! </p><br><p>  En cons√©quence, nous avons que les mod√®les cl√©s et test√©s au combat ont √©t√© retir√©s, et les nouveaux, pour les remplacer, pour une raison quelconque, n'ont pas √©t√© livr√©s, et il s'est av√©r√© comme dans une blague sur la fa√ßon dont la f√©e a agit√© sa baguette et la tour est tomb√©e du r√©servoir. </p><br><p>  Cependant, les syst√®mes distribu√©s ont un ensemble de pratiques √©prouv√©es et d'algorithmes √©prouv√©s.  Cependant, chaque programmeur qui se respecte consid√®re qu'il est de son devoir de rejeter des r√©alisations bien connues et de faire du v√©lo son propre bien, malgr√© l'exp√©rience acquise, un nombre consid√©rable d'articles scientifiques et de recherches universitaires.  Apr√®s tout, si vous pouvez utiliser des algorithmes et du multithreading, comment pouvez-vous vous retrouver dans un p√©trin avec la distribution?  Il ne peut y avoir deux opinions ici! </p><br><p>  En cons√©quence, les syst√®mes sont bogu√©s, les donn√©es divergent et se d√©t√©riorent, les services deviennent p√©riodiquement indisponibles pour l'√©criture, ou m√™me compl√®tement indisponibles, car soudainement un n≈ìud s'est √©cras√©, le r√©seau est tomb√© en panne, Java a consomm√© beaucoup de m√©moire et GC est terne, et il existe de nombreuses autres raisons qui pourraient retarder sa fin aux autorit√©s. </p><br><p>  Cependant, m√™me avec des approches connues et √©prouv√©es, la vie ne devient pas plus facile, car  les primitives fiables distribu√©es sont lourdes avec des exigences s√©rieuses pour la logique du code ex√©cutable.  Par cons√©quent, les coins sont coup√©s dans la mesure du possible.  Et, comme cela arrive souvent, avec des raccourcis h√¢tifs, la simplicit√© et l'√©volutivit√© relative apparaissent, mais la fiabilit√©, la disponibilit√© et la coh√©rence d'un syst√®me distribu√© disparaissent. </p><br><p>  Id√©alement, je ne voudrais pas du tout penser que notre syst√®me est distribu√© et multithread, c'est-√†-dire  travailler au 1er √©tage (algorithmes), sans penser aux 2e (multithreading + asynchronie) et 3e (distribution).  Cette fa√ßon d'isoler les abstractions augmenterait consid√©rablement la simplicit√©, la fiabilit√© et la vitesse d'√©criture du code.  Malheureusement, pour le moment, cela n'est possible que dans les r√™ves. </p><br><p>  Cependant, les abstractions individuelles permettent un isolement relatif.  L'un des exemples typiques est l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">utilisation de coroutines</a> , o√π au lieu de code asynchrone nous obtenons synchrone, c'est-√†-dire  on passe de la 2√®me √©tape √† la 1√®re √©tape, ce qui nous permet de simplifier consid√©rablement la r√©daction et la maintenance du code. </p><br><p>  L'article r√©v√®le successivement l'utilisation d'algorithmes sans verrouillage pour construire un syst√®me temps r√©el √©volutif distribu√©, coh√©rent et fiable, c'est-√†-dire  comment les r√©alisations sans verrouillage de la 2e √©tape aident √† la mise en ≈ìuvre de la 3e, r√©duisant la t√¢che aux algorithmes √† un seul thread de la premi√®re √©tape. </p><br><h2 id="postanovka-zadachi">  √ânonc√© du probl√®me </h2><br><p>  Cette t√¢che illustre seulement quelques approches importantes et est pr√©sent√©e comme un exemple pour introduire des probl√®mes dans le contexte.  Il peut √™tre facilement g√©n√©ralis√© √† des cas plus complexes, ce qui sera fait √† l'avenir. </p><br><p>  <strong>T√¢che: traitement des donn√©es en streaming en temps r√©el</strong> . </p><br><p>  Il existe deux flux de nombres.  Le gestionnaire lit les donn√©es de ces flux d'entr√©e et s√©lectionne les derniers nombres pour une certaine p√©riode.  Ces nombres sont moyenn√©s sur cet intervalle de temps, c'est-√†-dire  dans une fen√™tre de donn√©es glissante pour un temps donn√©.  La valeur moyenne obtenue doit √™tre √©crite dans la file d'attente de sortie pour un traitement ult√©rieur.  De plus, si le nombre de nombres dans la fen√™tre d√©passe un certain seuil, alors augmentez de un le compteur dans la base de donn√©es transactionnelle externe. </p><br><p><img src="https://habrastorage.org/webt/nf/9d/jh/nf9djhbhsjmrumrg5eckb1h6u_c.png" alt="Initiale"></p><br><p>  Nous notons certaines caract√©ristiques de ce probl√®me. </p><br><ol><li>  <em>Non-d√©terminisme</em> .  Il existe deux sources de comportement non d√©terministe: il s'agit d'une lecture de deux flux, ainsi que d'une fen√™tre temporelle.  Il est clair que la lecture peut √™tre effectu√©e de diff√©rentes mani√®res, et le r√©sultat final d√©pendra de la s√©quence dans laquelle les donn√©es seront extraites.  La fen√™tre temporelle modifie √©galement le r√©sultat du d√©but √†  la quantit√© de donn√©es dans la fen√™tre d√©pendra de la vitesse de travail. </li><li>  <em>L'√©tat du gestionnaire</em> .  Il existe un √©tat du gestionnaire sous la forme d'un ensemble de nombres dans la fen√™tre, dont d√©pendent les r√©sultats actuels et ult√©rieurs du travail.  C'est-√†-dire  nous avons un gestionnaire avec √©tat. </li><li>  <em>Interaction avec le stockage externe</em> .  Il est n√©cessaire de mettre √† jour la valeur du compteur dans la base de donn√©es externe.  Le point crucial est que le type de stockage externe est diff√©rent du stockage de l'√©tat du processeur et des threads. </li></ol><br><p>  Tout cela, comme nous le montrerons ci-dessous, affecte s√©rieusement les outils utilis√©s et les m√©thodes de mise en ≈ìuvre possibles. </p><br><p>  Il reste √† ajouter une petite touche √† la t√¢che, ce qui transf√®re imm√©diatement la t√¢che d'un domaine au-del√† de la complexit√© √† un impossible: une garantie <em>concomitante en</em> une <em>seule fois</em> est n√©cessaire. </p><br><h2 id="exactly-once">  Exactement une fois </h2><br><p>  <em>Exactement une fois est</em> souvent interpr√©t√© de mani√®re trop large, ce qui √©mascule le terme lui-m√™me et cesse de r√©pondre aux exigences initiales de la t√¢che.  Si nous parlons d'un syst√®me qui s'ex√©cute localement sur un ordinateur - alors tout est simple: prenez plus, jetez plus loin.  Mais dans ce cas, nous parlons d'un syst√®me distribu√© dans lequel: </p><br><ol><li>  Le nombre de gestionnaires peut √™tre important: chaque gestionnaire travaille avec sa propre donn√©e.  De plus, les r√©sultats peuvent √™tre ajout√©s √† divers endroits, par exemple, une base de donn√©es externe, √©ventuellement m√™me m√©lang√©e. </li><li>  Chaque gestionnaire peut interrompre soudainement le traitement.  Un syst√®me tol√©rant aux pannes implique un fonctionnement continu m√™me en cas de d√©faillance de certaines parties du syst√®me. </li></ol><br><p>  Ainsi, nous devons √™tre pr√©par√©s au fait que le gestionnaire peut tomber, et un autre gestionnaire devrait reprendre le travail d√©j√† effectu√© et poursuivre le traitement. </p><br><p>  La question se pose imm√©diatement: que signifiera <em>exactement une fois</em> si le gestionnaire non d√©terministe fonctionne?  Apr√®s tout, √† chaque red√©marrage, nous recevons, de mani√®re g√©n√©rale, diff√©rents √©tats r√©sultants.  La r√©ponse ici est simple: avec <em>exactement une fois,</em> il y a une telle ex√©cution du syst√®me dans laquelle chaque valeur d'entr√©e est trait√©e exactement une fois, donnant le r√©sultat de sortie correspondant.  De plus, cette ex√©cution n'a pas besoin d'√™tre physiquement sur le m√™me n≈ìud.  Mais le r√©sultat devrait √™tre comme si tout √©tait trait√© sur un seul n≈ìud logique <em>sans se bloquer</em> . </p><br><h2 id="concurrent-exactly-once">  Exactement simultan√© </h2><br><p>  Pour aggraver les exigences, nous introduisons un nouveau concept: <em>simultan√© une seule fois</em> .  La diff√©rence fondamentale avec une <em>seule fois exactement</em> est l'absence de pauses pendant le traitement, comme si tout √©tait trait√© sur le m√™me noeud <strong>sans pertes</strong> et <strong>sans pauses</strong> .  Dans notre t√¢che, nous aurons besoin d'exactement <em>simultan√© exactement une fois</em> , pour la simplicit√© de la pr√©sentation, afin de ne pas consid√©rer une comparaison avec les syst√®mes existants qui ne sont pas disponibles aujourd'hui. </p><br><p>  Les cons√©quences d'une telle exigence seront discut√©es ci-dessous. </p><br><h2 id="tranzakcionnost">  Transactionnel </h2><br><p>  Afin que le lecteur soit encore plus profond√©ment impr√©gn√© de la complexit√© qui est apparue, examinons divers mauvais sc√©narios qui doivent √™tre pris en compte lors du d√©veloppement d'un tel syst√®me.  Nous essaierons √©galement d'utiliser une approche g√©n√©rale qui nous permettra de r√©soudre le probl√®me ci-dessus en tenant compte de nos exigences. </p><br><p>  La premi√®re chose qui me vient √† l'esprit est la n√©cessit√© d'enregistrer l'√©tat du gestionnaire et les flux d'entr√©e et de sortie.  L'√©tat des flux de sortie est d√©crit par une simple file d'attente de nombres, et l'√©tat des flux d'entr√©e par leur position.  En substance, un flux est une file d'attente infinie et une position dans la file d'attente d√©finit uniquement un emplacement. </p><br><p><img src="https://habrastorage.org/webt/iu/h0/pf/iuh0pfzcezje80kdbsv3idyeu9a.jpeg" alt="Id√©e"></p><br><p>  L'impl√©mentation na√Øve suivante d'un gestionnaire survient √† l'aide d'une sorte d'entrep√¥t de donn√©es.  √Ä ce stade, les propri√©t√©s sp√©cifiques du r√©f√©rentiel ne seront pas importantes pour nous.  Nous utiliserons le langage Pseco pour illustrer l'id√©e (Pseco: = pseudo code): </p><br><pre><code class="hljs pgsql">handle(input_queues, output_queues, state): #    input_indexes = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.get_input_indexes() #      <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #         items, new_input_indexes = input_queues.get_from(input_indexes) #    state.queue.push(items) #     duration state.queue.trim_time_window(duration) avg = state.queue.avg() need_update_counter = state.queue.size() &gt; size_boundary # (A)      output_queues[<span class="hljs-number"><span class="hljs-number">0</span></span>].push(avg) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> need_update_counter: # (B)      db.increment_counter() # (C)     <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.save_state(state) # (D)    <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.save_queue_indexes(new_input_indexes) # (E)    input_indexes = new_input_indexes</code> </pre> <br><p>  Voici un algorithme simple √† un seul thread qui lit les donn√©es des flux d'entr√©e et √©crit les valeurs souhait√©es selon la t√¢che d√©crite ci-dessus. </p><br><p>  Voyons ce qui se passe en cas de chute d'un n≈ìud √† des moments arbitraires, ainsi qu'apr√®s la reprise du travail.  Il est clair qu'en cas de chute aux points <code>(A)</code> et <code>(E)</code> tout ira bien: soit les donn√©es n'ont pas encore √©t√© enregistr√©es n'importe o√π et nous restaurez simplement l'√©tat et continuons sur un autre n≈ìud, soit toutes les donn√©es n√©cessaires ont d√©j√† √©t√© enregistr√©es et continuons simplement l'√©tape suivante. </p><br><p>  Cependant, en cas de chute √† tous les autres points, des troubles inattendus nous attendent.  Si une baisse se produit au point <code>(B)</code> , alors lorsque le gestionnaire est red√©marr√©, nous restaurons l'√©tat et r√©enregistrons la valeur moyenne dans approximativement la m√™me plage de nombres.  Dans le cas d'une chute au point <code>(C)</code> en plus du doublon moyen, un doublon se produira dans l'incr√©ment de la valeur.  Et en cas de baisse de <code>(D)</code> nous obtiendrons un √©tat incoh√©rent du gestionnaire: l'√©tat correspond √† un nouveau moment dans le temps, et nous lirons les valeurs des flux d'entr√©e anciens. </p><br><p><img src="https://habrastorage.org/webt/fn/8z/6f/fn8z6f9t3y-fe2hzlepgnie7qps.jpeg" alt="Surprises"></p><br><p>  Dans le m√™me temps, rien ne changera fondamentalement lors de la r√©organisation des op√©rations d'enregistrement: les incoh√©rences et les doublons le resteront.  Ainsi, nous arrivons √† la conclusion que toutes les actions visant √† modifier l'√©tat du gestionnaire dans le r√©f√©rentiel, la file d'attente de sortie et la base de donn√©es doivent √™tre effectu√©es de mani√®re transactionnelle, c'est-√†-dire  tout est atomique en m√™me temps. </p><br><p>  En cons√©quence, il est n√©cessaire de d√©velopper un m√©canisme de sorte que diff√©rents stockages puissent changer transactionnellement leur √©tat, et non √† l'int√©rieur de chacun ind√©pendamment, mais transactionnellement entre tous les stockages simultan√©ment.  Bien s√ªr, vous pouvez placer notre stockage dans une base de donn√©es externe, cependant, la t√¢che supposait que le moteur de base de donn√©es et le moteur pour le cadre de traitement des donn√©es en streaming sont s√©par√©s et fonctionnent ind√©pendamment l'un de l'autre.  Ici, je veux consid√©rer le cas le plus difficile, car  les cas simples ne sont pas int√©ressants √† consid√©rer. </p><br><h2 id="konkurentnaya-otzyvchivost">  R√©activit√© comp√©titive </h2><br><p>  Consid√©rez l'ex√©cution concurrentielle exactement une fois de plus.  Dans le cas d'un syst√®me tol√©rant aux pannes, nous avons besoin de poursuivre le travail √† partir d'un certain point.  Il est clair que ce point se situera dans le pass√©, car  Pour maintenir les performances, il est impossible de stocker tous les moments de changements d'√©tat dans le pr√©sent et dans le futur: soit le dernier r√©sultat des op√©rations, soit un groupe de valeurs pour augmenter le d√©bit est enregistr√©.  Ce comportement nous am√®ne imm√©diatement au fait qu'apr√®s restauration de l'√©tat du processeur, il y aura un certain retard dans les r√©sultats, il augmentera avec l'augmentation de la taille du groupe de valeurs et de la taille de l'√©tat. </p><br><p>  En plus de ce retard, il existe √©galement des retards dans le syst√®me associ√©s au chargement de l'√©tat sur un autre n≈ìud.  En plus de cela, la d√©tection d'un n≈ìud probl√©matique prend √©galement un certain temps, et souvent beaucoup.  Cela est d√ª, tout d'abord, au fait que si nous fixons un temps de d√©tection court, des fausses alarmes fr√©quentes sont possibles, ce qui entra√Ænera toutes sortes d'effets sp√©ciaux d√©sagr√©ables. </p><br><p>  De plus, avec l'augmentation du nombre de processeurs parall√®les, il s'av√®re soudainement que tous ne fonctionnent pas aussi bien m√™me en l'absence de pannes.  Parfois, des √©moussements se produisent, ce qui entra√Æne √©galement des retards de traitement.  La raison de ces contours peut √™tre vari√©e: </p><br><ol><li>  <em>Logiciel</em> : pauses du GC, fragmentation de la m√©moire, pauses d'allocateur, interruption du noyau et planification des t√¢ches, probl√®mes avec les pilotes de p√©riph√©riques entra√Ænant des ralentissements. </li><li>  <em>Mat√©riel</em> : charge √©lev√©e du disque ou du r√©seau, limitation du processeur en raison de probl√®mes de refroidissement, surcharge, etc., ralentissement du disque en raison de probl√®mes techniques. </li></ol><br><p>  Et ce n'est en aucun cas une liste exhaustive des probl√®mes qui peuvent ralentir les gestionnaires. </p><br><p>  En cons√©quence, le ralentissement est une donn√©e avec laquelle il faut vivre.  Parfois, ce n'est pas un probl√®me grave, et parfois il est extr√™mement important de maintenir une vitesse de traitement √©lev√©e malgr√© les √©checs ou les ralentissements. </p><br><p>  Imm√©diatement, l'id√©e de duplication de syst√®mes se pose: ex√©cutons pour un m√™me flux de donn√©es non pas un mais deux processeurs √† la fois, voire trois.  Le probl√®me ici est que dans ce cas, des doublons et un comportement syst√®me incoh√©rent peuvent facilement se produire.  En r√®gle g√©n√©rale, les cadres ne sont pas con√ßus pour ce comportement et sugg√®rent que le nombre de gestionnaires √† un moment donn√© ne d√©passe pas un.  Les syst√®mes qui permettent la duplication d'ex√©cution d√©crite sont appel√©s <em>simultan√©s une seule fois</em> . </p><br><p>  Cette architecture vous permet de r√©soudre plusieurs probl√®mes √† la fois: </p><br><ol><li>  Comportement √† s√©curit√© int√©gr√©e: si l'un des n≈ìuds tombe, l'autre continue simplement de fonctionner comme si de rien n'√©tait.  Aucune coordination suppl√©mentaire n'est n√©cessaire, car  le second gestionnaire est ex√©cut√© quel que soit l'√©tat du premier. </li><li>  Suppression des contours: celui qui a fourni le r√©sultat en premier est bon pour lui.  L'autre n'aura qu'√† prendre un nouvel √©tat et continuer √† partir de ce moment. </li></ol><br><p>  Cette approche, en particulier, vous permet d'effectuer un calcul long et difficile pour un temps plus pr√©visible, car  la probabilit√© que les deux soient stupides et tombent beaucoup moins. </p><br><h3 id="veroyatnostnaya-ocenka">  √âvaluation des probabilit√©s </h3><br><p>  Essayons d'√©valuer les avantages de la duplication des performances.  Supposons que quelque chose se passe en moyenne tous les jours avec le gestionnaire: soit le GC est √©mouss√©, soit le n≈ìud est couch√©, soit les conteneurs sont devenus canc√©reux.  Supposons √©galement que nous pr√©parions des paquets de donn√©es en 10 secondes. </p><br><p>  La probabilit√© que quelque chose se produise lors de la cr√©ation du pack est alors de <code>10 / (24 ¬∑ 3600) ‚âÉ 1e-4</code> . </p><br><p>  Si vous ex√©cutez deux gestionnaires en parall√®le, la probabilit√© que les deux volent soit <code>‚âÉ 1e-8</code> .  Cet √©v√©nement arrivera donc dans 23 ans!  Oui, les syst√®mes ne vivent pas autant, ce qui signifie que cela n'arrivera jamais! </p><br><p>  De plus, si le temps de pr√©paration de l'emballage sera encore plus court et / ou que les √©moussements se produiront encore moins souvent, ce chiffre ne fera qu'augmenter. </p><br><p>  Ainsi, nous concluons que l'approche envisag√©e augmente consid√©rablement la fiabilit√© de l'ensemble de notre syst√®me.  Il ne reste plus qu'√† r√©soudre une petite question comme celle-ci: o√π lire pour savoir comment cr√©er un syst√®me <em>simultan√© en</em> une <em>seule fois</em> .  Et la r√©ponse est simple: vous devez lire ici. </p><br><h2 id="polutranzakcii">  Demi transaction </h2><br><p>  Pour une discussion plus approfondie, nous avons besoin du concept d'une <em>demi-transaction</em> .  La fa√ßon la plus simple de l'expliquer est avec un exemple. </p><br><p>  Envisagez de transf√©rer des fonds d'un compte bancaire √† un autre.  L'approche traditionnelle utilisant des transactions en langage Pseco peut √™tre d√©crite comme suit: </p><br><pre> <code class="hljs pgsql">transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): tx = db.begin_transaction() amount_from = tx.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error.insufficient_funds tx.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount_from - amount) tx.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, tx.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) + amount) tx.<span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok</code> </pre> <br><p>  Cependant, que se passe-t-il si ces transactions ne sont pas disponibles pour nous?  √Ä l'aide de verrous, cela peut √™tre fait comme suit: </p><br><pre> <code class="hljs pgsql">transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): #         lock_from = db.<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) lock_to = db.<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) amount_from = db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error.insufficient_funds db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount_from - amount) db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) + amount) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok</code> </pre> <br><p>  Cette approche peut conduire √† des blocages, comme  les verrous peuvent √™tre pris en diff√©rentes s√©quences en parall√®le.  Pour corriger ce comportement, il suffit d'introduire une fonction qui prend simultan√©ment plusieurs verrous dans une s√©quence d√©terministe (par exemple, trie par cl√©s), ce qui √©limine compl√®tement les √©ventuels blocages. </p><br><p>  Cependant, la mise en ≈ìuvre peut √™tre quelque peu simplifi√©e: </p><br><pre> <code class="hljs vbscript">transfer(from, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): lock_from = db.lock(from) amount_from = db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(from) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: return <span class="hljs-keyword"><span class="hljs-keyword">error</span></span>.insufficient_funds db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(from, amount_from - amount) lock_from.release() #   , # .. db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>...)     lock_to = db.lock(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) + amount) return ok</code> </pre> <br><p>  Cette approche rend √©galement l'√©tat final coh√©rent, en pr√©servant les invariants par le type de pr√©vention des d√©penses excessives de fonds.  La principale diff√©rence par rapport √† l'approche pr√©c√©dente est que dans une telle mise en ≈ìuvre, nous avons un certain laps de temps pendant lequel les comptes sont dans un √©tat incoh√©rent.  A savoir, une telle op√©ration implique que l'√©tat total des fonds dans les comptes ne change pas.  Dans ce cas, il y a un intervalle de temps entre <code>lock_from.release()</code> et <code>db.lock(to)</code> , pendant lequel la base de donn√©es peut donner une valeur incoh√©rente: le montant total peut diff√©rer de la bonne vers le bas. </p><br><p>  En fait, nous avons divis√© une transaction pour transf√©rer de l'argent en deux demi-transactions: </p><br><ol><li>  La premi√®re demi-transaction fait un ch√®que et d√©duit le montant n√©cessaire du compte. </li><li>  La deuxi√®me demi-transaction √©crit le montant retir√© sur un autre compte. </li></ol><br><p>  Il est clair que la division d'une transaction en transactions plus petites, d'une mani√®re g√©n√©rale, viole le comportement transactionnel.  Et l'exemple ci-dessus ne fait pas exception.  Cependant, si toutes les demi-transactions de la cha√Æne sont enti√®rement remplies, le r√©sultat sera coh√©rent avec tous les invariants pr√©serv√©s.  C'est pr√©cis√©ment ce qui est une propri√©t√© importante d'une cha√Æne de demi-transaction. </p><br><p>  Perdant temporairement une certaine coh√©rence, nous acqu√©rons n√©anmoins une autre caract√©ristique utile: l'ind√©pendance des op√©rations et, par cons√©quent, une meilleure √©volutivit√©.  L'ind√©pendance se manifeste dans le fait qu'une demi-transaction √† chaque fois fonctionne avec une seule ligne, lisant, v√©rifiant et modifiant ses donn√©es, sans communiquer avec d'autres donn√©es.  Ainsi, vous pouvez m√©langer une base de donn√©es dont les transactions fonctionnent avec un seul fragment.  De plus, cette approche peut √™tre utilis√©e dans le cas de r√©f√©rentiels h√©t√©rog√®nes, c'est-√†-dire  les demi-transactions peuvent commencer sur un type de stockage et se terminer sur un autre.  Ce sont ces propri√©t√©s utiles qui seront utilis√©es √† l'avenir. </p><br><p>  Une question l√©gitime se pose: comment mettre en ≈ìuvre la demi-transe dans les syst√®mes distribu√©s et non le r√¢teau?  Pour r√©soudre ce probl√®me, vous devez consid√©rer l'approche sans verrouillage. </p><br><h2 id="lock-free">  Sans verrou </h2><br><p>  Comme vous le savez, les approches sans verrouillage am√©liorent parfois les performances des syst√®mes multithreads, en particulier dans le cas d'un acc√®s concurrentiel √† la ressource.  Cependant, il n'est absolument pas √©vident qu'une telle approche puisse √™tre utilis√©e dans des syst√®mes distribu√©s.  Examinons en profondeur ce qu'est le verrouillage sans cl√© et pourquoi cette propri√©t√© sera utile pour r√©soudre notre probl√®me. </p><br><p>  Certains d√©veloppeurs ne comprennent pas toujours ce qu'est le sans-verrou.  Le regard born√© sugg√®re que cela est li√© aux instructions du processeur atomique.  Il est important de comprendre ici que le verrouillage signifie l'utilisation d‚Äôatomes, l‚Äôinverse n‚Äôest pas vrai, c‚Äôest-√†-dire  tous les ¬´atomiques¬ª n'offrent pas un comportement sans verrouillage. </p><br><p>  Une propri√©t√© importante de l'algorithme sans verrouillage est qu'au moins un thread progresse dans le syst√®me.  Mais pour une raison quelconque, beaucoup attribuent cette propri√©t√© comme une d√©finition (c'est une d√©finition si franche que l'on peut trouver, par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur Wikipedia</a> ).  Ici, il est n√©cessaire d'ajouter une nuance importante: des progr√®s sont r√©alis√©s m√™me dans le cas d'√©moussages d'un ou plusieurs fils.  Il s'agit d'un point tr√®s critique qui est souvent ignor√© et qui a de s√©rieuses implications pour un syst√®me distribu√©. </p><br><p>  Pourquoi l'absence d'une condition de progression d'au moins un thread annule-t-elle le concept d'un algorithme sans verrouillage?  Le fait est que dans ce cas, le spinlock habituel sera √©galement sans verrouillage.  En effet, celui qui a pris le verrou fera des progr√®s.  Existe-t-il un thread avec progress =&gt; lock-free? </p><br><p>  De toute √©vidence, sans verrou signifie sans verrou, tandis que le verrou tournant par son nom indique qu'il s'agit d'un vrai verrou.  C'est pourquoi il est important d'ajouter une condition au progr√®s, m√™me dans le cas d'√©mouss√©s.  Apr√®s tout, ces retards peuvent durer ind√©finiment, car  la d√©finition ne dit rien sur la ligne du temps sup√©rieure.  Et si c'est le cas, ces retards seront en quelque sorte √©quivalents √† la coupure des flux.  Dans ce cas, les algorithmes sans verrouillage produiront des progr√®s dans ce cas. </p><br><p>  Mais qui a dit que les approches sans verrouillage s'appliquent exclusivement aux syst√®mes multithreads?  En rempla√ßant les threads dans le m√™me processus sur le m√™me n≈ìud par des processus sur diff√©rents n≈ìuds et la m√©moire partag√©e des threads avec un stockage distribu√© partag√©, nous obtenons un algorithme distribu√© sans verrouillage. </p><br><p>  Une chute de n≈ìud dans un tel syst√®me √©quivaut √† un retard dans l'ex√©cution d'un thread pendant un certain temps, car  il est temps de restaurer le travail.  Dans le m√™me temps, l'approche sans verrouillage permet aux autres participants du syst√®me distribu√© de continuer √† travailler.  De plus, des algorithmes sp√©ciaux sans verrouillage peuvent √™tre ex√©cut√©s en parall√®le, d√©tectant un changement concurrentiel et supprimant les doublons. </p><br><p>  <em>L'</em> approche <em>Exactly-once</em> implique la pr√©sence d'un stockage distribu√© coh√©rent.  Ces stockages repr√©sentent en r√®gle g√©n√©rale une √©norme table de valeurs-cl√©s persistante.  Op√©rations possibles: <code>set</code> , <code>get</code> , <code>del</code> .  Cependant, une op√©ration plus compliqu√©e est requise pour l'approche sans verrouillage: CAS ou compare-and-swap.  Examinons plus en d√©tail cette op√©ration, les possibilit√©s de son utilisation, ainsi que les r√©sultats qu'elle donne. </p><br><h3 id="cas">  Cas </h3><br><p>  CAS ou compare-and-swap est la primitive de synchronisation principale et importante pour les algorithmes sans verrouillage et sans attente.  Son essence peut √™tre illustr√©e par le Pseco suivant: </p><br><pre> <code class="hljs kotlin">CAS(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected, new): # ,   atomic,   atomic: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() != expected: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(new) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p>  Parfois, pour l'optimisation, ils renvoient non pas <code>true</code> ou <code>false</code> , mais la valeur pr√©c√©dente, car  tr√®s souvent, ces op√©rations sont effectu√©es en boucle, et pour obtenir la valeur <code>expected</code> , vous devez d'abord la lire: </p><br><pre> <code class="hljs vala">CAS_optimized(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>): # ,   atomic,   atomic: current = <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> current == expected: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current #  CAS   CAS_optimized CAS(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.CAS_optimized(expected, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>) == expected</code> </pre> <br><p>  Cette approche peut sauver une lecture.  Dans le cadre de notre examen, nous utiliserons une forme simple de <code>CAS</code> , car  si vous le souhaitez, cette optimisation peut √™tre effectu√©e ind√©pendamment. </p><br><p>  Dans le cas de syst√®mes distribu√©s, chaque modification est versionn√©e.  C'est-√†-dire  nous lisons d'abord la valeur du magasin, obtenant la version actuelle des donn√©es.  Et puis nous essayons d'√©crire, en attendant que la version des donn√©es n'ait pas chang√©.  Dans ce cas, la version est incr√©ment√©e √† chaque mise √† jour des donn√©es: </p><br><pre> <code class="hljs cs">CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected_version, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>): atomic: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.get_version() != expected_version: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>, expected_version + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p>  Cette approche vous permet de contr√¥ler plus pr√©cis√©ment la mise √† jour des valeurs, en √©vitant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le probl√®me ABA</a> .  En particulier, la gestion des versions est prise en charge par Etcd et Zookeeper. </p><br><p>  Notez la propri√©t√© importante que donne l'utilisation des op√©rations <code>CAS_versioned</code> .  Le fait est qu'une telle op√©ration peut √™tre r√©p√©t√©e sans pr√©judice de la logique sup√©rieure.  Dans la programmation multi-thread, cette propri√©t√© n'a pas de valeur sp√©ciale, car  l√†, si l'op√©ration a √©chou√©, alors nous savons avec certitude qu'elle ne s'appliquait pas.  Dans le cas de syst√®mes distribu√©s, cet invariant est viol√©, car  la demande peut atteindre le destinataire, mais la r√©ponse r√©ussie n'est plus l√†.  Par cons√©quent, il est important de pouvoir renvoyer des requ√™tes sans craindre de casser les invariants de la logique de haut niveau. </p><br><p>  C'est cette propri√©t√© que <code>CAS_versioned</code> op√©ration <code>CAS_versioned</code> .  En fait, cette op√©ration peut √™tre r√©p√©t√©e √† l'infini jusqu'√† ce que la r√©ponse r√©elle du destinataire soit renvoy√©e.  Ce qui, √† son tour, g√©n√®re toute une classe d'erreurs li√©es √† l'interaction r√©seau. </p><br><h3 id="primer">  Exemple </h3><br><p>  Voyons comment, bas√© sur <code>CAS_versioned</code> et demi-transactions, pour transf√©rer d'un compte √† un autre, qui appartiennent, par exemple, √† diff√©rentes copies d'Etcd.  Ici, je suppose que la fonction <code>CAS_versioned</code> d√©j√† impl√©ment√©e en cons√©quence sur la base de l'API fournie. </p><br><pre> <code class="hljs pgsql">withdraw(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount): # CAS- <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #     version_from, amount_from = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error.insufficient_funds <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.CAS_versioned(version_from, amount_from - amount): break <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok deposit(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): # CAS- <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: version_to, amount_to = <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>.CAS_versioned(version_to, amount_to + amount): break <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): #   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> withdraw(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ok: #     , #    deposit(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount)</code> </pre> <br><p>  Ici, nous avons divis√© notre op√©ration en demi-transactions, et nous effectuons chaque demi-transaction via l'op√©ration <code>CAS_versioned</code> .  Cette approche vous permet de travailler ind√©pendamment avec chaque compte, ce qui permet d'utiliser un stockage h√©t√©rog√®ne qui n'est pas connect√© les uns aux autres.  Le seul probl√®me qui nous attend ici est la perte d'argent en cas de chute du processus en cours dans l'intervalle entre les demi-transactions. </p><br><h2 id="ochered">  File d'attente </h2><br><p>  Pour continuer, vous devez impl√©menter une file d'attente d'√©v√©nements.  L'id√©e est que pour que les gestionnaires communiquent entre eux, vous devez disposer d'une file d'attente de messages ordonn√©e dans laquelle les donn√©es ne sont ni perdues ni dupliqu√©es.  Par cons√©quent, toute interaction dans la cha√Æne de gestionnaires sera bas√©e sur cette primitive.  C'est √©galement un outil utile pour analyser et auditer les flux de donn√©es entrants et sortants.  En plus de cela, des mutations de l'√©tat des gestionnaires peuvent √©galement √™tre effectu√©es via la file d'attente. </p><br><p>  La file d'attente se composera d'une paire d'op√©rations: </p><br><ol><li>  Ajoutez un message √† la fin de la file d'attente. </li><li>  R√©ception d'un message de la file d'attente √† l'index sp√©cifi√©. </li></ol><br><p>  Dans ce contexte, je n'envisage pas de supprimer des messages de la file d'attente pour plusieurs raisons: </p><br><ol><li>  Plusieurs processeurs peuvent lire √† partir de la m√™me file d'attente.  La suppression de la synchronisation sera une t√¢che non triviale, mais pas impossible. </li><li>  Il est utile de maintenir une file d'attente pendant un intervalle relativement long (jour ou semaine) pour le d√©bogage et l'audit.  L'utilit√© de cette propri√©t√© est difficile √† surestimer. </li><li>  Vous pouvez supprimer les anciens √©l√©ments selon le calendrier ou en d√©finissant TTL sur les √©l√©ments de la file d'attente.  Il est important de s'assurer que les processeurs parviennent √† traiter les donn√©es avant que le balai arrive et nettoie tout.  Si le temps de traitement est de l'ordre de quelques secondes et le TTL de l'ordre de jours, rien de tout cela ne devrait se produire. </li></ol><br><p>  Pour stocker les √©l√©ments et mettre en ≈ìuvre efficacement l'ajout, nous avons besoin de: </p><br><ol><li>  La valeur avec l'index actuel.  Cet index pointe vers la fin de la file d'attente pour l'ajout d'√©l√©ments. </li><li>  ,    . </li></ol><br><h3 id="kak-by-lock-free-ochered">   lock-free  </h3><br><p>          :        .        : </p><br><ol><li>    CAS     . </li><li>       . </li></ol><br><p>    ,    ,     . </p><br><ol><li> <strong>    lock-free</strong> .  ,      ,          . Lock-free? !   ,    2 :   .         lock-free,     ‚Äî !    ,  ,        ,   .              .         , ..            ,     . </li><li> <strong>    </strong> .         ,               .    . </li></ol><br><p>  ,    lock-free         . </p><br><h3 id="lock-free-realizaciya-dobavleniya"> Lock-free   </h3><br><p> ,  ,     :   , ..      ,    : </p><br><pre> <code class="hljs pgsql">push(queue, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>): #      <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = queue.get_current_index() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #  ,    #    var = queue.at(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) #  = <span class="hljs-number"><span class="hljs-number">0</span></span>   , ..   # ,         <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> var.CAS_versioned(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>): #   ,    queue.update_index(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) break #   , .   <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = max(queue.get_current_index(), <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) update_index(queue, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #     cur_index, version = queue.get_current_index_versioned() #      , #  , .   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cur_index &gt;= <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>: # -     , #        break <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> queue.current_index_var().CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): #      ,   break # -  . # ,      ,  </code> </pre> <br><p>      .   ,            (     ‚Äî ,  ,     ).       lock-free   .    ? </p><br><p>   ,   <code>push</code>     ,      ! ,             ,      . </p><br><p>        .       :         .   ,      -   ,  -               .  ,      , ..      .          .        ?       , ..     ,    ,        . </p><br><p>  ,       ,          . ..    .        ,    ,     .          ,       . </p><br><p>  ,       .               ,   .    ,   ,     .       ,    . </p><br><h2 id="vzaimodeystvie-ocheredey">   </h2><br><p>  ,  ,   ,      . </p><br><p> <em></em> .       . </p><br><p>    ,      : </p><br><ol><li>  , ..  stateless. </li><li>  ,     ‚Äî . </li></ol><br><p> ,    ,        <em>concurrent exactly-once</em> . </p><br><p>        : </p><br><pre> <code class="hljs pgsql">handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output): <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) output.push(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>   .        : </p><br><pre> <code class="hljs pgsql">handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output, state): #   <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = state.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) output.push(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span> #   state.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>)</code> </pre> <br><p>     <em>exactly-once</em> .   ,           ,    ,    . </p><br><p>    <em>exactly-once</em> ,     ,    . ..,  ,       ,       ,   ,    ‚Äî      : </p><br><pre> <code class="hljs pgsql">#       get_next_index(queue): <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = queue.get_index() #     <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> queue.has(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): #    queue.push <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = max(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>, queue.get_index()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> #      . #  <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>    push_at(queue, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): var = queue.at(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> var.CAS_versioned(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>): #   queue.update_index(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output, state): #   #    {PREPARING, <span class="hljs-number"><span class="hljs-number">0</span></span>} fsm_state = state.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: switch fsm_state: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {PREPARING, input_index}: #   :   , #        output_index = output.get_next_index() fsm_state = {WRITING, input_index, output_index} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {WRITING, input_index, output_index}: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(input_index) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output.push_at(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, output_index): #  ,     input_index += <span class="hljs-number"><span class="hljs-number">1</span></span> #    ,  push_at  <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, #        fsm_state = {PREPARING, input_index} state.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(fsm_state)</code> </pre> <br><p>        <code>push_at</code> ?      ,   .   ,    ,  ,    .   ,               .             .          -  ,     lock-free . </p><br><p>  ,      : </p><br><ol><li>   :       . </li><li> ,  :      . </li></ol><br><p>   :   <em>concurrent</em>  <em>exactly-once</em> . </p><br><p>      ?   : </p><br><ol><li>       ,         ,   <code>push_at</code>     false.            . </li><li>       ,      . ,   ,       . </li></ol><br><p>     <em>concurrent exactly-once</em>   ?   ,     ,            .    ,           .            . </p><br><p>          : </p><br><pre> <code class="hljs pgsql">#     ,  ,     # ..       <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, #      <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>. #       <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> push_at_idempotent(queue, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> queue.push_at(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> queue.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output, state): <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: switch fsm_state: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {PREPARING, input_index}: #   ,   , #        output_index = output.get_next_index() fsm_state = {WRITING, input_index, output_index} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {WRITING, input_index, output_index}: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(input_index) #   , #       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output.push_at_idempotent(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, output_index): input_index += <span class="hljs-number"><span class="hljs-number">1</span></span> fsm_state = {PREPARING, input_index} #     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> state.CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state): <span class="hljs-keyword"><span class="hljs-keyword">version</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: #   ,    <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned()</code> </pre> <br><p>  : </p><br><p><img src="https://habrastorage.org/webt/rx/qi/ub/rxqiubplbrrdlokp_sniqhktmvu.png" alt="Simple"></p><br><p>     ,     .     ,           . </p><br><p>             kernel panic,   ,    ..              .              .       :      ,    .  ,        . </p><br><p>  ,    <strong> </strong>    ,    . </p><br><h2 id="reshenie-nachalnoy-zadachi">    </h2><br><p>        :    . </p><br><p>       :  ,     ,    ,      ,      : </p><br><pre> <code class="hljs pgsql">#  : # - input_queues -   # - output_queues -   # - state -    # - <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span> -    : state, inputs -&gt; state, outputs handle(input_queues, output_queues, state, <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>): #        <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: switch fsm_state: # input_indexes       <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {HANDLING, user_state, input_indexes}: #       inputs = [queue.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> queue, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> zip(input_queues, input_indexes)] #   ,    next_indexes = next(inputs, input_indexes) #    #     user_state, outputs = <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>(user_state, inputs) #      , #     fsm_state = {PREPARING, user_state, next_indexes, outputs, <span class="hljs-number"><span class="hljs-number">0</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {PREPARING, user_state, input_indexes, outputs, output_pos}: #  ,      #    output_index = output_queues[output_pos].get_next_index() #     fsm_state = { WRITING, user_state, input_indexes, outputs, output_pos, output_index } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> { WRITING, user_state, input_indexes, outputs, output_pos, output_index }: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = outputs[output_pos] #       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output_queues[output_pos].push_at_idempotent( <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, output_index ): #  ,      output_pos += <span class="hljs-number"><span class="hljs-number">1</span></span> #    ,      PREPARING. #     #     fsm_state = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output_pos == len(outputs): #   , #       {HANDLING, user_state, input_indexes} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: #       #   , #         {PREPARING, user_state, input_indexes, outputs, output_pos} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> state.CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state): <span class="hljs-keyword"><span class="hljs-keyword">version</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: #   ,    <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned()</code> </pre> <br><p>     : </p><br><p><img src="https://habrastorage.org/webt/fe/mk/bg/femkbgvjaxyy2gi9ye5wkaufqf4.png" alt="finale"></p><br><p>      : <code>HANDLING</code> .        , ..,  ,     .  ,      .    ,   <code>PREPARING</code>  <code>WRITING</code>   ,         .     ,      <code>HANDLING</code> . </p><br><p>  ,      ,       ,          .   ,           .  ,            . </p><br><p>      .         .               . </p><br><p><img src="https://habrastorage.org/webt/or/qk/tg/orqktgqgrdw-9tv0_wkl2wt_rye.png" alt="finale"></p><br><p>   : </p><br><pre> <code class="hljs cpp">my_handler(state, inputs): #      state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.push(inputs) #    duration state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.trim_time_window(duration) #   avg = state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.avg() need_update_counter = state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.size() &gt; size_boundary <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state, [ avg, <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> need_update_counter: <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: # none      none ]</code> </pre> <br><p>  ,      ,           <em>concurrent exactly-once</em>     <code>handle</code> . </p><br><p>        : </p><br><pre> <code class="hljs pgsql">handle_db(input_queue, db): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #      tx = db.begin_transaction() #     . #      , #      <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = tx.get_current_index() #    tx.write_current_index(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) #      <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = intput_queue.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: #    tx.increment_counter() tx.<span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>() #   ,      , #          </code> </pre> <br><p>    .  Parce que       ,         , , ,    <em>concurrent exactly-once</em> .       . </p><br><h2 id="za-bortom">   </h2><br><p>   ‚Äî            .        ,      ,     . </p><br><h3 id="optimizacii-dlya-konkretnogo-hranilischa">     </h3><br><p>      ,      ,       .           ,  ,          . </p><br><h3 id="asinhronnaya-publikaciya">   </h3><br><p>           .    ,     .  Parce que        ,      .              .        . </p><br><h3 id="gruppirovka-znacheniy">   </h3><br><p>        ‚Äî   . ,       ,     .    ,     -  ,   ,    .        , .. ,    ,        . </p><br><h3 id="dvoynoe-shardirovanie">   </h3><br><p>       .   ,     ,           .            ,    ,    . </p><br><h2 id="fundamentalnost-podhoda">   </h2><br><p>     . ,         .  :          ,      .     ,       . </p><br><p>      ,   ,      : </p><br><ol><li>    ,   .          . </li><li>     .      ,        . </li><li>          .    ,       .      ,   ,        . ..          .     :    . </li></ol><br><p>     , , -,     ,  -,     . </p><br><p>     ,     .     : </p><br><pre> <code class="hljs pgsql">transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): #   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> withdraw(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ok: #     , #    deposit(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount)</code> </pre> <br><p>  <code>withdraw</code>     ,   ,  <code>deposit</code>    :      ?    <code>deposit</code>  -     (,   ,       ),    .  ,    ,    ,   ,        ?    ,   ,      - ,     . </p><br><p>     ,   ,   ,     . ,     ,   ,   .   ,     .   ,       ,       .  Parce que     ,       ,        .      ,        :     ,     ‚Äî  . </p><br><h3 id="dvuhfaznost-bez-blokirovok">    </h3><br><p>      ,       . </p><br><p>      :        ,  ,     ,   ,   .   ,        -  : </p><br><ul><li> <em></em> .            ,   , ,     ,     . </li><li> <em></em> .        . </li></ul><br><p>     , , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . </p><br><p> ,        , ..       ,      ,  .        ,       . </p><br><p>          :     lock-free   ,           .            , ..      ,  . </p><br><p>      CAS       . ,      : </p><br><pre> <code class="hljs swift">#     ,    handle(input, output, state): # ... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> fsm_state: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {<span class="hljs-type"><span class="hljs-type">HANDLING</span></span>, ...}: #      fsm_state = {<span class="hljs-type"><span class="hljs-type">PREPARING</span></span>, ...} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {<span class="hljs-type"><span class="hljs-type">PREPARING</span></span>, input_index}: #   ... output_index = ...get_next_index() fsm_state = {<span class="hljs-type"><span class="hljs-type">WRITING</span></span>, output_index, ...} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {<span class="hljs-type"><span class="hljs-type">WRITING</span></span>, output_index, ...}: #  ,  output_index</code> </pre> <br><p>  ,     .          .      : </p><br><ol><li> <strong>PREPARING</strong> .     ,        . </li><li> <strong>WRITING</strong> .     .       ,       <strong>PREPARING</strong> . </li></ol><br><p>     ,      . ,          ,     ‚Äî    .     : </p><br><ol><li>         .  ,    , ..     ,      . </li><li>            , ..       .         ,     . </li></ol><br><p>  ,  lock-free        ,        ,     . </p><br><h2 id="trebovaniya-k-konsistentnosti">    </h2><br><p>  ,     .     ,      <em>Stale Read</em> ,       .   ‚Äî       CAS:              .       : </p><br><ul><li> <em>Distributed single register</em> ‚Äî       (, etcd  Zookeeper): <br><ol><li> Linearizability </li><li> Sequential consistency </li></ol></li><li> <em>Transactional</em> ‚Äî     (, MySQL, PostgreSQL  ..): <br><ol><li> Serializability </li><li> Snapshot Isolation </li><li> Repeatable Read </li><li> Read Committed </li></ol></li><li> <em>Distributed Transactional</em> ‚Äî NewSQL : <br><ol><li> Strict Consistency </li><li>    </li></ol></li></ul><br><p>   :             ?   ,  ,   .         ,    ,     CAS                .        , ,   <em>Read My Writes</em> . </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>        <em>exactly-once</em> .     , ..  ,  ,    ,    .       ,      ,  , , ..        ,     . </p><br><p>       lock-free       . </p><br><p>    : </p><br><ol><li> <strong></strong> :      . </li><li> <strong></strong> :       . </li><li> <strong></strong> :        : <em>exactly-once</em> . </li><li> <strong>Concurrent</strong> :       . </li><li> <strong>Real-time</strong> :     . </li><li> <strong>Lock-free</strong> :      ,     . </li><li> <strong>Deadlock free</strong> :      ,      . </li><li> <strong>Race condition free</strong> :     . </li><li> <strong>Hot-hot</strong> :        . </li><li> <strong>Hard stop</strong> :       . </li><li> <strong>No failover</strong> :                  . </li><li> <strong>No downtime</strong> :    . </li><li> <strong> </strong> :   ,    . </li><li> <strong></strong> :         . </li><li> <strong></strong> :         . </li><li> <strong></strong> :        . </li></ol><br><p>  ,        .  Mais c'est une autre histoire. </p><br><p><img src="https://habrastorage.org/webt/ku/4j/nf/ku4jnf9-1pkdjfh_peshj0xd73w.jpeg" alt="Lumi√®re"></p><br><h2 id="novye-terminy">   </h2><br><p>       : </p><br><ol><li> Concurrent exactly-once. </li><li> Semi-transactions  . </li><li> Lock-free two-phase commit,       . </li></ol><br><h2 id="zadachi-dlya-samoistyazaniya">    </h2><br><ol><li>     . </li><li>  lock-free       . </li><li>    . </li></ol><br><h2 id="literatura">  </h2><br><p> [1] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">:  ABA.</a> <br> [2] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Blog: You Cannot Have Exactly-Once Delivery</a> <br> [3] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">:         .</a> <br> [4] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">:  3:  .</a> <br> [5] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">:  .</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr413817/">https://habr.com/ru/post/fr413817/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr413807/index.html">D√©termination des caract√©ristiques balistiques-temporelles du mouvement du centre de masse d'un parachutiste atterrissant d'un avion</a></li>
<li><a href="../fr413809/index.html">Set-Top-Box et exp√©riences avec Android dans le conteneur LXC</a></li>
<li><a href="../fr413811/index.html">Le condens√© de mati√®res fra√Æches du monde du front-end de la derni√®re semaine n ¬∞ 318 (4-10 juin 2018)</a></li>
<li><a href="../fr413813/index.html">PHP Digest n ¬∞ 132 (27 mai - 10 juin 2018)</a></li>
<li><a href="../fr413815/index.html">Atelier de contribution Go en Russie</a></li>
<li><a href="../fr413819/index.html">Honn√™tement sur le march√© informatique en Russie</a></li>
<li><a href="../fr413823/index.html">Le boom de l'emploi insignifiant</a></li>
<li><a href="../fr413827/index.html">Le projet Kubernetes f√™te ses 4 ans</a></li>
<li><a href="../fr413831/index.html">La nouvelle version de Tesla Autopilot sortira en ao√ªt, pour la premi√®re fois avec des ¬´fonctions de conduite enti√®rement autonomes¬ª</a></li>
<li><a href="../fr413837/index.html">Faire de Tower Defense un jeu d'unit√© - Partie 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>