<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ“‹ ğŸ â˜€ï¸ Efek filter SVG. Bagian 2. Garis besar teks dengan feMorphology ğŸ‘©â€ğŸ“ ğŸ¤±ğŸ¿ ğŸ‘¨ğŸ¾â€ğŸ«</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rangkaian artikel yang diusulkan, " Efek Penyaringan SVG, " oleh Sara Soueidan, pengembang antarmuka UI / UX lepas dan penulis banyak artikel teknis y...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Efek filter SVG. Bagian 2. Garis besar teks dengan feMorphology</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439722/"><p>  Rangkaian artikel yang diusulkan, " <strong>Efek Penyaringan SVG,</strong> " oleh Sara Soueidan, pengembang antarmuka UI / UX lepas dan penulis banyak artikel teknis yang berbasis di Lebanon, berfokus pada karya filter SVG dan terdiri dari artikel berikut: </p><br><h1 id="effekty-filtracii-svg">  Efek Penyaringan SVG </h1><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Efek penyaringan SVG.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1. Filter SVG 101</a> . </li><li>  Efek penyaringan SVG.  Bagian 2. Garis besar teks dengan feMorphology </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Efek penyaringan SVG.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3. Pengaruh posterisasi gambar menggunakan feComponentTransfer</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Efek penyaringan SVG.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 4. Gambar dua warna dengan <strong>feComponentTransfer</strong></a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Efek penyaringan SVG.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 5. Mencocokkan teks dengan tekstur permukaan dengan <strong>feDisplacementMap</strong></a> </li></ol><br><hr><br><p>  Pada bagian kedua dari seri filter SVG, <strong>Sara Soueidan</strong> memperkenalkan kita pada filter <strong>feMorphology</strong> dan memberikan beberapa contoh bagaimana menggunakannya untuk menciptakan efek yang menarik. </p><br><p><img src="https://habrastorage.org/webt/pt/1l/yq/pt1lyq3deuk69mcyf2ax_yt9_tc.png"></p><a name="habracut"></a><br><p>  Pada bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>pertama dari seri ini</strong></a> tentang efek filter SVG, kami memperkenalkan dasar-dasar filter SVG - cara membuat mereka dan cara menggunakannya.  Kami juga memeriksa beberapa operasi penyaringan yang paling umum digunakan, yaitu  filter primitif.  Karena  Karena kami akan menggunakan kembali informasi ini, saya sarankan berhenti dan membaca artikel itu sebelum beralih ke yang ini. </p><br><p>  <strong>&lt;feMorphology&gt;</strong> adalah salah satu operasi filter SVG favorit saya.  Ini juga salah satu operasi paling sederhana, dan hasil penerapannya ke berbagai elemen selalu dapat diprediksi. </p><br><h2 id="chto-takoe-morfing">  Apa itu morphing? </h2><br><p>  Morphing berarti mengubah atau mengubah bentuk atau penampilan suatu objek. </p><br><p>  Filter morfologis beroperasi pada bentuk objek.  Ini memberikan dua transformasi bentuk yang telah ditentukan: erosi (mis. Penipisan atau reduksi) dan ekspansi (mis., Penebalan atau ekspansi).  Dengan kata lain, primitif <strong>feMorphology</strong> dapat digunakan untuk mengompresi atau memperluas elemen. </p><br><p>  Secara teknis, kedua operasi ini bekerja pada tingkat piksel, memperluas piksel ke piksel tetangga ( <strong>melebar</strong> ), atau menghancurkan piksel tetangga di tepi piksel terkontrol ( <strong>terkikis</strong> ), sambil mempertahankan garis besar di perbatasan piksel tersebut.  Nilai di mana piksel mengembang, atau jumlah piksel tetangga yang digunakan untuk "merentangkan" atau "memperluas" piksel, ditentukan oleh parameter <strong>radius</strong> . </p><br><pre><code class="plaintext hljs">&lt;feMorphology in=".." result=".." operator="dilate || erode" radius=""&gt; &lt;/feMorphology&gt;</code> </pre> <br><p>  Jari-jari morphing dapat direpresentasikan sebagai jari-jari lingkaran atau elips.  Semua piksel tetangga yang tertutup dalam lingkaran jari-jari ini, mulai dari piksel masukan, dianggap sebagai satu komunitas piksel dan akan digunakan dalam efek ekspansi atau erosi. </p><br><p>  Namun, pada kenyataannya, jari-jari sebenarnya mencirikan ukuran inti, yang disebut elemen penataan, yang lebih mirip matriks.  Untuk saat ini, itu cukup untuk mewakilinya sebagai persegi panjang kecil, lebar dan tingginya ditentukan oleh piksel yang ditentukan dalam atribut <strong>radius</strong> . <br><img src="https://habrastorage.org/webt/hn/vy/ch/hnvychycyjlugtdv4rebde8gcro.png"></p><br><p>  Untuk menggunakan filter, kita tidak perlu membahas hal-hal kecil yang membosankan yang dilakukan morphing pada tingkat piksel.  Cukup mengetahui bahwa Anda dapat memberikan satu atau dua nilai radius dalam <strong>feMorphology</strong> , yang akan menentukan jumlah di mana elemen akan dikompresi atau diperluas.  Jika dua angka ditentukan dalam atribut <strong>radius</strong> , yang pertama akan sesuai dengan jari-jari x, dan yang kedua dengan jari-jari y. </p><br><h2 id="morfing-izobrazheniy">  Gambar Morph </h2><br><p>  Jika operasi <strong>feMorphology</strong> diterapkan pada gambar, maka dua, sebagai aturan, hasil yang dapat diprediksi akan mengikuti: </p><br><ul><li>  Ukuran gambar berkurang jika operator <strong>erode digunakan</strong> , atau bertambah jika operator <strong>dilatasi digunakan</strong> . </li><li>  Dengan operator apa pun, gambar tampak seolah-olah dicat dengan kuas cat besar, dengan sedikit detail kecil. </li></ul><br><p>  Jadi, untuk menerapkan efek morphing pada gambar, kode kita akan terlihat seperti ini: </p><br><pre> <code class="plaintext hljs">&lt;svg width="450" height="300" viewBox="0 0 450 300"&gt; &lt;filter id="erode"&gt; &lt;feMorphology operator="erode" radius="3"&gt;&lt;/feMorphology&gt; &lt;/filter&gt; &lt;image xlink:href="..." width="90%" height="90%" x="10" y="10" filter="url(#erode)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><p>  Dalam fragmen ini, kami mengaburkan (kompres) gambar (dalam piksel) sebanyak 3 piksel.  Gambar berikut menunjukkan hasil dari kode ini.  Perhatikan bahwa ukuran gambar di sebelah kanan sedikit lebih kecil: </p><br><p><img src="https://habrastorage.org/webt/o6/_z/zo/o6_zzo1nl1ppmugvmhevox8afxi.png" alt="Di sebelah kanan, hasil menerapkan efek blur dari morphing ke gambar di sebelah kiri"><br>  Fig_2.  Di sebelah kanan, hasil menerapkan efek blur dari morphing ke gambar di sebelah kiri. </p><br><p>  Sekarang, jika kita menjaga radius morphing yang sama dan mengubah operator dari <strong>erode</strong> menjadi <strong>melebar</strong> , efeknya akan serupa, tetapi juga berbeda: </p><br><p><img src="https://habrastorage.org/webt/lf/ia/uv/lfiauvdmlzkld2fqfuzrm81pvpa.png"><br>  Fig_3.  Di sebelah kanan, hasil penerapan operasi <strong>morf dilatasi</strong> ke gambar di sebelah kiri. </p><br><p>  Dalam kedua kasus, gambar itu tampak seperti versi abstrak yang dilukis sendiri, dan ukuran keseluruhannya berubah ketika piksel mengembang atau menyusut. </p><br><p>  Namun selain hasil ini, mungkin hal pertama yang Anda perhatikan adalah perbedaan warna yang dihasilkan dari masing-masing dua efek ini: <strong>erode</strong> menciptakan gambar dengan banyak piksel gelap, sementara <strong>melebarkan</strong> mencerahkan hasilnya.  Ini disebabkan oleh kenyataan bahwa: </p><br><ul><li>  <strong>erode</strong> (nilai ini digunakan secara default) untuk masing-masing piksel menetapkan kecerahan terendah atau opacity tertinggi dari komunitasnya, masing-masing, untuk masing-masing saluran R, G, B dan A; </li><li>  <strong>melebarkan</strong> set untuk setiap saluran dari setiap piksel nilai yang sesuai dengan nilai cerah atau paling transparan dari komunitasnya. </li></ul><br><p>  <strong>Mengesampingkan</strong> detail teknis, menerapkan <strong>feMorphology</strong> ke gambar hampir selalu memiliki hasil yang sama: mengompresi atau meregangkan bagian-bagian kecil gambar sebagai salinan gambar dengan garis utama gelap atau terang. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/SaraSoueidan/embed/preview/eyyMea" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Namun, menerapkan <strong>feMorphology</strong> ke elemen monokrom seperti teks hanya mengompres atau merentangkannya tanpa membuat perubahan warna yang terlihat pada piksel, karena kami hanya memiliki satu warna untuk ... </p><br><h2 id="dobavlenie-cvetnogo-kontura-k-tekstu-s-pomoschyu-femorphology">  Menambahkan garis warna ke teks dengan feMorphology </h2><br><p>  Sekarang kita bisa menambahkan garis besar ke teks di SVG menggunakan atribut <strong>stroke</strong> untuk teks ini. </p><br><pre> <code class="plaintext hljs">&lt;!-- Adding an outline to SVG text using strokes --&gt; &lt;text font-size="80px" dx="100" dy="200" font-weight="700" stroke="deepPink" stroke-width="3px"&gt;Stroked Text&lt;/text&gt;</code> </pre> <br><p>  Menambahkan jalur yang biasanya berpusat di sekitar tepi teks sehingga setengah dari ketebalannya tumpang tindih oleh teks itu sendiri membuat teks lebih tipis, bahkan jika itu tidak dimaksudkan.  Sebagai gantinya, kita dapat melebarkan teks hingga ketebalan garis luar atau garis menggunakan <strong>feMorphology</strong> . </p><br><p>  Kecuali ditentukan lain, teks biasanya memiliki satu warna.  Jadi, diterapkan pada teks, <strong>feMorphology</strong> memungkinkan <strong>Anda</strong> untuk mengurangi atau meningkatkan ketebalan teks.  Setelah teks diperluas dengan <strong>feMorphology</strong> , <strong>teks</strong> tersebut dapat digunakan sebagai input ke filter primitif lainnya untuk membuat garis besar teks, yang kami butuhkan. </p><br><p>  Sebelum kita mempelajari bagaimana melakukan ini, lihat grafik yang menunjukkan perbedaan antara teks dengan garis lingkaran dan garis yang ditambahkan dengan <strong>feMorphology</strong> . </p><br><p><img src="https://habrastorage.org/webt/cu/rd/-d/curd-dnppif0tvvgoyb4sxrccn0.png" alt="Membandingkan teks sumber dengan teks dengan goresan dan garis besar dibuat dengan ** feMorphology **"><br>  Fig_4.  Perbandingan teks sumber dengan teks dengan goresan dan garis besar dibuat menggunakan <strong>feMorphology</strong> . </p><br><p>  Harap perhatikan bahwa teks sumber pada baris kedua menjadi lebih tipis setelah menambahkan garis halus, dibandingkan dengan teks dari baris ketiga, diperluas dengan <strong>feMorphology</strong> . </p><br><p>  Jadi, mari selangkah demi selangkah membuat bagian teks yang berwarna dengan garis besar.  Inilah hasil yang akan kami perjuangkan: </p><br><p><img src="https://habrastorage.org/webt/9o/ox/dc/9ooxdcthwek445glxn3u9kobgsy.png" alt="Hasil akhir"><br>  Fig_5.  Hasil akhirnya. </p><br><p>  Jadi, kami akan membuat SVG yang berisi teks kami dan filter yang memulai operasi ekstensi sederhana.  Ukuran ekstensi teks tergantung pada ketebalan garis yang ingin kita dapatkan. </p><br><pre> <code class="plaintext hljs">&lt;svg width="900" height="200" viewBox="100 0 900 200"&gt; &lt;filter id="outline"&gt; &lt;feMorphology in="SourceAlpha" result="DILATED" operator="dilate" radius="4"&gt;&lt;/feMorphology&gt; &lt;/filter&gt; &lt;!-- DILATED TEXT --&gt; &lt;text font-size="85px" dx="125" dy="130" font-weight="700" filter="url(#outline)"&gt;upgrade yourself&lt;/text&gt; &lt;/svg&gt;</code> </pre> <br><p>  Kode di atas akan mendapatkan saluran alfa teks, yang hanya merupakan versi hitam dari teks, dan meningkatkan ketebalan font sebesar 4px.  Hasil dari kode pada tahap ini adalah sebagai berikut: </p><br><p><img src="https://habrastorage.org/webt/th/ap/aj/thapajsoryyxflgrf1ky85t28wg.png" alt="Teks setelah penebalan"><br>  Fig_6.  Teks setelah penebalan. </p><br><p>  ... dibandingkan dengan teks sumber, yang memiliki warna isian biru tua: </p><br><p><img src="https://habrastorage.org/webt/lo/g6/e0/log6e0ykecbusfnf0lf8auxrcfc.png" alt="Sumber teks"><br>  Fig_7.  Sumber teks. </p><br><p>  Untuk membuat efek kontur, kami overlay teks sumber di atas teks yang diperluas, hanya menyisakan tepi teks yang diperluas (4px tambahan kami) yang terlihat di sekitar teks sumber, membuatnya terlihat seperti jalur.  Hamparan teks pada garis besarnya (teks diperluas) akan dilakukan menggunakan <strong>feMerge</strong> .  Bagaimana ini dilakukan, kami memeriksa dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya</a> . </p><br><p>  Apa lagi yang perlu kita lakukan sebelum menempatkan outline di sekitar teks adalah mewarnai outline itu sendiri.  Sama seperti yang kami lakukan di artikel sebelumnya, isi area filter dengan warna yang diinginkan, dan kemudian tambahkan layer warna dengan layer teks yang sudah diperluas, mis.  sirkuit kami menggunakan operator <strong>in</strong> .  Akibatnya, hanya bagian-bagian dari isi warna yang bersinggungan dengan teks yang diperluas yang akan ditampilkan, sehingga mewarnai.  Kemudian, kami menggabungkan garis warna yang dihasilkan dengan teks sumber untuk mendapatkan hasil yang diinginkan. </p><br><p>  Sekarang kode kita terlihat seperti ini: </p><br><pre> <code class="plaintext hljs">&lt;svg width="900" height="200" viewBox="100 0 900 200"&gt; &lt;filter id="outline"&gt; &lt;feMorphology in="SourceAlpha" result="DILATED" operator="dilate" radius="4"&gt;&lt;/feMorphology&gt; &lt;feFlood flood-color="#32DFEC" flood-opacity="1" result="PINK"&gt;&lt;/feFlood&gt; &lt;feComposite in="PINK" in2="DILATED" operator="in" result="OUTLINE"&gt;&lt;/feComposite&gt; &lt;feMerge&gt; &lt;feMergeNode in="OUTLINE" /&gt; &lt;feMergeNode in="SourceGraphic" /&gt; &lt;/feMerge&gt; &lt;/filter&gt; &lt;!-- DILATED TEXT --&gt; &lt;text font-size="85px" dx="125" dy="130" font-weight="700" filter="url(#outline)"&gt;upgrade yourself&lt;/text&gt; &lt;/svg&gt;</code> </pre> <br><p>  Proses menciptakan efek penyaringan dalam SVG terdiri dari mewakili hasil akhir dalam bentuk operasi sekuensial kecil, menggunakan hasil dari satu operasi sebagai input ke yang lain, dan akhirnya menggabungkan semua lapisan yang dibuat oleh mereka untuk mencapai hasil akhir. </p><br><p>  Dan ini adalah demo dari kode di atas: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/SaraSoueidan/embed/preview/QzxQqK" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Warna isi teks dapat ditentukan baik dalam CSS Anda atau dalam elemen <strong>teks</strong> menggunakan atribut <strong>fill</strong> .  Warna outline dapat diatur dalam atribut <strong>warna banjir</strong> dari primitif <strong>floFlood</strong> . </p><br><p>  Hebat!  Dan jika Anda ingin mengubah warna kontur?  Anda harus menggunakan primitif <strong>feFlood lagi</strong> dan menggabungkan warna mengisi dengan garis besar.  Dan setiap kali Anda ingin mengubah warna garis besar, Anda harus melakukan hal yang sama berulang kali.  Ini, memang, terlalu melelahkan.  Untungnya, ada cara yang lebih mudah. </p><br><h2 id="vybivanie-teksta">  Knock out text </h2><br><p>  Selain menambahkan kontur ke teks, kami juga dapat membuat kontur, mis.  teks timbul, yang berarti bahwa bagian dalam teks akan "dipotong" sehingga Anda dapat melihat latar belakang di baliknya melalui garis besar.  Contoh dari efek seperti itu mungkin terlihat seperti teks pada GIF berikutnya, yang menunjukkan perubahan warna latar belakang, dan bagaimana latar belakang ini dapat dilihat di dalam teks kita.  Ini demo yang akan kami buat di bagian ini: </p><br><p><img src="https://habrastorage.org/webt/go/bq/ew/gobqewey5txr4yvz2mgvmiirnfa.gif" alt="Contoh Teks Timbul"><br>  Fig_8.  Contoh teks timbul. </p><br><p>  Efek ini lebih mudah dibuat, dan kode yang diperlukan untuk menjalankannya terasa lebih pendek.  Perbedaan utama di sini adalah daripada meletakkan teks sumber di atas teks yang diperluas, kita akan menggunakan teks sumber yang sama untuk memotong bagian dalam teks yang diperluas.  Ini berarti bahwa hanya ketebalan tambahan dari teks yang diperluas yang akan tetap ada, dan bagian dalam akan dihapus, sehingga hanya menyisakan kita garis besarnya. </p><br><p>  Jika alih-alih menangkap dan memperluas saluran Alpha dari teks (yang merupakan hitam secara default), Anda menangkap teks sumber itu sendiri (yang dapat memiliki warna isian apa pun!), Perluas, dan kemudian gunakan teks itu lagi untuk memotong bagian dalam teks yang diperluas, Anda akan mendapatkan garis besar, yang berasal dari kode sumber itu sendiri.  Ini berarti bahwa warna jalur ini akan selalu cocok dengan warna teks sumber.  Dan karena kita dapat menentukan warna isian teks sumber dalam CSS, ini berarti Anda memiliki garis besar teks yang terpisah dari gayanya.  (Hore pemisahan kekhawatiran!) Kemudian Anda dapat menerapkan filter ini ke bagian teks apa pun dan mengubah warna teks ini dalam CSS kapan saja, tanpa perlu mengkonfigurasi kode filter.  Kode kami yang ditingkatkan sekarang terlihat seperti ini: </p><br><pre> <code class="plaintext hljs">&lt;svg width="900" height="450" viewBox="0 0 900 450"&gt; &lt;filter id="outliner"&gt; &lt;!-- Start by grabbing the alpha channel of the text and dilating it--&gt; &lt;feMorphology operator="dilate" radius="8" in="SourceAlpha" result="THICKNESS" /&gt; &lt;!-- Next, grab the original text (SourceGraphic) and use it to cut out the inside of the dilated text --&gt; &lt;feComposite operator="out" in="THICKNESS" in2="SourceGraphic"&gt;&lt;/feComposite&gt; &lt;/filter&gt; &lt;text dx="100" dy="300" filter="url(#outliner)" letter-spacing="10px"&gt;SVG Rocks&lt;/text&gt; &lt;/svg&gt;</code> </pre> <br><p>  Menggunakan font yang bagus, demo kami sekarang terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/webt/ck/vc/5d/ckvc5dlnx9qb8ufj89lg21kj_wi.png"><br>  Fig_9.  Hasil dari pekerjaan kami. </p><br><p>  Dalam style sheet kami, kami dapat memilih warna garis besar serta warna latar belakang SVG.  Anda juga dapat memilih gambar dengan teks di dalam SVG.  Dalam kode di bawah ini, saya menggunakan animasi CSS tanpa alasan untuk mengubah warna latar belakang, kecuali bahwa itu indah. </p><br><pre> <code class="plaintext hljs">svg text { font-family: 'Bangers', cursive; font-size: 150px; letter-spacing: 13px; fill: #000; /* This fill color determines the color of the outline */ } svg { background-color: gold; animation: colorsssss 2s linear infinite; animation-delay: 3s; } @keyframes colorsssss { 50% { background-color: deepPink; } }</code> </pre> <br><p>  Filter SVG di atas dapat digunakan kembali melalui SVG seperti halnya HTML.  Jika Anda ingin menerapkannya ke elemen HTML, Anda dapat melakukan ini menggunakan properti <strong>filter</strong> ;  cukup letakkan filter dalam HTML dan â€œpanggilâ€ dalam CSS: </p><br><pre> <code class="plaintext hljs">h2 { filter: url(#outliner); /* You can change the color of the outline here by changing the color of the heading */ color: deepPink; }</code> </pre> <br><p>  Dan demo kami yang sudah jadi, termasuk header HTML dengan filter yang diterapkan padanya: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/SaraSoueidan/embed/preview/EoEZwr" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Hal favorit saya tentang resep filter ini adalah dapat digunakan sebagai perangkat tambahan visual.  Jika browser tidak mendukung filter SVG, atau tidak mendukung filter CSS, atau tidak mendukung penerapan filter SVG ke elemen HTML, pengguna akan menerima teks sumber tanpa garis besar dan efek tembus yang diterapkan padanya.  Oh, dan ceri di atas kue?  Baik teks SVG dan HTML akan sepenuhnya dapat dicari dan diedit.  Hore peningkatan progresif!  Hidup SVG! </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Dengan hanya menggunakan dua operasi pemfilteran dalam SVG, Anda dapat menerapkan efek teks yang dipilih ke konten teks SVG atau HTML.  Masukkan filter ini dalam HTML dan gunakan saat Anda membutuhkannya. </p><br><p>  Pada artikel selanjutnya dalam seri ini, kita akan melihat <strong>feComponentTransfer</strong> , salah satu filter favorit favorit saya, dan melihat cara kerjanya dan efek apa yang dapat kita buat dengannya.  Tetap bersama kami. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id439722/">https://habr.com/ru/post/id439722/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id439712/index.html">Pengadaan publik: keseimbangan antara pemogokan Italia dan penjahat Rusia</a></li>
<li><a href="../id439714/index.html">Rusia di Apple: bagaimana kami mendapat kontrak jutaan dengan Beatles dan lagu "some Jerry"</a></li>
<li><a href="../id439716/index.html">Ekor OS atau cara melindungi diri Anda secara online</a></li>
<li><a href="../id439718/index.html">Pengembangan Aplikasi pada Elixir / Phoenix dengan Docker</a></li>
<li><a href="../id439720/index.html">Pengantar Pemrograman: Penembak 3D Sederhana dari Bawah ke Atas di Akhir Pekan, Bagian 2</a></li>
<li><a href="../id439724/index.html">Ikhtisar solusi AI & ML pada 2018 dan perkiraan untuk 2019: Bagian 2 - Alat dan perpustakaan, AutoML, RL, etika dalam AI</a></li>
<li><a href="../id439726/index.html">Lock-in: benar atau fiksi?</a></li>
<li><a href="../id439728/index.html">Konfigurasikan cadangan dan pemulihan Zimbra OSE yang lengkap dan terpisah tanpa menggunakan Zextras</a></li>
<li><a href="../id439730/index.html">Organisasi peredam melalui kelas standar</a></li>
<li><a href="../id439732/index.html">Lazarus - animasi sederhana menggunakan komponen TImageFragment</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>