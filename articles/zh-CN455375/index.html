<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✅ 🎊 🍽️ 用Pascal编写UDR ⚰️ 👩🏾‍⚖️ 🎣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="长期以来，Firebird能够通过编写外部函数-UDF（用户定义函数）来扩展PSQL语言的功能。 UDF可以用几乎任何编译的编程语言编写。 


 Firebird 3.0引入了插件体系结构以扩展Firebird的功能。 这些插件之一是外部引擎（external engine）。 UDR（用户定义的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>用Pascal编写UDR</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455375/"><p> 长期以来，Firebird能够通过编写外部函数-UDF（用户定义函数）来扩展PSQL语言的功能。  UDF可以用几乎任何编译的编程语言编写。 </p><br><p>  Firebird 3.0引入了插件体系结构以扩展Firebird的功能。 这些插件之一是外部引擎（external engine）。  UDR（用户定义的例程-用户定义的例程）机制在FirebirdExternal引擎界面的顶部添加了一层。 </p><br><p> 在本指南中，我们将告诉您如何声明UDR，其内部机制，功能，并提供在Pascal中编写UDR的示例。 此外，还将介绍使用新的面向对象的API的某些方面。 </p><a name="habracut"></a><br><blockquote>  <strong>备注</strong> <br><br> 本文旨在教您如何使用对象Firebird API编写UDR。 <br> 书面功能和程序可能没有实际应用。 </blockquote><p> 与传统UDF相比，UDR具有以下优点： </p><br><ul><li> 您不仅可以编写返回标量结果的函数，还可以编写存储过程（可执行的和选择性的）以及触发器； </li><li> 改进了对输入和输出参数的控制。 在某些情况下（通过描述符传递），输入参数的类型和其他属性完全不受控制，但是，您可以在UDF中获得这些属性。  UDR提供了更统一的声明输入和输出参数的方式，因为常规PSQL函数和过程就是这种情况。 </li><li>  UDR当前连接或事务的上下文可用，这使您可以执行 <br> 在这种情况下对当前数据库进行一些操作； </li><li> 发生异常时可以使用Firebird错误生成；无需返回特殊值； </li><li> 外部过程和函数（UDR）可以分组在PSQL包中； </li><li> 可以用任何编程语言（可选地编译为目标代码）编写UDR，为此，必须编写相应的“外部引擎”插件。 例如，有一些插件可以用Java或任何.NET语言编写外部模块。 </li></ul><br><blockquote>  <strong>备注</strong> <br><br> 当前的UDR实现使用PSQL存根。 例如，它用来 <br> 检查参数和返回值是否符合限制。 存根 <br> 之所以使用它，是因为不能直接调用内部函数。 结果 <br> 比较UDR和UDF性能的测试表明，UDR大约为 <br> 以添加两个参数的最简单函数为例，速度慢了2.5倍。 速度 <br>  UDR大约等于常规PSQL函数的速度。 也许将来 <br> 片刻将被优化。 在更复杂的功能中，这种开销可能变成 <br> 难以察觉。 </blockquote><p> 此外，在本手册的各个部分中，使用术语“外部过程”时， <br> 功能或触发器，我们指的是完全UDR（而不是UDF）。 </p><br><blockquote>  <strong>备注</strong> <br><br> 我们所有的示例都适用于Delphi 2009及更高版本以及Free Pascal。 全部 <br> 可以在Delphi和Free Pascal中编译示例 <br> 没有单独指定。 </blockquote><br><h2 id="firebird-api"> 火鸟API </h2><br><p>要用编译的编程语言编写外部过程，函数或触发器，我们需要了解新的面向对象的Firebird API。 本指南不包含Firebird API的完整说明。 您可以在与Firebird一起分发的文档目录（ <code>doc/Using_OO_API.html</code> ）中阅读该文档。 </p><br><p> 包含API的各种编程语言的插件不会作为Windows的Firebird分发的一部分进行分发，但是您可以从Linux分发的压缩tarbar文件（ <code>/opt/firebird/include/firebird/Firebird.pas</code>存档中的路径）中提取它们。 </p><br><h3 id="cloop"> 团 </h3><br><p>  CLOOP-跨语言面向对象的编程。 该工具不包含在Firebird中。 可以在源代码<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/FirebirdSQL/firebird/tree/B3_0_Release/extern/cloop中找到</a> 。 组装完该工具后，您可以基于<code>include/firebird/FirebirdInterface.idl</code>接口描述文件为您的编程语言（ <code>IdlFbInterfaces.h</code>或<code>Firebird.pas</code> ）生成一个API。 </p><br><p> 对于对象pascal，可通过以下命令完成： </p><br><pre> <code class="plaintext hljs">cloop FirebirdInterface.idl pascal Firebird.pas Firebird --uses SysUtils \ --interfaceFile Pascal.interface.pas \ --implementationFile Pascal.implementation.pas \ --exceptionClass FbException --prefix I \ --functionsFile fb_get_master_interface.pas</code> </pre> <br><p> 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/FirebirdSQL/firebird/tree/B3_0_Release/src/misc/pascal</a>上找到<code>Pascal.interface.pas</code> ， <code>Pascal.implementation.pas</code>和<code>fb_get_master_interface.pas</code> 。 </p><br><blockquote>  <strong>备注</strong> <br><br> 在这种情况下，将为Firebird API添加前缀I，因为这在Object Pascal中被接受。 </blockquote><br><h4 id="konstanty"> 常数 </h4><br><p> 在生成的<code>Firebird.pas</code>文件中没有<code>isc_*</code>常量。 这些用于C / C ++语言的常量可以在<a href="">https://github.com/FirebirdSQL/firebird/blob/B3_0_Release/src/include/consts_pub.h中</a>找到。 要获取Pascal语言的常量，我们将使用AWK脚本转换语法。 在Windows上，您将需要安装Windows的Gawk或使用Linux的Windows子系统（在Windows 10上可用）。 这是通过以下命令完成的： </p><br><pre> <code class="plaintext hljs">awk -f Pascal.Constants.awk consts_pub.h &gt; const.pas</code> </pre> <br><p> 实现后，必须将结果文件的内容立即复制到<code>Firebird.pas</code>文件的空const节。 可以在以下位置找到<code>Pascal.Constants.awk</code>文件 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/FirebirdSQL/firebird/tree/B3_0_Release/src/misc/pascal</a> 。 </p><br><h3 id="upravlenie-vremenem-zhizni"> 终身管理 </h3><br><p>  Firebird接口不是基于COM规范的，因此管理它们的生存期是不同的。 </p><br><p>  Firebird中有两个接口处理生命周期管理：IDisposable和IReferenceCounted。 后者在创建其他接口时特别有效：IPlugin对链接进行计数，就像插件使用的许多其他接口一样。 这些接口包括描述如何连接到数据库，事务管理和SQL语句的接口。 </p><br><p> 带有引用计数的接口的额外开销并非总是必要的。 例如，IMaster是调用API其余部分可用功能的主接口，根据定义，它具有无限的生存期。 对于其他API，生存期严格由父接口的生存期决定；  IStatus介面不是 <br> 多线程的。 对于寿命有限的接口，有一种简单的销毁它们的方法（即dispose（）函数）很有用。 </p><br><blockquote>  <strong>提示</strong> <br><br> 如果您不知道如何破坏对象，请查看其层次结构，如果有 <br> 接口IReferenceCounted，然后使用引用计数。 <br> 对于带有引用计数的接口，在完成对象的工作后，有必要 <br> 通过调用release（）方法减少参考计数器。 </blockquote><br><h2 id="obyavlenie-udr">  UDR公告 </h2><br><p> 可以使用DDL命令在数据库中添加或删除UDR，就像添加或删除常规PSQL过程，函数或触发器一样。 在这种情况下，将使用EXTERNAL NAME子句指示其在外部模块中的位置，而不是触发器主体。 </p><br><p> 考虑一下这句话的语法；它将在外部过程，函数和触发器中通用。 </p><br><p>  <strong>语法：</strong> </p><br><pre> <code class="plaintext hljs">EXTERNAL NAME '&lt;extname&gt;' ENGINE &lt;engine&gt; [AS &lt;extbody&gt;] &lt;extname&gt; ::= '&lt;module name&gt;!&lt;routine name&gt;[!&lt;misc info&gt;]'</code> </pre> <br><p> 此EXTERNAL NAME子句的参数是一个字符串，指示函数在外部模块中的位置。 对于使用UDR引擎的外部模块，通过分隔符的这一行指示外部模块的名称，模块内部功能的名称以及用户定义的信息。 感叹号（！）用作分隔符。 </p><br><p>  ENGINE子句指定用于处理外部模块连接的引擎的名称。  Firebird使用UDR引擎来处理以编译语言（C，C ++，Pascal）编写的外部模块。 用Java编写的外部函数需要Java引擎。 </p><br><p> 在关键字AS之后，可以指定字符串文字-外部模块的“正文”（过程，函数或触发器），外部模块可以将其用于各种目的。 例如，可以指定一个SQL查询来访问外部数据库或某种语言的文本，以供您的函数解释。 </p><br><h3 id="vneshnie-funkcii"> 外部功能 </h3><br><div class="spoiler">  <b class="spoiler_title">句法</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">{CREATE [OR ALTER] | RECREATE} FUNCTION funcname [(&lt;inparam&gt; [, &lt;inparam&gt; ...])] RETURNS &lt;type&gt; [COLLATE collation] [DETERMINISTIC] EXTERNAL NAME &lt;extname&gt; ENGINE &lt;engine&gt; [AS &lt;extbody&gt;] &lt;inparam&gt; ::= &lt;param_decl&gt; [{= |DEFAULT} &lt;value&gt;] &lt;value&gt; ::= {literal | NULL | context_var} &lt;param_decl&gt; ::= paramname &lt;type&gt; [NOT NULL] [COLLATE collation] &lt;extname&gt; ::= '&lt;module name&gt;!&lt;routine name&gt; [!&lt;misc info&gt;]' &lt;type&gt; ::= &lt;datatype&gt; | [TYPE OF] domain | TYPE OF COLUMN rel.col &lt;datatype&gt; ::= {SMALLINT | INT[EGER] | BIGINT} | BOOLEAN | {FLOAT | DOUBLE PRECISION} | {DATE | TIME | TIMESTAMP} | {DECIMAL | NUMERIC} [(precision [, scale])] | {CHAR | CHARACTER | CHARACTER VARYING | VARCHAR} [(size)] [CHARACTER SET charset] | {NCHAR |NATIONAL CHARACTER | NATIONAL CHAR} [VARYING] [(size)] | BLOB [SUB_TYPE {subtype_num | subtype_name}] [SEGMENT SIZE seglen] [CHARACTER SET charset] | BLOB [(seglen [, subtype_num])]</code> </pre> </div></div><br><p> 可以使用ALTER FUNCTION语句更改外部函数的所有参数。 </p><br><p>  <strong>语法：</strong> </p><br><pre> <code class="plaintext hljs">ALTER FUNCTION funcname [(&lt;inparam&gt; [, &lt;inparam&gt; ...])] RETURNS &lt;type&gt; [COLLATE collation] [DETERMINISTIC] EXTERNAL NAME &lt;extname&gt; ENGINE &lt;engine&gt; [AS &lt;extbody&gt;] &lt;extname&gt; ::= '&lt;module name&gt;!&lt;routine name&gt;[!&lt;misc info&gt;]'</code> </pre> <br><p> 您可以使用DROP FUNCTION语句删除外部函数。 </p><br><p>  <strong>语法：</strong> </p><br><pre> <code class="plaintext hljs">DROP FUNCTION funcname</code> </pre> <br><div class="scrollable-table"><table><caption> 外部功能的一些参数 </caption><thead><tr><th> 参量 </th><th> 内容描述 </th></tr></thead><tbody><tr><td> 函数名 </td><td> 存储功能的名称。 最多可以包含31个字节。 </td></tr><tr><td> 无形 </td><td> 输入参数的描述。 </td></tr><tr><td> 模块名称 </td><td> 该功能所在的外部模块的名称。 </td></tr><tr><td> 常规名称 </td><td> 外部模块内部函数的内部名称。 </td></tr><tr><td> 杂项信息 </td><td> 用户定义的信息要发送到 <br> 外部模块的功能。 </td></tr><tr><td> 引擎 </td><td> 使用外部功能的引擎的名称。 通常名称是UDR。 </td></tr><tr><td> 外部体 </td><td> 身体是一种外部功能。  UDR可以将其用于各种目的的字符串文字。 </td></tr></tbody></table></div><br><p> 这里我们将不描述输入参数和输出的语法。 它完全符合常规PSQL函数的语法，《 SQL语言指南》中对此进行了详细说明。 相反，我们给出了一些带有说明的声明外部函数的示例。 </p><br><p>  <strong>添加三个参数的功能</strong> </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> sum_args ( n1 <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, n2 <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, n3 <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">external</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-string"><span class="hljs-string">'udrcpp_example!sum_args'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">engine</span></span> udr;</code> </pre> <br><p> 该功能的实现在udrcpp_example模块中。 在此模块内部，以名称sum_args注册了一个函数。 外部功能使用UDR引擎。 </p><br><p>  <strong>Java函数</strong> </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> regex_replace ( regex <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">60</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">str</span></span> <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">60</span></span>), replacement <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">60</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">60</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">external</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-string"><span class="hljs-string">'org.firebirdsql.fbjava.examples.fbjava_example.FbRegex.replace( String, String, String)'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">engine</span></span> <span class="hljs-keyword"><span class="hljs-keyword">java</span></span>;</code> </pre> <br><p> 该函数的实现在<code>org.firebirdsql.fbjava.examples.fbjava_example.FbRegex</code>类的replace静态函数中。 外部函数使用Java引擎。 </p><br><h3 id="vneshnie-procedury"> 外部程序 </h3><br><div class="spoiler">  <b class="spoiler_title">句法</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">{CREATE [OR ALTER] | RECREATE} PROCEDURE procname [(&lt;inparam&gt; [, &lt;inparam&gt; ...])] RETURNS (&lt;outparam&gt; [&lt;outparam&gt; ...]) EXTERNAL NAME &lt;extname&gt; ENGINE &lt;engine&gt; [AS &lt;extbody&gt;] &lt;inparam&gt; ::= &lt;param_decl&gt; [{= | DEFAULT} &lt;value&gt;] &lt;outparam&gt; ::= &lt;param_decl&gt; &lt;value&gt; ::= {literal | NULL | context_var} &lt;param_decl&gt; ::= paramname &lt;type&gt; [NOT NULL] [COLLATE collation] &lt;extname&gt; ::= '&lt;module name&gt;!&lt;routine name&gt;[!&lt;misc info&gt;]' &lt;type&gt; ::= &lt;datatype&gt; | [TYPE OF] domain | TYPE OF COLUMN rel.col &lt;datatype&gt; ::= {SMALLINT | INT[EGER] | BIGINT} | BOOLEAN | {FLOAT | DOUBLE PRECISION} | {DATE | TIME | TIMESTAMP} | {DECIMAL | NUMERIC} [(precision [,scale])] | {CHAR | CHARACTER | CHARACTER VARYING | VARCHAR} [(size)] [CHARACTER SET charset] | {NCHAR | NATIONAL CHARACTER | NATIONAL CHAR} [VARYING] [(size)] | BLOB [SUB_TYPE {subtype_num | subtype_name}] [SEGMENT SIZE seglen] [CHARACTER SET charset] | BLOB [(seglen [, subtype_num])]</code> </pre> </div></div><br><p> 可以使用ALTER PROCEDURE语句更改外部过程的所有参数。 </p><br><p>  <strong>语法：</strong> </p><br><pre> <code class="plaintext hljs">ALTER PROCEDURE procname [(&lt;inparam&gt; [, &lt;inparam&gt; ...])] RETURNS (&lt;outparam&gt; [, &lt;outparam&gt; ...]) EXTERNAL NAME &lt;extname&gt; ENGINE &lt;engine&gt; [AS &lt;extbody&gt;]</code> </pre> <br><p> 您可以使用DROP PROCEDURE语句删除外部过程。 </p><br><p>  <strong>语法：</strong> </p><br><pre> <code class="plaintext hljs">DROP PROCEDURE procname</code> </pre> <br><div class="scrollable-table"><table><caption> 外部程序的一些参数 </caption><thead><tr><th> 参量 </th><th> 内容描述 </th></tr></thead><tbody><tr><td> 函数名 </td><td> 存储过程的名称。 最多可以包含31个字节。 </td></tr><tr><td> 无形 </td><td> 输入参数的描述。 </td></tr><tr><td> 超越 </td><td> 输出参数的描述。 </td></tr><tr><td> 模块名称 </td><td> 该过程所在的外部模块的名称。 </td></tr><tr><td> 常规名称 </td><td> 外部模块内部过程的内部名称。 </td></tr><tr><td> 杂项信息 </td><td> 用户定义的信息要发送到 <br> 外部模块程序。 </td></tr><tr><td> 引擎 </td><td> 使用外部过程的引擎的名称。 通常名称是UDR。 </td></tr><tr><td> 外部体 </td><td> 外部过程的主体。  UDR可以将其用于各种目的的字符串文字。 </td></tr></tbody></table></div><br><p> 这里我们将不描述输入和输出参数的语法。 它完全符合常规PSQL过程的语法，《 SQL语言指南》中对此进行了详细说明。 取而代之的是，我们给出一些带有解释说明外部程序的示例。 </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">procedure</span></span> gen_rows_pascal ( start_n <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>, end_n <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">result</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">external</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-string"><span class="hljs-string">'pascaludr!gen_rows'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">engine</span></span> udr;</code> </pre> <br><p> 该功能的实现在pascaludr模块中。 在此模块内部，该过程以gen_rows名称注册。 外部过程使用UDR引擎。 </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">procedure</span></span> write_log ( message <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">external</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-string"><span class="hljs-string">'pascaludr!write_log'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">engine</span></span> udr;</code> </pre> <br><p> 该功能的实现在pascaludr模块中。 在此模块内部，该过程以名称write_log注册。 外部过程使用UDR引擎。 </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">procedure</span></span> employee_pgsql ( <span class="hljs-comment"><span class="hljs-comment">-- Firebird 3.0.0 has a bug with external procedures without parameters dummy integer = 1 ) returns ( id type of column employee.id, name type of column employee.name ) external name 'org.firebirdsql.fbjava.examples.fbjava_example.FbJdbc .executeQuery()!jdbc:postgresql:employee|postgres|postgres' engine java as 'select * from employee';</span></span></code> </pre> <br><p> 该函数的实现在类的静态函数executeQuery中 <br>  <code>org.firebirdsql.fbjava.examples.fbjava_example.FbJdbc</code> 。 在感叹号（！）之后，可以找到Information以通过JDBC连接到外部数据库。 外部函数使用Java引擎。 在此，作为外部过程的“主体”，传递了SQL查询以检索数据。 </p><br><blockquote>  <strong>备注</strong> <br><br> 此过程使用一个存根，在该存根中传递未使用的参数。 这是由于在Firebird 3.0中存在一个无参数处理外部过程的错误。 </blockquote><br><h3 id="razmeschenie-vneshnih-procedur-i-funkciy-vnutri-paketov"> 将外部过程和函数放在包中 </h3><br><p> 在PSQL包中放置一组相互关联的过程和函数很方便。 软件包可以包含外部和常规PSQL过程和函数。 </p><br><div class="spoiler">  <b class="spoiler_title">句法</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">{CREATE [OR ALTER] | RECREATE} PACKAGE package_name AS BEGIN [&lt;package_item&gt; ...] END {CREATE | RECREATE} PACKAGE BODY package_name AS BEGIN [&lt;package_item&gt; ...] [&lt;package_body_item&gt; ...] END &lt;package_item&gt; ::= &lt;function_decl&gt;; | &lt;procedure_decl&gt;; &lt;function_decl&gt; ::= FUNCTION func_name [(&lt;in_params&gt;)] RETURNS &lt;type&gt; [COLLATE collation] [DETERMINISTIC] &lt;procedure_decl&gt; ::= PROCEDURE proc_name [(&lt;in_params&gt;)] [RETURNS (&lt;out_params&gt;)] &lt;package_body_item&gt; ::= &lt;function_impl&gt; | &lt;procedure_impl&gt; &lt;function_impl&gt; ::= FUNCTION func_name [(&lt;in_impl_params&gt;)] RETURNS &lt;type&gt; [COLLATE collation] [DETERMINISTIC] &lt;routine body&gt; &lt;procedure_impl&gt; ::= PROCEDURE proc_name [(&lt;in_impl_params&gt;)] [RETURNS (&lt;out_params&gt;)] &lt;routine body&gt; &lt;routine body&gt; ::= &lt;sql routine body&gt; | &lt;external body reference&gt; &lt;sql routine body&gt; ::= AS   [&lt;declarations&gt;] BEGIN [&lt;PSQL_statements&gt;]   END &lt;declarations&gt; ::= &lt;declare_item&gt; [&lt;declare_item&gt; ...] &lt;declare_item&gt; ::= &lt;declare_var&gt;; | &lt;declare_cursor&gt;; | &lt;subroutine declaration&gt;; | &lt;subroutine implimentation&gt; &lt;subroutine declaration&gt; ::= &lt;subfunc_decl&gt; | &lt;subproc_decl&gt; &lt;subroutine implimentation&gt; ::= &lt;subfunc_impl&gt; | &lt;subproc_impl&gt; &lt;external body reference&gt; ::= EXTERNAL NAME &lt;extname&gt; ENGINE &lt;engine&gt; [AS &lt;extbody&gt;] &lt;extname&gt; ::= '&lt;module name&gt;!&lt;routine name&gt;[!&lt;misc info&gt;]'</code> </pre> </div></div><br><p> 对于外部过程和函数，程序包名称，输入参数，它们的类型，默认值和输出参数在程序包头中指示，并且程序包主体中的所有内容都相同，除了默认值以及外部模块中的位置（EXTERNAL NAME子句） ，引擎名称，以及过程/功能的“主体”。 </p><br><p> 假设您编写了一个用于正则表达式的UDR，它位于PCRE的外部模块（动态库）中，并且您还有多个执行其他任务的UDR。 如果我们没有使用PSQL包，那么我们所有的外部过程和函数将相互混合，并且与普通的PSQL过程和函数混合在一起。 这使对依赖关系的搜索和对外部模块的更改变得很复杂，此外，还造成了混乱，并至少迫使使用前缀对过程和函数进行分组。  PSQL软件包使我们更容易完成此任务。 </p><br><div class="spoiler">  <b class="spoiler_title">RegExp软件包</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> TERM ^; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PACKAGE</span></span> REGEXP <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> preg_match( APattern <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">8192</span></span>), ASubject <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">8192</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> (Matches <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">8192</span></span>)); FUNCTION preg_is_match( APattern VARCHAR(8192), ASubject VARCHAR(8192)) RETURNS BOOLEAN; FUNCTION preg_replace( APattern VARCHAR(8192), AReplacement VARCHAR(8192), ASubject VARCHAR(8192)) RETURNS VARCHAR(8192); PROCEDURE preg_split( APattern VARCHAR(8192), ASubject VARCHAR(8192)) RETURNS (Lines VARCHAR(8192)); FUNCTION preg_quote( AStr VARCHAR(8192), ADelimiter CHAR(10) DEFAULT NULL) RETURNS VARCHAR(8192); <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>^ RECREATE <span class="hljs-keyword"><span class="hljs-keyword">PACKAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span> REGEXP <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> preg_match( APattern <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">8192</span></span>), ASubject <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">8192</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> (Matches <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">8192</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">EXTERNAL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-string"><span class="hljs-string">'PCRE!preg_match'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENGINE</span></span> UDR; FUNCTION preg_is_match( APattern VARCHAR(8192), ASubject VARCHAR(8192)) RETURNS BOOLEAN AS <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RETURN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> preg_match(:APattern, :ASubject)); <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> preg_replace( APattern <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">8192</span></span>), AReplacement <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">8192</span></span>), ASubject <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">8192</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">8192</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">EXTERNAL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-string"><span class="hljs-string">'PCRE!preg_replace'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENGINE</span></span> UDR; PROCEDURE preg_split( APattern VARCHAR(8192), ASubject VARCHAR(8192)) RETURNS (Lines VARCHAR(8192)) EXTERNAL NAME 'PCRE!preg_split' ENGINE UDR; FUNCTION preg_quote( AStr VARCHAR(8192), ADelimiter CHAR(10)) RETURNS VARCHAR(8192) EXTERNAL NAME 'PCRE!preg_quote' ENGINE UDR; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>^ <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> TERM ;^</code> </pre> </div></div><br><h3 id="vneshnie-triggery"> 外部触发 </h3><br><div class="spoiler">  <b class="spoiler_title">句法</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">{CREATE [OR ALTER] | RECREATE} TRIGGER trigname {&lt;relation_trigger_legacy&gt; | &lt;relation_trigger_sql2003&gt; | &lt;database_trigger&gt; | &lt;ddl_trigger&gt; } &lt;external-body&gt; &lt;external-body&gt; ::= EXTERNAL NAME &lt;extname&gt; ENGINE &lt;engine&gt; [AS &lt;extbody&gt;] &lt;relation_trigger_legacy&gt; ::= FOR {tablename | viewname} [ACTIVE | INACTIVE] {BEFORE | AFTER} &lt;mutation_list&gt; [POSITION number] &lt;relation_trigger_sql2003&gt; ::= [ACTIVE | INACTIVE] {BEFORE | AFTER} &lt;mutation_list&gt; [POSITION number] ON {tablename | viewname} &lt;database_trigger&gt; ::= [ACTIVE | INACTIVE] ON db_event [POSITION number] &lt;ddl_trigger&gt; ::= [ACTIVE | INACTIVE] {BEFORE | AFTER} &lt;ddl_events&gt; [POSITION number] &lt;mutation_list&gt; ::= &lt;mutation&gt; [OR &lt;mutation&gt; [OR &lt;mutation&gt;]] &lt;mutation&gt; ::= INSERT | UPDATE | DELETE &lt;db_event&gt; ::= CONNECT | DISCONNECT | TRANSACTION START | TRANSACTION COMMIT | TRANSACTION ROLLBACK &lt;ddl_events&gt; ::= ANY DDL STATEMENT | &lt;ddl_event_item&gt; [{OR &lt;ddl_event_item&gt;} ...] &lt;ddl_event_item&gt; ::= CREATE TABLE | ALTER TABLE | DROP TABLE | CREATE PROCEDURE | ALTER PROCEDURE | DROP PROCEDURE | CREATE FUNCTION | ALTER FUNCTION | DROP FUNCTION | CREATE TRIGGER | ALTER TRIGGER | DROP TRIGGER | CREATE EXCEPTION | ALTER EXCEPTION | DROP EXCEPTION | CREATE VIEW | ALTER VIEW | DROP VIEW | CREATE DOMAIN | ALTER DOMAIN | DROP DOMAIN | CREATE ROLE | ALTER ROLE | DROP ROLE | CREATE SEQUENCE | ALTER SEQUENCE | DROP SEQUENCE | CREATE USER | ALTER USER | DROP USER | CREATE INDEX | ALTER INDEX | DROP INDEX | CREATE COLLATION | DROP COLLATION | ALTER CHARACTER SET | CREATE PACKAGE | ALTER PACKAGE | DROP PACKAGE | CREATE PACKAGE BODY | DROP PACKAGE BODY | CREATE MAPPING | ALTER MAPPING | DROP MAPPING</code> </pre> <br><p> 可以使用ALTER TRIGGER语句更改外部触发器。 </p><br><p>  <strong>语法：</strong> </p><br><pre> <code class="plaintext hljs">ALTER TRIGGER trigname { [ACTIVE | INACTIVE] [ {BEFORE | AFTER} {&lt;mutation_list&gt; | &lt;ddl_events&gt;} | ON db_event ] [POSITION number] [&lt;external-body&gt;] &lt;external-body&gt; ::= EXTERNAL NAME &lt;extname&gt; ENGINE &lt;engine&gt; [AS &lt;extbody&gt;] &lt;extname&gt; ::= '&lt;module name&gt;!&lt;routine name&gt;[!&lt;misc info&gt;]' &lt;mutation_list&gt; ::= &lt;mutation&gt; [OR &lt;mutation&gt; [OR &lt;mutation&gt;]] &lt;mutation&gt; ::= { INSERT | UPDATE | DELETE }</code> </pre> </div></div><br><p> 您可以使用DROP TRIGGER语句删除外部触发器。 </p><br><p>  <strong>语法：</strong> </p><br><pre> <code class="plaintext hljs">DROP TRIGGER trigname</code> </pre> <br><div class="scrollable-table"><table><thead><tr><th> 参量 </th><th> 内容描述 </th></tr></thead><tbody><tr><td> 三角名 </td><td> 触发器的名称。 最多可以包含31个字节。 </td></tr><tr><td>  related_trigger_legacy </td><td> 表触发器声明（继承）。 </td></tr><tr><td>  lation_trigger_sql2003 </td><td> 根据SQL-2003标准声明表触发器。 </td></tr><tr><td>  database_trigger </td><td> 数据库触发器声明。 </td></tr><tr><td>  ddl_trigger </td><td>  DDL触发器声明。 </td></tr><tr><td> 表名 </td><td> 表的名称。 </td></tr><tr><td> 视图名 </td><td> 视图的名称。 </td></tr><tr><td> 变异清单 </td><td> 表事件列表。 </td></tr><tr><td> 变异 </td><td> 表中的事件之一。 </td></tr><tr><td>  db_event </td><td> 连接或事务事件。 </td></tr><tr><td>  ddl_events </td><td> 元数据更改事件列表。 </td></tr><tr><td>  ddl_event_item </td><td> 元数据更改事件之一。 </td></tr><tr><td> 数 </td><td> 触发顺序。  0至32767 </td></tr><tr><td> 外部体 </td><td> 外部触发器的主体。  UDR可以将其用于各种目的的字符串文字。 </td></tr><tr><td> 模块名称 </td><td> 触发器所在的外部模块的名称。 </td></tr><tr><td> 常规名称 </td><td> 外部模块内部触发器的内部名称。 </td></tr><tr><td> 杂项信息 </td><td> 用户定义的信息，用于传输到外部模块的触发器。 </td></tr><tr><td> 引擎 </td><td> 使用外部触发器的引擎的名称。 通常名称是UDR。 </td></tr></tbody></table></div><br><p> 这是带有解释的声明外部触发器的示例。 </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">database</span></span> <span class="hljs-string"><span class="hljs-string">'c:\temp\slave.fdb'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> persons ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">60</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>, address <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">60</span></span>), info <span class="hljs-built_in"><span class="hljs-built_in">blob</span></span> sub_type <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">database</span></span> <span class="hljs-string"><span class="hljs-string">'c:\temp\master.fdb'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> persons ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">60</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>, address <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">60</span></span>), info <span class="hljs-built_in"><span class="hljs-built_in">blob</span></span> sub_type <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> replicate_config ( <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">31</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>, data_source <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> replicate_config (<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, data_source) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'ds1'</span></span>, <span class="hljs-string"><span class="hljs-string">'c:\temp\slave.fdb'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">trigger</span></span> persons_replicate <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> persons <span class="hljs-keyword"><span class="hljs-keyword">external</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-string"><span class="hljs-string">'udrcpp_example!replicate!ds1'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">engine</span></span> udr;</code> </pre> <br><p> 触发器实现在udrcpp_example模块中。 在此模块内，触发器以复写名称注册。 外部触发器使用UDR引擎。 </p><br><p> 在到外部模块的链接中，使用了一个附加参数<code>ds1</code> ，通过该参数，可以从外部触发器的<em>copy_config</em>表中读取用于读取外部数据库的配置。 </p><br><h2 id="struktura-udr">  UDR结构 </h2><br><p> 现在是时候编写第一个UDR了。 我们将在Pascal中描述UDR的结构。 为了说明构建UDR的最小结构，我们将使用来自<code>examples/udr/</code>转换为Pascal的标准示例。 </p><br><p> 为新的动态库创建一个新项目，我们将其称为MyUdr。 因此，您应该获得文件<code>MyUdr.dpr</code> （如果在Delphi中创建了项目）或文件<code>MyUdr.lpr</code> （如果在Lazarus中创建了项目）。 现在，让我们更改主项目文件，使其看起来像这样： </p><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">library</span></span> MyUdr; <span class="hljs-meta"><span class="hljs-meta">{$IFDEF FPC}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$MODE DELPHI}</span></span><span class="hljs-meta"><span class="hljs-meta">{$H+}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> <span class="hljs-meta"><span class="hljs-meta">{$IFDEF unix}</span></span> cthreads, <span class="hljs-comment"><span class="hljs-comment">// the c memory manager is on some systems much faster for multi-threading cmem, {$ENDIF} UdrInit in 'UdrInit.pas', SumArgsFunc in 'SumArgsFunc.pas'; exports firebird_udr_plugin; end.</span></span></code> </pre> <br><p> 在这种情况下，您仅需要导出一个<code>firebird_udr_plugin</code>函数，该函数是外部UDR模块的插件的入口点。 该功能的实现将位于UdrInit模块中。 </p><br><blockquote>  <strong>备注</strong> <br><br> 如果要在Free Pascal中开发UDR，则将需要其他指令。 必须启用<code>{$mode objfpc}</code>才能启用对象Pascal模式。 相反，可以使用<code>{$mode delphi}</code>指令来确保与Delphi的兼容性。 由于我的示例应该可以在FPC和Delphi中成功编译，因此我选择<code>{$mode delphi}</code> 。 <br><br> 指令<code>{$H+}</code>包括对长字符串的支持。 如果您将使用字符串类型，ansistring类型，而不仅仅是以N结尾的字符串PChar，PAnsiChar，PWideChar，则这是必需的。 <br><br> 另外，我们将需要连接单独的模块以支持Linux和其他类似Unix的操作系统上的多线程。 </blockquote><br><h3 id="registraciya-procedur-funkciy-ili-triggerov"> 注册过程，函数或触发器 </h3><br><p> 现在添加UdrInit模块，它应该如下所示： </p><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> UdrInit; <span class="hljs-meta"><span class="hljs-meta">{$IFDEF FPC}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$MODE DELPHI}</span></span><span class="hljs-meta"><span class="hljs-meta">{$H+}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Firebird; <span class="hljs-comment"><span class="hljs-comment">//    External Engine  UDR function firebird_udr_plugin(AStatus: IStatus; AUnloadFlagLocal: BooleanPtr; AUdrPlugin: IUdrPlugin): BooleanPtr; cdecl; implementation uses SumArgsFunc; var myUnloadFlag: Boolean; theirUnloadFlag: BooleanPtr; function firebird_udr_plugin(AStatus: IStatus; AUnloadFlagLocal: BooleanPtr; AUdrPlugin: IUdrPlugin): BooleanPtr; cdecl; begin //    AUdrPlugin.registerFunction(AStatus, 'sum_args', TSumArgsFunctionFactory.Create()); //    //AUdrPlugin.registerProcedure(AStatus, 'sum_args_proc', // TSumArgsProcedureFactory.Create()); //AUdrPlugin.registerProcedure(AStatus, 'gen_rows', TGenRowsFactory.Create()); //    //AUdrPlugin.registerTrigger(AStatus, 'test_trigger', // TMyTriggerFactory.Create()); theirUnloadFlag := AUnloadFlagLocal; Result := @myUnloadFlag; end; initialization myUnloadFlag := false; finalization if ((theirUnloadFlag &lt;&gt; nil) and not myUnloadFlag) then theirUnloadFlag^ := true; end.</span></span></code> </pre> <br><p> 在<code>firebird_udr_plugin</code>函数中， <code>firebird_udr_plugin</code>必要注册我们的外部过程，函数和触发器的工厂。 对于每个功能，过程或触发器，必须编写自己的工厂。 这是使用IUdrPlugin接口方法完成的： </p><br><ul><li> registerFunction —   ; </li><li> registerProcedure —   ; </li><li> registerTrigger —   . </li></ul><br><p>         ,      (  ).       //  SQL.         (  ). </p><br><h3 id="realizaciya-vneshney-funkcii">    </h3><br><p>       .      SumArgsFunc.         . </p><br><div class="spoiler"> <b class="spoiler_title">   SumArgsFunc</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> SumArgsFunc; <span class="hljs-meta"><span class="hljs-meta">{$IFDEF FPC}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$MODE DELPHI}</span></span><span class="hljs-meta"><span class="hljs-meta">{$H+}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Firebird; <span class="hljs-comment"><span class="hljs-comment">// ********************************************************* // create function sum_args ( // n1 integer, // n2 integer, // n3 integer // ) returns integer // external name 'myudr!sum_args' // engine udr; // ********************************************************* type //        TSumArgsInMsg = record n1: Integer; n1Null: WordBool; n2: Integer; n2Null: WordBool; n3: Integer; n3Null: WordBool; end; PSumArgsInMsg = ^TSumArgsInMsg; //        TSumArgsOutMsg = record result: Integer; resultNull: WordBool; end; PSumArgsOutMsg = ^TSumArgsOutMsg; //       TSumArgsFunction TSumArgsFunctionFactory = class(IUdrFunctionFactoryImpl) //     procedure dispose(); override; {          .        . @param(AStatus  ) @param(AContext    ) @param(AMetadata   ) @param(AInBuilder     ) @param(AOutBuilder     ) } procedure setup(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder: IMetadataBuilder; AOutBuilder: IMetadataBuilder); override; {      TSumArgsFunction @param(AStatus  ) @param(AContext    ) @param(AMetadata   ) @returns(  ) } function newItem(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalFunction; override; end; //   TSumArgsFunction. TSumArgsFunction = class(IExternalFunctionImpl) //      procedure dispose(); override; {      execute             .        ,   ExternalEngine::getCharSet. @param(AStatus  ) @param(AContext    ) @param(AName   ) @param(AName    ) } procedure getCharSet(AStatus: IStatus; AContext: IExternalContext; AName: PAnsiChar; ANameSize: Cardinal); override; {    @param(AStatus  ) @param(AContext    ) @param(AInMsg    ) @param(AOutMsg    ) } procedure execute(AStatus: IStatus; AContext: IExternalContext; AInMsg: Pointer; AOutMsg: Pointer); override; end; implementation { TSumArgsFunctionFactory } procedure TSumArgsFunctionFactory.dispose; begin Destroy; end; function TSumArgsFunctionFactory.newItem(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalFunction; begin Result := TSumArgsFunction.Create(); end; procedure TSumArgsFunctionFactory.setup(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder, AOutBuilder: IMetadataBuilder); begin end; { TSumArgsFunction } procedure TSumArgsFunction.dispose; begin Destroy; end; procedure TSumArgsFunction.execute(AStatus: IStatus; AContext: IExternalContext; AInMsg, AOutMsg: Pointer); var xInput: PSumArgsInMsg; xOutput: PSumArgsOutMsg; begin //         xInput := PSumArgsInMsg(AInMsg); xOutput := PSumArgsOutMsg(AOutMsg); //     NULL    NULL xOutput^.resultNull := xInput^.n1Null or xInput^.n2Null or xInput^.n3Null; xOutput^.result := xInput^.n1 + xInput^.n2 + xInput^.n3; end; procedure TSumArgsFunction.getCharSet(AStatus: IStatus; AContext: IExternalContext; AName: PAnsiChar; ANameSize: Cardinal); begin end; end.</span></span></code> </pre> </div></div><br><p>       IUdrFunctionFactory.      IUdrFunctionFactoryImpl.       . ,         ,        .       . </p><br><p>  dispose    ,        .      . </p><br><p>  setup          .            ,        .      . </p><br><p>  newItem      .        ,       .   IRoutineMetadata        ,      .                 PSQL.           .          <code>TSumArgsFunction</code> . </p><br><p>      IExternalFunction.      <code>IExternalFunctionImpl</code> . </p><br><p>  dispose     ,        .      . </p><br><p>      . </p><br><p>  getCharSet   ,             .       ,               . </p><br><p>  execute     .        ,     ,      . </p><br><p>             .             ,        ,      BLOB.     BLOB,          . </p><br><p>       ,            .         ,      .   ,          ,    ,      NULL ( Null ).          ,             ,       IMessageMetadata.        ,         execute. </p><br><p>         . 对于 <br>    Null     Null  <br>    ,         NULL,   <br>       </p><br><h3 id="realizaciya-vneshney-procedury">    </h3><br><p>      UDR   .       :         .     , ..           EXECUTE PROCEDURE       . </p><br><p>    UdrInit    <code>firebird_udr_plugin</code>      . </p><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">firebird_udr_plugin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AUnloadFlagLocal: BooleanPtr; AUdrPlugin: IUdrPlugin)</span></span></span><span class="hljs-function">:</span></span> BooleanPtr; <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//    AUdrPlugin.registerFunction(AStatus, 'sum_args', TSumArgsFunctionFactory.Create()); //    AUdrPlugin.registerProcedure(AStatus, 'sum_args_proc', TSumArgsProcedureFactory.Create()); //AUdrPlugin.registerProcedure(AStatus, 'gen_rows', TGenRowsFactory.Create()); //    //AUdrPlugin.registerTrigger(AStatus, 'test_trigger', // TMyTriggerFactory.Create()); theirUnloadFlag := AUnloadFlagLocal; Result := @myUnloadFlag; end;</span></span></code> </pre> <br><blockquote>  <strong>备注</strong> <br><br>      uses  SumArgsProc,       . </blockquote><p>       IUdrProcedureFactory.      IUdrProcedureFactoryImpl.       . ,         ,        .       . </p><br><p>  dispose    ,        .      . </p><br><p>  setup          .            ,        .      . </p><br><p>  newItem      .        ,       .   IRoutineMetadata        ,      .                 PSQL.           .          <code>TSumArgsProcedure</code> . </p><br><p>          SumArgsProc. </p><br><div class="spoiler"> <b class="spoiler_title">   SumArgsProc</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> SumArgsProc; <span class="hljs-meta"><span class="hljs-meta">{$IFDEF FPC}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$MODE DELPHI}</span></span><span class="hljs-meta"><span class="hljs-meta">{$H+}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Firebird; <span class="hljs-comment"><span class="hljs-comment">{ ********************************************************** create procedure sp_sum_args ( n1 integer, n2 integer, n3 integer ) returns (result integer) external name 'myudr!sum_args_proc' engine udr; ********************************************************* }</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-comment"><span class="hljs-comment">//        TSumArgsInMsg = record n1: Integer; n1Null: WordBool; n2: Integer; n2Null: WordBool; n3: Integer; n3Null: WordBool; end; PSumArgsInMsg = ^TSumArgsInMsg; //        TSumArgsOutMsg = record result: Integer; resultNull: WordBool; end; PSumArgsOutMsg = ^TSumArgsOutMsg; //       TSumArgsProcedure TSumArgsProcedureFactory = class(IUdrProcedureFactoryImpl) //     procedure dispose(); override; {                  . @param(AStatus  ) @param(AContext    ) @param(AMetadata   ) @param(AInBuilder     ) @param(AOutBuilder     ) } procedure setup(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder: IMetadataBuilder; AOutBuilder: IMetadataBuilder); override; {      TSumArgsProcedure @param(AStatus  ) @param(AContext    ) @param(AMetadata   ) @returns(  ) } function newItem(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalProcedure; override; end; TSumArgsProcedure = class(IExternalProcedureImpl) public //      procedure dispose(); override; {      open             .        ,   ExternalEngine::getCharSet. @param(AStatus  ) @param(AContext    ) @param(AName   ) @param(AName    ) } procedure getCharSet(AStatus: IStatus; AContext: IExternalContext; AName: PAnsiChar; ANameSize: Cardinal); override; {    @param(AStatus  ) @param(AContext    ) @param(AInMsg    ) @param(AOutMsg    ) @returns(      nil   ) } function open(AStatus: IStatus; AContext: IExternalContext; AInMsg: Pointer; AOutMsg: Pointer): IExternalResultSet; override; end; implementation { TSumArgsProcedureFactory } procedure TSumArgsProcedureFactory.dispose; begin Destroy; end; function TSumArgsProcedureFactory.newItem(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalProcedure; begin Result := TSumArgsProcedure.create; end; procedure TSumArgsProcedureFactory.setup(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder, AOutBuilder: IMetadataBuilder); begin end; { TSumArgsProcedure } procedure TSumArgsProcedure.dispose; begin Destroy; end; procedure TSumArgsProcedure.getCharSet(AStatus: IStatus; AContext: IExternalContext; AName: PAnsiChar; ANameSize: Cardinal); begin end; function TSumArgsProcedure.open(AStatus: IStatus; AContext: IExternalContext; AInMsg, AOutMsg: Pointer): IExternalResultSet; var xInput: PSumArgsInMsg; xOutput: PSumArgsOutMsg; begin Result := nil; //         xInput := PSumArgsInMsg(AInMsg); xOutput := PSumArgsOutMsg(AOutMsg); //     NULL    NULL xOutput^.resultNull := xInput^.n1Null or xInput^.n2Null or xInput^.n3Null; xOutput^.result := xInput^.n1 + xInput^.n2 + xInput^.n3; end; end.</span></span></code> </pre> </div></div><br><p>      IExternalProcedure.      <code>IExternalProcedureImpl</code> . </p><br><p>  dispose     ,        .      . </p><br><p>  getCharSet                .       ,               . </p><br><p>  open     .        ,     ,      .     ,      nil,           .          .      TSumArgsFunction.execute. </p><br><h3 id="hranimaya-procedura-vybora">    </h3><br><p>     UDR    .      <code>firebird_udr_plugin</code> . </p><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">firebird_udr_plugin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AUnloadFlagLocal: BooleanPtr; AUdrPlugin: IUdrPlugin)</span></span></span><span class="hljs-function">:</span></span> BooleanPtr; <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//    AUdrPlugin.registerFunction(AStatus, 'sum_args', TSumArgsFunctionFactory.Create()); //    AUdrPlugin.registerProcedure(AStatus, 'sum_args_proc', TSumArgsProcedureFactory.Create()); AUdrPlugin.registerProcedure(AStatus, 'gen_rows', TGenRowsFactory.Create()); //    //AUdrPlugin.registerTrigger(AStatus, 'test_trigger', // TMyTriggerFactory.Create()); theirUnloadFlag := AUnloadFlagLocal; Result := @myUnloadFlag; end;</span></span></code> </pre> <br><blockquote>  <strong>备注</strong> <br><br>      uses  GenRowsProc,       . </blockquote><p>           .     ,    open,    . </p><br><div class="spoiler"> <b class="spoiler_title">   GenRowsProc</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> GenRowsProc; <span class="hljs-meta"><span class="hljs-meta">{$IFDEF FPC}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$MODE DELPHI}</span></span><span class="hljs-meta"><span class="hljs-meta">{$H+}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Firebird, SysUtils; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-comment"><span class="hljs-comment">{ ********************************************************** create procedure gen_rows ( start integer, finish integer ) returns (n integer) external name 'myudr!gen_rows' engine udr; ********************************************************* }</span></span> TInput = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> start: Integer; startNull: WordBool; finish: Integer; finishNull: WordBool; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; PInput = ^TInput; TOutput = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> n: Integer; nNull: WordBool; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; POutput = ^TOutput; <span class="hljs-comment"><span class="hljs-comment">//       TGenRowsProcedure TGenRowsFactory = class(IUdrProcedureFactoryImpl) //     procedure dispose(); override; {          .        . @param(AStatus  ) @param(AContext    ) @param(AMetadata   ) @param(AInBuilder     ) @param(AOutBuilder     ) } procedure setup(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder: IMetadataBuilder; AOutBuilder: IMetadataBuilder); override; {      TGenRowsProcedure @param(AStatus  ) @param(AContext    ) @param(AMetadata   ) @returns(  ) } function newItem(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalProcedure; override; end; //   TGenRowsProcedure. TGenRowsProcedure = class(IExternalProcedureImpl) public //      procedure dispose(); override; {      open             .        ,   ExternalEngine::getCharSet. @param(AStatus  ) @param(AContext    ) @param(AName   ) @param(AName    ) } procedure getCharSet(AStatus: IStatus; AContext: IExternalContext; AName: PAnsiChar; ANameSize: Cardinal); override; {    @param(AStatus  ) @param(AContext    ) @param(AInMsg    ) @param(AOutMsg    ) @returns(      nil   ) } function open(AStatus: IStatus; AContext: IExternalContext; AInMsg: Pointer; AOutMsg: Pointer): IExternalResultSet; override; end; //      TGenRowsProcedure TGenRowsResultSet = class(IExternalResultSetImpl) Input: PInput; Output: POutput; //       procedure dispose(); override; {      .     SUSPEND.          . @param(AStatus  ) @returns(True        , False   ) } function fetch(AStatus: IStatus): Boolean; override; end; implementation { TGenRowsFactory } procedure TGenRowsFactory.dispose; begin Destroy; end; function TGenRowsFactory.newItem(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalProcedure; begin Result := TGenRowsProcedure.create; end; procedure TGenRowsFactory.setup(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder, AOutBuilder: IMetadataBuilder); begin end; { TGenRowsProcedure } procedure TGenRowsProcedure.dispose; begin Destroy; end; procedure TGenRowsProcedure.getCharSet(AStatus: IStatus; AContext: IExternalContext; AName: PAnsiChar; ANameSize: Cardinal); begin end; function TGenRowsProcedure.open(AStatus: IStatus; AContext: IExternalContext; AInMsg, AOutMsg: Pointer): IExternalResultSet; begin //      NULL    if PInput(AInMsg).startNull or PInput(AInMsg).finishNull then begin POutput(AOutMsg).nNull := True; Result := nil; exit; end; //  if PInput(AInMsg).start &gt; PInput(AInMsg).finish then raise Exception.Create('First parameter greater then second parameter.'); Result := TGenRowsResultSet.create; with TGenRowsResultSet(Result) do begin Input := AInMsg; Output := AOutMsg; //   Output.nNull := False; Output.n := Input.start - 1; end; end; { TGenRowsResultSet } procedure TGenRowsResultSet.dispose; begin Destroy; end; //   True       . //   False       //         //     function TGenRowsResultSet.fetch(AStatus: IStatus): Boolean; begin Inc(Output.n); Result := (Output.n &lt;= Input.finish); end; end.</span></span></code> </pre> </div></div><br><p>   open   <code>TGenRowsProcedure</code>         NULL,      NULL,      NULL,              SELECT,      nil. </p><br><p>    ,       ,     .         UDR     Firebird.      UDR  Legacy UDF. </p><br><p>     ,   open     ,    IExternalResultSet.         <code>IExternalResultSetImpl</code> . </p><br><p>  dispose     .      . </p><br><p>  fetch       SELECT.        SUSPEND    PSQL  .     ,        .   true,       ,  <code>false</code> ,      .             ,      . </p><br><blockquote>  <strong>备注</strong> <br><br>  Delphi    yeild,          <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(...) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { ... yield result; }</code> </pre> <br><br>      ,     open,  ,          fetch.            (   SELECT   FIRST/ROWS/FETCH FIRST   SELECT.) </blockquote><br><h3 id="realizaciya-vneshnego-triggera">    </h3><br><p>     UDR   . </p><br><blockquote> <strong>Note</strong> <br><br>     C++        .  ,           .          . </blockquote><p>    UdrInit    <code>firebird_udr_plugin</code>      . </p><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">firebird_udr_plugin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AUnloadFlagLocal: BooleanPtr; AUdrPlugin: IUdrPlugin)</span></span></span><span class="hljs-function">:</span></span> BooleanPtr; <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//    AUdrPlugin.registerFunction(AStatus, 'sum_args', TSumArgsFunctionFactory.Create()); //    AUdrPlugin.registerProcedure(AStatus, 'sum_args_proc', TSumArgsProcedureFactory.Create()); AUdrPlugin.registerProcedure(AStatus, 'gen_rows', TGenRowsFactory.Create()); //    AUdrPlugin.registerTrigger(AStatus, 'test_trigger', TMyTriggerFactory.Create()); theirUnloadFlag := AUnloadFlagLocal; Result := @myUnloadFlag; end;</span></span></code> </pre> <br><blockquote>  <strong>备注</strong> <br><br>      uses  TestTrigger,       . </blockquote><p>       IUdrTriggerFactory.      IUdrTriggerFactoryImpl.       <br> . </p><br><p>  dispose    ,        .      . </p><br><p>  setup          .            ,        .      . </p><br><p>  newItem      .        ,       .   IRoutineMetadata           ,      .                 PSQL.           .          <code>TMyTrigger</code> . </p><br><p>          TestTrigger. </p><br><div class="spoiler"> <b class="spoiler_title">   TestTrigger</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> TestTrigger; <span class="hljs-meta"><span class="hljs-meta">{$IFDEF FPC}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$MODE DELPHI}</span></span><span class="hljs-meta"><span class="hljs-meta">{$H+}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Firebird, SysUtils; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-comment"><span class="hljs-comment">{ ********************************************************** create table test ( id int generated by default as identity, a int, b int, name varchar(100), constraint pk_test primary key(id) ); create or alter trigger tr_test_biu for test active before insert or update position 0 external name 'myudr!test_trigger' engine udr; }</span></span> <span class="hljs-comment"><span class="hljs-comment">//     NEW.*  OLD.* //      test TFieldsMessage = record Id: Integer; IdNull: WordBool; A: Integer; ANull: WordBool; B: Integer; BNull: WordBool; Name: record Length: Word; Value: array [0 .. 399] of AnsiChar; end; NameNull: WordBool; end; PFieldsMessage = ^TFieldsMessage; //       TMyTrigger TMyTriggerFactory = class(IUdrTriggerFactoryImpl) //     procedure dispose(); override; {          .       . @param(AStatus  ) @param(AContext    ) @param(AMetadata   ) @param(AFieldsBuilder     ) } procedure setup(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AFieldsBuilder: IMetadataBuilder); override; {      TMyTrigger @param(AStatus  ) @param(AContext    ) @param(AMetadata   ) @returns(  ) } function newItem(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalTrigger; override; end; TMyTrigger = class(IExternalTriggerImpl) //     procedure dispose(); override; {      execute             .        ,   ExternalEngine::getCharSet. @param(AStatus  ) @param(AContext    ) @param(AName   ) @param(AName    ) } procedure getCharSet(AStatus: IStatus; AContext: IExternalContext; AName: PAnsiChar; ANameSize: Cardinal); override; {   TMyTrigger @param(AStatus  ) @param(AContext    ) @param(AAction  ( ) ) @param(AOldMsg      :OLD.*) @param(ANewMsg      :NEW.*) } procedure execute(AStatus: IStatus; AContext: IExternalContext; AAction: Cardinal; AOldMsg: Pointer; ANewMsg: Pointer); override; end; implementation { TMyTriggerFactory } procedure TMyTriggerFactory.dispose; begin Destroy; end; function TMyTriggerFactory.newItem(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalTrigger; begin Result := TMyTrigger.create; end; procedure TMyTriggerFactory.setup(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AFieldsBuilder: IMetadataBuilder); begin end; { TMyTrigger } procedure TMyTrigger.dispose; begin Destroy; end; procedure TMyTrigger.execute(AStatus: IStatus; AContext: IExternalContext; AAction: Cardinal; AOldMsg, ANewMsg: Pointer); var xOld, xNew: PFieldsMessage; begin // xOld := PFieldsMessage(AOldMsg); xNew := PFieldsMessage(ANewMsg); case AAction of IExternalTrigger.ACTION_INSERT: begin if xNew.BNull and not xNew.ANull then begin xNew.B := xNew.A + 1; xNew.BNull := False; end; end; IExternalTrigger.ACTION_UPDATE: begin if xNew.BNull and not xNew.ANull then begin xNew.B := xNew.A + 1; xNew.BNull := False; end; end; IExternalTrigger.ACTION_DELETE: begin end; end; end; procedure TMyTrigger.getCharSet(AStatus: IStatus; AContext: IExternalContext; AName: PAnsiChar; ANameSize: Cardinal); begin end; end.</span></span></code> </pre> </div></div><br><p>      IExternalTrigger.      <code>IExternalTriggerImpl</code> . </p><br><p>  dispose     ,        .      . </p><br><p>  getCharSet                .       ,           . </p><br><p>  execute            .        ,     ,  ()              .   ()      IExternalTrigger.      <code>ACTION_</code> .     ,   Firebird       .        ,  DDL ,      ,         ,           nil.                 .          ,          ,      . </p><br><blockquote>  <strong>备注</strong> <br><br>  ,        ,             .             IMessageMetadata.        ,          .       ,      ,      /. </blockquote><p>        ,       PSQL  </p><br><pre> <code class="sql hljs"> if (:new.B IS NULL) THEN :new.B = :new.A + 1;</code> </pre> <br><h2 id="soobscheniya">  </h2><br><p>    UDR             ,    .                NEW  OLD. </p><br><p>        ,       ,      . <br>         : </p><br><ul><li><p>           ( Delphi  , .. record); </p><br></li><li><p>         IMessageMetadata,  /   ,      . </p><br></li></ul><br><p>     ,  —  ,                        UDR. </p><br><h3 id="rabota-s-buferom-soobscheniya-s-ispolzovaniem-struktury">        </h3><br><p>             .     : </p><br><pre> <code class="plaintext hljs">TMyStruct = record &lt;var_1&gt;: &lt;type_1&gt;; &lt;nullIndicator_1&gt;: WordBool; &lt;var_2&gt;: &lt;type_1&gt;; &lt;nullIndicator_2&gt;: WordBool; ... &lt;var_N&gt;: &lt;type_1&gt;; &lt;nullIndicator_N&gt;: WordBool; end; PMyStruct = ^TMyStruct;</code> </pre> <br><p>       /    ( ). Null-     /,       NOT NULL. Null-  2 .  -1   <br> /   NULL.      NULL-    NULL,      2-   .   SQL     : </p><br><div class="scrollable-table"><table><tbody><tr><th> SQL  </th><th> Delphi  </th><th>  </th></tr><tr><td> BOOLEAN </td><td> Boolean, ByteBool </td><td></td></tr><tr><td> SMALLINT </td><td> Smallint </td><td></td></tr><tr><td> INTEGER </td><td> Integer </td><td></td></tr><tr><td> BIGINT </td><td> Int64 </td><td></td></tr><tr><td> FLOAT </td><td> Single </td><td></td></tr><tr><td> DOUBLE PRECISION </td><td> Double </td><td></td></tr><tr><td> NUMERIC(N, M) </td><td>       : <br><ul><li> 1-4 — Smallint; </li><li> 5-9 — Integer; </li><li> 10-18 (3 ) — Int64; </li><li> 10-15 (1 ) — Double. </li></ul><br></td><td>           <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>10</mn><mi>M</mi></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.284ex" height="2.419ex" viewBox="0 -935.7 1844.5 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMAIN-30" x="500" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMATHI-4D" x="1415" y="557"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>10</mn><mi>M</mi></msup></math></span></span><script type="math/tex" id="MathJax-Element-1">10^M</script>  。 </td></tr><tr><td> DECIMAL(N, M) </td><td>       : <br><ul><li> 1-4 — Integer; </li><li> 5-9 — Integer; </li><li> 10-18 (3 ) — Int64; </li><li> 10-15 (1 ) — Double. </li></ul><br></td><td>           <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>10</mn><mi>M</mi></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.284ex" height="2.419ex" viewBox="0 -935.7 1844.5 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMAIN-30" x="500" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMATHI-4D" x="1415" y="557"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>10</mn><mi>M</mi></msup></math></span></span><script type="math/tex" id="MathJax-Element-2">10^M</script>  。 </td></tr><tr><td> CHAR(N) </td><td> array[0… M] of AnsiChar </td><td> M    <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>M</mi><mo>=</mo><mi>N</mi><mo>&amp;#x2217;</mo><mi>B</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi>P</mi><mi>e</mi><mi>r</mi><mi>C</mi><mi>h</mi><mi>a</mi><mi>r</mi><mo>&amp;#x2212;</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="28.996ex" height="2.419ex" viewBox="0 -780.1 12484.4 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMATHI-4D" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMAIN-3D" x="1329" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMATHI-4E" x="2385" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMAIN-2217" x="3496" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMATHI-42" x="4219" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMATHI-79" x="4978" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMATHI-74" x="5476" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMATHI-65" x="5837" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMATHI-73" x="6304" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMATHI-50" x="6773" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMATHI-65" x="7525" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMATHI-72" x="7991" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMATHI-43" x="8443" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMATHI-68" x="9203" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMATHI-61" x="9780" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMATHI-72" x="10309" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMAIN-2212" x="10983" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMAIN-31" x="11983" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>M</mi><mo>=</mo><mi>N</mi><mo>∗</mo><mi>B</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi>P</mi><mi>e</mi><mi>r</mi><mi>C</mi><mi>h</mi><mi>a</mi><mi>r</mi><mo>−</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-3">M = N * BytesPerChar - 1</script>  ， <br>  BytesPerChar —    ,    /.   UTF-8 —  4 /,  WIN1251 — 1 /. </td></tr><tr><td> VARCHAR(N) </td><td> FbVarChar&lt;N&gt; </td><td> M    <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>M</mi><mo>=</mo><mi>N</mi><mo>&amp;#x2217;</mo><mi>B</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi>P</mi><mi>e</mi><mi>r</mi><mi>C</mi><mi>h</mi><mi>a</mi><mi>r</mi><mo>&amp;#x2212;</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="28.996ex" height="2.419ex" viewBox="0 -780.1 12484.4 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMATHI-4D" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMAIN-3D" x="1329" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMATHI-4E" x="2385" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMAIN-2217" x="3496" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMATHI-42" x="4219" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMATHI-79" x="4978" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMATHI-74" x="5476" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMATHI-65" x="5837" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMATHI-73" x="6304" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMATHI-50" x="6773" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMATHI-65" x="7525" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMATHI-72" x="7991" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMATHI-43" x="8443" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMATHI-68" x="9203" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMATHI-61" x="9780" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMATHI-72" x="10309" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMAIN-2212" x="10983" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhiTYFpFk6nbtYAQZwT2p08bNWnilA#MJMAIN-31" x="11983" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>M</mi><mo>=</mo><mi>N</mi><mo>∗</mo><mi>B</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi>P</mi><mi>e</mi><mi>r</mi><mi>C</mi><mi>h</mi><mi>a</mi><mi>r</mi><mo>−</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-4">M = N * BytesPerChar - 1</script>  ， <br>  BytesPerChar —    ,    /.   UTF-8 —  4 /,  WIN1251 — 1 /.  Length      .  Delphi        C++, <br>     FbVarChar&lt;N&gt; ,  <br>        .   . </td></tr><tr><td> DATE </td><td> ISC_DATE </td><td></td></tr><tr><td> TIME </td><td> ISC_TIME </td><td></td></tr><tr><td> TIMESTAMP </td><td> ISC_TIMESTAMP </td><td>  ISC_TIMESTAMP    Firebird.pas,     .      . </td></tr><tr><td> BLOB </td><td> ISC_QUAD </td><td>  BLOB    ,    BlobId.     BLOB   . </td></tr></tbody></table></div><br><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">//      VARCHAR(N) // M = N * BytesPerChar - 1 record Length: Smallint; Data: array[0 .. M] of AnsiChar; end; //      TIMESTAMP ISC_TIMESTAMP = record date: ISC_DATE; time: ISC_TIME; end;</span></span></code> </pre> <br><p>         <br>    ,   . </p><br><p>         : </p><br><pre> <code class="plaintext hljs">function SUM_ARGS(A SMALLINT, B INTEGER) RETURNS BIGINT ....</code> </pre> <br><p>            <br> : </p><br><pre> <code class="plaintext hljs">TInput = record A: Smallint; ANull: WordBool; B: Integer; BNull: WordBool; end; PInput = ^TInput; TOutput = record Value: Int64; Null: WordBool; end; POutput = ^TOutput;</code> </pre> <br><p>          ( 3 ): </p><br><pre> <code class="sql hljs">function SUM_ARGS(A NUMERIC(4, 2), B NUMERIC(9, 3)) RETURNS NUMERIC(18, 6) ....</code> </pre> <br><p>            <br> : </p><br><pre> <code class="delphi hljs">TInput = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> A: Smallint; ANull: WordBool; B: Integer; BNull: WordBool; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; PInput = ^TInput; TOutput = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> Value: Int64; Null: WordBool; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; POutput = ^TOutput;</code> </pre> <br><p>         : </p><br><pre> <code class="sql hljs">procedure SOME_PROC(A CHAR(3) CHARACTER <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> WIN1251, B <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">CHARACTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> UTF8) ....</code> </pre> <br><p>          : </p><br><pre> <code class="delphi hljs">TInput = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> A: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> AnsiChar; ANull: WordBool; B: <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> Length: Smallint; Value: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">39</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> AnsiChar; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; BNull: WordBool; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; PInput = ^TInput;</code> </pre> <br><h3 id="rabota-s-buferom-soobscheniy-s-pomoschyu-imessagemetadata">       IMessageMetadata </h3><br><p>           <br>      <br> IMessageMetadata.      / <br>  : </p><br><ul><li>  /; </li><li>  ; </li><li>     ; </li><li>     BLOB; </li><li>      /; </li><li>   /   NULL; </li><li>      ; </li><li>      NULL-. </li></ul><br><h4 id="metody-interfeysa-imessagemetadata">   IMessageMetadata </h4><br><ol><li><p> getCount </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StatusType* status)</span></span></span></span></code> </pre> <br><p>   /  .   ,   ,    : 0 &lt;= index &lt; getCount(). </p><br></li><li><p> getField </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StatusType* status, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span></span></code> </pre> <br><p>   . </p><br></li><li><p> getRelation </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRelation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StatusType* status, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span></span></code> </pre> <br><p>    (    ). </p><br></li><li><p> getOwner </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOwner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StatusType* status, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span></span></code> </pre> <br><p>    . </p><br></li><li><p> getAlias </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAlias</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StatusType* status, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span></span></code> </pre> <br><p>   . </p><br></li><li><p> getType </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StatusType* status, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span></span></code> </pre> <br><p>  SQL  . </p><br></li><li><p> isNullable </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">FB_BOOLEAN </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isNullable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StatusType* status, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span></span></code> </pre> <br><p>  true,      NULL. </p><br></li><li><p> getSubType </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSubType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StatusType* status, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span></span></code> </pre> <br><p>    BLOB (0 — , 1 —   . .). </p><br></li><li><p> getLength </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StatusType* status, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span></span></code> </pre> <br><p>      . </p><br></li><li><p> getScale </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getScale</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StatusType* status, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span></span></code> </pre> <br><p>     . </p><br></li><li><p> getCharSet </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCharSet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StatusType* status, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span></span></code> </pre> <br><p>         BLOB. </p><br></li><li><p> getOffset </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOffset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StatusType* status, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span></span></code> </pre> <br><p>        (        ). </p><br></li><li><p> getNullOffset </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNullOffset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StatusType* status, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span></span></code> </pre> <br><p>   NULL      . </p><br></li><li><p> getBuilder </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">IMetadataBuilder* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBuilder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StatusType* status)</span></span></span></span></code> </pre> <br><p>   IMetadataBuilder,    . </p><br></li><li><p> getMessageLength </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMessageLength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StatusType* status)</span></span></span></span></code> </pre> <br><p>     (      ). </p><br></li></ol><br><h4 id="poluchenie-i-ispolzovanie-imessagemetadata">    IMessageMetadata </h4><br><p>     IMessageMetadata          IRoutineMetadata.       ,   .        . 例如： </p><br><div class="spoiler"> <b class="spoiler_title">   RoutineMetadata</b> <div class="spoiler_text"><pre> <code class="delphi hljs"> <span class="hljs-comment"><span class="hljs-comment">//       TSumArgsFunction TSumArgsFunctionFactory = class(IUdrFunctionFactoryImpl) //     procedure dispose(); override; {           @param(AStatus  ) @param(AContext    ) @param(AMetadata   ) @param(AInBuilder     ) @param(AOutBuilder     ) } procedure setup(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder: IMetadataBuilder; AOutBuilder: IMetadataBuilder); override; {      TSumArgsFunction @param(AStatus  ) @param(AContext    ) @param(AMetadata   ) @returns(  ) } function newItem(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalFunction; override; end; //   TSumArgsFunction. TSumArgsFunction = class(IExternalFunctionImpl) private FMetadata: IRoutineMetadata; public property Metadata: IRoutineMetadata read FMetadata write FMetadata; public //      procedure dispose(); override; {      execute             .        ,   ExternalEngine::getCharSet. @param(AStatus  ) @param(AContext    ) @param(AName   ) @param(AName    ) } procedure getCharSet(AStatus: IStatus; AContext: IExternalContext; AName: PAnsiChar; ANameSize: Cardinal); override; {    @param(AStatus  ) @param(AContext    ) @param(AInMsg    ) @param(AOutMsg    ) } procedure execute(AStatus: IStatus; AContext: IExternalContext; AInMsg: Pointer; AOutMsg: Pointer); override; end; ........................ { TSumArgsFunctionFactory } procedure TSumArgsFunctionFactory.dispose; begin Destroy; end; function TSumArgsFunctionFactory.newItem(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalFunction; begin Result := TSumArgsFunction.Create(); with Result as TSumArgsFunction do begin Metadata := AMetadata; end; end; procedure TSumArgsFunctionFactory.setup(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder, AOutBuilder: IMetadataBuilder); begin end;</span></span></code> </pre> </div></div><br><p>  IMessageMetadata           getInputMetadata  getOutputMetadata  IRoutineMetadata.    ,    ,      getTriggerMetadata. </p><br><blockquote> <strong></strong> <br><br>  ,     IMessageMetadata     .    IReferenceCounted.  getInputMetadata  getOutputMetadata     1   ,             <code>xInputMetadata</code>  <code>xOutputMetadata</code>   release. </blockquote><p>           .      IMessageMetadata    getOffset        .         .    <br>     null  ,       getNullOffset. </p><br><div class="spoiler"> <b class="spoiler_title">     IMessageMetadata</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">// ........................ procedure TSumArgsFunction.execute(AStatus: IStatus; AContext: IExternalContext; AInMsg, AOutMsg: Pointer); var n1, n2, n3: Integer; n1Null, n2Null, n3Null: WordBool; Result: Integer; resultNull: WordBool; xInputMetadata, xOutputMetadata: IMessageMetadata; begin xInputMetadata := FMetadata.getInputMetadata(AStatus); xOutputMetadata := FMetadata.getOutputMetadata(AStatus); try //        n1 := PInteger(PByte(AInMsg) + xInputMetadata.getOffset(AStatus, 0))^; n2 := PInteger(PByte(AInMsg) + xInputMetadata.getOffset(AStatus, 1))^; n3 := PInteger(PByte(AInMsg) + xInputMetadata.getOffset(AStatus, 2))^; //   null-      n1Null := PWordBool(PByte(AInMsg) + xInputMetadata.getNullOffset(AStatus, 0))^; n2Null := PWordBool(PByte(AInMsg) + xInputMetadata.getNullOffset(AStatus, 1))^; n3Null := PWordBool(PByte(AInMsg) + xInputMetadata.getNullOffset(AStatus, 2))^; //     = NULL,     nullFlag resultNull := True; Result := 0; //     NULL    NULL //       if not(n1Null or n2Null or n3Null) then begin Result := n1 + n2 + n3; //   ,   NULL  resultNull := False; end; PWordBool(PByte(AInMsg) + xOutputMetadata.getNullOffset(AStatus, 0))^ := resultNull; PInteger(PByte(AInMsg) + xOutputMetadata.getOffset(AStatus, 0))^ := Result; finally xInputMetadata.release; xOutputMetadata.release; end; end;</span></span></code> </pre> </div></div><br><h2 id="fabriki">  </h2><br><p>      .      . </p><br><p>      ,   .         IUdrProcedureFactory, IUdrFunctionFactory  IUdrTriggerFactory     UDR.          UDR   <code>firebird_udr_plugin</code> . </p><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">firebird_udr_plugin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AUnloadFlagLocal: BooleanPtr; AUdrPlugin: IUdrPlugin)</span></span></span><span class="hljs-function">:</span></span> BooleanPtr; <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//    AUdrPlugin.registerFunction(AStatus, 'sum_args', TSumArgsFunctionFactory.Create()); //    AUdrPlugin.registerProcedure(AStatus, 'gen_rows', TGenRowsFactory.Create()); //    AUdrPlugin.registerTrigger(AStatus, 'test_trigger', TMyTriggerFactory.Create()); theirUnloadFlag := AUnloadFlagLocal; Result := @myUnloadFlag; end;</span></span></code> </pre> <br><p>     <code>TSumArgsFunctionFactory</code>   IUdrFunctionFactory, <code>TGenRowsFactory</code>   IUdrProcedureFactory,  <code>TMyTriggerFactory</code>   IUdrTriggerFactory. </p><br><p>              ,   .         Firebird.  ,   SuperServer             ,  Classic   <br>      . </p><br><p>         setup  newItem   IUdrProcedureFactory, IUdrFunctionFactory  IUdrTriggerFactory. </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="delphi hljs"> <span class="hljs-title"><span class="hljs-title">IUdrFunctionFactory</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(IDisposable) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> VERSION = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata)</span></span></span><span class="hljs-function">:</span></span> IExternalFunction; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-title"><span class="hljs-title">IUdrProcedureFactory</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(IDisposable) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> VERSION = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata)</span></span></span><span class="hljs-function">:</span></span> IExternalProcedure; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-title"><span class="hljs-title">IUdrTriggerFactory</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(IDisposable) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> VERSION = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; fieldsBuilder: IMetadataBuilder)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata)</span></span></span><span class="hljs-function">:</span></span> IExternalTrigger; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> </div></div><br><p>  ,      IDisposable,       dispose.    Firebird   ,    .   dispose   ,   ,    .       <br>   <code>IUdrProcedureFactoryImpl</code> , <code>IUdrFunctionFactoryImpl</code> , <code>IUdrTriggerFactoryImpl</code> .      . </p><br><h3 id="metod-newitem">  newItem </h3><br><p>  newItem      ,   .   UDR        , ..    ,   .             . </p><br><p>            . ,      ,    ,    <code>IUdrFunctionFactory</code> .             .      . </p><br><p>   newItem     ,  <br>  UDR   UDR. </p><br><p>        </p><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSumArgsFunctionFactory</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata)</span></span></span><span class="hljs-function">:</span></span> IExternalFunction; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//     Result := TSumArgsFunction.Create(); end;</span></span></code> </pre> <br><p>   IRoutineMetadata        ,  UDR   .       UDR.         UDR      . </p><br><pre> <code class="delphi hljs"> <span class="hljs-comment"><span class="hljs-comment">//   TSumArgsFunction. TSumArgsFunction = class(IExternalFunctionImpl) private FMetadata: IRoutineMetadata; public property Metadata: IRoutineMetadata read FMetadata write FMetadata; public ... end;</span></span></code> </pre> <br><h3 id="metod-setup">  setup </h3><br><p>  setup                 .     IMetadataBuilder,          ,    .       <br>    setup,         setup      DLL ,   .         . </p><br><p>                    .        ,          SumArgs. </p><br><p>      ,     </p><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-comment"><span class="hljs-comment">//        TSumArgsInMsg = record n1: Integer; n1Null: WordBool; n2: Integer; n2Null: WordBool; n3: Integer; n3Null: WordBool; end; PSumArgsInMsg = ^TSumArgsInMsg; //        TSumArgsOutMsg = record result: Integer; resultNull: WordBool; end; PSumArgsOutMsg = ^TSumArgsOutMsg;</span></span></code> </pre> <br><p>    ,   setup    ,     . </p><br><div class="spoiler"> <b class="spoiler_title">SumArgsFunctionFactory</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{ TSumArgsFunctionFactory }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSumArgsFunctionFactory</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispose</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Destroy; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSumArgsFunctionFactory</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata)</span></span></span><span class="hljs-function">:</span></span> IExternalFunction; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := TSumArgsFunction.Create(); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSumArgsFunctionFactory</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder, AOutBuilder: IMetadataBuilder)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//      AInBuilder.setType(AStatus, 0, Cardinal(SQL_LONG) + 1); AInBuilder.setLength(AStatus, 0, sizeof(Int32)); AInBuilder.setType(AStatus, 1, Cardinal(SQL_LONG) + 1); AInBuilder.setLength(AStatus, 1, sizeof(Int32)); AInBuilder.setType(AStatus, 2, Cardinal(SQL_LONG) + 1); AInBuilder.setLength(AStatus, 2, sizeof(Int32)); //      AOutBuilder.setType(AStatus, 0, Cardinal(SQL_LONG) + 1); AOutBuilder.setLength(AStatus, 0, sizeof(Int32)); end;</span></span></code> </pre> </div></div><br><blockquote> <strong> </strong> <br><br>    SQL  Firebird .   ,     SQL       NULL.          XSQLDA. </blockquote><p>    </p><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSumArgsFunction</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AInMsg, AOutMsg: Pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xInput: PSumArgsInMsg; xOutput: PSumArgsOutMsg; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//         xInput := PSumArgsInMsg(AInMsg); xOutput := PSumArgsOutMsg(AOutMsg); //     = NULL,     nullFlag xOutput^.resultNull := True; //     NULL    NULL //       xOutput^.resultNull := xInput^.n1Null or xInput^.n2Null or xInput^.n3Null; xOutput^.result := xInput^.n1 + xInput^.n2 + xInput^.n3; end;</span></span></code> </pre> <br><p>        ,      ,          ,      setup. </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> FN_SUM_ARGS ( N1 <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">15</span></span>), N2 <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">15</span></span>), N3 <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">15</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">15</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">EXTERNAL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-string"><span class="hljs-string">'MyUdrSetup!sum_args'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENGINE</span></span> UDR;</code> </pre> <br><p>         </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> FN_SUM_ARGS(<span class="hljs-string"><span class="hljs-string">'15'</span></span>, <span class="hljs-string"><span class="hljs-string">'21'</span></span>, <span class="hljs-string"><span class="hljs-string">'35'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rdb$<span class="hljs-keyword"><span class="hljs-keyword">database</span></span></code> </pre> <br><h2 id="obobschyonnye-fabriki">   </h2><br><p>    UDR     ,          UDR.            .     Delphi 2009,  Free Pascal    FPC 2.2. </p><br><blockquote>  <strong>备注</strong> <br><br>  Free Pascal       <br> Delphi.    FPC 2.6.0    Delphi <br> . </blockquote><p>          <br> : </p><br><ul><li><p>   ,          ,         UDR,       ; </p><br></li><li><p>   ,       ,         UDR,        IMessageMetadata. </p><br></li></ul><br><p>            newItem   .          <code>IUdrFunctionFactoryImpl</code> , <code>IUdrProcedureFactoryImpl</code> , <code>IUdrTriggerFactoryImpl</code> .      : </p><br><div class="spoiler"> <b class="spoiler_title">SimpleFactories</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> UdrFactories; <span class="hljs-meta"><span class="hljs-meta">{$IFDEF FPC}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$MODE DELPHI}</span></span><span class="hljs-meta"><span class="hljs-meta">{$H+}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> SysUtils, Firebird; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-comment"><span class="hljs-comment">//     TFunctionSimpleFactory&lt;T: IExternalFunctionImpl, constructor&gt; = class (IUdrFunctionFactoryImpl) procedure dispose(); override; procedure setup(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder: IMetadataBuilder; AOutBuilder: IMetadataBuilder); override; function newItem(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalFunction; override; end; //     TProcedureSimpleFactory&lt;T: IExternalProcedureImpl, constructor&gt; = class (IUdrProcedureFactoryImpl) procedure dispose(); override; procedure setup(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder: IMetadataBuilder; AOutBuilder: IMetadataBuilder); override; function newItem(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalProcedure; override; end; //     TTriggerSimpleFactory&lt;T: IExternalTriggerImpl, constructor&gt; = class (IUdrTriggerFactoryImpl) procedure dispose(); override; procedure setup(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AFieldsBuilder: IMetadataBuilder); override; function newItem(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalTrigger; override; end;</span></span></code> </pre> </div></div><br><p>      setup   ,     ,    dispose   .     newItem          <code>T</code> . </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">implementation</span></span> <span class="hljs-comment"><span class="hljs-comment">{ TProcedureSimpleFactory&lt;T&gt; }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TProcedureSimpleFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispose</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Destroy; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TProcedureSimpleFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata)</span></span></span><span class="hljs-function">:</span></span> IExternalProcedure; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := T.Create; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TProcedureSimpleFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder, AOutBuilder: IMetadataBuilder)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-comment"><span class="hljs-comment">{ TFunctionFactory&lt;T&gt; }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFunctionSimpleFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispose</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Destroy; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFunctionSimpleFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata)</span></span></span><span class="hljs-function">:</span></span> IExternalFunction; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := T.Create; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFunctionSimpleFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder, AOutBuilder: IMetadataBuilder)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-comment"><span class="hljs-comment">{ TTriggerSimpleFactory&lt;T&gt; }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TTriggerSimpleFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispose</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Destroy; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TTriggerSimpleFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata)</span></span></span><span class="hljs-function">:</span></span> IExternalTrigger; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := T.Create; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TTriggerSimpleFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AFieldsBuilder: IMetadataBuilder)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> </div></div><br><p>    1       ,   .          : </p><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">firebird_udr_plugin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AUnloadFlagLocal: BooleanPtr; AUdrPlugin: IUdrPlugin)</span></span></span><span class="hljs-function">:</span></span> BooleanPtr; <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//    AUdrPlugin.registerFunction(AStatus, 'sum_args', TFunctionSimpleFactory&lt;TSumArgsFunction&gt;.Create()); //    AUdrPlugin.registerProcedure(AStatus, 'gen_rows', TProcedureSimpleFactory&lt;TGenRowsProcedure&gt;.Create()); //    AUdrPlugin.registerTrigger(AStatus, 'test_trigger', TTriggerSimpleFactory&lt;TMyTrigger&gt;.Create()); theirUnloadFlag := AUnloadFlagLocal; Result := @myUnloadFlag; end;</span></span></code> </pre> <br><p>    .          ,   .         <code>newItem</code> .  UDR   <code>IRoutineMetadata</code> ,       Firebird,        UDR.           ,    ,  UDR, ,    <br>  UDR.      ,         ,      . </p><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> UdrFactories; <span class="hljs-meta"><span class="hljs-meta">{$IFDEF FPC}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$MODE DELPHI}</span></span><span class="hljs-meta"><span class="hljs-meta">{$H+}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> SysUtils, Firebird; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ... <span class="hljs-comment"><span class="hljs-comment">//     TExternalFunction = class(IExternalFunctionImpl) Metadata: IRoutineMetadata; end; //     TExternalProcedure = class(IExternalProcedureImpl) Metadata: IRoutineMetadata; end; //     TExternalTrigger = class(IExternalTriggerImpl) Metadata: IRoutineMetadata; end;</span></span></code> </pre> <br><p>       ,           . </p><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> UdrFactories; <span class="hljs-meta"><span class="hljs-meta">{$IFDEF FPC}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$MODE DELPHI}</span></span><span class="hljs-meta"><span class="hljs-meta">{$H+}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> SysUtils, Firebird; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ... <span class="hljs-comment"><span class="hljs-comment">//     TExternalFunction = class(IExternalFunctionImpl) Metadata: IRoutineMetadata; end; //     TExternalProcedure = class(IExternalProcedureImpl) Metadata: IRoutineMetadata; end; //     TExternalTrigger = class(IExternalTriggerImpl) Metadata: IRoutineMetadata; end;</span></span></code> </pre> <br><p>       ,           . </p><br><p>       UDR   . </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> UdrFactories; <span class="hljs-meta"><span class="hljs-meta">{$IFDEF FPC}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$MODE DELPHI}</span></span><span class="hljs-meta"><span class="hljs-meta">{$H+}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> SysUtils, Firebird; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ... <span class="hljs-comment"><span class="hljs-comment">//      TFunctionFactory&lt;T: TExternalFunction, constructor&gt; = class (IUdrFunctionFactoryImpl) procedure dispose(); override; procedure setup(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder: IMetadataBuilder; AOutBuilder: IMetadataBuilder); override; function newItem(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalFunction; override; end; //      TProcedureFactory&lt;T: TExternalProcedure, constructor&gt; = class (IUdrProcedureFactoryImpl) procedure dispose(); override; procedure setup(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder: IMetadataBuilder; AOutBuilder: IMetadataBuilder); override; function newItem(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalProcedure; override; end; //      TTriggerFactory&lt;T: TExternalTrigger, constructor&gt; = class (IUdrTriggerFactoryImpl) procedure dispose(); override; procedure setup(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AFieldsBuilder: IMetadataBuilder); override; function newItem(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalTrigger; override; end;</span></span></code> </pre> </div></div><br><p>   newItem      ,  <br>  ,      . </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">implementation</span></span> ... <span class="hljs-comment"><span class="hljs-comment">{ TFunctionFactory&lt;T&gt; }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFunctionFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispose</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Destroy; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFunctionFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata)</span></span></span><span class="hljs-function">:</span></span> IExternalFunction; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := T.Create; (Result <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> T).Metadata := AMetadata; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFunctionFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder, AOutBuilder: IMetadataBuilder)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-comment"><span class="hljs-comment">{ TProcedureFactory&lt;T&gt; }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TProcedureFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispose</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Destroy; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TProcedureFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata)</span></span></span><span class="hljs-function">:</span></span> IExternalProcedure; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := T.Create; (Result <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> T).Metadata := AMetadata; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TProcedureFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder, AOutBuilder: IMetadataBuilder)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-comment"><span class="hljs-comment">{ TTriggerFactory&lt;T&gt; }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TTriggerFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispose</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Destroy; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TTriggerFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata)</span></span></span><span class="hljs-function">:</span></span> IExternalTrigger; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := T.Create; (Result <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> T).Metadata := AMetadata; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TTriggerFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AFieldsBuilder: IMetadataBuilder)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> </div></div><br><p>          <a href="">https://github.com/sim1984/udr-book/blob/master/examples/Common/UdrFactories.pas</a> . </p><br><h1 id="rabota-s-tipom-blob">    BLOB </h1><br><p>       BLOB    ( BLOB),    .  , BLOB    ,         .         BLOB .      BLOB   <br>  <code>IBlob</code> . </p><br><p>      BLOB  ,  BLOB    ,      BLOB   ,     BLOB     . </p><br><p>     BLOB    ,   BLOB     (),     64 .     <code>getSegment</code>  <code>IBlob</code> .     <code>putSegment</code>  <code>IBlob</code> . </p><br><h2 id="chtenie-dannyh-iz-blob">    BLOB </h2><br><p>     BLOB     <br>    (     <br>  LIST).     </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">procedure</span></span> <span class="hljs-keyword"><span class="hljs-keyword">split</span></span> ( txt <span class="hljs-built_in"><span class="hljs-built_in">blob</span></span> sub_type <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> <span class="hljs-built_in"><span class="hljs-built_in">character</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> utf8, delimiter <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">character</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> utf8 = <span class="hljs-string"><span class="hljs-string">','</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">external</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-string"><span class="hljs-string">'myudr!split'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">engine</span></span> udr;</code> </pre> <br><p>    : </p><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">firebird_udr_plugin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AUnloadFlagLocal: BooleanPtr; AUdrPlugin: IUdrPlugin)</span></span></span><span class="hljs-function">:</span></span> BooleanPtr; <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//    AUdrPlugin.registerProcedure(AStatus, 'split', TProcedureSimpleFactory&lt;TSplitProcedure&gt;.Create()); theirUnloadFlag := AUnloadFlagLocal; Result := @myUnloadFlag; end;</span></span></code> </pre> <br><p>         ,         .      . </p><br><p>     .        . </p><br><pre> <code class="delphi hljs"> TInput = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> txt: ISC_QUAD; txtNull: WordBool; delimiter: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span> .. <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> AnsiChar; delimiterNull: WordBool; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; TInputPtr = ^TInput; TOutput = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> Id: Integer; Null: WordBool; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; TOutputPtr = ^TOutput;</code> </pre> <br><p>     BLOB   BLOB,    <code>ISC_QUAD</code> . </p><br><p>        : </p><br><div class="spoiler"> <b class="spoiler_title">   Split    </b> <div class="spoiler_text"><pre> <code class="delphi hljs"> <span class="hljs-title"><span class="hljs-title">TSplitProcedure</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(IExternalProcedureImpl) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SaveBlobToStream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; ABlobId: ISC_QUADPtr; AStream: TStream)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readBlob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; ABlobId: ISC_QUADPtr)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-comment"><span class="hljs-comment">//      procedure dispose(); override; procedure getCharSet(AStatus: IStatus; AContext: IExternalContext; AName: PAnsiChar; ANameSize: Cardinal); override; function open(AStatus: IStatus; AContext: IExternalContext; AInMsg: Pointer; AOutMsg: Pointer): IExternalResultSet; override; end; TSplitResultSet = class(IExternalResultSetImpl) {$IFDEF FPC} OutputArray: TStringArray; {$ELSE} OutputArray: TArray&lt;string&gt;; {$ENDIF} Counter: Integer; Output: TOutputPtr; procedure dispose(); override; function fetch(AStatus: IStatus): Boolean; override; end;</span></span></code> </pre> </div></div><br><p>   <code>SaveBlobToStream</code>  <code>readBlob</code>    BLOB.   BLOB  ,  —           Delphi.       OutputArray     Counter. </p><br><p>   open  BLOB    .          <code>Split</code>    .        . </p><br><div class="spoiler"> <b class="spoiler_title">TSplitProcedure.open</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSplitProcedure</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">open</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AInMsg, AOutMsg: Pointer)</span></span></span><span class="hljs-function">:</span></span> IExternalResultSet; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xInput: TInputPtr; xText: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; xDelimiter: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> xInput := AInMsg; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> xInput.txtNull <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> xInput.delimiterNull <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; xText := readBlob(AStatus, AContext, @xInput.txt); xDelimiter := TFBCharSet.CS_UTF8.GetString(TBytes(@xInput.delimiter), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-comment"><span class="hljs-comment">//        //    //  - /4 SetLength(xDelimiter, 1); Result := TSplitResultSet.Create; with TSplitResultSet(Result) do begin Output := AOutMsg; OutputArray := xText.Split([xDelimiter], TStringSplitOptions.ExcludeEmpty); Counter := 0; end; end;</span></span></code> </pre> </div></div><br><blockquote>  <strong>备注</strong> <br><br>   <code>TFBCharSet</code>    Firebird.pas.    <br>      Firebird.     <br>        UTF-8. <br>     <a href="">FbCharsets.pas</a> </blockquote><p>       BLOB  .       BLOB   .      openBlob  <code>IAttachment</code> .    BLOB    ,        .              ,    <br> ( <code>IExternalContext</code> ). </p><br><p> BLOB   (),     64 .     <code>getSegment</code>  <code>IBlob</code> . </p><br><div class="spoiler"> <b class="spoiler_title">TSplitProcedure.SaveBlobToStream</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSplitProcedure</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SaveBlobToStream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; ABlobId: ISC_QUADPtr; AStream: TStream)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> att: IAttachment; trx: ITransaction; blob: IBlob; buffer: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span> .. <span class="hljs-number"><span class="hljs-number">32767</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> AnsiChar; l: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> att := AContext.getAttachment(AStatus); trx := AContext.getTransaction(AStatus); blob := att.openBlob(AStatus, trx, ABlobId, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> True <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> blob.getSegment(AStatus, SizeOf(buffer), @buffer, @l) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> IStatus.RESULT_OK: AStream.WriteBuffer(buffer, l); IStatus.RESULT_SEGMENT: AStream.WriteBuffer(buffer, l); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; AStream.Position := <span class="hljs-number"><span class="hljs-number">0</span></span>; blob.close(AStatus); <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Assigned(att) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> att.release; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Assigned(trx) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> trx.release; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Assigned(blob) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> blob.release; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> </div></div><br><blockquote>  <strong>备注</strong> <br><br>  ,  <code>IAttachment</code> , <code>ITransaction</code>  <code>IBlob</code> <br>   <code>IReferenceCounted</code> ,      <br>  .      <br>     1.      <br>         release. </blockquote><p>    <code>SaveBlobToStream</code>    BLOB  <br> : </p><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSplitProcedure</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readBlob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; ABlobId: ISC_QUADPtr)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-meta"><span class="hljs-meta">{$IFDEF FPC}</span></span> xStream: TBytesStream; <span class="hljs-meta"><span class="hljs-meta">{$ELSE}</span></span> xStream: TStringStream; <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-meta"><span class="hljs-meta">{$IFDEF FPC}</span></span> xStream := TBytesStream.Create(<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>); <span class="hljs-meta"><span class="hljs-meta">{$ELSE}</span></span> xStream := TStringStream.Create(<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-number"><span class="hljs-number">65001</span></span>); <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> SaveBlobToStream(AStatus, AContext, ABlobId, xStream); <span class="hljs-meta"><span class="hljs-meta">{$IFDEF FPC}</span></span> Result := TEncoding.UTF8.GetString(xStream.Bytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, xStream.Size); <span class="hljs-meta"><span class="hljs-meta">{$ELSE}</span></span> Result := xStream.DataString; <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> xStream.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><blockquote>  <strong>备注</strong> <br><br>   Free Pascal      <br>  Delphi   <code>TStringStream</code> .    FPC   <br>      ,    <br>        . </blockquote><p>  <code>fetch</code>           Counter      ,       .      .           <code>isc_convert_error</code> . </p><br><div class="spoiler"> <b class="spoiler_title"> isc_convert_error</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSplitResultSet</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispose</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SetLength(OutputArray, <span class="hljs-number"><span class="hljs-number">0</span></span>); Destroy; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSplitResultSet</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus)</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> statusVector: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span> .. <span class="hljs-number"><span class="hljs-number">4</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> NativeIntPtr; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Counter &lt;= High(OutputArray) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Output.Null := False; <span class="hljs-comment"><span class="hljs-comment">//         isc_random //        Firebird //  isc_convert_error try Output.Id := OutputArray[Counter].ToInteger(); except on e: EConvertError do begin statusVector[0] := NativeIntPtr(isc_arg_gds); statusVector[1] := NativeIntPtr(isc_convert_error); statusVector[2] := NativeIntPtr(isc_arg_string); statusVector[3] := NativeIntPtr(PAnsiChar('Cannot convert string to integer')); statusVector[4] := NativeIntPtr(isc_arg_end); AStatus.setErrors(@statusVector); end; end; inc(Counter); Result := True; end else Result := False; end;</span></span></code> </pre> </div></div><br><blockquote>  <strong>备注</strong> <br><br>        <code>isc_random</code>   <br> ,      . </blockquote><p>      : </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ids.ID <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SPLIT</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIST</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> MYTABLE), <span class="hljs-string"><span class="hljs-string">','</span></span>) ids</code> </pre> <br><blockquote>  <strong>备注</strong> <br><br>       ,  BLOB  <br>   ,       <br>    .       <br>   ,      <br>   .       <br>    <code>fetch</code>     . </blockquote><br><h2 id="zapis-dannyh-v-blob">    BLOB </h2><br><p>     BLOB     <br> BLOB  . </p><br><blockquote>  <strong>备注</strong> <br><br>      UDF     <br>  BLOB / .  UDF    <br> <a href="">blobsaveload.zip</a> </blockquote><p>      BLOB /      </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PACKAGE</span></span> BlobFileUtils <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> SaveBlobToFile(ABlob <span class="hljs-built_in"><span class="hljs-built_in">BLOB</span></span>, AFileName <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">CHARACTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> UTF8); FUNCTION LoadBlobFromFile(AFileName VARCHAR(255) CHARACTER <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> UTF8) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">BLOB</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>^ <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PACKAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span> BlobFileUtils <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> SaveBlobToFile(ABlob <span class="hljs-built_in"><span class="hljs-built_in">BLOB</span></span>, AFileName <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">CHARACTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> UTF8) <span class="hljs-keyword"><span class="hljs-keyword">EXTERNAL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-string"><span class="hljs-string">'BlobFileUtils!SaveBlobToFile'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENGINE</span></span> UDR; FUNCTION LoadBlobFromFile(AFileName VARCHAR(255) CHARACTER <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> UTF8) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">BLOB</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTERNAL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-string"><span class="hljs-string">'BlobFileUtils!LoadBlobFromFile'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENGINE</span></span> UDR; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>^</code> </pre> <br><p>      : </p><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">firebird_udr_plugin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AUnloadFlagLocal: BooleanPtr; AUdrPlugin: IUdrPlugin)</span></span></span><span class="hljs-function">:</span></span> BooleanPtr; <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//  AUdrPlugin.registerProcedure(AStatus, 'SaveBlobToFile', TSaveBlobToFileProcFactory.Create()); AUdrPlugin.registerFunction(AStatus, 'LoadBlobFromFile', TLoadBlobFromFileFuncFactory.Create()); theirUnloadFlag := AUnloadFlagLocal; Result := @myUnloadFlag; end;</span></span></code> </pre> <br><p>          BLOB  ,   UDR      <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">06.BlobSaveLoad</a> .       LoadBlobFromFile   : </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Firebird, Classes, SysUtils; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-comment"><span class="hljs-comment">//    TInput = record filename: record len: Smallint; str: array [0 .. 1019] of AnsiChar; end; filenameNull: WordBool; end; TInputPtr = ^TInput; //    TOutput = record blobData: ISC_QUAD; blobDataNull: WordBool; end; TOutputPtr = ^TOutput; //   LoadBlobFromFile TLoadBlobFromFileFunc = class(IExternalFunctionImpl) public procedure dispose(); override; procedure getCharSet(AStatus: IStatus; AContext: IExternalContext; AName: PAnsiChar; ANameSize: Cardinal); override; procedure execute(AStatus: IStatus; AContext: IExternalContext; AInMsg: Pointer; AOutMsg: Pointer); override; end; //       LoadBlobFromFile TLoadBlobFromFileFuncFactory = class(IUdrFunctionFactoryImpl) procedure dispose(); override; procedure setup(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder: IMetadataBuilder; AOutBuilder: IMetadataBuilder); override; function newItem(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalFunction; override; end;</span></span></code> </pre> </div></div><br><p>      <code>execute</code>  <code>TLoadBlobFromFile</code> ,    . </p><br><div class="spoiler"> <b class="spoiler_title">  execute</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TLoadBlobFromFileFunc</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AInMsg: Pointer; AOutMsg: Pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MaxBufSize = <span class="hljs-number"><span class="hljs-number">16384</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xInput: TInputPtr; xOutput: TOutputPtr; xFileName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; xStream: TFileStream; att: IAttachment; trx: ITransaction; blob: IBlob; buffer: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span> .. <span class="hljs-number"><span class="hljs-number">32767</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Byte; xStreamSize: Integer; xBufferSize: Integer; xReadLength: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> xInput := AInMsg; xOutput := AOutMsg; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> xInput.filenameNull <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> xOutput.blobDataNull := True; <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; xOutput.blobDataNull := False; <span class="hljs-comment"><span class="hljs-comment">//    xFileName := TEncoding.UTF8.GetString(TBytes(@xInput.filename.str), 0, xInput.filename.len * 4); SetLength(xFileName, xInput.filename.len); //     xStream := TFileStream.Create(xFileName, fmOpenRead or fmShareDenyNone); att := AContext.getAttachment(AStatus); trx := AContext.getTransaction(AStatus); blob := nil; try xStreamSize := xStream.Size; //     () if xStreamSize &gt; MaxBufSize then xBufferSize := MaxBufSize else xBufferSize := xStreamSize; //   blob blob := att.createBlob(AStatus, trx, @xOutput.blobData, 0, nil); //        BLOB   while xStreamSize &lt;&gt; 0 do begin if xStreamSize &gt; xBufferSize then xReadLength := xBufferSize else xReadLength := xStreamSize; xStream.ReadBuffer(buffer, xReadLength); blob.putSegment(AStatus, xReadLength, @buffer[0]); Dec(xStreamSize, xReadLength); end; //  BLOB blob.close(AStatus); finally if Assigned(blob) then blob.release; att.release; trx.release; xStream.Free; end; end;</span></span></code> </pre> </div></div><br><p>      BLOB     blobId     <code>createBlob</code>  <code>IAttachment</code> .       BLOB    ,        .              ,    ( <code>IExternalContext</code> ). </p><br><p>           BLOB,        <code>putSegment</code>  <code>IBlob</code>   ,       .             <code>close</code> . </p><br><h2 id="helper-dlya-raboty-s-tipom-blob">      BLOB </h2><br><p>         BLOB  <br> ,     BLOB  .    <br>      BLOB,      <br>       . </p><br><p>   Delphi  Free Pascal    <br>          . <br>     IBlob      <br>  / Blob. </p><br><p>    FbBlob,     . </p><br><div class="spoiler"> <b class="spoiler_title">BlobHelper</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> FbBlob; <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Classes, SysUtils, Firebird; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MAX_SEGMENT_SIZE = $<span class="hljs-number"><span class="hljs-number">7</span></span>FFF; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TFbBlobHelper = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">helper</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> IBlob <span class="hljs-comment"><span class="hljs-comment">{   BLOB   @param(AStatus  ) @param(AStream ) }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadFromStream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AStream: TStream)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-comment"><span class="hljs-comment">{     BLOB @param(AStatus  ) @param(AStream ) }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SaveToStream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AStream: TStream)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">implementation</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Math; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFbBlobHelper</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadFromStream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AStream: TStream)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xStreamSize: Integer; xReadLength: Integer; xBuffer: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span> .. MAX_SEGMENT_SIZE] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Byte; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> xStreamSize := AStream.Size; AStream.Position := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> xStreamSize &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> xReadLength := Min(xStreamSize, MAX_SEGMENT_SIZE); AStream.ReadBuffer(xBuffer, xReadLength); Self.putSegment(AStatus, xReadLength, @xBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>]); Dec(xStreamSize, xReadLength); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFbBlobHelper</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SaveToStream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AStream: TStream)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xInfo: TFbBlobInfo; Buffer: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span> .. MAX_SEGMENT_SIZE] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Byte; xBytesRead: Cardinal; xBufferSize: Cardinal; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> AStream.Position := <span class="hljs-number"><span class="hljs-number">0</span></span>; xBufferSize := Min(SizeOf(Buffer), MAX_SEGMENT_SIZE); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> True <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Self.getSegment(AStatus, xBufferSize, @Buffer[<span class="hljs-number"><span class="hljs-number">0</span></span>], @xBytesRead) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> IStatus.RESULT_OK: AStream.WriteBuffer(Buffer, xBytesRead); IStatus.RESULT_SEGMENT: AStream.WriteBuffer(Buffer, xBytesRead); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre> </div></div><br><p>         BLOB,     BLOB      : </p><br><div class="spoiler"> <b class="spoiler_title">TLoadBlobFromFileFunc.execute</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TLoadBlobFromFileFunc</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AInMsg: Pointer; AOutMsg: Pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xInput: TInputPtr; xOutput: TOutputPtr; xFileName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; xStream: TFileStream; att: IAttachment; trx: ITransaction; blob: IBlob; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> xInput := AInMsg; xOutput := AOutMsg; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> xInput.filenameNull <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> xOutput.blobDataNull := True; <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; xOutput.blobDataNull := False; <span class="hljs-comment"><span class="hljs-comment">//    xFileName := TEncoding.UTF8.GetString(TBytes(@xInput.filename.str), 0, xInput.filename.len * 4); SetLength(xFileName, xInput.filename.len); //     xStream := TFileStream.Create(xFileName, fmOpenRead or fmShareDenyNone); att := AContext.getAttachment(AStatus); trx := AContext.getTransaction(AStatus); blob := nil; try //   blob blob := att.createBlob(AStatus, trx, @xOutput.blobData, 0, nil); //     BLOB blob.LoadFromStream(AStatus, xStream); //  BLOB blob.close(AStatus); finally if Assigned(blob) then blob.release; att.release; trx.release; xStream.Free; end; end;</span></span></code> </pre> </div></div><br><h1 id="kontekst-soedineniya-i-tranzakcii">     </h1><br><p>    ,              ,    ,        / .  ,            BLOB. </p><br><p>    ,          <code>IExternalContext</code>   execute   ,    open .  <code>IExternalContext</code>        <code>getAttachment</code> ,       <code>getTransaction</code> .      UDR,              ,        ,     <code>startTransaction</code>  <code>IExternalContext</code> .              .  ,               , ..     (2PC). </p><br><p>          ,      SELECT    JSON.    : </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> GetJson ( sql_text <span class="hljs-built_in"><span class="hljs-built_in">blob</span></span> sub_type <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> <span class="hljs-built_in"><span class="hljs-built_in">character</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> utf8, sql_dialect <span class="hljs-built_in"><span class="hljs-built_in">smallint</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-built_in"><span class="hljs-built_in">blob</span></span> sub_type <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> <span class="hljs-built_in"><span class="hljs-built_in">character</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> utf8 <span class="hljs-keyword"><span class="hljs-keyword">external</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-string"><span class="hljs-string">'JsonUtils!getJson'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">engine</span></span> udr;</code> </pre> <br><p>      SQL ,        ,         .         <code>IMessageMetadata</code> .      ,          ,    <br>     Firebird. </p><br><blockquote>  <strong>备注</strong> <br><br>  JSON        . <br>    CHAR, VARCHAR  OCTETS NONE  BLOB SUB_TYPE BINARY <br>        base64, <br>      JSON. </blockquote><p>    : </p><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">firebird_udr_plugin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AUnloadFlagLocal: BooleanPtr; AUdrPlugin: IUdrPlugin)</span></span></span><span class="hljs-function">:</span></span> BooleanPtr; <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//   AUdrPlugin.registerFunction(AStatus, 'getJson', TFunctionSimpleFactory&lt;TJsonFunction&gt;.Create()); theirUnloadFlag := AUnloadFlagLocal; Result := @myUnloadFlag; end;</span></span></code> </pre> <br><p>        ,       : </p><br><div class="spoiler"> <b class="spoiler_title">   GetJson</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> JsonFunc; <span class="hljs-meta"><span class="hljs-meta">{$IFDEF FPC}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$MODE objfpc}</span></span><span class="hljs-meta"><span class="hljs-meta">{$H+}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$DEFINE DEBUGFPC}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Firebird, UdrFactories, FbTypes, FbCharsets, SysUtils, System.NetEncoding, System.Json; <span class="hljs-comment"><span class="hljs-comment">// ********************************************************* // create function GetJson ( // sql_text blob sub_type text, // sql_dialect smallint not null default 3 // ) returns blob sub_type text character set utf8 // external name 'JsonUtils!getJson' // engine udr; // ********************************************************* type TInput = record SqlText: ISC_QUAD; SqlNull: WordBool; SqlDialect: Smallint; SqlDialectNull: WordBool; end; InputPtr = ^TInput; TOutput = record Json: ISC_QUAD; NullFlag: WordBool; end; OutputPtr = ^TOutput; //   TSumArgsFunction. TJsonFunction = class(IExternalFunctionImpl) public procedure dispose(); override; procedure getCharSet(AStatus: IStatus; AContext: IExternalContext; AName: PAnsiChar; ANameSize: Cardinal); override; {         @param(AValue ) @param(Scale ) @returns(   ) } function MakeScaleInteger(AValue: Int64; Scale: Smallint): string; {       Json @param(AStatus  ) @param(AContext    ) @param(AJson   Json) @param(ABuffer  ) @param(AMeta  ) @param(AFormatSetting     ) } procedure writeJson(AStatus: IStatus; AContext: IExternalContext; AJson: TJsonArray; ABuffer: PByte; AMeta: IMessageMetadata; AFormatSettings: TFormatSettings); {    @param(AStatus  ) @param(AContext    ) @param(AInMsg    ) @param(AOutMsg    ) } procedure execute(AStatus: IStatus; AContext: IExternalContext; AInMsg: Pointer; AOutMsg: Pointer); override; end;</span></span></code> </pre> </div></div><br><p>   <code>MakeScaleInteger</code>       ,  <code>writeJson</code>        Json        .     ,      <code>execute</code>    . </p><br><div class="spoiler"> <b class="spoiler_title">TJsonFunction.execute</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TJsonFunction</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AInMsg, AOutMsg: Pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xFormatSettings: TFormatSettings; xInput: InputPtr; xOutput: OutputPtr; att: IAttachment; tra: ITransaction; stmt: IStatement; inBlob, outBlob: IBlob; inStream: TBytesStream; outStream: TStringStream; cursorMetaData: IMessageMetadata; rs: IResultSet; msgLen: Cardinal; msg: Pointer; jsonArray: TJsonArray; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> xInput := AInMsg; xOutput := AOutMsg; <span class="hljs-comment"><span class="hljs-comment">//      NULL,    NULL if xInput.SqlNull or xInput.SqlDialectNull then begin xOutput.NullFlag := True; Exit; end; xOutput.NullFlag := False; //      xFormatSettings := TFormatSettings.Create; xFormatSettings.DateSeparator := '-'; xFormatSettings.TimeSeparator := ':'; //      blob inStream := TBytesStream.Create(nil); outStream := TStringStream.Create('', 65001); jsonArray := TJsonArray.Create; //      att := AContext.getAttachment(AStatus); tra := AContext.getTransaction(AStatus); stmt := nil; inBlob := nil; outBlob := nil; try //  BLOB   inBlob := att.openBlob(AStatus, tra, @xInput.SqlText, 0, nil); inBlob.SaveToStream(AStatus, inStream); inBlob.close(AStatus); //   stmt := att.prepare(AStatus, tra, inStream.Size, @inStream.Bytes[0], xInput.SqlDialect, IStatement.PREPARE_PREFETCH_METADATA); //     cursorMetaData := stmt.getOutputMetadata(AStatus); //   rs := stmt.openCursor(AStatus, tra, nil, nil, nil, 0); //     msgLen := cursorMetaData.getMessageLength(AStatus); msg := AllocMem(msgLen); try //     while rs.fetchNext(AStatus, msg) = IStatus.RESULT_OK do begin //     JSON writeJson(AStatus, AContext, jsonArray, msg, cursorMetaData, xFormatSettings); end; finally //   FreeMem(msg); end; //   rs.close(AStatus); //  JSON   outStream.WriteString(jsonArray.ToJSON); //  json   blob outBlob := att.createBlob(AStatus, tra, @xOutput.Json, 0, nil); outBlob.LoadFromStream(AStatus, outStream); outBlob.close(AStatus); finally if Assigned(inBlob) then inBlob.release; if Assigned(stmt) then stmt.release; if Assigned(outBlob) then outBlob.release; tra.release; att.release; jsonArray.Free; inStream.Free; outStream.Free; end; end;</span></span></code> </pre> </div></div><br><p>                <code>getAttachment</code>  <code>getTransaction</code>  <code>IExternalContext</code> .    BLOB    SQL .      prepare  <code>IAttachment</code> .    SQL       .     <code>IStatement.PREPARE_PREFETCH_METADATA</code> ,             .         <code>getOutputMetadata</code>  <code>IStatement</code> . </p><br><blockquote>  <strong>备注</strong> <br><br>     getOutputMetadata      . <br>  <code>IStatement.PREPARE_PREFETCH_METADATA</code>     <br>        .     <br>         ,    . </blockquote><p>       openCursor     ( 2).           <code>getMessageLength</code>  <code>IMessageMetadata</code> .      ,         . </p><br><p>       <code>fetchNext</code>  <code>IResultSet</code> .     <code>msg</code>      <code>IStatus.RESULT_OK</code>   ,     .       <code>writeJson</code> ,     <code>TJsonObject</code>       <code>TJsonArray</code> . </p><br><p>     ,    <code>close</code> ,   Json   ,     ,     Blob. </p><br><p>    <code>writeJson</code> .  <code>IUtil</code>    ,        .               <code>IMessageMetadata</code> .      <code>TJsonObject</code>        .          .   NullFlag,    null       ,            Json. </p><br><div class="spoiler"> <b class="spoiler_title"> writeJson</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TJsonFunction</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeScaleInteger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AValue: Int64; Scale: Smallint)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> L: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := AValue.ToString; L := Result.Length; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (-Scale &gt;= L) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := <span class="hljs-string"><span class="hljs-string">'0.'</span></span> + Result.PadLeft(-Scale, <span class="hljs-string"><span class="hljs-string">'0'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Result := Result.Insert(Scale + L, <span class="hljs-string"><span class="hljs-string">'.'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TJsonFunction</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeJson</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AJson: TJsonArray; ABuffer: PByte; AMeta: IMessageMetadata; AFormatSettings: TFormatSettings)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> jsonObject: TJsonObject; i: Integer; FieldName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; NullFlag: WordBool; pData: PByte; util: IUtil; metaLength: Integer; <span class="hljs-comment"><span class="hljs-comment">//  CharBuffer: array [0 .. 35766] of Byte; charLength: Smallint; charset: TFBCharSet; StringValue: string; SmallintValue: Smallint; IntegerValue: Integer; BigintValue: Int64; Scale: Smallint; SingleValue: Single; DoubleValue: Double; BooleanValue: Boolean; DateValue: ISC_DATE; TimeValue: ISC_TIME; TimestampValue: ISC_TIMESTAMP; DateTimeValue: TDateTime; year, month, day: Cardinal; hours, minutes, seconds, fractions: Cardinal; blobId: ISC_QUADPtr; BlobSubtype: Smallint; blob: IBlob; textStream: TStringStream; binaryStream: TBytesStream; att: IAttachment; tra: ITransaction; begin //  IUtil util := AContext.getMaster().getUtilInterface(); //   TJsonObject    //     jsonObject := TJsonObject.Create; for i := 0 to AMeta.getCount(AStatus) - 1 do begin //      FieldName := AMeta.getAlias(AStatus, i); NullFlag := PWordBool(ABuffer + AMeta.getNullOffset(AStatus, i))^; if NullFlag then begin //  NULL    JSON      jsonObject.AddPair(FieldName, TJsonNull.Create); continue; end; //      pData := ABuffer + AMeta.getOffset(AStatus, i); case TFBType(AMeta.getType(AStatus, i)) of // VARCHAR SQL_VARYING: begin //    VARCHAR metaLength := AMeta.getLength(AStatus, i); charset := TFBCharSet(AMeta.getCharSet(AStatus, i)); //  VARCHAR  2  -  charLength := PSmallint(pData)^; //     base64 if charset = CS_BINARY then StringValue := TNetEncoding.Base64.EncodeBytesToString((pData + 2), charLength) else begin //       3  Move((pData + 2)^, CharBuffer, metaLength - 2); StringValue := charset.GetString(TBytes(@CharBuffer), 0, charLength * charset.GetCharWidth) SetLength(StringValue, charLength); end; jsonObject.AddPair(FieldName, StringValue); end; // CHAR SQL_TEXT: begin //    CHAR metaLength := AMeta.getLength(AStatus, i); charset := TFBCharSet(AMeta.getCharSet(AStatus, i)); //     base64 if charset = CS_BINARY then StringValue := TNetEncoding.Base64.EncodeBytesToString((pData + 2), metaLength) else begin //     Move(pData^, CharBuffer, metaLength); StringValue := charset.GetString(TBytes(@CharBuffer), 0, metaLength); charLength := metaLength div charset.GetCharWidth; SetLength(StringValue, charLength); end; jsonObject.AddPair(FieldName, StringValue); end; // FLOAT SQL_FLOAT: begin SingleValue := PSingle(pData)^; jsonObject.AddPair(FieldName, TJSONNumber.Create(SingleValue)); end; // DOUBLE PRECISION // DECIMAL(p, s),  p = 10..15  1  SQL_DOUBLE, SQL_D_FLOAT: begin DoubleValue := PDouble(pData)^; jsonObject.AddPair(FieldName, TJSONNumber.Create(DoubleValue)); end; // INTEGER // NUMERIC(p, s),  p = 1..4 SQL_SHORT: begin Scale := AMeta.getScale(AStatus, i); SmallintValue := PSmallint(pData)^; if (Scale = 0) then begin jsonObject.AddPair(FieldName, TJSONNumber.Create(SmallintValue)); end else begin StringValue := MakeScaleInteger(SmallintValue, Scale); jsonObject.AddPair(FieldName, TJSONNumber.Create(StringValue)); end; end; // INTEGER // NUMERIC(p, s),  p = 5..9 // DECIMAL(p, s),  p = 1..9 SQL_LONG: begin Scale := AMeta.getScale(AStatus, i); IntegerValue := PInteger(pData)^; if (Scale = 0) then begin jsonObject.AddPair(FieldName, TJSONNumber.Create(IntegerValue)); end else begin StringValue := MakeScaleInteger(IntegerValue, Scale); jsonObject.AddPair(FieldName, TJSONNumber.Create(StringValue)); end; end; // BIGINT // NUMERIC(p, s),  p = 10..18  3  // DECIMAL(p, s),  p = 10..18  3  SQL_INT64: begin Scale := AMeta.getScale(AStatus, i); BigintValue := Pint64(pData)^; if (Scale = 0) then begin jsonObject.AddPair(FieldName, TJSONNumber.Create(BigintValue)); end else begin StringValue := MakeScaleInteger(BigintValue, Scale); jsonObject.AddPair(FieldName, TJSONNumber.Create(StringValue)); end; end; // TIMESTAMP SQL_TIMESTAMP: begin TimestampValue := PISC_TIMESTAMP(pData)^; //    - util.decodeDate(TimestampValue.date, @year, @month, @day); util.decodeTime(TimestampValue.time, @hours, @minutes, @seconds, @fractions); //  -    Delphi DateTimeValue := EncodeDate(year, month, day) + EncodeTime(hours, minutes, seconds, fractions div 10); //  -    StringValue := FormatDateTime('yyyy/mm/dd hh:nn:ss', DateTimeValue, AFormatSettings); jsonObject.AddPair(FieldName, StringValue); end; // DATE SQL_DATE: begin DateValue := PISC_DATE(pData)^; //     util.decodeDate(DateValue, @year, @month, @day); //      Delphi DateTimeValue := EncodeDate(year, month, day); //      StringValue := FormatDateTime('yyyy/mm/dd', DateTimeValue, AFormatSettings); jsonObject.AddPair(FieldName, StringValue); end; // TIME SQL_TIME: begin TimeValue := PISC_TIME(pData)^; //     util.decodeTime(TimeValue, @hours, @minutes, @seconds, @fractions); //      Delphi DateTimeValue := EncodeTime(hours, minutes, seconds, fractions div 10); //      StringValue := FormatDateTime('hh:nn:ss', DateTimeValue, AFormatSettings); jsonObject.AddPair(FieldName, StringValue); end; // BOOLEAN SQL_BOOLEAN: begin BooleanValue := PBoolean(pData)^; jsonObject.AddPair(FieldName, TJsonBool.Create(BooleanValue)); end; // BLOB SQL_BLOB, SQL_QUAD: begin BlobSubtype := AMeta.getSubType(AStatus, i); blobId := ISC_QUADPtr(pData); att := AContext.getAttachment(AStatus); tra := AContext.getTransaction(AStatus); blob := att.openBlob(AStatus, tra, blobId, 0, nil); if BlobSubtype = 1 then begin //  charset := TFBCharSet(AMeta.getCharSet(AStatus, i)); //      textStream := TStringStream.Create('', charset.GetCodePage); try blob.SaveToStream(AStatus, textStream); StringValue := textStream.DataString; finally textStream.Free; blob.release; tra.release; att.release end; end else begin //      binaryStream := TBytesStream.Create; try blob.SaveToStream(AStatus, binaryStream); //    base64 StringValue := TNetEncoding.Base64.EncodeBytesToString (binaryStream.Memory, binaryStream.Size); finally binaryStream.Free; blob.release; tra.release; att.release end; end; jsonObject.AddPair(FieldName, StringValue); end; end; end; //     Json   AJson.AddElement(jsonObject); end;</span></span></code> </pre> </div></div><br><blockquote>  <strong>备注</strong> <br><br>   TFbType     <code>Firebird.pas</code> . <br>      ,      <br> <a href="">FbTypes</a>        . <br><br>  TFBCharSet     <code>Firebird.pas</code> . <br>     <br> <a href="">FbCharsets</a>     .  ,     <br>  ,       <br>   ,  ,    , <br>   <code>TEncoding</code>   ,     <br>       Delphi. </blockquote><p>    CHAR  VARCHAR  ,    OCTETS,     base64,          Delphi.  ,    VARCHAR  2      . </p><br><p>  SMALLINT, INTEGER, BIGINT      ,  .      <code>getScale</code>  <code>IMessageMetadata</code> .     0,     ,    <code>MakeScaleInteger</code> . </p><br><p>  DATE, TIME  TIMESTAMP           <code>decodeDate</code>  <code>decodeTime</code>  <code>IUtil</code> .        -   Delphi  <code>TDateTime</code> . </p><br><p>   BLOB    Delphi.  BLOB ,     <code>TBytesStream</code> .        base64.  BLOB ,     <code>TStringStream</code>  ,     .       BLOB <br> . </p><br><p> 仅此而已。      UDR  Firebird,   . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN455375/">https://habr.com/ru/post/zh-CN455375/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN455355/index.html">最小的有线电视网络。 第8部分：光骨干网</a></li>
<li><a href="../zh-CN455359/index.html">实用的Swift很简单</a></li>
<li><a href="../zh-CN455361/index.html">我们制作了一个浏览器扩展程序，用于检查考试结果</a></li>
<li><a href="../zh-CN455371/index.html">从5μA到20 mA的稳定电流源</a></li>
<li><a href="../zh-CN455373/index.html">如何调整Spring的法则，使其对小型提供者有所帮助？ 取消它</a></li>
<li><a href="../zh-CN455377/index.html">物联网架构</a></li>
<li><a href="../zh-CN455379/index.html">（静态）在C ++程序中选择最佳容器</a></li>
<li><a href="../zh-CN455381/index.html">3CX技术支持做出响应：在PBX服务器上捕获SIP通信</a></li>
<li><a href="../zh-CN455387/index.html">了解弹性堆栈中的机器学习（又名Elasticsearch，又名ELK）</a></li>
<li><a href="../zh-CN455389/index.html">Haxe 4：新功能？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>