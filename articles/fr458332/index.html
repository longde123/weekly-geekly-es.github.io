<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚åöÔ∏è üë©üèΩ‚Äçüè≠ üê´ Programmation asynchrone - performances asynchrones: comprendre les co√ªts de l'async et attendre üßõüèΩ üë≤üèΩ üëï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article est assez ancien, mais n'a pas perdu sa pertinence. En ce qui concerne async / wait, un lien vers celui-ci appara√Æt g√©n√©ralement. Je n'ai ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programmation asynchrone - performances asynchrones: comprendre les co√ªts de l'async et attendre</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458332/"><p>  Cet article est assez ancien, mais n'a pas perdu sa pertinence.  En ce qui concerne async / wait, un lien vers celui-ci appara√Æt g√©n√©ralement.  Je n'ai pas trouv√© de traduction en russe, j'ai d√©cid√© d'aider quelqu'un qui ne parle pas couramment. </p><br><hr><br><p> La programmation asynchrone a longtemps √©t√© le royaume des d√©veloppeurs les plus exp√©riment√©s qui ont soif de masochisme - ceux qui avaient assez de temps libre, d'inclination et de capacit√© psychique pour penser aux rappels des rappels dans un flux d'ex√©cution non lin√©aire.  Avec l'av√®nement de Microsoft .NET Framework 4.5, C # et Visual Basic nous ont tous apport√© l'asynchronie, de sorte que les simples mortels peuvent d√©sormais √©crire des m√©thodes asynchrones presque aussi facilement que des m√©thodes synchrones.  Les rappels ne sont plus n√©cessaires.  Plus de code de marshaling explicite d'un contexte de synchronisation √† un autre.  Plus de soucis sur la fa√ßon dont les r√©sultats d'ex√©cution ou les exceptions √©voluent.  Il n'y a pas besoin d'astuces qui d√©forment les moyens de langages de programmation pour la commodit√© de d√©velopper du code asynchrone.  Bref, il n'y a plus de probl√®mes et de maux de t√™te. </p><a name="habracut"></a><br><p>  Bien s√ªr, bien qu'il soit maintenant facile de commencer √† √©crire des m√©thodes asynchrones (voir les articles d'Eric Lippert et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mads Torgersen</a> dans ce <em>MSDN Magazine [OCTOBRE 2011]</em> ), une compr√©hension est n√©cessaire pour le faire correctement. ce qui se passe sous le capot.  Chaque fois qu'un langage ou une biblioth√®que augmente le niveau d'abstraction qu'un d√©veloppeur peut utiliser, cela s'accompagne in√©vitablement de co√ªts cach√©s qui r√©duisent la productivit√©.  Dans de nombreux cas, ces co√ªts sont n√©gligeables, de sorte qu'ils peuvent √™tre n√©glig√©s dans la plupart des cas par la plupart des programmeurs.  Cependant, les d√©veloppeurs avanc√©s doivent bien comprendre quels sont les co√ªts pr√©sents afin de prendre les mesures n√©cessaires et de r√©soudre les probl√®mes √©ventuels s'ils se manifestent.  Cela est requis lors de l'utilisation d'outils de programmation asynchrone en C # et Visual Basic. </p><br><p>  Dans cet article, je vais d√©crire les entr√©es et les sorties des m√©thodes asynchrones, expliquer comment les m√©thodes asynchrones sont impl√©ment√©es et discuter de certains des co√ªts les plus faibles.  Notez que ce n'est pas une recommandation de d√©former le code lisible en quelque chose qui est difficile √† maintenir, au nom de la microoptimisation et des performances.  Ce ne sont que les connaissances qui vous aideront √† diagnostiquer les probl√®mes que vous pouvez rencontrer et un ensemble d'outils pour surmonter ces probl√®mes.  En outre, cet article est bas√© sur l'aper√ßu de la version 4.5 de .NET Framework, et probablement les d√©tails d'impl√©mentation sp√©cifiques peuvent changer dans la version finale. </p><br><h4 id="poluchit-udobnuyu-model-myshleniya">  Obtenez un mod√®le de r√©flexion confortable </h4><br><p>  Depuis des d√©cennies, les programmeurs utilisent des langages de programmation de haut niveau C #, Visual Basic, F # et C ++ pour d√©velopper des applications productives.  Cette exp√©rience a permis aux programmeurs d'√©valuer les co√ªts de diverses op√©rations et d'acqu√©rir des connaissances sur les meilleures techniques de d√©veloppement.  Par exemple, dans la plupart des cas, l'invocation d'une m√©thode synchrone est relativement √©conomique, surtout si le compilateur peut incorporer le contenu de la m√©thode invoqu√©e directement dans le point d'appel.  Par cons√©quent, les d√©veloppeurs sont habitu√©s √† diviser le code en petites m√©thodes faciles √† entretenir, sans avoir √† se soucier des cons√©quences n√©gatives de l'augmentation du nombre d'appels.  Le mod√®le de r√©flexion de ces programmeurs est con√ßu pour g√©rer les appels de m√©thode. </p><br><p>  Avec l'av√®nement des m√©thodes asynchrones, un nouveau mod√®le de pens√©e s'impose.  C # et Visual Basic avec leurs compilateurs sont capables de cr√©er l'illusion que la m√©thode asynchrone fonctionne comme son homologue synchrone, bien que tout soit compl√®tement faux √† l'int√©rieur.  Le compilateur g√©n√®re une √©norme quantit√© de code pour le programmeur, tr√®s similaire au mod√®le standard que les d√©veloppeurs ont √©crit pour prendre en charge l'asynchronie pendant le temps o√π il √©tait n√©cessaire de le faire √† la main.  De plus, le code g√©n√©r√© par le compilateur contient des appels aux fonctions de la biblioth√®que .NET Framework, ce qui r√©duit encore la quantit√© de travail qu'un programmeur doit effectuer.  Afin d'avoir le bon mod√®le de pens√©e et de l'utiliser pour prendre des d√©cisions √©clair√©es, il est important de comprendre ce que le compilateur g√©n√®re pour vous. </p><br><h4 id="bolshe-razmer-metodov-menshe-vyzovov">  Plus de m√©thodes, moins d'appels </h4><br><p>  Lorsque vous travaillez avec du code synchrone, l'ex√©cution de m√©thodes avec un contenu vide est pratiquement sans valeur.  Pour les m√©thodes asynchrones, ce n'est pas le cas.  Consid√©rez cette m√©thode asynchrone, compos√©e d'une instruction (et qui, en raison du manque d'instructions d'attente, sera ex√©cut√©e de mani√®re synchrone): </p><br><pre><code class="plaintext hljs">public static async Task SimpleBodyAsync() { Console.WriteLine("Hello, Async World!"); }</code> </pre> <br><p>  Un d√©compilateur de langage interm√©diaire (IL) r√©v√©lera le vrai contenu de cette fonction apr√®s la compilation, produisant quelque chose de similaire √† la figure 1. Ce qui √©tait un simple liner transform√© en deux m√©thodes, dont l'une appartient √† la classe auxiliaire de la machine √† √©tats.  La premi√®re est une m√©thode stub qui a une signature similaire √† celle √©crite par le programmeur (cette m√©thode a le m√™me nom, la m√™me port√©e, elle prend les m√™mes param√®tres et renvoie le m√™me type), mais ne contient pas de code √©crit par le programmeur.  Il ne contient qu'un passe-partout standard pour la configuration initiale.  Le code de configuration initiale initialise la machine d'√©tat n√©cessaire pour repr√©senter la m√©thode asynchrone et la d√©marre √† l'aide d'un appel √† la m√©thode de l'utilitaire MoveNext.  Le type d'objet de la machine d'√©tat contient une variable avec l'√©tat d'ex√©cution de la m√©thode asynchrone, vous permettant de l'enregistrer lors du basculement entre les points d'attente asynchrones.  Il contient √©galement du code √©crit par un programmeur, modifi√© pour assurer le transfert des r√©sultats d'ex√©cution et des exceptions √† l'objet Task retourn√©;  maintien de la position actuelle dans la m√©thode afin que l'ex√©cution puisse continuer √† partir de cette position apr√®s la reprise, etc. </p><br><p>  <strong>Figure 1</strong> mod√®le de m√©thode asynchrone </p><br><pre> <code class="plaintext hljs">[DebuggerStepThrough] public static Task SimpleBodyAsync() { &lt;SimpleBodyAsync&gt;d__0 d__ = new &lt;SimpleBodyAsync&gt;d__0(); d__.&lt;&gt;t__builder = AsyncTaskMethodBuilder.Create(); d__.MoveNext(); return d__.&lt;&gt;t__builder.Task; } [CompilerGenerated] [StructLayout(LayoutKind.Sequential)] private struct &lt;SimpleBodyAsync&gt;d__0 : &lt;&gt;t__IStateMachine { private int &lt;&gt;1__state; public AsyncTaskMethodBuilder &lt;&gt;t__builder; public Action &lt;&gt;t__MoveNextDelegate; public void MoveNext() { try { if (this.&lt;&gt;1__state == -1) return; Console.WriteLine("Hello, Async World!"); } catch (Exception e) { this.&lt;&gt;1__state = -1; this.&lt;&gt;t__builder.SetException(e); return; } this.&lt;&gt;1__state = -1; this.&lt;&gt;t__builder.SetResult(); } ... }</code> </pre> <br><p>  Lorsque vous vous demandez combien co√ªtent les appels aux m√©thodes asynchrones, souvenez-vous de ce mod√®le.  Le bloc try / catch dans la m√©thode MoveNext est n√©cessaire pour emp√™cher une √©ventuelle tentative d'incorporation de cette m√©thode JIT par le compilateur, donc au moins nous obtenons le co√ªt de l'appel de la m√©thode, tandis que lors de l'utilisation de la m√©thode synchrone, cet appel ne le sera probablement pas (√† condition que contenu minimaliste).  Nous recevrons plusieurs appels aux proc√©dures Framework (par exemple, SetResult).  Ainsi que plusieurs op√©rations d'√©criture dans les champs de l'objet machine d'√©tat.  Bien s√ªr, nous devons comparer tous ces co√ªts avec les co√ªts de Console.WriteLine, qui pr√©vaudront probablement (ils incluent les co√ªts de verrouillage, d'E / S, etc.) Faites attention aux optimisations que l'environnement fait pour vous.  Par exemple, un objet de machine d'√©tat est impl√©ment√© en tant que struct.  Cette structure sera encadr√©e dans un tas g√©r√© uniquement si la m√©thode doit interrompre l'ex√©cution, en attendant la fin de l'op√©ration, et cela ne se produira jamais dans cette m√©thode simple.  Ainsi, le mod√®le de cette m√©thode asynchrone ne n√©cessitera pas d'allocation de m√©moire √† partir du tas.  Le compilateur et le runtime tenteront de minimiser le nombre d'op√©rations d'allocation de m√©moire. </p><br><h4 id="kogda-ne-nuzhno-ispolzovat-async">  Quand ne pas utiliser Async </h4><br><p>  Le .NET Framework essaie de g√©n√©rer des impl√©mentations efficaces pour les m√©thodes asynchrones √† l'aide de diverses m√©thodes d'optimisation.  N√©anmoins, les d√©veloppeurs, bas√©s sur leur exp√©rience, appliquent souvent leurs m√©thodes d'optimisation, qui peuvent √™tre risqu√©es et peu pratiques pour l'automatisation par le compilateur et le runtime, car ils essaient d'utiliser des approches universelles.  Si vous ne l'oubliez pas, le refus d'utiliser des m√©thodes asynchrones est b√©n√©fique dans un certain nombre de cas sp√©cifiques, en particulier, cela s'applique aux m√©thodes dans les biblioth√®ques qui peuvent √™tre utilis√©es avec des param√®tres plus fins.  Habituellement, cela se produit lorsqu'il est certain que la m√©thode peut √™tre ex√©cut√©e de mani√®re synchrone, car les donn√©es dont elle d√©pend sont d√©j√† pr√™tes. </p><br><p>  Lors de la cr√©ation de m√©thodes asynchrones, les d√©veloppeurs de .NET Framework ont ‚Äã‚Äãpass√© beaucoup de temps √† optimiser le nombre d'op√©rations de gestion de la m√©moire.  Cela est n√©cessaire car la gestion de la m√©moire entra√Æne le co√ªt le plus √©lev√© dans les performances d'une infrastructure asynchrone.  L'op√©ration d'allocation de m√©moire pour un objet est g√©n√©ralement relativement peu co√ªteuse.  Allouer de la m√©moire aux objets revient √† remplir le panier de produits au supermarch√© - vous ne d√©pensez rien lorsque vous les mettez dans le panier.  Les d√©penses se produisent lorsque vous payez √† la caisse, sortez votre portefeuille et donnez de l'argent d√©cent.  Et si l'allocation de m√©moire est facile, le garbage collection ult√©rieur peut gravement affecter les performances des applications.  Lorsque vous d√©marrez le garbage collection, l'analyse et le marquage des objets qui se trouvent actuellement en m√©moire mais qui n'ont pas de liens sont effectu√©s.  Plus il y a d'objets plac√©s, plus il faut de temps pour les marquer.  De plus, plus le nombre d'objets de grande taille plac√©s est grand, plus la collecte des ordures est souvent n√©cessaire.  Cet aspect du travail avec la m√©moire a un impact global sur le syst√®me: plus les ordures sont produites par des m√©thodes asynchrones, plus l'application s'ex√©cute lentement, m√™me si les microtests ne pr√©sentent pas de co√ªts importants. </p><br><p>  Pour les m√©thodes asynchrones qui suspendent leur ex√©cution (en attente de donn√©es qui ne sont pas encore pr√™tes), l'environnement doit cr√©er un objet de type Task, qui sera renvoy√© par la m√©thode, car cet objet sert de r√©f√©rence unique √† l'appel.  Cependant, des appels de m√©thode asynchrones peuvent souvent √™tre effectu√©s sans suspension.  Ensuite, le runtime peut renvoyer du cache l'objet Task pr√©c√©demment termin√©, qui est utilis√© √† plusieurs reprises sans avoir √† cr√©er de nouveaux objets Task.  Vrai, cela n'est autoris√© que dans certaines conditions, par exemple, lorsque la m√©thode asynchrone renvoie une t√¢che, une t√¢che ou un objet non universel (non g√©n√©rique) ou lorsque la t√¢che universelle est sp√©cifi√©e par un type de r√©f√©rence TResult et que null est renvoy√© par la m√©thode.  Bien que la liste de ces conditions s'allonge au fil du temps, il est pr√©f√©rable de savoir comment l'op√©ration est mise en ≈ìuvre. <br></p><p>  Consid√©rez une impl√©mentation de ce type comme un MemoryStream.  MemoryStream est h√©rit√© de Stream et red√©finit les nouvelles m√©thodes impl√©ment√©es dans .NET 4.5: ReadAsync, WriteAsync et FlushAsync, afin de fournir une optimisation de code sp√©cifique √† la m√©moire.  √âtant donn√© que l'op√©ration de lecture est effectu√©e √† partir d'un tampon situ√© en m√©moire, c'est-√†-dire qu'il s'agit en fait d'une copie de la zone de m√©moire, les meilleures performances seront si ReadAsync est ex√©cut√© en mode synchrone.  Une impl√©mentation de ceci dans une m√©thode asynchrone pourrait ressembler √† ceci: </p><br><pre> <code class="plaintext hljs">public override async Task&lt;int&gt; ReadAsync(byte [] buffer, int offset, int count, CancellationToken cancellationToken) { cancellationToken.ThrowIfCancellationRequested(); return this.Read(buffer, offset, count); }</code> </pre> <br><p>  Assez simple.  Et puisque Read est un appel synchrone et que la m√©thode n'a pas d'instructions d'attente pour contr√¥ler les attentes, tous les appels √† ce ReadAsync seront en fait ex√©cut√©s de mani√®re synchrone.  Examinons maintenant un cas standard d'utilisation de threads, par exemple, une op√©ration de copie: </p><br><pre> <code class="plaintext hljs">byte [] buffer = new byte[0x1000]; int numRead; while((numRead = await source.ReadAsync(buffer, 0, buffer.Length)) &gt; 0) { await source.WriteAsync(buffer, 0, numRead); }</code> </pre> <br><p>  Veuillez noter que dans l'exemple ReadAsync donn√©, le flux source est toujours appel√© avec le m√™me param√®tre de longueur de tampon, ce qui signifie qu'il est tr√®s probable que la valeur de retour (le nombre d'octets lus) sera √©galement r√©p√©t√©e.  Sauf dans de rares circonstances, l'impl√©mentation de ReadAsync est peu susceptible d'utiliser l'objet Task mis en cache comme valeur de retour, mais vous pouvez le faire. </p><br><p>  Consid√©rez une autre option d'impl√©mentation pour cette m√©thode, illustr√©e √† la figure 2. En utilisant les avantages de ses aspects inh√©rents aux scripts standard pour cette m√©thode, nous pouvons optimiser l'impl√©mentation en excluant les op√©rations d'allocation de m√©moire, ce qui est peu probable √† partir de l'ex√©cution.  Nous pouvons √©liminer compl√®tement la perte de m√©moire en renvoyant le m√™me objet Task qui a √©t√© utilis√© lors de l'appel ReadAsync pr√©c√©dent si le m√™me nombre d'octets a √©t√© lu.  Et pour une telle op√©ration de bas niveau, qui est susceptible d'√™tre tr√®s rapide et sera appel√©e √† plusieurs reprises, cette optimisation aura un effet significatif, en particulier sur le nombre de garbage collections. </p><br><p>  <strong>Figure 2</strong> Optimisation de la cr√©ation de t√¢ches </p><br><pre> <code class="plaintext hljs">private Task&lt;int&gt; m_lastTask; public override Task&lt;int&gt; ReadAsync(byte [] buffer, int offset, int count, CancellationToken cancellationToken) { if (cancellationToken.IsCancellationRequested) { var tcs = new TaskCompletionSource&lt;int&gt;(); tcs.SetCanceled(); return tcs.Task; } try { int numRead = this.Read(buffer, offset, count); return m_lastTask != null &amp;&amp; numRead == m_lastTask.Result ? m_lastTask : (m_lastTask = Task.FromResult(numRead)); } catch(Exception e) { var tcs = new TaskCompletionSource&lt;int&gt;(); tcs.SetException(e); return tcs.Task; } }</code> </pre> <br><p>  Une m√©thode d'optimisation similaire en √©liminant la cr√©ation inutile d'objets Task peut √™tre utilis√©e si la mise en cache est n√©cessaire.  Envisagez une m√©thode con√ßue pour r√©cup√©rer le contenu d'une page Web et le mettre en cache pour r√©f√©rence future.  En tant que m√©thode asynchrone, cela peut √™tre √©crit comme suit (en utilisant la nouvelle biblioth√®que System.Net.Http.dll pour .NET 4.5): </p><br><pre> <code class="plaintext hljs">private static ConcurrentDictionary&lt;string,string&gt; s_urlToContents; public static async Task&lt;string&gt; GetContentsAsync(string url) { string contents; if (!s_urlToContents.TryGetValue(url, out contents)) { var response = await new HttpClient().GetAsync(url); contents = response.EnsureSuccessStatusCode().Content.ReadAsString(); s_urlToContents.TryAdd(url, contents); } return contents; }</code> </pre> <br><p>  Il s'agit d'une impl√©mentation frontale.  Et pour les appels GetContentsAsync qui ne trouvent pas de donn√©es dans le cache, la surcharge de cr√©ation d'un nouvel objet Task peut √™tre n√©glig√©e par rapport au co√ªt de r√©ception de donn√©es sur le r√©seau.  Cependant, dans le cas de l'obtention de donn√©es √† partir du cache, ces co√ªts deviennent importants si vous enveloppez simplement et donnez les donn√©es locales disponibles. <br></p><p>  Pour √©liminer ces co√ªts (si n√©cessaire pour obtenir des performances √©lev√©es), vous pouvez r√©√©crire la m√©thode comme indiqu√© dans la figure 3. Nous avons maintenant deux m√©thodes: une m√©thode publique synchrone et une m√©thode priv√©e asynchrone, √† laquelle le public d√©l√®gue.  La collection Dictionary met d√©sormais en cache les objets Task cr√©√©s, et non leur contenu, de sorte que les futures tentatives de r√©cup√©ration du contenu d'une page pr√©c√©demment obtenue avec succ√®s peuvent √™tre effectu√©es en acc√©dant simplement √† la collection pour renvoyer l'objet Task existant.  √Ä l'int√©rieur, vous pouvez utiliser les m√©thodes ContinueWith de l'objet Task, ce qui nous permet d'enregistrer l'objet ex√©cut√© dans la collection - au cas o√π le chargement de la page aurait r√©ussi.  Bien s√ªr, ce code est plus complexe et n√©cessite beaucoup de d√©veloppement et de support, comme d'habitude lors de l'optimisation des performances: vous ne voulez pas passer du temps √† l'√©crire jusqu'√† ce que les tests de performances montrent que ces complications conduisent √† son am√©lioration, ce qui est impressionnant et √©vident.  Les am√©liorations d√©pendront en fait de la m√©thode d'application.  Vous pouvez prendre une suite de tests qui simule des cas d'utilisation courants et √©valuer les r√©sultats pour d√©terminer si le jeu en vaut la chandelle. </p><br><p>  <strong>Figure 3</strong> Mise en cache manuelle des t√¢ches </p><br><pre> <code class="plaintext hljs">private static ConcurrentDictionary&lt;string,Task&lt;string&gt;&gt; s_urlToContents; public static Task&lt;string&gt; GetContentsAsync(string url) { Task&lt;string&gt; contents; if (!s_urlToContents.TryGetValue(url, out contents)) { contents = GetContentsInternalAsync(url); contents.ContinueWith(delegate { s_urlToContents.TryAdd(url, contents); }, CancellationToken.None, TaskContinuationOptions.OnlyOnRanToCompletion | TaskContinuatOptions.ExecuteSynchronously, TaskScheduler.Default); } return contents; } private static async Task&lt;string&gt; GetContentsInternalAsync(string url) { var response = await new HttpClient().GetAsync(url); return response.EnsureSuccessStatusCode().Content.ReadAsString(); }</code> </pre> <br><p>  Une autre m√©thode d'optimisation associ√©e aux objets Task consiste √† d√©terminer s'il faut renvoyer un tel objet √† partir de la m√©thode asynchrone.  C # et Visual Basic prennent en charge les m√©thodes asynchrones qui renvoient une valeur nulle (void) et ne cr√©ent pas du tout d'objets Task.  Les m√©thodes asynchrones dans les biblioth√®ques doivent toujours renvoyer Task et Task, car lors de la conception d'une biblioth√®que, vous ne pouvez pas savoir qu'elles ne seront pas utilis√©es en attendant la fin.  Cependant, lors du d√©veloppement d'applications, les m√©thodes qui renvoient void peuvent trouver leur place.  La principale raison de l'existence de ces m√©thodes est de fournir des environnements pilot√©s par √©v√©nements existants, tels que ASP.NET et Windows Presentation Foundation (WPF).  En utilisant async et wait, ces m√©thodes facilitent l'impl√©mentation des gestionnaires de boutons, des √©v√©nements de chargement de page, etc.  Si vous avez l'intention d'utiliser une m√©thode asynchrone avec void, soyez prudent avec la gestion des exceptions: les exceptions de celle-ci appara√Ætront dans tout SynchronizationContext qui √©tait actif au moment o√π la m√©thode a √©t√© appel√©e. <br></p><h4 id="ne-zabyvayte-o-kontekste">  N'oubliez pas le contexte </h4><br><p>  Il existe de nombreux contextes diff√©rents dans le .NET Framework: LogicalCallContext, SynchronizationContext, HostExecutionContext, SecurityContext, ExecutionContext et autres (leur montant gigantesque peut sugg√©rer que les cr√©ateurs du Framework √©taient financi√®rement motiv√©s pour cr√©er de nouveaux contextes, mais je suis s√ªr que ce n'est pas le cas).  Certains de ces contextes affectent fortement les m√©thodes asynchrones, non seulement en termes de fonctionnalit√©s, mais √©galement en termes de performances. </p><br><p>  <strong>SynchronizationContext</strong> SynchronizationContext joue un r√¥le important pour les m√©thodes asynchrones.  Un ¬´contexte de synchronisation¬ª n'est qu'une abstraction pour garantir qu'un appel de d√©l√©gu√© avec les sp√©cificit√©s d'une biblioth√®que ou d'un environnement particulier est marshal√©.  Par exemple, WPF a un DispatcherSynchronizationContext pour repr√©senter un thread d'interface utilisateur (UI) pour Dispatcher: l'envoi d'un d√©l√©gu√© √† ce contexte de synchronisation entra√Æne la mise en file d'attente de ce d√©l√©gu√© pour l'ex√©cution par le Dispatcher dans son thread.  ASP.NET fournit un AspNetSynchronizationContext qui est utilis√© pour garantir que les op√©rations asynchrones impliqu√©es dans le traitement d'une demande ASP.NET sont garanties d'√™tre ex√©cut√©es s√©quentiellement et sont li√©es √† l'√©tat HttpContext correct.  Eh bien, etc.  En g√©n√©ral, il existe environ 10 sp√©cialisations de SynchronizationContext dans le .NET Framework, certaines ouvertes, d'autres internes. </p><br><p>  Lors de l'attente de t√¢ches ou d'objets d'autres types pour lesquels le .NET Framework peut impl√©menter cela, les objets qui les attendent (par exemple, TaskAwaiter) capturent le SynchronizationContext en cours au moment o√π l'attente (attend) commence.  √Ä la fin de l'attente, si le SynchronizationContext a √©t√© captur√©, la poursuite de la m√©thode asynchrone est envoy√©e √† ce contexte de synchronisation.  Pour cette raison, les programmeurs √©crivant des m√©thodes asynchrones qui sont appel√©es √† partir du flux d'interface utilisateur n'ont pas besoin de marshaler manuellement les appels vers le flux d'interface utilisateur pour mettre √† jour les contr√¥les d'interface utilisateur: le Framework effectue ce marshaling automatiquement. </p><br><p>  Malheureusement, ce marshaling a un prix.  Pour les d√©veloppeurs d'applications qui utilisent attendent pour impl√©menter leur flux de contr√¥le, le marshaling automatique est la bonne solution.  Les biblioth√®ques ont souvent une histoire compl√®tement diff√©rente.  Pour les d√©veloppeurs d'applications, ce marshaling est principalement n√©cessaire pour que le code contr√¥le le contexte dans lequel il est ex√©cut√©, par exemple, pour acc√©der aux contr√¥les d'interface utilisateur ou pour acc√©der au HttpContext correspondant √† la demande ASP.NET requise.  Cependant, les biblioth√®ques ne sont g√©n√©ralement pas tenues de satisfaire √† une telle exigence.  Par cons√©quent, le marshaling automatique entra√Æne souvent des co√ªts suppl√©mentaires compl√®tement inutiles.  Jetons un autre regard sur le code qui copie les donn√©es d'un flux √† un autre: </p><br><pre> <code class="plaintext hljs">byte [] buffer = new byte[0x1000]; int numRead; while((numRead = await source.ReadAsync(buffer, 0, buffer.Length)) &gt; 0) { await source.WriteAsync(buffer, 0, numRead); }</code> </pre> <br><p>  Si cette copie est appel√©e √† partir du flux d'interface utilisateur, chaque op√©ration de lecture et d'√©criture forcera l'ex√©cution √† revenir au flux d'interface utilisateur.  Dans le cas d'un m√©gaoctet de donn√©es dans la source et les flux qui lisent et √©crivent de mani√®re asynchrone (c'est-√†-dire la plupart de leurs impl√©mentations), cela signifie environ 500 commutateurs du flux d'arri√®re-plan vers le flux d'interface utilisateur.  Pour g√©rer ce comportement dans les types de t√¢che et de t√¢che, la m√©thode ConfigureAwait est cr√©√©e.  Cette m√©thode accepte le param√®tre continueOnCapturedContext d'un type bool√©en qui contr√¥le le marshaling.  Si true (valeur par d√©faut), attendre renvoie automatiquement le contr√¥le au SynchronizationContext captur√©.  Si false est utilis√©, le contexte de synchronisation sera ignor√© et l'environnement continuera √† ex√©cuter l'op√©ration asynchrone dans le thread o√π il a √©t√© interrompu.  L'impl√©mentation de cette logique donnera une version plus efficace du code de copie entre les threads: <br></p><pre> <code class="plaintext hljs">byte [] buffer = new byte[0x1000]; int numRead; while((numRead = await source.ReadAsync(buffer, 0, buffer.Length).ConfigureAwait(false)) &gt; 0) { await source.WriteAsync(buffer, 0, numRead).ConfigureAwait(false); }</code> </pre> <br><p>  Pour les d√©veloppeurs de biblioth√®ques, une telle acc√©l√©ration suffit en soi pour toujours penser √† utiliser ConfigureAwait, √† l'exception de rares conditions dans lesquelles la biblioth√®que en sait suffisamment sur le runtime et devra ex√©cuter la m√©thode avec acc√®s au contexte correct. </p><br><p>  Outre les performances, il existe une autre raison pour laquelle vous devez utiliser ConfigureAwait lors du d√©veloppement de biblioth√®ques.  Imaginez que la m√©thode CopyStreamToStreamAsync, impl√©ment√©e avec une version de code sans ConfigureAwait, est appel√©e √† partir d'un flux d'interface utilisateur dans WPF, par exemple, comme ceci: </p><br><pre> <code class="plaintext hljs">private void button1_Click(object sender, EventArgs args) { Stream src = ‚Ä¶, dst = ‚Ä¶; Task t = CopyStreamToStreamAsync(src, dst); t.Wait(); // deadlock! }</code> </pre> <br><p>  Dans ce cas, le programmeur devait √©crire button1_Click en tant que m√©thode asynchrone dans laquelle l'op√©rateur attend est cens√© ex√©cuter la t√¢che, et ne pas utiliser la m√©thode d'attente synchrone de cet objet.  La m√©thode Wait doit √™tre utilis√©e dans de nombreux autres cas, mais ce sera presque toujours une erreur de l'utiliser pour attendre dans un flux d'interface utilisateur, comme indiqu√© ici.  La m√©thode Wait ne reviendra pas tant que la t√¢che n'est pas termin√©e.  Dans le cas de CopyStreamToStreamAsync, son flux asynchrone tente de renvoyer l'ex√©cution avec l'envoi de donn√©es au SynchronizationContext captur√©, et ne peut pas terminer tant que ces transferts ne sont pas termin√©s (car ils sont n√©cessaires pour continuer son fonctionnement).  Mais ces exp√©ditions, √† leur tour, ne peuvent pas √™tre ex√©cut√©es, car le thread d'interface utilisateur qui doit les g√©rer est bloqu√© par l'appel d'attente.  Il s'agit d'une d√©pendance cyclique conduisant √† un blocage.  Si CopyStreamToStreamAsync est impl√©ment√© avec ConfigureAwait (false), il n'y aura ni d√©pendance ni blocage. </p><br><p>  <strong>ExecutionContext</strong> ExecutionContext est une partie importante du .NET Framework, mais la plupart des programmeurs ignorent encore parfaitement son existence. ExecutionContext ‚Äì  ,        SecurityContext  LogicalCallContext,   ,         .  ,    ThreadPool.QueueUserWorkItem, Task.Run, Delegate.BeginInvoke, Stream.BeginRead, WebClient.DownloadStringAsync      Framework,    ExecutionContext   ExecutionContext.Run ( ). ,  ,  ThreadPool.QueueUserWorkItem,  Windows  (identity),           WaitCallback.   ,   Task.Run    LogicalCallContext,         LogicalCallContext    Action. ExecutionContext     . </p><br><p>  Framework    ,          ExecutionContext,     ,      .     Windows      LogicalCallContext     .     (WindowsIdentity.Impersonate  CallContext.LogicalSetData)               . </p><br><h4 id="osvobodites-ot-sborki-musora">     </h4><br><p>        .    C#  Visual Basic     ,        .          await.  ,      ,    -   .   C#  Visual Basic  (¬´¬ª)      ,     await  (boxed)  ,     . </p><br><p>                  .   ,     . ,       ,     ,     . </p><br><p>       C#  Visual Basic      ,      . ,     </p><br><pre> <code class="plaintext hljs">public static async Task FooAsync() { var dto = DateTimeOffset.Now; var dt = dto.DateTime; await Task.Yield(); Console.WriteLine(dt); }</code> </pre> <br><p>    dto      await,     .    ,  , -    dto: </p><br><p> <strong>Figure 4</strong>    </p><br><pre> <code class="plaintext hljs">[StructLayout(LayoutKind.Sequential), CompilerGenerated] private struct &lt;FooAsync&gt;d__0 : &lt;&gt;t__IStateMachine { private int &lt;&gt;1__state; public AsyncTaskMethodBuilder &lt;&gt;t__builder; public Action &lt;&gt;t__MoveNextDelegate; public DateTimeOffset &lt;dto&gt;5__1; public DateTime &lt;dt&gt;5__2; private object &lt;&gt;t__stack; private object &lt;&gt;t__awaiter; public void MoveNext(); [DebuggerHidden] public void &lt;&gt;t__SetMoveNextDelegate(Action param0); }</code> </pre> <br><p>         ,     .   ,     ,  , ,        .       ,        : </p><br><pre> <code class="plaintext hljs">public static async Task FooAsync() { var dt = DateTimeOffset.Now.DateTime; await Task.Yield(); Console.WriteLine(dt); }</code> </pre> <br><p>  ,   .NET (GC)    ,  ,      ,  :      0,  ,    ,     (.NET GC    0, 1  2).      ,    GC        .     ,  ,   ,    ,     ,     ,   .     0,   ,    ,   .   ,     ,         ,    . </p><br><p>                (        ,       ).    JIT   ,        ,               ,        ,      .          ,    ,        .   ,      ,  ,     ,     .   ,          ,     .  ,  C#  Visual Basic        ,       ,     . </p><br><h4 id="izbegayte-slozhnosti">   </h4><br><p>  C#  Visual Basic  ,       awaits:  .   await      ,     Task  ,       ,  . ,   ,      : <br></p><pre> <code class="plaintext hljs">public static async Task&lt;int&gt; SumAsync(Task&lt;int&gt; a, Task&lt;int&gt; b, Task&lt;int&gt; c) { return Sum(await a, await b, await c); } private static int Sum(int a, int b, int c) { return a + b + c; }</code> </pre> <br><p>  C#     ‚Äúawait b‚Äù    Sum.      await,       Sum,  -       async ,   ¬´¬ª     await.    ,       await       .   ,  ,       CLR,    ,      ,       .         ,                 &lt;&gt;t__stack.         ,   ,   Tuple&lt;int, int&gt;             &lt;&gt;__stack.  ,     ,    ,          . ,    SumAsync : </p><br><pre> <code class="plaintext hljs">public static async Task&lt;int&gt; SumAsync(Task&lt;int&gt; a, Task&lt;int&gt; b, Task&lt;int&gt; c) { int ra = await a; int rb = await b; int rc = await c; return Sum(ra, rb, rc); }</code> </pre> <br><p>            ,   ra, rb  rc,    .  ,    :                   .          ,           ,        ,    .  ,           ,    ,       ,          . </p><br><p> ,        ,        .      Sum   ,    await   ,       .     ,    await   ,  .      await  ,      Task.WhenAll: </p><br><pre> <code class="plaintext hljs">public static async Task&lt;int&gt; SumAsync(Task&lt;int&gt; a, Task&lt;int&gt; b, Task&lt;int&gt; c) { int [] results = await Task.WhenAll(a, b, c); return Sum(results[0], results[1], results[2]); }</code> </pre> <br><p>  Task.WhenAll  Task&lt;TResult[]&gt;,    ,       ,     ,       .           .     ,         WhenAll,    Task  Task.        ,          ,    ,   ,   ,    WhenAll ,    .         WhenAll,     , ,   params,       .    ,  ,         .   Figure 5 <br></p><p> <strong>Figure 5</strong>     </p><br><pre> <code class="plaintext hljs">public static Task&lt;int&gt; SumAsync(Task&lt;int&gt; a, Task&lt;int&gt; b, Task&lt;int&gt; c) { return (a.Status == TaskStatus.RanToCompletion &amp;&amp; b.Status == TaskStatus.RanToCompletion &amp;&amp; c.Status == TaskStatus.RanToCompletion) ? Task.FromResult(Sum(a.Result, b.Result, c.Result)) : SumAsyncInternal(a, b, c); } private static async Task&lt;int&gt; SumAsyncInternal(Task&lt;int&gt; a, Task&lt;int&gt; b, Task&lt;int&gt; c) { await Task.WhenAll((Task)a, b, c).ConfigureAwait(false); return Sum(a.Result, b.Result, c.Result); }</code> </pre> <br><h4 id="asinhronnost-i-proizvoditelnost">    </h4><br><p>      ,           .  ,         .            ,            . ,      ,     :      ,      ,      /          ,       .     .NET Framework              ,       .   ,       .NET Framework,     .  ,  ,       Framework,   ,     ,  . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr458332/">https://habr.com/ru/post/fr458332/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr458316/index.html">Yandex Retro Games Battle 2019 - d√©veloppement de jeux pour ZX Spectrum</a></li>
<li><a href="../fr458324/index.html">Tout ce dont vous avez besoin pour commencer avec Vue.js</a></li>
<li><a href="../fr458326/index.html">Yandex ouvre des ensembles de donn√©es Toloka pour les chercheurs</a></li>
<li><a href="../fr458328/index.html">Comment dupliquer les objectifs de Yandex.Metrica dans Google Analytics</a></li>
<li><a href="../fr458330/index.html">Il n'y a pas de limite √† la perfection: comment les interfaces neuronales aident l'humanit√©</a></li>
<li><a href="../fr458334/index.html">R√©plication continue de l'ancien vers le nouveau PostgreSQL avec Slony</a></li>
<li><a href="../fr458336/index.html">Le cycle complet de d√©veloppement de produits informatiques en utilisant l'exemple de projet: r√¥les d'√©quipe, t√¢ches client, √©tapes</a></li>
<li><a href="../fr458338/index.html">Gestionnaire de s√©curit√© des applications. D√©veloppeur ou s√©curit√©?</a></li>
<li><a href="../fr458342/index.html">Texturation, ou ce que vous devez savoir pour devenir un artiste de surface. Partie 1. Pixel</a></li>
<li><a href="../fr458344/index.html">Utilisation de la messagerie asynchrone pour am√©liorer la disponibilit√©</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>