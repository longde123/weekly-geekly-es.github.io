<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游뗶 游둟游낗 游늾 La lucha por los recursos, parte 2: jugamos con la configuraci칩n de Cgroups 游댉 游 游</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Comenzamos a estudiar los Grupos de control (Cgroups) en Red Hat Enterprise Linux 7, un mecanismo a nivel de n칰cleo que le permite controlar el uso de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>La lucha por los recursos, parte 2: jugamos con la configuraci칩n de Cgroups</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/424367/">  Comenzamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">a estudiar los Grupos de control</a> (Cgroups) en Red Hat Enterprise Linux 7, un mecanismo a nivel de n칰cleo que le permite controlar el uso de los recursos del sistema, examin칩 brevemente los fundamentos te칩ricos y ahora pasa a la pr치ctica de administrar recursos de CPU, memoria y E / S. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mh/c7/4p/mhc74pjs5mq_w3d404hmfmxukfy.png"></div><br>  Sin embargo, antes de cambiar cualquier cosa, siempre es 칰til averiguar c칩mo est치 todo organizado ahora. <br><a name="habracut"></a><br>  Hay dos herramientas con las que puede ver el estado de los cgroups activos en el sistema.  En primer lugar, se trata de systemd-cgls, un comando que muestra una lista en forma de 치rbol de cgroups y procesos en ejecuci칩n.  Su salida se parece a esto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nt/i7/bk/nti7bkd9izxkgviokentn9myehw.png"></div><br>  Aqu칤 vemos los cgroups de nivel superior: user.slice y system.slice.  No tenemos m치quinas virtuales, por lo tanto, bajo carga, estos grupos de nivel superior reciben el 50% de los recursos de la CPU (ya que el segmento de la m치quina no est치 activo).  Hay dos segmentos secundarios en user.slice: user-1000.slice y user-0.slice.  Los segmentos de usuario se identifican mediante la ID de usuario (UID), por lo que identificar al propietario puede ser dif칤cil, excepto para ejecutar procesos.  En nuestro caso, las sesiones ssh muestran que el usuario 1000 es m치s rico y que el usuario 0 es root, respectivamente. <br><br>  El segundo comando que usaremos es systemd-cgtop.  Muestra una imagen del uso de recursos en tiempo real (la salida de systemd-cgls, por cierto, tambi칠n se actualiza en tiempo real).  En la pantalla, se ve as칤: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z5/pi/yh/z5piyhlyaj_f0noc3h0cgabpvue.png"></div><br>  Hay un problema con systemd-cgtop: muestra estad칤sticas solo para aquellos servicios y sectores para los que est치 habilitada la contabilidad de uso de recursos.  La contabilidad se habilita creando archivos conf de inserci칩n en los subdirectorios apropiados en / etc / systemd / system.  Por ejemplo, el men칰 desplegable en la siguiente captura de pantalla permite el uso de CPU y memoria para el servicio sshd.  Para hacerlo usted mismo, simplemente cree el mismo men칰 desplegable en un editor de texto.  Adem치s, la contabilidad tambi칠n se puede habilitar con la propiedad set-systemctl sshd.service CPUAccounting = true comando MemoryAccounting = true. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1n/9p/be/1n9pbeounuudbk5qlcqekxadnoo.png"></div><br>  Despu칠s de crear el men칰 desplegable, debe ingresar el comando systemctl daemon-reload, as칤 como el comando systemctl restart &lt;service_name&gt; para el servicio correspondiente.  Como resultado, ver치 estad칤sticas sobre el uso de los recursos, pero esto crear치 una carga adicional, ya que los recursos tambi칠n se gastar치n en contabilidad.  Por lo tanto, la contabilidad debe incluirse cuidadosamente y solo para aquellos servicios y grupos que necesitan ser monitoreados de esta manera.  Sin embargo, a menudo en lugar de systemd-cgtop, puede hacerlo con los comandos top o iotop. <br><br><h3>  Cambie las bolas de CPU para divertirse y ser 칰til </h3><br>  Ahora veamos c칩mo un cambio en la bola del procesador (recursos compartidos de la CPU) afecta el rendimiento.  Por ejemplo, tendremos dos usuarios sin privilegios y un servicio del sistema.  El usuario con el inicio de sesi칩n mrichter tiene un UID de 1000, que se puede verificar utilizando el archivo / etc / passwd. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ld/ia/dp/ldiadp_tvevimxoiu1_aiqnko-e.png"></div><br>  Esto es importante porque los segmentos de usuario se nombran por UID y no por nombre de cuenta. <br><br>  Ahora, repasemos el directorio desplegable y veamos si ya hay algo para su segmento. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/77/0b/7n/770b7nqx3kjyuebjwjf8tfcdtgu.png"></div><br>  No hay nada  Aunque hay algo m치s, eche un vistazo a las cosas relacionadas con foo.service: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i2/wj/ie/i2wjiei6venywdoook6pvb6qzby.png"></div><br>  Si est치 familiarizado con los archivos de unidad systemd, ver치 aqu칤 un archivo de unidad completamente ordinario que ejecuta el comando / usr / bin / sha1sum / dev / zero como un servicio (en otras palabras, un demonio). Para nosotros, lo importante es que foo tomar치 literalmente todos los recursos del procesador que el sistema le permitir치 usar.  Adem치s, aqu칤 tenemos un ajuste directo para el servicio foo, el valor de las bolas de CPU es igual a 2048. De forma predeterminada, como recordar치, se usa con el valor 1024, por lo que bajo carga foo recibir치 una doble participaci칩n de los recursos de la CPU dentro del sistema. , su segmento principal de nivel superior (ya que foo es un servicio). <br><br>  Ahora ejecuta foo a trav칠s de systemctl y mira lo que nos muestra el comando superior: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yj/ay/re/yjayreeugvlhzfoyuvsu4jbuopa.png"></div><br>  Como pr치cticamente no hay otras cosas que funcionen en el sistema, el servicio foo (pid 2848) consume casi todo el tiempo de procesador de una CPU. <br><br>  Ahora vamos a introducir mrichter en la ecuaci칩n del usuario.  Primero, le cortamos una bola de CPU hasta 256, luego inicia sesi칩n e inicia foo.exe, en otras palabras, el mismo programa, pero como un proceso de usuario. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/v4/ga/rp/v4garp2tjh-dkxbutnjzjvk-mtc.png"></div><br>  Entonces mrichter lanz칩 foo.  Y aqu칤 est치 lo que muestra el comando superior: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qj/vh/_d/qjvh_d9glhvigqombngeti5xvos.png"></div><br>  Extra침o, 쯘h?  El usuario mrichter parece obtener aproximadamente el 10 por ciento del tiempo del procesador, ya que tiene = 256 bolas, y foo.service tiene hasta 2048, 쯡o? <br><br>  Ahora introducimos dorf en la ecuaci칩n.  Este es otro usuario normal con una bola de CPU est치ndar igual a 1024. Tambi칠n ejecutar치 foo, y nuevamente veremos c칩mo cambiar치 la distribuci칩n del tiempo del procesador. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bz/54/lu/bz54lujtxyjcwfqf17sztisnj3e.png"></div><br>  dorf es un usuario de la vieja escuela, solo comienza el proceso, sin ning칰n script inteligente ni nada m치s.  Y de nuevo nos fijamos en la salida de arriba: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ov/mn/bz/ovmnbzbrdvfnhqpz2o4quzkhjb0.png"></div><br>  Entonces ... echemos un vistazo al 치rbol de cgroups e intentemos averiguar qu칠 es qu칠: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1j/qd/wz/1jqdwzweorfw_yrtbl31ga0cfj0.png"></div><br>  Si recuerda, generalmente en un sistema hay tres cgroups de nivel superior: Sistema, Usuario y M치quina.  Como no hay m치quinas virtuales en nuestro ejemplo, solo quedan segmentos del sistema y del usuario.  Cada uno de ellos tiene una bola de CPU de 1024 y, por lo tanto, bajo carga recibe la mitad del tiempo del procesador.  Como foo.service vive en el sistema y no hay otros candidatos para el tiempo de CPU en este segmento, foo.service recibe el 50% de los recursos de la CPU. <br><br>  Adem치s, los usuarios dorf y mrichter viven en la secci칩n Usuario.  La primera bola es 1024, la segunda - 256. Por lo tanto, dorf obtiene cuatro veces m치s tiempo de procesador que mrichter.  Ahora veamos qu칠 muestra la parte superior: foo.service - 50%, dorf - 40%, mrichter - 10%. <br><br>  Traduciendo esto a un lenguaje de casos de uso, podemos decir que dorf tiene una prioridad m치s alta.  En consecuencia, los cgroups est치n configurados para que el usuario mrichter reduzca los recursos por el tiempo que necesitan dorf'u.  De hecho, despu칠s de todo, mientras mrichter estaba solo en el sistema, recibi칩 el 50% del tiempo del procesador, ya que en el segmento de Usuario nadie m치s compiti칩 por los recursos de la CPU. <br><br>  De hecho, las bolas de CPU son una forma de proporcionar un cierto "m칤nimo garantizado" de tiempo de procesador, incluso para usuarios y servicios con menor prioridad. <br><br>  Adem치s, tenemos una manera de establecer una cuota fija para los recursos de la CPU, un cierto l칤mite en n칰meros absolutos.  Haremos esto para el usuario mrichter y veremos c칩mo cambia la distribuci칩n de recursos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bu/zd/ni/buzdnitn6z8eda2fr7lrhy4vd9q.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/s3/uy/os/s3uyosq5pxft-3math1cev5bqiy.png"></div><br>  Ahora eliminemos las tareas del usuario dorf, y esto es lo que sucede: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sq/bd/4s/sqbd4s0k8hgchpuwnkw06jncqqc.png"></div><br>  Para mrichter, el l칤mite absoluto de la CPU es del 5%, por lo que foo.service obtiene el resto del tiempo del procesador. <br><br>  Contin칰e intimidando y detenga foo.service: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/y1/y8/8_/y1y88_nywde7vz7aufqa4jxfaqg.png"></div><br>  Lo que vemos aqu칤: mrichter tiene el 5% del tiempo del procesador, y el 95% restante del sistema est치 inactivo.  Burla formal, s칤. <br><br>  De hecho, este enfoque le permite pacificar de manera efectiva los servicios o aplicaciones que les gusta cambiar repentinamente y utilizar todos los recursos del procesador en detrimento de otros procesos. <br><br>  Entonces, aprendimos a controlar la situaci칩n actual con cgroups.  Ahora profundizamos un poco m치s y vemos c칩mo se implementa cgroup en el nivel del sistema de archivos virtual. <br><br>  El directorio ra칤z para todos los cgroups en ejecuci칩n se encuentra en / sys / fs / cgroup.  Cuando el sistema arranca, se llena cuando comienzan los servicios y otras tareas.  Al iniciar y detener servicios, sus subdirectorios aparecen y desaparecen. <br><br>  En la siguiente captura de pantalla, fuimos a un subdirectorio para el controlador de la CPU, es decir, en el segmento del sistema.  Como puede ver, el subdirectorio para foo a칰n no est치 aqu칤.  Ejecute foo y verifique un par de cosas, a saber, su PID y su bola de CPU actual: <br><br><img src="https://habrastorage.org/webt/l1/ac/ms/l1acmsfmdl-co5sstjuy0lbpo5y.png"><br><br>  Advertencia importante: aqu칤 puede cambiar los valores sobre la marcha.  S칤, en teor칤a se ve genial (y en realidad tambi칠n), pero puede convertirse en un gran desastre.  Por lo tanto, antes de cambiar algo, sopesa todo cuidadosamente y nunca juegues en servidores de batalla.  Pero de todos modos, un sistema de archivos virtual es algo para profundizar a medida que aprende c칩mo funcionan los cgroups. <br><br><ul><li>  Parte 1 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">habr.com/company/redhatrussia/blog/423051</a> </li><li>  Parte 3 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">habr.com/company/redhatrussia/blog/425803</a> </li><li>  Parte 4 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">habr.com/company/redhatrussia/blog/427413</a> </li><li>  Parte 5 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">habr.com/company/redhatrussia/blog/429064</a> </li><li>  Parte 6 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">habr.com/company/redhatrussia/blog/430748</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es424367/">https://habr.com/ru/post/es424367/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es424353/index.html">Antecedentes: el buscador estatal de Internet Sputnik y su compleja historia</a></li>
<li><a href="../es424355/index.html">Moldeo por inyecci칩n: como funciona</a></li>
<li><a href="../es424361/index.html">C칩mo la gamificaci칩n mejora la experiencia del usuario</a></li>
<li><a href="../es424363/index.html">"Si quieres crear algo realmente genial, necesitas profundizar y saber c칩mo funciona tu c칩digo en el sistema, en el hardware"</a></li>
<li><a href="../es424365/index.html">C칩mo funciona el seguimiento de pila en ARM</a></li>
<li><a href="../es424369/index.html">Mi archivo favorito en la base de c칩digo de Chromium</a></li>
<li><a href="../es424371/index.html">Implementar vCloud Extender</a></li>
<li><a href="../es424373/index.html">D칩nde trabajar en TI, problema 1: Voximplant</a></li>
<li><a href="../es424375/index.html">Revisi칩n del moldeador al vac칤o Mayku FormBox: deje que las piezas se propaguen</a></li>
<li><a href="../es424377/index.html">Playme TIO review: DVR de montaje magn칠tico de alta gama</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>