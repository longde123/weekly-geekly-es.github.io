<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤¶ğŸ¾ ğŸš´ğŸ½ ğŸ˜ˆ Kami bekerja di konsol dengan cepat dan efisien ğŸ˜ ğŸ¦• ğŸ‘¨ğŸ¾â€ğŸ¤â€ğŸ‘¨ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di jaringan, Anda dapat menemukan banyak kiat untuk bekerja secara efektif di konsol. Dalam sebagian besar artikel ini, penulis berbicara tentang kata...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami bekerja di konsol dengan cepat dan efisien</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425137/"><p> Di jaringan, Anda dapat menemukan banyak kiat untuk bekerja secara efektif di konsol.  Dalam sebagian besar artikel ini, penulis berbicara tentang kata-kata hampa seperti "belajar kunci panas" atau " <code>sudo !!</code> akan menjalankan perintah terakhir di bawah sudo".  Saya akan memberi tahu Anda apa yang harus dilakukan ketika Anda sudah mempelajari tombol pintas dan tahu tentang <code>sudo !!</code>  . </p><a name="habracut"></a><br><h3 id="terminal-dolzhen-zapuskatsya-mgnovenno">  Terminal harus mulai secara instan </h3><br><p>  Berapa lama Anda perlu memulai terminal?  Dan satu lagi?  Untuk waktu yang lama, terminal saya diluncurkan oleh Ctrl + Alt + T dan saya pikir itu cepat.  Tetapi ketika saya pindah dari Openbox ke i3, saya mulai menjalankan terminal melalui Win + Enter, kombinasi ini berada di konfigurasi default.  Dan tahukah Anda?  Saya tidak lagi berpikir bahwa Ctrl + Alt + T cepat. </p><br><p>  Tentu saja, leluconnya bukan untuk mendapatkan milidetik, tetapi pada kenyataan bahwa Anda membuka terminal pada tingkat refleks, sama sekali tidak memperhatikannya. </p><br><p>  Jika Anda sering bekerja di terminal, tetapi meraih mouse untuk meluncurkannya, maka cobalah mengatur hotkey yang nyaman.  Saya yakin Anda akan menyukainya. </p><br><h3 id="zsh-vmesto-bash">  Zsh bukannya bash </h3><br><p>  Ini adalah tema hollywood, saya tahu.  Zsh harus diinstal setidaknya untuk tiga fitur: lanjutkan otomatis, koreksi salah ketik dan penyelesaian beberapa pathname: ketika satu Tab mengubah <code>/u/s/d</code> menjadi <code>/usr/share/doc</code> .  Arch Linux telah lama beralih ke zsh dalam disk instalasinya.  Saya harap suatu hari nanti zsh akan menjadi shell default di Ubuntu.  Ini akan menjadi momen bersejarah. </p><br><p>  Memulai dengan zsh sama sekali tidak sulit.  Instal melalui manajer paket dan ambil beberapa konfigurasi yang sudah jadi.  Saya merekomendasikan konfigurasi yang digunakan oleh Arch Linux: </p><br><pre> <code class="plaintext hljs">wget -O ~/.zshrc https://git.grml.org/f/grml-etc-core/etc/zsh/zshrc</code> </pre> <br><p>  Tetap hanya untuk mengubah "shell default" menjadi zsh dan masuk. </p><br><pre> <code class="plaintext hljs">chsh -s $(which zsh)</code> </pre> <br><p>  Segalanya, terus bekerja seolah-olah tidak ada yang terjadi. </p><br><h3 id="kakim-dolzhen-byt-shell-prompt">  Apa yang seharusnya menjadi shell prompt </h3><br><p>  Prompt shell adalah teks kecil yang muncul di terminal sebelum perintah Anda.  Itu perlu disesuaikan dengan karakter pekerjaan Anda.  Anggap saja seperti dashboard mobil.  Letakkan informasi yang berguna di sana, biarkan itu membantu Anda menavigasi.  Jadikan nyaman, terutama jika Anda melihatnya setiap hari! </p><br><p>  Shell prompt akan menampilkan direktori shell saat ini.  Jika direktori saat ini tidak ditampilkan di prompt shell, Anda harus menyimpannya di kepala Anda dan secara berkala memeriksanya dengan <code>pwd</code> .  Jangan lakukan itu.  Ingatlah hal-hal yang lebih penting dan jangan buang waktu dengan <code>pwd</code> . </p><br><p>  Jika Anda secara berkala beralih dari pengguna ke root, Anda perlu indikasi pengguna saat ini.  Seringkali penting bukan nama pengguna spesifik, tetapi statusnya (reguler atau root).  Cara termudah untuk melakukan ini adalah warna: prompt shell merah di root, hijau di penggunanya.  Jadi Anda tidak akan pernah mengacaukan shell root dengan yang biasa. </p><br><p>  Jika Anda terhubung ke server melalui ssh, maka Anda perlu membedakan shell lokal Anda dari server.  Untuk melakukan ini, shell prompt harus berisi nama host, atau lebih baik lagi, indikator koneksi ssh. </p><br><p>  Shell prompt dapat menampilkan kode kembali dari perintah terakhir.  Biarkan saya mengingatkan Anda bahwa kode pengembalian nol berarti bahwa perintah selesai dengan sukses, bukan nol - perintah gagal.  Kode pengembalian untuk perintah terakhir dapat ditemukan dengan <code>echo $?</code>  , tetapi mengetik semuanya di keyboard terlalu panjang.  Lebih baik, prompt shell akan memberi tahu Anda jika perintah gagal. </p><br><p>  Jika Anda bekerja dengan repositori git, maka akan berguna untuk menampilkan status repositori di prompt shell: cabang saat ini dan status direktori kerja.  Dengan cara ini Anda akan menghemat waktu pada <code>git status</code> <code>git branch</code> dan perintah-perintah <code>git branch</code> dan tidak akan salah dalam cabang saat melakukan. </p><br><p>  Seseorang menambahkan jam atau nama terminal virtual (tty), atau beberapa coretan arbitrary ke prompt shell mereka.  Ini semua berlebihan.  Lebih baik meninggalkan lebih banyak ruang untuk tim. </p><br><p>  Shell prompt saya dalam kondisi yang berbeda terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/webt/ka/q3/gf/kaq3gfz9idb6pkxdglx44qyuxlq.png"></p><br><p>  Tangkapan layar menunjukkan bahwa judul jendela terminal melakukan tugas yang serupa.  Ini juga merupakan bagian dari dasbor dan juga dapat disesuaikan. </p><br><p>  Bagaimana menerapkan semua ini di <code>.zshrc</code> Anda?  Variabel <code>PROMPT</code> bertanggung jawab untuk prompt kiri, dan <code>RPROMPT</code> untuk <code>RPROMPT</code> kanan.  Variabel <code>EUID</code> akan membantu menentukan status pengguna (reguler atau <code>EUID</code> , dan keberadaan koneksi ssh - <code>SSH_CLIENT</code> atau <code>SSH2_CLIENT</code> .  Kami mendapatkan benda kerja berikut: </p><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ -n <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$SSH_CLIENT</span></span></span><span class="hljs-string">"</span></span> || -n <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$SSH2_CLIENT</span></span></span><span class="hljs-string">"</span></span> ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">$EUID</span></span> == 0 ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> PROMPT=... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> PROMPT=... <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment"># not SSH if [[ $EUID == 0 ]]; then PROMPT=... else PROMPT=... fi fi</span></span></code> </pre> <br><p>  Saya tidak secara spesifik menunjukkan kode yang siap untuk disalin-tempel, karena implementasi khusus adalah masalah selera.  Jika Anda tidak ingin repot dan tangkapan layar saya tidak membuat Anda jijik, Anda dapat mengambil konfigurasi dari <a href="">github</a> . </p><br><p>  Ringkasan: </p><br><ul><li>  Minimum yang diperlukan adalah direktori saat ini. </li><li>  Cangkang mulut harus terlihat jelas. </li><li>  Nama pengguna tidak membawa muatan jika Anda selalu duduk di bawah pengguna yang sama. </li><li>  Hostname berguna jika Anda terhubung ke server melalui SSH.  Tidak diperlukan jika Anda selalu bekerja pada mesin yang sama. </li><li>  Penyelesaian perintah terakhir yang gagal berguna untuk segera dilihat. </li><li>  Status repositori git menghemat waktu pada <code>git status</code> <code>git branch</code> dan perintah <code>git branch</code> dan merupakan perlindungan tambahan terhadap si bodoh. </li></ul><br><h3 id="aktivnoe-ispolzovanie-istorii-komand">  Penggunaan aktif riwayat perintah </h3><br><p>  Sebagian besar perintah dalam hidup Anda, Anda masukkan lebih dari sekali, yang berarti akan lebih mudah untuk menariknya keluar dari sejarah daripada mengetik lagi.  Semua shell modern dapat mengingat sejarah tim dan menyediakan beberapa cara untuk mencari sejarah ini. </p><br><p>  Mungkin Anda sudah tahu cara menggali cerita dengan Ctrl + R.  Ini memiliki dua kelemahan signifikan: </p><br><ol><li>  Untuk memulai pencarian, bidang input harus kosong.  Yaitu  dalam kasus "Saya mulai mengetik perintah - Saya ingat tentang pencarian" Anda harus menghapus apa yang telah dimulai, tekan Ctrl + R dan ulangi entri.  Ini waktu yang sangat lama. </li><li>  Pencarian maju tidak bekerja secara default, karena  Ctrl + S menghentikan terminal. </li></ol><br><p>  Cara kerja pencarian tercepat dan paling nyaman: </p><br><ol><li>  Anda mulai mengetik tim </li><li>  Apakah Anda ingat pencarian? </li><li>  Anda menekan tombol pintas dan shell menawarkan tim dari sejarah yang memulai persis sama. </li></ol><br><p>  Misalnya, Anda ingin menyinkronkan direktori lokal dengan direktori jarak jauh menggunakan <code>rsync</code> .  Anda sudah melakukan ini beberapa jam yang lalu dan ingin mengeluarkan tim dari sejarah.  Ketik <code>rsync</code> , tekan kombinasi tertentu sekali atau dua kali, dan perintah yang dihargai siap dijalankan.  Anda tidak perlu mengaktifkan mode pencarian riwayat terlebih dahulu, prompt shell tidak berubah menjadi <code>(reverse-i-search)':</code> , tidak ada yang melompat di mana pun.  Anda hanya mengulangi perintah dari cerita.  Sama seperti panah â†‘ â†“, Anda mengulangi perintah yang dimasukkan sebelumnya, hanya dengan filter di awal perintah.  Sangat nyaman dan menghemat banyak waktu. </p><br><p>  Dalam cangkang ikan dan ipython, pencarian semacam itu sudah ditugaskan untuk panah.  Saya pikir banyak beralih ke ikan hanya demi perilaku panah seperti itu. </p><br><p>  Di bash dan zsh, secara default, pencarian ini tidak berfungsi, Anda harus mengaktifkannya dengan tangan.  Saya mengkonfigurasi PgUp untuk mencari mundur dan PgDown untuk mencari maju.  Jauh untuk menjangkau mereka, tetapi saya sudah terbiasa.  Mungkin di masa depan saya akan menetapkan kembali untuk sesuatu yang lebih dekat, misalnya, Ctrl + P dan Ctrl + N. </p><br><p>  Untuk bash, Anda perlu menambahkan beberapa baris ke <code>/etc/inputrc</code> atau <code>~/.inputrc</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-string"><span class="hljs-string">"\e[5~"</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-search-backward <span class="hljs-string"><span class="hljs-string">"\e[6~"</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-search-forward</code> </pre> <br><p>  Jika Anda sudah siap <code>zshrc</code> , maka pencarian kemungkinan besar sudah ditugaskan ke PgUp dan PgDown.  Jika tidak, tambahkan ke <code>~/.zshrc</code> </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">bindkey</span></span> <span class="hljs-string"><span class="hljs-string">"^[[5~"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-beginning-search-backward <span class="hljs-comment"><span class="hljs-comment"># pg up bindkey "^[[6~" history-beginning-search-forward # pg down</span></span></code> </pre> <br><p>  Sangat mengherankan bahwa seiring waktu saya mulai menulis tim berdasarkan asumsi bahwa nantinya saya akan mengambilnya dari sejarah.  Berikut ini beberapa trik: </p><br><p>  <strong>Menggabungkan tim</strong> yang selalu mengeksekusi satu demi satu </p><br><pre> <code class="plaintext hljs">ip link set eth1 up &amp;&amp; dhclient eth1 mkdir /tmp/t &amp;&amp; mount /dev/sdb1 /tmp/t</code> </pre> <br><p>  <strong>Path absolut alih-alih yang relatif</strong> memungkinkan Anda menjalankan perintah dari direktori apa pun: <br>  <code>vim ~/.ssh/config</code> alih-alih <code>vim .ssh/config</code> , <code>systemd-nspawn /home/chroot/stretch</code> bukan <code>systemd-nspawn /home/chroot/stretch</code> <code>systemd-nspawn stretch</code> , dll. </p><br><p>  <strong>Topeng wildcard</strong> membuat tim lebih fleksibel.  Biasanya digunakan dengan <code>chmod</code> dan <code>chown</code> . </p><br><pre> <code class="plaintext hljs">chown root:root /var/www/*.sq &amp;&amp; chmod 644 /var/www/*.sq</code> </pre> <br><h3 id="goryachie-klavishi">  Tombol cepat </h3><br><p>  Saya akan mencantumkan minimum yang diperlukan. </p><br><p>  Alt +.  - Mengganti argumen terakhir dari perintah sebelumnya.  Anda juga dapat mengetik urutannya <code>!$</code> . <br>  Ctrl + A, Ctrl + E - pergi ke awal dan akhir dari perintah yang diedit, masing-masing. <br>  Ctrl + U, Ctrl + Y - potong semuanya ke clipboard, rekatkan dari clipboard.  Ini membantu ketika Anda mencetak perintah yang rumit, dan kemudian Anda mengerti bahwa Anda perlu menjalankan yang lain di depannya.  Hmm, di mana menyembunyikan input saat ini?  Di sini dan bersembunyi. <br>  Ctrl + W - menghapus satu kata di sebelah kiri kursor.  Jika dijepit dan ditahan, cepat-cepat menghapus baris perintah.  Secara default, teks tidak dihapus, tetapi ditempatkan di buffer (yang untuk Ctrl + Y). <br>  Ctrl + K - menghapus dari kursor ke akhir baris.  Ctrl + A, Ctrl + K dengan cepat menghapus baris perintah. <br>  PgUp, PgDown, Ctrl + R - cari berdasarkan sejarah. <br>  Ctrl + L - hapus terminal. </p><br><h3 id="otzyvchivost-klaviatury">  Keyboard responsif </h3><br><p>  Saya akan memberi tahu Anda tentang pengaturan kecil, yang memungkinkan Anda untuk menggulir lebih cepat, bergerak di sekitar teks atau menghapus.  Apa yang kita lakukan ketika kita ingin menghapus sesuatu yang lama?  Tahan Backspace dan perhatikan bagaimana kursor berjalan kembali, mengambil surat tambahan.  Apa yang terjadi dengan ini?  Ketika Backspace ditekan, satu karakter terhapus, lalu ada sedikit keterlambatan, kemudian ulang otomatis dipicu: Backspace menghapus karakter satu per satu, seolah-olah mereka terus-menerus mengetuknya. </p><br><p>  Saya sarankan menyesuaikan penundaan dan tingkat pengulangan otomatis ke kecepatan jari Anda.  Penundaan sebelum coba ulang otomatis diperlukan ketika Anda ingin menghapus hanya satu karakter - ini memberi Anda waktu untuk melepaskan kunci.  Penundaan yang terlalu lama membuat menunggu pengulangan otomatis.  Tidak cukup lama untuk mengganggu, tetapi cukup untuk memperlambat pemindahan pikiran dari kepala ke komputer.  Semakin tinggi frekuensi pengulangan, semakin cepat teks dihapus, dan semakin sulit untuk menghentikan proses ini pada waktunya.  Inti dari pengaturan adalah menemukan jalan tengah. </p><br><p>  Jadi perintah ajaib: </p><br><pre> <code class="plaintext hljs">xset r rate 190 20</code> </pre> <br><p>  190 - durasi penundaan dalam milidetik, <br>  20 - frekuensi dalam jumlah pengulangan per detik. </p><br><p>  Saya sarankan mulai dengan nilai-nilai ini dan secara bertahap mengurangi penundaan sampai positif palsu muncul, lalu sedikit kembali.  Jika Anda mengatur penundaan yang sangat singkat, maka keyboard akan menjadi tidak mungkin digunakan.  Anda harus memulai ulang server X atau seluruh komputer.  Jadi berhati-hatilah. </p><br><p>  Untuk menyimpan parameter, tambahkan perintah ini di suatu tempat ke X-start otomatis. </p><br><h3 id="indikator-zaversheniya-processa">  Bilah kemajuan </h3><br><p>  Saya cukup sering harus memulai proses panjang: beberapa jenis cetak tebal, menyalin melalui jaringan, membongkar / mengemas arsip, membangun paket, dll.  Biasanya saya memulai proses seperti itu, beralih ke tugas lain dan secara berkala melihat apakah proses panjang saya telah berakhir.  Kebetulan saya membenamkan diri dalam pekerjaan dan melupakannya.  Solusinya adalah dengan menambahkan pemberitahuan penyelesaian proses, yang akan membuat saya keluar dari trance. </p><br><p>  Anda dapat menggunakan alat yang berbeda untuk ini: notify-send, dzen2, beep, aplay.  Semuanya bagus dengan caranya sendiri, tetapi jangan bekerja pada ssh.  Karena itu, saya menggunakan bip terminal: </p><br><pre> <code class="plaintext hljs">long-running-command; echo $'\a'</code> </pre> <br><p>  Dalam pengkodean ASCII, ada karakter 0x7 yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bel</a> .  Ini dirancang untuk berbunyi bip dengan speaker PC.  Speaker PC tidak mutakhir, tidak ada di mana-mana, dan masih belum terdengar di headphone.  Oleh karena itu, beberapa terminal menggunakan apa yang disebut bel visual.  Saya menggunakan urxvt dan itu membuat bel visual mengaktifkan bendera urgensi.  Ini adalah saat sebuah jendela memberi tahu Anda bahwa itu perlu perhatian. </p><br><p>  Anda dapat memeriksa sekarang bagaimana terminal Anda bereaksi terhadap simbol bel: </p><br><pre> <code class="plaintext hljs">sleep 3; echo $'\a'</code> </pre> <br><p>  Tiga detik diberikan bagi Anda untuk beralih ke jendela lain, jika tidak mungkin tidak bekerja. </p><br><p>  Sayangnya, bel visual melalui urgensi tidak tersedia di semua terminal.  Saya memeriksa yang paling populer. </p><br><table><thead><tr><th>  terminal </th><th>  bel visual melalui urgensi </th></tr></thead><tbody><tr><td>  konsole </td><td>  termasuk dalam pengaturan </td></tr><tr><td>  urxvt </td><td>  ada disana </td></tr><tr><td>  terminal xfce4 </td><td>  termasuk dalam pengaturan </td></tr><tr><td>  xterm </td><td>  tidak </td></tr><tr><td>  istilah retro keren </td><td>  tidak </td></tr><tr><td>  Lxterminal </td><td>  tidak </td></tr><tr><td>  terminal gnome </td><td>  tidak </td></tr></tbody></table><br><p>  Butuh waktu terlalu lama untuk menulis <code>echo $'\a'</code> , jadi saya membuat alias <code>wake</code> . </p><br><h3 id="aliasy">  Alias </h3><br><p>  Perintah <code>cp</code> , <code>scp</code> dan <code>rm</code> harus selalu bekerja secara rekursif.  Argumen <code>-r</code> hanya warisan yang buruk!  Masih ada alasan untuk <code>cp</code> : </p><br><pre> <code class="plaintext hljs">cp * foodir</code> </pre> <br><p>  itu hanya menyalin file ke foodir, dan dengan <code>-r</code> switch, ia akan berpikir bahwa Anda memutuskan untuk menyalin foodir ke dirinya sendiri.  Tetapi seberapa sering Anda membutuhkan fitur ini? </p><br><p>  <code>rm</code> dan <code>scp</code> tidak punya alasan apa pun, mereka hanya membosankan!  Perintah <code>mkdir</code> memiliki situasi yang mirip dengan <code>-p</code> switch.  Jadi jangan ragu untuk menambahkan ke <code>~/.zshrc</code> </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> cp=<span class="hljs-string"><span class="hljs-string">'cp -r'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> scp=<span class="hljs-string"><span class="hljs-string">'scp -r'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> rm=<span class="hljs-string"><span class="hljs-string">'rm -r'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> mkdir=<span class="hljs-string"><span class="hljs-string">'mkdir -p'</span></span></code> </pre> <br><p>  Wow, bagaimana saya hidup tanpa ini sebelumnya!  Anda dapat melangkah lebih jauh dan menambahkan <code>-f</code> ke <code>rm</code> , tetapi dengan risiko dan risiko Anda sendiri.  Saya menahan diri untuk saat ini. </p><br><p>  Anda kemungkinan besar sudah menggunakan variasi <code>ls</code> berbeda, karena ini adalah alias yang paling populer. </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> ls=<span class="hljs-string"><span class="hljs-string">'ls -F --color=auto'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> la=<span class="hljs-string"><span class="hljs-string">'ls -A --color=auto'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> ll=<span class="hljs-string"><span class="hljs-string">'ls -l --color=auto -h'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> lla=<span class="hljs-string"><span class="hljs-string">'ll -A --color=auto -h'</span></span></code> </pre> <br><p>  Nah, grep warna jauh lebih bagus daripada tidak berwarna: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> grep=<span class="hljs-string"><span class="hljs-string">'grep --colour=auto'</span></span></code> </pre> <br><p>  Jangan lupa bahwa alias tidak berfungsi dalam skrip!  Semua kunci harus ditentukan di sana. </p><br><h3 id="slepoy-metod-pechati">  Metode Pencetakan Buta </h3><br><p>  Tidak peduli seberapa basi itu, tetapi metode pencetakan sepuluh jari yang buta memungkinkan Anda untuk mencetak lebih cepat.  Pada awalnya akan sulit, tetapi seiring waktu Anda akan mempercepat ke kecepatan yang belum pernah terjadi sebelumnya. </p><br><p>  Menguasai metode pencetakan buta adalah yang terbaik untuk liburan atau liburan ketika tidak ada yang terburu-buru.  Dalam proses belajar, tidak mungkin tidak terburu-buru.  Tugas Anda adalah <em>mengingat</em> di mana surat itu berada.  Dan tidak dengan otak seperti halnya dengan otot.  Lebih baik mengetik perlahan tapi tanpa kesalahan daripada cepat dengan kesalahan.  Ingat: master mencapai kecepatan tinggi bukan dengan mengorbankan jari cepat, tetapi karena mereka tidak melakukan kesalahan. </p><br><p>  Jangan terbawa pada awalnya dengan pemain keyboard.  Secara psikologis sulit untuk tetap tenang selama kompetisi.  Belajar di simulator.  Ini bagus ketika simulator menawarkan kata-kata yang dapat diucapkan secara mental.  Saya belajar di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">vse10</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengetik</a> simulator online.  Simulator â€œSolo on the Keyboardâ€ yang terkenal itu tampak bodoh bagi saya. </p><br><p>  Layak dimulai dengan deretan pusat Fyvaprolge.  Hanya setelah Anda ingat di mana kunci itu berada, apakah itu layak untuk dipindahkan.  Baru setelah itu. </p><br><p>  Beristirahatlah.  Istirahatkan otak dan jari Anda.  Rasakan bahwa kesalahan telah terjadi - saatnya untuk istirahat. </p><br><p>  Pada awalnya, saya menguasai metode pencetakan buta dalam bahasa Rusia dan mulai dengan akselerasi.  Sekarang saya meningkatkan keterampilan saya dalam tata letak bahasa Inggris. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425137/">https://habr.com/ru/post/id425137/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425125/index.html">@Pythonetc September 2018</a></li>
<li><a href="../id425129/index.html">Bagaimana cara mengotomatisasi pembuatan mesin virtual? Kami memberi tahu secara detail</a></li>
<li><a href="../id425131/index.html">Apa yang harus dibaca tentang teknologi blockchain: panduan, buku, dan artikel</a></li>
<li><a href="../id425133/index.html">Masalah pembayaran lintas batas - mengapa dan bagaimana blockchain digunakan di sini</a></li>
<li><a href="../id425135/index.html">Mengapa VoIP diakui sebagai layanan informasi di AS, dan apa artinya bagi industri dan pengguna telekomunikasi</a></li>
<li><a href="../id425139/index.html">Bintang pop di bawah lensa kecerdasan buatan</a></li>
<li><a href="../id425141/index.html">"Menghadapi Guido What You Tell Him" â€‹â€‹atau Percakapan Python dengan Bobuk</a></li>
<li><a href="../id425143/index.html">Sekolah Tinggi Ekonomi menolak kuliah yang mendukung kursus online</a></li>
<li><a href="../id425145/index.html">Pergi yang luar biasa</a></li>
<li><a href="../id425149/index.html">Antara langit dan bumi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>