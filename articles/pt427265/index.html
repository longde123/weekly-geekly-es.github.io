<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§Ωüèª üê∑ üìü Protobuffers est√£o errados üôà üÜë üôèüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Na maior parte da minha vida profissional, sou contra o uso de buffers de protocolo. Eles s√£o claramente escritos por amadores, incrivelmente altament...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Protobuffers est√£o errados</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427265/"> Na maior parte da minha vida profissional, sou contra o uso de buffers de protocolo.  Eles s√£o claramente escritos por amadores, incrivelmente altamente especializados, sofrem de muitas armadilhas, s√£o dif√≠ceis de compilar e resolver um problema que ningu√©m al√©m do Google realmente tem.  Se esses problemas dos proto-buffers permanecessem na quarentena das abstra√ß√µes de serializa√ß√£o, minhas reivindica√ß√µes terminariam a√≠.  Infelizmente, por√©m, o design inadequado dos protobuffers √© t√£o intrusivo que esses problemas podem vazar para o seu c√≥digo. <br><br>  <b>Estreita especializa√ß√£o e desenvolvimento por amadores</b> <br><br>  Pare.  Feche o seu cliente de e-mail onde voc√™ j√° me escreveu uma carta dizendo que "os melhores engenheiros do mundo trabalham no Google", que "seus projetos, por defini√ß√£o, n√£o podem ser criados por amadores".  Eu n√£o quero ouvir isso. <br><br>  Vamos apenas n√£o discutir este t√≥pico.  Divulga√ß√£o completa: eu trabalhava no Google.  Este foi o primeiro (mas infelizmente n√£o o √∫ltimo) lugar que eu j√° usei Protobuffers.  Todos os problemas sobre os quais eu quero falar existem na base de c√≥digo do Google;  n√£o √© apenas "uso indevido de protobuffers" e coisas do g√™nero. <br><a name="habracut"></a><br>  De longe, o maior problema com os Protobuffers √© o terr√≠vel sistema de tipos.  Os f√£s de Java devem se sentir em casa aqui, mas infelizmente, literalmente, ningu√©m acha que Java √© um sistema de tipo bem projetado.  Os caras do campo de digita√ß√£o din√¢mico reclamam de restri√ß√µes desnecess√°rias, enquanto os representantes do campo de digita√ß√£o est√°tico, como eu, reclamam de restri√ß√µes desnecess√°rias e da falta de tudo o que voc√™ realmente deseja do sistema de tipos.  Perder nos dois casos. <br><br>  A especializa√ß√£o e o desenvolvimento restritos de amadores andam de m√£os dadas.  Muitas das especifica√ß√µes pareciam aparafusadas no √∫ltimo momento - e obviamente estavam aparafusadas no √∫ltimo momento.  Algumas restri√ß√µes o for√ßar√£o a parar, co√ßar a cabe√ßa e perguntar: "Que diabos?"  Mas estes s√£o apenas sintomas de um problema mais profundo: <br><br>  Obviamente, protobuffers s√£o criados por amadores porque oferecem solu√ß√µes ruins para problemas conhecidos e j√° resolvidos. <br><br><h1>  Falta de composi√ß√£o </h1><br>  Os protobuffers oferecem v√°rios recursos que n√£o funcionam entre si.  Por exemplo, veja a lista de fun√ß√µes de digita√ß√£o ortogonais, mas ao mesmo tempo limitadas que encontrei na documenta√ß√£o. <br><br><ul><li> <code>oneof</code> campos n√£o pode ser <code>repeated</code> . </li><li>  O <code>map&lt;k,v&gt;</code> campos <code>map&lt;k,v&gt;</code> possui uma sintaxe especial para chaves e valores, mas n√£o √© usado em nenhum outro tipo. </li><li>  Embora os campos do <code>map</code> possam ser parametrizados, nenhum tipo definido pelo usu√°rio √© permitido mais.  Isso significa que voc√™ est√° impedido de especificar manualmente suas pr√≥prias especializa√ß√µes em estruturas de dados comuns. </li><li>  <code>map</code> campos do <code>map</code> n√£o podem ser <code>repeated</code> . </li><li>  <code>map</code> chaves do <code>map</code> <i>podem</i> ser <code>string</code> , mas <i>n√£o</i> <code>bytes</code> .  O enum tamb√©m √© proibido, embora este √∫ltimo seja considerado equivalente a n√∫meros inteiros em todas as outras partes da especifica√ß√£o Protobuffers. </li><li>  <code>map</code> valores do <code>map</code> n√£o podem ser outro <code>map</code> . </li></ul><br>  Esta lista maluca de restri√ß√µes √© o resultado de uma escolha sem princ√≠pios de fun√ß√µes de projeto e aparafusamento no √∫ltimo momento.  Por exemplo, <code>oneof</code> campos n√£o pode ser <code>repeated</code> , porque, em vez de um tipo lateral, o gerador de c√≥digo produzir√° campos opcionais mutuamente exclusivos.  Essa transforma√ß√£o √© v√°lida apenas para um campo singular (e, como veremos mais adiante, n√£o funciona nem para ele). <br><br>  A restri√ß√£o dos campos do <code>map</code> , que n√£o pode ser <code>repeated</code> , √© aproximadamente da mesma √≥pera, mas mostra uma restri√ß√£o diferente do sistema de tipos.  Nos bastidores, o <code>map&lt;k,v&gt;</code> transforma em algo semelhante ao <code>repeated Pair&lt;k,v&gt;</code> .  E como <code>repeated</code> √© a palavra-chave m√°gica do idioma, e n√£o o tipo normal, ela n√£o se combina consigo mesma. <br><br>  Suas suposi√ß√µes sobre o problema com <code>enum</code> s√£o t√£o verdadeiras quanto as minhas. <br><br>  O que √© t√£o frustrante sobre tudo isso √© uma compreens√£o insuficiente de como os sistemas de tipos modernos funcionam.  Esse entendimento <i>simplificaria drasticamente a</i> especifica√ß√£o dos Protobuffers e ao mesmo tempo <i>removeria todas as restri√ß√µes arbitr√°rias</i> . <br><br>  A solu√ß√£o √© a seguinte: <br><br><ul><li>  Fa√ßa todos os campos na mensagem <code>required</code> .  Isso torna cada mensagem <i>um</i> tipo de produto. </li><li>  Aumente o valor do campo <code>oneof</code> para tipos de dados independentes.  Este ser√° um tipo de coproduto. </li><li>  Permitir a parametriza√ß√£o de tipos de produtos e coprodutos de outros tipos. </li></ul><br>  Isso √© tudo!  Essas tr√™s altera√ß√µes s√£o tudo o que voc√™ precisa para determinar quaisquer dados poss√≠veis.  Com este sistema simples, voc√™ pode refazer todas as outras especifica√ß√µes dos Protobuffers. <br><br>  Por exemplo, voc√™ pode refazer os campos <code>optional</code> : <br><br><pre> <code class="hljs pgsql">product Unit { // <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> fields } coproduct Optional&lt;t&gt; { t <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; Unit unset = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Criar campos <code>repeated</code> tamb√©m √© simples: <br><br><pre> <code class="hljs php">coproduct <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;t&gt; { Unit <span class="hljs-keyword"><span class="hljs-keyword">empty</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; Pair&lt;t, <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;t&gt;&gt; cons = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Obviamente, a l√≥gica real da serializa√ß√£o permite que voc√™ fa√ßa algo mais inteligente do que enviar listas vinculadas pela rede - afinal, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">implementa√ß√£o e a sem√¢ntica n√£o precisam corresponder uma √† outra</a> . <br><br><h1>  Escolha duvidosa </h1><br>  Os protobuffers no estilo Java distinguem entre os tipos <i>escalar</i> e de <i>mensagem</i> .  Os escalares correspondem mais ou menos √†s primitivas da m√°quina - coisas como <code>int32</code> , <code>bool</code> e <code>string</code> .  Por outro lado, os tipos de mensagens s√£o o restante.  Todos os tipos de biblioteca e usu√°rio s√£o mensagens. <br><br>  Obviamente, os dois tipos de tipos t√™m sem√¢nticas completamente diferentes. <br><br>  Campos com tipos escalares est√£o sempre presentes.  Mesmo se voc√™ n√£o os instalou.  Eu j√° disse isso (pelo menos no proto3 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><sup>1</sup></a> <a name="1_1"></a>  ) s√£o todos os proto-buffers inicializados em zeros, mesmo se eles n√£o tiverem absolutamente nenhum dado?  Os campos escalares obt√™m valores falsos: por exemplo, <code>uint32</code> inicializado com <code>0</code> e <code>string</code> inicializada com <code>""</code> . <br><br>  N√£o √© poss√≠vel distinguir um campo que n√£o estava no proto-buffer de um campo ao qual √© atribu√≠do um valor padr√£o.  Presumivelmente, essa decis√£o foi tomada para otimiza√ß√£o, a fim de n√£o encaminhar padr√µes escalares.  Isso √© apenas uma suposi√ß√£o, porque a documenta√ß√£o n√£o menciona essa otimiza√ß√£o, portanto, sua suposi√ß√£o n√£o ser√° pior que a minha. <br><br>  Quando discutirmos as reivindica√ß√µes do Protobuffers de uma solu√ß√£o ideal para compatibilidade com vers√µes anteriores e futuras da API, veremos que essa incapacidade de distinguir entre valores indefinidos e padr√£o √© um pesadelo real.  Especialmente se for realmente uma decis√£o consciente de economizar um bit (definido ou n√£o) para o campo. <br><br>  Compare esse comportamento com os tipos de mensagem.  Enquanto os campos escalares s√£o "burros", o comportamento dos campos de mensagens √© completamente <i>insano</i> .  Internamente, os campos da mensagem est√£o l√° ou n√£o, mas o comportamento √© louco.  Um pequeno pseudoc√≥digo para seu acessador vale mais que mil palavras.  Imagine isso em Java ou em outro lugar: <br><br><pre> <code class="hljs pgsql">private Foo m_foo; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Foo foo { // <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> `foo` <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> used <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> an expression <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_foo != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_foo; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Foo(); } // <span class="hljs-keyword"><span class="hljs-keyword">instead</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> `foo` <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> used <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> an lvalue mutable <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_foo = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) m_foo = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Foo(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_foo; } }</code> </pre> <br>  Em teoria, se o campo <code>foo</code> n√£o estiver definido, voc√™ ver√° uma c√≥pia inicializada padr√£o, solicitada ou n√£o, mas n√£o poder√° alterar o cont√™iner.  Mas se voc√™ mudar de posi√ß√£o, tamb√©m mudar√° seu pai!  Tudo isso √© apenas para evitar o uso do tipo <code>Maybe Foo</code> e sua "dor de cabe√ßa" associada para descobrir o que um valor indefinido deve significar. <br><br>  Esse comportamento √© particularmente flagrante porque viola a lei!  Esperamos o trabalho <code>msg.foo = msg.foo;</code>  n√£o vai funcionar.  Em vez disso, a implementa√ß√£o muda silenciosamente a <code>msg</code> para uma c√≥pia do <code>foo</code> com inicializa√ß√£o zero, se ela n√£o existia antes. <br><br>  Ao contr√°rio dos campos escalares, pelo menos voc√™ pode determinar que o campo da mensagem n√£o est√° definido.  As liga√ß√µes de idioma para protobuffers oferecem algo como o m√©todo <code>bool has_foo()</code> gerado.  Se estiver presente, no caso de c√≥pias frequentes do campo de mensagem de um protobuffer para outro, voc√™ deve escrever o seguinte c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (src.has_foo(src)) { dst.set_foo(src.foo()); }</code> </pre> <br>  Observe que, pelo menos em idiomas com digita√ß√£o est√°tica, este modelo <i>n√£o pode ser abstra√≠do</i> devido √† rela√ß√£o nominal entre os <code>has_foo()</code> <code>foo()</code> , <code>set_foo()</code> e <code>has_foo()</code> .  Como todas essas fun√ß√µes s√£o seus pr√≥prios <i>identificadores</i> , n√£o temos como ger√°-las programaticamente, com exce√ß√£o da macro do pr√©-processador: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> COPY_IFF_SET(src, dst, field) \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (src.has_##field(src)) { \ dst.set_##field(src.field()); \ }</span></span></code> </pre> <br>  (mas as macros de pr√©-processador s√£o proibidas pelo guia de estilo do Google). <br><br>  Se, em vez disso, todos os campos adicionais foram implementados como <code>Maybe</code> , voc√™ pode definir com seguran√ßa os pontos de discagem abstratos. <br><br>  Para mudar de assunto, vamos falar sobre outra decis√£o duvidosa.  Embora voc√™ possa definir um dos campos nos <code>oneof</code> , a sem√¢ntica deles <i>n√£o corresponde ao</i> tipo de co-produto!  Novato erro pessoal!  Em vez disso, voc√™ obt√©m um campo opcional para cada caso e c√≥digo m√°gico nos setters, que simplesmente desfar√£o qualquer outro campo, se definido. <br><br>  √Ä primeira vista, parece que isso deve ser semanticamente equivalente ao tipo correto de uni√£o.  Mas, em vez disso, temos uma fonte de erro nojenta e indescrit√≠vel!  Quando esse comportamento √© combinado com uma implementa√ß√£o ilegal <code>msg.foo = msg.foo;</code>  , uma atribui√ß√£o aparentemente normal exclui silenciosamente quantidades arbitr√°rias de dados! <br><br>  Como resultado, isso significa que <code>oneof</code> campos n√£o forma <code>Prism</code> cumpridor da lei e as mensagens n√£o formam <code>Lens</code> cumpridor da lei.  Boa sorte com suas tentativas de escrever manipula√ß√µes n√£o triviais de protobuffer sem erros.  <i>√â literalmente imposs√≠vel escrever um c√≥digo polim√≥rfico universal, livre de erros em protobuffers</i> . <br><br>  Isso n√£o √© muito agrad√°vel de ouvir, especialmente para aqueles que amam o polimorfismo param√©trico, que <i>promete exatamente o oposto</i> . <br><br><h1>  Compatibilidade com vers√µes anteriores e futuras </h1><br>  Um dos "recursos matadores" frequentemente mencionados dos Protobuffers √© sua "capacidade sem problemas de escrever APIs compat√≠veis com vers√µes anteriores e posteriores".  Esta declara√ß√£o foi colocada diante de seus olhos para obscurecer a verdade. <br><br>  Que protobuffers s√£o <i>permissivos</i> .  Eles conseguem lidar com mensagens do passado ou do futuro, porque n√£o fazem absolutamente nenhuma promessa sobre a apar√™ncia dos seus dados.  Tudo √© opcional!  Mas se voc√™ precisar, os Protobuffers ter√£o prazer em preparar e fornecer algo com a verifica√ß√£o de tipo, independentemente de fazer sentido. <br><br>  Isso significa que os Protobuffers realizam a "viagem no tempo" prometida, enquanto <i>fazem silenciosamente a coisa errada por padr√£o</i> .  Obviamente, um programador cuidadoso pode (e deve) escrever um c√≥digo que verifique a corre√ß√£o dos protobuffers recebidos.  Mas se voc√™ fizer verifica√ß√µes de corre√ß√£o de prote√ß√£o em todos os sites, talvez isso signifique apenas que a etapa de desserializa√ß√£o foi muito permissiva.  Tudo o que voc√™ conseguiu fazer foi descentralizar a l√≥gica da valida√ß√£o de um limite bem definido e borr√°-la em toda a base de c√≥digo. <br><br>  Um dos argumentos poss√≠veis √© que os protobuffers salvam qualquer informa√ß√£o que eles n√£o entendam na mensagem.  Em princ√≠pio, isso significa transmiss√£o n√£o destrutiva da mensagem atrav√©s de um intermedi√°rio que n√£o entende esta vers√£o do esquema.  Esta √© uma vit√≥ria clara, n√£o √©? <br><br>  Obviamente, no papel, esse √© um recurso interessante.  Mas nunca vi um aplicativo em que essa propriedade esteja realmente armazenada.  Com exce√ß√£o do software de roteamento, nenhum programa deseja verificar apenas determinados bits de uma mensagem e encaminh√°-la inalterada.  A grande maioria dos programas em protobuffers decodificar√° a mensagem, a transformar√° em outra e a enviar√° para outro local.  Infelizmente, essas convers√µes s√£o feitas por ordem e codificadas manualmente.  E as convers√µes manuais de um protobuffer para outro n√£o preservam campos desconhecidos, porque √© literalmente in√∫til. <br><br>  Essa atitude onipresente em rela√ß√£o aos proto-bufferes como universalmente compat√≠vel tamb√©m se manifesta de outras maneiras feias.  Os guias de estilo para protobuffers se op√µem ativamente a DRY e sugerem incorporar defini√ß√µes no c√≥digo sempre que poss√≠vel.  Eles argumentam que isso permitir√° o uso de mensagens separadas no futuro se as defini√ß√µes divergirem.  Enfatizo que eles oferecem abandonar a pr√°tica de 60 anos de boa programa√ß√£o <i>para o caso de</i> , de repente, em algum momento no futuro, voc√™ precisar alterar alguma coisa. <br><br>  A raiz do problema √© que o Google combina o significado dos dados com sua representa√ß√£o f√≠sica.  Quando voc√™ est√° em uma escala do Google, isso faz sentido.  No final, eles t√™m uma ferramenta interna que compara o pagamento por hora do programador usando a rede, o custo de armazenamento de bytes X e outras coisas.  Diferentemente da maioria das empresas de tecnologia, o sal√°rio dos programadores √© um dos menores itens de despesas do Google.  Financeiramente, faz sentido que eles gastem o tempo dos programadores para economizar alguns bytes. <br><br>  Al√©m das cinco principais empresas de tecnologia, ningu√©m mais est√° dentro das cinco ordens de grandeza do Google.  Sua inicializa√ß√£o <i>n√£o pode</i> gastar horas de engenharia economizando bytes.  Mas economizar bytes e desperdi√ßar o tempo dos programadores no processo √© exatamente para o que os protobuffers s√£o otimizados. <br><br>  Vamos enfrent√°-lo.  Voc√™ n√£o se ajusta √† escala do Google e nunca se encaixa.  Pare de usar o culto √† carga da tecnologia apenas porque "o Google usa" e porque "essas s√£o as melhores pr√°ticas do setor". <br><br><h1>  Protobuffers poluem bases de c√≥digo </h1><br>  Se fosse poss√≠vel limitar o uso de protobuffers apenas √† rede, eu n√£o falaria t√£o severamente sobre essa tecnologia.  Infelizmente, embora em princ√≠pio existam v√°rias solu√ß√µes, nenhuma delas √© boa o suficiente para ser usada em software real. <br><br>  Os protobuffers correspondem aos dados que voc√™ deseja enviar pelo canal de comunica√ß√£o.  Eles geralmente s√£o <i>consistentes</i> , mas n√£o <i>id√™nticos</i> , com os dados reais com os quais o aplicativo gostaria de trabalhar.  Isso nos coloca em uma posi√ß√£o desconfort√°vel; voc√™ deve escolher entre uma das tr√™s m√°s op√ß√µes: <br><br><ol><li>  Mantenha um tipo separado que descreva os dados realmente necess√°rios e garanta que ambos os tipos sejam suportados simultaneamente. </li><li>  Empacote os dados completos em um formato para transmiss√£o e uso pelo aplicativo. </li><li>  Recupere dados completos sempre que necess√°rio, no formato curto de transmiss√£o. </li></ol><br>  A op√ß√£o 1 √© claramente a solu√ß√£o "certa", mas n√£o √© adequada para protobuffers.  O idioma n√£o √© poderoso o suficiente para codificar tipos que podem funcionar duas vezes em dois formatos.  Isso significa que voc√™ precisa escrever um tipo de dados completamente separado, desenvolv√™-lo de forma s√≠ncrona com os Protobuffers e <i>escrever especificamente um c√≥digo de serializa√ß√£o para eles</i> .  Mas como a maioria das pessoas parece usar Protobuffers para n√£o escrever c√≥digo de serializa√ß√£o, essa op√ß√£o obviamente nunca √© implementada. <br><br>  Em vez disso, o c√≥digo usando protobuffers permite que eles sejam distribu√≠dos por toda a base de c√≥digo.  √â uma realidade.  Meu projeto principal no Google foi um compilador que pegou um "programa" escrito em uma varia√ß√£o de Protobuffers e produziu um "programa" equivalente em outra.  Os formatos de entrada e sa√≠da eram bem diferentes para que suas vers√µes paralelas corretas do C ++ nunca funcionassem.  Como resultado, meu c√≥digo n√£o p√¥de usar nenhuma das t√©cnicas avan√ßadas de escrita do compilador, porque os dados do Protobuffers (e o c√≥digo gerado) eram muito dif√≠ceis de fazer algo interessante com eles. <br><br>  Como resultado, em vez de 50 linhas de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esquemas</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">recurs√£o</a> , 10.000 linhas de embaralhamento de buffer especial foram usadas.  O c√≥digo que eu queria escrever era literalmente imposs√≠vel com proto-buffers. <br><br>  Embora este seja um caso, n√£o √© √∫nico.  Devido √† natureza severa da gera√ß√£o de c√≥digo, as manifesta√ß√µes de proto-buffers em idiomas nunca ser√£o idiom√°ticas e n√£o podem ser feitas - a menos que voc√™ reescreva o gerador de c√≥digo. <br><br>  Mas, mesmo assim, voc√™ ainda tem um problema ao incorporar um sistema de baixa qualidade no idioma de destino.  Como a maioria das fun√ß√µes dos Protobuffers √© mal pensada, essas propriedades duvidosas vazam para nossas bases de c√≥digo.  Isso significa que somos for√ßados a n√£o apenas implementar, mas tamb√©m usar essas m√°s id√©ias em qualquer projeto que espere interagir com os Protobuffers. <br><br>  Em uma base s√≥lida, √© f√°cil perceber coisas sem sentido, mas se voc√™ for em outra dire√ß√£o, na melhor das hip√≥teses, encontrar√° dificuldades e, na pior das hip√≥teses, com verdadeiro horror antigo. <br><br>  Em geral, desista da esperan√ßa de quem implementa Protobuffers em seus projetos. <br><br><hr><br><a name="1"></a>  1. At√© hoje, h√° uma discuss√£o acalorada no Google sobre proto2 e se os campos devem ser marcados conforme <code>required</code> .  Os manifestos ‚Äú <code>optional</code> √© considerado prejudicial‚Äù <i>e</i> ‚Äú <code>required</code> considerados prejudiciais‚Äù s√£o distribu√≠dos ao mesmo tempo.  Boa sorte, descubra, pessoal.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">‚Üë</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt427265/">https://habr.com/ru/post/pt427265/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt427253/index.html">typeof Tudo e mal-entendidos pato</a></li>
<li><a href="../pt427255/index.html">Cowon D2: f√≠gado longo musical</a></li>
<li><a href="../pt427257/index.html">Cameron Craig: Sete li√ß√µes aprendidas em 10 anos de gerenciamento de rela√ß√µes p√∫blicas da Apple</a></li>
<li><a href="../pt427259/index.html">O que o Teste de Turing realmente verifica</a></li>
<li><a href="../pt427263/index.html">Seja um ninja de seguran√ßa: grava√ß√£o de webinar e n√≠vel de b√¥nus</a></li>
<li><a href="../pt427267/index.html">SNMP + Java - experi√™ncia pessoal. Escrevendo um analisador de arquivos MIB</a></li>
<li><a href="../pt427269/index.html">V√≠deo do Google OKR cinco anos depois - uma revis√£o da experi√™ncia do Google Ventures na implementa√ß√£o do OKR (2012-2017)</a></li>
<li><a href="../pt427271/index.html">Hist√≥ria e experi√™ncia do uso de tradu√ß√£o autom√°tica. Palestra Yandex</a></li>
<li><a href="../pt427273/index.html">A intelig√™ncia artificial pode deixar as casas de apostas sem trabalho?</a></li>
<li><a href="../pt427275/index.html">Arquitetura de informa√ß√µes da Internet, parte 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>