<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚀 🍖 💪🏾 Como o código de barras é organizado? 🔪 🕡 💇🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá Habr! 

 Uma pessoa moderna encontra códigos de barras todos os dias, sem sequer pensar nisso. Quando compramos produtos no supermercado, seus cód...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como o código de barras é organizado?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439604/">  Olá Habr! <br><br>  Uma pessoa moderna encontra códigos de barras todos os dias, sem sequer pensar nisso.  Quando compramos produtos no supermercado, seus códigos são lidos precisamente com a ajuda de um código de barras.  Também encomendas, mercadorias em armazéns e assim por diante.  No entanto, poucas pessoas sabem como isso realmente funciona. <br><br>  Como o código de barras é organizado e o que é codificado nesta figura? <br><br><img src="https://habrastorage.org/webt/zg/gi/wt/zggiwtxnuelznl9cq6u9jzcio5m.jpeg"><br><br>  Vamos tentar descobrir, ao mesmo tempo, escreveremos um decodificador desses códigos. <a name="habracut"></a><br><br><h2>  1. Introdução </h2><br>  O uso de códigos de barras tem uma longa história.  As primeiras tentativas de automação começaram nos anos 50; uma patente para um leitor de código foi obtida em 1952.  O engenheiro envolvido na triagem de carros na estrada de ferro queria simplificar o processo.  A idéia era óbvia - codificar o número usando tiras e lê-las usando fotocélulas.  Em 1962, os códigos começaram a ser oficialmente usados ​​para identificar carros nas ferrovias americanas (sistema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">KarTrak</a> ). Em 1968, o holofote foi substituído por um raio laser, o que aumentou a precisão e reduziu o tamanho do leitor.  Em 1973, o formato “Universal Product Code” apareceu e, em 1974, o primeiro produto foi vendido usando um scanner de código (a goma de mascar da Wrigley são os Estados Unidos;) em um supermercado.  Em 1984, um terço das lojas usavam serpentinas, mas na Rússia começaram a ser usadas nos anos 90. <br><br>  Muitos códigos diferentes são usados ​​para tarefas diferentes, por exemplo, a sequência "12345678" pode ser representada de tais maneiras (e isso não é tudo): <br><br><img src="https://habrastorage.org/webt/gf/uo/ef/gfuoefu3nglocmhctpw_z8ivbpe.png"><br><br>  Vamos começar a análise bit a bit.  Além disso, tudo descrito abaixo se refere ao formulário “Code-128” - simplesmente porque seu formato é bastante simples e direto.  Aqueles que desejam experimentar outras espécies podem abrir um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">gerador on</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">line</a> e ver por si mesmos. <br><br>  À primeira vista, o código de barras parece ser apenas uma sequência aleatória de linhas; de fato, sua estrutura é claramente fixa: <br><br><img src="https://habrastorage.org/webt/rx/ag/qf/rxagqfppyrtszrl7ldjku2lekg8.jpeg"><br><br>  1 - Espaço vazio necessário para identificar claramente o início do código <br>  2 - Iniciar símbolo.  Para o Código 128, são possíveis três opções (chamadas A, B e C): 11010000100, 11010010000 ou 11010011100, elas correspondem a diferentes tabelas de códigos (mais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">na Wikipedia</a> ). <br>  3 - Na verdade, o código que contém os dados que precisamos <br>  4 - soma de verificação <br>  5 - Pare o símbolo.  Para o Code-128, é 1100011101011. <br>  6 (1) - espaço vazio. <br><br>  Agora, sobre como os bits são codificados.  Tudo é muito simples aqui - se você considerar a largura da linha mais fina como "1", a linha de largura dupla fornecerá o código "11", um "111" triplo e assim por diante.  O espaço vazio será "0" ou "00" ou "000" de acordo com o mesmo princípio.  Quem desejar pode comparar o código de início na imagem para garantir que a regra seja cumprida. <br><br>  Agora você pode começar a programar. <br><br><h2>  Obter a sequência de bits </h2><br>  Em princípio, esta é a parte mais difícil e, é claro, algoritmicamente, pode ser implementada de maneiras diferentes.  Não tenho certeza de que o algoritmo abaixo seja ideal, mas é o suficiente para um estudo de caso. <br><br>  Para começar, carregue a imagem, estique-a em largura, pegue uma linha horizontal no meio da imagem, converta-a em preto e branco e carregue-a como uma matriz. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt image_path = <span class="hljs-string"><span class="hljs-string">"barcode.jpg"</span></span> img = Image.open(image_path) width, height = img.size basewidth = <span class="hljs-number"><span class="hljs-number">4</span></span>*width img = img.resize((basewidth, height), Image.ANTIALIAS) hor_line_bw = img.crop((<span class="hljs-number"><span class="hljs-number">0</span></span>, int(height/<span class="hljs-number"><span class="hljs-number">2</span></span>), basewidth, int(height/<span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>)).convert(<span class="hljs-string"><span class="hljs-string">'L'</span></span>) hor_data = np.asarray(hor_line_bw, dtype=<span class="hljs-string"><span class="hljs-string">"int32"</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br>  No código de barras, “1” corresponde a preto e, em RGB, pelo contrário, 0, portanto, a matriz deve ser invertida.  Ao mesmo tempo, calculamos o valor médio. <br><br><pre> <code class="python hljs">hor_data = <span class="hljs-number"><span class="hljs-number">255</span></span> - hor_data avg = np.average(hor_data) plt.plot(hor_data) plt.show()</code> </pre><br>  Iniciamos o programa para garantir que o código de barras esteja carregado corretamente: <br><br><img src="https://habrastorage.org/webt/8z/jp/po/8zjppozs3lgketrraqtqeuzgj8g.jpeg"><br><br>  Agora você precisa determinar a largura de um "bit".  Para isso, destacamos o início da sequência inicial "1101", registrando os momentos de transição do gráfico pela linha do meio. <br><br><pre> <code class="python hljs">pos1, pos2 = <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span> bits = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(basewidth - <span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &lt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; avg: bits += <span class="hljs-string"><span class="hljs-string">"1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pos1 == <span class="hljs-number"><span class="hljs-number">-1</span></span>: pos1 = p <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bits == <span class="hljs-string"><span class="hljs-string">"101"</span></span>: pos2 = p <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &gt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; avg: bits += <span class="hljs-string"><span class="hljs-string">"0"</span></span> bit_width = int((pos2 - pos1)/<span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre><br>  Registramos apenas as transições no meio, para que o código "1101" seja escrito como "101", mas isso é suficiente para descobrirmos sua largura em pixels. <br><br>  Agora a decodificação real.  Encontramos a próxima transição pelo meio e determinamos o número de bits que caem no intervalo.  Como a correspondência não é absoluta (o código pode ser ligeiramente curvado ou esticado), usamos o arredondamento. <br><br><pre> <code class="python hljs">bits = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(basewidth - <span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &gt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; avg: interval = p - pos1 cnt = interval/bit_width bits += <span class="hljs-string"><span class="hljs-string">"1"</span></span>*int(round(cnt)) pos1 = p <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &lt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; avg: interval = p - pos1 cnt = interval/bit_width bits += <span class="hljs-string"><span class="hljs-string">"0"</span></span>*int(round(cnt)) pos1 = p</code> </pre><br>  Não tenho certeza se essa é a melhor opção, talvez exista uma maneira melhor, quem quiser pode escrever nos comentários. <br><br>  Se tudo foi feito corretamente, obtemos a seguinte sequência de saída: <br><br> <code>11010010000110001010001000110100010001101110100011011101000111011011 <br> 01100110011000101000101000110001000101100011000101110110011011001111 <br> 00010101100011101011</code> <br> <br><h2>  Decodificação </h2><br>  Aqui, em princípio, não há dificuldades.  Os caracteres no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Código 128</a> são codificados com um código de 11 bits, que possui três variedades (A, B e C) e pode armazenar codificações ou números diferentes de caracteres de 00 a 99. <br><br>  No nosso caso, o início da sequência é 11010010000, que corresponde ao "Código B".  Ele foi terrivelmente quebrado para conduzir manualmente todos os códigos da Wikipedia, portanto a tabela foi simplesmente copiada do navegador e sua análise também foi feita em Python (dica: isso não é necessário para a produção). <br><br><pre> <code class="python hljs"> CODE128_CHART = <span class="hljs-string"><span class="hljs-string">""" 0 _ _ 00 32 S 11011001100 212222 1 ! ! 01 33 ! 11001101100 222122 2 " " 02 34 " 11001100110 222221 3 # # 03 35 # 10010011000 121223 ... 93 GS } 93 125 } 10100011110 111341 94 RS ~ 94 126 ~ 10001011110 131141 103 Start Start A 208 SCA 11010000100 211412 104 Start Start B 209 SCB 11010010000 211214 105 Start Start C 210 SCC 11010011100 211232 106 Stop Stop - - - 11000111010 233111"""</span></span>.split() SYMBOLS = [value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> CODE128_CHART[<span class="hljs-number"><span class="hljs-number">6</span></span>::<span class="hljs-number"><span class="hljs-number">8</span></span>]] VALUESB = [value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> CODE128_CHART[<span class="hljs-number"><span class="hljs-number">2</span></span>::<span class="hljs-number"><span class="hljs-number">8</span></span>]] CODE128B = dict(zip(SYMBOLS, VALUESB))</code> </pre><br>  Agora a coisa mais simples permanece.  Dividimos nossa sequência de bits em blocos de 11 caracteres: <br><br><pre> <code class="python hljs">sym_len = <span class="hljs-number"><span class="hljs-number">11</span></span> symbols = [bits[i:i+sym_len] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(bits), sym_len)]</code> </pre><br>  Finalmente, formamos a linha e a exibimos na tela: <br><br><pre> <code class="python hljs">str_out = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> sym <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> symbols: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CODE128A[sym] == <span class="hljs-string"><span class="hljs-string">'Start'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CODE128A[sym] == <span class="hljs-string"><span class="hljs-string">'Stop'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> str_out += CODE128A[sym] print(<span class="hljs-string"><span class="hljs-string">" "</span></span>, sym, CODE128A[sym]) print(<span class="hljs-string"><span class="hljs-string">"Str:"</span></span>, str_out)</code> </pre><br>  Não darei a resposta para o que está codificado na tabela, que seja lição de casa para os leitores (usar programas prontos para smartphones será considerado trapaça). <br><br>  O código também não implementa a verificação CRC, aqueles que desejam podem fazer isso sozinhos. <br><br>  Obviamente, o algoritmo é imperfeito e foi escrito em meia hora.  Para fins mais profissionais, existem bibliotecas prontas, por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pyzbar</a> .  O código usando essa biblioteca terá apenas 4 linhas: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pyzbar.pyzbar <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> decode img = Image.open(image_path) decode = decode(img) print(decode)</code> </pre><br>  (primeiro você precisa instalar a biblioteca digitando o comando pip install pyzbar) <br><br>  <b>Adição</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">vinograd19</a> escreveu nos comentários sobre a contagem de CRC: <br><br>  <i>A história do dígito de verificação é interessante.</i>  <i>Surgiu evolutivamente.</i> <i><br></i>  <i>O dígito de verificação é necessário para evitar decodificação incorreta.</i>  <i>Se o código de barras era 1234 e foi reconhecido como 7234, você precisa de uma validação que impeça a substituição de 1 por 7. A validação pode ser imprecisa para que pelo menos 90% dos números inválidos sejam determinados com antecedência.</i> <i><br><br></i>  <i>1ª abordagem: vamos pegar a quantia.</i>  <i>Para que o restante da divisão por 10 seja 0. Bem, ou seja, os 12 primeiros caracteres carregam uma carga de informações e o último dígito é selecionado para que a soma dos dígitos seja dividida por 10. Decodifique a sequência, se a soma não for divisível por dez, significa decodificada com um erro e você precisa fazer isso mais uma vez.</i>  <i>Por exemplo, o código 1234 é válido.</i>  <i>1 + 2 + 3 + 4 = 10. O código 1216 também é válido, mas 1218 não é.</i> <i><br><br></i>  <i>Isso evita problemas com a automação.</i>  <i>No entanto, no momento da criação dos códigos de barras, houve um fallback na forma de digitar um número nas teclas.</i>  <i>E há um caso ruim: se você alterar a ordem dos dois dígitos, a soma de verificação não muda, e isso é ruim.</i>  <i>Ou seja, se o código de barras 1234 foi martelado como 2134, a soma de verificação convergirá, mas inserimos o número errado.</i>  <i>Acontece que a ordem errada dos números é um caso comum se você pressionar as teclas rapidamente.</i> <i><br><br></i>  <i>2ª abordagem.</i>  <i>Bem, vamos tornar a quantia um pouco mais complicada.</i>  <i>Para que os números em lugares pares sejam levados em consideração duas vezes.</i>  <i>Então, ao alterar a ordem, o valor definitivamente não convergirá para o desejado.</i>  <i>Por exemplo, o código 2364 é válido (2 + 3 + 3 + 6 + 4 + 4 = 20) e o código 3264 é inválido (3+ 2 + 2 + 6 + 4 + 4 = 19).</i>  <i>Mas aqui estava outro exemplo ruim de dirigir.</i>  <i>Alguns teclados são de tal ordem que dez dígitos são organizados em duas linhas.</i>  <i>a primeira linha é 12345 e, abaixo dela, a segunda segunda linha é 67890. Se, em vez da tecla "1", pressione a tecla "2" à direita, a soma de verificação impedirá a entrada incorreta.</i>  <i>Mas se, em vez da tecla "1", pressione a tecla "6" abaixo, ela poderá não avisar.</i>  <i>Afinal, 6 = 1 + 5, e no caso em que esse número esteja em um local par ao calcular a soma de verificação, temos 2 * 6 = 2 * 1 + 2 * 5.</i>  <i>Ou seja, a soma de verificação aumentou exatamente 10, portanto, seu último dígito não foi alterado.</i>  <i>Por exemplo, as somas de verificação nos códigos 2134 e 2634 são iguais.</i>  <i>O mesmo erro ocorrerá se pressionarmos 7 em vez de 2, em vez de 3, pressionar 8 e assim por diante.</i> <i><br><br></i>  <i>3ª abordagem.</i>  <i>Ok, vamos pegar a soma novamente, apenas os números em lugares pares serão levados em conta ... três vezes.</i>  <i>Ou seja, o código 1234565 é válido, porque 1 + 2 * 3 + 3 + 4 * 3 + 5 + 6 * 3 +5 = 50.</i> <i><br><br></i>  <i>O método descrito tornou-se o padrão para o cálculo da soma de verificação EAN13 com algumas correções: o número de dígitos tornou-se fixo e igual a 13, onde o 13º é a mesma soma de verificação.</i>  <i>Os números em lugares ímpares são contados três vezes, nos pares - uma vez.</i> <br><br><h2>  Conclusão </h2><br>  Como você pode ver, mesmo uma coisa simples como um código de barras tem muitas coisas interessantes.  A propósito, outro truque para quem já leu até aqui - o texto sob o código de barras (se houver) duplica completamente seu conteúdo.  Isso é feito para que, em caso de código ilegível, o operador possa digitá-lo manualmente.  Portanto, para descobrir o conteúdo de um código de barras geralmente é simples - basta olhar para o texto abaixo. <br><br>  Como sugerido nos comentários, o mais popular no comércio é o código EAN-13, a codificação de bits é a mesma, e aqueles que desejam podem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ver a</a> estrutura <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dos</a> caracteres. <br><br>  Se os leitores não perderem o interesse, considere os códigos QR separadamente. <br><br>  Obrigado pela atenção. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt439604/">https://habr.com/ru/post/pt439604/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt439594/index.html">Anotações da Primavera: AOP Magic</a></li>
<li><a href="../pt439596/index.html">Como acelerei o processamento de imagens no Android 15 vezes</a></li>
<li><a href="../pt439598/index.html">A Microsoft falou sobre o custo do suporte pago para o Windows 7</a></li>
<li><a href="../pt439600/index.html">Finlândia resume resultados preliminares de experimentos com renda básica garantida</a></li>
<li><a href="../pt439602/index.html">Ética no espaço digital - as regras básicas das relações digitais internacionais</a></li>
<li><a href="../pt439606/index.html">Produção piloto de eletrônicos por um preço mínimo</a></li>
<li><a href="../pt439608/index.html">Religião moderna: o que as pessoas dão ao Google, Facebook, Amazon e Apple?</a></li>
<li><a href="../pt439610/index.html">Como no meu veículo elétrico Chevrolet Bolt, na garantia, dois módulos de bateria foram substituídos e o terceiro sob monitoramento</a></li>
<li><a href="../pt439612/index.html">JavaScript robusto: perseguindo um mito</a></li>
<li><a href="../pt439614/index.html">Como distinguir um reparo bom de um reparo ruim, ou como no SRG criamos uma biblioteca Java multiencadeada a partir do analisador Tomit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>