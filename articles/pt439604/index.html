<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöÄ üçñ üí™üèæ Como o c√≥digo de barras √© organizado? üî™ üï° üíáüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° Habr! 

 Uma pessoa moderna encontra c√≥digos de barras todos os dias, sem sequer pensar nisso. Quando compramos produtos no supermercado, seus c√≥d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como o c√≥digo de barras √© organizado?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439604/">  Ol√° Habr! <br><br>  Uma pessoa moderna encontra c√≥digos de barras todos os dias, sem sequer pensar nisso.  Quando compramos produtos no supermercado, seus c√≥digos s√£o lidos precisamente com a ajuda de um c√≥digo de barras.  Tamb√©m encomendas, mercadorias em armaz√©ns e assim por diante.  No entanto, poucas pessoas sabem como isso realmente funciona. <br><br>  Como o c√≥digo de barras √© organizado e o que √© codificado nesta figura? <br><br><img src="https://habrastorage.org/webt/zg/gi/wt/zggiwtxnuelznl9cq6u9jzcio5m.jpeg"><br><br>  Vamos tentar descobrir, ao mesmo tempo, escreveremos um decodificador desses c√≥digos. <a name="habracut"></a><br><br><h2>  1. Introdu√ß√£o </h2><br>  O uso de c√≥digos de barras tem uma longa hist√≥ria.  As primeiras tentativas de automa√ß√£o come√ßaram nos anos 50; uma patente para um leitor de c√≥digo foi obtida em 1952.  O engenheiro envolvido na triagem de carros na estrada de ferro queria simplificar o processo.  A id√©ia era √≥bvia - codificar o n√∫mero usando tiras e l√™-las usando fotoc√©lulas.  Em 1962, os c√≥digos come√ßaram a ser oficialmente usados ‚Äã‚Äãpara identificar carros nas ferrovias americanas (sistema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">KarTrak</a> ). Em 1968, o holofote foi substitu√≠do por um raio laser, o que aumentou a precis√£o e reduziu o tamanho do leitor.  Em 1973, o formato ‚ÄúUniversal Product Code‚Äù apareceu e, em 1974, o primeiro produto foi vendido usando um scanner de c√≥digo (a goma de mascar da Wrigley s√£o os Estados Unidos;) em um supermercado.  Em 1984, um ter√ßo das lojas usavam serpentinas, mas na R√∫ssia come√ßaram a ser usadas nos anos 90. <br><br>  Muitos c√≥digos diferentes s√£o usados ‚Äã‚Äãpara tarefas diferentes, por exemplo, a sequ√™ncia "12345678" pode ser representada de tais maneiras (e isso n√£o √© tudo): <br><br><img src="https://habrastorage.org/webt/gf/uo/ef/gfuoefu3nglocmhctpw_z8ivbpe.png"><br><br>  Vamos come√ßar a an√°lise bit a bit.  Al√©m disso, tudo descrito abaixo se refere ao formul√°rio ‚ÄúCode-128‚Äù - simplesmente porque seu formato √© bastante simples e direto.  Aqueles que desejam experimentar outras esp√©cies podem abrir um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">gerador on</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">line</a> e ver por si mesmos. <br><br>  √Ä primeira vista, o c√≥digo de barras parece ser apenas uma sequ√™ncia aleat√≥ria de linhas; de fato, sua estrutura √© claramente fixa: <br><br><img src="https://habrastorage.org/webt/rx/ag/qf/rxagqfppyrtszrl7ldjku2lekg8.jpeg"><br><br>  1 - Espa√ßo vazio necess√°rio para identificar claramente o in√≠cio do c√≥digo <br>  2 - Iniciar s√≠mbolo.  Para o C√≥digo 128, s√£o poss√≠veis tr√™s op√ß√µes (chamadas A, B e C): 11010000100, 11010010000 ou 11010011100, elas correspondem a diferentes tabelas de c√≥digos (mais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">na Wikipedia</a> ). <br>  3 - Na verdade, o c√≥digo que cont√©m os dados que precisamos <br>  4 - soma de verifica√ß√£o <br>  5 - Pare o s√≠mbolo.  Para o Code-128, √© 1100011101011. <br>  6 (1) - espa√ßo vazio. <br><br>  Agora, sobre como os bits s√£o codificados.  Tudo √© muito simples aqui - se voc√™ considerar a largura da linha mais fina como "1", a linha de largura dupla fornecer√° o c√≥digo "11", um "111" triplo e assim por diante.  O espa√ßo vazio ser√° "0" ou "00" ou "000" de acordo com o mesmo princ√≠pio.  Quem desejar pode comparar o c√≥digo de in√≠cio na imagem para garantir que a regra seja cumprida. <br><br>  Agora voc√™ pode come√ßar a programar. <br><br><h2>  Obter a sequ√™ncia de bits </h2><br>  Em princ√≠pio, esta √© a parte mais dif√≠cil e, √© claro, algoritmicamente, pode ser implementada de maneiras diferentes.  N√£o tenho certeza de que o algoritmo abaixo seja ideal, mas √© o suficiente para um estudo de caso. <br><br>  Para come√ßar, carregue a imagem, estique-a em largura, pegue uma linha horizontal no meio da imagem, converta-a em preto e branco e carregue-a como uma matriz. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt image_path = <span class="hljs-string"><span class="hljs-string">"barcode.jpg"</span></span> img = Image.open(image_path) width, height = img.size basewidth = <span class="hljs-number"><span class="hljs-number">4</span></span>*width img = img.resize((basewidth, height), Image.ANTIALIAS) hor_line_bw = img.crop((<span class="hljs-number"><span class="hljs-number">0</span></span>, int(height/<span class="hljs-number"><span class="hljs-number">2</span></span>), basewidth, int(height/<span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>)).convert(<span class="hljs-string"><span class="hljs-string">'L'</span></span>) hor_data = np.asarray(hor_line_bw, dtype=<span class="hljs-string"><span class="hljs-string">"int32"</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br>  No c√≥digo de barras, ‚Äú1‚Äù corresponde a preto e, em RGB, pelo contr√°rio, 0, portanto, a matriz deve ser invertida.  Ao mesmo tempo, calculamos o valor m√©dio. <br><br><pre> <code class="python hljs">hor_data = <span class="hljs-number"><span class="hljs-number">255</span></span> - hor_data avg = np.average(hor_data) plt.plot(hor_data) plt.show()</code> </pre><br>  Iniciamos o programa para garantir que o c√≥digo de barras esteja carregado corretamente: <br><br><img src="https://habrastorage.org/webt/8z/jp/po/8zjppozs3lgketrraqtqeuzgj8g.jpeg"><br><br>  Agora voc√™ precisa determinar a largura de um "bit".  Para isso, destacamos o in√≠cio da sequ√™ncia inicial "1101", registrando os momentos de transi√ß√£o do gr√°fico pela linha do meio. <br><br><pre> <code class="python hljs">pos1, pos2 = <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span> bits = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(basewidth - <span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &lt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; avg: bits += <span class="hljs-string"><span class="hljs-string">"1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pos1 == <span class="hljs-number"><span class="hljs-number">-1</span></span>: pos1 = p <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bits == <span class="hljs-string"><span class="hljs-string">"101"</span></span>: pos2 = p <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &gt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; avg: bits += <span class="hljs-string"><span class="hljs-string">"0"</span></span> bit_width = int((pos2 - pos1)/<span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre><br>  Registramos apenas as transi√ß√µes no meio, para que o c√≥digo "1101" seja escrito como "101", mas isso √© suficiente para descobrirmos sua largura em pixels. <br><br>  Agora a decodifica√ß√£o real.  Encontramos a pr√≥xima transi√ß√£o pelo meio e determinamos o n√∫mero de bits que caem no intervalo.  Como a correspond√™ncia n√£o √© absoluta (o c√≥digo pode ser ligeiramente curvado ou esticado), usamos o arredondamento. <br><br><pre> <code class="python hljs">bits = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(basewidth - <span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &gt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; avg: interval = p - pos1 cnt = interval/bit_width bits += <span class="hljs-string"><span class="hljs-string">"1"</span></span>*int(round(cnt)) pos1 = p <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &lt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; avg: interval = p - pos1 cnt = interval/bit_width bits += <span class="hljs-string"><span class="hljs-string">"0"</span></span>*int(round(cnt)) pos1 = p</code> </pre><br>  N√£o tenho certeza se essa √© a melhor op√ß√£o, talvez exista uma maneira melhor, quem quiser pode escrever nos coment√°rios. <br><br>  Se tudo foi feito corretamente, obtemos a seguinte sequ√™ncia de sa√≠da: <br><br> <code>11010010000110001010001000110100010001101110100011011101000111011011 <br> 01100110011000101000101000110001000101100011000101110110011011001111 <br> 00010101100011101011</code> <br> <br><h2>  Decodifica√ß√£o </h2><br>  Aqui, em princ√≠pio, n√£o h√° dificuldades.  Os caracteres no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C√≥digo 128</a> s√£o codificados com um c√≥digo de 11 bits, que possui tr√™s variedades (A, B e C) e pode armazenar codifica√ß√µes ou n√∫meros diferentes de caracteres de 00 a 99. <br><br>  No nosso caso, o in√≠cio da sequ√™ncia √© 11010010000, que corresponde ao "C√≥digo B".  Ele foi terrivelmente quebrado para conduzir manualmente todos os c√≥digos da Wikipedia, portanto a tabela foi simplesmente copiada do navegador e sua an√°lise tamb√©m foi feita em Python (dica: isso n√£o √© necess√°rio para a produ√ß√£o). <br><br><pre> <code class="python hljs"> CODE128_CHART = <span class="hljs-string"><span class="hljs-string">""" 0 _ _ 00 32 S 11011001100 212222 1 ! ! 01 33 ! 11001101100 222122 2 " " 02 34 " 11001100110 222221 3 # # 03 35 # 10010011000 121223 ... 93 GS } 93 125 } 10100011110 111341 94 RS ~ 94 126 ~ 10001011110 131141 103 Start Start A 208 SCA 11010000100 211412 104 Start Start B 209 SCB 11010010000 211214 105 Start Start C 210 SCC 11010011100 211232 106 Stop Stop - - - 11000111010 233111"""</span></span>.split() SYMBOLS = [value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> CODE128_CHART[<span class="hljs-number"><span class="hljs-number">6</span></span>::<span class="hljs-number"><span class="hljs-number">8</span></span>]] VALUESB = [value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> CODE128_CHART[<span class="hljs-number"><span class="hljs-number">2</span></span>::<span class="hljs-number"><span class="hljs-number">8</span></span>]] CODE128B = dict(zip(SYMBOLS, VALUESB))</code> </pre><br>  Agora a coisa mais simples permanece.  Dividimos nossa sequ√™ncia de bits em blocos de 11 caracteres: <br><br><pre> <code class="python hljs">sym_len = <span class="hljs-number"><span class="hljs-number">11</span></span> symbols = [bits[i:i+sym_len] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(bits), sym_len)]</code> </pre><br>  Finalmente, formamos a linha e a exibimos na tela: <br><br><pre> <code class="python hljs">str_out = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> sym <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> symbols: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CODE128A[sym] == <span class="hljs-string"><span class="hljs-string">'Start'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CODE128A[sym] == <span class="hljs-string"><span class="hljs-string">'Stop'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> str_out += CODE128A[sym] print(<span class="hljs-string"><span class="hljs-string">" "</span></span>, sym, CODE128A[sym]) print(<span class="hljs-string"><span class="hljs-string">"Str:"</span></span>, str_out)</code> </pre><br>  N√£o darei a resposta para o que est√° codificado na tabela, que seja li√ß√£o de casa para os leitores (usar programas prontos para smartphones ser√° considerado trapa√ßa). <br><br>  O c√≥digo tamb√©m n√£o implementa a verifica√ß√£o CRC, aqueles que desejam podem fazer isso sozinhos. <br><br>  Obviamente, o algoritmo √© imperfeito e foi escrito em meia hora.  Para fins mais profissionais, existem bibliotecas prontas, por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pyzbar</a> .  O c√≥digo usando essa biblioteca ter√° apenas 4 linhas: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pyzbar.pyzbar <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> decode img = Image.open(image_path) decode = decode(img) print(decode)</code> </pre><br>  (primeiro voc√™ precisa instalar a biblioteca digitando o comando pip install pyzbar) <br><br>  <b>Adi√ß√£o</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">vinograd19</a> escreveu nos coment√°rios sobre a contagem de CRC: <br><br>  <i>A hist√≥ria do d√≠gito de verifica√ß√£o √© interessante.</i>  <i>Surgiu evolutivamente.</i> <i><br></i>  <i>O d√≠gito de verifica√ß√£o √© necess√°rio para evitar decodifica√ß√£o incorreta.</i>  <i>Se o c√≥digo de barras era 1234 e foi reconhecido como 7234, voc√™ precisa de uma valida√ß√£o que impe√ßa a substitui√ß√£o de 1 por 7. A valida√ß√£o pode ser imprecisa para que pelo menos 90% dos n√∫meros inv√°lidos sejam determinados com anteced√™ncia.</i> <i><br><br></i>  <i>1¬™ abordagem: vamos pegar a quantia.</i>  <i>Para que o restante da divis√£o por 10 seja 0. Bem, ou seja, os 12 primeiros caracteres carregam uma carga de informa√ß√µes e o √∫ltimo d√≠gito √© selecionado para que a soma dos d√≠gitos seja dividida por 10. Decodifique a sequ√™ncia, se a soma n√£o for divis√≠vel por dez, significa decodificada com um erro e voc√™ precisa fazer isso mais uma vez.</i>  <i>Por exemplo, o c√≥digo 1234 √© v√°lido.</i>  <i>1 + 2 + 3 + 4 = 10. O c√≥digo 1216 tamb√©m √© v√°lido, mas 1218 n√£o √©.</i> <i><br><br></i>  <i>Isso evita problemas com a automa√ß√£o.</i>  <i>No entanto, no momento da cria√ß√£o dos c√≥digos de barras, houve um fallback na forma de digitar um n√∫mero nas teclas.</i>  <i>E h√° um caso ruim: se voc√™ alterar a ordem dos dois d√≠gitos, a soma de verifica√ß√£o n√£o muda, e isso √© ruim.</i>  <i>Ou seja, se o c√≥digo de barras 1234 foi martelado como 2134, a soma de verifica√ß√£o convergir√°, mas inserimos o n√∫mero errado.</i>  <i>Acontece que a ordem errada dos n√∫meros √© um caso comum se voc√™ pressionar as teclas rapidamente.</i> <i><br><br></i>  <i>2¬™ abordagem.</i>  <i>Bem, vamos tornar a quantia um pouco mais complicada.</i>  <i>Para que os n√∫meros em lugares pares sejam levados em considera√ß√£o duas vezes.</i>  <i>Ent√£o, ao alterar a ordem, o valor definitivamente n√£o convergir√° para o desejado.</i>  <i>Por exemplo, o c√≥digo 2364 √© v√°lido (2 + 3 + 3 + 6 + 4 + 4 = 20) e o c√≥digo 3264 √© inv√°lido (3+ 2 + 2 + 6 + 4 + 4 = 19).</i>  <i>Mas aqui estava outro exemplo ruim de dirigir.</i>  <i>Alguns teclados s√£o de tal ordem que dez d√≠gitos s√£o organizados em duas linhas.</i>  <i>a primeira linha √© 12345 e, abaixo dela, a segunda segunda linha √© 67890. Se, em vez da tecla "1", pressione a tecla "2" √† direita, a soma de verifica√ß√£o impedir√° a entrada incorreta.</i>  <i>Mas se, em vez da tecla "1", pressione a tecla "6" abaixo, ela poder√° n√£o avisar.</i>  <i>Afinal, 6 = 1 + 5, e no caso em que esse n√∫mero esteja em um local par ao calcular a soma de verifica√ß√£o, temos 2 * 6 = 2 * 1 + 2 * 5.</i>  <i>Ou seja, a soma de verifica√ß√£o aumentou exatamente 10, portanto, seu √∫ltimo d√≠gito n√£o foi alterado.</i>  <i>Por exemplo, as somas de verifica√ß√£o nos c√≥digos 2134 e 2634 s√£o iguais.</i>  <i>O mesmo erro ocorrer√° se pressionarmos 7 em vez de 2, em vez de 3, pressionar 8 e assim por diante.</i> <i><br><br></i>  <i>3¬™ abordagem.</i>  <i>Ok, vamos pegar a soma novamente, apenas os n√∫meros em lugares pares ser√£o levados em conta ... tr√™s vezes.</i>  <i>Ou seja, o c√≥digo 1234565 √© v√°lido, porque 1 + 2 * 3 + 3 + 4 * 3 + 5 + 6 * 3 +5 = 50.</i> <i><br><br></i>  <i>O m√©todo descrito tornou-se o padr√£o para o c√°lculo da soma de verifica√ß√£o EAN13 com algumas corre√ß√µes: o n√∫mero de d√≠gitos tornou-se fixo e igual a 13, onde o 13¬∫ √© a mesma soma de verifica√ß√£o.</i>  <i>Os n√∫meros em lugares √≠mpares s√£o contados tr√™s vezes, nos pares - uma vez.</i> <br><br><h2>  Conclus√£o </h2><br>  Como voc√™ pode ver, mesmo uma coisa simples como um c√≥digo de barras tem muitas coisas interessantes.  A prop√≥sito, outro truque para quem j√° leu at√© aqui - o texto sob o c√≥digo de barras (se houver) duplica completamente seu conte√∫do.  Isso √© feito para que, em caso de c√≥digo ileg√≠vel, o operador possa digit√°-lo manualmente.  Portanto, para descobrir o conte√∫do de um c√≥digo de barras geralmente √© simples - basta olhar para o texto abaixo. <br><br>  Como sugerido nos coment√°rios, o mais popular no com√©rcio √© o c√≥digo EAN-13, a codifica√ß√£o de bits √© a mesma, e aqueles que desejam podem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ver a</a> estrutura <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dos</a> caracteres. <br><br>  Se os leitores n√£o perderem o interesse, considere os c√≥digos QR separadamente. <br><br>  Obrigado pela aten√ß√£o. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt439604/">https://habr.com/ru/post/pt439604/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt439594/index.html">Anota√ß√µes da Primavera: AOP Magic</a></li>
<li><a href="../pt439596/index.html">Como acelerei o processamento de imagens no Android 15 vezes</a></li>
<li><a href="../pt439598/index.html">A Microsoft falou sobre o custo do suporte pago para o Windows 7</a></li>
<li><a href="../pt439600/index.html">Finl√¢ndia resume resultados preliminares de experimentos com renda b√°sica garantida</a></li>
<li><a href="../pt439602/index.html">√âtica no espa√ßo digital - as regras b√°sicas das rela√ß√µes digitais internacionais</a></li>
<li><a href="../pt439606/index.html">Produ√ß√£o piloto de eletr√¥nicos por um pre√ßo m√≠nimo</a></li>
<li><a href="../pt439608/index.html">Religi√£o moderna: o que as pessoas d√£o ao Google, Facebook, Amazon e Apple?</a></li>
<li><a href="../pt439610/index.html">Como no meu ve√≠culo el√©trico Chevrolet Bolt, na garantia, dois m√≥dulos de bateria foram substitu√≠dos e o terceiro sob monitoramento</a></li>
<li><a href="../pt439612/index.html">JavaScript robusto: perseguindo um mito</a></li>
<li><a href="../pt439614/index.html">Como distinguir um reparo bom de um reparo ruim, ou como no SRG criamos uma biblioteca Java multiencadeada a partir do analisador Tomit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>